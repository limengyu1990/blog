<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        Dubbo源码阅读之服务暴露 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 不会Haskell的Scala写不出好的JavaScript。 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>不负如来不负卿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#ServiceConfig类变量"><span class="toc-text">ServiceConfig类变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ProxyFactory接口"><span class="toc-text">ProxyFactory接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#getInvoker方法"><span class="toc-text">getInvoker方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Wrapper包装类"><span class="toc-text">Wrapper包装类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#暴露到注册中心"><span class="toc-text">暴露到注册中心</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Protocol接口的export方法"><span class="toc-text">Protocol接口的export方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#暴露到本地"><span class="toc-text">暴露到本地</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 不会Haskell的Scala写不出好的JavaScript。 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Dubbo源码阅读之服务暴露
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2018-08-16 21:17:19</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/blog/tags/#dubbo" title="dubbo">dubbo</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p>本小节详细介绍dubbo服务的暴露，可以先看下之前的文章《Dubbo源码阅读之集成Spring(0201)》</p>
</blockquote>
<h3 id="ServiceConfig类变量"><a href="#ServiceConfig类变量" class="headerlink" title="ServiceConfig类变量"></a>ServiceConfig类变量</h3><p>在ServiceConfig类中定义了如下变量，下文中会用到，我们先简单看下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Protocol实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dubbo协议服务URL</span></span><br><span class="line"><span class="comment"> * 记录暴露的服务URL</span></span><br><span class="line"><span class="comment"> * dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;bind.ip=192.168.99.60&amp;bind.port=20880&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=4328&amp;qos.port=22222&amp;side=provider&amp;timestamp=1528278313225</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 记录暴露的服务端点</span></span><br><span class="line"><span class="comment"> * subscribeUrl = provider://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;category=configurators&amp;check=false&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=4328&amp;side=provider&amp;timestamp=1528278313225</span></span><br><span class="line"><span class="comment"> * registerUrl = dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;bind.ip=192.168.99.60&amp;bind.port=20880&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=4328&amp;qos.port=22222&amp;side=provider&amp;timestamp=1528278313225</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Exporter&lt;?&gt;&gt; exporters = <span class="keyword">new</span> ArrayList&lt;Exporter&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>首先我们先来了解下ProxyFactory接口</p>
<h3 id="ProxyFactory接口"><a href="#ProxyFactory接口" class="headerlink" title="ProxyFactory接口"></a>ProxyFactory接口</h3><h4 id="getInvoker方法"><a href="#getInvoker方法" class="headerlink" title="getInvoker方法"></a>getInvoker方法</h4><p>getInvoker方法是在ProxyFactory接口中定义的。ProxyFactory接口相关类图如下：<br><img src="img/ProxyFactory.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SPI</span>(<span class="string">"javassist"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> proxy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 接口实现类或者代理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 接口类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 注册中心url，本地为injvm</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> invoker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象ProxyFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProxyFactory</span> <span class="keyword">implements</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">//接口数组</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//获取url的interfaces参数的值</span></span><br><span class="line">        String config = invoker.getUrl().getParameter(<span class="string">"interfaces"</span>);</span><br><span class="line">        <span class="keyword">if</span> (config != <span class="keyword">null</span> &amp;&amp; config.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//使用逗号","分隔interfaces参数值</span></span><br><span class="line">            String[] types = Constants.COMMA_SPLIT_PATTERN.split(config);</span><br><span class="line">            <span class="keyword">if</span> (types != <span class="keyword">null</span> &amp;&amp; types.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//这里会将"远程服务接口类、EchoService类"放入到接口数组中</span></span><br><span class="line">                interfaces = <span class="keyword">new</span> Class&lt;?&gt;[types.length + <span class="number">2</span>];</span><br><span class="line">                interfaces[<span class="number">0</span>] = invoker.getInterface();</span><br><span class="line">                interfaces[<span class="number">1</span>] = EchoService.class;</span><br><span class="line">                <span class="comment">//然后将"interfaces参数的值"放入到接口数组</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">                    interfaces[i + <span class="number">1</span>] = ReflectUtils.forName(types[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (interfaces == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//interfaces数组为空的话，则将远程服务接口类、EchoService类放入到接口数组中</span></span><br><span class="line">            interfaces = <span class="keyword">new</span> Class&lt;?&gt;[]&#123;invoker.getInterface(), EchoService.class&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后调用子类体实现来获取代理类</span></span><br><span class="line">        <span class="keyword">return</span> getProxy(invoker, interfaces);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取代理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> types  远程服务接口类数组：</span></span><br><span class="line"><span class="comment">     *               invoker.getInterface()、</span></span><br><span class="line"><span class="comment">     *               EchoService.class、</span></span><br><span class="line"><span class="comment">     *               invoker.getUrl().getParameter("interfaces")</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] types)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk动态代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyFactory</span> <span class="keyword">extends</span> <span class="title">AbstractProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为interfaces这些接口生成代理类</span></span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                interfaces, <span class="keyword">new</span> InvokerInvocationHandler(invoker));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//返回AbstractProxyInvoker抽象类（该类后面的小节会详细介绍）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//根据方法名称methodName和参数类型parameterTypes获取到指定方法</span></span><br><span class="line">                Method method = proxy.getClass().getMethod(methodName, parameterTypes);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//使用参数arguments调用该代理类的method方法</span></span><br><span class="line">                <span class="keyword">return</span> method.invoke(proxy, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Javassist</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavassistProxyFactory</span> <span class="keyword">extends</span> <span class="title">AbstractProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为interfaces这些接口生成代理类(后面会分析Proxy类，这是dubbo自己定义的类)</span></span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="keyword">new</span> InvokerInvocationHandler(invoker));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">	<span class="comment">// TODO Wrapper类不能正确处理带$的类名</span></span><br><span class="line">        <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">'$'</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line">        </span><br><span class="line">	<span class="comment">//返回AbstractProxyInvoker抽象类（该类后面的小节会详细介绍）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//使用Wrapper包装类类调用远程服务方法</span></span><br><span class="line">                <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JavassistProxyFactory类的getInvoker方法实现中，会为相应的接口类(例如：com.alibaba.dubbo.demo.DemoService)生成包装类，生成的逻辑会在单独的小节介绍，这里只简单看下大概生成的类。</p>
<h4 id="Wrapper包装类"><a href="#Wrapper包装类" class="headerlink" title="Wrapper包装类"></a>Wrapper包装类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">alibaba</span>.<span class="title">dubbo</span>.<span class="title">common</span>.<span class="title">bytecode</span>.<span class="title">Wrapper0</span> <span class="keyword">extends</span> <span class="title">Wrapper</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Wrapper0</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="comment">//属性名称数组</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String[] pns;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//&lt;属性名称，属性类型&gt;</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> java.util.Map pts;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//所有方法名称数组</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String[] mns;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//已声明的方法名称数组</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String[] dmns;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//针对每个方法都会定义一个mts数组变量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Class[] mts0;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String[] getPropertyNames()&#123; </span><br><span class="line">		<span class="keyword">return</span> pns; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasProperty</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pts.containsKey($<span class="number">1</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Class <span class="title">getPropertyType</span><span class="params">(String n)</span></span>&#123; </span><br><span class="line">		<span class="keyword">return</span> (Class)pts.get($<span class="number">1</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String[] getMethodNames()&#123; </span><br><span class="line">		<span class="keyword">return</span> mns; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String[] getDeclaredMethodNames()&#123; </span><br><span class="line">		<span class="keyword">return</span> dmns; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(Object o, String n, Object v)</span></span>&#123; </span><br><span class="line">		com.alibaba.dubbo.demo.DemoService w; </span><br><span class="line">		<span class="keyword">try</span>&#123; </span><br><span class="line">			w = ((com.alibaba.dubbo.demo.DemoService)$<span class="number">1</span>); </span><br><span class="line">		&#125;<span class="keyword">catch</span>(Throwable e)&#123; </span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e); </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> com.alibaba.dubbo.common.bytecode.NoSuchPropertyException(<span class="string">"Not found property \""</span>+$<span class="number">2</span>+<span class="string">"\" filed or setter method in class com.alibaba.dubbo.demo.DemoService."</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getPropertyValue</span><span class="params">(Object o, String n)</span></span>&#123; </span><br><span class="line">		com.alibaba.dubbo.demo.DemoService w; </span><br><span class="line">		<span class="keyword">try</span>&#123; </span><br><span class="line">			w = ((com.alibaba.dubbo.demo.DemoService)$<span class="number">1</span>); </span><br><span class="line">		&#125;<span class="keyword">catch</span>(Throwable e)&#123; </span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e); </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> com.alibaba.dubbo.common.bytecode.NoSuchPropertyException(<span class="string">"Not found property \""</span>+$<span class="number">2</span>+<span class="string">"\" filed or setter method in class com.alibaba.dubbo.demo.DemoService."</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 执行服务接口的方法</span></span><br><span class="line"><span class="comment">	 * $1/$2/$3/$4分别对应相应下标的参数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> o 服务接口实例</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> n 服务接口方法名</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> p 服务接口方法参数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> v 服务接口方法参数值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 服务接口调用返回值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invokeMethod</span><span class="params">(Object o, String n, Class[] p, Object[] v)</span> <span class="keyword">throws</span> java.lang.reflect.InvocationTargetException</span>&#123;</span><br><span class="line">		com.alibaba.dubbo.demo.DemoService w; </span><br><span class="line">		<span class="keyword">try</span>&#123; </span><br><span class="line">			w = ((com.alibaba.dubbo.demo.DemoService)$<span class="number">1</span>); </span><br><span class="line">		&#125;<span class="keyword">catch</span>(Throwable e)&#123; </span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e); </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">try</span>&#123; </span><br><span class="line">			<span class="comment">//方法名称为sayHello 并且 只有一个参数</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="string">"sayHello"</span>.equals($<span class="number">2</span>) &amp;&amp; $<span class="number">3</span>.length == <span class="number">1</span>)&#123;  </span><br><span class="line">				<span class="comment">//调用接口方法sayHello</span></span><br><span class="line">				<span class="keyword">return</span> ($w)w.sayHello((java.lang.String)$<span class="number">4</span>[<span class="number">0</span>]);</span><br><span class="line">			&#125; </span><br><span class="line">		&#125; <span class="keyword">catch</span>(Throwable e) &#123;      </span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> java.lang.reflect.InvocationTargetException(e);  </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> com.alibaba.dubbo.common.bytecode.NoSuchMethodException(<span class="string">"Not found method \""</span>+$<span class="number">2</span>+<span class="string">"\" in class com.alibaba.dubbo.demo.DemoService."</span>); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="暴露到注册中心"><a href="#暴露到注册中心" class="headerlink" title="暴露到注册中心"></a>暴露到注册中心</h3><p>我们先看下DelegateProviderMetaDataInvoker类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DelegateProviderMetaDataInvoker类实现了invoker接口</span></span><br><span class="line"><span class="comment"> * 并且持有一个Invoker变量，操作都会委托给该变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegateProviderMetaDataInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Invoker&lt;T&gt; invoker;</span><br><span class="line">    <span class="keyword">private</span> ServiceConfig metadata;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelegateProviderMetaDataInvoker</span><span class="params">(Invoker&lt;T&gt; invoker,ServiceConfig metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.invoker = invoker;</span><br><span class="line">        <span class="keyword">this</span>.metadata = metadata;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> invoker.getInterface();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> invoker.getUrl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> invoker.isAvailable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        invoker.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceConfig <span class="title">getMetadata</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> metadata;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Protocol接口的export方法"><a href="#Protocol接口的export方法" class="headerlink" title="Protocol接口的export方法"></a>Protocol接口的export方法</h4><p>先来看下Protocol接口的定义，其export方法和refer方法存在@Adaptive注解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 协议</span></span><br><span class="line"><span class="comment"> * Protocol. (API/SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SPI</span>(<span class="string">"dubbo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当用户没有配置端口时，获取默认端口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> default port</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为远程调用暴露服务</span></span><br><span class="line"><span class="comment">     * 1、接收到请求后协议应该记录请求源地址，通过: RpcContext.getContext().setRemoteAddress()</span></span><br><span class="line"><span class="comment">     * 2、export()方法必须是幂等的，也就是说，暴露同一个URL的invoker两次时，调用1次和2次没有什么不同</span></span><br><span class="line"><span class="comment">     * 3、传入的Invoker实例由框架实现并传入，协议不需要关心</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;     服务类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker 服务invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 暴露服务的exporter引用，用来以后取消暴露服务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException 当暴露服务出错时抛出，比如端口已占用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用一个远程服务</span></span><br><span class="line"><span class="comment">     * 1、当用户调用 refer()所返回的 Invoker对象的invoke()时，协议需相应执行同URL远端export()传入的Invoker对象的invoke()方法.</span></span><br><span class="line"><span class="comment">     * 2、refer()返回的Invoker由协议实现，一般来说，协议需要在此Invoker中发送远程请求。</span></span><br><span class="line"><span class="comment">     * 3、当URL中设置了check=false时，这个实现不可以抛出异常，而是尝试着从连接失败中恢复</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> T 远程服务类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 远程服务接口类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 远程服务的URL地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行服务的本地代理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException when there's any error while connecting to the service provider</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁协议</span></span><br><span class="line"><span class="comment">     * 1、取消该协议所有已经暴露和引用的服务</span></span><br><span class="line"><span class="comment">     * 2、释放协议所有占用的资源，如：链接、端口等</span></span><br><span class="line"><span class="comment">     * 3、协议在释放后，依然能暴露和引用新的服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可以看到export方法是定义在Protocol接口中的，我们是通过ExtensionLoader类获取到Protocol的自适应扩展实例的，因此我们在调用export方法进行服务暴露时，实际上调用的是自适应扩展实例的export方法：</span><br><span class="line">```java</span><br><span class="line"><span class="comment">//自适应扩展实现类</span></span><br><span class="line">Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取invoker对象</span></span><br><span class="line">Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class="line"><span class="comment">//将invoker和当前对象(ServiceBean)包装成DelegateProviderMetaDataInvoker对象</span></span><br><span class="line">DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用自适应扩展实现类的export方法</span></span><br><span class="line">Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br></pre></td></tr></table></figure></p>
<p>那么，在获取自适应扩展实例时都进行了哪些操作呢？我们在《Dubbo源码阅读之SPI扩展机制》文章中介绍过Dubbo的SPI机制，这里就不再详细介绍了，只简单说明下是如何获取到Protocol实例的。<br>首先我们我们通过ExtensionLoader.getExtensionLoader(Protocol.class)调用，获取到了Protocol的扩展加载器，然后调用它的getAdaptiveExtension()方法拿到自适应扩展实例(Dubbo为它自动生成的一个类，后面介绍)，在此过程中，会先去扫描3个相关路径找到所有的Protocol扩展实现类定义，<br>最终会找到如下定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#扩展名称=扩展实现类</span><br><span class="line">registry=com.alibaba.dubbo.registry.integration.RegistryProtocol</span><br><span class="line">mock=com.alibaba.dubbo.rpc.support.MockProtocol</span><br><span class="line">injvm=com.alibaba.dubbo.rpc.protocol.injvm.InjvmProtocol</span><br><span class="line">dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br><span class="line">#Protocol包装类</span><br><span class="line">filter=com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper</span><br><span class="line">listener=com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper</span><br></pre></td></tr></table></figure></p>
<p>然后检查每个扩展实现类，如果没有找到存在@Adaptive注解的扩展类，则Dubbo会为其生成一个自适应扩展类，生成的实现类如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成的实现类名为：Protocol$Adaptive，实现了Protocol接口</span></span><br><span class="line"><span class="comment"> * 只有接口方法上标有<span class="doctag">@Adaptive</span>注解，才会为其生成实现，</span></span><br><span class="line"><span class="comment"> * 例如，Protocol接口的destroy()方法没有<span class="doctag">@Adaptive</span>注解，因此下面的方法实现中直接抛了异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Protocol</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">alibaba</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">Protocol</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//提示 Protocol接口的destroy()方法没有@Adaptive注解，因此不支持</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"method public abstract void com.alibaba.dubbo.rpc.Protocol.destroy() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//提示 Protocol接口的getDefaultPort()方法没有@Adaptive注解，因此不支持</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"method public abstract int com.alibaba.dubbo.rpc.Protocol.getDefaultPort() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arg0 服务接口类</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arg1 注册中心url</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> com.alibaba.dubbo.rpc.<span class="function">Invoker <span class="title">refer</span><span class="params">(java.lang.Class arg0, com.alibaba.dubbo.common.URL arg1)</span> <span class="keyword">throws</span> com.alibaba.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arg1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">//url参数不可以为空</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		com.alibaba.dubbo.common.URL url = arg1;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//使用url的protocol属性值(这里为registry)，作为扩展名称，如果为空，则默认使用"dubbo"</span></span><br><span class="line">		String extName = url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(extName == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取扩展名称为extName的Protocol扩展实例</span></span><br><span class="line">		com.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//调用该extension实例的refer方法</span></span><br><span class="line">		<span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">public</span> com.alibaba.dubbo.rpc.<span class="function">Exporter <span class="title">export</span><span class="params">(com.alibaba.dubbo.rpc.Invoker arg0)</span> <span class="keyword">throws</span> com.alibaba.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arg0 == <span class="keyword">null</span>)&#123;</span><br><span class="line">		    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"com.alibaba.dubbo.rpc.Invoker argument == null"</span>);</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>) &#123;</span><br><span class="line">		    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"com.alibaba.dubbo.rpc.Invoker argument getUrl() == null"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		com.alibaba.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//使用url的protocol属性值(这里为registry)，作为扩展名称，如果为空，则默认使用"dubbo"</span></span><br><span class="line">		String extName = ( url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol() );</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(extName == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取扩展名称为extName的Protocol扩展实例（此扩展实例已经被包装类包装过）</span></span><br><span class="line">		com.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//调用该extension实例的export方法(包装类的export方法)</span></span><br><span class="line">		<span class="keyword">return</span> extension.export(arg0);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面我们说到，调用export方法实际上是调用自适应扩展实现类的export方法，我们来看下其实现。<br>首先校验invoker参数不可以为空，然后校验invoker对象的getUrl()方法返回的URL对象不可以为空，然后我们使用URL对象的protocol属性作为扩展名称extName(提示：在上一节的loadRegistries(boolean provider)加载注册中心url列表方法中，我们设置了注册中心url的protocol属性值为”registry”)，然后根据扩展名称extName获取到真正的Protocol扩展实例(RegistryProtocol,然后RegistryProtocol会被包装)，最后调用该Protocol扩展实例的export方法。<br>通过生成的自适应扩展实现类，我们可以根据不同的扩展名称调用不同的扩展实例。<br>在getExtension(extName)方法中，获取到相应的扩展实例后(RegistryProtocol)，Dubbo会再去查看下该扩展是否存在相应的包装类，在上面我们扫描出来Protocol接口存在2个包装类，ProtocolFilterWrapper和ProtocolListenerWrapper，接着Dubbo会创建包装类的实例，并将刚才生成RegistryProtocol扩展实例通过构造函数参数传递到包装类中，通过包装类，Dubbo就实现了功能增强。<br>因此，现在我们再回过头来看下export方法的调用：首先是调用自适应扩展实现类的export方法，在export方法内部，根据扩展名称获取到真实的扩展实例RegistryProtocol，然后又通过两个包装类将真实的扩展实例进行了包装，最后调用的是包装类的export方法。<br>具体的调用链我们已经分析完了，现在我们来看下对应的代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据扩展名称创建扩展实例后，会获取包装类，将扩展实例进行包装</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//根据扩展名称name获取扩展实现类clazz</span></span><br><span class="line">	Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">	<span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">	    <span class="comment">//扩展实现类为空，则抛出异常</span></span><br><span class="line">	    <span class="keyword">throw</span> findException(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	    <span class="comment">//先从缓存中获取扩展实现类的实例，如果没有获取到，则新建一个并放入缓存。</span></span><br><span class="line">	    T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">	    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">		EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">		instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">//处理扩展实现类实例的依赖注入</span></span><br><span class="line">	    injectExtension(instance);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">//获取到type接口的所有包装类</span></span><br><span class="line">	    Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">	    <span class="keyword">if</span> (wrapperClasses != <span class="keyword">null</span> &amp;&amp; !wrapperClasses.isEmpty()) &#123;</span><br><span class="line">		<span class="comment">//遍历包装类</span></span><br><span class="line">		<span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">		    <span class="comment">//包装类通过构造方法创建实例，然后进行依赖注入</span></span><br><span class="line">		    instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> instance;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">	    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Extension instance(name: "</span> + name + <span class="string">", class: "</span> +</span><br><span class="line">		    type + <span class="string">")  could not be instantiated: "</span> + t.getMessage(), t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolFilterWrapper</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//根据上面的分析，这里的protocol是ProtocolListenerWrapper</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Protocol protocol;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtocolFilterWrapper</span><span class="params">(Protocol protocol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"protocol == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">	    <span class="comment">//如果url的protocol属性为registry，则调用protocol的export方法</span></span><br><span class="line">            <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....省略其他方法....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolListenerWrapper</span> <span class="keyword">implements</span> <span class="title">Protocol</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//根据上面的分析，这里的protocol是RegistryProtocol</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Protocol protocol;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtocolListenerWrapper</span><span class="params">(Protocol protocol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"protocol == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">	    <span class="comment">//如果url的protocol属性为registry，则调用protocol的export方法</span></span><br><span class="line">            <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListenerExporterWrapper&lt;T&gt;(protocol.export(invoker),</span><br><span class="line">                Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener.class)</span><br><span class="line">                        .getActivateExtension(invoker.getUrl(), Constants.EXPORTER_LISTENER_KEY)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过我们的分析，最终会调用RegistryProtocol的export方法进行服务暴露，接下来，我们就来分析下该方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//获取invoker对象</span></span><br><span class="line">Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//将invoker和当前对象(ServiceBean)包装成DelegateProviderMetaDataInvoker对象</span></span><br><span class="line">DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过invoker的url(即注册中心url)获取providerUrl的地址（即服务暴露的url）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> origininvoker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> URL <span class="title">getProviderUrl</span><span class="params">(<span class="keyword">final</span> Invoker&lt;?&gt; origininvoker)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取参数export指定的服务地址</span></span><br><span class="line">	String export = origininvoker.getUrl().getParameterAndDecoded(Constants.EXPORT_KEY);</span><br><span class="line">	<span class="keyword">if</span> (export == <span class="keyword">null</span> || export.length() == <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="comment">//注册中心服务暴露url为空</span></span><br><span class="line">	    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The registry export url is null! registry: "</span> + origininvoker.getUrl());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//根据url字符串生成URL对象</span></span><br><span class="line">	URL providerUrl = URL.valueOf(export);</span><br><span class="line">	<span class="keyword">return</span> providerUrl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取originInvoker对象对应的缓存key（移除了dynamic、enabled属性的服务提供者url）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getCacheKey</span><span class="params">(<span class="keyword">final</span> Invoker&lt;?&gt; originInvoker)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取服务暴露的url，即export参数对应的url</span></span><br><span class="line">	URL providerUrl = getProviderUrl(originInvoker);</span><br><span class="line">	<span class="comment">//移除dynamic、enabled参数，剩下的url作为缓存key</span></span><br><span class="line">	String key = providerUrl.removeParameters(<span class="string">"dynamic"</span>, <span class="string">"enabled"</span>).toFullString();</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取注册中心url(如果是注册中心协议，则修改了protocol属性值，属性值为url的registry参数值，并移除url的registry参数)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> originInvoker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> URL <span class="title">getRegistryUrl</span><span class="params">(Invoker&lt;?&gt; originInvoker)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//注册中心url</span></span><br><span class="line">	URL registryUrl = originInvoker.getUrl();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(registryUrl.getProtocol())) &#123;</span><br><span class="line">	    <span class="comment">//如果registryUrl的protocol属性为"registry"，则获取registryUrl的registry参数值，如果没有获取到，则默认protocol = dubbo</span></span><br><span class="line">	    <span class="comment">//这里获取到protocol = multicast</span></span><br><span class="line">	    String protocol = registryUrl.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_DIRECTORY);</span><br><span class="line">	    <span class="comment">//设置registryUrl的protocol属性值，并移除registry参数</span></span><br><span class="line">	    registryUrl = registryUrl.setProtocol(protocol).removeParameter(Constants.REGISTRY_KEY);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> registryUrl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 基于invoker的地址获取一个注册中心的实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> originInvoker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Registry <span class="title">getRegistry</span><span class="params">(<span class="keyword">final</span> Invoker&lt;?&gt; originInvoker)</span> </span>&#123;</span><br><span class="line">	URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">	<span class="comment">//获取实例</span></span><br><span class="line">	<span class="keyword">return</span> registryFactory.getRegistry(registryUrl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回注册到注册中心的地址并过滤一次url参数(即服务提供者url)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> originInvoker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> URL <span class="title">getRegistedProviderUrl</span><span class="params">(<span class="keyword">final</span> Invoker&lt;?&gt; originInvoker)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//服务暴露的url，即export参数指定的url</span></span><br><span class="line">	URL providerUrl = getProviderUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在注册中心中看到的服务地址</span></span><br><span class="line">	<span class="keyword">final</span> URL registedProviderUrl = providerUrl.removeParameters(</span><br><span class="line">			<span class="comment">//删除不需要输出的参数key</span></span><br><span class="line">			getFilteredKeys(providerUrl)</span><br><span class="line">		)</span><br><span class="line">		<span class="comment">//移除监控</span></span><br><span class="line">		.removeParameter(Constants.MONITOR_KEY)</span><br><span class="line">		<span class="comment">//移除绑定ip、port</span></span><br><span class="line">		.removeParameter(Constants.BIND_IP_KEY)</span><br><span class="line">		.removeParameter(Constants.BIND_PORT_KEY)</span><br><span class="line">		<span class="comment">//移除qos</span></span><br><span class="line">		.removeParameter(QOS_ENABLE)</span><br><span class="line">		.removeParameter(QOS_PORT)</span><br><span class="line">		.removeParameter(ACCEPT_FOREIGN_IP);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> registedProviderUrl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务暴露</span></span><br><span class="line"><span class="comment"> * originInvoker参数就是上面我们创建的wrapperInvoker</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">	<span class="comment">//暴露invoker(后面会分析该方法)</span></span><br><span class="line">	<span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取注册中心地址,如：multicast://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&amp;dubbo=2.0.0&amp;export=dubbo%3A%2F%2F192.168.99.60%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26bind.ip%3D192.168.99.60%26bind.port%3D20880%26dubbo%3D2.0.0%26generic%3Dfalse%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D7520%26qos.port%3D22222%26side%3Dprovider%26timestamp%3D1528784828723&amp;pid=7520&amp;qos.port=22222&amp;timestamp=1528784779675</span></span><br><span class="line">	URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取注册中心实例</span></span><br><span class="line">	<span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注册中心url的export参数指定的url(服务提供者url)，去掉了一些key</span></span><br><span class="line">	<span class="keyword">final</span> URL registedProviderUrl = getRegistedProviderUrl(originInvoker);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断是否延迟发布，默认是true</span></span><br><span class="line">	<span class="keyword">boolean</span> register = registedProviderUrl.getParameter(<span class="string">"register"</span>, <span class="keyword">true</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注册服务提供者(保存到map缓存中)</span></span><br><span class="line">	ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registedProviderUrl);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (register) &#123;</span><br><span class="line">	    <span class="comment">//registryUrl注册中心url，registedProviderUrl服务提供者url</span></span><br><span class="line">	    <span class="comment">//获取注册中心，并将服务提供者注册到注册中心</span></span><br><span class="line">	    register(registryUrl, registedProviderUrl);</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">//根据originInvoker获取到ProviderInvokerWrapper并标识isReg = true</span></span><br><span class="line">	    ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当提供者订阅时，会影响一个场景，即同一JVM即暴露服务，又引用同一服务。</span></span><br><span class="line">	<span class="comment">// 因为subscribed使用服务的名称作为缓存key，它会导致订阅信息被覆盖</span></span><br><span class="line">	<span class="comment">//如：provider://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;category=configurators&amp;check=false&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=5452&amp;side=provider&amp;timestamp=1528789631708</span></span><br><span class="line">	<span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建OverrideListener对象(后面小节会介绍)</span></span><br><span class="line">	<span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//保存overrideSubscribeUrl和overrideSubscribeListener</span></span><br><span class="line">	overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//订阅服务(后面注册中心小节会介绍)</span></span><br><span class="line">	registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//确保每次发布时都返回一个新的exporter实例</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;T&gt;(exporter, originInvoker, overrideSubscribeUrl, registedProviderUrl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * subscribedOverrideUrl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registedProviderUrl 服务提供者url</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> URL <span class="title">getSubscribedOverrideUrl</span><span class="params">(URL registedProviderUrl)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//设置protocol = provider,修改前 protocol = dubbo</span></span><br><span class="line">	<span class="comment">//设置category = configurators</span></span><br><span class="line">	<span class="comment">//设置check = false</span></span><br><span class="line">	<span class="keyword">return</span> registedProviderUrl.setProtocol(Constants.PROVIDER_PROTOCOL)</span><br><span class="line">		.addParameters(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY,</span><br><span class="line">			Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过registryUrl获取注册中心，然后将服务提供者url注册到注册中心</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registryUrl 注册中心url</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registedProviderUrl 服务提供者url</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL registryUrl, URL registedProviderUrl)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//根据注册中心url 获取注册中心实例</span></span><br><span class="line">	Registry registry = registryFactory.getRegistry(registryUrl);</span><br><span class="line">	<span class="comment">//注册 服务提供者 到注册中心</span></span><br><span class="line">	registry.register(registedProviderUrl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为了解决RMI反复暴露端口冲突的问题，已经暴露的服务不需要再次暴露</span></span><br><span class="line"><span class="comment"> * &lt;providerurl,exporter&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ExporterChangeableWrapper&lt;?&gt;&gt; bounds = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ExporterChangeableWrapper&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;服务提供者url,NotifyListener&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;URL, NotifyListener&gt; overrideListeners = <span class="keyword">new</span> ConcurrentHashMap&lt;URL, NotifyListener&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴露originInvoker</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ExporterChangeableWrapper&lt;T&gt; <span class="title">doLocalExport</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取缓存key</span></span><br><span class="line">	String key = getCacheKey(originInvoker);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//先检查是否暴露过，没有暴露过的话，则进行暴露</span></span><br><span class="line">	ExporterChangeableWrapper&lt;T&gt; exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">	<span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">	    <span class="keyword">synchronized</span> (bounds) &#123;</span><br><span class="line">		exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">		<span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">		    <span class="comment">//根据originInvoker，及其服务提供者url，创建InvokerDelegete对象</span></span><br><span class="line">		    <span class="keyword">final</span> Invoker&lt;?&gt; invokerDelegete = <span class="keyword">new</span> InvokerDelegete&lt;T&gt;(originInvoker, getProviderUrl(originInvoker));</span><br><span class="line">		   </span><br><span class="line">		    <span class="comment">//1、因为invokerDelegete对象的getUrl方法将会返回服务提供者url，其protocol属性将会返回扩展名称dubbo，因此这里会调用DubboProtocol的export方法进行暴露</span></span><br><span class="line">		    <span class="comment">//2、创建ExporterChangeableWrapper对象</span></span><br><span class="line">		    exporter = <span class="keyword">new</span> ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegete), originInvoker);</span><br><span class="line">		    </span><br><span class="line">		    <span class="comment">//dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;bind.ip=192.168.99.60&amp;bind.port=20880&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=6440&amp;qos.port=22222&amp;side=provider&amp;timestamp=1528789363848</span></span><br><span class="line">		    <span class="comment">//URL url = exporter.getInvoker().getUrl();</span></span><br><span class="line">		    <span class="comment">//放入缓存</span></span><br><span class="line">		    bounds.put(key, exporter);</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoker委托类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerDelegete</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">InvokerWrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Invoker&lt;T&gt; invoker;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> invoker</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> url   服务提供者url</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InvokerDelegete</span><span class="params">(Invoker&lt;T&gt; invoker, URL url)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">super</span>(invoker, url);</span><br><span class="line">	    <span class="keyword">this</span>.invoker = invoker;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (invoker <span class="keyword">instanceof</span> InvokerDelegete) &#123;</span><br><span class="line">		<span class="keyword">return</span> ((InvokerDelegete&lt;T&gt;) invoker).getInvoker();</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> invoker;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * exporter代理</span></span><br><span class="line"><span class="comment"> * 建立通过protocol已暴露的exporter和已返回的exporter的对应关系</span></span><br><span class="line"><span class="comment"> * 并且可以在覆盖时修改关系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ExporterChangeableWrapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Exporter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Invoker&lt;T&gt; originInvoker;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//protocol.export(invokerDelegete)返回的Exporter</span></span><br><span class="line">	<span class="keyword">private</span> Exporter&lt;T&gt; exporter;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ExporterChangeableWrapper</span><span class="params">(Exporter&lt;T&gt; exporter, Invoker&lt;T&gt; originInvoker)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">this</span>.exporter = exporter;</span><br><span class="line">	    <span class="keyword">this</span>.originInvoker = originInvoker;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">getOriginInvoker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> originInvoker;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> exporter.getInvoker();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExporter</span><span class="params">(Exporter&lt;T&gt; exporter)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">this</span>.exporter = exporter;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    String key = getCacheKey(<span class="keyword">this</span>.originInvoker);</span><br><span class="line">	    bounds.remove(key);</span><br><span class="line">	    exporter.unexport();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可销毁的Exporter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DestroyableExporter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Exporter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executor = Executors.newSingleThreadExecutor(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"Exporter-Unexport"</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Exporter&lt;T&gt; exporter;</span><br><span class="line">	<span class="keyword">private</span> Invoker&lt;T&gt; originInvoker;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//overrideSubscribeUrl 订阅的url</span></span><br><span class="line">	<span class="keyword">private</span> URL subscribeUrl; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//registedProviderUrl 注册的服务提供者url</span></span><br><span class="line">	<span class="keyword">private</span> URL registerUrl;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DestroyableExporter</span><span class="params">(Exporter&lt;T&gt; exporter, Invoker&lt;T&gt; originInvoker, URL subscribeUrl, URL registerUrl)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">this</span>.exporter = exporter;</span><br><span class="line">	    <span class="keyword">this</span>.originInvoker = originInvoker;</span><br><span class="line">	    <span class="keyword">this</span>.subscribeUrl = subscribeUrl;</span><br><span class="line">	    <span class="keyword">this</span>.registerUrl = registerUrl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> exporter.getInvoker();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//获取注册中心实例</span></span><br><span class="line">	    Registry registry = RegistryProtocol.INSTANCE.getRegistry(originInvoker);</span><br><span class="line">	    <span class="keyword">try</span> &#123;</span><br><span class="line">	        <span class="comment">//取消注册registerUrl</span></span><br><span class="line">		registry.unregister(registerUrl);</span><br><span class="line">	    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">		logger.warn(t.getMessage(), t);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">try</span> &#123;</span><br><span class="line">	        <span class="comment">//移除监听</span></span><br><span class="line">		NotifyListener listener = RegistryProtocol.INSTANCE.overrideListeners.remove(subscribeUrl);</span><br><span class="line">		<span class="comment">//取消订阅subscribeUrl</span></span><br><span class="line">		registry.unsubscribe(subscribeUrl, listener);</span><br><span class="line">	    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">		logger.warn(t.getMessage(), t);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">//提交线程，取消暴露服务</span></span><br><span class="line">	    executor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		    <span class="keyword">try</span> &#123;</span><br><span class="line">		        <span class="comment">//取消暴露服务时，等待注册中心通知所有的消费者的超时时间</span></span><br><span class="line">			<span class="keyword">int</span> timeout = ConfigUtils.getServerShutdownTimeout();</span><br><span class="line">			<span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			    logger.info(<span class="string">"Waiting "</span> + timeout + <span class="string">"ms for registry to notify all consumers before unexport. Usually, this is called when you use dubbo API"</span>);</span><br><span class="line">			    Thread.sleep(timeout);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//取消暴露服务</span></span><br><span class="line">			exporter.unexport();</span><br><span class="line">		    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">			logger.warn(t.getMessage(), t);</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProviderConsumerRegTable类用来保存注册的服务提供者和消费者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderConsumerRegTable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;服务唯一名称,Set&lt;服务提供者执行器&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, Set&lt;ProviderInvokerWrapper&gt;&gt; providerInvokers = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Set&lt;ProviderInvokerWrapper&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, Set&lt;ConsumerInvokerWrapper&gt;&gt; consumerInvokers = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Set&lt;ConsumerInvokerWrapper&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册服务提供者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registryUrl 注册中心地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> providerUrl 服务提供者url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerProvider</span><span class="params">(Invoker invoker, URL registryUrl, URL providerUrl)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建ProviderInvokerWrapper实例</span></span><br><span class="line">        ProviderInvokerWrapper wrapperInvoker = <span class="keyword">new</span> ProviderInvokerWrapper(invoker, registryUrl, providerUrl);</span><br><span class="line">        </span><br><span class="line">	<span class="comment">//获取服务唯一名称标识</span></span><br><span class="line">        String serviceUniqueName = providerUrl.getServiceKey();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//根据serviceUniqueName从缓存中获取</span></span><br><span class="line">	Set&lt;ProviderInvokerWrapper&gt; invokers = providerInvokers.get(serviceUniqueName);</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">if</span> (invokers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            providerInvokers.putIfAbsent(serviceUniqueName, <span class="keyword">new</span> ConcurrentHashSet&lt;ProviderInvokerWrapper&gt;());</span><br><span class="line">            invokers = providerInvokers.get(serviceUniqueName);</span><br><span class="line">        &#125;</span><br><span class="line">        invokers.add(wrapperInvoker);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过invoker 获取相应的ProviderInvokerWrapper</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> invoker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProviderInvokerWrapper <span class="title">getProviderWrapper</span><span class="params">(Invoker invoker)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取服务提供者url</span></span><br><span class="line">	URL providerUrl = invoker.getUrl();</span><br><span class="line">	<span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(providerUrl.getProtocol())) &#123;</span><br><span class="line">	    <span class="comment">//获取export参数的值，即(服务提供者url)</span></span><br><span class="line">	    providerUrl = URL.valueOf(providerUrl.getParameterAndDecoded(Constants.EXPORT_KEY));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取服务唯一标识</span></span><br><span class="line">	String serviceUniqueName = providerUrl.getServiceKey();</span><br><span class="line">	<span class="comment">//根据服务唯一标识获取invokers</span></span><br><span class="line">	Set&lt;ProviderInvokerWrapper&gt; invokers = providerInvokers.get(serviceUniqueName);</span><br><span class="line">	<span class="keyword">if</span> (invokers == <span class="keyword">null</span>) &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (ProviderInvokerWrapper providerWrapper : invokers) &#123;</span><br><span class="line">	    Invoker providerInvoker = providerWrapper.getInvoker();</span><br><span class="line">	    <span class="comment">//通过invoker获取providerWrapper</span></span><br><span class="line">	    <span class="keyword">if</span> (providerInvoker == invoker) &#123;</span><br><span class="line">		<span class="keyword">return</span> providerWrapper;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重新暴露修改了url的invoker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> originInvoker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newInvokerUrl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doChangeLocalExport</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker, URL newInvokerUrl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取originInvoker对应的缓存key</span></span><br><span class="line">	String key = getCacheKey(originInvoker);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从缓存中获取该exporter</span></span><br><span class="line">	<span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">	    logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">"error state, exporter should not be null"</span>));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="comment">//重新生成invokerDelegete</span></span><br><span class="line">	    <span class="keyword">final</span> Invoker&lt;T&gt; invokerDelegete = <span class="keyword">new</span> InvokerDelegete&lt;T&gt;(originInvoker, newInvokerUrl);</span><br><span class="line">	    <span class="comment">//重新暴露服务</span></span><br><span class="line">	    exporter.setExporter(protocol.export(invokerDelegete));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来我们看下OverrideListener类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、确保由registryProtocol返回的exporter可以被正常销毁</span></span><br><span class="line"><span class="comment"> * 2、通知后，无需重新注册到注册中心</span></span><br><span class="line"><span class="comment"> * 3、通过暴露方法传递invoker，最好是exporter的invoker</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideListener</span> <span class="keyword">implements</span> <span class="title">NotifyListener</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 已订阅的url</span></span><br><span class="line"><span class="comment">	 * protocol = provider</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> URL subscribeUrl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Invoker originInvoker;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OverrideListener</span><span class="params">(URL subscribeUrl, Invoker originalInvoker)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">this</span>.subscribeUrl = subscribeUrl;</span><br><span class="line">	    <span class="keyword">this</span>.originInvoker = originalInvoker;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通知</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> urls 已注册的信息列表，它总是非空。这意味着与RegistryService#lookup(URL)有相同的返回值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">	    logger.debug(<span class="string">"original override urls: "</span> + urls);</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">//获取匹配到的url</span></span><br><span class="line">	    List&lt;URL&gt; matchedUrls = getMatchedUrls(urls, subscribeUrl);</span><br><span class="line">	    logger.debug(<span class="string">"subscribe url: "</span> + subscribeUrl + <span class="string">", override urls: "</span> + matchedUrls);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">//没有匹配到结果，直接返回</span></span><br><span class="line">	    <span class="keyword">if</span> (matchedUrls.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">		</span><br><span class="line">	    <span class="comment">//根据匹配的url生成configurators列表(后面小节会分析该方法)</span></span><br><span class="line">	    List&lt;Configurator&gt; configurators = RegistryDirectory.toConfigurators(matchedUrls);</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">final</span> Invoker&lt;?&gt; invoker;</span><br><span class="line">	    <span class="keyword">if</span> (originInvoker <span class="keyword">instanceof</span> InvokerDelegete) &#123;</span><br><span class="line">	        <span class="comment">//委托类，调用getInvoker()方法获取invoker</span></span><br><span class="line">		invoker = ((InvokerDelegete&lt;?&gt;) originInvoker).getInvoker();</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		invoker = originInvoker;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">//originUrl即export参数对应的url(原始服务提供者url)</span></span><br><span class="line">	    URL originUrl = RegistryProtocol.<span class="keyword">this</span>.getProviderUrl(invoker);</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">//这里的exporter就是在上步的doLocalExport()方法中生成的</span></span><br><span class="line">	    String key = getCacheKey(originInvoker);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">//根据缓存key从缓存中获取exporter</span></span><br><span class="line">	    ExporterChangeableWrapper&lt;?&gt; exporter = bounds.get(key);</span><br><span class="line">	    <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">		logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">"error state, exporter should not be null"</span>));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">//当前的url(旧的服务暴露的url)，可能已经合并了很多次</span></span><br><span class="line">	    URL currentUrl = exporter.getInvoker().getUrl();</span><br><span class="line">	   </span><br><span class="line">	    <span class="comment">//合并配置，生成新的服务暴露url</span></span><br><span class="line">	    URL newUrl = getConfigedInvokerUrl(configurators, originUrl);</span><br><span class="line">	    </span><br><span class="line">	    <span class="keyword">if</span> (!currentUrl.equals(newUrl)) &#123;</span><br><span class="line">		<span class="comment">//已暴露的服务提供者url已经发生改变，重新暴露</span></span><br><span class="line">		RegistryProtocol.<span class="keyword">this</span>.doChangeLocalExport(originInvoker, newUrl);</span><br><span class="line"></span><br><span class="line">		logger.info(<span class="string">"exported provider url changed, origin url: "</span> + originUrl + <span class="string">", old export url: "</span> + currentUrl + <span class="string">", new export url: "</span> + newUrl);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取匹配的url</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> configuratorUrls</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> currentSubscribe 当前已订阅的url</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> List&lt;URL&gt; <span class="title">getMatchedUrls</span><span class="params">(List&lt;URL&gt; configuratorUrls, URL currentSubscribe)</span> </span>&#123;</span><br><span class="line">	    List&lt;URL&gt; result = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">	    </span><br><span class="line">	    <span class="keyword">for</span> (URL url : configuratorUrls) &#123;</span><br><span class="line">		URL overrideUrl = url;</span><br><span class="line">		<span class="comment">//与旧版本兼容</span></span><br><span class="line">		<span class="keyword">if</span> (url.getParameter(Constants.CATEGORY_KEY) == <span class="keyword">null</span> &amp;&amp; Constants.OVERRIDE_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">		    <span class="comment">//url的category参数为空，并且url协议为override时，则新增url的category参数 = configurators</span></span><br><span class="line">		    overrideUrl = url.addParameter(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//检测url是否可以应用到当前服务</span></span><br><span class="line">		<span class="comment">//consumerUrl,providerUrl</span></span><br><span class="line">		<span class="keyword">if</span> (UrlUtils.isMatch(currentSubscribe, overrideUrl)) &#123;</span><br><span class="line">		    <span class="comment">//匹配，则将该url保存</span></span><br><span class="line">		    result.add(url);</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 合并configurators的url，返回新的url</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> configurators</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> url 原始服务提供者url</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> URL <span class="title">getConfigedInvokerUrl</span><span class="params">(List&lt;Configurator&gt; configurators, URL url)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">for</span> (Configurator configurator : configurators) &#123;</span><br><span class="line">	        <span class="comment">//配置url</span></span><br><span class="line">		url = configurator.configure(url);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> url;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后我们来看下DubboProtocol的export方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存发布的服务</span></span><br><span class="line"><span class="comment"> * &lt;URL的serviceKey,Exporter&gt;</span></span><br><span class="line"><span class="comment"> * 通过key可以获取到服务发布对象DubboExporter，</span></span><br><span class="line"><span class="comment"> * 然后通过DubboExporter的getInvoker方法得到服务调用对象Invoker,从而调用服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Exporter&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者端为调度事件暴露一个存根服务</span></span><br><span class="line"><span class="comment"> * &lt;servicekey,stubmethods&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, String&gt; stubServiceMethodsMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> invoker 即新创建的InvokerDelegete对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//服务提供者url</span></span><br><span class="line">	<span class="comment">//dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;bind.ip=192.168.99.60&amp;bind.port=20880&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=7520&amp;qos.port=22222&amp;side=provider&amp;timestamp=1528784828723</span></span><br><span class="line">	URL url = invoker.getUrl();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取服务名称，格式为：group/ServiceName:version:port</span></span><br><span class="line">	<span class="comment">// 这里group和version没有设置，因此key = com.alibaba.dubbo.demo.DemoService:20880</span></span><br><span class="line">	String key = serviceKey(url);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//生成key值之后，结合Invoker和exportMap生成服务暴露对象exporter，</span></span><br><span class="line">	<span class="comment">//然后将生成的服务暴露对象exporter作为value值放入map中，从而实现服务发布</span></span><br><span class="line">	DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">	exporterMap.put(key, exporter);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//为调度事件暴露一个存根服务，默认false</span></span><br><span class="line">	Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//是否是回调服务</span></span><br><span class="line">	Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, <span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class="line">	    <span class="comment">//存根服务方法</span></span><br><span class="line">	    String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);</span><br><span class="line">	    <span class="keyword">if</span> (stubServiceMethods == <span class="keyword">null</span> || stubServiceMethods.length() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">		    <span class="comment">//设置了存根代理支持事件，但是没有发现存根方法</span></span><br><span class="line">		    logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">"consumer ["</span> + url.getParameter(Constants.INTERFACE_KEY) +</span><br><span class="line">			    <span class="string">"], has set stubproxy support event ,but no stub methods founded."</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//保存存根方法</span></span><br><span class="line">		stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//开启服务</span></span><br><span class="line">	openServer(url);</span><br><span class="line">	<span class="comment">//优化序列化(加载优化序列化类,后面小节会详细介绍)</span></span><br><span class="line">	optimizeSerialization(url);</span><br><span class="line">	<span class="comment">//返回exporter</span></span><br><span class="line">	<span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存已创建的服务器</span></span><br><span class="line"><span class="comment"> * &lt;地址address，ExchangeServer&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ExchangeServer&gt; serverMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ExchangeServer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启服务(后面会小节会详解讲解)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取服务地址</span></span><br><span class="line">	String key = url.getAddress();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//客户端可以暴露一个只能服务端调用的服务</span></span><br><span class="line">	<span class="keyword">boolean</span> isServer = url.getParameter(Constants.IS_SERVER_KEY, <span class="keyword">true</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">	    <span class="comment">//先从缓存中获取下该服务地址key对应的服务器</span></span><br><span class="line">	    ExchangeServer server = serverMap.get(key);</span><br><span class="line">	    <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//创建服务器，并放入缓存</span></span><br><span class="line">		serverMap.put(key, createServer(url));</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//服务器支持重置，与override一起使用</span></span><br><span class="line">		<span class="comment">//重置服务器</span></span><br><span class="line">		server.reset(url);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建服务器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url 服务提供者url</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ExchangeServer <span class="title">createServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//当服务器关闭时，发送readonly事件，默认情况下，是启用的。</span></span><br><span class="line">	url = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString());</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//默认情况下，启用心跳</span></span><br><span class="line">	url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取Transporter扩展，默认使用netty</span></span><br><span class="line">	String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;</span><br><span class="line">	    <span class="comment">//不支持的服务器类型</span></span><br><span class="line">	    <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported server type: "</span> + str + <span class="string">", url: "</span> + url);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在url中添加codec=dubbo</span></span><br><span class="line">	url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);</span><br><span class="line">	</span><br><span class="line">	ExchangeServer server;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	    <span class="comment">//Exchangers门面 绑定到服务器</span></span><br><span class="line">	    server = Exchangers.bind(url, requestHandler);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">	    <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Fail to start server(url: "</span> + url + <span class="string">") "</span> + e.getMessage(), e);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取客户端扩展名称</span></span><br><span class="line">	str = url.getParameter(Constants.CLIENT_KEY);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="comment">//获取支持的Transporter扩展名称列表</span></span><br><span class="line">	    Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();</span><br><span class="line">	    <span class="keyword">if</span> (!supportedTypes.contains(str)) &#123;</span><br><span class="line">		<span class="comment">//不支持的客户端类型</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported client type: "</span> + str);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="暴露到本地"><a href="#暴露到本地" class="headerlink" title="暴露到本地"></a>暴露到本地</h3><p>主要的方法调用protocol.export上文我们已经介绍过了，这里就不再介绍了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴露服务到本地注册中心</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url 服务暴露的url</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exportLocal</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">	    <span class="comment">//例如：injvm://127.0.0.1/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;bind.ip=192.168.99.60&amp;bind.port=20880&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=4328&amp;qos.port=22222&amp;side=provider&amp;timestamp=1528278313225</span></span><br><span class="line">	    URL local = URL.valueOf(url.toFullString())</span><br><span class="line">		    <span class="comment">//设置injvm协议</span></span><br><span class="line">		    .setProtocol(Constants.LOCAL_PROTOCOL)</span><br><span class="line">		    <span class="comment">//设置本地地址</span></span><br><span class="line">		    .setHost(LOCALHOST)</span><br><span class="line">		    <span class="comment">//设置端口</span></span><br><span class="line">		    .setPort(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">//获取到实现类ref的Class对象，然后将它放入到ThreadLocal中</span></span><br><span class="line">	    ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref));</span><br><span class="line"></span><br><span class="line">	    <span class="comment">//暴露服务(后面会分析export方法)</span></span><br><span class="line">	    Exporter&lt;?&gt; exporter = protocol.export(</span><br><span class="line">		    proxyFactory.getInvoker(ref, (Class) interfaceClass, local)</span><br><span class="line">	    );</span><br><span class="line"></span><br><span class="line">	    <span class="comment">//保存暴露的服务到本地变量中</span></span><br><span class="line">	    exporters.add(exporter);</span><br><span class="line">	    logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to local registry"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，关于服务暴露的内容，我们就介绍完毕了，下一小节，介绍如果引用服务.</p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/blog/js/index.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/blog/js/gitment.js"></script>
<script>
    var gitment = new Gitment({
        id: 'Dubbo源码阅读之服务暴露',
        owner: 'limengyu1990',
        repo: 'hexo-blog',
        oauth: {
            client_id: '7cfc73dd62b57f07ed83',
            client_secret: 'dd03b7e54aadf0d81e4c9c93e23a41272bcfcfa1',
        },
    })
    gitment.render('comment-container')
</script>

</html>
