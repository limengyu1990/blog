<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        数据结构与算法-复杂度分析(上) - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 不会Haskell的Scala写不出好的JavaScript。 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>不负如来不负卿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是复杂度分析"><span class="toc-text">什么是复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要进行复杂度分析"><span class="toc-text">为什么要进行复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何进行复杂度分析"><span class="toc-text">如何进行复杂度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#大O表示法的由来"><span class="toc-text">大O表示法的由来</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#大O表示法的特点"><span class="toc-text">大O表示法的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#时间复杂度分析法则"><span class="toc-text">时间复杂度分析法则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常见的时间复杂度级别"><span class="toc-text">常见的时间复杂度级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#空间复杂度"><span class="toc-text">空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例子"><span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#时间复杂度分析"><span class="toc-text">时间复杂度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#O-1"><span class="toc-text">O(1)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#O-logn-、O-nlogn"><span class="toc-text">O(logn)、O(nlogn)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#O-m-n-、O-m-n"><span class="toc-text">O(m+n)、O(m*n)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#空间复杂度分析"><span class="toc-text">空间复杂度分析</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 不会Haskell的Scala写不出好的JavaScript。 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        数据结构与算法-复杂度分析(上)
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2018-10-13 15:04:40</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/blog/tags/#算法" title="算法">算法</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#数据结构" title="数据结构">数据结构</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#复杂度分析" title="复杂度分析">复杂度分析</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p>本小节总结: 时间、空间复杂度分析</p>
<ul>
<li>什么是复杂度分析？</li>
<li>为什么要进行复杂度分析？</li>
<li>如何进行时间、空间复杂度分析？(大O表示法)</li>
</ul>
</blockquote>
<h3 id="什么是复杂度分析"><a href="#什么是复杂度分析" class="headerlink" title="什么是复杂度分析"></a>什么是复杂度分析</h3><ol>
<li>数据結构与算法是为了解决”如何让计算机运行的更快同时更省存储空间”的问题，因此，执行效率是评估一个算法好坏的重要指标。</li>
<li>我们需要从算法执行时间、占用空间两个纬度来评估数据结构和算法的性能。通常使用时间复杂度和空间复杂度来描述性能问题。</li>
<li>复杂度分析描述的是算法执行时间(占用空间)与数据规模的增长关系。</li>
</ol>
<h3 id="为什么要进行复杂度分析"><a href="#为什么要进行复杂度分析" class="headerlink" title="为什么要进行复杂度分析"></a>为什么要进行复杂度分析</h3><p>平时我们会把代码运行一遍，然后通过统计、监控就可以得到算法执行的时间和占用的内存，此方法称为事后统计法，存在很大的局限性。</p>
<ol>
<li>测试结果非常依赖测试环境</li>
<li>测试结果受数据规模的影响很大，我们需要一个不用具体的测试数据进行测试就可以粗略的评估算法执行效率的方法。</li>
<li>掌握复杂度分析，将会编写出性能更优的代码，有利于降低系统开发和维护的成本。</li>
</ol>
<h3 id="如何进行复杂度分析"><a href="#如何进行复杂度分析" class="headerlink" title="如何进行复杂度分析"></a>如何进行复杂度分析</h3><h4 id="大O表示法的由来"><a href="#大O表示法的由来" class="headerlink" title="大O表示法的由来"></a>大O表示法的由来</h4><p>所有代码的执行时间T(n)与每行代码的执行次数n成正比。用大O表示法就是:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	<span class="type">T</span>(n) = <span class="type">O</span>(f(n))</span><br><span class="line">其中:</span><br><span class="line">	<span class="type">T</span>(n) 表示代码执行时间。</span><br><span class="line">	f(n) 表示每行代码执行的次数总和。</span><br><span class="line">	大<span class="number">0</span> 表示代码执行时间 <span class="type">T</span>(n) 与 f(n) 表达式成正比。</span><br></pre></td></tr></table></figure></p>
<p>大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<code>代码执行时间</code>随<code>数据规模增长</code>的变化趋势。因此也叫做渐进时间复杂度，简称时间复杂度。</p>
<h4 id="大O表示法的特点"><a href="#大O表示法的特点" class="headerlink" title="大O表示法的特点"></a>大O表示法的特点</h4><p>以时间复杂度为例，由于时间复杂度描述的是算法<code>执行时间</code>与<code>数据规模增长</code>的变化趋势，所以常量阶、低阶、以及系数实际上对这种增长趋势不产生决定性影响，因此在进行时间复杂度分析时可以省略这些项。</p>
<h4 id="时间复杂度分析法则"><a href="#时间复杂度分析法则" class="headerlink" title="时间复杂度分析法则"></a>时间复杂度分析法则</h4><ol>
<li>只关注循环次数最多的一段代码：比如<code>循环</code>操作</li>
<li>加法法则取量级最大代码复杂度：比如一段代码中有单循环和多重循环，则取<code>多重循环</code>的复杂度。</li>
<li>乘法法则嵌套代码复杂度取乘积: 比如递归、多重循环等，取嵌套内外代码复杂度的乘积。</li>
<li>多个规模求加法：比如方法有两个参数分别控制两个循环的次数，则将两者的复杂度进行相加，即: <code>O(m+n)</code></li>
</ol>
<h4 id="常见的时间复杂度级别"><a href="#常见的时间复杂度级别" class="headerlink" title="常见的时间复杂度级别"></a>常见的时间复杂度级别</h4><ol>
<li><p>多项式阶<br> 随着数据规模的不断增长，算法的执行时间和空间占用，按照多项式的比例增长。从低阶到高阶常见的有(越高阶效率越低)：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">O(<span class="number">1</span>): 常数阶</span><br><span class="line"></span><br><span class="line">O(logn): 对数阶</span><br><span class="line"></span><br><span class="line">O(n): 线性阶</span><br><span class="line"></span><br><span class="line">O(nlogn): 线性对数阶</span><br><span class="line"></span><br><span class="line">O(n^<span class="number">2</span>): 平方阶</span><br><span class="line"></span><br><span class="line">O(n^<span class="number">3</span>): 立方阶</span><br></pre></td></tr></table></figure>
</li>
<li><p>非多项式阶<br> 我们把时间复杂度为非多项式量级的算法问题叫做NP(Non-Deterministic Ploynomial非确定多项式)问题，随着数据规模的不断增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">O(<span class="number">2</span>^n): 指数阶</span><br><span class="line"></span><br><span class="line">O(n!): 阶乘阶</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>空间复杂度和时间复杂度类似，全称为：渐进空间复杂度，表示算法的<code>存储空间</code>和<code>数据规模</code>之间的增长关系。<br>常见的空间复杂度级别有：O(1)、O(n)、O(n^2)，而O(logn)、O(nlogn)这样的对数阶复杂度平时都用不到。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><h5 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> sum = i + j;</span><br></pre></td></tr></table></figure>
<p>只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</p>
<h5 id="O-logn-、O-nlogn"><a href="#O-logn-、O-nlogn" class="headerlink" title="O(logn)、O(nlogn)"></a>O(logn)、O(nlogn)</h5><p>對數階時間複雜度是很常見的，也是很難分析的。看如下例子:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">	i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根據上文分析方法可知第3行是循環執行次數最多的，因此只要知道這行代碼執行的次數，就可以知道整段代碼的時間複雜度。<br>根據代碼可以知道<code>i</code>是從<code>1</code>開始取值的，每次循環都乘以<code>2</code>，當<code>i &lt;= n</code>時，循環結束。<br><code>i</code>的取值就是等比數列，如果列出來就是:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>^<span class="number">0</span> <span class="number">2</span>^<span class="number">1</span> <span class="number">2</span>^<span class="number">2</span> .. <span class="number">2</span>^n .. <span class="number">2</span>^k .. <span class="number">2</span>^x = n</span><br></pre></td></tr></table></figure></p>
<p>因此只要我們算出來x的的值，就可以知道這行代碼的執行次數了:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>^x = n, 求解x</span><br><span class="line"></span><br><span class="line">x = log2n</span><br></pre></td></tr></table></figure></p>
<p>因此，該段代碼的時間複雜度就是<code>O(log2n)</code>.</p>
<p>代碼稍微修改下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123; </span><br><span class="line">	i = i * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据上文的思路可以知道这段代码的时间复杂度为<code>O(log3n)</code>.</p>
<p>实际上，不管是以2为底、以3为底，还是以10为底，我们可以把所有对数阶的时间复杂度都记为<code>O(logn)</code>.<br>因為对数之间是可以互相转换的，<code>log3n</code> 就等于 <code>log32 * log2n</code>，所以 <code>O(log3n) = O(C * log2n)</code>，其中 <code>C = log32</code> 是一个常量。<br>由於采用大<code>O</code>标记复杂度的时候可以忽略系数，即<code>O(Cf(n)) = O(f(n))</code>。所以,<code>O(log2n)</code>就等于<code>O(log3n)</code>。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的”底”，统一表示为<code>O(logn)</code>.</p>
<p>根據<code>乘法法则</code>,如果一段代码的时间复杂度是<code>O(logn)</code>，我们循环执行<code>n</code>遍，时间复杂度就是<code>O(nlogn)</code>了。</p>
<p><code>O(nlogn)</code>也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是<code>O(nlogn)</code>.</p>
<h5 id="O-m-n-、O-m-n"><a href="#O-m-n-、O-m-n" class="headerlink" title="O(m+n)、O(m*n)"></a>O(m+n)、O(m*n)</h5><p>下面的例子中,代码的复杂度由两个数据的规模来决定。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>從代碼中可以看出，<code>m</code>和<code>n</code>表示兩個數據規模，由於我們不知道<code>m</code>和<code>n</code>哪個量級大，因此我們就不可以簡單的使用<code>加法法則</code>,省略掉其中一個，所以時間複雜度為: <code>O(m+n)</code>.</p>
<p>乘法法则继续有效: <code>T1(m) * T2(n) = O(f(m) * f(n))</code></p>
<h4 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h4><p>空间复杂度全称就是<code>渐进空间复杂度</code>，表示算法的<code>存储空间</code>与<code>数据规模</code>之间的增长关系。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    print out a[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和分析時間複雜度一樣，第2行代码中，我们申请了一个空间存储变量<code>i</code>，但是它是<code>常量阶</code>的，跟数据规模<code>n</code>没有关系，所以我们可以忽略.</p>
<p>第<code>3</code>行申请了一个大小为<code>n</code>的<code>int</code>类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是<code>O(n)</code>.</p>
<p>常见的空间复杂度有<code>O(1)</code>、<code>O(n)</code>、<code>O(n2)</code>，像<code>O(logn)</code>、<code>O(nlogn)</code>这样的<code>对数阶</code>复杂度平时都用不到.</p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="https://github.com/bobcn/hexo_resize_image.js"></script>
<script src="/blog/js/index.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/blog/js/gitment.js"></script>
<script>
    var gitment = new Gitment({
        id: '数据结构与算法-复杂度分析(上)',
        owner: 'limengyu1990',
        repo: 'hexo-blog',
        oauth: {
            client_id: '7cfc73dd62b57f07ed83',
            client_secret: 'dd03b7e54aadf0d81e4c9c93e23a41272bcfcfa1',
        },
    })
    gitment.render('comment-container')
</script>

</html>
