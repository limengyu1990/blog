<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        Plutus编写可靠的智能合约 - undefined
        
    </title><meta name="robots" content="noindex">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>不负如来不负卿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UTXO类型记帐"><span class="toc-text">UTXO类型记帐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#智能合约"><span class="toc-text">智能合约</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#智能合约的力量"><span class="toc-text">智能合约的力量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#真实世界和不可替代的代币"><span class="toc-text">真实世界和不可替代的代币</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#可信第三方"><span class="toc-text">可信第三方</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#区块链上的不可替代令牌"><span class="toc-text">区块链上的不可替代令牌</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#贷款"><span class="toc-text">贷款</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ACTUS"><span class="toc-text">ACTUS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ACTUS数据标准"><span class="toc-text">ACTUS数据标准</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ACTUS算法标准"><span class="toc-text">ACTUS算法标准</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#欢迎来到Plutus-可靠智能合约的新语言"><span class="toc-text">欢迎来到Plutus - 可靠智能合约的新语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么Plutus？"><span class="toc-text">为什么Plutus？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关于Plutus框架"><span class="toc-text">关于Plutus框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行Plutus游乐场"><span class="toc-text">运行Plutus游乐场</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Plutus-Tx"><span class="toc-text">Plutus Tx</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Plutus-Tx是什么"><span class="toc-text">Plutus Tx是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编写基础的PlutusTx程序"><span class="toc-text">编写基础的PlutusTx程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数和数据类型"><span class="toc-text">函数和数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Plutus-Tx-的Prelude和内置函数"><span class="toc-text">Plutus Tx 的Prelude和内置函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#提升值"><span class="toc-text">提升值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展的UTXO模型"><span class="toc-text">扩展的UTXO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Scripts"><span class="toc-text">Scripts</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Validator-Redeemer和Data-Scripts"><span class="toc-text">Validator, Redeemer和Data Scripts</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#附加扩展模型说明"><span class="toc-text">附加扩展模型说明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#共享Plutus代码"><span class="toc-text">共享Plutus代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#回滚和其他扩展UTXO模型注意事项"><span class="toc-text">回滚和其他扩展UTXO模型注意事项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用脚本添加分类帐功能"><span class="toc-text">使用脚本添加分类帐功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编写链下代码"><span class="toc-text">编写链下代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#触发器"><span class="toc-text">触发器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Slot-Ranges-插槽范围"><span class="toc-text">Slot Ranges(插槽范围)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#我们的第一个链上代码"><span class="toc-text">我们的第一个链上代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有参数的合约"><span class="toc-text">有参数的合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多阶段合约"><span class="toc-text">多阶段合约</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#建立复杂的交易"><span class="toc-text">建立复杂的交易</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#超越Ada并使用任意自定义代币"><span class="toc-text">超越Ada并使用任意自定义代币</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个复杂的例子-安全的不可替代代币"><span class="toc-text">一个复杂的例子: 安全的不可替代代币</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结尾"><span class="toc-text">结尾</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#词汇表"><span class="toc-text">词汇表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#References"><span class="toc-text">References</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Plutus编写可靠的智能合约
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2021-01-08 21:37:53</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/blog/tags/#Plutus" title="Plutus">Plutus</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#DApps" title="DApps">DApps</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#智能合约" title="智能合约">智能合约</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Cardano" title="Cardano">Cardano</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本书教您如何使用<code>IOHK</code>为区块链上的智能合约开发的新型通用语言<code>Plutus</code>编写可靠的智能合约。快来探索Plutus的世界，并通过现实场景和示例代码片段学习我们的新语言！</p>
<h3 id="UTXO类型记帐"><a href="#UTXO类型记帐" class="headerlink" title="UTXO类型记帐"></a>UTXO类型记帐</h3><p>为了精通<code>Plutus</code>的所有功能，不可避免的是，您必须首先对<code>Cardano</code>平台上的记账处理方式有深刻的了解。</p>
<p>传统上，我们将资金转移视为在两个银行帐户之间进行转移，或者在数字货币的情况下可能是在互联网地址之间进行。 与许多其他加密货币平台（例如比特币）一样，Cardano平台使用的是称为UTXO风格的记账方法。可在Cardano分类帐正式规范的一部分中找到此类会计的完整正式描述，请参见[7]。</p>
<p>UTXO风格的记账记录的不是帐户之间的资金流，而是交易之间的资金流。每笔交易都有输入（花费的钱来自哪里）和输出（这笔钱要到哪去）。<br>请注意，事务主体还可能包含其他数据，正如我们稍后在”扩展UTXO模型”一章中检查扩展UTXO模型时所看到的。</p>
<p>请考虑下面的数据流程图，UTXO资金流示例:</p>
<p><img src="Plutus编写可靠的智能合约/flow.jpg" alt=""></p>
<p>黑线表示<code>unspent</code>(未使用)的交易输出，红线表示将这些输出用作后续交易的输入。</p>
<p>垂直未标记的框表示具有多个输入和多个输出的单个交易。</p>
<p>蓝色证书表示插图中剩余的未使用输出。</p>
<p>请注意，在此数据流图的开始处, <code>Alice</code>在此图的开始时间之前的未使用输出中有100个Ada - 这笔钱来自该图范围之外的一项或多项交易。我们用一个盒子(标有她的名字和100个Ada)抽象它。此盒子有两条黑色（输出）线，这些输出的总和总计为100个Ada):</p>
<ul>
<li>先前的58个Ada输出仍未被Alice使用，并且是她最终<code>unspent</code>(未使用)输出的一部分</li>
<li>Alice未使用的输出中的42<code>Ada</code>成为新交易的一部分</li>
</ul>
<p>现在，Bob从先前未使用的输出中获得了10个Ada。并通过如下步骤花费它们：</p>
<ul>
<li>所有10个Ada都转到新交易中</li>
</ul>
<p>我们在此说明的这项新交易有两个输入，<code>Alice</code>输入42，<code>Bob</code>输入10。<br>此交易有两个输出，Bob有2个Ada，Charlie有50。<br>我们还看到，<code>Charlie</code>从先前未使用的输出中提取了52个Ada，他总共可以在以后的交易中花费102个Ada。鲍勃只剩下一个2 Ada的输出，而<code>Alice</code>其他交易未使用的输出总共有58个Ada。</p>
<p>上面的模型严格显示了几个参与者之间的货币流动。<br>在此简化版本中，所示的交易无需支付费用,等等。<br>即使在这个经过简化的模型中，我们也看到一个输出必须始终用尽。也就是说，一个<code>unspent</code>(未使用)输出的记录无法被修改（这将是基于帐户的簿记），只能被完全使用。</p>
<p>为了维护分类帐簿记的完整性，新交易必须具有所有正在使用的未使用输出（合计所有未使用输出的正确数量）。在上面的示例中，我们的新交易从Alice中删除了(即用作输入)未使用的输出值42和Bob的值10，总计52个Ada。<br>然后，我们必须从该交易中获得52个Ada的输出(2个Ada到Bob，50个Ada到Charlie）。请注意，Bob既有该交易使用的未使用输出，也有该交易产生的未使用输出。 就是说，他从这次交易中得到了（2 Ada）的变化。 由于没有真正的方法来花费部分输出，因此这是UTXO记账处理部分支出的方式 - 通过添加”change”输出。</p>
<p>在此请注意，这种记账方式可以方便（即使不是很直观）将现金流从多个贡献者分配到多个接收者，也就是将其流入一个普通的罐子，（即交易），然后再发送给预期的收款人。<br>从广义上讲，这是智能合约的目标。<br>让我们更正式地探讨在处理UTXO事务事件期间发生了什么。<br>对于我们在此处讨论的基本交易模型，请参考基本UTXO定义。</p>
<p>基本UTXO定义:<br><img src="Plutus编写可靠的智能合约/defined.jpg" alt=""></p>
<p>在查看交易结构之前，<br>让我们看看如何在分类帐上进行簿记。包含此信息的分类账上的记录称为<code>UTXO</code>，<code>Unspent Transaction Outputs</code>的简写，在图中表示为<code>UTXO</code>。该记录是一个有限映射，其中的键是一对事务ID和一个索引，<code>TxIn = TxId * Ix</code>。交易ID<code>TxId</code>可以从提交进行处理的完整交易中计算得出，并且是该交易的唯一标识符。索引<code>Ix</code>是必需的，因为可能有多个输出，并且每个索引必须在给定事务的一组输出中具有唯一的标识符。UTXO有限映射中的值是一对硬币值和一个地址，其类型为<code>TxOut = Addr * Coin</code>。<br>请注意，用户地址始终是公共密钥，<br>并且他们身上的资金属于能够证明他们拥有相应私钥的实体。<br>脚本（或智能合约）地址略有不同，我们将在后面看到。</p>
<p>至于交易本身的结构，让我们首先检查输出。单个交易可以将其花费的钱分配到几个不同的地址。<br>输出（类型为<code>TxOut</code>的值）作为有限映射中的值存储在交易中。<br>有限映射的键是有限映射上下文中的不同索引值，因此交易ID和索引的组合将成为交易输出的全局唯一标识符。 在UTXO记帐方案中，我们通过此复合全局标识符将输出值与输入值相关联。</p>
<p>输入是不关心顺序的，是一个集合而不是列表。<br>该集合的元素既不包含要花费的硬币值，也不包含金钱来自的地址。<br>这是传统会计和UTXO会计之间的主要区别：所花的钱仅由当前驻留在区块链上的分类账上先前处理的交易的未花费输出来指代。<br>输入集的每个元素都是一对交易ID和一个索引，如上所述，它们唯一地标识了要花费的UTXO中未使用的输出。</p>
<p>处理交易涉及以某种方式更新分类帐上的UTXO，以使正在处理的交易花费的资金可供输出中列出的地址的所有者花费。即，从分类账UTXO中删除了与已处理交易输入对应的所有条目。</p>
<p>此外，交易输出的有限映射中的所有<code>TxOut</code>值都添加到<code>UTXO</code>中，该有限映射的键由正在处理的交易的ID组成，索引值与此交易的输出的有限映射一样。</p>
<p>也就是说，如果<code>tx</code>包含一对输入对和ID为<code>id</code>的输出<code>（in，outs）</code>的有限映射，并且<code>ix |→ (a，c)</code>是输出的条目，则UTXO将添加条目<code>(id，ix）|→ (a，c)</code>。 在这里，我们使用符号<code>k | → v</code>来引用有限映射中具有键<code>k</code>和值<code>v</code>的条目。</p>
<p>现在，我们想用数学符号（这是人类可读的）来简洁地捕获此更新，但是可以将其直接转换为代码.我们在解释将<code>Plutus Tx scrips</code>包含在交易中时也将坚持使用此符号。<br>以下定义是过滤UTXO有限映射的三种方法：</p>
<ul>
<li>第一个是通过键的子集<code>ins</code>来过滤UTXO。</li>
<li>第二个过滤器补充了第一个过滤器的结果（即，所有UTXO条目没有由输入列表中的键索引）。</li>
<li>第三个过滤器按值过滤UTXO条目。</li>
</ul>
<p><img src="Plutus编写可靠的智能合约/filter.jpg" alt=""></p>
<p>我们希望使用这种表示法来处理新交易。<br>也就是说，删除用完的输出，并构建交易添加到UTXO的一组新输出(如上所述).<br>我们可以如下计算输出：</p>
<p><img src="Plutus编写可靠的智能合约/compute.jpg" alt=""></p>
<p>使用这种表示法，我们可以根据交易<code>tx</code>定义UTXO更新，如下所示：</p>
<p><img src="Plutus编写可靠的智能合约/defined-out.jpg" alt=""></p>
<p>注意，作为验证交易的一部分，必须对交易的输出中的Ada总量和所有输入中的Ada总量进行显式计算。<br>除了被添加为UTXO条目外，Ada还用于输入。最主要的是库房，它作为一种价值记录在分类账上。例如，交易费用和保证金已支付到库房中。交易中也可能有没有相应输入的输出条目-这些是由于从奖励地址收集奖励而引起的。</p>
<p>现在，为了验证一项交易，需要进行大量的计算，包括交易中的<code>Ada</code>和分类账上其他账户中的<code>Ada</code>，以确保<code>Ada</code>既不被创建也不被销毁。这被称为广义<code>accounting</code>(会计/记账)属性<br>UTXO记帐方案提供内置保护，以防止给定输出的重复支出。 这种固有的保护，加上广义会计属性的执行，确保不允许出现不诚实的支出。这是卡达诺分类帐簿记系统的一个关键属性，特别是因为存在一个固定数量的Ada，它永远不会改变。</p>
<p>还要注意，交易还包括大量其他数据，如<code>witnesses</code>(见证人)、证书和脚本及其哈希。在这里，我们没有详细介绍Cardano分类账实现中使用的特定类型和计算，但是您现在应该对交易的结构以及如何处理交易有了充分的了解，以便能够理解在使用<code>Plutus</code>代码生成交易时幕后发生了什么。</p>
<h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><p>传统合同是关于贷款、销售、租赁等具有法律约束力的协议。智能合同试图从合同的概念中消除”协议”的这一元素，代之以一种软件，以确保任何相关方都不能通过疏忽或恶意行为破坏合同。这是通过放弃对个人、公司或政府行为的依赖，转而依赖计划或智能合约的执行来实现的，以控制合约参与者之间的资金转移。在区块链的账本上永久化程序及其结果。具体来说，参与者只通过分布式加密账本参与智能合约。这确保了整个历史（包括合同的当前状态）以高度的可靠性不可更改地记录下来。</p>
<p>从智能合约作者的角度来看，区块链是一个分布式簿记系统。区块链上的分类账是一个记录，记录谁拥有多少虚拟资源（比特币、Ada等）以及资产何时从一个实体转移到另一个实体。<br>数字资产的所有者是通过他们的公钥来识别的，他们可能是人，也可能是机器。</p>
<p>在Cardano区块链上，在区块链上运行的智能合约程序是用一种称为Plutus Core的语言编写的。然而，智能合约的作者并不直接编写Plutus Core。Plutus平台（将在下一章讨论）是一个软件开发工具包（SDK），使您能够轻松地编写智能合约，包括最终将作为<code>Plutus Core</code>在区块链上运行的逻辑。</p>
<p>现在，我们将智能合约作为概念进行一些启发，考虑和限制，并讨论称为ACTUS的金融合约用例的详尽分类。<br>在下一章中，我们将解释软件的特定部分以及它们在构建，编译和执行智能合约中所扮演的角色。</p>
<h4 id="智能合约的力量"><a href="#智能合约的力量" class="headerlink" title="智能合约的力量"></a>智能合约的力量</h4><p>让我们从广义的角度来讨论智能合约的功能。构建Plutus智能合约平台的目标是能够对尽可能广泛的合约类型进行建模，因此我们的目标是使其尽可能通用。然而，智能合约只是一个行为完全确定的程序，它不能通过法律制度或其他强制手段迫使参与者以某种方式行事。智能合约也不是参与者签署的具有法律约束力的文件。</p>
<p>智能合约的威力在于它能够充当一个受信任的实体，所有其他参与者都可以根据参与合约的要求将其部分资产转移到该实体。在执行智能合约的方式中，参与者只能直接向该程序捐款或其他代币，而不能向其他参与者捐款，从而剥夺了他们滥用资金和违反合约所代表的协议的机会。</p>
<p>然后，资源将根据合同规则进行重新分配，但永远不会在无限长的时间内锁定合同。这种永远不会无限期锁定参与者资金的特性是任何设计良好的智能合约的关键特征，我们将在接下来的章节中看到如何在某些Plutus智能合约示例的设计中确保这一点。通常，在作者设定的超时时间，返还给合同的所有资金都会退还，但是，根据合同的状态，在超时时发生的情况还有其他选择。</p>
<p>此外，合同程序的代码可供所有签订合同的参与者使用，从而使他们能够就是否参加合同做出明智的决定。这些是智能合约确保人类行为者很难执行不诚实行为的某些方式。</p>
<p>使用可信程序负责合约中涉及的代币的想法作为确保可预测结果的基础<br>可以很容易地想到将这种范例应用于现有问题的各种用例。通过一个示例可以最好地说明智能合约的目的和功能，我们将在本书中继续使用该示例。 让我们考虑一个众筹活动。这种类型的资源转移计划可以解释为智能合约程序。</p>
<p>任何基本的人群资助者的总体计划通常是相同的。 参与者能够为这一事业做出贡献，希望在某个日期之前筹集的总资金超过提供众筹产品的实体所设定的最低金额。 如果筹集了足够的资金，则该产品将被制造出来并发送给贡献者。 如果不是，则不生产任何产品，并将所有资金退还给贡献者。<br>在这里，我们可以立即记下合同在众筹者功能中的作用。 此类合同的目的是，在达到目标金额的情况下，开展活动的实体必须同意它将为提供者提供产品，否则退还所缴的款项。使用智能合约，可以强制执行。<br>合同的执行是指由以下两种类型的事件触发而导致的合同状态更改：</p>
<p>•合同外部环境的变化，例如时间的流逝，以及<br>•有关参与者的行动<br>在合同执行期间的不同时间点，可以允许不同的当事人从合同中收取资金，也可以要求他们向合同中付款。</p>
<h4 id="真实世界和不可替代的代币"><a href="#真实世界和不可替代的代币" class="headerlink" title="真实世界和不可替代的代币"></a>真实世界和不可替代的代币</h4><p>尽管我们可以通过简单地在区块链上执行来在合同参与者之间强制进行正确的资金转移，但是将真实世界中的项目作为智能合同中的代币进行竞争有些棘手。在深入研究Plutus功能的技术说明之前，务必将此类挑战告知读者。<br>在处理现实生活中必须转移所有权的物品时，有两种最流行的选择，特别是那些没有相关所有权文件的物品（如大多数小规模物品，如猫、家具等）。</p>
<h5 id="可信第三方"><a href="#可信第三方" class="headerlink" title="可信第三方"></a>可信第三方</h5><p>第一种方法是让一个可信的第三方证人确认所涉物品确实到达了预定的接收者。该方应了解物品的真实命运，并受到原所有人和预期新所有人的信任。这在合同的执行中引入了信任元素，这正是区块链技术想要消除的。不过，但是，在这种情况下，信任将仅限于双方均离线同意的无利益关系方。 在这种解决方案的实现中必须发生的是：</p>
<ul>
<li>发送对象的一方、接收方和受信任的第三方各自做出选择：<ul>
<li>或者他们认为目标接收者收到了物品</li>
<li>或者它没有</li>
</ul>
</li>
<li>至少三分之二的人选择确认收到代币</li>
<li>合同执行其代码的分支，对应于成功的项目转移</li>
</ul>
<p>仅需要三分之二的各方同意，原因是，如果原始所有者和接收者在项目是否已成功易手上存在分歧，那么受信任的第三方可以通过投票来解决分歧。</p>
<p>例如，该方案在实施代管合同方面可能很有用（在接下来的章节中，我们将使用Plutus看到一个智能合同示例）。如果第三方确认成功接收托管物品，则该物品的卖方将获得款项。如果第三方未确认接收，托管合同中的款项将被退还。请注意，如果买方和卖方都确认买方收到物品，而受信任的第三方没有确认，则托管资金仍将分配给卖方，但”受信任”存在可疑之处。</p>
<p>一个可信的第三方方案也可以用来确认众筹活动的所有参与者都收到了资助的产品。在这种情况下，成功的转移分支机构将把资金释放给第三方托管的项目的卖方。<br>但是，在现实中这将相当困难-这个受信方是否需要四处走动，以确认正确且无缺陷的物品已交付给每个预期的收件人？ 我们是否需要多个受信任的第三方？ 如何选择它们？<br>这种情况可能需要更具创造性的代币跟踪解决方案，<br>或与真正的合同整合在一起，可能因未能分发众筹项目而导致法律后果。</p>
<p>现在，在其中一个捐助者没有收到他们资助的项目的情况下，合同的制定者将面临一项决定。<br>如果一个人没有收到他们的物品，一种选择是退款给每个人；另一种选择是发起一个退款给每个人。<br>该选择取决于合同的目的，合同必须适应的现实情况，创建者的偏好等。</p>
<p>回想一下，智能合约的重要特征之一是永远不会锁定其中的资金。因此，如果合约的作者选择等待预定时间，以使受信任的第三方确认所有转移， 在这段时间过后，每个贡献者都必须获得退款。<br>有可能（尤其是在Plutus平台上）在超时后选择锁定在合同中的资金的另一种重新分配方式。 但是，在某一方未能在给定时间范围内履行合同的预期职责（从而阻碍合同的执行）时，为每个参与者全额退款通常是最自然的选择。</p>
<h5 id="区块链上的不可替代令牌"><a href="#区块链上的不可替代令牌" class="headerlink" title="区块链上的不可替代令牌"></a>区块链上的不可替代令牌</h5><p>另一种解决方案是利用区块链上的不可替代令牌。<br>不可替代的代币是其价值不直接与特定货币（在我们的情况下为Ada）绑定的代币。</p>
<p>这种令牌的许多可能示例之一是咖啡。即使是经过特殊烘焙的咖啡，也无法保证在不同时间或来自不同卖方的价格相同。由于供求关系的变化，其价格将习惯性地波动。<br>这些类型的令牌不会自动彼此自动交换，也不能自动交换一定数量的货币。在出售或交换每个此类代币时，双方必须商定价格（或在交易的情况下为另一个不可替代的代币）</p>
<p>可以通过唯一ID在区块链上跟踪这些类型的令牌，该ID与地址相关联，因此与所有者相关联，类似于常规的所有权文档。 我们将讨论如何在扩展的UTxO模型中准确构造这样的唯一ID。<br>我们将在后面章节介绍如何处理自定义令牌。</p>
<h4 id="贷款"><a href="#贷款" class="headerlink" title="贷款"></a>贷款</h4><p>现实世界中存在的项目，而不仅仅是存在于区块链中的项目，并不是构建最广泛的智能合约的唯一问题。贷款是另一种类型的合同，其中如果不诉诸法律行动的威胁，则很难取代信任的内容。</p>
<p>从本质上讲，贷款是一种合同，其中一方承诺（将来）支付其目前没有的钱。解决该问题的一种方法是再次依靠第三方。这次，合同依靠该方提前提供贷款。这并不是完全明智的解决方案，部分破坏了贷款的目的-如果有一方愿意冒险承担贷款的全部价值（包括利息），并且没有从合同中受益，为什么这笔贷款甚至是必要的？</p>
<p>还有另一种方法来构建智能合约贷款及其变体。可以在区块链上引入不可替代的代币，即获得贷款的实体交换必须支付给贷款方的总价值（即贷款加利息）。这甚至允许重新协商贷款条款，可能会改变贷款代币的价值。在支持非货币代币的智能合约平台上，这是一种非常有前途的贷款管理方法，前提是有一些现实世界的法律保证在未付款的情况下为贷款人提供支持。还有另一种方法来构建智能合约贷款及其变体。可以在区块链上引入不可替代的代币，即获得贷款的实体交换必须支付给贷款方的总价值（即贷款加利息）。这甚至允许重新协商贷款条款，可能会改变贷款代币的价值。在支持非货币代币的智能合约平台上，这是一种非常有前途的贷款管理方法，前提是有一些现实世界的法律保证在未付款的情况下为贷款人提供支持。</p>
<h4 id="ACTUS"><a href="#ACTUS" class="headerlink" title="ACTUS"></a><a href="https://www.actusfrf.org/" target="_blank" rel="noopener">ACTUS</a></h4><p>ACTUS是一个正在进行的项目，旨在将所有（或几乎所有）金融合同的分类或分类定义为少量组。 几家主要的金融公司（包括Ariadne，Deloitte和Stevens理工学院）共同创建了这一通用标准。</p>
<p>根据《证券法》的定义，金融合同是:</p>
<ul>
<li>以单独协商的合同、协议或选择权的形式进行的一种安排，用于购买、出售、出借、交换或回购，或金融市场参与者通常达成的其他类似的单独协商的交易。</li>
</ul>
<p>ACTUS认识到有两种不同的方式来看待金融合同，这两种方式由两个不同的学科描述：</p>
<h5 id="ACTUS数据标准"><a href="#ACTUS数据标准" class="headerlink" title="ACTUS数据标准"></a>ACTUS数据标准</h5><ul>
<li>数据标准定义了一组通用的法律术语（或CT属性），在不同的金融协议中用作参数。它是以数据字典的形式实现的，具有按合同类型分类的属性适用性。</li>
</ul>
<h5 id="ACTUS算法标准"><a href="#ACTUS算法标准" class="headerlink" title="ACTUS算法标准"></a>ACTUS算法标准</h5><ul>
<li>算法标准定义了嵌入在法律协议中的逻辑，这些逻辑最终将合同条款转化为实际现金流，或者更一般地说是业务事件。</li>
</ul>
<p>两个标准都有描述几乎所有金融合同的工具，ACTUS的目标是确保两个标准所描述的内容的语义是相同的。ACTUS分类根据基本算法结构将合同分为若干组。对于同一分类组中的合同，进行大致相同的计算以确定合同的执行。同一组合同之间的差异通常表现在算法中某些参数的取值上。ACTUS网站上提供了每个小组内合同的正式规范。</p>
<p>我们在这里讨论ACTUS分类方法的原因是，在Plutus中实现ACTUS契约的想法在概念上是非常令人兴奋的，这是一个重大的现实世界的实际进展。从ACTUS网站上，</p>
<blockquote>
<p>最近的金融危机暴露了风险管理和金融监管方面的严重缺陷。回顾过去，在能够支持财务分析的数据标准中，缺乏及时报告的细粒度数据是造成危机的主要原因。ACTUS项目旨在通过创建金融工具一致表示的全球标准来弥补这一弱点。</p>
</blockquote>
<p>金融合同包括诸如期货，贷款债券，抵押等之类的东西。实质上，金融合同是仅处理货币转移和有关未来货币转移的承诺的合同。 这些类型的合同受外部事件（例如股票的市场价值等）的影响。它们通常也是现实世界中所有权变化的结果，这种抵押将用于购买房屋。 但是，它们处理两种主要类型的令牌，</p>
<ul>
<li>货币，</li>
<li>以及合约或金融产品本身（例如股票或期货）</li>
</ul>
<p>这使得金融合同成为智能合同实施的完美候选。货币已经是区块链可以追踪的代币类型中的巨星——毕竟，Cardano是一个加密货币平台。交易合同和金融产品也可以在支持智能合约的分类账上建模。在本书接下来的章节中，我们非常兴奋地探索将所有ACTUS合约表示为智能合约实现的方法。</p>
<h3 id="欢迎来到Plutus-可靠智能合约的新语言"><a href="#欢迎来到Plutus-可靠智能合约的新语言" class="headerlink" title="欢迎来到Plutus - 可靠智能合约的新语言"></a>欢迎来到Plutus - 可靠智能合约的新语言</h3><h4 id="为什么Plutus？"><a href="#为什么Plutus？" class="headerlink" title="为什么Plutus？"></a>为什么Plutus？</h4><p>我们使用高保证软件（尤其是智能合约）的方法背后的秘密是使用高级类型系统的函数式编程。Plutus是一个功能开发和执行平台，用于Cardano结算和计算层的分布式合同应用程序。它提供了一个平台，您可以在这个平台上开发和部署应用程序，它的设计考虑了三个主要受众：开发人员、业务专家和学术界。Plutus嵌入在Haskell中，Haskell程序员很熟悉它，但它比Haskell本身更易于分析。</p>
<p>通过使用Plutus，您可以对正确执行智能合约充满信心。它借鉴了现代语言研究的成果，以领先的纯函数式编程语言Haskell为基础，提供了一个安全的、全栈的编程环境。Plutus提供了相当大的安全优势。它提供了一种更简单、更健壮的方式来显示您的智能合约是正确的，并且不会遇到以前智能合约语言设计中发现的问题。</p>
<p>Plutus为智能合约和分布式应用程序开发提供了一种新的集成方法，比以前的替代方案更方便、更安全。链上和链下代码都基于相同的语言。智能合约开发人员使用统一的代码库，然后Plutus工具链会自动将其分为链上和链下代码和包进行部署。‌Plutus是基于函数式编程语言比传统的命令式和面向对象编程语言更适合于安全和可验证的程序的思想而设计的。‌‌它的设计简洁明了，所面临的挑战是它可以放在餐巾纸上。这个简化的代码是由团队实现的，如图所示：</p>
<p><img src="Plutus编写可靠的智能合约/img.jpg" alt=""></p>
<p>为开发人员提供了一个SDK，其中包括开始使用Plutus所需的库、API、工具和文档。作为此SDK的一部分，Plutus游乐场可用于测试您的Plutus用例和代码。这是一个用于探索性Plutus开发的轻量级、基于web的测试环境。在这里，您可以轻松地编写和部署合同，而无需安装和维护完整的开发环境和区块链。一旦Plutus与Cardano完全集成，就可以将您在Plutus游乐场开发的合同部署到Cardano区块链本身的结算层。在Plutus 游乐场中开发的合同使用与部署到Cardano mainnet的相同的编程语言和库接口。</p>
<h4 id="关于Plutus框架"><a href="#关于Plutus框架" class="headerlink" title="关于Plutus框架"></a>关于Plutus框架</h4><p>‌Plutus由多个部件组成，这些部件紧密地协同工作。Plutus平台是用于定义用于编写智能合约的组合软件支持的术语，包括用于在Haskell中编写链外代码的库、用于在Plutus事务（Plutus Tx）中编写链上代码的库以及用于测试智能合约的仿真器支持。‌Plutus Core是指实际的语言，一种设计成链上代码运行的小型函数式编程语言。Plutus Tx是Haskell的一个子集，编译成Plutus Core，Plutus IR是编译成Plutus Core的中间语言，用作编译器编写者的目标语言。</p>
<p>Plutus Playground（简称PP）是一个工具，用于编写和测试用于构建智能合约的任何代码，并定义钱包能够参与合约的端点（例如，向脚本付款、获得退款等）。PP编辑器中定义的另一段主要代码是一个函数，该函数生成一个脚本，该脚本将包含在扩展UTxO模型中钱包所生成的交易主体中。由时间和其他外部因素驱动的合同执行，以及用户的操作，将由Playground工具根据此脚本中的定义进行模拟。在游乐场工具中编写的代码不会与区块链或任何钱包中的数据交互。取而代之的是，它使用了模拟版本，称为mockchain和mock wallet。</p>
<p>请注意，本书打算与最新的PP Web版本同步更新。当两个版本之间存在重大，相关或值得注意的区别时，我们将讨论最新源代码版本中的某些功能。</p>
<h4 id="运行Plutus游乐场"><a href="#运行Plutus游乐场" class="headerlink" title="运行Plutus游乐场"></a>运行Plutus游乐场</h4><p>使用Plutus Playground的最简单方法是使用稳定版本。<br>要使用我们在本书中讨论的版本，并使本书的内容保持同步，请参见<br>Alpha版本。<br>在此地址，读者将看到一个用于开发Plutus Tx代码的窗口。 窗口中的代码是用户可以编辑的单个Haskell模块。 还有其他两个选项卡，<code>Simulation</code>和<code>Transactions</code>，这两个选项卡都用于测试在编辑器中编写的代码。<br>选项卡下面还列出了几个演示，这些演示的代码可以加载到编辑器中：Crowdfunding，Game，Messages和Vesting示例。 我们将在相应的示例章节中讨论这些内容。 还有一个指向Plutus教程的链接，该教程与本书的各章都有很多内容。</p>
<p>有关高级用法的说明，包括设置Plutus Playground的本地Docker映像，或在本地使用Haskell库，请参阅Plutus存储库README。</p>
<h3 id="Plutus-Tx"><a href="#Plutus-Tx" class="headerlink" title="Plutus Tx"></a>Plutus Tx</h3><h4 id="Plutus-Tx是什么"><a href="#Plutus-Tx是什么" class="headerlink" title="Plutus Tx是什么"></a>Plutus Tx是什么</h4><p>Plutus Tx是我们为Haskell程序的特殊分隔部分指定的名称，该程序将被编译为Plutus Core（通常在交易中进行，因此称为<code>Tx</code>）。因此，生成的Plutus Core表达式可以是交易数据或存储在分类帐中的数据的一部分。这些代码段需要在区块链上进行特殊处理，被称为Plutus脚本。 在下一章扩展的UTXO模型中，我们将讨论它们用于控制资金转移的机制。</p>
<p>Haskell程序中的这些特殊的Plutus Tx部分本身就是Haskell。 严格来说，只支持Haskell的一个子集，但是大多数简单的Haskell都可以工作，并且编译器会告诉您是否使用了不受支持的内容。本章介绍了Plutus Tx语言。 有关Plutus Tx编译到的Plutus Core本质的深入讨论，请参见[2]。</p>
<p>Plutus平台使用的关键技术称为分阶段元编程。这意味着Haskell主程序会生成另一个程序，在本例中为将在区块链上运行的Plutus Core程序。Plutus Tx是我们用来编写这些程序的机制。事实上，它只是Haskell，这意味着我们可以使用与主程序相同的技术，并且我们可以在两者之间共享类型和定义。</p>
<h4 id="编写基础的PlutusTx程序"><a href="#编写基础的PlutusTx程序" class="headerlink" title="编写基础的PlutusTx程序"></a>编写基础的PlutusTx程序</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">-- Necessary language extensions for the Plutus Tx compiler to work.</span></span><br><span class="line">  <span class="meta">&#123;-# LANGUAGE TemplateHaskell     #-&#125;</span></span><br><span class="line">  <span class="meta">&#123;-# LANGUAGE DataKinds           #-&#125;</span></span><br><span class="line">  <span class="meta">&#123;-# LANGUAGE ScopedTypeVariables #-&#125;</span></span><br><span class="line"><span class="keyword">module</span> Tutorial.PlutusTx <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Language.PlutusTx 1⃣️</span><br><span class="line"><span class="keyword">import</span> Language.PlutusTx.Lift 2⃣️</span><br><span class="line"><span class="keyword">import</span> Language.PlutusTx.Builtins 3⃣️</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Language.PlutusCore</span><br><span class="line"><span class="keyword">import</span> Language.PlutusCore.Pretty</span><br><span class="line"><span class="keyword">import</span> Language.PlutusCore.Quote</span><br><span class="line"><span class="keyword">import</span> Language.PlutusCore.Evaluation.CkMachine </span><br><span class="line"><span class="keyword">import</span> Data.Text.Prettyprint.Doc 4⃣️</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 主要的Plutus Tx模块</li>
<li>2⃣️ 对于lifting的额外支持</li>
<li>3⃣️ 内置函数</li>
<li>4⃣️ 用于示例</li>
</ul>
<p>Plutus Tx使用了模板Haskell。这有几个原因：</p>
<ul>
<li>模板Haskell允许我们在编译时（即我们进行Plutus Tx编译时）进行工作。</li>
<li>它允许我们连接实际调用Plutus Tx编译器的机器。</li>
</ul>
<p>因此，我们将看到模板Haskell引号的一些用法。模板Haskell quote使用特殊的括号<code>[||</code>和<code>||]</code>，类型为<code>Q(TExp A)</code>。这意味着它表示一个<code>a</code>类型的表达式，它位于引号的<code>Q</code>类型中。可以使用<code>$$</code>运算符将此类型的定义拼接到程序中。</p>
<blockquote>
<p>还有一个缩写<code>TExpQ a</code>表示<code>Q(TExp a)</code>，它避免了一些括号</p>
</blockquote>
<p>我们将使用的关键函数是<code>compile</code>。 <code>compile</code>的类型为<code>TExpQ a → TExpQ (CompiledCode a)</code>。这是什么意思？ -我们已经看见<code>TExpQ</code> - <code>CompiledCode a</code>是一个已编译的<code>Plutus Core</code>程序，对应于类型为<code>a</code>的Haskell程序</p>
<p>这意味着<code>compile</code>允许您获取（<code>quoted</code>(引用的)）Haskell程序，并将其转换为（引用的）<code>Plutus Core</code>程序，然后您可以将其拼接到主程序中。在编译Haskell主程序时会发生这种情况（因为这是运行模板Haskell的时候）。</p>
<p>如果你已经知道阶段元编程，你可能会感到困惑。我们不应该在运行时而不是编译时生成<code>Plutus Core</code>程序吗？这会很方便，但是我们需要Haskell编译器来帮助我们编译任意Haskell，所以我们必须在编译时这样做。稍后我们将看到，我们可以在运行时将一些值从Haskell提升到Plutus Core，这足以让我们编写依赖于运行时值的程序。</p>
<p>重申一下：<code>compile</code>需要<code>Template Haskell</code>引用，因此您在引号内编写的内容只是正常的Haskell。</p>
<p>下面是我们可以编写的最基本的程序：一个计算结果为整数1的程序。</p>
<blockquote>
<p>Plutus Core语法看起来不熟悉。 很好，因为它是”汇编语言”，您无需检查编译器的输出。但是，出于本章的目的，对其进行研究很有启发性，以使您对正在发生的事情有一个模糊的想法。</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;-|</span></span><br><span class="line"><span class="comment">  &gt;&gt;&gt; pretty $ getPlc integerOne</span></span><br><span class="line"><span class="comment">  (program 1.0.0</span></span><br><span class="line"><span class="comment">    (con 8 ! 1)</span></span><br><span class="line"><span class="comment">-&#125;</span></span><br><span class="line"><span class="title">integerOne</span> :: <span class="type">CompiledCode</span> <span class="type">Integer</span> </span><br><span class="line"><span class="title">integerOne</span> = $$(compile <span class="number">3</span>⃣️ <span class="number">4</span>⃣️</span><br><span class="line">    [||                 <span class="number">2</span>⃣️</span><br><span class="line">        (<span class="number">1</span> :: <span class="type">Integer</span>)  <span class="number">1</span>⃣️</span><br><span class="line">    ||])</span><br></pre></td></tr></table></figure>
<p>1⃣️ 我们始终在Plutus Core中使用无界整数，因此我们必须将此数字字面量固定为<code>Integer</code>而不是<code>Int</code>。</p>
<p>2⃣️ 引用的类型为<code>TExpQ Integer</code>。</p>
<p>3⃣️ <code>compile</code>将<code>TExpQ Integer</code>放入<code>TExpQ (CompiledCode Integer)</code>.</p>
<p>4⃣️ 拼接(<code>$$</code>符号)将<code>TExpQ (CompiledCode Integer)</code>插入程序。</p>
<p>我们可以在这里看到元编程的工作原理：Haskell程序<code>1</code>在编译时变成了<code>CompiledCode Integer</code>，我们将其拼接到Haskell程序中，然后可以在运行时进行检查以查看生成的Plutus Core（或放在区块链上）。</p>
<p>适应这里最重要的事情是我们在第一个示例中看到的模式：一个<code>TH</code>引号包裹在对<code>compile</code>的调用中，然后包裹到<code>$$</code>拼接中。这就是我们编写所有Plutus Tx程序的方式。</p>
<p>这里有一个稍微复杂一点的程序，即整数的恒等式函数。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&#123;- |</span></span><br><span class="line"><span class="comment">  &gt;&gt;&gt; pretty $ getPlc integerIdentity</span></span><br><span class="line"><span class="comment">  (program 1.0.0</span></span><br><span class="line"><span class="comment">    (lam ds [(con integer) (con 8)] ds)</span></span><br><span class="line"><span class="comment">  )</span></span><br><span class="line"><span class="comment">-&#125;</span></span><br><span class="line"><span class="title">integerIdentity</span> :: <span class="type">CompiledCode</span> (<span class="type">Integer</span> -&gt; <span class="type">Integer</span>) </span><br><span class="line"><span class="title">integerIdentity</span> = $$(compile [|| \(x:: <span class="type">Integer</span>) -&gt; x ||])</span><br></pre></td></tr></table></figure>
<p>到目前为止，如此熟悉：我们将一个lambda编译为一个lambda(“lam”)。</p>
<h4 id="函数和数据类型"><a href="#函数和数据类型" class="headerlink" title="函数和数据类型"></a>函数和数据类型</h4><p>您还可以在表达式内使用函数。实际上，您通常会希望将<code>Plutus Tx</code>程序的整体定义为引号之外的定义，然后只需在引号内对其进行调用。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# INLINABLE plusOne #-&#125;</span> <span class="number">2</span>⃣️</span><br><span class="line"><span class="title">plusOne</span> :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span> </span><br><span class="line"><span class="title">plusOne</span> x = x `addInteger` <span class="number">1</span> <span class="number">1</span>⃣️</span><br><span class="line"></span><br><span class="line"><span class="meta">&#123;-# INLINABLE myProgram #-&#125;</span> <span class="number">2</span>⃣️</span><br><span class="line"><span class="title">myProgram</span> :: <span class="type">Integer</span></span><br><span class="line"><span class="title">myProgram</span> =</span><br><span class="line">    <span class="keyword">let</span></span><br><span class="line">        plusOneLocal :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span> </span><br><span class="line">        plusOneLocal x = x `addInteger` <span class="number">1</span> <span class="number">1</span>⃣️</span><br><span class="line">        localPlus = plusOneLocal <span class="number">1</span></span><br><span class="line">        externalPlus = plusOne <span class="number">1</span></span><br><span class="line">    <span class="keyword">in</span> localPlus `addInteger` externalPlus <span class="number">1</span>⃣️</span><br><span class="line"></span><br><span class="line"><span class="title">functions</span> :: <span class="type">CompiledCode</span> <span class="type">Integer</span> </span><br><span class="line"><span class="title">functions</span> = $$(compile [|| myProgram ||])</span><br></pre></td></tr></table></figure>
<ul>
<li><p>1⃣️ <code>addInteger</code>来自<code>Language.PlutusTx.Builtins</code>，并且映射到Plutus Core中的内置整数加法。</p>
</li>
<li><p>2⃣️ 可重用的函数以GHC的<code>INLINABLE</code>实用程序标记。非本地函数通常必须在<code>Plutus Tx</code>块中使用，因为它指示GHC保留<code>Plutus Tx</code>编译器所需的信息。尽管这并非总是必要的，但最好将所有此类函数标记为<code>INLINABLE</code>。</p>
</li>
</ul>
<p>我们可以自由使用普通的Haskell数据类型和模式匹配：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">matchMaybe</span> :: <span class="type">CompiledCode</span> (<span class="type">Maybe</span> <span class="type">Integer</span> -&gt; <span class="type">Integer</span>) </span><br><span class="line"><span class="title">matchMaybe</span> = $$(compile [|| \(x:: <span class="type">Maybe</span> <span class="type">Integer</span>) -&gt; <span class="keyword">case</span> x <span class="keyword">of</span></span><br><span class="line">     <span class="type">Just</span> n -&gt; n</span><br><span class="line">     <span class="type">Nothing</span> -&gt; <span class="number">0</span></span><br><span class="line">   ||])</span><br></pre></td></tr></table></figure></p>
<p>与函数不同，数据类型不需要在表达式内部使用任何特殊的注释，因此我们可以使用Prelude中的<code>Maybe</code>之类的类型。这也适用于您自己的数据类型！</p>
<p>下面是一个小示例，其中我们自己的数据类型表示一个潜在的开放结束日期。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- | Either a specific end date, or "never".</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">EndDate</span> = <span class="type">Fixed</span> <span class="type">Integer</span> | <span class="type">Never</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | 检查给定时间是否超过结束日期。</span></span><br><span class="line"><span class="title">pastEnd</span> :: <span class="type">CompiledCode</span> (<span class="type">EndDate</span> -&gt; <span class="type">Integer</span> -&gt; <span class="type">Bool</span>)</span><br><span class="line"><span class="title">pastEnd</span> = $$(compile [|| \(end::<span class="type">EndDate</span>) (current::<span class="type">Integer</span>) -&gt; <span class="keyword">case</span> end <span class="keyword">of</span></span><br><span class="line">        <span class="type">Fixed</span> n -&gt; n `lessThanEqInteger` current</span><br><span class="line">        <span class="type">Never</span> -&gt; <span class="type">False</span></span><br><span class="line">    ||])</span><br></pre></td></tr></table></figure></p>
<h4 id="Plutus-Tx-的Prelude和内置函数"><a href="#Plutus-Tx-的Prelude和内置函数" class="headerlink" title="Plutus Tx 的Prelude和内置函数"></a>Plutus Tx 的Prelude和内置函数</h4><p><code>Language.PlutusTx.Prelude</code>模块是常规Haskell Prelude的直接替代品，但重新定义了某些功能，以使Plutus Tx编译器更易于处理。 每当编写希望使用Plutus Tx编译器编译的代码时，都应使用Plutus Tx Prelude。</p>
<p>为了使用<code>Plutus Tx Prelude</code>, 需要使用<code>NoImplicitPrelude</code>语言标记并导入<code>import Language.PlutusTx.Prelude</code>.</p>
<p>Plutus Tx具有一些可用于处理原始数据（整数和字节串）的内置类型和功能，以及一些特殊功能。 这些内建函数也从Plutus Tx Prelude中导出。</p>
<p>内置的<code>error</code>值得一提。<code>error</code>会导致交易在评估时中止，这是发出验证失败的信号的方法。</p>
<h4 id="提升值"><a href="#提升值" class="headerlink" title="提升值"></a>提升值</h4><p>到目前为止，我们已经看到了如何静态地定义代码片段（当您编译主Haskell程序时），但是您可能希望动态地定义代码片段（当您运行主Haskell程序时）。例如，您可能正在编写交易主体以启动众筹智能合约，这需要通过用户输入来确定目标的大小、活动开始和结束时间等参数化。</p>
<p>您可以通过将静态代码编写为一个函数，然后在运行时传递参数（通过<code>lifting</code>它，然后将两个程序一起应用）来实现此目的。 作为一个非常简单的示例，让我们编写一个<code>addOne</code>函数。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">addOne</span> :: <span class="type">CompiledCode</span> (<span class="type">Integer</span> -&gt; <span class="type">Integer</span>)</span><br><span class="line"><span class="title">addOne</span> = $$(compile [|| \(x:: <span class="type">Integer</span>) -&gt; x `addInteger` <span class="number">1</span> ||])</span><br></pre></td></tr></table></figure>
<p>现在，假设我们想在运行时将其应用于<code>4</code>，从而为我们提供了一个计算为<code>5</code>的程序。 好吧，我们需要将参数(<code>4</code>)从Haskell提升到Plutus Core，然后将函数应用到它。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;- |</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; let program = addOneToN 4</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; pretty program</span></span><br><span class="line"><span class="comment">(program 1.0.0</span></span><br><span class="line"><span class="comment"> [</span></span><br><span class="line"><span class="comment">   [</span></span><br><span class="line"><span class="comment">     (lam</span></span><br><span class="line"><span class="comment">        addInteger</span></span><br><span class="line"><span class="comment">        (fun [(con integer) (con 8)] (fun [(con integer) (con 8)] [(con integer) (con 8)]))</span></span><br><span class="line"><span class="comment">        (lam ds [(con integer) (con 8)] [ [ addInteger ds ] (con 8 ! 1) ])</span></span><br><span class="line"><span class="comment">      )</span></span><br><span class="line"><span class="comment">      &#123; (builtin addInteger) (con 8) &#125;</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">    (con 8 ! 4) </span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; pretty $ runCk program</span></span><br><span class="line"><span class="comment">(con 8 ! 5)</span></span><br><span class="line"><span class="comment">-&#125;</span></span><br><span class="line"><span class="title">addOneToN</span> :: <span class="type">Integer</span> -&gt; <span class="type">CompiledCode</span> <span class="type">Integer</span> </span><br><span class="line"><span class="title">addOneToN</span> n =</span><br><span class="line">    addOne</span><br><span class="line">    `applyCode` <span class="number">1</span>⃣️</span><br><span class="line">    unsafeLiftCode n <span class="number">2</span>⃣️</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ <code>applyCode</code>应用一个<code>CompiledCode</code>到另一个</li>
<li>2⃣️ <code>unsafeLiftCode</code>提升参数<code>n</code>到<code>CompiledCode Integer</code></li>
</ul>
<p>我们使用<code>unsafeLiftCode</code>函数提升了参数。为了使用它，一个类型必须具有<code>Lift</code>类的实例。实际上，您应该使用<code>Language.PlutusTx.Lift</code>中的<code>makeLift</code>TH函数生成它们。提升功能使得在<code>Plutus Tx</code>程序内部以及使用该程序的外部代码中都可以轻松使用相同的类型。</p>
<blockquote>
<p><code>unsafeLiftCode</code>是”不安全的”，因为它会忽略因<code>lifting</code>不受支持的内容而可能发生的任何错误。</p>
</blockquote>
<p>组合程序将原始已编译的lambda应用于提升后的值（请注意，由于我们已将加法运算编译为内置函数，因此lambda有点复杂了）。然后，我们使用了Plutus Core的<code>CK</code>评估程序来评估程序并检查结果是否符合我们的预期.</p>
<p>这是我们的自定义数据类型的示例。输出是<code>False</code>的编码版本。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">makeLift</span> ''<span class="type">EndDate</span></span><br><span class="line"><span class="comment">&#123;- |</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; let program = pastEndAt Never 5</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; pretty $ runCk program</span></span><br><span class="line"><span class="comment">(abs</span></span><br><span class="line"><span class="comment">  out_Bool (type) (lam case_True out_Bool (lam case_False out_Bool case_False))</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">-&#125;</span></span><br><span class="line"><span class="title">pastEndAt</span> :: <span class="type">EndDate</span> -&gt; <span class="type">Integer</span> -&gt; <span class="type">CompiledCode</span> <span class="type">Bool</span> </span><br><span class="line"><span class="title">pastEndAt</span> end current =</span><br><span class="line">    pastEnd</span><br><span class="line">    `applyCode` unsafeLiftCode end </span><br><span class="line">    `applyCode` unsafeLiftCode current</span><br></pre></td></tr></table></figure></p>
<h3 id="扩展的UTXO模型"><a href="#扩展的UTXO模型" class="headerlink" title="扩展的UTXO模型"></a>扩展的UTXO模型</h3><p>本章旨在帮助读者更清楚地了解Plutus在Cardano-Shelley区块链账本中的位置。在这里，我们将对扩展的UTXO模型进行高层次的解释，并向读者介绍使用<code>scripts</code>(脚本)作为在区块链上制定智能合约的工具的想法。在本章中，我们使用并构建了UTXO风格记账一章中的概念和符号。</p>
<p>在基本的UTXO模型中，用于授权交易的方案是可靠的，但有些基础。 它也仅限于严格的<code>Ada</code>会计。<br>扩展的UTXO模型为基于UTXO的Cardano区块链带来了以太坊基于帐户的<code>scripting</code>模型表达的重要部分，其中包括智能合约支持。该扩展包含两个组件：</p>
<ul>
<li><code>交易</code>所携带的数据的扩展以及节点所执行的相应处理方案</li>
<li>钱包后端的扩展，便于协调链上计算执行的链外代码。<ul>
<li>请注意，扩展的UTXO钱包必须有权访问分类帐数据，以便能够随时查看（或查找）指定地址的输出</li>
</ul>
</li>
</ul>
<p>在本章中，我们重点讨论第一部分。在扩展的UTXO模型中，必须进行额外的链上计算来验证交易。如果没有<code>scripts</code>，Shelley分类账UTXO状态更新规则基本上由两个步骤组成（当然，这两个步骤都是由节点执行的计算，并且都是链上的）:</p>
<ol>
<li>检查交易是否有效，包括验证以下内容：<ul>
<li>它是活动的（交易时间尚未过去）</li>
<li>花费的Ada值为非负</li>
<li>广义记账属性持有</li>
<li>交易金额不超过最大金额</li>
<li>费用正在支付</li>
<li>等等</li>
</ul>
</li>
<li>检查事务正在执行的每个操作是否由相应的私钥的持有者<code>witnessed</code>(见证)<ul>
<li>每个输出的支出（由key持有人见证，用于支出资金的地址）</li>
<li>领取奖励（由奖励地址的抵押密钥的持有人见证）</li>
<li>每个证书的应用（由证书作者见证）</li>
<li>genesis(创始) key delegations</li>
</ul>
</li>
</ol>
<p>对于这种类型的记账的详细形式描述，我们将读者再次引向[7]。扩展Cardano分类帐功能的主要方法是在第二步中添加<code>script</code>功能。</p>
<h4 id="Scripts"><a href="#Scripts" class="headerlink" title="Scripts"></a>Scripts</h4><p>回想一下Plutus Tx一章，脚本（特别是Plutus脚本）是交易携带的Plutus核心表达式（或者存储在分类账上）。它们是在Haskell程序的一个特殊分隔的部分中定义的，称为Plutus Tx，然后编译成Plutus Core。</p>
<p>脚本是将智能合约功能添加到扩展的UTXO模型的一种方式。 本书的许多后续章节都讨论了定义特定智能合约的构建脚本。 但是，在本节中，我们通常讨论扩展的UTXO模型中如何使用脚本。 有关带有脚本的扩展UTXO模型的正式规范的草案，请参见[8]。</p>
<p>脚本(如<code>witnesses</code>(见证人))是确保事务仅执行授权操作的另一种工具。<code>witnessing</code>(见证)输出(非脚本)支出的目的是通过检查输出是否确实由该密钥签名(见证)来验证支出该输出的钱包是否具有与相应UTXO条目中的地址(即支出资金的地址)相关联的私钥。</p>
<p>脚本<code>s :: Script</code>有自己的地址<code>a :: Addr_script</code>，可以向其付款。该脚本地址是脚本的哈希值。因此，对于脚本，我们要检查交易（以及生成该交易的钱包）是否具有该地址为哈希值的原始脚本。整个验证程序脚本本身永远不会存储在分类帐中，仅存储其哈希，并且仅作为属于该脚本的未使用的UTXO条目的地址。</p>
<p>脚本的作用不是在当前事务中生成额外的输入或输出（或产生新事务）。<br>脚本仅用于验证给定事务是否正在消耗未使用的输出，是否允许这样做。此脚本锁定方法仅与UTXO中与脚本地址相关联的那些输出有关，这意味着这些输出属于脚本。</p>
<p>例如，回想一下众筹活动计划。 如果运动的所有者是时候收集捐款了，他的钱包应该产生一个带有输入的交易，该输入对应于资助者的捐赠（即分类账UTXO中的条目，在<code>Addr</code>字段中具有该众筹合同的脚本地址）。</p>
<p>此交易的输出必须与贡献者的输入加上交易费用的总和相同，可能在每个交易的<code>Addr</code>字段中有所有者自己的地址。</p>
<p>这种交易所携带的脚本的目的将是证明对UTXO条目的这种使用是被授权的，例如 达到了活动目标，并且在当前时间间隔内，允许所有者收取捐款。</p>
<p>钱包需要计算费用，或者将其添加到输入中，或者在可能的情况下将其减去到输出中。<br>确切的行为应该由用户配置。请注意，更改输入和输出会影响交易费用。但是，还要注意，费用总是可以预先计算并全额支付的，因为携带脚本的事务附带了验证它所需的所有输入、输出和其他数据。因此，不存在交易费用不足的问题。</p>
<p>在这里，我们必须注意的是，使用这个脚本授权一个输出的开销时会用到一些数据，包括<code>validator</code>(验证器)脚本、<code>redeemer</code>(赎回者)脚本、<code>data</code>(数据)脚本和合同的数据类型等。这些都是Plutus非常重要的特性，并且是使执行依赖合同状态的验证成为可能的工具。我们将在下一节中讨论每种方法的作用，并在后面的每个示例中解释每种方法的用法。</p>
<h4 id="Validator-Redeemer和Data-Scripts"><a href="#Validator-Redeemer和Data-Scripts" class="headerlink" title="Validator, Redeemer和Data Scripts"></a>Validator, Redeemer和Data Scripts</h4><p><code>Validator</code>脚本是带有几个输入参数的Plutus Core函数，它们也是Plutus Core表达式。</p>
<ol>
<li>Validator script<ul>
<li>由一笔交易携带的脚本地址中的资金<ul>
<li>在交易内部，<code>Validator</code>脚本存储为一个有限映射，由该脚本的哈希索引</li>
</ul>
</li>
<li>是下面讨论的以下3种类型的函数<ul>
<li>data script</li>
<li>redeemer script</li>
<li>交易和分类帐数据</li>
</ul>
</li>
<li>返回一个布尔值，表示验证结果</li>
</ul>
</li>
<li>Data script<ul>
<li>由支付给脚本的交易携带<ul>
<li>在交易中，数据脚本由输出的索引<code>ix</code>索引，该索引用于向脚本付款</li>
</ul>
</li>
<li>包含有关给定智能合约的状态信息，例如<ul>
<li>众筹活动参与者的公钥，或</li>
<li>参与者必须猜猜单词的哈希值才能赢得合同锁定的资金</li>
</ul>
</li>
<li>全部存储在分类帐中</li>
<li>当脚本验证需要时计算的哈希值，不存储在链上</li>
</ul>
</li>
</ol>
<p>回想一下，在经典模型中，UTXO条目的形式是<code>(txid，ix) |→ (a，c)</code>.</p>
<p>对于扩展模型，如果<code>a :: Addr_script</code>是脚本地址，我们必须将其他数据存储在分类帐中，该分类帐将UTXO条目的键<code>(txid，ix)</code>与支付给该脚本的交易携带的数据脚本相关联。请注意，在交易内部，只能使用索引值来查找数据脚本。 在UTXO上，交易ID也包含在用于查找数据脚本的密钥中。 这是承载它的交易的ID。</p>
<ol start="3">
<li>Redeemer script<ul>
<li>由从脚本地址花费资金的交易携带<ul>
<li>在事务中，<code>Redeemer</code>脚本通过其预期使用的<code>validator</code>(而不是<code>Redeemer</code>本身)的哈希索引</li>
</ul>
</li>
<li>通常代表钱包选择采取的行动，例如<ul>
<li>从脚本中收集资金</li>
<li>退还对脚本的付款</li>
<li>猜测一个单词</li>
</ul>
</li>
<li>给定其他输入数据(即数据脚本，分类帐状态和携带交易数据)，只有<code>redeemer</code>脚本的唯一值才会导致<code>validator</code>的评估结果为true。</li>
<li>值从不存储在链上，只作为交易数据的一部分出现</li>
<li>当<code>script</code>验证需要时计算的哈希值，不存储在链上</li>
</ul>
</li>
</ol>
<p>当执行特定动作的条件得到满足时（即，用户执行特定动作或达到特定时间），此<code>script</code>值必须由钱包确定性地生成。<br>合同的开发人员有责任确保事件触发器、端点和<code>validator script</code>的定义正确无误。</p>
<ol start="4">
<li>一个<code>PendingTx</code>值.<ul>
<li>包含有关当前交易的信息<ul>
<li>输入和输出</li>
<li>有效期等</li>
</ul>
</li>
<li>还包含有关分类帐状态的信息，该信息由进行交易验证的特定节点提供</li>
</ul>
</li>
</ol>
<p>当我们说输出被脚本锁定或属于脚本地址时，这意味着该UTXO条目的地址是某个验证程序脚本的哈希（不是赎回者，也不是数据脚本）。<br>这种使用哈希的地址模型与经典的UTXO模型中的地址相距不远，经典的UTXO模型中的地址类型包含<code>paying</code>(付款)和<code>staking</code>(锁定)(public，即验证)密钥。</p>
<p>与常规地址一样，使用<code>script</code>地址实际上可以完成两件事。可以创建与其关联的UTXO条目(即，支付给脚本)，并消费与该脚本关联的条目。支付给脚本的交易必须具有输出<code>ix |→ (a，c)</code>，以使地址<code>a</code>是它要支付的<code>validator</code>脚本的哈希值(由钱包进行链下计算)。它必须另外带有与此索引<code>ix</code>相关联的<code>data</code>脚本。它甚至可以携带多个<code>data</code>脚本，并在同一合同的多个不同状态下付款(当然，输出不同)。<br>无需使用散列到此处的<code>validator</code>来执行<code>script</code>验证。<br>实际上，处理此类事务的节点确实需要在此处完全看到原始验证器，除非这个相同的交易也是从相同的脚本地址开始消费的。</p>
<p>现在，为了证明交易<code>ix</code>确实有权使用<code>validator</code>脚本锁定的输出，进行验证的节点必须将<code>validateScript</code>函数应用于该<code>validator</code>脚本，以及上面的三个参数，这实际上是将<code>validator</code>应用于三个参数的计算。<br>由于这三个脚本的类型不同，因此有必要在这里使用这样的泛型求值器函数。正如<code>Plutus Tx</code>一章所指出的，<code>data</code>和<code>redemiter</code>脚本可以是由<code>template Haskell</code>生成的不同类型的<code>Plutus Core</code>表达式，<br>因此，泛型<code>alidateScript</code>函数所知道的就是这三种类型的脚本。但是，<code>validator</code>本身期望的是其必须在其上计算的确切类型的项，例如一个公钥类型的项作为数据脚本参数。</p>
<p>总而言之，节点计算</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">validateScript</span> vld dsc rdm</span><br></pre></td></tr></table></figure>
<p>where</p>
<ul>
<li>验证器<code>vld</code>来自交易数据并散列到与交易所花费的分类帐<code>UTXO</code>条目的地址相等的值</li>
<li>数据脚本<code>dsc</code>存储在分类帐中，并与交易正在花费的<code>UTXO</code>条目相关联(可以通过该条目作为关键字来查找)</li>
<li><code>redeemer rdm</code>是钱包(或其所有者)在生成交易时执行的操作的选择，直接来自交易数据</li>
</ul>
<p>为了使验证成功，合同(验证者)必须在给定状态的上下文中允许选择操作。 请注意，本着UTXO风格记帐的精神，合同状态永远不会在UTXO条目中更新。 您只能使用该条目，并使用不同的数据脚本创建一个新条目。</p>
<p>如果此<code>validateScript</code>计算返回true，则验证过程将继续。否则，将取消整个交易。本质上，给定分类账状态和携带交易数据的上下文，<code>validator</code>(验证器)用于显示所提供的操作(<code>redeemer</code>)确实会导致正确的状态(数据脚本)，这意味着代码定义的智能合约功能在验证器中允许花费脚本拥有的资金。</p>
<p>请注意，与传统的UTXO模型一样，使用此模型，未验证的交易不会产生费用。但是，与经典模型不同，扩展模型允许从不属于生成交易的钱包的脚本地址进行支出。这是因为必须提供<code>validator</code>脚本（而不是私钥）才能从该地址使用，并且脚本是公开可用的。</p>
<p>读者稍后还会注意到，在我们讨论编写一个完整的<code>Plutus</code>合同时，返回<code>PlutusTx</code>验证程序脚本的<code>off-chain</code>函数接受一个参数。对于每种合同，此参数的类型不同。例如，对于众筹合同，它将是<code>Campaign</code>类型的术语:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">contributionScript</span> :: <span class="type">Campaign</span> → <span class="type">ValidatorScript</span></span><br></pre></td></tr></table></figure>
<p>任何类型的合同的此参数都是一种数据结构，其中包含有关合同的必要的非状态，不变的数据(例如，<code>campaign</code>所有者的公钥)。通过此数据结构参数传递给验证器的值不仅用于在验证器中定义某些合同功能，而且还用于合同识别。通常，以这种方式来定义此无状态合同结构参数的类型是一个好主意，即，该参数必须使生成的合同具有唯一性，从而使其验证者哈希地址也具有唯一性。 这样，用户就可以（例如）准确地支付他们想要的众筹实例的费用，而不会意外地以<code>top hat</code>(大礼帽)代替<code>Plutus</code>教科书！</p>
<h4 id="附加扩展模型说明"><a href="#附加扩展模型说明" class="headerlink" title="附加扩展模型说明"></a>附加扩展模型说明</h4><h5 id="共享Plutus代码"><a href="#共享Plutus代码" class="headerlink" title="共享Plutus代码"></a>共享Plutus代码</h5><p>下一章将详细介绍的链下代码是由用户的钱包(或在<code>Playground</code>模拟器中为<code>mock</code>钱包)运行的。链下代码的主要目标是在正确的时间生成正确的脚本，并构建携带该脚本的事务。</p>
<p>回想一下，<code>Plutus Playground</code>是一个平台，可以在该平台上编写链上和链下代码，以在模拟链上模拟智能合约功能。在模拟过程中，模拟钱包共享在<code>Playground</code>中编写的所有代码，并且任何钱包都可以使用。</p>
<p>在真实的Cardano区块链环境中，链上和链下合约代码应由参与该合约并通过网络分发的所有钱包使用。这意味着需要另一种可靠的方式共享Plutus代码。链上代码被散列，并且散列存储在UTXO中，为参与者提供了一种方法来验证它确实是正确合同的正确代码。链下代码只是生成脚本和交易的一种方式，然后将其作为交易处理的一部分进行验证和认证。因此，没有必要使用区块链为其真实性提供额外的保证-仅通过像GitHub这样的可靠代码存储库共享此类代码就足够了。</p>
<p>然而，与编写和理解法律合同所需的法律诀窍类似，智能合约的创建者和用户需要对Plutus代码有足够的了解，才能相信合约正在做他们期望的事情。在这种情况下，加密安全是无能为力的——这就是这本书的用武之地！</p>
<h5 id="回滚和其他扩展UTXO模型注意事项"><a href="#回滚和其他扩展UTXO模型注意事项" class="headerlink" title="回滚和其他扩展UTXO模型注意事项"></a>回滚和其他扩展UTXO模型注意事项</h5><p>鉴于区块链事件（如交易确认）可以触发链外协调代码的执行，我们需要仔细考虑需要回滚依赖于回滚交易的任何操作的含义。这里不提供此功能的详细信息。</p>
<p>扩展UTXO系统还有其他一些与Plutus用户不太相关的特性，我们在本章中也不会详细解释。</p>
<h5 id="使用脚本添加分类帐功能"><a href="#使用脚本添加分类帐功能" class="headerlink" title="使用脚本添加分类帐功能"></a>使用脚本添加分类帐功能</h5><p>在本书的后续示例中，我们将引导读者逐步完成Plutus合同的构建，测试和使用过程。<br>有关使用脚本向UTXO分类帐添加特定功能的工作示例，我们希望向读者介绍以下文档，</p>
<ul>
<li>UTXO分类帐上的多币种，请参阅<a href="https://github.com/input-output-hk/plutus/tree/master/docs/multi-currency" target="_blank" rel="noopener">4</a><ul>
<li>一种基于脚本的模型的实现，用于模拟链上不同类型的货币和不可替代的代币</li>
</ul>
</li>
<li>使用脚本的多重签名方案的正式规范，参见<a href="https://github.com/input-output-hk/cardano-ledger-specs" target="_blank" rel="noopener">9</a><ul>
<li>强制执行针对<code>spending outputs</code>(支出输出)的自定义<code>witnessing</code>(见证)策略的正式规范 </li>
</ul>
</li>
</ul>
<h3 id="编写链下代码"><a href="#编写链下代码" class="headerlink" title="编写链下代码"></a>编写链下代码</h3><p>使用Plutus需要编写链上代码和链外代码，这两部分可以很好地协同工作。在开始编写代码之前，我们将简要介绍完整的Plutus合约的组成，以及链上和链下代码在其中的作用。</p>
<p>Plutus合约</p>
<ul>
<li>Plutus合约是Haskell程序，<ul>
<li>可在用户的钱包中运行</li>
<li>也向区块链提交代码(脚本)以供节点运行</li>
</ul>
</li>
<li>在Plutus智能合约定义中，我们有端点<ul>
<li>端点是钱包执行的函数，用于参与正在定义的智能合约（通常由用户输入数据参数化）</li>
<li>端点是链下函数</li>
<li>端点用于构建事务并提交以进行处理</li>
<li>端点调用生成<code>Plutus Tx</code>代码(特别是<code>validator</code>,<code>redeemer</code>和<code>data scripts</code>)的函数，这些代码将包含在事务中并由节点在链上执行</li>
</ul>
</li>
<li>除端点外，Plutus合约定义可能还包含<ul>
<li>所有必要的<code>imports</code></li>
<li>数据类型定义，表示有关合同特定实例的不可变信息，例如合同的所有者以及合同中涉及的任何截止日期，例如<code>Campaign</code>(活动)或<code>Game</code>(游戏)</li>
<li>为合同构建<code>validator</code>,<code>redeemer</code>和<code>data scripts</code>的函数，通常由该类型的术语(<code>Campaign</code>、<code>Game</code>等)参数化</li>
<li>用于端点执行的事件触发器和处理程序定义</li>
<li>计算所需的任何附加功能</li>
</ul>
</li>
<li>链下(端点)代码可以由任何通过<code>wallet monad</code>实现特定API的钱包执行(如下所述)<ul>
<li>这允许钱包执行特定于钱包的计算，包括构建事务、捕获和抛出错误、记录消息等。</li>
</ul>
</li>
<li>链上(<code>Plutus Tx</code>)代码在编译时生成<ul>
<li>在Plutus合约中定义并包含在端点生成的交易中</li>
<li>由节点执行以授权交易的<code>spending</code>(支出)脚本输出</li>
</ul>
</li>
<li>Plutus合约至少应包含端点，这些端点通过使用<code>validator</code>(验证器)，<code>redeemer</code>(救世主)和<code>data scripts</code>(数据脚本)来生成交易，使用户能够<ul>
<li>向合同支付（这涉及使用<code>validator</code>和<code>redeemer</code>脚本来创建属于合同的<code>unspent</code>(未使用)输出）</li>
<li>从合同中支出（这将要求节点在特定的<code>validator</code>，<code>redeemer</code>和<code>data scripts</code>上执行链上计算以解锁正在<code>spent</code>(消耗)的输出）</li>
</ul>
</li>
</ul>
<p>让我们先看看Plutus合同的链下部分，这些代码将由钱包执行。<br>在任何实现<code>MonadWallet</code>的monad中，此类代码都由<code>monadic</code>计算表示:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">MonadWallet</span> (<span class="title">m</span> :: * -&gt; *) = (<span class="type">WalletAPI</span> <span class="title">m</span>, <span class="type">WalletDiagnostics</span> <span class="title">m</span>) :: <span class="type">Constraint</span></span></span><br></pre></td></tr></table></figure></p>
<p>通过编写独立于monad特定选择的代码，我们确保它在不同的钱包实现中运行，尤其是Plutus Playground的模拟钱包和实际的Cardano钱包。<br>那么<code>WalletAPI</code>和<code>WalletDiagnostics</code>的约束是什么？<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">MonadError</span> <span class="type">WalletAPIError</span> m =&gt; <span class="type">WalletDiagnostics</span> (<span class="title">m</span> :: * -&gt; *) <span class="keyword">where</span></span></span><br><span class="line">  logMsg :: <span class="type">Text</span> -&gt; m ()</span><br></pre></td></tr></table></figure></p>
<p>因此，这使我们可以抛出并捕获错误(<code>WalletAPIError</code>类型)并记录诊断消息。<br>让我们尝试一下写个<code>Hello World</code>的链下Plutus代码：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE OverloadedStrings #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE NoImplicitPrelude #-&#125;</span> <span class="number">1</span>⃣️</span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TemplateHaskell #-&#125;</span> <span class="number">2</span>⃣️</span><br><span class="line"><span class="meta">&#123;-# OPTIONS_GHC -fno-warn-missing-signatures #-&#125;</span> <span class="number">3</span>⃣️</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> OffChain.Hello <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Language.PlutusTx.Prelude 4⃣️</span><br><span class="line"><span class="keyword">import</span> Playground.Contract</span><br><span class="line"><span class="keyword">import</span> Wallet</span><br><span class="line"></span><br><span class="line"><span class="title">hello</span> :: <span class="type">WalletDiagnostics</span> m =&gt; m () </span><br><span class="line"><span class="title">hello</span> = logMsg <span class="string">"Hello from the wallet!"</span></span><br><span class="line"></span><br><span class="line">$(mkFunctions ['hello]) <span class="number">5</span>⃣️</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1⃣️ <code>Plutus</code>带有自己的<code>Prelude</code>，因此我们禁用了标准<code>Haskell Prelude</code>的隐式导入。</li>
<li>2⃣️ <code>TemplateHaskell</code>用于将Haskell类型“提升”为Plutus Core类型，还用于在<code>Playground</code>中提供<code>off-chain</code>链下代码，如我们的示例所示。</li>
<li>3⃣️ <code>Plutus Template Haskell</code>生成的代码缺少类型签名，因此我们禁用了这可能引起的警告。</li>
<li>4⃣️ 我们总是导入<code>Plutus Prelude</code></li>
<li>5⃣️ 使用<code>TemplateHaskell</code>，<code>mkFunctions</code>将使其参数列表中命名的所有函数在<code>Playground</code>上可用。</li>
</ul>
<p>将此代码粘贴到<code>Playground</code>的<code>Editor</code>选项卡中并进行编译，将使<code>hello</code>函数在<code>Simulation</code>选项卡中可用，因此我们可以将其添加为其中一个钱包的<code>action</code>(操作)。</p>
<p><img src="Plutus编写可靠的智能合约/7-01.png" alt=""></p>
<p><code>evaluation</code>(执行)后，我们将在<code>Transactions</code>选项卡的<code>Logs</code>部分中看到预期的消息:</p>
<p><img src="Plutus编写可靠的智能合约/7-02.png" alt=""></p>
<p><code>WalletAPI</code>类更为复杂:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">WalletAPI</span> (<span class="title">m</span> :: * -&gt; *) <span class="keyword">where</span></span></span><br><span class="line">  submitTxn :: <span class="type">Tx</span> -&gt; m ()                                         <span class="number">1</span>⃣️</span><br><span class="line">  ownPubKey :: m <span class="type">PubKey</span>                                           <span class="number">2</span>⃣️</span><br><span class="line">  sign :: <span class="type">ByteString</span> -&gt; m <span class="type">Signature</span>                               <span class="number">3</span>⃣️</span><br><span class="line">  createPaymentWithChange :: <span class="type">Value</span> -&gt; m (<span class="type">Set</span> <span class="type">TxIn</span>, <span class="type">Maybe</span> <span class="type">TxOut</span>)   <span class="number">4</span>⃣️</span><br><span class="line">  registerOnce :: <span class="type">EventTrigger</span> -&gt; <span class="type">EventHandler</span> m -&gt; m ()          <span class="number">5</span>⃣️</span><br><span class="line">  watchedAddresses :: m <span class="type">AddressMap</span>                                <span class="number">6</span>⃣️</span><br><span class="line">  startWatching :: <span class="type">Address</span> -&gt; m ()                                <span class="number">7</span>⃣️</span><br><span class="line">  slot :: m <span class="type">Slot</span>                                                  <span class="number">8</span>⃣️</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1⃣️ 提交一个交易</li>
<li>2⃣️ 获取属于钱包的公钥</li>
<li>3⃣️ 对任意字符串进行加密签名</li>
<li>4⃣️ 创建一组交易输入和可选的交易输出以进行更改，适用于从钱包中支付给定值</li>
<li>5⃣️ 注册事件触发器，以便在触发器条件变为真时立即执行指定的操作</li>
<li>6⃣️ 获取钱包正在监视的地址</li>
<li>7⃣️ 开始监视地址的更改</li>
<li>8⃣️ 获取当前时间(<code>slot</code>)</li>
</ul>
<p>让我们通过重新实现<code>Playground</code>中的<code>payToWallet_</code>函数开始探索<code>WalletAPI</code>，该函数只是向另一个钱包支付一定数量的<code>Ada</code>.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE NoImplicitPrelude               #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TemplateHaskell                 #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# OPTIONS_GHC -fno-warn-missing-signatures #-&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> OffChain.PayToWallet <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Language.PlutusTx.Prelude </span><br><span class="line"><span class="keyword">import</span> Ledger</span><br><span class="line"><span class="keyword">import</span> Ledger.Ada</span><br><span class="line"><span class="keyword">import</span> Playground.Contract </span><br><span class="line"><span class="keyword">import</span> Wallet</span><br><span class="line"><span class="keyword">import</span> Wallet.Emulator.Types (<span class="title">walletPubKey</span>)</span><br><span class="line"><span class="keyword">import</span> Control.Monad (<span class="title">void</span>)</span><br><span class="line"><span class="keyword">import</span> Data.Maybe (<span class="title">maybeToList</span>)</span><br><span class="line"> </span><br><span class="line"><span class="title">myPayToWallet</span> :: <span class="type">MonadWallet</span> m =&gt; <span class="type">Wallet</span> -&gt; <span class="type">Ada</span> -&gt; m () <span class="number">1</span>⃣️</span><br><span class="line"><span class="title">myPayToWallet</span> wallet ada = <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">let</span> pubKey = walletPubKey wallet <span class="number">2</span>⃣️ </span><br><span class="line">      val = toValue ada</span><br><span class="line">      o = pubKeyTxOut val pubKey</span><br><span class="line">  (ins, mo) &lt;- createPaymentWithChange val </span><br><span class="line">  void $ createTxAndSubmit</span><br><span class="line">      defaultSlotRange <span class="number">3</span>⃣️ </span><br><span class="line">      ins</span><br><span class="line">      (o : maybeToList mo)</span><br><span class="line"></span><br><span class="line">$(mkFunctions ['myPayToWallet])</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1⃣️ <code>myPayToWallet</code>函数接受两个参数，用于发送资金的钱包和要发送的金额</li>
<li>2⃣️ 我们可以使用<code>walletPubKey</code>查找一个钱包的公钥</li>
<li>3⃣️ 我们在此处使用<code>defaultSlotRange</code>表示交易将始终有效。</li>
</ul>
<p>与我们的第一个<code>hello</code>示例相反，函数<code>myPayToWallet</code>具有参数。将函数作为<code>action</code>(动作)添加到模拟后，将提示用户在<code>Playground</code>中输入这些值.</p>
<p><img src="Plutus编写可靠的智能合约/7-03.png" alt=""></p>
<p><img src="Plutus编写可靠的智能合约/7-04.png" alt=""></p>
<p>注意我们如何使用<code>createPaymentWithChange</code>来帮助我们构建交易：给定一个值，此函数将选择属于该钱包的合适的<code>unspent</code>(未使用)的交易输出，我们可以将其用作输入。<br>如果输入的总和超过了我们想要转移的值，它还将有选择地创建一个新的交易输出，该更改可以到达该输出。</p>
<p>顺便说一句，向公用密钥支付一些值非常普遍，以至于为此存在辅助函数<code>payToPublicKey</code>和<code>payToPublicKey_</code>(<code>payToPublicKey</code>返回生成的事务，<code>payToPublicKey_</code>不返回).</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">payToPutoblicKey</span> :: (<span class="type">Monad</span> m, <span class="type">WalletAPI</span> m) =&gt; <span class="type">SlotRange</span> -&gt; <span class="type">Value</span> -&gt; <span class="type">PubKey</span> -&gt; m <span class="type">Tx</span> </span><br><span class="line"><span class="title">payToPublicKey_</span> :: (<span class="type">Monad</span> m, <span class="type">WalletAPI</span> m) =&gt; <span class="type">SlotRange</span> -&gt; <span class="type">Value</span> -&gt; <span class="type">PubKey</span> -&gt; m ()</span><br></pre></td></tr></table></figure>
<p>使用<code>payToPublicKey</code>，我们可以将<code>myPayToWallet</code>编写得更简单，如下所示:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myPayToWallet</span> :: <span class="type">MonadWallet</span> m =&gt; <span class="type">Wallet</span> -&gt; <span class="type">Ada</span> -&gt; m () </span><br><span class="line"><span class="title">myPayToWallet</span> wallet ada = <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">let</span> pubKey = walletPubKey wallet </span><br><span class="line">        val = toValue ada</span><br><span class="line">    payToPublicKey_ defaultSlotRange val pubKey</span><br></pre></td></tr></table></figure></p>
<p>现在我们已经了解了如何创建和提交事务，让我们使用<code>registerOnce</code>来注册触发器.</p>
<h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><p>钱包可以通过指定<code>EventTrigger</code>和<code>EventHandler</code>来注册一个或多个触发器。事件触发器定义了一个条件，事件处理程序描述了条件变为<code>true</code>后该做什么.<br>以下函数允许我们构造触发器:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">neverT</span>              :: <span class="type">EventTrigger</span>                                   <span class="number">1</span>⃣️</span><br><span class="line"><span class="title">alwaysT</span>             :: <span class="type">EventTrigger</span>                                   <span class="number">2</span>⃣️</span><br><span class="line"><span class="title">notT</span>                :: <span class="type">EventTrigger</span> -&gt; <span class="type">EventTrigger</span>                   <span class="number">3</span>⃣️</span><br><span class="line"><span class="title">andT</span>                :: <span class="type">EventTrigger</span> -&gt; <span class="type">EventTrigger</span> -&gt; <span class="type">EventTrigger</span>   <span class="number">4</span>⃣️</span><br><span class="line"><span class="title">orT</span>                 :: <span class="type">EventTrigger</span> -&gt; <span class="type">EventTrigger</span> -&gt; <span class="type">EventTrigger</span>   <span class="number">5</span>⃣️</span><br><span class="line"><span class="title">slotRangeT</span>          :: <span class="type">SlotRange</span> -&gt; <span class="type">EventTrigger</span>                      <span class="number">6</span>⃣️</span><br><span class="line"><span class="title">fundsAtAddressGeqT</span>  :: <span class="type">Address</span> -&gt; <span class="type">Value</span> -&gt; <span class="type">EventTrigger</span>               <span class="number">7</span>⃣️</span><br><span class="line"><span class="title">fundsAtAddressGtT</span>   :: <span class="type">Address</span> -&gt; <span class="type">Value</span> -&gt; <span class="type">EventTrigger</span>               <span class="number">8</span>⃣️</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1⃣️ 永远不为true</li>
<li>2⃣️ 总是为true</li>
<li>3⃣️ 给定触发器的逻辑取反</li>
<li>4⃣️ 逻辑<code>conjunction</code>(连接): 当两个触发器都为真时为真</li>
<li>5⃣️ 逻辑<code>disjunction</code>(析取)：当至少一个触发器为真时为真</li>
<li>6⃣️ 检查当前<code>slot</code>(插槽)是否在给定范围内</li>
<li>7⃣️ 如果该地址的资金至少为指定值，则为true</li>
<li>8⃣️ 如果该地址的资金大于指定的值，则为true</li>
</ul>
<blockquote>
<p>触发器<code>fundsAtAddressGeqT</code>和<code>fundsAtAddressGtT</code>只会将那些<code>unspent</code>(未使用)的交易输出存入在注册触发器之后创建的<code>account</code>中.</p>
</blockquote>
<p>事件处理程序定义为:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EventHandler</span> :: (<span class="type">AnnotatedEventTrigger</span> <span class="type">Bool</span> -&gt; m ()) -&gt; <span class="type">EventHandler</span> m</span><br></pre></td></tr></table></figure></p>
<p>类型为<code>AnnotatedEventTrigger</code>的参数允许处理程序检查复合触发器的哪一部分(使用<code>and</code>和/或<code>orT</code>构建的触发器)实际上已变为true。</p>
<p>例如，我们可以编写一个函数，该函数将等待指定的<code>slot</code>直到执行交易：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE NoImplicitPrelude               #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TemplateHaskell                 #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ScopedTypeVariables             #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# OPTIONS_GHC -fno-warn-missing-signatures #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> OffChain.Trigger <span class="keyword">where</span></span><br><span class="line"><span class="keyword">import</span> Language.PlutusTx.Prelude </span><br><span class="line"><span class="keyword">import</span> Ledger</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Ledger.Ada <span class="keyword">as</span> Ada</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Playground.Contract</span><br><span class="line"><span class="keyword">import</span> Wallet</span><br><span class="line"><span class="keyword">import</span> Wallet.Emulator.Types (<span class="title">walletPubKey</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">waitUntil</span> :: <span class="keyword">forall</span> m. <span class="type">MonadWallet</span> m =&gt; <span class="type">Slot</span> -&gt; <span class="type">Wallet</span> -&gt; <span class="type">Ada</span> -&gt; m () <span class="number">1</span>⃣️</span><br><span class="line"><span class="title">waitUntil</span> sl wallet ada = registerOnce trigger handler                <span class="number">2</span>⃣️</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    trigger :: <span class="type">EventTrigger</span>                                           <span class="number">3</span>⃣️</span><br><span class="line">    trigger = slotRangeT $ intervalFrom sl</span><br><span class="line"></span><br><span class="line">    handler :: <span class="type">EventHandler</span> m</span><br><span class="line">    handler = <span class="type">EventHandler</span> $ const $                                  <span class="number">4</span>⃣️</span><br><span class="line">          payToPublicKey_</span><br><span class="line">              defaultSlotRange</span><br><span class="line">              (<span class="type">Ada</span>.toValue ada)</span><br><span class="line">              (walletPubKey wallet)</span><br><span class="line"></span><br><span class="line">$(mkFunctions ['waitUntil])</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 我们给出三个参数，我们要等待的<code>slot</code>(时间段)，我们要向其发送资金的钱包，以及要发送的金额。</li>
<li>2⃣️ 在这里，我们注册触发器</li>
<li>3⃣️ 一旦当前<code>slot</code>(插槽)为指定的插槽，则将触发此操作, 或稍后</li>
<li>4⃣️ 处理程序使用<code>const</code>忽略<code>AnnotatedEventTrigger</code>并执行交易</li>
</ul>
<p><img src="Plutus编写可靠的智能合约/7-05.png" alt=""></p>
<p><img src="Plutus编写可靠的智能合约/7-06.png" alt=""></p>
<p>这实际上是一个不寻常的示例，我们并不需要触发器来达到这种效果，因为我们可以简单地使用交易的<code>slot range</code>来代替：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">waitUntil</span> :: <span class="type">MonadWallet</span> m =&gt; <span class="type">Slot</span> -&gt; <span class="type">Wallet</span> -&gt; <span class="type">Ada</span> -&gt; m () </span><br><span class="line"><span class="title">waitUntil</span> sl wallet ada =</span><br><span class="line">    payToPublicKey_ (intervalFrom sl)        <span class="number">1</span>⃣️</span><br><span class="line">    (<span class="type">Ada</span>.toValue ada) </span><br><span class="line">    (walletPubKey wallet)</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 我们不象以前那样使用<code>defaultSlotRange</code>，而是说只有在到达<code>slot</code>(插槽)<code>sl</code>时，此交易才有效。</li>
</ul>
<h4 id="Slot-Ranges-插槽范围"><a href="#Slot-Ranges-插槽范围" class="headerlink" title="Slot Ranges(插槽范围)"></a><code>Slot Ranges</code>(插槽范围)</h4><p>交易的<code>slot range</code>决定交易在其中有效的<code>slot</code>。我们可以用以下函数构造<code>slot ranges</code>:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">always</span>            :: <span class="type">SlotRange</span> <span class="number">1</span>⃣️</span><br><span class="line"><span class="title">defaultSlotRange</span>  :: <span class="type">SlotRange</span> <span class="number">2</span>⃣️</span><br><span class="line"><span class="title">singleton</span>         :: <span class="type">Slot</span> -&gt; <span class="type">SlotRange</span> <span class="number">3</span>⃣️</span><br><span class="line"><span class="title">interval</span>          :: <span class="type">Slot</span> -&gt; <span class="type">Slot</span> -&gt; <span class="type">SlotRange</span> <span class="number">4</span>⃣️</span><br><span class="line"><span class="title">intervalFrom</span>      :: <span class="type">Slot</span> -&gt; <span class="type">SlotRange</span> <span class="number">5</span>⃣️</span><br><span class="line"><span class="title">intervalTo</span>        :: <span class="type">Slot</span> -&gt; <span class="type">SlotRange</span> <span class="number">6</span>⃣️</span><br><span class="line"><span class="title">intersection</span>      :: <span class="type">SlotRange</span> -&gt; <span class="type">SlotRange</span> -&gt; <span class="type">Maybe</span> <span class="type">SlotRange</span> <span class="number">7</span>⃣️</span><br><span class="line"><span class="title">hull</span>              :: <span class="type">SlotRange</span> -&gt; <span class="type">SlotRange</span> -&gt; <span class="type">SlotRange</span> <span class="number">8</span>⃣️</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 所有<code>slots</code>(插槽)的范围；使用此范围的交易将始终有效。</li>
<li>2⃣️ 默认的<code>slot</code>范围，<code>always</code>的同义词</li>
<li>3⃣️ 专门由指定的<code>slot</code>组成的范围。</li>
<li>4⃣️ 给定两个插槽<code>a</code>和<code>b</code>，<code>interval a b</code>是从<code>a</code>开始并在<code>b</code>之前一个<code>slot</code>结束的范围，因此该范围包含<code>a</code>，但不包含<code>b</code>.</li>
<li>5⃣️ 从给定的插槽(包括在内)开始，并且永不结束的范围。</li>
<li>6⃣️ 在给定的<code>slot</code>之前结束一个<code>slot</code>的范围，不包括在内。</li>
<li>7⃣️ 如果两个给定范围<code>intersection</code>(交叉)，则提供它们的<code>overlap</code>(重叠)。</li>
<li>8⃣️ 包含两个给定范围的最小范围</li>
</ul>
<p>可以使用以下函数检查插槽范围：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">member</span>    :: <span class="type">Slot</span> -&gt; <span class="type">SlotRange</span> -&gt; <span class="type">Bool</span> <span class="number">1</span>⃣️</span><br><span class="line"><span class="title">overlaps</span>  :: <span class="type">SlotRange</span> -&gt; <span class="type">SlotRange</span> -&gt; <span class="type">Bool</span> <span class="number">2</span>⃣️</span><br><span class="line"><span class="title">contains</span>  :: <span class="type">SlotRange</span> -&gt; <span class="type">SlotRange</span> -&gt; <span class="type">Bool</span> <span class="number">3</span>⃣️</span><br><span class="line"><span class="title">isEmpty</span>   :: <span class="type">SlotRange</span> -&gt; <span class="type">Bool</span> <span class="number">4</span>⃣️</span><br><span class="line"><span class="title">before</span>    :: <span class="type">Slot</span> -&gt; <span class="type">SlotRange</span> -&gt; <span class="type">Bool</span> <span class="number">5</span>⃣️  </span><br><span class="line"><span class="title">after</span>     :: <span class="type">Slot</span> -&gt; <span class="type">SlotRange</span> -&gt; <span class="type">Bool</span> <span class="number">6</span>⃣️</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1⃣️ 检查给定的插槽是否包含在给定的范围内。</li>
<li>2⃣️ 检查两个给定范围是否<code>overlap</code>(重叠)，即至少有一个公共插槽。</li>
<li>3⃣️ 检查第一个范围是否完全包含第二个范围，即第二个范围的所有成员是否都是第一个范围的成员。</li>
<li>4⃣️ 此范围是否为空，即不包含任何插槽？</li>
<li>5⃣️ 检查给定的插槽是否早于给定范围的开始。</li>
<li>6⃣️ 检查给定的插槽是否晚于给定范围的末尾。</li>
</ul>
<p>至此，我们通过<code>Wallet API</code>的简短教程结束。我们已经了解了如何记录消息，如何创建和提交简单的交易，如何使用触发器在执行特定操作之前等待条件变为真，以及如何创建，检查和使用<code>slot</code>范围。<br>在下一章中，我们将深入研究链上代码并创建我们的第一个智能合约。</p>
<h3 id="我们的第一个链上代码"><a href="#我们的第一个链上代码" class="headerlink" title="我们的第一个链上代码"></a>我们的第一个链上代码</h3><p>现在，我们对<code>Wallet API</code>有所了解，并且知道如何编写链下代码，让我们看一下链上代码的第一个示例，一个简单的猜测游戏。</p>
<p>这个游戏的想法是，一个玩家可以想出一个秘密的话，然后捐赠一些Ada作为奖励谁猜对了秘密。</p>
<p>和往常一样，在编写Haskell代码时，我们应该首先考虑类型。特别是，我们必须找出<code>data scripts</code>和<code>redeemer scripts</code>中包装的类型。</p>
<p>如果猜测成功，则<code>redeemer scripts</code>将解锁奖励，因此它必须包含该猜测。</p>
<p>为了让<code>validator script</code>能够完成它的工作并验证猜测，<br>它需要能够决定猜测是否正确。<br>因此，<code>data scripts</code>的一个明显的选择是密语，但是由于<code>data scripts</code>在公共账本上对所有人都是可见的，这将使玩家正确猜测变得微不足道。</p>
<p>因此，我们没有直接使用秘密单词，而是将其哈希值用于<code>data scripts</code>，这样就不可能（或者至少很难）通过查看分类账上的<code>data scripts</code>来重建密语。</p>
<p>单词及其散列都可以用<code>ByteString</code>来表示，这是<code>Plutus Core</code>可用的基本类型之一，但与<code>normal Haskell</code>一样，最好为这两个单词创建不同的类型，这样就不会有混淆它们的危险。</p>
<p>一旦定义了这些类型，就可以使用模板<code>Haskell</code>函数<code>makeLift</code>来在链上使用这些函数，该函数将创建<code>Lift</code>实例，因此使我们能够使用关键的方法将普通的旧值转换为<code>Plutus</code>脚本:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lifted</span> :: <span class="type">Lift</span> a =&gt; a -&gt; <span class="type">Script</span></span><br></pre></td></tr></table></figure></p>
<p>我们开始吧！</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span> <span class="number">1</span>⃣️</span><br><span class="line"><span class="meta">&#123;-# LANGUAGE NoImplicitPrelude #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TemplateHaskell #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# OPTIONS_GHC -fno-warn-missing-signatures #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Game.Guess <span class="keyword">where</span></span><br><span class="line"><span class="keyword">import</span> Language.PlutusTx</span><br><span class="line"><span class="keyword">import</span> Language.PlutusTx.Builtins (<span class="title">equalsByteString</span>)</span><br><span class="line"><span class="keyword">import</span> Language.PlutusTx.Prelude</span><br><span class="line"><span class="keyword">import</span> Ledger</span><br><span class="line"><span class="keyword">import</span> Ledger.Ada</span><br><span class="line"><span class="keyword">import</span> Playground.Contract</span><br><span class="line"><span class="keyword">import</span> Wallet</span><br><span class="line"><span class="keyword">import</span> Data.ByteString.Lazy.Char8 (<span class="title">pack</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">HashedText</span> = <span class="type">HashedText</span> <span class="type">ByteString</span></span></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">ClearText</span> = <span class="type">ClearText</span> <span class="type">ByteString</span> </span></span><br><span class="line"><span class="title">makeLift</span> ''<span class="type">HashedText</span></span><br><span class="line"><span class="title">makeLift</span> ''<span class="type">ClearText</span></span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 链上代码需要</li>
</ul>
<p>所以我们定义了一种类型，<code>HashedText</code>，用于散列密文，另一种类型<code>ClearText</code>，用于猜测。</p>
<p>我们继续使用两个助手函数来创建<code>data scripts</code>和<code>redeemer scripts</code>:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mkDataScript</span> :: <span class="type">String</span> -&gt; <span class="type">DataScript</span> </span><br><span class="line"><span class="title">mkDataScript</span> secret =</span><br><span class="line">    <span class="keyword">let</span> hashedText = <span class="type">HashedText</span> $ sha2_256 $ pack secret </span><br><span class="line">    <span class="keyword">in</span> <span class="type">DataScript</span> $ lifted hashedText</span><br><span class="line"></span><br><span class="line"><span class="title">mkRedeemerScript</span> :: <span class="type">String</span> -&gt; <span class="type">RedeemerScript</span> </span><br><span class="line"><span class="title">mkRedeemerScript</span> clear =</span><br><span class="line">    <span class="keyword">let</span> clearText = <span class="type">ClearText</span> $ pack clear </span><br><span class="line">    <span class="keyword">in</span> <span class="type">RedeemerScript</span> $ lifted clearText</span><br></pre></td></tr></table></figure></p>
<p>函数<code>mkDataScript</code>接收一个秘密单词，对其进行哈希处理，将其包装为我们的<code>HashedText</code>类型，最后将其提升为<code>DataScript</code>脚本以供链上使用。<br>函数<code>mkRedeemerScript</code>接收一个<code>guess</code>猜测，将其包装为<code>ClearText</code>类型并将其提升为<code>RedeemerScript</code>脚本。</p>
<p>要实现<code>validator</code>脚本，我们记得它将用三个参数调用，<code>data script</code>, <code>redeemer script</code>和<code>pending transaction</code>。<br>因此，我们可以从一个普通的Haskell函数<code>validate</code>开始，该函数接受一个<code>HashedText</code>(用于<code>data</code>脚本)，一个<code>ClearText</code>(用于<code>redeemer</code>脚本)和一个<code>pending</code>交易，并返回一个<code>Bool</code>(指示验证是否成功)，然后将该函数提升为脚本:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">GameValidator</span> = <span class="type">HashedText</span> -&gt; <span class="type">ClearText</span> -&gt; <span class="type">PendingTx</span> -&gt; <span class="type">Bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">validate</span> :: <span class="type">GameValidator</span></span><br><span class="line"><span class="title">validate</span> (<span class="type">HashedText</span> hashed) (<span class="type">ClearText</span> clear) _ =</span><br><span class="line">    equalsByteString hashed (sha2_256 clear) </span><br><span class="line"></span><br><span class="line"><span class="title">gameValidator</span> :: <span class="type">ValidatorScript</span></span><br><span class="line"><span class="title">gameValidator</span> = <span class="type">ValidatorScript</span> $$(compileScript [|| validate ||])</span><br></pre></td></tr></table></figure>
<p>因此，我们使用牛津括号<code>[||...||]</code>将<code>validate</code>转换为<code>TExp GameValidator</code>。使用<code>compileScript</code>将其编译成<code>TExp Script</code>，然后使用<code>$(...)</code>将结果拼接为脚本.</p>
<p>为了使用脚本锁定资金并随后赎回这些资金，我们需要脚本地址，我们可以使用<code>scriptAddress</code>从<code>validator script</code>中计算出该地址:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">gameAddress</span> :: <span class="type">Address</span></span><br><span class="line"><span class="title">gameAddress</span> = scriptAddress gameValidator</span><br></pre></td></tr></table></figure></p>
<p>仍然缺少与脚本进行交互的<code>Wallet</code>端点。 我们需要三个：</p>
<ul>
<li>想要猜出这个秘密单词的玩家会调用一个<code>startGame</code>函数。此函数将监视游戏地址，以便将新锁定的资金告知其钱包。（对于钱包来说，要跟踪整个分类账上所有未使用的交易输出是不可行的。我们必须告诉它”监视”哪个特定地址。）</li>
<li>一个<code>lock</code>函数接收密码和一个数量，它将把这个数量锁定在脚本地址上。</li>
<li>一个<code>guess</code>函数，供玩家尝试猜出秘密单词并在猜对的情况下收集锁定的资金。</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">startGame</span> :: <span class="type">MonadWallet</span> m =&gt; m () </span><br><span class="line"><span class="title">startGame</span> = startWatching gameAddress</span><br><span class="line"></span><br><span class="line"><span class="title">lock</span> :: <span class="type">MonadWallet</span> m =&gt; <span class="type">String</span> -&gt; <span class="type">Ada</span> -&gt; m () <span class="number">1</span>⃣️</span><br><span class="line"><span class="title">lock</span> secret ada = payToScript_</span><br><span class="line">    defaultSlotRange gameAddress</span><br><span class="line">    (toValue ada) </span><br><span class="line">    (mkDataScript secret)</span><br><span class="line"></span><br><span class="line"><span class="title">guess</span> :: <span class="type">MonadWallet</span> m =&gt; <span class="type">String</span> -&gt; m ()</span><br><span class="line"><span class="title">guess</span> word = collectFromScript <span class="number">2</span>⃣️</span><br><span class="line">    defaultSlotRange </span><br><span class="line">    gameValidator </span><br><span class="line">    (mkRedeemerScript word)</span><br><span class="line"></span><br><span class="line">$(mkFunctions ['startGame, 'lock, 'guess])</span><br></pre></td></tr></table></figure>
<ul>
<li><p>1⃣️ 函数<code>PayToScript_</code>是类似<code>payToPublicKey_</code>的辅助函数, 它使钱包代码可以很容易地将资金发送到脚本锁定的地址。它的参数是<code>slot range</code>，脚本地址，数量和数据脚本。</p>
</li>
<li><p>2⃣️ 如果<code>payToScript_</code>允许我们将资金发送到脚本地址，那么<code>collectFromScript</code>函数允许我们从脚本地址取款。它的参数是<code>slot range</code>、<code>validator script</code>和<code>redeemer script</code>.</p>
</li>
</ul>
<p>我们可以在<code>Playground</code>上对此进行测试：如果钱包<code>#1</code>想出秘密单词，钱包<code>#2</code>和<code>#3</code>想要尝试猜测它，我们的模拟可能包含以下操作：</p>
<ul>
<li>Wallet #2 starts</li>
<li>Wallet #3 starts</li>
<li>Wallet #1 用秘密单词<code>Haskell</code>和<code>5 Ada</code>奖励来挑战其他人</li>
<li>Wallet #2 猜<code>Scala</code>(猜错了)</li>
<li>Wallet #3 猜对</li>
</ul>
<p><img src="Plutus编写可靠的智能合约/7-07.png" alt=""></p>
<p>因此，Wallet #3 最终会得到奖励。</p>
<p><img src="Plutus编写可靠的智能合约/7-08.png" alt=""></p>
<p>当执行这些操作时，区块链上会发生什么？</p>
<p>当Wallet #1执行<code>lock</code>时，一个交易<code>tx 1</code>将被提交到区块链，成功验证(前提是<code>Wallet #1</code>拥有至少<code>5 Ada</code>)并被合并到一个区块中。作为输入，该交易将具有一个或多个属于Wallet #1钱包的<code>UTxO</code>，总价值至少为<code>5 Ada</code>。作为输出，交易将在<code>game script address</code>(游戏脚本地址)处具有一个<code>UTxO</code>，其值为<code>5 Ada</code>，数据脚本包含<code>Haskell</code>的哈希。 对于更改可能还会有另一个输出。</p>
<p>然后，Wallet #2提交事务<code>tx 2</code>，输入新创建的脚本输出，输出其自己的公钥。<br>但是，由于使用了错误的<code>redeemer</code>(即: <code>Scala</code>)，因此该交易将无法验证。</p>
<p>最后，Wallet #3提交交易<code>tx 3</code>，输入是脚本输出，输出是其自己的公钥，由于使用了正确的<code>redeemer</code>(即: <code>Haskell</code>)，因此该交易将被成功验证：</p>
<p><img src="Plutus编写可靠的智能合约/7-09.png" alt=""></p>
<p>这是我们第一个将链上代码和链下代码相结合的<code>Plutus</code>智能合约示例。我们已经了解了如何将类型和值提升到<code>Plutus Core</code>，如何编写<code>validator</code>脚本，以及如何与钱包中的脚本地址交互。</p>
<h3 id="有参数的合约"><a href="#有参数的合约" class="headerlink" title="有参数的合约"></a>有参数的合约</h3><p>在上一章中简单的简短游戏示例之后，现在让我们尝试一些更具野心和切实的东西，来开展运行众筹活动。</p>
<p>在这样的活动中，活动的所有者设置一个资金目标、结束日期和收款截止日期。</p>
<p>捐赠者可以在活动结束前为活动提供资金。如果所有捐款总额达到资助目标，所有者在收款截止日期前有时间收取所有捐款。如果目标未达到，或者所有者未能在截止日期前募集资金，出资人可以在截止日期后收回其出资。</p>
<p>举例来说，假设钱包<code>#1</code>的所有者开展了一项活动，其筹资目标为<code>12Ada</code>，结束日期<code>slot</code>为<code>#10</code>，收款截止日期为<code>#20</code>。<br>让我们进一步假设，钱包<code>#2</code>为该活动贡献了<code>7Ada</code>，钱包<code>#3</code>贡献了<code>6Ada</code>，并且都在<code>slot</code>(插槽)<code>#10</code>之前做出了贡献。</p>
<p>然后活动成功，并且钱包<code>#1</code>有时间在(<code>slot</code>)<code>#20</code>之前收集总计<code>7 + 6 = 13Ada</code>。</p>
<p>如果钱包<code>#1</code>没有在(<code>slot</code>)<code>#20</code>之前领取这些资金，则钱包<code>#2</code>可以回收<code>7Ada</code>，钱包<code>#3</code>可以回收<code>6Ada</code>。</p>
<p>另一方面，如果只有钱包<code>#2</code>贡献<code>7Ada</code>，而钱包<code>#3</code>根本不贡献，则无法达到筹资目标，并且竞选失败。在这种情况下，钱包<code>#1</code>无法收集任何资金，钱包<code>#2</code>可以在<code>#20</code>或之后回收<code>7Ada</code>。</p>
<p>那么我们如何使用<code>Plutus</code>进行这样的活动呢？</p>
<p>首先，我们希望脚本可以通过上面解释的配置数据参数化，即所有者、资金目标、结束日期和收集截止日期。这样，脚本将可用于许多不同的活动。</p>
<p>因此，我们要做的第一件事是定义一个表示这些参数的类型:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds                       #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DeriveAnyClass                  #-&#125;</span> <span class="number">1</span>⃣️</span><br><span class="line"><span class="meta">&#123;-# LANGUAGE NoImplicitPrelude               #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ScopedTypeVariables             #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TemplateHaskell                 #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# OPTIONS_GHC -fno-warn-missing-signatures #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Parameters.Crowd <span class="keyword">where</span></span><br><span class="line"><span class="keyword">import</span> Language.PlutusTx</span><br><span class="line"><span class="keyword">import</span> Language.PlutusTx.Prelude <span class="keyword">hiding</span> (<span class="title">plus</span>) </span><br><span class="line"><span class="keyword">import</span> Ledger</span><br><span class="line"><span class="keyword">import</span> Ledger.Ada</span><br><span class="line"><span class="keyword">import</span> Playground.Contract</span><br><span class="line"><span class="keyword">import</span> Wallet</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Text (<span class="title">pack</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Campaign</span> = <span class="type">Campaign</span> &#123;</span></span><br><span class="line"><span class="class">      <span class="title">campaignOwner</span> :: <span class="type">PubKey</span></span></span><br><span class="line"><span class="class">    , <span class="title">fundingTarget</span> :: <span class="type">Ada</span></span></span><br><span class="line"><span class="class">    , <span class="title">endDate</span>       :: <span class="type">Slot</span></span></span><br><span class="line"><span class="class">    , <span class="title">collectionDeadline</span> :: <span class="type">Slot</span></span></span><br><span class="line"><span class="class">&#125; <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Generic</span>, <span class="type">ToJSON</span>, <span class="type">FromJSON</span>, <span class="type">ToSchema</span>) 2⃣️</span></span><br><span class="line"></span><br><span class="line"><span class="title">makeLift</span> ''<span class="type">Campaign</span></span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 我们需要它能够派生<code>Generic</code>和<code>ToSchema</code>实例。</li>
<li>2⃣️ 我们需要<code>ToJSON</code>，<code>FromJSON</code>和<code>ToSchema</code>实例，才能将<code>Campaign</code>用作<code>Playground</code>钱包端点的参数。</li>
</ul>
<p>接下来，让我们弄清楚<code>data</code>脚本和<code>redeemer</code>脚本要使用的类型！</p>
<p>有两种情况下，人们会希望从脚本中申请资金：活动成功后的活动所有者收款和活动失败后的捐赠者要求退款。</p>
<p>为了使<code>validator</code>脚本确定此类声明是否有效，它必须知道两种情况中的哪一种适用，这告诉我们，<code>redeemer</code>脚本必须包含此信息。</p>
<p>因此，我们将对<code>redeemer</code>脚本使用以下类型:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">CampaignAction</span> = <span class="type">Collect</span> | <span class="type">Refund</span> </span></span><br><span class="line"><span class="title">makeLift</span> ''<span class="type">CampaignAction</span></span><br></pre></td></tr></table></figure>
<p>数据脚本呢？我们应该把什么信息附在每一份竞选捐款上？</p>
<p>为了确定<code>Collect</code>主张的有效性，我们需要知道是否达到了筹资目标，以及当前<code>slot</code>是否在结束日期和收款截止日期之间，但这些都是我们不需要任何额外信息就能发现的。</p>
<p>但是，要决定<code>refund</code>主张，我们必须知道截止日期已经过去，并且所收回的捐款是否确实是由要求退款的人做出的，因此我们需要此信息(捐款来自何处)，附加到每个脚本输出上。</p>
<p>因此，对于我们的数据脚本，我们将使用:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Contributor</span> = <span class="type">Contributor</span> &#123;<span class="title">getContributor</span> :: <span class="type">PubKey</span>&#125; 1⃣️</span></span><br><span class="line"></span><br><span class="line"><span class="title">makeLift</span> ''<span class="type">Contributor</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>1⃣️ 我们可以简单地使用<code>PubKey</code>来代替，但是正如上一章所提到的，使用<code>newtype</code>来避免混淆总是比较安全的。</li>
</ul>
<p>和前面一样，我们编写了简单的辅助函数来创建<code>data</code>脚本和<code>redeemer</code>脚本:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mkRedeemerScript</span> :: <span class="type">CampaignAction</span> -&gt; <span class="type">RedeemerScript</span> </span><br><span class="line"><span class="title">mkRedeemerScript</span> = <span class="type">RedeemerScript</span> . lifted</span><br><span class="line"></span><br><span class="line"><span class="title">mkDataScript</span> :: <span class="type">PubKey</span> -&gt; <span class="type">DataScript</span> </span><br><span class="line"><span class="title">mkDataScript</span> = <span class="type">DataScript</span> . lifted . <span class="type">Contributor</span></span><br></pre></td></tr></table></figure></p>
<p>现在让我们将注意力转向<code>validator</code>脚本！与最后一个示例一样，我们将首先编写一个简单的<code>Haskell</code>函数<code>validate</code>，其中包含所有逻辑，然后将该函数提升为脚本。</p>
<p>为了进行验证，我们必须知道动作是否在正确的时间发生：<code>Collect</code>动作不能在<code>endDate</code>之前发生，而必须在<code>collectionDeadline</code>之前发生。另一方面，<code>Refund</code>动作一定不能在<code>collectionDeadline</code>之前发生。</p>
<p>与钱包中运行的链下代码不同，我们可以用<code>slot</code>查找当前<code>slot</code>，<code>validator</code>是无状态的，因此我们无法访问其中的当前<code>slot</code>。但是，我们确实有挂起的交易，特别是该交易的<code>slot</code>范围。所以我们知道当前<code>slot</code>必须属于这个<code>slot</code>范围，并且我们可以使用这个信息来进行交易验证。</p>
<p>下面的<code>helper</code>函数将证明是有用的。函数<code>collectionRange</code>计算允许收集的<code>slot</code>范围，函数<code>inCollectionRange</code>检查挂起交易的<code>slot</code>范围是否包含在活动的收集范围中。函数<code>refundRange</code>和<code>inRefundRange</code>在允许退款时对范围执行相同的操作。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">collectionRange</span> :: <span class="type">Campaign</span> -&gt; <span class="type">SlotRange</span> </span><br><span class="line"><span class="title">collectionRange</span> campaign =</span><br><span class="line">    interval</span><br><span class="line">        (endDate campaign) </span><br><span class="line">        (collectionDeadline campaign)</span><br><span class="line"></span><br><span class="line"><span class="title">inCollectionRange</span> :: <span class="type">Campaign</span> -&gt; <span class="type">PendingTx</span> -&gt; <span class="type">Bool</span> </span><br><span class="line"><span class="title">inCollectionRange</span> campaign tx =</span><br><span class="line">    collectionRange campaign `contains` pendingTxValidRange tx </span><br><span class="line"></span><br><span class="line"><span class="title">refundRange</span> :: <span class="type">Campaign</span> -&gt; <span class="type">SlotRange</span></span><br><span class="line"><span class="title">refundRange</span> = intervalFrom . collectionDeadline</span><br><span class="line"></span><br><span class="line"><span class="title">inRefundRange</span> :: <span class="type">Campaign</span> -&gt; <span class="type">PendingTx</span> -&gt; <span class="type">Bool</span> </span><br><span class="line"><span class="title">inRefundRange</span> campaign tx =</span><br><span class="line">    refundRange campaign `contains` pendingTxValidRange tx</span><br></pre></td></tr></table></figure></p>
<p>为了检查是否达到了筹资目标，我们必须计算属于脚本的挂起交易的所有输入中包含的Ada总量，因此我们编写一个辅助函数<code>totalInput</code>来做到这一点：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">totalInput</span> :: <span class="type">PendingTx</span> -&gt; <span class="type">Ada</span></span><br><span class="line"><span class="title">totalInput</span> tx = foldl f zero (pendingTxInputs tx)</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">      f :: <span class="type">Ada</span> -&gt; <span class="type">PendingTxIn</span> -&gt; <span class="type">Ada</span> </span><br><span class="line">      f ada i</span><br><span class="line">        | fromScript i = ada `plus` fromValue (pendingTxInValue i) </span><br><span class="line">        | otherwise = ada</span><br><span class="line">    </span><br><span class="line">      fromScript :: <span class="type">PendingTxIn</span> -&gt; <span class="type">Bool</span> <span class="number">1</span>⃣️</span><br><span class="line">      fromScript i = <span class="keyword">case</span> pendingTxInWitness i <span class="keyword">of</span></span><br><span class="line">          <span class="type">Nothing</span> -&gt; <span class="type">False</span></span><br><span class="line">          <span class="type">Just</span> (h, _) -&gt; h == ownHash tx   <span class="number">2</span>⃣️</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1⃣️ 此交易输入对应于我们脚本的输出吗？</li>
<li>2⃣️ 函数<code>ownHash :: PendingTx → ValidatorHash</code>给我们当前正在评估的<code>validator</code>脚本的哈希值。</li>
</ul>
<p>为了退款，我们必须检查<code>pending</code>交易的所有输出是否都归原始贡献者所有，因此我们编写了一个<code>Contributor</code>函数来检查:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">toContributor</span> :: <span class="type">Contributor</span> -&gt; <span class="type">PendingTxOut</span> -&gt; <span class="type">Bool</span> </span><br><span class="line"><span class="title">toContributor</span> (<span class="type">Contributor</span> key) o = <span class="keyword">case</span> pendingTxOutData o <span class="keyword">of</span></span><br><span class="line">      <span class="type">DataTxOut</span> -&gt; <span class="type">False</span> <span class="number">1</span>⃣️</span><br><span class="line">      <span class="type">PubKeyTxOut</span> key' -&gt; key' == key <span class="number">2</span>⃣️</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 如果<code>output</code>被脚本锁定，则不会发送给贡献者，并且我们返回False</li>
<li>2⃣️ 如果<code>output</code>到一个公钥，我们会检查它是否是正确的公钥。</li>
</ul>
<p>完成这些准备后，我们可以编写<code>validate</code>:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">CampaignValidator</span> = <span class="type">Contributor</span> -&gt; <span class="type">CampaignAction</span> -&gt; <span class="type">PendingTx</span> -&gt; <span class="type">Bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">validate</span> :: <span class="type">Campaign</span> -&gt; <span class="type">CampaignValidator</span> </span><br><span class="line"><span class="title">validate</span> campaign _ <span class="type">Collect</span> tx =</span><br><span class="line">      (tx `txSignedBy` campaignOwner campaign) <span class="number">1</span>⃣️</span><br><span class="line">      &amp;&amp; (totalInput tx &gt;= fundingTarget campaign) <span class="number">2</span>⃣️ </span><br><span class="line">      &amp;&amp; inCollectionRange campaign tx <span class="number">3</span>⃣️</span><br><span class="line"><span class="title">validate</span> campaign contributor <span class="type">Refund</span> tx =</span><br><span class="line">      all (toContributor contributor) (pendingTxOutputs tx) <span class="number">4</span>⃣️</span><br><span class="line">      &amp;&amp; inRefundRange campaign tx <span class="number">5</span>⃣️</span><br><span class="line">      &amp;&amp; (tx `txSignedBy` getContributor contributor) <span class="number">6</span>⃣️</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1⃣️ 只允许活动所有者收集捐款</li>
<li>2⃣️ 必须达到筹资目标</li>
<li>3⃣️ 只允许在结束日期和收款截止日期之间收款</li>
<li>4⃣️ 退款必须归原始捐款人所有</li>
<li>5⃣️ 仅在收款截止日期之后才允许退款</li>
<li>6⃣️ 退款要求必须由捐款者提出</li>
</ul>
<p>为了使用<code>validate</code>为活动创建<code>validator</code>脚本，仅仅像上一章那样简单地提升函数是不够的。这将导致错误的类型，因为我们还有额外的<code>Campaign</code>参数。<br>相反，我们可以使用<code>applyScript</code>将<code>Campaign → CampaignValidator</code>类型的<code>script</code>转换为<code>CampaignValidator</code>类型的<code>script</code>：</p>
<p>这里的问题是我们使用的特定活动只能在运行时知道，而<code>compileScript</code>在编译时有效。函数<code>applyScript</code>至关重要地使我们能够在运行时操作脚本，这就是使我们能够创建依赖于运行时参数的脚本的原因。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mkValidatorScript</span> :: <span class="type">Campaign</span> -&gt; <span class="type">ValidatorScript</span> </span><br><span class="line"><span class="title">mkValidatorScript</span> campaign = <span class="type">ValidatorScript</span> $</span><br><span class="line">    $$(compileScript [|| validate ||]) `applyScript` lifted campaign</span><br></pre></td></tr></table></figure></p>
<p>这是链上代码要做的全部工作，因此现在让我们将注意力转向链下钱包端点。我们从一个函数开始计算活动的脚本地址:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">campaignAddress</span> :: <span class="type">Campaign</span> -&gt; <span class="type">Address</span> </span><br><span class="line"><span class="title">campaignAddress</span> = scriptAddress . mkValidatorScript</span><br></pre></td></tr></table></figure>
<p>我们的第一个端点<code>startCampaign</code>将由活动所有者运行。该端点注册了一个触发器，以等待活动结束日期并在达到资金目标后收集捐款。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">startCampaign</span> :: <span class="keyword">forall</span> m. <span class="type">MonadWallet</span> m </span><br><span class="line">    =&gt; <span class="type">Ada</span> <span class="comment">-- funding target</span></span><br><span class="line">    -&gt; <span class="type">Slot</span> <span class="comment">-- end date</span></span><br><span class="line">    -&gt; <span class="type">Slot</span> <span class="comment">-- collection deadline </span></span><br><span class="line">    -&gt; m ()</span><br><span class="line"><span class="title">startCampaign</span> ft ed cd = <span class="keyword">do</span> </span><br><span class="line">    key &lt;- ownPubKey</span><br><span class="line">    <span class="keyword">let</span> campaign = <span class="type">Campaign</span></span><br><span class="line">          &#123; campaignOwner       = key</span><br><span class="line">          , fundingTarget       = ft</span><br><span class="line">          , endDate             = ed</span><br><span class="line">          , collectionDeadline  = cd</span><br><span class="line">          &#125;</span><br><span class="line">    logMsg $ pack $ <span class="string">"starting "</span> ++ show campaign</span><br><span class="line">    registerOnce (trigger campaign) (handler campaign)</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    trigger :: <span class="type">Campaign</span> -&gt; <span class="type">EventTrigger</span> </span><br><span class="line">    trigger campaign =</span><br><span class="line">        fundsAtAddressGeqT <span class="number">1</span>⃣️</span><br><span class="line">            (campaignAddress campaign)</span><br><span class="line">            (toValue $ fundingTarget campaign)</span><br><span class="line">        `andT`</span><br><span class="line">        slotRangeT (collectionRange campaign) <span class="number">2</span>⃣️</span><br><span class="line"></span><br><span class="line">    handler :: <span class="type">Campaign</span> -&gt; <span class="type">EventHandler</span> m </span><br><span class="line">    handler campaign = <span class="type">EventHandler</span> $ const $ <span class="keyword">do</span></span><br><span class="line">        logMsg $ pack $ <span class="string">"collecting from "</span> ++ show campaign </span><br><span class="line">        collectFromScript</span><br><span class="line">            (collectionRange campaign)</span><br><span class="line">            (mkValidatorScript campaign)</span><br><span class="line">            (mkRedeemerScript <span class="type">Collect</span>)  <span class="number">3</span>⃣️</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1⃣️ 是否达到了筹资目标？</li>
<li>2⃣️ 到达结束日期了吗？</li>
<li>3⃣️ 我们收集资金。</li>
</ul>
<p>第二个端点是供贡献者使用的。它允许他们为一项活动捐款，还将注册一个触发器，以检查是否已达到收款截止日期并且所有者尚未收款，在这种情况下，将收回捐款:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">contribute</span> :: <span class="keyword">forall</span> m. <span class="type">MonadWallet</span> m =&gt; <span class="type">Campaign</span> -&gt; <span class="type">Ada</span> -&gt; m () </span><br><span class="line"><span class="title">contribute</span> campaign ada = <span class="keyword">do</span></span><br><span class="line">    logMsg $ pack $ <span class="string">"contributing to "</span> ++ show campaign</span><br><span class="line">    key &lt;- ownPubKey</span><br><span class="line">    tx &lt;- payToScript <span class="number">1</span>⃣️</span><br><span class="line">      defaultSlotRange </span><br><span class="line">      (campaignAddress campaign) </span><br><span class="line">      (toValue ada) </span><br><span class="line">      (mkDataScript key)</span><br><span class="line">    registerOnce trigger (handler tx)</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    range :: <span class="type">SlotRange</span></span><br><span class="line">    range = refundRange campaign</span><br><span class="line"></span><br><span class="line">    trigger :: <span class="type">EventTrigger</span> </span><br><span class="line">    trigger =</span><br><span class="line">        fundsAtAddressGtT (campaignAddress campaign) mempty <span class="number">2</span>⃣️</span><br><span class="line">        `andT`</span><br><span class="line">        slotRangeT range</span><br><span class="line"></span><br><span class="line">    handler :: <span class="type">Tx</span> -&gt; <span class="type">EventHandler</span> m </span><br><span class="line">    handler tx = <span class="type">EventHandler</span> $ const $ <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">let</span> txId = hashTx tx <span class="number">4</span>⃣️</span><br><span class="line">      logMsg $ pack $ <span class="string">"Reclaiming contribution "</span> ++ show txId</span><br><span class="line">          ++ <span class="string">" from "</span> ++ show campaign</span><br><span class="line">      collectFromScriptTxn <span class="number">5</span>⃣️</span><br><span class="line">          range</span><br><span class="line">          (mkValidatorScript campaign)</span><br><span class="line">          (mkRedeemerScript <span class="type">Refund</span>) <span class="number">6</span>⃣️</span><br><span class="line">          txId</span><br><span class="line">$(mkFunctions ['startCampaign, 'contribute])</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 函数<code>payToScript</code>是<code>payToScript_</code>的变体，它返回创建和提交的交易。我们需要事件处理程序从正确的交易输出中收回资金。</li>
<li>2⃣️ 是否有要回收的捐款？</li>
<li>3⃣️ 收集期限是否已到？</li>
<li>4⃣️ 我们用<code>hashTx</code>获得交易的交易标识符。</li>
<li>5⃣️ 函数<code>collectFromScriptTxn</code>与<code>collectFromScript</code>类似，但它还需要一个交易标识符，以便仅从由具有该标识符的交易创建的脚本输出中进行收集</li>
<li>6⃣️ 我们要求退款</li>
</ul>
<p>就是这样！现在，我们准备在<code>Playground</code>中测试我们的代码。一个小问题是，为了为<code>contribute</code>端点提供<code>Campaign</code>参数，我们需要知道<code>campaign</code>(活动)所有者的公钥。<br>下表列出了所有<code>Playground</code>钱包及其公用密钥将会是有用的:</p>
<p><img src="Plutus编写可靠的智能合约/7-10.png" alt=""></p>
<p>我们从<code>wallet #1</code>拥有的一个成功的活动开始，资金目标为<code>12Ada</code>，结束日期为<code>slot #10</code>，收款截止日期为<code>slot #20</code>.</p>
<p><img src="Plutus编写可靠的智能合约/7-11.png" alt=""></p>
<p>如预期，<code>wallet #1</code>可以在结束日期收集<code>13Ada</code>的捐款:</p>
<p><img src="Plutus编写可靠的智能合约/7-12.png" alt=""></p>
<p>现在，让我们模拟同一活动的失败场景，因为<code>wallet＃3</code>仅贡献<code>4Ada</code>:</p>
<p><img src="Plutus编写可靠的智能合约/7-13.png" alt=""></p>
<p>在这种情况下，贡献者的<code>wallet＃2</code>和<code>wallet＃3</code>会在<code>slot #20</code>中收回他们的钱:</p>
<p><img src="Plutus编写可靠的智能合约/7-14.png" alt=""></p>
<p>在区块链上会发生什么？对于成功的活动，交易图表如下所示:<br><img src="success-01.png" alt=""></p>
<p>最后，未达到其筹资目标的活动系列如下所示:<br><img src="fail-01.png" alt=""></p>
<p>这一章介绍了如何编写参数化合同来实施一个非常现实的众筹活动。<br>我们希望您发现此信息是有用的。</p>
<h3 id="多阶段合约"><a href="#多阶段合约" class="headerlink" title="多阶段合约"></a>多阶段合约</h3><p>到目前为止，我们看到的示例脚本有一个共同点：所有锁定的资金都是一步到位的。在本章中，我们想看一个例子，在这个例子中，情况并非如此，资金可以通过许多步骤收集。</p>
<p>我们的例子将是一个<code>vesting scheme</code>(归属计划): 在这样一个计划中，部分锁定资金(所谓的份额)在特定时间可用。为了简化问题，我们将研究两个此类部分的归属计划。</p>
<p>例如，可能有一笔金额为<code>4Ada</code>且可用日期为<code>slot #10</code>的款项，另一笔金额为<code>6 Ada</code>且可用日期为<code>slot #20</code>的款项。因此，总共有<code>10Ada</code>被锁定在这个方案中，而在一开始，这些<code>Ada</code>都不可用。从<code>slot #10</code>开始，可以收集前4个<code>Ada</code>，从<code>slot #20</code>开始，可以收集其余的<code>6Ada</code>.</p>
<p>请注意，该计划的所有者，即被允许收取资金的人，可以按照自己喜欢的任何步骤进行收集。因此，在上面的示例中，她可能会在<code>slot #10</code>中收集<code>2Ada</code>，在<code>slot #11</code>中收集另外<code>2Ada，</code>然后在<code>slot #20</code>中收集<code>5Ada</code>，并在<code>slot #21</code>中收集最后的<code>1Ada</code>。</p>
<p>在实现此示例时，我们将必须构造一个具有一个或多个输入和两个输出的交易，因此我们将无法像以前一样使用便捷的帮助程序功能，如<code>payToScript_</code>或<code>collectFromScript</code>.</p>
<h4 id="建立复杂的交易"><a href="#建立复杂的交易" class="headerlink" title="建立复杂的交易"></a>建立复杂的交易</h4><p>我们可以使用以下方法构建任意复杂的交易:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">createTxAndSubmit</span> :: <span class="type">MonadWallet</span> m =&gt; <span class="type">SlotRange</span> -&gt; <span class="type">Set</span> <span class="type">TxIn</span> -&gt; [<span class="type">TxOut</span>] -&gt; m <span class="type">Tx</span></span><br></pre></td></tr></table></figure>
<p>为了应用此函数，我们需要构造交易输入和交易输出，并且我们可以为此使用以下函数:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pubKeyTxIn</span> :: <span class="type">TxOutRef</span> -&gt; <span class="type">PubKey</span> -&gt; <span class="type">TxIn</span></span><br><span class="line"><span class="title">scriptTxIn</span> :: <span class="type">TxOutRef</span> -&gt; <span class="type">ValidatorScript</span> -&gt; <span class="type">RedeemerScript</span> -&gt; <span class="type">TxIn</span></span><br><span class="line"></span><br><span class="line"><span class="title">pubKeyTxOut</span> :: <span class="type">Value</span> -&gt; <span class="type">PubKey</span> -&gt; <span class="type">TxOut</span></span><br><span class="line"><span class="title">scriptTxOut</span> :: <span class="type">Value</span> -&gt; <span class="type">ValidatorScript</span> -&gt; <span class="type">DataScript</span> -&gt; <span class="type">TxOut</span></span><br></pre></td></tr></table></figure></p>
<p>最后，为了获得必要的<code>TxOutRef</code>，我们可以使用:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">outputsAt</span> :: <span class="type">MonadWallet</span> m =&gt; <span class="type">Address</span> -&gt; m (<span class="type">Map</span> <span class="type">TxOutRef</span> <span class="type">TxOut</span>)</span><br></pre></td></tr></table></figure></p>
<p>请注意，<code>outputsAt</code>只返回钱包已知的输出，即那些位于被监视或已注册触发器的地址的输出。</p>
<p>让我们首先定义<code>tranches</code>(付款)和<code>vesting</code>(归属)方案的类型！<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds                       #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DeriveAnyClass                  #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE NoImplicitPrelude               #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ScopedTypeVariables             #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TemplateHaskell                 #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# OPTIONS_GHC -fno-warn-missing-signatures #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Multi.Vesting <span class="keyword">where</span></span><br><span class="line"><span class="keyword">import</span> Language.PlutusTx</span><br><span class="line"><span class="keyword">import</span> Language.PlutusTx.Builtins (<span class="title">greaterThanEqInteger</span>)</span><br><span class="line"><span class="keyword">import</span> Language.PlutusTx.Prelude <span class="keyword">hiding</span> (<span class="title">plus</span>, <span class="title">minus</span>) Ledger</span><br><span class="line"><span class="keyword">import</span> Ledger.Ada</span><br><span class="line"><span class="keyword">import</span> Playground.Contract</span><br><span class="line"><span class="keyword">import</span> Wallet</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Control.Monad (<span class="title">void</span>)</span><br><span class="line"><span class="keyword">import</span> Data.Map (<span class="type">Map</span>)</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Map <span class="keyword">as</span> Map</span><br><span class="line"><span class="keyword">import</span> Data.Set (<span class="type">Set</span>)</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Set <span class="keyword">as</span> Set</span><br><span class="line"><span class="keyword">import</span> Data.Text (<span class="title">pack</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分期付款, 份额</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tranche</span> = <span class="type">Tranche</span></span></span><br><span class="line">&#123; date :: <span class="type">Slot</span></span><br><span class="line">, amount :: <span class="type">Ada</span></span><br><span class="line">&#125; <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Generic</span>, <span class="type">ToJSON</span>, <span class="type">FromJSON</span>, <span class="type">ToSchema</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">makeLift</span> ''<span class="type">Tranche</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 兑现，归属，受益权</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Vesting</span> = <span class="type">Vesting</span></span></span><br><span class="line">&#123; tranche1 :: <span class="type">Tranche</span></span><br><span class="line">, tranche2 :: <span class="type">Tranche</span></span><br><span class="line">, owner :: <span class="type">PubKey</span></span><br><span class="line">&#125; <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Generic</span>, <span class="type">ToJSON</span>, <span class="type">FromJSON</span>, <span class="type">ToSchema</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">makeLift</span> ''<span class="type">Vesting</span></span><br></pre></td></tr></table></figure></p>
<p>让我们编写两个辅助函数来处理<code>tranches</code>(份额)和<code>vesting</code>(兑现)方案:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 计划中锁定的总金额</span></span><br><span class="line"><span class="title">totalAmount</span> :: <span class="type">Vesting</span> -&gt; <span class="type">Ada</span></span><br><span class="line"><span class="title">totalAmount</span> v = amount (tranche1 v) `plus` amount (tranche2 v)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Funds guaranteed to be available in that range.</span></span><br><span class="line"><span class="title">availableFrom</span>:: <span class="type">Vesting</span> -&gt; <span class="type">SlotRange</span> -&gt; <span class="type">Ada</span> </span><br><span class="line"><span class="title">availableFrom</span> v r =</span><br><span class="line"><span class="title">availableFromTranche</span> (tranche1 v) `plus` availableFromTranche (tranche2 v)</span><br><span class="line"><span class="title">where</span></span><br><span class="line">  availableFromTranche :: <span class="type">Tranche</span> -&gt; <span class="type">Ada</span> a</span><br><span class="line">  vailableFromTranche t =</span><br><span class="line">    <span class="keyword">if</span> intervalFrom (date t) `contains` r </span><br><span class="line">        <span class="keyword">then</span> amount t</span><br><span class="line">    <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>现在是时候为<code>data</code>脚本和<code>redeemer</code>脚本考虑合适的类型了。在<code>vesting</code>计划的整个生命周期中唯一发生变化的是已经收集了多少钱，并且无需任何其他数据即可观察到该信息。这意味着我们可以在<code>data</code>脚本中使用单元类型<code>()</code>.</p>
<p><code>redeemer</code>脚本的作用是指示从脚本中收集资金的意图，但在本例中，只有一个意图: 提取资金。所以我们也可以选择<code>()</code>作为<code>redeemer</code>脚本的类型。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">dataScript</span> :: <span class="type">DataScript</span></span><br><span class="line"><span class="title">dataScript</span> = <span class="type">DataScript</span> $ lifted ()</span><br><span class="line"></span><br><span class="line"><span class="title">redeemerScript1</span> :: <span class="type">RedeemerScript</span> </span><br><span class="line"><span class="title">redeemerScript1</span> = <span class="type">RedeemerScript</span> $</span><br><span class="line">      <span class="comment">-- `redeemer`被传递给`data`脚本(unit)，它只是忽略它</span></span><br><span class="line">      $$(<span class="type">Ledger</span>.compileScript [|| \(_ :: <span class="type">Sealed</span> (<span class="type">HashedDataScript</span> ())) -&gt; () ||]) </span><br><span class="line"></span><br><span class="line"><span class="title">redeemerScript0</span> :: <span class="type">RedeemerScript</span></span><br><span class="line"><span class="title">redeemerScript0</span> = <span class="type">RedeemerScript</span> $ $$(<span class="type">Ledger</span>.compileScript [|| () ||])</span><br></pre></td></tr></table></figure>
<p>我们现在可以定义<code>validator</code>脚本了。再次，我们将首先定义一个普通的<code>Haskell</code>函数<code>validate</code>来完成所有的工作，然后我们将使用上一章学习的技术通过<code>vesting</code>方案参数化<code>validator</code>脚本。</p>
<p>函数<code>validate</code>必须检查我们从脚本中收集的资金是否超出当时允许的数额，即我们是否将足够的资金锁定回脚本，以及交易是否由<code>vesting</code>方案所有者签名。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">VestingValidator</span> = () -&gt; () -&gt; <span class="type">PendingTx</span> -&gt; <span class="type">Bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">validate</span> :: <span class="type">Vesting</span> -&gt; <span class="type">VestingValidator</span> </span><br><span class="line"><span class="title">validate</span> v () () tx =</span><br><span class="line">  <span class="keyword">let</span> hash = ownHash tx <span class="number">1</span>⃣️</span><br><span class="line">      available = availableFrom v (pendingTxValidRange tx) <span class="number">2</span>⃣️</span><br><span class="line">      unreleased = totalAmount v `minus` available <span class="number">3</span>⃣️</span><br><span class="line">      remaining = adaLockedBy tx hash <span class="number">4</span>⃣️</span><br><span class="line">  <span class="keyword">in</span> (toInt remaining `greaterThanEqInteger` toInt unreleased) </span><br><span class="line">        &amp;&amp; (tx `txSignedBy` owner v)</span><br><span class="line"></span><br><span class="line"><span class="title">mkValidatorScript</span> :: <span class="type">Vesting</span> -&gt; <span class="type">ValidatorScript</span> </span><br><span class="line"><span class="title">mkValidatorScript</span> = <span class="type">ValidatorScript</span></span><br><span class="line">                  . applyScript $$(compileScript [|| validate ||]) </span><br><span class="line">                  . lifted</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 我们的<code>validator</code>(验证者)<code>hash</code></li>
<li>2⃣️ 已释放的资金</li>
<li>3⃣️ 尚未释放的资金</li>
<li>4⃣️ 此交易在合同中留下的资金</li>
</ul>
<p>现在我们准备定义我们的钱包端点，我们需要三个端点:</p>
<ul>
<li><code>registerScheme</code> - 让所有者用来开始监视他的<code>vesting</code>方案</li>
<li><code>vest</code> - 让某人将资金锁定在<code>vesting</code>方案中</li>
<li><code>withdraw</code> - 让所有者从其<code>vesting</code>方案中提取资金</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">vestingAddress</span> :: <span class="type">Vesting</span> -&gt; <span class="type">Address</span> </span><br><span class="line"><span class="title">vestingAddress</span> = scriptAddress . mkValidatorScript</span><br><span class="line"></span><br><span class="line"><span class="title">registerScheme</span> :: <span class="type">MonadWallet</span> m =&gt; <span class="type">Tranche</span> -&gt; <span class="type">Tranche</span> -&gt; m () </span><br><span class="line"><span class="title">registerScheme</span> t1 t2 = <span class="keyword">do</span></span><br><span class="line">    key &lt;- ownPubKey </span><br><span class="line">    <span class="keyword">let</span> v = <span class="type">Vesting</span></span><br><span class="line">            &#123; </span><br><span class="line">              tranche1 = t1 , </span><br><span class="line">              tranche2 = t2 , </span><br><span class="line">              owner = key </span><br><span class="line">            &#125;</span><br><span class="line">    logMsg $ pack $ <span class="string">"registering "</span> ++ show v </span><br><span class="line">    startWatching $ vestingAddress v</span><br><span class="line"></span><br><span class="line"><span class="title">vest</span> :: <span class="type">MonadWallet</span> m =&gt; <span class="type">Vesting</span> -&gt; m () </span><br><span class="line"><span class="title">vest</span> v = <span class="keyword">do</span></span><br><span class="line">    logMsg $ pack $ <span class="string">"vesting in "</span> ++ show v </span><br><span class="line">    payToScript_</span><br><span class="line">        defaultSlotRange </span><br><span class="line">        (vestingAddress v) </span><br><span class="line">        (toValue $ totalAmount v) </span><br><span class="line">        dataScript</span><br></pre></td></tr></table></figure>
<p><code>withdraw</code>函数是最有趣和最复杂的函数: 除非我们要提取所有剩余资金，否则我们必须构造一个具有两个输出的交易，一个输出到我们提取资金的公钥，另一个到锁定剩余金额的脚本。该交易的输入将是属于该脚本的所有<code>UTxO</code>(尽管在正常情况下，始终只有一个这样的输出).</p>
<p>如本章引言中所述，我们将为此使用<code>createTxAndSubmit</code>.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">withdraw</span> :: <span class="type">MonadWallet</span> m =&gt; <span class="type">Tranche</span> -&gt; <span class="type">Tranche</span> -&gt; <span class="type">Ada</span> -&gt; m ()</span><br><span class="line"><span class="title">withdraw</span> t1 t2 ada = <span class="keyword">do</span></span><br><span class="line">      key &lt;- ownPubKey </span><br><span class="line">      <span class="keyword">let</span> v = <span class="type">Vesting</span></span><br><span class="line">              &#123; </span><br><span class="line">                tranche1 = t1 , </span><br><span class="line">                tranche2 = t2 , </span><br><span class="line">                owner = key </span><br><span class="line">              &#125;</span><br><span class="line">      logMsg $ pack $</span><br><span class="line">          <span class="string">"withdrawing "</span> ++ show ada ++ <span class="string">" from "</span> ++ show v</span><br><span class="line">      utxos &lt;- outputsAt $ vestingAddress v <span class="number">1</span>⃣️</span><br><span class="line"></span><br><span class="line">      sl &lt;- slot</span><br><span class="line">      <span class="keyword">let</span> range = intervalFrom sl</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> o = pubKeyTxOut (toValue ada) key</span><br><span class="line">      <span class="keyword">let</span> change = locked utxos `minus` ada <span class="number">2</span>⃣️ </span><br><span class="line">          fundsRemaining = change &gt; <span class="number">0</span></span><br><span class="line">          outs = <span class="keyword">if</span> fundsRemaining</span><br><span class="line">              <span class="keyword">then</span> [ o</span><br><span class="line">                  , scriptTxOut</span><br><span class="line">                    (toValue change) </span><br><span class="line">                    (mkValidatorScript v) </span><br><span class="line">                    dataScript</span><br><span class="line">                  ] </span><br><span class="line">              <span class="keyword">else</span> [o]</span><br><span class="line">      void $ createTxAndSubmit </span><br><span class="line">          range</span><br><span class="line">          (ins v utxos fundsRemaining) </span><br><span class="line">          outs</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">      ins :: <span class="type">Vesting</span> <span class="number">3</span>⃣️</span><br><span class="line">          -&gt; <span class="type">Map</span> <span class="type">TxOutRef</span> <span class="type">TxOut</span></span><br><span class="line">          -&gt; <span class="type">Bool</span></span><br><span class="line">          -&gt; <span class="type">Set</span> <span class="type">TxIn</span></span><br><span class="line">      ins v utxos outputsUseDataScript = <span class="type">Set</span>.fromList </span><br><span class="line">          [ scriptTxIn</span><br><span class="line">              r</span><br><span class="line">              (mkValidatorScript v)</span><br><span class="line">              (<span class="keyword">if</span> outputsUseDataScript <span class="keyword">then</span> redeemerScript1 <span class="keyword">else</span> redeemerScript0)</span><br><span class="line">           | r &lt;- <span class="type">Map</span>.keys utxos </span><br><span class="line">          ]</span><br><span class="line"></span><br><span class="line">      locked :: <span class="type">Map</span> <span class="type">TxOutRef</span> <span class="type">TxOut</span> -&gt; <span class="type">Ada</span> <span class="number">4</span>⃣️</span><br><span class="line">      locked = <span class="type">Map</span>.foldl' f zero</span><br><span class="line">        <span class="keyword">where</span></span><br><span class="line">          f :: <span class="type">Ada</span> -&gt; <span class="type">TxOut</span> -&gt; <span class="type">Ada</span></span><br><span class="line">          f a o = a `plus` fromValue (txOutValue o)</span><br><span class="line"></span><br><span class="line">$(mkFunctions ['registerScheme, 'vest, 'withdraw])</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 我们使用<code>outputAt</code>获取所有被脚本锁定的<code>UTxO</code>.</li>
<li>2⃣️ 我们需要在脚本中锁定多少更改？</li>
<li>3⃣️ 我们交易的输入，每个由脚本锁定的<code>UTxO</code>对应一个.</li>
<li>4⃣️ 脚本中还有多少被锁定的钱？</li>
</ul>
<p>让我们从本章开始在<code>Playground</code>中尝试示例！</p>
<p><img src="Plutus编写可靠的智能合约/10-01.png" alt=""></p>
<p><img src="Plutus编写可靠的智能合约/10-02.png" alt=""></p>
<p><img src="Plutus编写可靠的智能合约/10-03.png" alt=""></p>
<p><img src="Plutus编写可靠的智能合约/10-04.png" alt=""></p>
<p><img src="Plutus编写可靠的智能合约/10-05.png" alt=""></p>
<p>我们将其作为练习，让读者检查如果<code>wallet #2</code>尝试过早提取太多钱，验证将失败。</p>
<p>让我们想象一下一切顺利之后区块链上会发生什么！<br>在第一笔交易中，<code>wallet #1</code>的所有者<code>Alice</code>注册了该方案。在之后的交易中，<code>wallet #2</code>的所有者<code>Bob</code>根据<code>vesting</code>方案提取了资金:</p>
<p><img src="Plutus编写可靠的智能合约/10-06.png" alt=""></p>
<p>在本章中，我们已经看到了如何编写多阶段合同，这些合同要经过几个阶段才能最终收回所有款项。我们还看到了如何”手动”构造具有多个输入和输出的复杂交易。</p>
<h3 id="超越Ada并使用任意自定义代币"><a href="#超越Ada并使用任意自定义代币" class="headerlink" title="超越Ada并使用任意自定义代币"></a>超越Ada并使用任意自定义代币</h3><p>在前面的示例中，每当需要<code>Value</code>时，我们都专门使用Ada。这很有道理，因为Ada是卡达诺支持的基本货币。</p>
<p>不过，<code>Plutus</code>提供了一个更通用的<code>value</code>概念，支持定制<code>fungible</code>(可替代)、<code>non-fungible</code>(不可替代)和<code>mixed</code>(混合)代币(参见智能合约)，在本章中，我们将演示如何超越Ada并使用其他代币。</p>
<p>Plutus中的<code>value</code>是什么？</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Value</span> = <span class="type">Value</span></span></span><br><span class="line">  &#123;getValue :: <span class="type">Map</span> <span class="type">CurrencySymbol</span> (<span class="type">Map</span> <span class="type">TokenName</span> <span class="type">Integer</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>类型<code>CurrencySymbol</code>和<code>TokenName</code>都是围绕<code>ByteString</code>的简单包装.</p>
<p><code>value</code>的概念包括<code>Ada</code>，可替代代币，不可替代代币以及更多奇特的混合情况:</p>
<ul>
<li><code>Ada</code>将空的<code>bytestring</code>作为<code>CurrencySymbol</code>和<code>TokenName</code>.</li>
<li>可替代代币由<code>CurrencySymbol</code>表示，对于该代币，恰好有一个<code>TokenSymbol</code>可以具有任意非负数(<code>Ada</code>是其中的一个特例).</li>
<li>一类不可替换的代币是一个带有多个标记名的<code>CurrencySymbol</code>，每个代币名都有一个数量。每个名称对应一个唯一的不可替代代币。</li>
<li>混合代币是指具有多个<code>TokenName</code>且数量大于一的代币。</li>
</ul>
<p>在本章中，我们看一个可替代代币的示例。实际上，我们将<code>forge</code>(锻造/伪造)我们自己的货币<code>Plutus</code>，并展示如何进行交易。</p>
<p>对于自定义代币，出现了如何<code>forge</code>(锻造/伪造)它们的问题：此类代币最初是如何形成的？</p>
<p>从技术上讲，这是通过<code>Tx</code>类型的<code>txForge</code>字段发生的:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tx</span> = <span class="type">Tx</span></span></span><br><span class="line">&#123; txInputs      :: <span class="type">Set</span> <span class="type">TxIn</span></span><br><span class="line">, txOutputs     :: [<span class="type">Txout</span>]</span><br><span class="line">, txForge       :: <span class="type">Value</span></span><br><span class="line">, txFee         :: <span class="type">Ada</span></span><br><span class="line">, txValidRange  :: <span class="type">SlotRange</span></span><br><span class="line">, txSignatures  :: <span class="type">Map</span> <span class="type">PubKey</span> <span class="type">Signature</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了使交易有效，输入值和<code>txForge</code>的总和必须等于输出值和<code>txFee</code>的总和，因此通过使交易的<code>txForge</code>具有正值，我们可以<code>create</code>价值(<code>value</code>).</p>
<p>显然，我们不能允许任意交易具有正的<code>txForge</code>值。如果这样做，每个人都可以随时凭空创造价值。</p>
<p>在<code>Cardano</code>区块链上锻造<code>Ada</code>是在创世块中完成。但是我们如何<code>forge</code>(锻造/伪造)<code>Ada</code>以外的代币呢？</p>
<blockquote>
<p>规则是，如果交易的<code>txForge</code>值非零，那么对于该<code>value</code>中的每个货币符号，都必须有一个脚本输入，其验证脚本哈希值等于该货币符号。</p>
</blockquote>
<p>这使我们能够编码自定义代币的货币策略，其中<code>validator</code>脚本通过使用该脚本的哈希作为代币的货币符号来定义此策略。</p>
<p>在我们的示例中，我们需要一个非常简单的货币政策：代币的发行者可以<code>forge</code>(锻造/伪造)任意数量的代币，但没有其他人可以伪造。</p>
<p>让我们首先定义代表此策略的<code>Fungible</code>类型:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds                       #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DeriveAnyClass                  #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE NoImplicitPrelude               #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ScopedTypeVariables             #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TemplateHaskell                 #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# OPTIONS_GHC -fno-warn-missing-signatures #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Token.Fungible <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Language.PlutusTx</span><br><span class="line"><span class="keyword">import</span> Language.PlutusTx.Prelude <span class="keyword">hiding</span> (<span class="title">plus</span>, <span class="title">minus</span>)</span><br><span class="line"><span class="keyword">import</span> Ledger</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Ledger.Ada <span class="keyword">as</span> A</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Ledger.Value <span class="keyword">as</span> V</span><br><span class="line"><span class="keyword">import</span> Playground.Contract</span><br><span class="line"><span class="keyword">import</span> Wallet</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Control.Monad (<span class="title">void</span>)</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.ByteString.Lazy.Char8 <span class="keyword">as</span> C</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Map <span class="keyword">as</span> Map</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Set <span class="keyword">as</span> Set</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Text <span class="keyword">as</span> T</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Fungible</span> = <span class="type">Fungible</span></span></span><br><span class="line">  &#123; name :: <span class="type">TokenName</span> <span class="number">1</span>⃣️</span><br><span class="line">  , issuer :: <span class="type">PubKey</span> <span class="number">2</span>⃣️</span><br><span class="line">  &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Generic</span>, <span class="type">ToJSON</span>, <span class="type">FromJSON</span>, <span class="type">ToSchema</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">makeLift</span> ''<span class="type">Fungible</span></span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 我们的货币名称(例如<code>Plutus</code>).</li>
<li>2⃣️ 被允许<code>forge</code>(锻造/伪造)这种货币的人.</li>
</ul>
<p>该策略永远不会更改，因此对于其数据脚本，我们可以使用单位类型<code>()</code>.</p>
<p>对于<code>redeemer</code>脚本，我们希望包含要<code>forge</code>(伪造)多少钱的信息，因此让我们对这些<code>forge</code>(伪造)代币使用<code>Integer</code>, 这样我们得到:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">FungibleValidator</span> = () -&gt; <span class="type">Integer</span> -&gt; <span class="type">PendingTx</span> -&gt; <span class="type">Bool</span></span></span><br></pre></td></tr></table></figure></p>
<p>我们现在准备写下验证逻辑，即我们的货币的货币政策:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">validateFungible</span> :: <span class="type">Fungible</span> -&gt; <span class="type">FungibleValidator</span> </span><br><span class="line"><span class="title">validateFungible</span> f () n tx =</span><br><span class="line">    <span class="keyword">case</span> pendingTxOutputs tx <span class="keyword">of</span></span><br><span class="line">        [o] -&gt; <span class="keyword">case</span> pendingTxOutData o <span class="keyword">of</span></span><br><span class="line">            <span class="type">DataTxOut</span> -&gt; <span class="type">False</span> </span><br><span class="line">            <span class="type">PubKeyTxOut</span> key -&gt;</span><br><span class="line">                key == issuer f <span class="number">1</span>⃣️</span><br><span class="line">                &amp;&amp; txSignedBy tx (issuer f) <span class="number">2</span>⃣️</span><br><span class="line">                &amp;&amp; pendingTxOutValue o == v <span class="number">3</span>⃣️</span><br><span class="line">        _ -&gt; <span class="type">False</span> <span class="number">4</span>⃣️</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    v :: <span class="type">Value</span> <span class="number">5</span>⃣️ </span><br><span class="line">    v = <span class="type">V</span>.singleton</span><br><span class="line">            (ownCurrencySymbol tx) <span class="number">6</span>⃣️</span><br><span class="line">            (name f)</span><br><span class="line">            n</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1⃣️ 新伪造的钱必须交给货币发行者.</li>
<li>2⃣️ 伪造交易必须由货币发行人签署.</li>
<li>3⃣️ 伪造的值必须是<code>redeemer</code>脚本指示的值.</li>
<li>4⃣️ 我们期望只有一个输出.</li>
<li>5⃣️ 与<code>redeemer</code>脚本相对应的<code>Value</code>.</li>
<li>6⃣️ 与<code>ownHash</code>函数类似，<code>ownCurrencySymbol</code>函数为我们提供了当前正在验证的<code>CurrencySymbol</code>.</li>
</ul>
<p>和以前一样，我们现在可以编写辅助函数来创建各种脚本和地址:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fungibleDataScript</span> :: <span class="type">DataScript</span> </span><br><span class="line"><span class="title">fungibleDataScript</span> = <span class="type">DataScript</span> $ lifted ()</span><br><span class="line"></span><br><span class="line"><span class="title">mkFungibleRedeemerScript</span> :: <span class="type">Integer</span> -&gt; <span class="type">RedeemerScript</span> </span><br><span class="line"><span class="title">mkFungibleRedeemerScript</span> = <span class="type">RedeemerScript</span> . lifted</span><br><span class="line"></span><br><span class="line"><span class="title">mkFungibleValidator</span> :: <span class="type">Fungible</span> -&gt; <span class="type">ValidatorScript</span> </span><br><span class="line"><span class="title">mkFungibleValidator</span> = <span class="type">ValidatorScript</span></span><br><span class="line">                      . applyScript $$(compileScript [|| validateFungible ||]) </span><br><span class="line">                      . lifted</span><br><span class="line"></span><br><span class="line"><span class="title">fungibleAddress</span> :: <span class="type">Fungible</span> -&gt; <span class="type">Address</span> </span><br><span class="line"><span class="title">fungibleAddress</span> = scriptAddress . mkFungibleValidator</span><br><span class="line"></span><br><span class="line"><span class="title">fungibleSymbol</span> :: <span class="type">Fungible</span> -&gt; <span class="type">CurrencySymbol</span></span><br><span class="line"><span class="title">fungibleSymbol</span> f = <span class="keyword">case</span> validatorScriptHash $ mkFungibleValidator f <span class="keyword">of</span></span><br><span class="line">  <span class="type">ValidatorHash</span> h -&gt; <span class="type">V</span>.currencySymbol h</span><br><span class="line"></span><br><span class="line"><span class="title">fungibleValue</span> :: <span class="type">Fungible</span> -&gt; <span class="type">Integer</span> -&gt; <span class="type">Value</span></span><br><span class="line"><span class="title">fungibleValue</span> f = <span class="type">V</span>.singleton (fungibleSymbol f) (name f)</span><br></pre></td></tr></table></figure></p>
<p>现在我们可以将注意力转向编写钱包端点<code>forge</code>，这将允许钱包所有者伪造新货币(前提是她是该货币的发行人).<br>为此，我们首先必须在代表货币政策的脚本地址处创建一个<code>UTXO</code>(值为零).我们必须等到<code>UTXO</code>在区块链上可见，然后才能发出伪造交易，该交易将使用以前的<code>UTXO</code>作为输入来验证其伪造。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">forge</span> :: <span class="keyword">forall</span> m. <span class="type">MonadWallet</span> m</span><br><span class="line">      =&gt; <span class="type">String</span> <span class="comment">-- token name</span></span><br><span class="line">      -&gt; <span class="type">Integer</span> <span class="comment">-- quantity to forge </span></span><br><span class="line">      -&gt; m ()</span><br><span class="line"><span class="title">forge</span> n s = <span class="keyword">do</span></span><br><span class="line">    key &lt;- ownPubKey </span><br><span class="line">    <span class="keyword">let</span> f = <span class="type">Fungible</span></span><br><span class="line">            &#123; name = <span class="type">TokenName</span> $ <span class="type">C</span>.pack n</span><br><span class="line">            , issuer = key <span class="number">1</span>⃣️</span><br><span class="line">            &#125;</span><br><span class="line">    logMsg $ <span class="type">T</span>.pack $</span><br><span class="line">          <span class="string">"forging "</span> ++ show s ++ <span class="string">" of "</span> ++ show f</span><br><span class="line">    startWatching $ fungibleAddress f <span class="number">2</span>⃣️</span><br><span class="line">    void $ createTxAndSubmit <span class="number">3</span>⃣️</span><br><span class="line">        defaultSlotRange</span><br><span class="line">        <span class="type">Set</span>.empty</span><br><span class="line">        [ scriptTxOut</span><br><span class="line">          <span class="type">V</span>.zero </span><br><span class="line">          (mkFungibleValidator f) </span><br><span class="line">          fungibleDataScript</span><br><span class="line">        ]</span><br><span class="line">    go f</span><br><span class="line"> <span class="keyword">where</span></span><br><span class="line">    go :: <span class="type">Fungible</span> -&gt; m () </span><br><span class="line">    go f = <span class="keyword">do</span></span><br><span class="line">        t &lt;- trigger</span><br><span class="line">        registerOnce t $ handler f</span><br><span class="line"></span><br><span class="line">    trigger :: m <span class="type">EventTrigger</span> </span><br><span class="line">    trigger = <span class="keyword">do</span></span><br><span class="line">      sl &lt;- slot</span><br><span class="line">      return $ slotRangeT $ intervalFrom $ sl + <span class="number">1</span>    <span class="number">4</span>⃣️</span><br><span class="line"></span><br><span class="line">    handler :: <span class="type">Fungible</span> -&gt; <span class="type">EventHandler</span> m </span><br><span class="line">    handler f = <span class="type">EventHandler</span> $ const $ <span class="keyword">do</span></span><br><span class="line">        outs &lt;- outputsAt $ fungibleAddress f </span><br><span class="line">        <span class="keyword">case</span> <span class="type">Map</span>.keys outs <span class="keyword">of</span></span><br><span class="line">            (ref : _) -&gt; <span class="keyword">do</span>     <span class="number">5</span>⃣️</span><br><span class="line">                <span class="keyword">let</span> v = fungibleValue f s</span><br><span class="line">                signTxAndSubmit_ <span class="type">Tx</span></span><br><span class="line">                    &#123;  txInputs = <span class="type">Set</span>.singleton $ scriptTxIn <span class="number">6</span>⃣️</span><br><span class="line">                                    ref</span><br><span class="line">                                    (mkFungibleValidator f)</span><br><span class="line">                                    (mkFungibleRedeemerScript s)</span><br><span class="line">                      , txOutputs = [pubKeyTxOut v $ issuer f] <span class="number">7</span>⃣️</span><br><span class="line">                      , txFee = <span class="type">A</span>.zero</span><br><span class="line">                      , txForge = v <span class="number">8</span>⃣️</span><br><span class="line">                      , txValidRange = defaultSlotRange </span><br><span class="line">                      , txSignatures = <span class="type">Map</span>.empty</span><br><span class="line">                    &#125;</span><br><span class="line">            -&gt;  go f  <span class="number">9</span>⃣️</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 钱包所有者必须是货币发行者。</li>
<li>2⃣️ 我们需要观察我们货币的”货币政策”地址，以便能够检测到第一笔交易何时被区块链接受。</li>
<li>3⃣️ 第一笔交易没有输入且值为零。我们需要的只是在”货币政策”-地址处输出的脚本。</li>
<li>4⃣️ 我们只需等待一个<code>slot</code></li>
<li>5⃣️ 我们需要作为<code>input</code>的<code>UTXO</code>位于区块链上。</li>
<li>6⃣️ 我们将第一步创建的<code>UTXO</code>用作伪造交易的输入。</li>
<li>7⃣️ 伪造的<code>value</code>归钱包所有人所有。</li>
<li>8⃣️ 我们实际上在这里伪造。</li>
<li>9⃣️ 如果第一步的交易尚未在区块链上，我们将继续等待。</li>
</ul>
<p>一旦完成，我们就完成了！现在每个人都可以用<code>forge</code>来伪造自己的货币了！</p>
<p>但是，这又提出了一个问题：我们如何交易这种新货币？ -我们知道我们可以发送和接收新货币，就像发送和接收<code>Ada</code>一样。<br>然而，如果我们想出售一些新货币的代币来换取一些<code>Ada</code>呢？我们是否只是简单地发送代币并希望买家将<code>Ada</code>发送回去？我们是否希望买方信任我们并首先发送<code>Ada</code>？</p>
<p>我们可以使用<code>Plutus</code>智能合约，任何人都不必信任任何人进行此类的交易——我们可以简单地定义一个脚本，以保证双方履行其义务:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Trade</span> = <span class="type">Trade</span></span></span><br><span class="line">  &#123; value1 :: <span class="type">Value</span>   <span class="comment">-- 卖家想交易什么</span></span><br><span class="line">  , party1 :: <span class="type">PubKey</span>  <span class="comment">-- 卖家</span></span><br><span class="line">  , value2 :: <span class="type">Value</span>   <span class="comment">-- 买家想付多少钱</span></span><br><span class="line">  , party2 :: <span class="type">PubKey</span>  <span class="comment">-- 买家</span></span><br><span class="line">  , deadline :: <span class="type">Slot</span>  <span class="comment">-- 交易必须在这之前完成</span></span><br><span class="line">  &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Generic</span>, <span class="type">ToJSON</span>, <span class="type">FromJSON</span>, <span class="type">ToSchema</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">makeLift</span> ''<span class="type">Trade</span></span><br></pre></td></tr></table></figure>
<p>我们将编写一个脚本，该脚本使用类型为<code>Trade</code>的值进行参数化，以确保买卖双方都在截止日期之前支付了他们承诺的金额，或者双方都可以收回他们的钱。</p>
<p>该脚本将再次是无状态的，因此<code>data</code>脚本可以再次是<code>()</code>。对于<code>redeemer</code>脚本，我们区分两种可能的操作: 执行成功的交易或在交易失败的情况下一次性收回资金:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">TradeAction</span> = <span class="type">Execute</span> | <span class="type">Reclaim</span></span></span><br><span class="line">    <span class="keyword">deriving</span> <span class="type">Show</span></span><br><span class="line"></span><br><span class="line"><span class="title">makeLift</span> ''<span class="type">TradeAction</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">TradeValidator</span> = () -&gt; <span class="type">TradeAction</span> -&gt; <span class="type">PendingTx</span> -&gt; <span class="type">Bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">validateTrade</span> :: <span class="type">Trade</span> -&gt; <span class="type">TradeValidator</span></span><br><span class="line"><span class="title">validateTrade</span> t () <span class="type">Execute</span> tx = <span class="keyword">case</span> pendingTxOutputs tx <span class="keyword">of</span> <span class="number">1</span>⃣️</span><br><span class="line">      [o1, o2] -&gt; <span class="keyword">case</span> (pendingTxOutData o1, pendingTxOutData o2) <span class="keyword">of</span> <span class="number">2</span>⃣️ </span><br><span class="line">          (<span class="type">PubKeyTxOut</span> key1, <span class="type">PubKeyTxOut</span> key2) -&gt; <span class="number">3</span>⃣️ </span><br><span class="line">                intervalTo (deadline t) <span class="number">4</span>⃣️</span><br><span class="line">                    `contains` pendingTxValidRange tx</span><br><span class="line">              &amp;&amp; key1 == party1 t <span class="number">5</span>⃣️ </span><br><span class="line">              &amp;&amp; key2 == party2 t <span class="number">6</span>⃣️ </span><br><span class="line">              &amp;&amp; pendingTxOutValue o1 == value2 t <span class="number">7</span>⃣️ </span><br><span class="line">              &amp;&amp; pendingTxOutValue o2 == value1 t <span class="number">8</span>⃣️</span><br><span class="line">          -&gt;  <span class="type">False</span></span><br><span class="line">      -   -&gt;  <span class="type">False</span></span><br><span class="line"></span><br><span class="line"><span class="title">validateTrade</span> t () <span class="type">Reclaim</span> tx = <span class="keyword">case</span> pendingTxOutputs tx <span class="keyword">of</span></span><br><span class="line">    [o] -&gt; <span class="keyword">case</span> pendingTxOutData o <span class="keyword">of</span> </span><br><span class="line">        <span class="type">PubKeyTxOut</span> key -&gt;</span><br><span class="line">              intervalFrom (deadline t)</span><br><span class="line">                  `contains` pendingTxValidRange tx</span><br><span class="line">            &amp;&amp; (</span><br><span class="line">                (key == party1 t &amp;&amp; pendingTxOutValue o == value1 t)</span><br><span class="line">                || </span><br><span class="line">                (key == party2 t &amp;&amp; pendingTxOutValue o == value2 t)</span><br><span class="line">              )</span><br><span class="line">        _                 -&gt; <span class="type">False</span></span><br><span class="line">    _   -&gt; <span class="type">False</span></span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 成功交易的情况。</li>
<li>2⃣️ 必须有两个输出</li>
<li>3⃣️ 两个输出都必须指向公钥地址</li>
<li>4⃣️ 这必须在截止日期之前发生</li>
<li>5⃣️ 第一个输出到<code>seller</code></li>
<li>6⃣️ 第二个输出到<code>buyer</code></li>
<li>7⃣️ 卖方得到付款</li>
<li>8⃣️ 买方得到了卖出的价值</li>
</ul>
<p>我们编写了常用的辅助函数，并完成了链上部分:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> mkTradeValidator :: <span class="type">Trade</span> -&gt; <span class="type">ValidatorScript</span> </span><br><span class="line"> mkTradeValidator =</span><br><span class="line">          <span class="type">ValidatorScript</span></span><br><span class="line">        . applyScript $$(compileScript [|| validateTrade ||]) </span><br><span class="line">        . lifted</span><br><span class="line"></span><br><span class="line"><span class="title">tradeDataScript</span> :: <span class="type">DataScript</span> </span><br><span class="line"><span class="title">tradeDataScript</span> = <span class="type">DataScript</span> $ lifted ()</span><br><span class="line"></span><br><span class="line"><span class="title">mkTradeRedeemerScript</span> :: <span class="type">TradeAction</span> -&gt; <span class="type">RedeemerScript</span> </span><br><span class="line"><span class="title">mkTradeRedeemerScript</span> = <span class="type">RedeemerScript</span> . lifted</span><br><span class="line"></span><br><span class="line"><span class="title">tradeAddress</span> :: <span class="type">Trade</span> -&gt; <span class="type">Address</span></span><br><span class="line"><span class="title">tradeAddress</span> = scriptAddress . mkTradeValidator</span><br></pre></td></tr></table></figure>
<p>我们需要两个端点，一个是卖方，一个是买方。为简单起见，我们将不进行任意值的交易，而只考虑卖方出售某种数量的单一货币的情况。</p>
<p>卖家将在交易对应的脚本地址锁定要出售的货币，然后注册两个触发器:</p>
<ul>
<li>如果买方在截止日期之前锁定付款，则第一个触发器将触发。在这种情况下，卖方将通过创建将付款支付给自己，将货币支付给买方的<code>transaction</code>来执行<code>trade</code>(交易)。</li>
<li>如果卖方的资金仍在，第二个触发器将在截止日期一到就触发。当这种情况发生时，交易失败，卖方将收回她的货币</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sell</span> :: <span class="keyword">forall</span> m. <span class="type">MonadWallet</span> m</span><br><span class="line">    =&gt; <span class="type">PubKey</span> <span class="comment">-- currency issuer -&gt; String -- currency name</span></span><br><span class="line">    -&gt; <span class="type">Integer</span> <span class="comment">-- currency quantity -&gt; Value -- price</span></span><br><span class="line">    -&gt; <span class="type">PubKey</span> <span class="comment">-- buyer</span></span><br><span class="line">    -&gt; <span class="type">Slot</span> <span class="comment">-- deadline</span></span><br><span class="line">    -&gt; m ()</span><br><span class="line"><span class="title">sell</span> i c n v2 p2 dl = <span class="keyword">do</span> </span><br><span class="line">    <span class="keyword">let</span> f = <span class="type">Fungible</span></span><br><span class="line">            &#123; issuer = i</span><br><span class="line">            , name = <span class="type">TokenName</span> $ <span class="type">C</span>.pack c </span><br><span class="line">            &#125;</span><br><span class="line">      v1 = fungibleValue f n </span><br><span class="line">    p1 &lt;- ownPubKey</span><br><span class="line">    <span class="keyword">let</span> t = <span class="type">Trade</span></span><br><span class="line">            &#123; value1 =v1</span><br><span class="line">            , party1 =p1 </span><br><span class="line">            , value2 =v2 </span><br><span class="line">            , party2 =p2</span><br><span class="line">            , deadline = dl</span><br><span class="line">            &#125;</span><br><span class="line">    logMsg $ <span class="type">T</span>.pack $ <span class="string">"starting sale in "</span> ++ show t</span><br><span class="line"></span><br><span class="line">    tx &lt;- payToScript <span class="number">1</span>⃣️</span><br><span class="line">        defaultSlotRange</span><br><span class="line">        (tradeAddress t) </span><br><span class="line">        v1 </span><br><span class="line">        tradeDataScript</span><br><span class="line">    registerOnce (trigger1 t) (handler1 t) </span><br><span class="line">    registerOnce (trigger2 t) (handler2 t tx</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    trigger1 :: <span class="type">Trade</span> -&gt; <span class="type">EventTrigger</span> <span class="number">2</span>⃣️</span><br><span class="line">    trigger1 t =</span><br><span class="line">      fundsAtAddressGeqT </span><br><span class="line">          (tradeAddress t)</span><br><span class="line">          (value1 t &lt;&gt; value2 t) </span><br><span class="line">      `andT`</span><br><span class="line">      slotRangeT</span><br><span class="line">          (intervalTo $ deadline t)</span><br><span class="line"></span><br><span class="line">    trigger2 t = <span class="number">3</span>⃣️</span><br><span class="line">      fundsAtAddressGeqT</span><br><span class="line">          (tradeAddress t)</span><br><span class="line">          (value1 t) </span><br><span class="line">      `andT`</span><br><span class="line">      slotRangeT</span><br><span class="line">          (intervalFrom $ deadline t)</span><br><span class="line"></span><br><span class="line">    handler1 :: <span class="type">Trade</span> -&gt; <span class="type">EventHandler</span> m <span class="number">4</span>⃣️</span><br><span class="line">    handler1 t = <span class="type">EventHandler</span> $ const $ <span class="keyword">do</span></span><br><span class="line">      logMsg $ <span class="type">T</span>.pack $ <span class="string">"executing "</span> ++ show t </span><br><span class="line">      m &lt;- outputsAt $ tradeAddress t</span><br><span class="line">      <span class="keyword">let</span> ins = <span class="type">Set</span>.fromList</span><br><span class="line">            [ scriptTxIn </span><br><span class="line">                r</span><br><span class="line">                (mkTradeValidator t)</span><br><span class="line">                (mkTradeRedeemerScript <span class="type">Execute</span>) </span><br><span class="line">            | r &lt;- <span class="type">Map</span>.keys m</span><br><span class="line">            ]</span><br><span class="line">          outs =</span><br><span class="line">            [ pubKeyTxOut (value2 t) (party1 t) </span><br><span class="line">            , pubKeyTxOut (value1 t) (party2 t) </span><br><span class="line">            ]</span><br><span class="line">      void $ createTxAndSubmit </span><br><span class="line">          (intervalTo $ deadline t) </span><br><span class="line">          ins</span><br><span class="line">          outs</span><br><span class="line">    </span><br><span class="line">    handler2 :: <span class="type">Trade</span> -&gt; <span class="type">Tx</span> -&gt; <span class="type">EventHandler</span> m <span class="number">5</span>⃣️ </span><br><span class="line">    handler2 t tx = <span class="type">EventHandler</span> $ const $ <span class="keyword">do</span></span><br><span class="line">          logMsg $ <span class="type">T</span>.pack $ <span class="string">"reclaiming "</span> ++ show t </span><br><span class="line">          collectFromScriptTxn</span><br><span class="line">              (intervalFrom $ deadline t) </span><br><span class="line">              (mkTradeValidator t) </span><br><span class="line">              (mkTradeRedeemerScript <span class="type">Reclaim</span>) </span><br><span class="line">              (hashTx tx)</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 将货币锁定在<code>trade</code>(交易)脚本上。</li>
<li>2⃣️ 买方在截止日期之前付款了吗？</li>
<li>3⃣️ 期限已过，我的资金是否仍被锁定？</li>
<li>4⃣️ 执行<code>trade</code>(交易)</li>
<li>5⃣️ 收回货币</li>
</ul>
<p>买方的<code>buy</code>端点要简单一些，因为卖方负责执行成功的交易。因此，买方仅需担心在交易失败的情况下收回付款:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">buy</span> :: <span class="keyword">forall</span> m. <span class="type">MonadWallet</span> m</span><br><span class="line">    =&gt; <span class="type">PubKey</span> <span class="comment">-- currency issuer -&gt; String -- currency name</span></span><br><span class="line">    -&gt; <span class="type">Integer</span> <span class="comment">-- currency quantity -&gt; PubKey -- seller</span></span><br><span class="line">    -&gt; <span class="type">Value</span> <span class="comment">-- price</span></span><br><span class="line">    -&gt; <span class="type">Slot</span> <span class="comment">-- deadline</span></span><br><span class="line">    -&gt; m ()</span><br><span class="line"><span class="title">buy</span> i c n p1 v2 dl = <span class="keyword">do</span> </span><br><span class="line">    <span class="keyword">let</span> f = <span class="type">Fungible</span></span><br><span class="line">            &#123; issuer = i</span><br><span class="line">            , name = <span class="type">TokenName</span> $ <span class="type">C</span>.pack c </span><br><span class="line">            &#125;</span><br><span class="line">        v1 = fungibleValue f n p2 &lt;- ownPubKey</span><br><span class="line">    <span class="keyword">let</span> t = <span class="type">Trade</span></span><br><span class="line">            &#123; value1 =v1</span><br><span class="line">            , party1 =p1 </span><br><span class="line">            , value2 =v2 </span><br><span class="line">            , party2 =p2 </span><br><span class="line">            , deadline = dl </span><br><span class="line">            &#125;</span><br><span class="line">    logMsg $ <span class="type">T</span>.pack $ <span class="string">"starting buy in "</span> ++ show t</span><br><span class="line"></span><br><span class="line">    tx &lt;- payToScript <span class="number">1</span>⃣️</span><br><span class="line">        defaultSlotRange</span><br><span class="line">        (tradeAddress t) </span><br><span class="line">        v2 </span><br><span class="line">        tradeDataScript</span><br><span class="line">    registerOnce (trigger t) (handler t tx)</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    trigger t = <span class="number">2</span>⃣️</span><br><span class="line">        fundsAtAddressGeqT </span><br><span class="line">            (tradeAddress t)</span><br><span class="line">            (value2 t) </span><br><span class="line">        `andT`</span><br><span class="line">        slotRangeT</span><br><span class="line">            (intervalFrom $ deadline t)</span><br><span class="line"></span><br><span class="line">    handler :: <span class="type">Trade</span> -&gt; <span class="type">Tx</span> -&gt; <span class="type">EventHandler</span> m <span class="number">3</span>⃣️ </span><br><span class="line">    handler t tx = <span class="type">EventHandler</span> $ const $ <span class="keyword">do</span></span><br><span class="line">        logMsg $ <span class="type">T</span>.pack $ <span class="string">"reclaiming "</span> ++ show t </span><br><span class="line">        collectFromScriptTxn</span><br><span class="line">            (intervalFrom $ deadline t) </span><br><span class="line">            (mkTradeValidator t) </span><br><span class="line">            (mkTradeRedeemerScript <span class="type">Reclaim</span>) </span><br><span class="line">            (hashTx tx)</span><br><span class="line"></span><br><span class="line">$(mkFunctions ['forge, 'sell, 'buy])</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 将付款锁定在<code>trade</code>(交易)脚本上。</li>
<li>2⃣️ 期限已过，我的付款是否仍被锁定？</li>
<li>3⃣️ 收回付款。</li>
</ul>
<p>最后，我们可以在<code>Playground</code>中测试所有这些情况: <code>wallet #1</code>伪造了20个单位的新货币<code>Plutus</code>，然后用<code>wallet #2</code>将其中的10个兑换为<code>5Ada</code>:</p>
<p><img src="Plutus编写可靠的智能合约/11-01.png" alt=""></p>
<p><img src="Plutus编写可靠的智能合约/11-02.png" alt=""></p>
<p><img src="Plutus编写可靠的智能合约/11-03.png" alt=""></p>
<p><img src="Plutus编写可靠的智能合约/11-04.png" alt=""></p>
<p>正如预期的那样，<code>wallet #1</code>最终获得<code>15 Ada</code>和<code>10 Plutus</code>，而<code>wallet #2</code>最终获得<code>5 Ada</code>和<code>10 Plutus</code>.</p>
<p>这就是整个序列在区块链上的样子：<code>wallet #1</code>的所有者<code>Alice</code>的第一笔交易创建了<code>Plutus</code>货币政策的脚本输出。她的第二笔交易伪造了20个<code>Plutus</code>。然后，她将10个<code>Plutus</code>锁定在与<code>wallet #2</code>所有者<code>Bob</code>的交易脚本中，后者也将5个<code>Ada</code>的价格锁定在该脚本中。最终<code>transaction</code>(交易)执行<code>trade</code>(交易)。</p>
<p><img src="Plutus编写可靠的智能合约/11-05.png" alt=""></p>
<p>至此结束本章。 我们已经学习了如何超越Ada并使用任意的自定义代币，如何伪造新代币以及如何安全地进行交易。</p>
<h3 id="一个复杂的例子-安全的不可替代代币"><a href="#一个复杂的例子-安全的不可替代代币" class="headerlink" title="一个复杂的例子: 安全的不可替代代币"></a>一个复杂的例子: 安全的不可替代代币</h3><p>在本章中，我们要展示一个复杂而安全的系统的演变。我们将分几个步骤开发解决方案，每个步骤都比前一个步骤更安全。在此过程中，我们将学习一些新的和有趣的设计技术，并深入研究上一章介绍的自定义代币系统。</p>
<p>想象一下，我们刚刚有了一个绝妙的想法：我们希望通过将艺术品链接到区块链上独特的、不可替代的代币来将其标记化。这些代币中的每一个都将与一件特定的艺术品相关联，因此，只需交易相应的代币，就可以很容易地交易一幅画的所有权。</p>
<p>这本书是关于Plutus的，而不是国际法，所以让我们假设我们的律师已经用这个想法解决了所有的法律问题，我们也解决了将真实世界的艺术品与区块链上的代币联系起来的问题(可能通过与一位知名的艺术经销商建立合作关系，后者公开证明某某某绘画作品的所有权是由某某某标志决定的)</p>
<p>让我们把注意力集中在技术挑战上，使智能合约方面的事情尽可能无懈可击！</p>
<p>在上一章中，我们使用了一个<code>currency symbol</code>(货币符号)和一个代币名称作为我们的自定义货币，我们现在需要每个代币一个代币名称，即每个我们想要代币化的艺术品都有一个代币名称。</p>
<p>让我们从创造一个只允许我们伪造新代币的货币政策开始:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds                       #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DeriveAnyClass                  #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE NoImplicitPrelude               #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ScopedTypeVariables             #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TemplateHaskell                 #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# OPTIONS_GHC -fno-warn-missing-signatures #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> NonFungible.NonFungible1 <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>  Language.PlutusTx</span><br><span class="line"><span class="keyword">import</span>  Language.PlutusTx.Prelude <span class="keyword">hiding</span> (<span class="title">plus</span>, <span class="title">minus</span>)</span><br><span class="line"><span class="keyword">import</span>  Ledger</span><br><span class="line"><span class="keyword">import</span>  <span class="keyword">qualified</span> Ledger.Ada <span class="keyword">as</span> A</span><br><span class="line"><span class="keyword">import</span>  <span class="keyword">qualified</span> Ledger.Value <span class="keyword">as</span> V</span><br><span class="line"><span class="keyword">import</span>  Playground.Contract</span><br><span class="line"><span class="keyword">import</span>  Wallet</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>  Control.Monad (<span class="title">void</span>)</span><br><span class="line"><span class="keyword">import</span>  Control.Monad.Except (<span class="type">MonadError</span> (..))</span><br><span class="line"><span class="keyword">import</span>  <span class="keyword">qualified</span> Data.ByteString.Lazy.Char8 <span class="keyword">as</span> C</span><br><span class="line"><span class="keyword">import</span>  <span class="keyword">qualified</span> Data.Map.Strict  <span class="keyword">as</span> Map </span><br><span class="line"><span class="keyword">import</span>  <span class="keyword">qualified</span> Data.Set <span class="keyword">as</span> Set</span><br><span class="line"><span class="keyword">import</span>  <span class="keyword">qualified</span> Data.Text <span class="keyword">as</span> T</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">NonFungible</span> = <span class="type">NonFungible</span></span></span><br><span class="line">    &#123; issuer :: <span class="type">PubKey</span>    <span class="number">1</span>⃣️</span><br><span class="line">    &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Generic</span>, <span class="type">ToJSON</span>, <span class="type">FromJSON</span>, <span class="type">ToSchema</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">makeLift</span> ''<span class="type">NonFungible</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>1⃣️ 我们要记住的就是我们自己的公钥。</li>
</ul>
<p>数据脚本可以是<code>()</code>, <code>redeemer</code>脚本应该包含我们想要伪造的代币的名称。这将导致以下验证逻辑：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">NonFungibleValidator</span> =</span></span><br><span class="line">    ()</span><br><span class="line">    -&gt; <span class="type">TokenName</span></span><br><span class="line">    -&gt; <span class="type">PendingTx</span></span><br><span class="line">    -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="title">validateNonFungible</span> :: <span class="type">NonFungible</span> -&gt; <span class="type">NonFungibleValidator</span> </span><br><span class="line"><span class="title">validateNonFungible</span> nf () name tx =</span><br><span class="line">       txSignedBy tx (issuer nf) <span class="number">1</span>⃣️ </span><br><span class="line">    &amp;&amp; foldl f <span class="type">V</span>.zero (pendingTxOutputs tx) == v <span class="number">2</span>⃣️</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    v :: <span class="type">Value</span></span><br><span class="line">    v = <span class="type">V</span>.singleton</span><br><span class="line">      (ownCurrencySymbol tx) <span class="number">3</span>⃣️</span><br><span class="line">      name</span><br><span class="line">      <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    f :: <span class="type">Value</span> -&gt; <span class="type">PendingTxOut</span> -&gt; <span class="type">Value</span></span><br><span class="line">    f w o = w `<span class="type">V</span>.plus` pendingTxOutValue o</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️  <code>transaction</code>(交易)必须由我们签名，这样别人就不能伪造新的代币了。</li>
<li>2⃣️  所有输出值的总和应完全由新伪造的代币组成。</li>
<li>3⃣️  代币的货币符号将是我们的<code>validator</code>脚本的哈希。</li>
</ul>
<p>接下来我们创建一些助手函数:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mkNonFungibleRedeemer</span> :: <span class="type">String</span> -&gt; <span class="type">RedeemerScript</span> </span><br><span class="line"><span class="title">mkNonFungibleRedeemer</span> name =</span><br><span class="line">    <span class="keyword">let</span> s = $$(compileScript [|| \(t :: <span class="type">TokenName</span>) (_ :: <span class="type">Sealed</span> (<span class="type">HashedDataScript</span> ())) -&gt; t ||])</span><br><span class="line">      <span class="keyword">in</span> <span class="type">RedeemerScript</span> $ applyScript s $ lifted $ <span class="type">TokenName</span> $ <span class="type">C</span>.pack name</span><br><span class="line"></span><br><span class="line"><span class="title">mkNonFungibleValidator</span> :: <span class="type">NonFungible</span> -&gt; <span class="type">ValidatorScript</span> </span><br><span class="line"><span class="title">mkNonFungibleValidator</span> = <span class="type">ValidatorScript</span></span><br><span class="line">                        . applyScript $$(compileScript [|| validateNonFungible ||]) </span><br><span class="line">                        . lifted</span><br><span class="line"></span><br><span class="line"><span class="title">nonFungibleAddress</span> :: <span class="type">NonFungible</span> -&gt; <span class="type">Address</span> </span><br><span class="line"><span class="title">nonFungibleAddress</span> = scriptAddress . mkNonFungibleValidator</span><br><span class="line"></span><br><span class="line"><span class="title">nonFungibleSymbol</span> :: <span class="type">NonFungible</span> -&gt; <span class="type">CurrencySymbol</span></span><br><span class="line"><span class="title">nonFungibleSymbol</span> nf = <span class="keyword">case</span> validatorScriptHash $ mkNonFungibleValidator nf <span class="keyword">of</span></span><br><span class="line">      <span class="type">ValidatorHash</span> h -&gt; <span class="type">V</span>.currencySymbol h</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 给定一个令牌名称(为了方便起见，用字符串表示)，返回相应令牌的值。</span></span><br><span class="line"><span class="title">nonFungibleValue</span> :: <span class="type">NonFungible</span> -&gt; <span class="type">String</span> -&gt; <span class="type">Value</span> </span><br><span class="line"><span class="title">nonFungibleValue</span> nf name = <span class="type">V</span>.singleton</span><br><span class="line">      (nonFungibleSymbol nf) </span><br><span class="line">      (<span class="type">TokenName</span> $ <span class="type">C</span>.pack name)</span><br><span class="line">      <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为我们的货币政策创建一个脚本输出。</span></span><br><span class="line"><span class="title">mkNonFungibleTxOut</span> :: <span class="type">NonFungible</span> -&gt; <span class="type">TxOut</span> </span><br><span class="line"><span class="title">mkNonFungibleTxOut</span> nf =</span><br><span class="line">    scriptTxOut </span><br><span class="line">        <span class="type">V</span>.zero</span><br><span class="line">        (mkNonFungibleValidator nf)</span><br><span class="line">        unitData</span><br></pre></td></tr></table></figure>
<p><code>unitData</code>助手为我们创建一个类型为<code>()</code>的数据脚本。</p>
<p>现在我们可以写钱包端点了。我们将提供两个:</p>
<ul>
<li>通过创建脚本的一个输出来表示我们的货币政策，然后通过<code>start</code>来初始化我们的业务</li>
<li><code>forge</code>实际上是伪造一个新的代币。为简单起见，我们将始终将新伪造的代币发送到我们自己的钱包中。</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">start</span> :: <span class="type">MonadWallet</span> m =&gt; m () </span><br><span class="line"><span class="title">start</span> = <span class="keyword">do</span></span><br><span class="line">  key &lt;- ownPubKey</span><br><span class="line">  <span class="keyword">let</span> nf = <span class="type">NonFungible</span> &#123;issuer = key&#125; <span class="number">1</span>⃣️</span><br><span class="line">  logMsg $ <span class="type">T</span>.pack $</span><br><span class="line">    <span class="string">"starting "</span> ++ show nf</span><br><span class="line">  startWatching $ nonFungibleAddress nf <span class="number">2</span>⃣️</span><br><span class="line">  void $ createTxAndSubmit <span class="number">3</span>⃣️ </span><br><span class="line">      defaultSlotRange</span><br><span class="line">      <span class="type">Set</span>.empty </span><br><span class="line">      [mkNonFungibleTxOut nf]</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 当然，我们将成为发行人。</li>
<li>2⃣️ 我们需要注意与我们的货币政策相对应的地址，因为我们需要在该地址找到输出以进行伪造</li>
<li>3⃣️ 我们根据货币政策创建一个输出</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">forge</span> :: <span class="keyword">forall</span> m. <span class="type">MonadWallet</span> m </span><br><span class="line">      =&gt; <span class="type">String</span> <span class="comment">-- token name</span></span><br><span class="line">      -&gt; m () </span><br><span class="line"><span class="title">forge</span> n = <span class="keyword">do</span></span><br><span class="line">    key &lt;- ownPubKey</span><br><span class="line">    <span class="keyword">let</span> nf = <span class="type">NonFungible</span> &#123;issuer = key&#125; </span><br><span class="line">    logMsg $ <span class="type">T</span>.pack $</span><br><span class="line">      <span class="string">"forging "</span> ++ n ++ <span class="string">" of "</span> ++ show nf</span><br><span class="line">    outs &lt;- outputsAt $ nonFungibleAddress nf <span class="number">1</span>⃣️</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Map</span>.keys outs <span class="keyword">of</span></span><br><span class="line">        [ref] -&gt; <span class="keyword">do</span> <span class="number">2</span>⃣️ </span><br><span class="line">            <span class="keyword">let</span> v = nonFungibleValue nf n <span class="number">3</span>⃣️</span><br><span class="line">            signTxAndSubmit_ <span class="type">Tx</span></span><br><span class="line">                &#123; txInputs = <span class="type">Set</span>.singleton $ scriptTxIn <span class="number">4</span>⃣️</span><br><span class="line">                                ref</span><br><span class="line">                                (mkNonFungibleValidator nf)</span><br><span class="line">                                (mkNonFungibleRedeemer n)</span><br><span class="line">                , txOutputs = [ pubKeyTxOut v $ issuer nf <span class="number">5</span>⃣️</span><br><span class="line">                              , mkNonFungibleTxOut nf</span><br><span class="line">                              ]</span><br><span class="line">                , txFee     = <span class="type">A</span>.zero</span><br><span class="line">                , txForge   = v  <span class="number">6</span>⃣️</span><br><span class="line">                , txValidRange = defaultSlotRange</span><br><span class="line">                , txSignatures = <span class="type">Map</span>.empty</span><br><span class="line">                &#125;</span><br><span class="line">        _   -&gt; throwError $  <span class="number">7</span>⃣️</span><br><span class="line">                  <span class="type">OtherError</span> $ <span class="type">T</span>.pack <span class="string">"'start' has not run"</span></span><br><span class="line"></span><br><span class="line">$(mkFunctions ['start, 'forge])</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 我们获取与货币政策相对应的所有输出</li>
<li>2⃣️ 应该只有一个这样的输出</li>
<li>3⃣️ 我们想要伪造的代币的<code>Value</code></li>
<li>4⃣️ 我们需要货币政策输出作为我们进行<code>forging</code>(伪造)交易的输入</li>
<li>5⃣️ 我们需要两个输出，一个用于伪造代币，一个用于货币政策(以便我们有可用于伪造下一个代币的输出)</li>
<li>6⃣️ 我们实际上在这里伪造</li>
<li>7⃣️ 输出不在那里，所以我们可能忘了先运行<code>start</code></li>
</ul>
<p>我们可以在<code>Plutus</code>游乐场进行测试，并为达芬奇的《蒙娜丽莎》和梵高的《星夜》铸造代币(是的，我们非常乐观的是卢浮宫和现代艺术博物馆将渴望与我们携手合作…)。</p>
<p><img src="Plutus编写可靠的智能合约/12-01.png" alt=""></p>
<p><img src="Plutus编写可靠的智能合约/12-02.png" alt=""></p>
<p>有用！我们现在是<code>Mona Lisa</code>代币和<code>The Starry Night</code>代币的骄傲所有者。</p>
<p>我们完了吗？ 我们可以部署这些脚本并开展业务吗？</p>
<p>我们确保我们的货币政策保证只有我们才能伪造代币，那么还有什么可能出问题呢？</p>
<p>我们应该记住，脚本仅使用脚本输出作为输入进行验证，但是任何人都可以使用任意脚本输出创建交易。在我们的案例中，这意味着某些恶作剧者（或商业竞争对手）可以通过在我们的货币政策中创建另一个输出来从中捣乱：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这将由其他钱包运行</span></span><br><span class="line"><span class="title">prank</span> :: <span class="type">MonadWallet</span> m =&gt; <span class="type">Wallet</span> -&gt; m () </span><br><span class="line"><span class="title">prank</span> w = <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">let</span> nf = <span class="type">NonFungible</span> &#123;issuer = walletPubKey w&#125; <span class="number">1</span>⃣️ </span><br><span class="line">    logMsg $ <span class="type">T</span>.pack $</span><br><span class="line">        <span class="string">"playing prank on "</span> ++ show nf</span><br><span class="line">    <span class="keyword">let</span> v = <span class="type">A</span>.toValue <span class="number">1</span></span><br><span class="line">    (ins, mout) &lt;- createPaymentWithChange v</span><br><span class="line">    pk &lt;- ownPubKey</span><br><span class="line">    void $ createTxAndSubmit <span class="number">2</span>⃣️</span><br><span class="line">        defaultSlotRange </span><br><span class="line">        ins</span><br><span class="line">        (scriptTxOut</span><br><span class="line">            <span class="type">V</span>.zero </span><br><span class="line">            (mkNonFungibleValidator nf) </span><br><span class="line">            unitData</span><br><span class="line">        : pubKeyTxOut v pk </span><br><span class="line">        : maybeToList mout</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">$(mkFunctions ['start, 'forge, 'prank])</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1⃣️ 我们使用模块<code>Wallet.Emulator</code>中的<code>walletPubKey</code>来轻松查找属于钱包的公钥。</li>
<li>2⃣️ 我们创建一个输入为<code>1 ada</code>和两个输出的交易，一个输出向我们返还<code>1ada</code>，另一个向货币政策脚本(具有零值)输出。</li>
</ul>
<p>为什么我们需要一个<code>1ada</code>的输入，我们会立即偿还？为什么我们不能像<code>start</code>那样简单地做呢？如果我们这样做，恶作剧者创建的交易将具有与<code>start</code>创建的交易相同的标识符，因为这两个交易将具有完全相同的输入和输出。然后，脚本输出将无法与<code>start</code>创建的常规输出区分开来。但是这个恶作剧的全部目的是创建一个不同的脚本输出来破坏我们的代码！</p>
<p>请注意，这只是我们在操场上测试时的一个问题；在一个真正的区块链上，每笔交易都必须支付一笔费用，因此永远不会有两笔交易具有相同的输入和输出，因为区块链防止了双重消费。因此，区块链上永远不会有两个具有相同标识符的有效交易。</p>
<p>我们可以在操场上尝试<code>prank</code>的效果，并在伪造<code>Mona Lisa</code>代币后让<code>Wallet #2</code>调用它:</p>
<p><img src="Plutus编写可靠的智能合约/12-03.png" alt=""></p>
<p>恶作剧有效，并且伪造<code>The Starry Night</code>代币失败。</p>
<p><img src="Plutus编写可靠的智能合约/12-04.png" alt=""></p>
<p>更糟的是，我们收到一个误导性的错误消息:</p>
<p><img src="Plutus编写可靠的智能合约/12-05.png" alt=""></p>
<p>那么该怎么办呢？实际上，一旦我们意识到为了进行伪造，我们就不会在乎使用我们自己还是他人创建的脚本输出，这是一个一行的解决方案。任何人都会做的:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">forge</span> :: <span class="keyword">forall</span> m. <span class="type">MonadWallet</span> m </span><br><span class="line">      =&gt; <span class="type">String</span> <span class="comment">-- token name</span></span><br><span class="line">      -&gt; m () </span><br><span class="line"><span class="title">forge</span> n = <span class="keyword">do</span></span><br><span class="line">    key &lt;- ownPubKey</span><br><span class="line">    <span class="keyword">let</span> nf = <span class="type">NonFungible</span> &#123;issuer = key&#125; </span><br><span class="line">    logMsg $ <span class="type">T</span>.pack $</span><br><span class="line">          <span class="string">"forging "</span> ++ n ++ <span class="string">" of "</span> ++ show nf</span><br><span class="line"></span><br><span class="line">    outs &lt;- outputsAt $ nonFungibleAddress nf</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Map</span>.keys outs <span class="keyword">of</span></span><br><span class="line">        (ref : _) -&gt; <span class="keyword">do</span>   <span class="number">1</span>⃣️</span><br><span class="line">            <span class="keyword">let</span> v = nonFungibleValue nf n</span><br><span class="line">            signTxAndSubmit_ <span class="type">Tx</span></span><br><span class="line">                &#123; txInputs  = <span class="type">Set</span>.singleton $ scriptTxIn</span><br><span class="line">                                ref</span><br><span class="line">                                (mkNonFungibleValidator nf)</span><br><span class="line">                                (mkNonFungibleRedeemer n)</span><br><span class="line">                , txOutputs = [ pubKeyTxOut v $ issuer nf</span><br><span class="line">                              , mkNonFungibleTxOut nf</span><br><span class="line">                              ]</span><br><span class="line">                , txFee     = <span class="type">A</span>.zero</span><br><span class="line">                , txForge   = v</span><br><span class="line">                , txValidRange = defaultSlotRange</span><br><span class="line">                , txSignatures = <span class="type">Map</span>.empty</span><br><span class="line">                &#125;</span><br><span class="line">        _   -&gt; throwError $</span><br><span class="line">                  <span class="type">OtherError</span> $ <span class="type">T</span>.pack <span class="string">"'start' has not run"</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>1⃣️ 我们只需要至少一个输出，而我们只需获取第一个。</li>
</ul>
<p>当我们在操场上进行与之前相同的操作时，我们将获得<code>The Starry Night</code>代币：</p>
<p><img src="Plutus编写可靠的智能合约/12-06.png" alt=""></p>
<p><img src="Plutus编写可靠的智能合约/12-07.png" alt=""></p>
<p>唉，现在恶作剧者可以开始他的游戏，把下面的一行改成<code>prank</code>(恶作剧):</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- This will be run by a different wallet.</span></span><br><span class="line"><span class="title">prank</span> :: <span class="type">MonadWallet</span> m =&gt; <span class="type">Wallet</span> -&gt; m () </span><br><span class="line"><span class="title">prank</span> w = <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">let</span> nf = <span class="type">NonFungible</span> &#123;issuer = walletPubKey w&#125; </span><br><span class="line">    logMsg $ <span class="type">T</span>.pack $</span><br><span class="line">        <span class="string">"playing prank on "</span> ++ show nf</span><br><span class="line">    <span class="keyword">let</span> v = <span class="type">A</span>.toValue <span class="number">1</span></span><br><span class="line">    (ins, mout) &lt;- createPaymentWithChange v </span><br><span class="line">    pk &lt;- ownPubKey</span><br><span class="line">    void $ createTxAndSubmit</span><br><span class="line">        defaultSlotRange </span><br><span class="line">        ins</span><br><span class="line">        (scriptTxOut</span><br><span class="line">            <span class="type">V</span>.zero</span><br><span class="line">            (mkNonFungibleValidator nf)</span><br><span class="line">            (<span class="type">DataScript</span> $ lifted (<span class="number">42</span> :: <span class="type">Integer</span>)) <span class="number">1</span>⃣️</span><br><span class="line">        : pubKeyTxOut v pk </span><br><span class="line">        : maybeToList mout</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">$(mkFunctions ['start, 'forge, 'prank])</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 恶作剧者没有将<code>()</code>作为数据脚本传入，而是传入<code>Integer</code>类型的<code>42</code>，即”错误”类型！</li>
</ul>
<p>这次，他不得不更加努力地破坏我们，不得不多次调用<code>prank</code>:</p>
<p><img src="Plutus编写可靠的智能合约/12-08.png" alt=""></p>
<p><img src="Plutus编写可靠的智能合约/12-09.png" alt=""></p>
<p><img src="Plutus编写可靠的智能合约/12-10.png" alt=""></p>
<p>请注意，这次我们还会收到其他错误消息，不是我们的自定义钱包错误，而是”脚本错误”。</p>
<p>那么发生了什么？</p>
<p>我们必须认识到，交易的<code>script outputs</code>不会被验证，只有<code>script inputs</code>会被验证.<br>这意味着不检查脚本输出的<code>data script</code>;特别是，它可以是任意类型(如我们的示例中的整数).</p>
<p>当我们选择”错误”类型的输出作为伪造交易的输入时会发生什么？该输入将被验证，并且我们的验证器假设数据脚本的类型为<code>()</code>。因此，当类型不是预期的类型时，它将在不执行任何验证代码的情况下失败。</p>
<p>为什么在这次攻击中，恶作剧者必须多次调用<code>prank</code>？ -对于锻造，我们选择找到的第一个脚本输出。如果幸运的话，我们选择一个我们自己创建的脚本，其中包含一个具有正确类型的数据脚本。</p>
<p>我们”查看”<code>outputsAt</code>的结果的顺序是一个实现细节，它取决于创建输出的交易的哈希值。<br>通过多次调用<code>prank</code>，该恶作剧者增加了他的输出之一成为我们的钱包看到的第一个输出的可能性，这反过来将导致在验证期间<code>forge</code>的失败。</p>
<p>我们怎样才能抵御这种狡猾而微妙的攻击呢？-实际上非常简单：我们不选择找到的第一个脚本输出，而是简单地过滤输出并检查它们的数据脚本：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">forge</span> :: <span class="keyword">forall</span> m. <span class="type">MonadWallet</span> m </span><br><span class="line">      =&gt; <span class="type">String</span> <span class="comment">-- token name</span></span><br><span class="line">      -&gt; m () </span><br><span class="line"><span class="title">forge</span> n = <span class="keyword">do</span></span><br><span class="line">    key &lt;- ownPubKey</span><br><span class="line">    <span class="keyword">let</span> nf = <span class="type">NonFungible</span> &#123;issuer = key&#125; </span><br><span class="line">    logMsg $ <span class="type">T</span>.pack $</span><br><span class="line">        <span class="string">"forging "</span> ++ n ++ <span class="string">" of "</span> ++ show nf</span><br><span class="line">    outs &lt;- outputsAt $ nonFungibleAddress nf</span><br><span class="line">    <span class="keyword">case</span> map fst $ filter f $ <span class="type">Map</span>.toList outs <span class="keyword">of</span> <span class="number">1</span>⃣️</span><br><span class="line">        (ref : _) -&gt; <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">let</span> v = nonFungibleValue nf n</span><br><span class="line">            signTxAndSubmit_ <span class="type">Tx</span></span><br><span class="line">              &#123; txInputs  = <span class="type">Set</span>.singleton $ scriptTxIn</span><br><span class="line">                              ref</span><br><span class="line">                              (mkNonFungibleValidator nf)</span><br><span class="line">                              (mkNonFungibleRedeemer n)</span><br><span class="line">              , txOutputs = [ pubKeyTxOut v $ issuer nf</span><br><span class="line">                            , mkNonFungibleTxOut nf</span><br><span class="line">                            ]</span><br><span class="line">              , txFee     = <span class="type">A</span>.zero</span><br><span class="line">              , txForge   = v</span><br><span class="line">              , txValidRange = defaultSlotRange </span><br><span class="line">              , txSignatures = <span class="type">Map</span>.empty</span><br><span class="line">              &#125;</span><br><span class="line">        _     -&gt;  throwError $</span><br><span class="line">                      <span class="type">OtherError</span> $ <span class="type">T</span>.pack <span class="string">"'start' has not run"</span></span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    f :: (<span class="type">TxOutRef</span>, <span class="type">TxOut</span>) -&gt; <span class="type">Bool</span> </span><br><span class="line">    f (_, o) = <span class="keyword">case</span> txOutType o <span class="keyword">of</span></span><br><span class="line">        <span class="type">PayToPubKey</span> _ -&gt; <span class="type">False</span> <span class="number">2</span>⃣️</span><br><span class="line">        <span class="type">PayToScript</span> ds -&gt; ds == unitData  <span class="number">3</span>⃣️</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1⃣️ 我们过滤在脚本地址找到的输出</li>
<li>2⃣️ 这种情况实际上是不可能的，因为我们知道这是脚本的输出</li>
<li>3⃣️ 我们检查数据脚本是否是预期的，即<code>()</code></li>
</ul>
<p>在操场上再次尝试同样的动作，<code>The Starry Night</code>又回来了:</p>
<p><img src="Plutus编写可靠的智能合约/12-11.png" alt=""></p>
<p>总结一下到目前为止我们已经取得的成就：我们的货币政策脚本保证，除了我们之外，没有人可以伪造新代币。<br>但是，为了使我们进行伪造交易，我们需要在该货币政策的地址处有输出。</p>
<p>我们不能假设只有一个这样的输出，因为其他人可以自己在该地址创建任意的输出。如果不是因为其他输出可能有错误的数据脚本类型，这就不会是一个问题，这使得我们的验证程序脚本在使用其中一个错误的输出时失败。通过对可能有多个输出的事实进行准备，并通过过滤出具有错误类型的数据脚本的输出，我们可以确保始终会找到一个有效的输出。因此，我们将始终能够在需要时伪造新代币。</p>
<p>就我们自己而言，我们现在很安全。通过最新的代码迭代，我们确保了无论其他人做什么，我们都可以在需要的时候伪造新的代币，并且编写了验证程序脚本，以确保没有其他人可以创建新的代币。</p>
<p>不幸的是，还有另一个问题：我们的经营理念取决于这样一个事实，即我们处理的每件艺术品都有一个唯一的代币。如果有人从我们这里购买蒙娜丽莎代币，那么如果我们将另一个蒙娜德丽莎代币出售给其他人，他将非常沮丧。当然，我们绝不会做这样的事情，但是-如果我们可以使系统保证始终有最多一个给定名称的代币，那不是很好吗？毕竟，首先使用区块链的原因之一是用科学和密码证明取代信任的想法。人们已经发明了智能合约来机械地强制执行此类属性，从而使每个人都可以自己检查代码，而不必被迫信任任何人。</p>
<p>那么，我们如何调整合同以迫使自己诚实呢？我们需要某种方式来跟踪已伪造的代币。这种合同状态直观上属于数据脚本，但是当前版本的Plutus使得检查数据脚本有些困难（除了验证者脚本正在检查的属于脚本输入的脚本之外）。 这将在下一版的Plutus中更改。</p>
<p>在我们的例子中，使用值来跟踪已经伪造的代币将更容易：我们的想法是，不伪造一个代币，而是伪造三个，但”<code>trap</code>(捕获)”脚本输出中的两个令牌，然后它们将成为下一个伪造交易的脚本输入，因此通过检查该输入的值，我们可以看到哪些代币已经被伪造。为什么是三个而不是两个？其他人只能得到一个具有给定名称的代币，因此当我们看到一个脚本输出包含两个同名代币时，我们知道是我们创建了该输出。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">validateNonFungible</span> :: <span class="type">NonFungible</span> -&gt; <span class="type">NonFungibleValidator</span> </span><br><span class="line"><span class="title">validateNonFungible</span> nf () name tx =</span><br><span class="line">      txSignedBy tx (issuer nf)</span><br><span class="line">    &amp;&amp; <span class="keyword">case</span> (pendingTxInputs tx, pendingTxOutputs tx) <span class="keyword">of</span></span><br><span class="line">        ([i], os@(o : _)) -&gt;    <span class="number">1</span>⃣️</span><br><span class="line">            <span class="keyword">let</span> inValue = pendingTxInValue i    <span class="number">2</span>⃣️</span><br><span class="line">            <span class="keyword">in</span>  foldl f <span class="type">V</span>.zero os</span><br><span class="line">                  == (inValue `<span class="type">V</span>.plus` v3)      <span class="number">3</span>⃣️</span><br><span class="line">              &amp;&amp; pendingTxOutValue o</span><br><span class="line">                  == (inValue `<span class="type">V</span>.plus` v2)      <span class="number">4</span>⃣️</span><br><span class="line">              &amp;&amp; <span class="type">V</span>.valueOf inValue s name == <span class="number">0</span>  <span class="number">5</span>⃣️</span><br><span class="line">              &amp;&amp; <span class="keyword">case</span> pendingTxOutHashes o <span class="keyword">of</span></span><br><span class="line">                    <span class="type">Just</span> (vh, _) -&gt; vh == ownHash tx  <span class="number">6</span>⃣️</span><br><span class="line">                    <span class="type">Nothing</span> -&gt; <span class="type">False</span></span><br><span class="line">        _   -&gt; <span class="type">False</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    s :: <span class="type">CurrencySymbol</span></span><br><span class="line">    s = ownCurrencySymbol tx</span><br><span class="line"></span><br><span class="line">    v, v2, v3 :: <span class="type">Value</span></span><br><span class="line">    v = <span class="type">V</span>.singleton s name <span class="number">1</span> </span><br><span class="line">    v2 = v `<span class="type">V</span>.plus` v</span><br><span class="line">    v3 = v2 `<span class="type">V</span>.plus` v</span><br><span class="line"></span><br><span class="line">    f :: <span class="type">Value</span> -&gt; <span class="type">PendingTxOut</span> -&gt; <span class="type">Value</span></span><br><span class="line">    f w o = w `<span class="type">V</span>.plus` pendingTxOutValue o</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 我们期望恰好有一个输入，即我们当前正在验证的脚本输入，以及至少一个输出，第一个是新的脚本输出</li>
<li>2⃣️ 输入值将由我们已经伪造的所有代币组成</li>
<li>3⃣️ 我们伪造了三次代币</li>
<li>4⃣️ 新的脚本值必须”trap”两个新伪造的代币</li>
<li>5⃣️ 在这里，我们检查输入值是否已经包含我们想要伪造的代币</li>
<li>6⃣️ 第一个输出(包含<code>trapped</code>(受限制)的两个额外代币)必须再次进入货币政策脚本</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mkNonFungibleTxOut</span> :: <span class="type">NonFungible</span> -&gt; <span class="type">Value</span> -&gt; <span class="type">TxOut</span> <span class="number">1</span>⃣️</span><br><span class="line"><span class="title">mkNonFungibleTxOut</span> nf v =</span><br><span class="line">      scriptTxOut</span><br><span class="line">          v</span><br><span class="line">          (mkNonFungibleValidator nf) </span><br><span class="line">          unitData</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 我们为这个<code>helper</code>函数添加了另一个<code>Value</code>类型的参数，因为我们的脚本输出不再都是零值。</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">forge</span> :: <span class="keyword">forall</span> m. <span class="type">MonadWallet</span> m </span><br><span class="line">    =&gt; <span class="type">String</span> <span class="comment">-- token name</span></span><br><span class="line">    -&gt; m ()</span><br><span class="line"><span class="title">forge</span> n = <span class="keyword">do</span></span><br><span class="line">    key &lt;- ownPubKey</span><br><span class="line">    <span class="keyword">let</span> nf = <span class="type">NonFungible</span> &#123;issuer = key&#125; </span><br><span class="line">    logMsg $ <span class="type">T</span>.pack $</span><br><span class="line">        <span class="string">"forging "</span> ++ n ++ <span class="string">" of "</span> ++ show nf</span><br><span class="line">    outs &lt;- outputsAt $ nonFungibleAddress nf</span><br><span class="line">    <span class="keyword">case</span> findOut (nonFungibleSymbol nf) $ <span class="type">Map</span>.toList outs <span class="keyword">of</span> <span class="number">1</span>⃣️</span><br><span class="line">        <span class="type">Just</span> (ref, o) -&gt; <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">let</span> v  = nonFungibleValue nf n</span><br><span class="line">                v2 = v `<span class="type">V</span>.plus` v</span><br><span class="line">                v3 = v2 `<span class="type">V</span>.plus` v</span><br><span class="line">                vIn = txOutValue o </span><br><span class="line">                vOut = vIn `<span class="type">V</span>.plus` v2</span><br><span class="line">            signTxAndSubmit_ <span class="type">Tx</span></span><br><span class="line">                &#123; txInputs = <span class="type">Set</span>.singleton $ scriptTxIn</span><br><span class="line">                                ref</span><br><span class="line">                                (mkNonFungibleValidator nf)</span><br><span class="line">                                (mkNonFungibleRedeemer n)</span><br><span class="line">                , txOutputs = [ mkNonFungibleTxOut nf vOut <span class="number">2</span>⃣️</span><br><span class="line">                              , pubKeyTxOut v key <span class="number">3</span>⃣️</span><br><span class="line">                              ]</span><br><span class="line">                , txFee     = <span class="type">A</span>.zero</span><br><span class="line">                , txForge   = v3                  <span class="number">4</span>⃣️</span><br><span class="line">                , txValidRange = defaultSlotRange </span><br><span class="line">                , txSignatures = <span class="type">Map</span>.empty</span><br><span class="line">                &#125;</span><br><span class="line">        _  -&gt; throwError $</span><br><span class="line">                  <span class="type">OtherError</span> $ <span class="type">T</span>.pack <span class="string">"'start' has not run"</span></span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    findOut :: <span class="type">CurrencySymbol</span></span><br><span class="line">              -&gt; [(<span class="type">TxOutRef</span>, <span class="type">TxOut</span>)]</span><br><span class="line">              -&gt; <span class="type">Maybe</span> (<span class="type">TxOutRef</span>, <span class="type">TxOut</span>) </span><br><span class="line">    findOut s xs =</span><br><span class="line">        <span class="keyword">let</span> ys = filter f xs <span class="number">5</span>⃣️</span><br><span class="line">        <span class="keyword">in</span> <span class="keyword">case</span> find (ours s . snd) ys <span class="keyword">of</span> <span class="number">6</span>⃣️</span><br><span class="line">            <span class="type">Just</span>  x -&gt; <span class="type">Just</span> x</span><br><span class="line">            <span class="type">Nothing</span> -&gt; find (zero . snd) ys <span class="number">7</span>⃣️</span><br><span class="line"></span><br><span class="line">    f :: (<span class="type">TxOutRef</span>, <span class="type">TxOut</span>) -&gt; <span class="type">Bool</span> </span><br><span class="line">    f (_, o) = <span class="keyword">case</span> txOutType o <span class="keyword">of</span></span><br><span class="line">        <span class="type">PayToPubKey</span> _ -&gt; <span class="type">False</span> </span><br><span class="line">        <span class="type">PayToScript</span> ds -&gt; ds == unitData</span><br><span class="line"></span><br><span class="line">    ours :: <span class="type">CurrencySymbol</span> -&gt; <span class="type">TxOut</span> -&gt; <span class="type">Bool</span></span><br><span class="line">    ours s o = <span class="keyword">case</span> <span class="type">AM</span>.lookup s $ <span class="type">V</span>.getValue $ txOutValue o <span class="keyword">of</span></span><br><span class="line">        <span class="type">Nothing</span> -&gt; <span class="type">False</span></span><br><span class="line">        <span class="type">Justm</span> -&gt; any (&gt;= <span class="number">2</span>) [i|(_,i) &lt;- <span class="type">AM</span>.toList m]</span><br><span class="line">        </span><br><span class="line">    zero :: <span class="type">TxOut</span> -&gt; <span class="type">Bool</span></span><br><span class="line">    zero o = txOutValue o == <span class="type">V</span>.zero</span><br><span class="line"></span><br><span class="line">$(mkFunctions ['start, 'forge])</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 我们使用助手函数<code>findOut</code>来查找正确的脚本输出(如果存在的话)。</li>
<li>2⃣️ 第一个输出必须是脚本输出；其值是脚本输入的值加上两个新伪造的代币</li>
<li>3⃣️ 第三个代币指向我们自己的地址</li>
<li>4⃣️ 我们铸造了三种新的代币</li>
<li>5⃣️ 首先，我们像以前一样筛选具有正确类型的数据脚本</li>
<li>6⃣️ 然后，我们寻找至少包含两次代币的输出。这样的输出一定是我们创建的</li>
<li>7⃣️ 如果我们找不到这样的输出，我们就选择一个值为零的输出。这可能来自其他人，但不会对我们造成任何伤害。</li>
</ul>
<p>我们可以在操场上尝试一下，看看再次尝试伪造<code>Monad Lisa</code>代币时会发生什么:</p>
<p><img src="Plutus编写可靠的智能合约/12-12.png" alt=""></p>
<p><img src="Plutus编写可靠的智能合约/12-13.png" alt=""></p>
<p><img src="Plutus编写可靠的智能合约/12-14.png" alt=""></p>
<p>不出所料，<code>Mona Lisa</code>代币的第二次锻造失败，我们只得到一个<code>Mona Lisa</code>代币和一个<code>Starry Night</code>代币。</p>
<p>使用此版本的合同，我们可以防止错误地伪造同一代币两次（并且我们仍然可以确保没有其他人可以破坏我们）。只要我们以目前的形式使用钱包端点，就永远不会有两个蒙娜丽莎代币。</p>
<p>不幸的是，这不能使怀疑论者确信不可能两次伪造相同的代币。实际上，我们可以通过如下更改<code>forge</code>的设置来做到这一点:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">forge</span> :: <span class="keyword">forall</span> m. <span class="type">MonadWallet</span> m </span><br><span class="line">      =&gt; <span class="type">String</span> <span class="comment">-- token name</span></span><br><span class="line">      -&gt; m ()</span><br><span class="line"><span class="title">forge</span> n = <span class="keyword">do</span></span><br><span class="line">    key &lt;- ownPubKey</span><br><span class="line">    <span class="keyword">let</span> nf = <span class="type">NonFungible</span> &#123;issuer = key&#125; </span><br><span class="line">    logMsg $ <span class="type">T</span>.pack $</span><br><span class="line">        <span class="string">"forging "</span> ++ n ++ <span class="string">" of "</span> ++ show nf</span><br><span class="line">    outs &lt;- outputsAt $ nonFungibleAddress nf</span><br><span class="line">    <span class="keyword">case</span> findOut (nonFungibleSymbol nf) $ <span class="type">Map</span>.toList outs <span class="keyword">of</span></span><br><span class="line">            <span class="type">Just</span> (ref, o) -&gt; <span class="keyword">do</span></span><br><span class="line">                <span class="keyword">let</span> v = nonFungibleValue nf n</span><br><span class="line">                    v2  = v `<span class="type">V</span>.plus` v</span><br><span class="line">                    v3  = v2 `<span class="type">V</span>.plus` v</span><br><span class="line">                    vIn = txOutValue o </span><br><span class="line">                    vOut = vIn `<span class="type">V</span>.plus` v2</span><br><span class="line">                signTxAndSubmit_ <span class="type">Tx</span></span><br><span class="line">                    &#123; txInputs  = <span class="type">Set</span>.singleton $ scriptTxIn</span><br><span class="line">                                      ref</span><br><span class="line">                                      (mkNonFungibleValidator nf)</span><br><span class="line">                                      (mkNonFungibleRedeemer n)</span><br><span class="line">                    , txOutputs = [ mkNonFungibleTxOut nf vOut</span><br><span class="line">                                  , pubKeyTxOut v key</span><br><span class="line">                                  ]         </span><br><span class="line">                    , txFee     = <span class="type">A</span>.zero</span><br><span class="line">                    , txForge   = v3</span><br><span class="line">                    , txValidRange = defaultSlotRange </span><br><span class="line">                    , txSignatures = <span class="type">Map</span>.empty</span><br><span class="line">                    &#125;      </span><br><span class="line">            _     -&gt; throwError $</span><br><span class="line">                        <span class="type">OtherError</span> $ <span class="type">T</span>.pack <span class="string">"'start' has not run"</span></span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    findOut :: <span class="type">CurrencySymbol</span></span><br><span class="line">              -&gt; [(<span class="type">TxOutRef</span>, <span class="type">TxOut</span>)]</span><br><span class="line">              -&gt; <span class="type">Maybe</span> (<span class="type">TxOutRef</span>, <span class="type">TxOut</span>) </span><br><span class="line">    findOut s xs =</span><br><span class="line">        <span class="keyword">let</span> ys = filter f xs</span><br><span class="line">        <span class="keyword">in</span> <span class="keyword">case</span> find (zero . snd) ys <span class="keyword">of</span> <span class="number">1</span>⃣️</span><br><span class="line">              <span class="type">Just</span> x -&gt; <span class="type">Just</span> x</span><br><span class="line">              <span class="type">Nothing</span> -&gt; find (ours s . snd) ys</span><br><span class="line"></span><br><span class="line">    f :: (<span class="type">TxOutRef</span>, <span class="type">TxOut</span>) -&gt; <span class="type">Bool</span> </span><br><span class="line">    f (_, o) = <span class="keyword">case</span> txOutType o <span class="keyword">of</span></span><br><span class="line">        <span class="type">PayToPubKey</span> _ -&gt; <span class="type">False</span> </span><br><span class="line">        <span class="type">PayToScript</span> ds -&gt; ds == unitData</span><br><span class="line"></span><br><span class="line">    ours :: <span class="type">CurrencySymbol</span> -&gt; <span class="type">TxOut</span> -&gt; <span class="type">Bool</span></span><br><span class="line">    ours s o = <span class="keyword">case</span> <span class="type">AM</span>.lookup s $ <span class="type">V</span>.getValue $ txOutValue o <span class="keyword">of</span></span><br><span class="line">        <span class="type">Nothing</span> -&gt; <span class="type">False</span></span><br><span class="line">        <span class="type">Justm</span> -&gt; any (&gt;= <span class="number">2</span>) [i | (_,i) &lt;- <span class="type">AM</span>.toList m]</span><br><span class="line">    </span><br><span class="line">    zero :: <span class="type">TxOut</span> -&gt; <span class="type">Bool</span></span><br><span class="line">    zero o = txOutValue o == <span class="type">V</span>.zero</span><br><span class="line"></span><br><span class="line">$(mkFunctions ['start, 'forge])</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">* <span class="number">1</span>⃣️ 在我们首先寻找一个包含至少两次代币的输出之前，然后寻找一个零值输出。我们在这里简单地交换这两个，所以现在我们将选择一个值为零的输出。</span><br><span class="line"></span><br><span class="line">如果我们现在在锻造两个代币之后再次调用`start`，我们将创建一个新的脚本输出，其值为零，并且该输出将作为下一次锻造的输入（由于`findOut`的逻辑发生了变化）。我们最终得到了两个蒙娜丽莎的代币，正如我们的批评者声称的那样，如果我们愿意的话，我们可以。</span><br><span class="line"></span><br><span class="line">![](<span class="type">Plutus</span>编写可靠的智能合约/<span class="number">12</span><span class="number">-15.</span>png)</span><br><span class="line"></span><br><span class="line">![](<span class="type">Plutus</span>编写可靠的智能合约/<span class="number">12</span><span class="number">-16.</span>png)</span><br><span class="line"></span><br><span class="line">那么，我们如何才能使合同如此严密，以至于无论我们在钱包里做了什么，每个人都绝对肯定地知道，同一代币的实例永远不会超过一个？</span><br><span class="line"></span><br><span class="line">其思想是创建一个只能存在一次的`admin`代币。一旦我们有了它，我们就可以要求这个`admin`代币出现在代表我们货币政策的脚本输入中。因为`admin`代币只存在一次，所以最多只能有一个合适的脚本输入，所以我们不能再通过两个不同的脚本输入来欺骗。</span><br><span class="line"></span><br><span class="line">我们还可以停止每次伪造三个新的代币，而是伪造两个，因为只要我们确保`admin`代币位于脚本地址，我们就可以通过查找`admin`代币的存在来识别正确的脚本输出。</span><br><span class="line"></span><br><span class="line">乍一看，这个想法看起来像循环逻辑：我们希望通过使用只存在一次的`admin`代币来解决防止伪造多个同名代币的问题。听起来为了解决我们原来的问题，我们现在面临着与`admin`代币完全相同的问题：我们如何确保它只能存在一次？</span><br><span class="line"></span><br><span class="line">幸运的是，有一个解决办法。请记住，<span class="string">"交易输出"</span>是唯一的（如上所述，严格来说，在没有费用的情况下，这在<span class="string">"游乐场"</span>中是不正确的，但对于花费了一些`ada`的交易输出，这是正确的）。</span><br><span class="line"></span><br><span class="line">我们将按如下方式创建管理代币：我们选择我们拥有的唯一交易输出。</span><br><span class="line"></span><br><span class="line">在`admin`代币的货币政策中，我们确保只能在`spends`(花费)此输出的交易中伪造新的`admin`代币。</span><br><span class="line"></span><br><span class="line">通过`spending`(花费)它，输出将被`销毁`，因此我们再也不会进行第二次这样的交易，并且`admin`代币确实是唯一的。</span><br><span class="line"></span><br><span class="line">让我们看一下代码:</span><br><span class="line">```haskell</span><br><span class="line"><span class="comment">-- admin代币由交易输出参数化，而交易输出又由交易的散列和输出索引给出</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Admin</span> = (<span class="type">TxHash</span>, <span class="type">Integer</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将引用转换为 哈希索引对 的输出</span></span><br><span class="line"><span class="title">mkAdmin</span> :: <span class="type">TxOutRef</span> -&gt; <span class="type">Admin</span></span><br><span class="line"><span class="title">mkAdmin</span> (<span class="type">TxOutRefOf</span> h i) = (plcTxHash h, i)</span><br><span class="line"></span><br><span class="line"><span class="comment">--我们不需要`data`脚本和`redeemer`脚本中的数据，所以两者都可以是单元类型</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">AdminValidator</span> = () -&gt; () -&gt; <span class="type">PendingTx</span> -&gt; <span class="type">Bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">validateAdmin</span> :: <span class="type">Admin</span> -&gt; <span class="type">AdminValidator</span> </span><br><span class="line"><span class="title">validateAdmin</span> (h, i) () () tx =</span><br><span class="line">        spendsOutput tx h i <span class="number">1</span>⃣️ </span><br><span class="line">    &amp;&amp; <span class="keyword">case</span> pendingTxOutputs tx <span class="keyword">of</span></span><br><span class="line">        (o : _) -&gt; <span class="type">V</span>.valueOf </span><br><span class="line">            (pendingTxOutValue o) </span><br><span class="line">            (ownCurrencySymbol tx) </span><br><span class="line">            adminTokenName</span><br><span class="line">            == <span class="number">1</span>        <span class="number">2</span>⃣️</span><br><span class="line">        [] -&gt; <span class="type">False</span>     <span class="number">3</span>⃣️</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 我们确保伪造<code>admin</code>代币的交易使用散列<code>h</code>和索引<code>i</code>表示的输出</li>
<li>2⃣️ <code>admin</code>代币必须包含在数量为1的第一个输出中</li>
<li>3⃣️ 必须至少有一个输出</li>
</ul>
<p>我们添加了一些标准的助手函数:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">adminRedeemer</span> :: <span class="type">RedeemerScript</span></span><br><span class="line"><span class="title">adminRedeemer</span> = <span class="type">RedeemerScript</span> </span><br><span class="line">    $$(compileScript [|| \(_ :: <span class="type">Sealed</span> (<span class="type">HashedDataScript</span> ())) -&gt; () ||])</span><br><span class="line"></span><br><span class="line"><span class="title">mkAdminValidator</span> :: <span class="type">Admin</span> -&gt; <span class="type">ValidatorScript</span> </span><br><span class="line"><span class="title">mkAdminValidator</span> = <span class="type">ValidatorScript</span></span><br><span class="line">                        . applyScript $$(compileScript [|| validateAdmin ||]) </span><br><span class="line">                        . lifted</span><br><span class="line"></span><br><span class="line"><span class="title">adminAddress</span> :: <span class="type">Admin</span> -&gt; <span class="type">Address</span></span><br><span class="line"><span class="title">adminAddress</span> = scriptAddress . mkAdminValidator</span><br><span class="line"></span><br><span class="line"><span class="title">adminSymbol</span> :: <span class="type">Admin</span> -&gt; <span class="type">CurrencySymbol</span></span><br><span class="line"><span class="title">adminSymbol</span> admin = <span class="keyword">case</span> validatorScriptHash $ mkAdminValidator admin <span class="keyword">of</span></span><br><span class="line">    <span class="type">ValidatorHash</span> h -&gt; <span class="type">V</span>.currencySymbol h</span><br><span class="line"></span><br><span class="line"><span class="title">adminTokenName</span> :: <span class="type">TokenName</span></span><br><span class="line"><span class="title">adminTokenName</span> = <span class="type">TokenName</span> emptyByteString</span><br><span class="line"></span><br><span class="line"><span class="comment">-- The value of the admin token.</span></span><br><span class="line"><span class="title">adminValue</span> :: <span class="type">Admin</span> -&gt; <span class="type">Value</span></span><br><span class="line"><span class="title">adminValue</span> admin = <span class="type">V</span>.singleton (adminSymbol admin) adminTokenName <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>我们需要对现有代码进行一些更改以纳入<code>admin-token</code>的想法:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">NonFungible</span> = <span class="type">NonFungible</span></span></span><br><span class="line">    &#123; issuer :: <span class="type">PubKey</span></span><br><span class="line">    , adminCurrency :: <span class="type">CurrencySymbol</span> <span class="number">1</span>⃣️ </span><br><span class="line">    &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Generic</span>, <span class="type">ToJSON</span>, <span class="type">FromJSON</span>, <span class="type">ToSchema</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">makeLift</span> ''<span class="type">NonFungible</span></span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 我们的<code>NonFungible</code>记录需要一个新字段，即<code>admin</code>代币的货币符号</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">NonFungibleValidator</span> =</span></span><br><span class="line">    ()</span><br><span class="line">    -&gt; <span class="type">TokenName</span></span><br><span class="line">    -&gt; <span class="type">PendingTx</span></span><br><span class="line">    -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="title">validateNonFungible</span> :: <span class="type">NonFungible</span> -&gt; <span class="type">NonFungibleValidator</span> </span><br><span class="line"><span class="title">validateNonFungible</span> nf () name tx =</span><br><span class="line">        txSignedBy tx (issuer nf)</span><br><span class="line">    &amp;&amp; <span class="keyword">case</span> (pendingTxInputs tx, pendingTxOutputs tx) <span class="keyword">of</span></span><br><span class="line">        ([i], os@(o : _)) -&gt;</span><br><span class="line">            <span class="keyword">let</span> inValue = pendingTxInValue i</span><br><span class="line">            <span class="keyword">in</span>    foldl f <span class="type">V</span>.zero os</span><br><span class="line">                  == (inValue `<span class="type">V</span>.plus` v2)    <span class="number">1</span>⃣️</span><br><span class="line">              &amp;&amp; pendingTxOutValue o</span><br><span class="line">                  == (inValue `<span class="type">V</span>.plus` v)</span><br><span class="line">              &amp;&amp; <span class="type">V</span>.valueOf inValue s name == <span class="number">0</span> </span><br><span class="line">              &amp;&amp; <span class="type">V</span>.valueOf</span><br><span class="line">                  inValue     </span><br><span class="line">                  (adminCurrency nf)  <span class="number">2</span>⃣️ </span><br><span class="line">                  adminTokenName</span><br><span class="line">                  == <span class="number">1</span></span><br><span class="line">              &amp;&amp; <span class="keyword">case</span> pendingTxOutHashes o <span class="keyword">of</span></span><br><span class="line">                  <span class="type">Just</span> (vh, _) -&gt; vh == ownHash tx </span><br><span class="line">                  <span class="type">Nothing</span> -&gt; <span class="type">False</span></span><br><span class="line">        _   -&gt; <span class="type">False</span></span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    s :: <span class="type">CurrencySymol</span></span><br><span class="line">    s = ownCurrencySymbol tx</span><br><span class="line"></span><br><span class="line">    v, v2 :: <span class="type">Value</span></span><br><span class="line">    v = <span class="type">V</span>.singleton s name <span class="number">1</span> </span><br><span class="line">    v2 = v `<span class="type">V</span>.plus` v</span><br><span class="line"></span><br><span class="line">    f :: <span class="type">Value</span> -&gt; <span class="type">PendingTxOut</span> -&gt; <span class="type">Value</span></span><br><span class="line">    f w o = w `<span class="type">V</span>.plus` pendingTxOutValue o</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 我们只需要伪造两个代币，就不再需要三个</li>
<li>2⃣️ <code>admin</code>代币必须是脚本输入的一部分</li>
</ul>
<p>我们添加了一个助手来检查给定交易输出中是否包含<code>admin</code>代币:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">hasAdminToken</span> :: <span class="type">CurrencySymbol</span> -&gt; (<span class="type">TxOutRef</span>, <span class="type">TxOut</span>) -&gt; <span class="type">Bool</span> </span><br><span class="line"><span class="title">hasAdminToken</span> s (_, o) =</span><br><span class="line">    <span class="type">V</span>.valueOf (txOutValue o) s adminTokenName == <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>现在我们可以编写端点了。最大的变化是在<code>start</code>中，现在我们必须首先伪造<code>admin</code>代币，然后才能开始执行政策:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">start</span> :: <span class="keyword">forall</span> m. <span class="type">MonadWallet</span> m =&gt; m (<span class="type">CurrencySymbol</span>) </span><br><span class="line"><span class="title">start</span> = <span class="keyword">do</span></span><br><span class="line">    key &lt;- ownPubKey</span><br><span class="line">    outs &lt;- outputsAt $ pubKeyAddress key </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Map</span>.toList outs <span class="keyword">of</span></span><br><span class="line">        [] -&gt; throwError $</span><br><span class="line">                <span class="type">OtherError</span> $ <span class="type">T</span>.pack <span class="string">"need at least one output"</span></span><br><span class="line">        ((ref,o):_) -&gt;  <span class="keyword">do</span>  <span class="number">1</span>⃣️ </span><br><span class="line">        <span class="keyword">let</span> admin = mkAdmin ref</span><br><span class="line">        startWatching $ adminAddress admin</span><br><span class="line">        logMsg $ <span class="type">T</span>.pack $</span><br><span class="line">            <span class="string">"starting admin "</span> ++ show admin</span><br><span class="line">        void $ createTxAndSubmit  <span class="number">2</span>⃣️</span><br><span class="line">            defaultSlotRange</span><br><span class="line">            <span class="type">Set</span>.empty </span><br><span class="line">            [scriptTxOut</span><br><span class="line">                <span class="type">V</span>.zero</span><br><span class="line">                (mkAdminValidator admin) unitData</span><br><span class="line">            ]</span><br><span class="line">        go1 ref $ txOutValue o <span class="number">3</span>⃣️</span><br><span class="line">        pure (adminSymbol admin)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    go1 :: <span class="type">TxOutRef</span> -&gt; <span class="type">Value</span> -&gt; m () </span><br><span class="line">    go1 ref v = <span class="keyword">do</span></span><br><span class="line">        t &lt;- trigger</span><br><span class="line">        registerOnce t $ handler1 ref v</span><br><span class="line"></span><br><span class="line">    trigger :: m <span class="type">EventTrigger</span> </span><br><span class="line">    trigger = <span class="keyword">do</span></span><br><span class="line">        sl &lt;- slot</span><br><span class="line">        return $ slotRangeT $ intervalFrom $ sl + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    handler1 :: <span class="type">TxOutRef</span> -&gt; <span class="type">Value</span> -&gt; <span class="type">EventHandler</span> m </span><br><span class="line">    handler1 ref v = <span class="type">EventHandler</span> $ const $ <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">let</span> admin = mkAdmin ref</span><br><span class="line">        outs &lt;- outputsAt $ adminAddress admin </span><br><span class="line">        <span class="keyword">case</span> <span class="type">Map</span>.keys outs <span class="keyword">of</span></span><br><span class="line">            [] -&gt; go1 ref v <span class="number">4</span>⃣️</span><br><span class="line">            (ref' : _) -&gt; <span class="keyword">do</span></span><br><span class="line">                key &lt;- ownPubKey</span><br><span class="line">                <span class="keyword">let</span> i1 = pubKeyTxIn ref key <span class="number">5</span>⃣️</span><br><span class="line">                    i2 = scriptTxIn <span class="number">6</span>⃣️</span><br><span class="line">                            ref'</span><br><span class="line">                            (mkAdminValidator admin)</span><br><span class="line">                            unitRedeemer</span><br><span class="line">                    o = pubKeyTxOut <span class="number">7</span>⃣️</span><br><span class="line">                            (v `<span class="type">V</span>.plus` adminValue admin)</span><br><span class="line">                            key</span><br><span class="line">                </span><br><span class="line">                signTxAndSubmit_ <span class="type">Tx</span></span><br><span class="line">                    &#123; txInputs  = <span class="type">Set</span>.fromList [i1, i2]</span><br><span class="line">                    , txOutputs  [o]</span><br><span class="line">                    , txFee      = <span class="type">A</span>.zero</span><br><span class="line">                    , txForge    = adminValue admin</span><br><span class="line">                    , txValidRange = defaultSlotRange </span><br><span class="line">                    , txSignatures = <span class="type">Map</span>.empty</span><br><span class="line">                    &#125;</span><br><span class="line">                logMsg $ <span class="type">T</span>.pack $</span><br><span class="line">                    <span class="string">"forging admin token "</span> ++ </span><br><span class="line">                    show (adminSymbol admin)</span><br><span class="line"></span><br><span class="line">                go2 (adminSymbol admin) <span class="number">8</span>⃣️</span><br><span class="line"></span><br><span class="line">    go2 :: <span class="type">CurrencySymbol</span> -&gt; m () </span><br><span class="line">    go2 s = <span class="keyword">do</span></span><br><span class="line">        t &lt;- trigger</span><br><span class="line">        registerOnce t $ handler2 s</span><br><span class="line">    </span><br><span class="line">    handler2 :: <span class="type">CurrencySymbol</span> -&gt; <span class="type">EventHandler</span> m </span><br><span class="line">    handler2 s = <span class="type">EventHandler</span> $ const $ <span class="keyword">do</span></span><br><span class="line">        key &lt;- ownPubKey</span><br><span class="line">        outs &lt;- outputsAt $ pubKeyAddress key</span><br><span class="line">        <span class="keyword">case</span> find (hasAdminToken s) $ <span class="type">Map</span>.toList outs <span class="keyword">of</span></span><br><span class="line">              <span class="type">Nothing</span> -&gt; go2 s</span><br><span class="line">              <span class="type">Just</span> (ref, o) -&gt; <span class="keyword">do</span>  <span class="number">9</span>⃣️</span><br><span class="line">                  <span class="keyword">let</span> nf = <span class="type">NonFungible</span></span><br><span class="line">                              &#123; issuer = key</span><br><span class="line">                              , adminCurrency = s</span><br><span class="line">                              &#125;</span><br><span class="line">                  logMsg $ <span class="type">T</span>.pack $</span><br><span class="line">                      <span class="string">"starting tokens "</span> ++ show nf</span><br><span class="line">                  <span class="keyword">let</span> v = <span class="type">V</span>.singleton s adminTokenName <span class="number">1</span></span><br><span class="line">                      i = pubKeyTxIn ref key 🔟</span><br><span class="line">                      o1 = scriptTxOut <span class="number">1</span>⃣️<span class="number">1</span>⃣️</span><br><span class="line">                                v</span><br><span class="line">                                (mkNonFungibleValidator nf) </span><br><span class="line">                                unitData</span><br><span class="line">                      o2 = pubKeyTxOut  <span class="number">1</span>⃣️<span class="number">2</span>⃣️</span><br><span class="line">                                (txOutValue o `<span class="type">V</span>.minus` v)</span><br><span class="line">                                key</span><br><span class="line">                  void $ createTxAndSubmit</span><br><span class="line">                      defaultSlotRange </span><br><span class="line">                      (<span class="type">Set</span>.singleton i) </span><br><span class="line">                      [o1, o2]</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 我们选择输出之一作为<code>admin</code>代币策略使用的唯一输出</li>
<li>2⃣️ 我们为我们的<code>admin</code>代币策略创建脚本输出</li>
<li>3⃣️ 我们等到脚本输出可用</li>
<li>4⃣️ 如果脚本输出尚不可用，我们将继续等待</li>
<li>5⃣️ 第一个输入是我们唯一的输出</li>
<li>6⃣️ 第二个输入是我们等待的脚本输出</li>
<li>7⃣️ 输出传给我们，它包括来自唯一输入的值(没有必要浪费这些钱…)和新伪造的<code>admin</code>代币</li>
<li>8⃣️ 我们再次等待，这一次<code>admin</code>代币变为可用</li>
<li>9⃣️ 我们选取包含<code>admin</code>代币的输出</li>
<li>🔟 输入将是包含<code>admin</code>代币的输出</li>
<li>1⃣️1⃣️ 我们的代币的货币政策的第一个输出包含<code>admin</code>代币</li>
<li>1⃣️2⃣️ 第二个输出获取输入中包含的多余值</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">forge</span> :: <span class="keyword">forall</span> m. <span class="type">MonadWallet</span> m</span><br><span class="line">      =&gt; <span class="type">CurrencySymbol</span> <span class="comment">-- admin token symbol </span></span><br><span class="line">      -&gt; <span class="type">String</span> <span class="comment">-- token name</span></span><br><span class="line">      -&gt; m ()</span><br><span class="line"><span class="title">forge</span> s n = <span class="keyword">do</span></span><br><span class="line">    key &lt;- ownPubKey</span><br><span class="line">    <span class="keyword">let</span> nf = <span class="type">NonFungible</span></span><br><span class="line">            &#123; issuer = key </span><br><span class="line">            , adminCurrency = s</span><br><span class="line">            &#125;</span><br><span class="line">    logMsg $ <span class="type">T</span>.pack $</span><br><span class="line">        <span class="string">"forging "</span> ++ n ++ <span class="string">" of "</span> ++ show nf</span><br><span class="line"></span><br><span class="line">    outs &lt;- outputsAt $ nonFungibleAddress nf </span><br><span class="line">    <span class="keyword">case</span> findOut s $ <span class="type">Map</span>.toList outs <span class="keyword">of</span></span><br><span class="line">        <span class="type">Just</span> (ref, o) -&gt; <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">let</span> v = nonFungibleValue nf n</span><br><span class="line">                v2 = v `<span class="type">V</span>.plus` v </span><br><span class="line">                vIn = txOutValue o </span><br><span class="line">                vOut = vIn `<span class="type">V</span>.plus` v</span><br><span class="line">            signTxAndSubmit_ <span class="type">Tx</span></span><br><span class="line">                &#123; txInputs  = <span class="type">Set</span>.singleton $ scriptTxIn</span><br><span class="line">                                  ref</span><br><span class="line">                                  (mkNonFungibleValidator nf)</span><br><span class="line">                                  (mkNonFungibleRedeemer n)</span><br><span class="line">                , txOutputs = [ mkNonFungibleTxOut nf vOut</span><br><span class="line">                              , pubKeyTxOut v key</span><br><span class="line">                              ]</span><br><span class="line">                , txFee     = <span class="type">A</span>.zero</span><br><span class="line">                , txForge   = v2   <span class="number">1</span>⃣️</span><br><span class="line">                , txValidRange = defaultSlotRange </span><br><span class="line">                , txSignatures = <span class="type">Map</span>.empty</span><br><span class="line">               &#125;</span><br><span class="line">        _   -&gt; throwError $</span><br><span class="line">                    <span class="type">OtherError</span> $ <span class="type">T</span>.pack <span class="string">"'start' has not run"</span>   </span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    findOut :: <span class="type">CurrencySymbol</span></span><br><span class="line">            -&gt; [(<span class="type">TxOutRef</span>, <span class="type">TxOut</span>)]</span><br><span class="line">            -&gt; <span class="type">Maybe</span> (<span class="type">TxOutRef</span>, <span class="type">TxOut</span>)</span><br><span class="line">    findOut = find . hasAdminToken      <span class="number">2</span>⃣️</span><br><span class="line"></span><br><span class="line">$(mkFunctions ['start, 'forge])</span><br></pre></td></tr></table></figure>
<ul>
<li>1⃣️ 我们只会伪造两次代币，不再是三次</li>
<li>2⃣️ 函数<code>findOut</code>现在更加简单: 我们只是寻找<code>admin</code>代币的存在</li>
</ul>
<p>我们终于达到了目标：通过系统地堵住一个又一个漏洞，我们现在有了一份可靠和安全的合同。没有人可以干涉我们，每个人都可以肯定，<br>无论我们做什么，永远不会有两个相同名称的代币。剩下的就是说服卢浮宫和我们合作。。。</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><h4 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h4><ul>
<li><p><code>Ada</code><br>卡达诺区块链提供的货币。<code>currency symbol</code>(货币符号)为<code>empty bytestring</code>且不对应货币政策的特殊<code>token</code></p>
</li>
<li><p><code>Address</code><br> <code>transaction output</code>的一部分，决定如何解锁该输出中的<code>value</code>。有两种地址，<code>public key addresses</code>(公钥地址)和<code>script addresses</code>(脚本地址)。</p>
</li>
<li><p><code>Contract Endpoints</code><br>钱包使用的<code>Off-chain</code>函数与区块链进行交互，尤其是与智能合约进行交互。</p>
</li>
<li><p><code>Currency Symbol</code><br>代表自定义货币(代币类)的字节串。<br>对于<code>Ada</code>而言，它是<code>empty bytestring</code>，对于自定义货币而言，它是<code>validator script</code>的哈希值，该哈希值表示控制伪造该货币新代币的货币策略。</p>
</li>
<li><p><code>Data Script</code><br><code>Plutus Core</code>代码段，它是<code>script output</code>的一部分，将传递给<code>validator script</code>以检查<code>script input</code>的有效性。</p>
</li>
<li><p><code>Extended UTXO</code><br><code>Plutus平台</code>所基于的分类帐模型。使用<code>data script</code>和<code>transaction</code>信息扩展传统的<code>UTXO</code>模型</p>
</li>
<li><p><code>Fungible Token</code><br>可以与其他代币互换的代币</p>
</li>
<li><p><code>Mockchain</code><br>一个Cardano区块链仿真器，忠实地实现了扩展的UTXO模型</p>
</li>
<li><p><code>Mock wallet</code><br>一个用于与<code>Mockchain</code>进行交互的钱包模拟器</p>
</li>
<li><p><code>Non-fungible Token</code><br>不可与其他代币互换的代币  </p>
</li>
<li><p><code>Off-chain code</code><br>作为智能合约的一部分编写的代码，通常在用户的钱包中，在链下执行</p>
</li>
<li><p><code>On-chain code</code><br>作为智能合约的一部分编写的代码，在交易验证期间在链上执行</p>
</li>
<li><p><code>Plutus Core</code><br>一种小型功能编程语言，旨在作为<code>on-chain</code>代码运行</p>
</li>
<li><p><code>Plutus IR</code><br>编译为<code>Plutus Core</code>的中间语言，用作编译器编写者的目标语言</p>
</li>
<li><p><code>Plutus Platform</code><br>用于编写智能合约的组合软件支持，包括:</p>
<ul>
<li>用于在<code>Haskell</code>中编写链下代码的库  </li>
<li>用于在<code>Plutus Tx</code>中编写链上代码的库</li>
<li>模拟器支持测试智能合约</li>
</ul>
</li>
<li><p><code>Plutus Playground</code><br>一个基于浏览器的环境，用于编写和测试Plutus合同</p>
</li>
<li><p><code>Plutus Tx</code><br><code>Haskell</code>的一个子集，编译成<code>Plutus Core</code></p>
</li>
<li><p><code>Public Key Address</code><br><code>transaction output</code>的可能地址类型。为了在这样一个<code>address</code>解锁资金，必须证明拥有相应的私钥</p>
</li>
<li><p><code>Public Key Input</code><br>从<code>public key output</code>中收集<code>value</code>的<code>transaction input</code>的类型.<br>具有这种输入的<code>transaction</code>必须由相应私钥的所有者签名才能生效</p>
</li>
<li><p><code>Public Key Output</code><br>将值锁定在<code>public key address</code>上的<code>transaction output</code>: 由<code>public key address</code>和<code>Value</code>组成的一对</p>
</li>
<li><p><code>Redeemer Script</code><br>一段<code>Plutus Core</code>代码，它是<code>script input</code>的一部分，并由<code>validator script</code>用来验证该输入</p>
</li>
<li><p><code>Script Address</code><br><code>transaction output</code>的可能<code>address</code>类型：验证程序脚本的哈希</p>
</li>
<li><p><code>Script Input</code><br>从<code>script output</code>收集<code>value</code>的<code>transaction input</code>类型。包含<code>redeemer script</code></p>
</li>
<li><p><code>Script Output</code><br>将值锁定在<code>script address</code>的<code>transaction output</code>: 由<code>script address</code>、<code>value</code>和<code>data script</code>组成的三元组</p>
</li>
<li><p><code>Token</code><br>由<code>currency symbol</code>和<code>token name</code>定义的自定义<code>value</code>。可以是<code>fungible token</code>(可替换标记)、<code>non-fungible token</code>(不可替换标记)或<code>mixed</code>(混合)标记。<code>Ada</code>是一种特殊的代币，其中<code>currency symbol</code>和<code>token name</code>都是空的<code>bytestring</code>.</p>
</li>
<li><p><code>Token Name</code><br>表示一个代币的<code>Bytestring</code>(在<code>Ada</code>的情况下是空的<code>Bytestring</code>)</p>
</li>
<li><p><code>Transaction</code><br>从零个或多个<code>transaction input</code>收集<code>value</code>，并将该值重新分配到零个或多个<code>transaction output</code>。可以随意打造新值</p>
</li>
<li><p><code>Transaction Input</code><br>确定从何处获取<code>transaction</code>重新分配的<code>value</code>。与两个<code>transaction output</code>相对应，有两种输入类型，即<code>public key inputs</code>和<code>script inputs</code></p>
</li>
<li><p><code>Transaction Output</code><br>确定<code>transaction</code>如何分配其<code>inputs</code>。有两种类型，<code>public key outputs</code>和<code>script outputs</code></p>
</li>
<li><p><code>Unspent Transaction Output</code><br>尚未由<code>transaction input</code>收集以用于另一个<code>transaction</code>的<code>transaction output</code></p>
</li>
<li><p><code>UTXO</code><br>看<code>Unspent Transaction Output</code></p>
</li>
<li><p><code>Validator Script</code><br>一段<code>Plutus Core</code>代码，用于验证是否允许<code>transaction</code>将<code>script output</code>用作<code>transaction input</code></p>
</li>
<li><p><code>Value</code><br>从技术上讲，从货币符号到从<code>token</code>符号到整数的映射。表示<code>Ada</code>和<code>token</code>的集合，是通过<code>transactions</code>重新分配的”<code>substance</code>(物质)”</p>
</li>
</ul>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p>TODO</p>
<!-- flag of hidden posts -->
        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> thank you </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
        <span><a href="https://serokell.io/blog">serokell</a></span>
        <span>/</span>
        
        <span><a href="https://iohk.io/en/blog">IOHK</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/blog/js/index.js"></script>

<!--create by tea9-->

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <script>
        var gitalk = new Gitalk({
          clientID: '7cfc73dd62b57f07ed83',
          clientSecret: 'dd03b7e54aadf0d81e4c9c93e23a41272bcfcfa1',
          repo: 'blog',
          owner: 'limengyu1990',
          admin: 'limengyu1990',
          id: location.pathname,      // Ensure uniqueness and length less than 50
          distractionFreeMode: false  // Facebook-like distraction free mode
        })
        gitalk.render('comment-container')
    </script>

<!--end-->


</html>
