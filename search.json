[{"title":"深入理解Haskell-IO","url":"/blog/2019/05/29/深入理解Haskell-IO/","content":"> 本文翻译自[维基百科](https://wiki.haskell.org/IO_inside),想要看原文的可以去那里查看.\n\n### IO内部\nHaskell I/O一直是新Haskellers混乱和惊喜的根源。虽然Haskell中的简单I/O代码看起来非常类似于命令式语言中的等价物，但尝试编写更复杂的代码通常会导致完全混乱。这是因为Haskell I/O内部真的非常不同。Haskell是一种纯语言，甚至I/O系统也无法打破这种纯度。\n以下正文试图解释Haskell I/O实现的细节，这个解释应该可以帮助你最终掌握所有的智能I/O技巧。此外，我已经添加了您可能遇到的各种陷阱的详细说明。阅读本文后，您将获得\"Haskell I/O大师\"学位，该学位同等于计算机科学和数学学士学位。\n如果您是Haskell I/O新手，您可能更愿意从阅读[IO简介](https://wiki.haskell.org/Introduction_to_IO)开始\n\n#### Haskell是一门纯语言\nHaskell是一门纯语言，这意味着任何函数调用的结果完全由其参数决定，像C中的`rand()`或`getchar()`这样的伪函数在每次调用时都会返回不同的结果，这些函数根本不可能在Haskell中编写。而且，Haskell函数不能有副作用，这意味着这些函数不能对\"真实世界\"做任何更改，例如：更改文件/写入文件/打印/通过网络发送数据等。这两个限制一起意味着任何函数调用都可以被具有相同参数的先前调用的结果替换，并且语言保证所有这些重新排列不会改变程序结果!\n\n让我们将其与C语言进行比较: 优化C编译器尝试猜测哪些函数没有副作用，并且不依赖于可变全局变量。如果这个猜测错了，优化可以改变程序的语义！为了避免这种灾难，C优化器在猜测中是保守的，或者需要程序员提供有关函数纯度的提示。\n\n与优化的C编译器相比，Haskell编译器是一组纯数学转换。这导致更好的高级优化设施。此外，纯数学计算可以更容易地分成几个可以并行执行的线程，这在多核CPU的这些日子里越来越重要。最后，纯计算不易出错且更容易验证，这增加了Haskell的稳健性和使用Haskell的程序开发速度。Haskell纯度允许编译器只调用其结果确实需要计算高级函数的最终值的函数(例如: main) - 这称为惰性求值。纯粹的数学计算是件好事，但是I/O动作怎么样？函数如下:\n```\nputStrLn \"Press any key to begin formatting\"\n```\n不能返回任何有意义的结果值，那么我们如何确保编译器不会省略或重新排序其执行？总的来说，我们如何使用完全惰性的语言处理有状态的算法和副作用？这个问题在18年的Haskell开发中提出了许多不同的解决方案(参见Haskell的历史)，尽管现在基于monads的解决方案已成为标准。\n\n#### monad是什么?\n什么是monad? 这是来自数学范畴理论的东西，我不知道了。为了理解monad如何用于解决I/O和副作用的问题，您不需要知道它。就像我一样，只知道小学数学就足够了。\n让我们想象一下，我们想在Haskell中实现众所周知的`getchar`函数。它应该有什么样的类型？我们试试吧：\n```\ngetchar :: Char\n\nget2chars = [getchar,getchar]\n```\n只有`Char`类型的`getchar`函数会得到什么？您可以在`get2chars`的定义中看到所有可能出现的问题：\n* 因为Haskell编译器将所有函数视为纯函数(没有副作用)，所以它可以避免对`getchar`的\"过度\"调用, 并使用两次返回值.\n* 即使它确实进行了两次调用，也无法确定应首先执行哪个调用。你想按照阅读顺序或相反的顺序返回两个字符吗？`get2chars`定义中没有任何内容可以回答这个问题。\n\n从程序员的角度来看，如何解决这些问题呢？\n让我们为`getchar`函数增加一个\"伪装\"的参数，使每个调用与编译器的观点\"不同\":\n```\ngetchar :: Int -> Char\n\nget2chars = [getchar 1, getchar 2]\n```\n马上，这解决了上面提到的第一个问题 - 现在编译器将进行两次调用，因为编译器将它们视为具有不同的参数。整个`get2chars`函数也应该有一个\"伪装\"参数，否则我们会遇到同样的问题：\n```\ngetchar   :: Int -> Char\nget2chars :: Int -> String\n\nget2chars _ = [getchar 1, getchar 2]\n```\n现在我们需要给编译器一些线索来确定它应该首先调用哪个函数。Haskell语言没有提供任何表达评估顺序的方法......除了数据依赖性！如何添加一个人工数据依赖项，以防止在第一个`getchar`之前评估第二个`getchar`？为了实现这一目标，我们将从`getchar`函数返回一个额外的\"伪装\"结果，该\"伪装\"结果将用作下一个`getchar`函数调用的参数：\n```\ngetchar :: Int -> (Char, Int)\n\nget2chars _ = [a,b]  where (a,i) = getchar 1\n                           (b,_) = getchar i\n```\n到目前为止还不错 - 现在我们可以保证在读`b`之前读取`a`，因为读`b`需要通过读`a`返回的值(`i`)!\n我们在`get2chars`中添加了一个\"伪装\"参数，但问题是Haskell编译器太聪明了! 它可以相信外部`getchar`函数真的依赖于它的参数，但是对于`get2chars`函数，它会看到我们是在作弊，因为我们扔掉了它(参数使用了_占位符)! 因此，编译器不会觉得有必要按照我们想要的顺序执行调用。我们该如何解决这个问题? 将这个\"虚假\"的参数传递给`getchar`函数怎么样?! 这样的话，编译器就无法猜测它是否真的未使用过。\n\n```\nget2chars i0 = [a,b]  where (a,i1) = getchar i0\n                            (b,i2) = getchar i1\n```\n还有更多 - `get2chars`具有与`getchar`功能相同的纯度问题。\n如果需要调用`get2chars`两次，则需要一种方法来描述这些调用的顺序。看着：\n```\nget4chars = [get2chars 1, get2chars 2]  -- order of 'get2chars' calls isn't defined 未定义'get2chars'调用的顺序\n```\n我们已经知道如何处理这些问题 - `get2chars`函数也应该返回一些可以用来顺序调用的\"伪装\"值：\n```\nget2chars :: Int -> (String, Int)\n\nget4chars i0 = (a++b)  where (a,i1) = get2chars i0\n                             (b,i2) = get2chars i1\n```\n但是`get2chars`函数应该返回什么\"伪装\"值？如果我们使用一些整数常量，那么过于聪明的Haskell编译器会猜测我们想再次作弊。如何返回`getchar`函数返回的值？看：\n```\nget2chars :: Int -> (String, Int)\nget2chars i0 = ([a,b], i2)  where (a,i1) = getchar i0\n                                  (b,i2) = getchar i1\n```\n信不信由你，但我们刚刚已经构建了整个`monadic` Haskell I/O系统。\n\n#### 欢迎来到真实世界，宝贝\n警告：关于IO的以下故事是不正确的，因为它无法实际解释IO的一些重要方面（包括交互和并发）。但是，有些人发现开始理解是有用的。\nHaskell `main`函数具有以下类型:\n```\nmain :: RealWorld -> ((), RealWorld)\n```\n其中`RealWorld`是一种\"伪装\"的类型，用来替换我们的Int。\n这就像在接力赛中接过的接力棒。当`main`函数调用某些IO函数时，它将作为参数收到的\"RealWorld\"传递给了IO函数。所有IO函数都有类似的类型，涉及`RealWorld`作为参数和结果。确切地说，`IO`是以下列方式定义的类型同义词：\n```\ntype IO a  =  RealWorld -> (a, RealWorld)\n```\n因此，`main`函数只有类型`IO()`，`getChar`函数有类型`IO Char`,等等。您可以将`IO Char`类型视为\"获取当前的`RealWorld`，对其执行某些操作，并返回`Char`和（可能已更改的）`RealWorld`。让我们看`main`调用`getChar`两次：\n```\ngetChar :: RealWorld -> (Char, RealWorld)\n\nmain :: RealWorld -> ((), RealWorld)\nmain world0 = let (a, world1) = getChar world0\n                  (b, world2) = getChar world1\n              in ((), world2)\n```\n仔细看看：`main`函数将收到的`world0`传递给第一个`getChar`函数。 这个`getChar`函数返回一些`RealWorld`类型的新值，它将在下一次调用中使用。最后，`main`返回它从第二个`getChar`获得的`world2`。\n* 如果没有使用它读取的字符，这里是否可以省略任何`getChar`调用？不，因为我们需要返回第二个`getChar`结果的`world2`，这又需要从第一个`getChar`返回的`world1`。\n* 是否可以重新排序`getChar`调用？ 否：第二个`getChar`在第一个之前无法调用，因为它使用了第一次调用返回的`world1`.\n* 是否可以重复调用？ 在Haskell语义中 - 是的，但真正的编译器永远不会在这种简单的情况下重复工作（否则，生成的程序将没有任何速度保证）。\n\n正如我们已经说过的那样，RealWorld值被用作一个接力棒，它在严格的顺序中被`main`调用的所有例程之间传递。在每个例程中，RealWorld值以相同的方式使用。 总的来说，为了\"计算\"从`main`返回的`world`，我们应该直接或间接地执行从`main`调用的每个IO过程。这意味着插入链中的每个程序都将在我们打算调用它时执行(相对于其他IO操作)。让我们考虑以下程序：\n```\nmain = do a <- ask \"What is your name?\"\n          b <- ask \"How old are you?\"\n          return ()\n\nask s = do putStr s\n           readLn\n```\n现在你有足够的知识以低级别方式重写它，并检查每个应该执行的操作是否真的将使用它应该具有的参数并按照我们期望的顺序执行。\n但是条件执行呢？没问题。让我们定义众所周知的`when`操作：\n```\nwhen :: Bool -> IO () -> IO ()\nwhen condition action world =\n    if condition\n      then action world\n      else ((), world)\n```\n如您所见，我们可以根据数据值轻松地在执行链中包含或排除IO过程(操作)，如果在`when`的调用中`condition`为False，那么`action`将永远不会被调用，因为真实的Haskell编译器，从不调用其结果不用于最终结果的函数(例如: 这里main函数的`world`最终值)。循环和更复杂的控制结构可以以相同的方式实现。试试看吧！\n最后，你可能想要知道，在程序中传递这些RealWorld值需要花费的成本，它是免费的，这些\"伪装\"值仅在编译器分析和优化代码时存在，但是当它进入汇编代码生成时，它\"突然\"意识到这种类型就像`()`，因此所有的这些参数和结果值都可以从最终生成的代码中省略。这不漂亮吗？\n\n#### `>>=` 和 `do` 表示法\n所有初学者(包括我)都认为`do`是执行IO动作的魔术语句。那是错的,`do`只是语法糖，它简化了使用IO(以及其他monad的程序)的编写，但这超出了本教程的范围。`do`符号最终被转换为传递`world`值的语句，就像我们上面手动编写的那样，用于简化几个IO操作的粘合。您不需要只为一条语句使用`do`语句,例如:\n```\nmain = do putStr \"Hello!\"\n```\n脱糖后:\n```\nmain = putStr \"Hello!\"\n```\n让我们来看看如何在下面的例子中使用多个语句来解释`do`\n```\nmain = do putStr \"What is your name?\"\n          putStr \"How old are you?\"\n          putStr \"Nice day!\"\n```\n这里的`do`语句只是加入了应该按顺序执行的几个IO动作。它被翻译成一个所谓的\"绑定运算符\"的顺序应用程序，即`>>`：\n```\nmain = (putStr \"What is your name?\") >> ((putStr \"How old are you?\") >> (putStr \"Nice day!\"))\n```\n这个绑定操作符只是结合了两个IO动作，通过在它们之间传递`world`来顺序执行它们：\n```\n(>>) :: IO a -> IO b -> IO b\n(action1 >> action2) world0 =\n   let (a, world1) = action1 world0\n       (b, world2) = action2 world1\n   in (b, world2)\n```\n如果以这种方式定义运算符对您来说很奇怪，请按以下方式阅读此定义：\n```\naction1 >> action2 = action\n  where\n    action world0 = let (a, world1) = action1 world0\n                        (b, world2) = action2 world1\n                    in (b, world2)\n```\n现在，您可以在使用`>>`的位置替换其定义，并检查由`do`语法糖构造的程序实际上与我们通过手动操作`world`值编写的程序相同。\n\n更复杂的示例涉及使用`<-`绑定的变量：\n```\nmain = do \n   a <- readLn\n   print a\n```\n这段代码可以脱糖为:\n```\nmain = readLn >>= (\\a -> print a)\n```\n正如您应该记住的那样,`>>`绑定操作符默默地忽略其第一个`action`的值，仅将其第二个`action`的结果做为整体结果返回。\n另一方面,`>>=`绑定操作符(注意末尾的额外'=')允许我们使用其第一个`action`的结果, 并将其作为附加参数传递给第二个`action`,看看定义：\n```\n(>>=) :: IO a -> (a -> IO b) -> IO b\n(action1 >>= action2) world0 =\n   let (a, world1) = action1 world0\n       (b, world2) = action2 a world1\n   in (b, world2)\n```\n首先,第二个`action`的类型(更准确地说,是一个返回IO action的函数),即`a -> IO b`是什么意思? \n通过替换IO定义,我们得到`a -> RealWorld -> (b, RealWorld)`,这意味着第二个action实际上有两个参数: 实际在其中使用的类型`a`,以及用于IO action排序的`RealWorld`类型的值. \n情况总是如此,与您在其类型签名中看到的相比较,任何IO过程都另有一个参数,此参数隐藏在别名\"IO\"的定义中。\n其次,您可以使用`>>`和`>>=`这些操作来简化您的程序。例如,在上面的代码中我们不需要引入变量a,因为`readLn`的结果可以直接发送到`print`:\n```\nmain = readLn >>= print\n```\n第三,如你所见,符号：\n```\ndo x <- action1\n    action2\n```\n其中`action1`的类型为`IO a`,而`action2`的类型为`IO b`,转换为：\n```\naction1 >>= (\\x -> action2)\n```\n其中`>>=`的第二个参数的类型为`a -> IO b`,这就是处理`<-`绑定的方式: `<-`左侧的名称只是后续操作的一个参数,表示为一个大的IO action.\n另请注意,如果`action1`的类型为`IO a`,那么`x`将只有类型`a`; 您可以将`<-`的效果视为将`action1`的IO值\"解包\"为`x`.\n还要注意`<-`不是真正的运算符,它是纯语法,就像`do`本身一样,它的含义只取决于它被贬低的方式.\n\n看下一个例子:\n```\nmain = do putStr \"What is your name?\"\n          a <- readLn\n          putStr \"How old are you?\"\n          b <- readLn\n          print (a,b)\n```\n这段代码可以脱糖为:\n```\nmain = putStr \"What is your name?\"\n       >> readLn\n       >>= \\a -> putStr \"How old are you?\"\n       >> readLn\n       >>= \\b -> print (a,b)\n```\n我在这里省略了括号,`>>`和`>>=`运算符都是左关联的,但是lambda绑定总是尽可能向右延伸,这意味着这里引入的`a`和`b`绑定对所有剩余的动作都有效.\n作为练习,自己添加括号并将此过程转换为显式传递`world`值的低级代码(练习),我认为这应该足以帮助您最终了解`do`转换和绑定操作符`>>=`的工作原理.\n\n不好,我忘记了第三个monadic运算符: `return`,它只是结合了它的两个参数: 传递的值和`world`:\n```\nreturn :: a -> IO a\nreturn a world0 = (a, world0)\n```\n转换一个简单的`return`用法示例怎么样？说，\n```\nmain = do a <- readLn\n          return (a*2)\n```\n具有命令式语言背景的程序员通常认为Haskell中的`return`与其他语言一样,会立即从IO过程返回.正如你在其定义中看到的那样(甚至只是从它的类型),这样的假设是完全错误的,\n使用`return`的唯一目的是将一些值(类型为'a')`lift`到整个动作的结果中(类型为`IO a`),因此它通常应该仅用作某个IO序列的最后执行语句,例如,尝试将以下过程转换为相应的低级代码(练习)：\n```\nmain = do a <- readLn\n          when (a>=0) $ do\n              return ()\n          print \"a is negative\"\n```\n并且您将意识到即使对于`a`的非负值,也会执行`print`语句. 如果需要从IO过程中间退出,可以使用`if`语句:\n```\nain = do a <- readLn\n          if (a>=0)\n            then return ()\n            else print \"a is negative\"\n```\n而且，Haskell设计规则允许我们使用以下设计:\n```\nmain = do a <- readLn\n          if (a>=0) then return ()\n            else do\n          print \"a is negative\"\n          ...\n```\n这可能有助于从冗长的`do`语句中逃脱。\n\n最后一个练习: 实现一个函数`liftM`.它将普通值的操作提升到monadic的操作,它的类型签名:\n```\nliftM :: (a -> b) -> (IO a -> IO b)\n```\n如果这对您来说太难了,请从以下高级定义开始并以低级方式重写它(练习):\n```\nliftM f action = do x <- action\n                    return (f x)\n```\n\n#### 可变数据(引用/数组/哈希表)\n\n#### IO动作作为值\n\n#### 异常处理\n\n\n#### 与C/C++和外部库的接口\n\n#### IO monad的黑暗面\n\n#### 更安全的方法: ST monad\n\n#### 欢迎来到机器: 现实的GHC实施\n\n#### 进一步阅读\n\n#### to-do列表\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["IO"]},{"title":"Dubbo源码阅读之服务器创建","url":"/blog/2019/02/20/Dubbo源码阅读之服务器创建/","content":">在《Dubbo源码阅读之服务暴露》一文中，我们知道在服务暴露时会创建服务器，这篇文章我们就详细看下服务器相关的源码。\n\n![](images/dubbo.jpeg)\n\n###\n\n\n\n","tags":["dubbo"]},{"title":"Haskell常用扩展","url":"/blog/2018/11/20/Haskell常用扩展/","content":"\n### BinaryLiterals\n\n### ExistentialQuantification\n\n### FlexibleInstances\n\n### LambdaCase\n一个句法扩展，允许你用\\case代替\\arg - > case arg of.\n请考虑以下函数定义：\n```\ndayOfTheWeek :: Int -> String\ndayOfTheWeek 0 = \"Sunday\"\ndayOfTheWeek 1 = \"Monday\"\ndayOfTheWeek 2 = \"Tuesday\"\ndayOfTheWeek 3 = \"Wednesday\"\ndayOfTheWeek 4 = \"Thursday\"\ndayOfTheWeek 5 = \"Friday\"\ndayOfTheWeek 6 = \"Saturday\"\n```\n如果您想避免重复函数名称，可以这样编写：\n```\ndayOfTheWeek :: Int -> String\ndayOfTheWeek i = case i of\n    0 -> \"Sunday\"\n    1 -> \"Monday\"\n    2 -> \"Tuesday\"\n    3 -> \"Wednesday\"\n    4 -> \"Thursday\"\n    5 -> \"Friday\"\n    6 -> \"Saturday\"\n```\n而使用LambdaCase扩展后，您可以将其编写为函数表达式，而无需为参数命名：\n```\n{-# LANGUAGE LambdaCase #-}\n\ndayOfTheWeek :: Int -> String\ndayOfTheWeek = \\case\n    0 -> \"Sunday\"\n    1 -> \"Monday\"\n    2 -> \"Tuesday\"\n    3 -> \"Wednesday\"\n    4 -> \"Thursday\"\n    5 -> \"Friday\"\n    6 -> \"Saturday\"\n```\n\n### ScopedTypeVariables\nScopedTypeVariables允许您引用声明中的通用量化类型, 更明确一点：\n```\nimport Data.Monoid\n\nfoo :: forall a b c. (Monoid b, Monoid c) => (a, b, c) -> (b, c) -> (a, b, c)\nfoo (a, b, c) (b', c') = (a :: a, b'', c'')\n    where (b'', c'') = (b <> b', c <> c') :: (b, c)\n```\n重要的是我们可以使用a,b和c来指示编译器在声明的子表达式中(where子句中的元组和最终结果中的第一个a),实际上,ScopedTypeVariables有助于将复杂函数编写为部分之和，允许程序员将类型签名添加到没有具体类型的中间值。\n\n\n### OverloadedStrings\n通常，Haskell中的字符串文字具有String类型（它是[Char]的类型别名）。虽然这对于较小的教育程序来说不是问题，但实际应用程序通常需要更高效的存储，例如Text或ByteString.\nOverloadedStrings只是将文字类型更改为:\n```\n\"test\" :: Data.String.IsString a => a\n```\n允许它们直接传递给期望这种类型的函数。许多库为类似字符串的类型实现了这个接口，包括Data.Text和Data.ByteString ，它们都比[Char]提供了一定的时间和空间优势。\n\n还有一些像Postgresql简单库那样的OverloadedStrings独特用途，它允许用双引号编写SQL查询，就像普通字符串一样，但提供了对不正确连接的保护，这是一种臭名昭着的SQL注入攻击源。\n要创建IsString类的实例，您需要实现fromString函数。示例：\n```\ndata Foo = A | B | Other String deriving Show\n\ninstance IsString Foo where\n  fromString \"A\" = A\n  fromString \"B\" = B\n  fromString xs  = Other xs\n\ntests :: [ Foo ]\ntests = [ \"A\", \"B\", \"Testing\" ]\n```\n\n\n\n### TupleSections\n一种语法扩展，允许以节的方式应用元组构造函数(它是一个运算符):\n```\n(a,b) == (,) a b\n\n-- With TupleSections\n(a,b) == (,) a b == (a,) b == (,b) a\n```\n#### N-tuples\n它也适用于元素大于2的元组\n```\n(,2,) 1 3 == (1,2,3)\n```\n#### Mapping\n这在使用部分的其他地方也很有用:\n```\nmap (,\"tag\") [1,2,3] == [(1,\"tag\"), (2, \"tag\"), (3, \"tag\")]\n```\n没有此扩展的上述示例如下所示：\n```\nmap (\\a -> (a, \"tag\")) [1,2,3]\n```\n\n\n\n","tags":["haskell"]},{"title":"wire-server翻译","url":"/blog/2018/11/19/wire-server翻译/","content":"\n### 仓库内容\n这个仓库包含一下源代码：\n\n#### services(服务)\n* nginz: 反向代理公共API（带有libzauth自定义模块的Nginx）\n* galley: 会话和团队\n* brig: 账户\n* gundeck: 推送通知中心\n* cannon: WebSocket推送通知\n* cargohold: 资产(图像，文件...)存储\n* proxy: 集成第三方API\n* restund: 用于音频/视频通话的STUN/TURN服务器\n\n#### tools(工具)\n* api-simulations: 自动化运行冒烟和负载测试 \n* makedeb: 创建Debian软件包\n* bonanza: 转换和转发日志数据\n* db/: 迁移工具(例如: 当添加新的表时)\n\n#### libs(库)\n* 共享库\n\n#### 其他\n* build: 为某些平台构建脚本和Dockerfiles\n* deploy: (正在进行中)-如何在短暂的内存演示模式下运行wire-server\n* doc: 文档\n\n### 架构概述\n下图提供了构成Wire Server的组件（部署）体系结构的高级概述，以及组件之间主要的内部和外部依赖关系。\n![](img/main.png)\n内部组件之间的通信目前没有通过专用认证或加密来保护，并且被假定为局限于专用网络。\n\n### Development setup(开发设置)\n#### 如何构建wire-server二进制文件\n两种方式：\n* 本地编译源代码\n  这需要一系列依赖于您的平台/操作系统的依赖关系，例如：\n    * Haskell 和Rust编译器和包管理器\n    * 依赖于你的平台/操作系统的一些依赖包(libsodium, openssl, protobuf, icu, geoip, snappy, cryptobox-c,)\n  查看依赖详情(doc/Dependencies.md)\n  设置好所有的依赖项后，下面的操作应该是成功的：\n```shell\n# build all haskell services\nmake\n# build one haskell service, e.g. brig:\ncd services/brig && make\n```\n默认的make target（fast）编译未优化（编译时间更快，二进制文件更慢），这对于开发目的来说应该没问题。 使用make install获取优化的二进制文件。\n对于编译nginz，请看(services/nginz/README.md)\n* 使用Docker\n如果您不希望从头开始构建所有docker镜像(例如:alpine-builder需要很长时间),可以从此处下载现成的镜像。\n如果你希望构建你自己的Docker镜像，你需要docker version >= 17.05和make，然后执行:\n```shell\nmake docker-services\n```\n最终，它将构建一系列docker镜像，有关详细信息，请看Makefiles和Dockerfiles，以及build/alpine/README.md\n\n#### 如何运行集成测试\n运行集成测试前，要求所有的haskell服务((brig,galley,cannon,gundeck,proxy,cargohold)都已经正确配置并且已启动，然后才能执行例如:brig-integration二进制文件。这要求在体系结构图中看到的大多数部署依赖项也都是可用的：\n* 必须的内部依赖项\n  * cassandra(使用正确的schema)\n  * elasticsearch(使用正确的schema)\n  * redis\n* 必须的外部依赖项是以下已经配置好的AWS服务(或提供相同API的假的配件)\n  * SES\n  * SQS\n  * SNS\n  * S3\n  * Cloudfront\n  * DynamoDB\n使用docker-compose设置这些真实的只是在内存中的内部和\"假\"的外部依赖是非常容易的。在一个单独的终端中运行以下命令(它将阻塞终端，使用C-c去关闭这些所有的docker镜像):\n```shell\ndeploy/docker-ephemeral/run.sh\n```\n然后，运行所有的集成测试:\n```shell\nmake integration\n```\n或者，在顶级目录上进行make(生成所有服务的二进制文件)，然后执行例如: cd services/brig && make integration 只运行一个服务的集成测试。\n\n您可以使用$WIRE_STACK_OPTIONS通过Makefiles将参数传递给堆栈，这是很有用的，例如：传递参数到tasty，或者暂时禁用-Werror而不会有意外提交任何内容的风险，如下所示：\n```shell\nWIRE_STACK_OPTIONS='--ghc-options=-Wwarn --test-arguments=\"--quickcheck-tests=19919 --quickcheck-replay=651712\"' make integration\n```\n提示：https://github.com/feuerbach/tasty#runtime\n#### 如何使用\"假\"的外部依赖运行wire-server\n看https://github.com/wireapp/wire-server/blob/develop/deploy/services-demo/README.md\n#### 如何使用真实的AWS服务运行wire-server\n文档，配置和代码尚未完全准备好（请不要打开issue来询问这个问题！）。 有关如何运行有线服务器的更多信息将在不久的将来提供。\n作为简要概述，他需要设置:\n* 数据库集群(cassandra, redis, elasticsearch)\n* 外部依赖\n  * 有权访问的亚马逊账户\n     * SES\n     * SQS\n     * SNS\n     * S3\n     * Cloudfront\n     * DynamoDB\n  * Nexmo/Twilio账户(如果你想发送短信)\n  * Giphy/Google/Spotify/Soundcloud API密钥(如果你希望通过代理这些服务来支持预览)\n  * TURN服务(如果你希望支持语音/视频通话)\n* 所有服务的生产预备环境配置\n* 其他基础架构配置(DNS, SSL certificates, metrics, logging, etc)\n\n#### Roadmap(路线图)\n* 部署选项\n"},{"title":"Redis源码阅读-字符串","url":"/blog/2018/11/17/Redis源码阅读-字符串/","content":">Redis动态字符串数据结构的定义及实现在sds.h和sds.c文件中。\n\n* 字符串定义\n* 字符串实现\n* 方法实现\n\n### 字符串定义\n我们平时在使用Redis时，经常使用的数据结构就是字符串，例如：\n```shell\n127.0.0.1:6379> set name Redis\nOK\n127.0.0.1:6379> get name\n\"Redis\"\n127.0.0.1:6379> del name\n(integer) 1\n```\n那么字符串在Redis是如何定义的呢？我们可以在sds.h文件中找到答案。\n在该文件中，我们可以看到Redis字符串数据结构SDS由两部分组成，sds指针和sdshdr头部类型，\n其中sdshdr类型定义了5种(sdshdr5/sdshdr8/sdshdr16/sdshdr32/sdshdr64)，主要是为了针对不同长度的字符串，节省内存：\n```c\ntypedef char *sds;\n\nstruct __attribute__ ((__packed__)) sdshdr5 {\n    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr8 {\n    uint8_t len;\n    uint8_t alloc;\n    unsigned char flags;\n    char buf[];\n};\n\n/*flags值定义*/\n#define SDS_TYPE_5  0\n#define SDS_TYPE_8  1\n#define SDS_TYPE_16 2\n#define SDS_TYPE_32 3\n#define SDS_TYPE_64 4\n\n//掩码\n#define SDS_TYPE_MASK 7\n#define SDS_TYPE_BITS 3\n\n/*通过buf指针获取sds头指针，T为sds头类型值，s为buf指针\n *这里##会将两个字符串连接起来，如:T为8，则sdshdr##T为sdshrd8\n *sizeof(struct sdshdr##T)为结构体sdshdr8占用的字节数，这里为3字节\n */\n#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));\n\n#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))\n\n#define SDS_TYPE_5_LEN(f) ((f)>>SDS_TYPE_BITS)\n```\n![](img/sds.png)\nlen   标识当前字节数组的长度，不包含字符串结束标识。\nalloc 标识当前字节数组分配的内存大小，不包含字符串结束标识。\nflags 低3位标识当前使用的是哪个sdshdr类型。\nbuf   保存字符串值和结束标识。\n*sds  指向buf数组的起始地址\n为SDS增加一个头部类型可以提高一些操作的效率，例如用O(1)的复杂度就可以从头部中取到字符串长度。\nsdshdr头部类型是通过结构体定义的，默认情况下会进行内存对齐优化，即结构体分配的内存是内部最大元素的整数倍，例如sdshdr32将会分配12字节。\n这里使用__attribute__ ((__packed__))关闭内存对齐优化，从而按照实际占用字节数来对齐，即sdshdr32将会分配9字节，节省了3字节。内存紧凑，使用sds-1就可以得到flags字段，进而得到其头部类型。没有内存对齐，cpu寻址效率就会降低，Redis是在内存分配前做了一些操作，解决内存对齐的，后面会看到。\nbuf数组初始化时不占用内存空间，使得头部内存和存储字符串的内存地址连续，另外结尾隐含一个'\\0',而SDS是以len字段来判断是否是否到达字符串末尾的，因此在字符串中间可以出现'\\0'，即SDS字符串是二进制安全的。\n\n### 字符串实现\n创建新字符串使用的是sds.c中的sdsnewlen函数：\n```c\n// 使用init指针指向的内容和initlen创建一个新的字符串\nsds sdsnewlen(const void *init, size_t initlen) {\n    void *sh;\n    \n    // buf数组起始地址\n    sds s;\n    \n    // 根据长度选择合适的sds头部类型\n    char type = sdsReqType(initlen);\n\n    // 用type 8创建空字符串方便追加\n    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;\n    \n    // 根据sds头部类型获取头部大小\n    int hdrlen = sdsHdrSize(type);\n    \n    // flag指针\n    unsigned char *fp;\n\n    // 为sds分配内存（后面会分析s_malloc）\n    // 内存大小为：sds头部大小 + 存储字符串的长度initlen + 末尾空字符大小1字节\n    sh = s_malloc(hdrlen+initlen+1); \n\n    if (!init)\n        // 内存初始化为0（后面会分析memset）\n        memset(sh, 0, hdrlen+initlen+1);\n    // 内存分配失败\n    if (sh == NULL) return NULL;\n\n    // buf数组的起始地址\n    s = (char*)sh+hdrlen;\n    \n    // buf数组起始地址-1，即为flags字段\n    fp = ((unsigned char*)s)-1;\n\n    // 初始化sds头部的len,alloc,flags字段\n    switch(type) {\n        case SDS_TYPE_5: {\n            *fp = type | (initlen << SDS_TYPE_BITS);\n            break;\n        }\n        case SDS_TYPE_8: {\n            //根据buf起始地址获取指向sds头部的起始地址的指针\n            SDS_HDR_VAR(8,s);\n\t    // 设置len字段值为initlen\n            sh->len = initlen;\n\t    // 设置alloc字段值为initlen\n            sh->alloc = initlen;\n\t    // 设置flags字段类型为type\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n    }\n    // 初始化buf数组\n    if (initlen && init)\n        // 拷贝init到buf数组（后面会分析memcpy）\n        memcpy(s, init, initlen);\n\n    // 添加末尾空字符标识\n    s[initlen] = '\\0';\n    return s;\n}\n\n/**\n * 根据字符串长度获取合适的头部类型\n * @param string_size 字符串初始长度\n * @return\n */\nstatic inline char sdsReqType(size_t string_size) {\n    if (string_size < 1<<5) //32\n        return SDS_TYPE_5;\n    if (string_size < 1<<8) //256\n        return SDS_TYPE_8;\n    if (string_size < 1<<16) //65536\n        return SDS_TYPE_16;\n#if (LONG_MAX == LLONG_MAX) //等于有符号long最大值\n    if (string_size < 1ll<<32) //4gb\n        return SDS_TYPE_32;\n    return SDS_TYPE_64;\n#else\n    return SDS_TYPE_32;\n#endif\n}\n\n/**\n * 通过字符串头部类型获取其头大小\n * @param type 字符串类型 0-4\n * @return\n */\nstatic inline int sdsHdrSize(char type) {\n    // type & SDS_TYPE_MASK = type\n    // 例如：sdshdr8， 1 & 7 = 1\n    switch(type&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            return sizeof(struct sdshdr5);\n        case SDS_TYPE_8:\n            //sizeof计算结构体大小，取消了内存对齐\n            return sizeof(struct sdshdr8); // 3字节\n        case SDS_TYPE_16:\n            return sizeof(struct sdshdr16); // 5字节\n        case SDS_TYPE_32:\n            return sizeof(struct sdshdr32); // 9字节\n        case SDS_TYPE_64:\n            return sizeof(struct sdshdr64); // 17字节\n    }\n    return 0;\n}\n```\n关于内存操作的函数，将在内存操作小节介绍，这里就不在进行介绍了。\n### 方法实现\n","tags":["redis"]},{"title":"数据结构与算法-复杂度分析","url":"/blog/2018/10/13/数据结构与算法-复杂度分析/","content":">本小节总结时间、空间复杂度分析\n* 什么是复杂度分析？\n* 为什么要进行复杂度分析？\n* 如何进行时间、空间复杂度分析？(大O表示法)\n\n### 什么是复杂度分析\n1. 数据机构与算法是为了解决\"如何让计算机运行的更快同时更省存储空间\"的问题，因此，执行效率是评估一个算法好坏的重要指标。\n2. 我们需要从算法执行时间、占用空间两个纬度来评估数据结构和算法的性能。通常使用时间复杂度和空间复杂度来描述性能问题。\n3. 复杂度分析描述的是算法执行时间(占用空间)与数据规模的增长关系。\n\n### 为什么要进行复杂度分析\n平时我们会把代码运行一遍，然后通过统计、监控就可以得到算法执行的时间和占用的内存，此方法称为事后统计法，存在很大的局限性。\n1. 测试结果非常依赖测试环境\n2. 测试结果受数据规模的影响很大，我们需要一个不用具体的测试数据进行测试就可以粗略的评估算法执行效率的方法。\n3. 掌握复杂度分析，将会编写出性能更优的代码，有利于降低系统开发和维护的成本。\n\n### 如何进行复杂度分析\n#### 大O表示法的由来\n所有代码的执行时间T(n)与每行代码的执行次数n成正比。用大O表示法就是:\n```\n\tT(n) = O(f(n))\n其中:\n\tT(n) 表示代码执行时间。\n\tf(n) 表示每行代码执行的次数总和。\n\t大0 表示代码执行时间 T(n) 与 f(n) 表达式成正比。\n```\n大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势。因此也叫做渐进时间复杂度，简称时间复杂度。\n\n#### 大O表示法的特点\n以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模增长的变化趋势，所以常量阶、低阶、以及系数实际上对这种增长趋势不产生决定性影响，因此在进行时间复杂度分析时可以省略这些项。\n\n#### 时间复杂度分析法则\n1. 只关注循环次数最多的一段代码：比如循环操作\n2. 加法法则取量级最大代码复杂度：比如一段代码中有单循环和多重循环，则取多重循环的复杂度。\n3. 乘法法则嵌套代码复杂度取乘积: 比如递归、多重循环等，取嵌套内外代码复杂度的乘积。\n4. 多个规模求加法：比如方法有两个参数分别控制两个循环的次数，则将两者的复杂度进行相加，即：O(m+n)\n\n#### 常见的时间复杂度级别\n1. 多项式阶\n    随着数据规模的不断增长，算法的执行时间和空间占用，按照多项式的比例增长。从低阶到高阶常见的有(越高阶效率越低)：\n```perl    \n\tO(1): 常数阶\n\n\tO(logn): 对数阶\n\n\tO(n): 线性阶\n\n\tO(nlogn): 线性对数阶\n\n\tO(n^2): 平方阶\n\n\tO(n^3): 立方阶\n```\n2. 非多项式阶\n    我们把时间复杂度为非多项式量级的算法问题叫做NP(Non-Deterministic Ploynomial非确定多项式)问题，随着数据规模的不断增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括：\n```perl\n\tO(2^n): 指数阶\n\n\tO(n!): 阶乘阶\n```\n#### 空间复杂度\n空间复杂度和时间复杂度类似，全称为：渐进空间复杂度，表示算法的存储空间和数据规模之间的增长关系。\n常见的空间复杂度级别有：O(1)、O(n)、O(n^2)，而O(logn)、O(nlogn)这样的对数阶复杂度平时都用不到。\n\n\n\n### 例子\n#### 时间复杂度分析\n##### O(1)\n\n##### O(logn)、O(nlogn)\n\n##### O(m+n)、O(m*n)\n \n#### 空间复杂度分析\n\n\n","tags":["复杂度分析"]},{"title":"Dubbo源码阅读之Configurator动态配置","url":"/blog/2018/09/05/Dubbo源码阅读之Configurator动态配置/","content":">我们可以编写动态配置来配置服务提供者。这个操作通常在监控中心完成。\n\n### 官网文档\n我们先看下官网给的文档说明\n```java\nRegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();\n//获取注册中心\nRegistry registry = registryFactory.getRegistry(URL.valueOf(\"zookeeper://10.20.153.10:2181\"));\n//注册配置\nregistry.register(URL.valueOf(\"override://0.0.0.0/com.foo.BarService?category=configurators&dynamic=false&application=foo&timeout=1000\"));\n```\n在这个配置override url中：\n* override:// 表示数据将会被覆盖，当前dubbo支持override和absent，可以自行扩展，必填参数.\n* 0.0.0.0 表示该配置对所有IP地址都有效，如果只想覆盖指定的ip数据，则可以替换指定的ip地址，必填参数.\n* com.foo.BarService 表示对指定的服务有效，必填参数.\n* category=configurators 表示数据是动态配置的，必填参数.\n* dynamic=false 表示数据是持久化的，当注册方撤销时，数据仍存储在注册表中。\n* enabled=true 启用覆盖策略，可以不传，不传的话，默认值为启用\n* application=foo 表示对指定的application有效，可以不传，不传的话则对所有应用程序有效。\n* timeout=1000 表示满足上述条件的timeout参数的值将会被1000覆盖，如果想要覆盖其他参数，则直接添加到override URL参数上。\n\n#### 例子\n* 禁用服务提供者(通常用于临时踢掉提供者机器，类似于禁止消费者访问，请使用路由规则)\n```java\noverride://10.20.153.10/com.foo.BarService?category=configurators&dynamic=false&disbaled=true\n```\n\n* 调整权重:(通常用于容量评估，默认为100)\n```java\noverride://10.20.153.10/com.foo.BarService?category=configurators&dynamic=false&weight=200\n```\n\n* 调整负载均衡策略(默认策略为随机)\n```java\noverride://10.20.153.10/com.foo.BarService?category=configurators&dynamic=false&loadbalance=leastactive\n```\n\n* 服务降级:(通常用于暂时屏蔽非关键服务的错误）\n```java\noverride://0.0.0.0/com.foo.BarService?category=configurators&dynamic=false&application=foo&mock=force:return+null\n```\n\n现在我们开始看源码实现\n### Configurator接口\n```java\npublic interface Configurator extends Comparable<Configurator> {\n\n    /**\n     * 获取配置url\n     */\n    URL getUrl();\n\n    /**\n     * 配置服务提供者url\n     * 向url中添加新属性(absent) 或者 覆盖url中的属性(override).(新属性来源于配置url)\n     * @param url 旧的提供者url\n     * @return  新的提供者url\n     */\n    URL configure(URL url);\n}\n```\n\n#### AbstractConfigurator抽象类\n该抽象类实现了Configurator接口。并实现了configure方法，在该方法中，会判断当前url是否满足覆盖url的条件。如果满足的话，会调用抽象方法doConfigure执行相应的配置。doConfigure抽象方法由两个子类AbsentConfigurator(absent)和OverrideConfigurator(override)进行实现。\n```java\npublic abstract class AbstractConfigurator implements Configurator {\n\n    /**\n     * 配置url\n     */\n    private final URL configuratorUrl;\n\n    public AbstractConfigurator(URL url) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"configurator url == null\");\n        }\n        this.configuratorUrl = url;\n    }\n\n    @Override\n    public URL getUrl() {\n        return configuratorUrl;\n    }\n\n    /**\n     * @param url 旧的url\n     * @return\n     */\n    @Override\n    public URL configure(URL url) {\n        if (configuratorUrl == null || configuratorUrl.getHost() == null\n                || url == null || url.getHost() == null) {\n            return url;\n        }\n        //如果override url存在端口，则意味着它是服务提供者地址\n        //我们想要这个override url控制一个指定的服务提供者\n        //该覆盖url规则可能对特定的服务提供者实例生效，或者对持有这个服务提供者实例的消费者生效\n        if (configuratorUrl.getPort() != 0) {\n            if (url.getPort() == configuratorUrl.getPort()) {\n                //服务提供者\n                return configureIfMatch(url.getHost(), url);\n            }\n        } else {\n            //configuratorUrl没有端口，意味着这个url的ip指定的是一个消费者地址或者0.0.0.0\n            //如果它是一个消费者ip地址，目的是控制一个特定的消费者实例，\n            //它必须在消费者端生效，任何提供者都将会忽略该url\n            //如果ip是0.0.0.0，则该配置url对消费者、生产者都生效\n            if (url.getParameter(Constants.SIDE_KEY, Constants.PROVIDER).equals(Constants.CONSUMER)) {\n                //消费者\n                //NetUtils.getLocalHost is the ip address consumer registered to registry.\n                //NetUtils.getLocalHost是一个注册到注册中心的消费者ip地址\n                return configureIfMatch(NetUtils.getLocalHost(), url);\n            } else if (url.getParameter(Constants.SIDE_KEY, Constants.CONSUMER).equals(Constants.PROVIDER)) {\n                //生产者\n                // take effect on all providers, so address must be 0.0.0.0,\n                // otherwise it won't flow to this if branch\n                //对所有生产者生效，因此地址必须是0.0.0.0，否则，它将不会进入这个分支\n                return configureIfMatch(Constants.ANYHOST_VALUE, url);\n            }\n        }\n        return url;\n    }\n\n    /**\n     * @param host 受影响的主机地址\n     * @param url\n     * @return\n     */\n    private URL configureIfMatch(String host, URL url) {\n        if (Constants.ANYHOST_VALUE.equals(configuratorUrl.getHost())\n                || host.equals(configuratorUrl.getHost())) {\n            //配置url的host等于0.0.0.0，或者等于host\n            \n            //获取配置url的application参数值，如果为空，则获取username属性\n            String configApplication = configuratorUrl.getParameter(Constants.APPLICATION_KEY,configuratorUrl.getUsername());\n            //获取当前url的application参数值，如果为空，则获取username属性\n            String currentApplication = url.getParameter(Constants.APPLICATION_KEY, url.getUsername());\n\n            if (configApplication == null || Constants.ANY_VALUE.equals(configApplication)\n                    || configApplication.equals(currentApplication)) {\n                //配置url的configApplication = (null || * || currentApplication)\n                Set<String> condtionKeys = new HashSet<String>();\n                \n\t\t//添加category、check、dynamic、enabled参数\n                condtionKeys.add(Constants.CATEGORY_KEY);\n                condtionKeys.add(Constants.CHECK_KEY);\n                condtionKeys.add(Constants.DYNAMIC_KEY);\n                condtionKeys.add(Constants.ENABLED_KEY);\n                \n\t\t//遍历配置url的参数列表\n                for (Map.Entry<String, String> entry : configuratorUrl.getParameters().entrySet()) {\n                    //参数key\n                    String key = entry.getKey();\n                    //参数value\n                    String value = entry.getValue();\n                    \n\t\t    if (key.startsWith(\"~\") || Constants.APPLICATION_KEY.equals(key) || Constants.SIDE_KEY.equals(key)) {\n\t\t\t//参数key = (application || side || ^~ )\n                        \n\t\t\t//添加该key参数\n                        condtionKeys.add(key);\n                        \n\t\t\tif (value != null && !Constants.ANY_VALUE.equals(value)\n                                && !value.equals(url.getParameter(key.startsWith(\"~\") ? key.substring(1) : key))) {\n                            //如果 当前url的key参数的值 != * 并且 不等于 配置url的key参数的值，则直接返回当前url\n                            return url;\n                        }\n                    }\n                }\n                //从配置url中移除condtionKeys参数，然后执行配置\n                return doConfigure(url, configuratorUrl.removeParameters(condtionKeys));\n            }\n        }\n        return url;\n    }\n\n    /**\n     * 1、具有特定主机IP的URL比0.0.0.0的优先级高\n     * 2、如果两个url有相同的host，比较priority字段的值\n     */\n    @Override\n    public int compareTo(Configurator o) {\n        if (o == null) {\n            return -1;\n        }\n\n        int ipCompare = getUrl().getHost().compareTo(o.getUrl().getHost());\n        if (ipCompare == 0) {\n            int i = getUrl().getParameter(Constants.PRIORITY_KEY, 0),\n                    j = o.getUrl().getParameter(Constants.PRIORITY_KEY, 0);\n            if (i < j) {\n                return -1;\n            } else if (i > j) {\n                return 1;\n            } else {\n                return 0;\n            }\n        } else {\n            return ipCompare;\n        }\n    }\n    \n    //抽象方法，执行相应配置策略\n    protected abstract URL doConfigure(URL currentUrl, URL configUrl);\n\n}\n```\n#### AbsentConfigurator实现类\n```java\npublic class AbsentConfigurator extends AbstractConfigurator {\n\n    public AbsentConfigurator(URL url) {\n        super(url);\n    }\n    \n    /**\n     * @currentUrl 服务提供者url\n     * @configUrl  配置url\n     */\n    @Override\n    public URL doConfigure(URL currentUrl, URL configUrl) {\n        //将配置url中的参数添加到服务提供者url参数中(只会添加不存在的，不会覆盖已存在的参数)\n        return currentUrl.addParametersIfAbsent(configUrl.getParameters());\n    }\n}\n\n/**\n * 只有原服务提供者url中不包含该参数时，才会添加，不会覆盖\n */\npublic URL addParametersIfAbsent(Map<String, String> parameters) {\n        if (parameters == null || parameters.size() == 0) {\n            return this;\n        }\n        //A-1,B-2,C-2 覆盖url\n        //A-2,B-2     原服务提供者url参数\n        //A-2,B-2,C-2 新的服务提供者url参数\n        Map<String, String> map = new HashMap<String, String>(parameters);\n        map.putAll(getParameters());\n        return new URL(protocol, username, password, host, port, path, map);\n}\n```\n\n#### OverrideConfigurator实现类\n```java\npublic class OverrideConfigurator extends AbstractConfigurator {\n\n    public OverrideConfigurator(URL url) {\n        super(url);\n    }\n \n    /**\n     * @currentUrl 服务提供者url\n     * @configUrl  配置url\n     */\n    @Override\n    public URL doConfigure(URL currentUrl, URL configUrl) {\n        //将配置url中的参数添加到服务提供者url参数中\n        return currentUrl.addParameters(configUrl.getParameters());\n    }\n}\n\n/**\n * 将配置url中的参数添加到服务提供者url参数中(会覆盖)\n */\npublic URL addParameters(Map<String, String> parameters) {\n\tif (parameters == null || parameters.size() == 0) {\n\t    return this;\n\t}\n\t//参数值没有发生变化\n\tboolean hasAndEqual = true;\n\tfor (Map.Entry<String, String> entry : parameters.entrySet()) {\n\t    //获取当前服务提供者url的参数值\n\t    String value = getParameters().get(entry.getKey());\n\t    if (value == null) {\n\t\t//当前服务提供者url中的参数值为空，并且覆盖url中的参数值不为空\n\t\tif (entry.getValue() != null) {\n\t\t    hasAndEqual = false;\n\t\t    break;\n\t\t}\n\t    } else {\n\t\t//当前服务提供者url中的参数值不为空，并且和覆盖url中的参数值不相等\n\t\tif (!value.equals(entry.getValue())) {\n\t\t    hasAndEqual = false;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tif (hasAndEqual) {\n\t    //没有发生变化。立即返回\n\t    return this;\n\t}\n\tMap<String, String> map = new HashMap<String, String>(getParameters());\n\t//使用配置url中的参数值覆盖当前服务提供者url中的参数值\n\tmap.putAll(parameters);\n\treturn new URL(protocol, username, password, host, port, path, map);\n}\n```\n\n#### 配置工厂类\n工厂类用来创建相应的配置策略实现类\n```java\npublic class AbsentConfiguratorFactory implements ConfiguratorFactory {\n    @Override\n    public Configurator getConfigurator(URL url) {\n        return new AbsentConfigurator(url);\n    }\n}\n\npublic class OverrideConfiguratorFactory implements ConfiguratorFactory {\n    @Override\n    public Configurator getConfigurator(URL url) {\n        return new OverrideConfigurator(url);\n    }\n}\n```\n配置扩展\n```java\noverride=com.alibaba.dubbo.rpc.cluster.configurator.override.OverrideConfiguratorFactory\nabsent=com.alibaba.dubbo.rpc.cluster.configurator.absent.AbsentConfiguratorFactory\n```\n\n自定义的配置策略实现，可以自行参照AbsentConfigurator类进行实现，本小节就先介绍到这里了。","tags":["dubbo"]},{"title":"Netty4.1源码阅读之common包-001","url":"/blog/2018/09/04/Netty4-1源码阅读之common包-001/","tags":["netty"]},{"title":"Dubbo源码阅读之Router","url":"/blog/2018/08/30/Dubbo源码阅读之Router/","content":">Router负责从多个Invoker中按路由规则选出子集,比如读写分离,应用隔离,白名单等\n路由规则确定一个服务调用的目标服务器.它有两种路由规则：条件路由规则和脚本路由规则。同时也支持扩展。\n![](img/read-write.png)\n![](img/rule.png)\n\nRouter相关类图如下：\n![](img/router.jpg)\n\n在AbstractDirectory抽象类的list方法，以及RegistryDirectory类的route方法中将会调用Router类的route方法筛选invoker列表。\n```java\n//AbstractDirectory抽象类的list方法\n@Override\npublic List<Invoker<T>> list(Invocation invocation) throws RpcException {\n\tif (destroyed) {\n\t    throw new RpcException(\"Directory already destroyed .url: \" + getUrl());\n\t}\n\t//根据invocation获取invokers列表(根据方法名查询缓存methodInvokerMap)\n\tList<Invoker<T>> invokers = doList(invocation);\n\tList<Router> localRouters = this.routers;\n\tif (localRouters != null && !localRouters.isEmpty()) {\n\t    //遍历路由\n\t    for (Router router : localRouters) {\n\t\ttry {\n\t\t    if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) {\n\t\t\t//如果url的runtime配置为true,则每次都会进行route\n\t\t\t//执行路由，进行过滤\n\t\t\tinvokers = router.route(invokers, getConsumerUrl(), invocation);\n\t\t    }\n\t\t} catch (Throwable t) {\n\t\t    logger.error(\"Failed to execute router: \" + getUrl() + \", cause: \" + t.getMessage(), t);\n\t\t}\n\t    }\n\t}\n\treturn invokers;\n}\n\n//RegistryDirectory类的route方法中\nprivate List<Invoker<T>> route(List<Invoker<T>> invokers, String method) {\n\t//创建Invocation对象\n\tInvocation invocation = new RpcInvocation(method, new Class<?>[0], new Object[0]);\n\t//获取路由列表\n\tList<Router> routers = getRouters();\n\tif (routers != null) {\n\t    for (Router router : routers) {\n\t\tif (router.getUrl() != null) {\n\t\t    //执行路由\n\t\t    invokers = router.route(invokers, getConsumerUrl(), invocation);\n\t\t}\n\t    }\n\t}\n\treturn invokers;\n}\n```\n\n### Router接口\n```java\npublic interface Router extends Comparable<Router> {\n\n    /**\n     * 获取路由url\n     * @return url\n     */\n    URL getUrl();\n\n    /**\n     * 执行路由\n     * @param invokers\n     * @param url  refer url\n     * @param invocation\n     * @return routed invokers\n     */\n    <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException;\n}\n```\n#### ConditionRouter实现类\nConditionRouter：基于条件表达式的路由规则，它的条件规则如下：\n* => 之前的为消费者匹配条件，所有参数和消费者的 URL 进行对比，当消费者满足匹配条件时，对该消费者执行后面的过滤规则。\n* => 之后为提供者地址列表的过滤条件，所有参数和提供者的 URL 进行对比，消费者最终只拿到过滤后的地址列表。\n* 如果匹配条件为空，表示对所有消费方应用，如：=> host != 10.20.153.11\n* 如果过滤条件为空，表示禁止访问，如：host = 10.20.153.10 =>\n```java\npublic class ConditionRouter implements Router, Comparable<Router> {\n\n    private static final Logger logger = LoggerFactory.getLogger(ConditionRouter.class);\n\n    /**\n     * 路由正则\n     */\n    private static Pattern ROUTE_PATTERN = Pattern.compile(\"([&!=,]*)\\\\s*([^&!=,\\\\s]+)\");\n    /**\n     * 路由url\n     */\n    private final URL url;\n    /**\n     * 优先级 优先级越大排得越靠前，默认为0\n     */\n    private final int priority;\n    /**\n     * 是否强制执行路由\n     */\n    private final boolean force;\n    /**\n     * <method,[list*,get*]>\n     */\n    private final Map<String, MatchPair> whenCondition;\n    /**\n     * <host,[192.168.99.60]>\n     */\n    private final Map<String, MatchPair> thenCondition;\n\n    public ConditionRouter(URL url) {\n        this.url = url;\n        //从url中获取priority参数\n        this.priority = url.getParameter(Constants.PRIORITY_KEY, 0);\n        //从url中获取force参数\n        this.force = url.getParameter(Constants.FORCE_KEY, false);\n        try {\n            //从url中获取rule参数，并解码\n            String rule = url.getParameterAndDecoded(Constants.RULE_KEY);\n            if (rule == null || rule.trim().length() == 0) {\n                //无效的路由规则\n                throw new IllegalArgumentException(\"Illegal route rule!\");\n            }\n            //从路由规则中移除consumer.和provider.\n            rule = rule.replace(\"consumer.\", \"\").replace(\"provider.\", \"\");\n            //查看路由规则中是否存在\"=>\"符号，并获取出现的位置i\n            int i = rule.indexOf(\"=>\");\n            //如果路由规则中不存在=>符号，则when为null,否则=>符号的左侧部分为when\n            String whenRule = i < 0 ? null : rule.substring(0, i).trim();\n            //如果路由规则中不存在=>符号，则整个路由规则都是then，否则=>符号右侧部分为then\n            String thenRule = i < 0 ? rule.trim() : rule.substring(i + 2).trim();\n            //解析规则\n            Map<String, MatchPair> when = StringUtils.isBlank(whenRule) || \"true\".equals(whenRule) ? new HashMap<String, MatchPair>() : parseRule(whenRule);\n            Map<String, MatchPair> then = StringUtils.isBlank(thenRule) || \"false\".equals(thenRule) ? null : parseRule(thenRule);\n            // NOTE: It should be determined on the business level whether the `When condition` can be empty or not.\n            //提示：应该在业务层面搞定`When condition` 是否可以为empty 或者not empty\n            this.whenCondition = when;\n            this.thenCondition = then;\n        } catch (ParseException e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    /**\n     * 解析规则\n     * @param rule\n     * @return\n     * @throws ParseException\n     */\n    private static Map<String, MatchPair> parseRule(String rule) throws ParseException {\n        Map<String, MatchPair> condition = new HashMap<String, MatchPair>();\n        if (StringUtils.isBlank(rule)) {\n            //路由规则为空，则直接返回\n            return condition;\n        }\n        //kv对，存储匹配和不匹配的条件\n        MatchPair pair = null;\n        // 多个值 \n        Set<String> values = null;\n        //使用正则进行匹配 method = find*,list*,get*,is*\n        final Matcher matcher = ROUTE_PATTERN.matcher(rule);\n        //尝试逐一匹配\n        while (matcher.find()) {\n            String separator = matcher.group(1);\n            String content = matcher.group(2);\n            //条件表达式的开始部分\n            if (separator == null || separator.length() == 0) {\n                pair = new MatchPair();\n                condition.put(content, pair);\n            }\n            //条件表达式的KV部分\n            else if (\"&\".equals(separator)) {\n                if (condition.get(content) == null) {\n                    pair = new MatchPair();\n                    condition.put(content, pair);\n                } else {\n                    pair = condition.get(content);\n                }\n            }\n            //KV部分的值\n            else if (\"=\".equals(separator)) {\n                if (pair == null) {\n                    throw new ParseException(\"Illegal route rule \\\"\"\n                            + rule + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\", matcher.start());\n                }\n                values = pair.matches;\n                values.add(content);\n            }\n            else if (\"!=\".equals(separator)) {\n                if (pair == null) {\n                    throw new ParseException(\"Illegal route rule \\\"\"\n                            + rule + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\", matcher.start());\n                }\n                values = pair.mismatches;\n                values.add(content);\n            }\n            // kv的value部分，其中value有多个值，使用逗号分隔\n            else if (\",\".equals(separator)) { // Should be seperateed by ','\n                if (values == null || values.isEmpty()) {\n                    throw new ParseException(\"Illegal route rule \\\"\"\n                            + rule + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\", matcher.start());\n                }\n                values.add(content);\n            } else {\n                throw new ParseException(\"Illegal route rule \\\"\" + rule\n                        + \"\\\", The error char '\" + separator + \"' at index \"\n                        + matcher.start() + \" before \\\"\" + content + \"\\\".\", matcher.start());\n            }\n        }\n        return condition;\n    }\n\n    @Override\n    public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation)\n            throws RpcException {\n        if (invokers == null || invokers.isEmpty()) {\n            return invokers;\n        }\n        try {\n            if (!matchWhen(url, invocation)) {\n\t        //不匹配when规则，直接返回\n                return invokers;\n            }\n            List<Invoker<T>> result = new ArrayList<Invoker<T>>();\n            if (thenCondition == null) {\n\t        //当前消费者在服务黑名单里\n                logger.warn(\"The current consumer in the service blacklist. consumer: \" + NetUtils.getLocalHost() + \", service: \" + url.getServiceKey());\n                return result;\n            }\n            for (Invoker<T> invoker : invokers) {\n                if (matchThen(invoker.getUrl(), url)) {\n\t\t    //成功匹配then规则，添加到结果集\n                    result.add(invoker);\n                }\n            }\n            if (!result.isEmpty()) {\n                return result;\n            } else if (force) { \n\t        //强制执行 \n                logger.warn(\"The route result is empty and force execute. consumer: \" + NetUtils.getLocalHost() + \", service: \" + url.getServiceKey() + \", router: \" + url.getParameterAndDecoded(Constants.RULE_KEY));\n                return result;\n            }\n        } catch (Throwable t) {\n            logger.error(\"Failed to execute condition router rule: \" + getUrl() + \", invokers: \" + invokers + \", cause: \" + t.getMessage(), t);\n        }\n\t//没有一个符合规则的Provider,则直接返回。5\n        return invokers;\n    }\n\n    @Override\n    public URL getUrl() {\n        return url;\n    }\n\t\n    //是否匹配when规则\n    boolean matchWhen(URL url, Invocation invocation) {\n        return whenCondition == null || whenCondition.isEmpty() || matchCondition(whenCondition, url, null, invocation);\n    }\n    \n    //url参数为invoker的url属性\n    private boolean matchThen(URL url, URL param) {\n        //then规则不为空，且匹配then规则，则返回true\n        return !(thenCondition == null || thenCondition.isEmpty()) && matchCondition(thenCondition, url, param, null);\n    }\n\n    /**\n     * 匹配条件\n     * @param condition\n     * @param url\n     * @param param\n     * @param invocation\n     * @return\n     */\n    private boolean matchCondition(Map<String, MatchPair> condition, URL url, URL param, Invocation invocation) {\n        //获取url参数，即消费者的parameters的Map集合\n\tMap<String, String> sample = url.toMap();\n        boolean result = false;\n        for (Map.Entry<String, MatchPair> matchPair : condition.entrySet()) {\n            //例如：method，或者url中的某个参数\n\t    String key = matchPair.getKey();\n            String sampleValue;\n            if (invocation != null && (Constants.METHOD_KEY.equals(key) || Constants.METHODS_KEY.equals(key))) {\n                //key=method，则从invocation中获取真实方法名\n\t\tsampleValue = invocation.getMethodName();\n            } else {\n\t        //从url参数中获取key对应的值\n                sampleValue = sample.get(key);\n                if (sampleValue == null) {\n\t\t    //添加前缀default.进行获取\n                    sampleValue = sample.get(Constants.DEFAULT_KEY_PREFIX + key);\n                }\n            }\n            if (sampleValue != null) {\n\t        //调用MatchPair的isMatch方法进行匹配\n                if (!matchPair.getValue().isMatch(sampleValue, param)) {\n                    return false;\n                } else {\n                    result = true;\n                }\n            } else {\n                if (!matchPair.getValue().matches.isEmpty()) {\n                    return false;\n                } else {\n                    result = true;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * 内部类\n     */\n    private static final class MatchPair {\n        final Set<String> matches = new HashSet<String>();\n        final Set<String> mismatches = new HashSet<String>();\n    \n        //value为调用的方法名，或者为url自定义参数的值\n\t//param参数为route方法的url参数，即ref url\n        private boolean isMatch(String value, URL param) {\n            if (!matches.isEmpty() && mismatches.isEmpty()) {\n                //存在=，不存在!=\n                for (String match : matches) {\n                    //进行匹配\n                    if (UrlUtils.isMatchGlobPattern(match, value, param)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            if (!mismatches.isEmpty() && matches.isEmpty()) {\n                //存在!=,不存在=\n                for (String mismatch : mismatches) {\n                    if (UrlUtils.isMatchGlobPattern(mismatch, value, param)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            if (!matches.isEmpty() && !mismatches.isEmpty()) {\n                //存在=，也存在!=,优先使用!=\n                for (String mismatch : mismatches) {\n                    if (UrlUtils.isMatchGlobPattern(mismatch, value, param)) {\n                        return false;\n                    }\n                }\n                for (String match : matches) {\n                    if (UrlUtils.isMatchGlobPattern(match, value, param)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            return false;\n        }\n    }\n}\n\n//param参数为route方法的url参数\npublic static boolean isMatchGlobPattern(String pattern, String value, URL param) {\n\tif (param != null && pattern.startsWith(\"$\")) {\n\t    pattern = param.getRawParameter(pattern.substring(1));\n\t}\n\treturn isMatchGlobPattern(pattern, value);\n}\n\npublic static boolean isMatchGlobPattern(String pattern, String value) {\n\tif (\"*\".equals(pattern)) {\n\t    return true;\n\t}\n\tif ((pattern == null || pattern.length() == 0) && (value == null || value.length() == 0)) {\n\t    return true;\n\t}\n\tif ((pattern == null || pattern.length() == 0) || (value == null || value.length() == 0)) {\n\t    return false;\n\t}\n        //获取*号最后出现的位置\n\tint i = pattern.lastIndexOf('*');\n\t// 没有 \"*\"\n\tif (i == -1) {\n\t    return value.equals(pattern);\n\t}\n\t// \"*\" 为最后\n\telse if (i == pattern.length() - 1) {\n\t    return value.startsWith(pattern.substring(0, i));\n\t}\n\t// \"*\" 在开始处\n\telse if (i == 0) {\n\t    return value.endsWith(pattern.substring(i + 1));\n\t}\n\t// \"*\" 在中间\n\telse {\n\t    String prefix = pattern.substring(0, i);\n\t    String suffix = pattern.substring(i + 1);\n\t    return value.startsWith(prefix) && value.endsWith(suffix);\n\t}\n}\n```\n\n##### 调试parseRule方法\n我们使用一个例子来debug下parseRule方法\n```java\npublic static void main(String[] args) throws ParseException {\n        //我们定义一个规则：method = find*,list*,get*,is* => host = 192.168.99.60,192.168.99.61\n\tString rule = \"method = find*,list*,get*,is* => host = 192.168.99.60,192.168.99.61\";\n\t\n\trule = rule.replace(\"consumer.\", \"\").replace(\"provider.\", \"\");\n\t\n\t//查看路由规则中是否存在\"=>\"符号，并获取出现的位置i\n\tint i = rule.indexOf(\"=>\");\n\tString whenRule = i < 0 ? null : rule.substring(0, i).trim();\n\t\n\t//如果路由规则中不存在=>符号，则整个路由规则都是then，否则=>符号右侧部分为then\n\tString thenRule = i < 0 ? rule.trim() : rule.substring(i + 2).trim();\n\t\n\t//解析规则\n\tMap<String, MatchPair> when = StringUtils.isBlank(whenRule) || \"true\".equals(whenRule) ? new HashMap<String, MatchPair>() : parseRule(whenRule);\n\tMap<String, MatchPair> then = StringUtils.isBlank(thenRule) || \"false\".equals(thenRule) ? null : parseRule(thenRule);\n}\n\n//parseRule方法部分源码\nMap<String, MatchPair> condition = new HashMap<String, MatchPair>();\nfinal Matcher matcher = ROUTE_PATTERN.matcher(rule);\n//尝试逐一匹配\nwhile (matcher.find()) {\n    String separator = matcher.group(1);\n    String content = matcher.group(2);\n}\n```\n当解析when规则的时候，在while循环中将会依次解析出如下值(第二个分割线以下的内容是解析then时的结果)：\n```java\nseparator   content\n------------------------------------\n    \"\"      method(第一次遍历)\n    =\t    find*\n    ,       list*\n    ,       get*\n    ,       is*\n------------------------------------\n    \"\"\t    host\n    =       192.168.99.60\n    ,       192.168.99.61\n```\n其中第一次遍历时，separator为空，content为method，此时将会新建一个MatchPair对象，然后放入到condition哈希中，后面的遍历将会按照separator值的不同进入到不同的分支，然后把content值加入到MatchPair对象的matches集合中(separator为=号则放入matches集合,为!=则放入mismatches集合中)。\n```java\nif (separator == null || separator.length() == 0) {\n\tpair = new MatchPair();\n\tcondition.put(content, pair);\n}\n```\n解析then规则的过程类似，这里就不介绍了。\n\n\n#### ScriptRouter实现类\n![](img/ScriptRouter.png)\n```java\npublic class ScriptRouter implements Router {\n\n    /**\n     * <脚本类型，脚本引擎>\n     */\n    private static final Map<String, ScriptEngine> engines = new ConcurrentHashMap<String, ScriptEngine>();\n\n    /**\n     * 当前使用的脚本引擎\n     */\n    private final ScriptEngine engine;\n\n    /**\n     * 优先级\n     */\n    private final int priority;\n    /**\n     * 路由规则\n     */\n    private final String rule;\n\n    /**\n     * 路由url\n     */\n    private final URL url;\n\n    public ScriptRouter(URL url) {\n        this.url = url;\n        //获取url的type参数，标识脚本类型，如：js、groovy\n        String type = url.getParameter(Constants.TYPE_KEY);\n        //获取url的priority参数，标识优先级\n        this.priority = url.getParameter(Constants.PRIORITY_KEY, 0);\n        //获取url的rule参数，标识脚本规则\n        String rule = url.getParameterAndDecoded(Constants.RULE_KEY);\n        if (type == null || type.length() == 0) {\n            //默认脚本类型，javascript\n            type = Constants.DEFAULT_SCRIPT_TYPE_KEY;\n        }\n        if (rule == null || rule.length() == 0) {\n            //路由规则不可以为空\n            throw new IllegalStateException(new IllegalStateException(\"route rule can not be empty. rule:\" + rule));\n        }\n        //根据脚本类型,从缓存中获取脚本引擎\n        ScriptEngine engine = engines.get(type);\n        if (engine == null) {\n            //根据脚本类型type创建一个脚本引擎\n            engine = new ScriptEngineManager().getEngineByName(type);\n            if (engine == null) {\n                throw new IllegalStateException(new IllegalStateException(\"Unsupported route rule type: \" + type + \", rule: \" + rule));\n            }\n            //放入缓存\n            engines.put(type, engine);\n        }\n        this.engine = engine;\n        this.rule = rule;\n    }\n\n    @Override\n    public URL getUrl() {\n        return url;\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {\n        try {\n            List<Invoker<T>> invokersCopy = new ArrayList<Invoker<T>>(invokers);\n            Compilable compilable = (Compilable) engine;\n            //将参数传递到脚本引擎\n            Bindings bindings = engine.createBindings();\n            bindings.put(\"invokers\", invokersCopy);\n            bindings.put(\"invocation\", invocation);\n            bindings.put(\"context\", RpcContext.getContext());\n            //编译规则脚本\n            CompiledScript function = compilable.compile(rule);\n            //执行脚本，返回筛选后的invokers列表\n            Object obj = function.eval(bindings);\n            if (obj instanceof Invoker[]) {\n                invokersCopy = Arrays.asList((Invoker<T>[]) obj);\n            } else if (obj instanceof Object[]) {\n                invokersCopy = new ArrayList<Invoker<T>>();\n                for (Object inv : (Object[]) obj) {\n                    invokersCopy.add((Invoker<T>) inv);\n                }\n            } else {\n                invokersCopy = (List<Invoker<T>>) obj;\n            }\n            return invokersCopy;\n        } catch (ScriptException e) {\n            //fail then ignore rule .invokers.\n            logger.error(\"route error , rule has been ignored. rule: \" + rule + \", method:\" + invocation.getMethodName() + \", url: \" + RpcContext.getContext().getUrl(), e);\n            return invokers;\n        }\n    }\n}\n```\n\n#### MockInvokersSelector实现类\nMockInvokersSelector：其实就是用于路由 Mock 服务与非Mock服务。\nDubbo默认会在AbstractDirectory#setRouters方法中自动添加MockInvokersSelector路由规则。\n```java\npublic class MockInvokersSelector implements Router{\n\n    @Override\n    public <T> List<Invoker<T>> route(final List<Invoker<T>> invokers,URL url, final Invocation invocation) throws RpcException {\n        if (invocation.getAttachments() == null) {\n            //附加参数为空\n            //返回不支持mock协议的invoker\n            return getNormalInvokers(invokers);\n        } else {\n            //从附加参数中获取invocation.need.mock属性的值\n            String value = invocation.getAttachments().get(Constants.INVOCATION_NEED_MOCK);\n            if (value == null) {\n                //返回不支持mock协议的invoker\n                return getNormalInvokers(invokers);\n            } else if (Boolean.TRUE.toString().equalsIgnoreCase(value)) {\n                //如果invocation.need.mock = true,则返回mock-Invokers\n                return getMockedInvokers(invokers);\n            }\n        }\n        return invokers;\n    }\n    ....省略其他方法....\n}\n\npublic abstract class AbstractDirectory<T> implements Directory<T> {\n    \n    /**\n     * 设置路由\n     * 1、添加：收到notify通知的routers、当前url的router参数、new MockInvokersSelector()\n     * 2、将routers排序\n     * 3、缓存routers\n     * @param routers 收到notify通知的routers\n     */\n    protected void setRouters(List<Router> routers) {\n        routers = routers == null ? new ArrayList<Router>() : new ArrayList<Router>(routers);\n        //获取路由器工厂扩展名称，router参数\n        String routerkey = url.getParameter(Constants.ROUTER_KEY);\n        if (routerkey != null && routerkey.length() > 0) {\n            //根据路由器工厂扩展名获取扩展实例\n            RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getExtension(routerkey);\n            //根据url获取路由器实例，并放入routers\n            routers.add(routerFactory.getRouter(url));\n        }\n        //添加支持mock协议的invoker选择器\n        routers.add(new MockInvokersSelector());\n        //排序\n        Collections.sort(routers);\n        this.routers = routers;\n    }\n    ....省略其他方法....\n}\n \n```\n\n#### 自定义Router\n假如我们的服务提供者分为多个不同的组，我们想要根据某个调用参数调用不同的组。\n我们可以自定义一个CustomRouter类，然后实现route方法。\n\n```java\npublic class CustomRouter extends ConditionRouter{\n\n    @Override\n    public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation)throws RpcException {\n        if (invokers == null || invokers.isEmpty()) {\n            return invokers;\n        }\n\t//获取调用参数\n\tObject[] arguments = invocation.getArguments();\n        if(arguments == null || arguments.length == 0){\n            logger.error(\"方法: {} 缺少路由参数routeKey\",invocation.getMethodName());\n            return null;\n        }\n\t//获取路由key\n        Object routeKey = arguments[0];\n\tString consumerGroup = getGroup(routeKey);\n\t//String consumerGroup = url.getParameter(Constants.GROUP_KEY);\n\n        List<Invoker<T>> result = new ArrayList<Invoker<T>>();\n\tfor (Invoker<T> invoker : invokers) {\n\t    //获取服务提供者的group参数\n            String group = invoker.getUrl().getParameter(Constants.GROUP_KEY);\n            \n\t    //判断当前服务提供者的group是否和当前调用参数中的group是否匹配\n\t    if (consumerGroup.equals(group)) {\n\t        //匹配的话，则保存当前服务提供者\n                result.add(invoker);\n            }\n        }\n\tif(result.size() > 0){\n\t   //返回匹配的服务提供者组\n\t   return result;\n\t}\n        return invokers;\n    }\n    \n    /**\n     * 获取group\n     */\n    private String getGroup(String routeKey){\n\tif(routeKey.endsWith(\"1\")){\n\t   return \"v1\";\n\t}else{\n\t   return \"v2\";\n\t}\n    }\n}\n\n/**\n * 工厂\n */\npublic class CustomRouterFactory implements RouterFactory {\n\n    public static final String NAME = \"custom\";\n\n    @Override\n    public Router getRouter(URL url) {\n        return new CustomRouter(url);\n    }\n\n}\n```\n\n然后我们配置扩展，让dubbo可以自动发现。\n```java\ncustom=com.alibaba.dubbo.rpc.cluster.router.custom.CustomRouterFactory\n```\n\n然后配置路由规则，例如可以在RegistryProtocol类的register方法中加入添加路由规则进行断点测试。\n```java\npublic void register(URL registryUrl, URL registedProviderUrl) {\n        //获取注册中心\n\tRegistry registry = registryFactory.getRegistry(registryUrl);\n\t//注册服务提供者\n\tregistry.register(registedProviderUrl);\n\t\n\t//测试代码(添加路由规则),group=foo标识对指定的foo组生效\n\t#URL routerUrl = URL.valueOf(\"routers://0.0.0.0/com.alibaba.dubbo.demo.DemoService?name=test&category=routers&router=custom&dynamic=false&version=1.0&group=foo\");\n\tURL routerUrl = URL.valueOf(\"routers://0.0.0.0/com.alibaba.dubbo.demo.DemoService?name=test&category=routers&router=custom&dynamic=false\");\n\tregistry.register(routerUrl);\n}\n```\n\n最后模拟消费者调用进行测试即可。\n\n\n\n\n\n\n\n\n\n\n\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之服务引用","url":"/blog/2018/08/23/Dubbo源码阅读之服务引用/","content":">本小节讲解上小节遗留的ref = createProxy(map)方法，不了解的可以先看下上篇文章《Dubbo源码阅读之集成Spring-0202注解解析》\n\n该方法定义在ReferenceConfig类中，在调用init方法进行初始化时，会调用createProxy方法来生成代理对象。\n\n### createProxy创建代理\n```java\n/**\n * 创建代理\n */\nprivate T createProxy(Map<String, String> map) {\n\tURL tmpUrl = new URL(\"temp\", \"localhost\", 0, map);\n\tfinal boolean isJvmRefer;\n\t//是否引用本地服务，新版使用： scope=local来判断\n\tif (isInjvm() == null) {\n\t    if (url != null && url.length() > 0) {\n\t\t//如果配置中指定了url属性，则不使用本地引用\n\t\tisJvmRefer = false;\n\t    } else if (InjvmProtocol.getInjvmProtocol().isInjvmRefer(tmpUrl)) {\n\t\t//默认情况下，如果有本地服务，则引用本地服务\n\t\tisJvmRefer = true;\n\t    } else {\n\t\tisJvmRefer = false;\n\t    }\n\t} else {\n\t    isJvmRefer = isInjvm().booleanValue();\n\t}\n\tif (isJvmRefer) {\n\t    //构建本地协议\n\t    URL url = new URL(Constants.LOCAL_PROTOCOL, NetUtils.LOCALHOST, 0, interfaceClass.getName()).addParameters(map);\n\t    //引用本地服务(后面会分析该方法)\n\t    invoker = refprotocol.refer(interfaceClass, url);\n\t    if (logger.isInfoEnabled()) {\n\t\tlogger.info(\"Using injvm service \" + interfaceClass.getName());\n\t    }\n\t} else {\n\t    if (url != null && url.length() > 0) {\n\t\t//用户指定了URL属性，可以是p2p地址或者注册中心的地址，多个地址使用\";\"分隔\n\t\tString[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);\n\t\tif (us != null && us.length > 0) {\n\t\t    for (String u : us) {\n\t\t\tURL url = URL.valueOf(u);\n\t\t\tif (url.getPath() == null || url.getPath().length() == 0) {\n\t\t\t    //path为空时，使用服务接口名称作为path\n\t\t\t    url = url.setPath(interfaceName);\n\t\t\t}\n\t\t\tif (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n\t\t\t    //注册中心协议，添加引用标识refer参数\n\t\t\t    urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));\n\t\t\t} else {\n\t\t\t    //p2p地址(后面会分析该方法)\n\t\t\t    urls.add(ClusterUtils.mergeUrl(url, map));\n\t\t\t}\n\t\t    }\n\t\t}\n\t    } else {\n\t\t//从注册中心配置中组装URL(后面会分析该方法)\n\t\tList<URL> us = loadRegistries(false);\n\t\tif (us != null && !us.isEmpty()) {\n\t\t    //遍历注册中心us(后面会分析该方法)\n\t\t    for (URL u : us) {\n\t\t\t//加载监控url(后面会分析该方法)\n\t\t\tURL monitorUrl = loadMonitor(u);\n\t\t\tif (monitorUrl != null) {\n\t\t\t    //添加monitor参数\n\t\t\t    map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));\n\t\t\t}\n\t\t\t//添加refer参数\n\t\t\turls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));\n\t\t    }\n\t\t}\n\t\tif (urls == null || urls.isEmpty()) {\n\t\t    //在消费者端，没有配置注册中心，因此无法引用相应服务接口\n\t\t    throw new IllegalStateException(\"No such any registry to reference \" + interfaceName + \" on the consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion() + \", please config <dubbo:registry address=\\\"...\\\" /> to your spring config.\");\n\t\t}\n\t    }\n\t    if (urls.size() == 1) {\n\t\t//引用一个远程服务(后面会分析该方法)\n\t\t//registry://172.172.172.47:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&dubbo=2.0.0&pid=1172&qos.port=33333&refer=application%3Ddemo-consumer%26check%3Dfalse%26dubbo%3D2.0.0%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D1172%26qos.port%3D33333%26register.ip%3D192.168.99.60%26side%3Dconsumer%26timestamp%3D1535094943004&registry=zookeeper&timestamp=1535095022853\n\t\tinvoker = refprotocol.refer(interfaceClass, urls.get(0));\n\t    } else {\n\t\t//如果有多个url\n\t\tList<Invoker<?>> invokers = new ArrayList<Invoker<?>>();\n\t\tURL registryURL = null;\n\t\tfor (URL url : urls) {\n\t\t    //记录\"远程引用\"\n\t\t    invokers.add(refprotocol.refer(interfaceClass, url));\n\t\t    if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n\t\t\t//使用最后一个注册中心url\n\t\t\tregistryURL = url;\n\t\t    }\n\t\t}\n\t\tif (registryURL != null) {\n\t\t    //有注册中心协议的URL，使用AvailableCluster\n\t\t    URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);\n\t\t    invoker = cluster.join(new StaticDirectory(u, invokers));\n\t\t} else { \n\t\t    //不是注册中心的url\n\t\t    invoker = cluster.join(new StaticDirectory(invokers));\n\t\t}\n\t    }\n\t}\n\t//检测服务提供者是否存在\n\tBoolean c = check;\n\tif (c == null && consumer != null) {\n\t    c = consumer.isCheck();\n\t}\n\tif (c == null) {\n\t    //默认需要检测服务提供者是否存在\n\t    c = true;\n\t}\n\t//检测服务提供者是否存在\n\tif (c && !invoker.isAvailable()) {\n\t    throw new IllegalStateException(\"Failed to check the status of the service \" + interfaceName + \". No provider available for the service \" + (group == null ? \"\" : group + \"/\") + interfaceName + (version == null ? \"\" : \":\" + version) + \" from the url \" + invoker.getUrl() + \" to the consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion());\n\t}\n\tif (logger.isInfoEnabled()) {\n\t    logger.info(\"Refer dubbo service \" + interfaceClass.getName() + \" from url \" + invoker.getUrl());\n\t}\n\t//创建服务代理\n\treturn (T) proxyFactory.getProxy(invoker);\n}\n\n/**\n * 构造注册中心URL\n * @param provider\n * @return\n */\nprotected List<URL> loadRegistries(boolean provider) {\n\t//检测是否配置了RegistryConfig，并配置\n\tcheckRegistry();\n\tList<URL> registryList = new ArrayList<URL>();\n\tif (registries != null && !registries.isEmpty()) {\n\t    //遍历注册中心配置\n\t    for (RegistryConfig config : registries) {\n\t\t//获取当前注册中心地址，例如： zookeeper://172.172.172.47:2181\n\t\tString address = config.getAddress();\n\t\tif (address == null || address.length() == 0) {\n\t\t    //设置address = 0.0.0.0\n\t\t    address = Constants.ANYHOST_VALUE;\n\t\t}\n\t\t//从系统配置中获取注册中心地址\n\t\tString sysaddress = System.getProperty(\"dubbo.registry.address\");\n\t\tif (sysaddress != null && sysaddress.length() > 0) {\n\t\t    //如果系统配置的注册中心地址不为空，则优先使用系统配置\n\t\t    address = sysaddress;\n\t\t}\n\t\tif (address != null && address.length() > 0\n\t\t\t&& !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) {\n\t\t    //注册中心地址可用\n\t\t    Map<String, String> map = new HashMap<String, String>();\n\t\t    //附加参数，即找到application、config类中的属性，并添加进来\n\t\t    appendParameters(map, application);\n\t\t    appendParameters(map, config);\n\t\t    map.put(\"path\", RegistryService.class.getName());\n\t\t    map.put(\"dubbo\", Version.getVersion());\n\t\t    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n\t\t    if (ConfigUtils.getPid() > 0) {\n\t\t\tmap.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n\t\t    }\n\t\t    if (!map.containsKey(\"protocol\")) {\n\t\t\t//添加protocol参数\n\t\t\tif (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension(\"remote\")) {\n\t\t\t    map.put(\"protocol\", \"remote\");\n\t\t\t} else {\n\t\t\t    map.put(\"protocol\", \"dubbo\");\n\t\t\t}\n\t\t    }\n\t\t    //根据address和map生成注册中心url\n\t\t    List<URL> urls = UrlUtils.parseURLs(address, map);\n\t\t    \n\t\t    //遍历注册中心url，添加registry参数,并设置protocol属性，然后保存起来\n\t\t    for (URL url : urls) {\n\t\t\t//url = zookeeper://172.172.172.47:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&dubbo=2.0.0&pid=1172&qos.port=33333&timestamp=1535095022853\n\t\t\t//添加registry参数 = zookeeper\n\t\t\turl = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());\n\t\t\t\n\t\t\t//重新设置协议为registry\n\t\t\turl = url.setProtocol(Constants.REGISTRY_PROTOCOL);\n\t\t\tif ((provider && url.getParameter(Constants.REGISTER_KEY, true))\n\t\t\t\t|| (!provider && url.getParameter(Constants.SUBSCRIBE_KEY, true))) {\n\t\t\t    //registry://172.172.172.47:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&dubbo=2.0.0&pid=1172&qos.port=33333&registry=zookeeper&timestamp=1535095022853\n\t\t\t    registryList.add(url);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\treturn registryList;\n}\n\n/**\n * 检测RegistryConfig配置\n */\nprotected void checkRegistry() {\n\t//向后兼容\n\tif (registries == null || registries.isEmpty()) {\n\t    //获取到注册中心属性配置值\n\t    String address = ConfigUtils.getProperty(\"dubbo.registry.address\");\n\t    if (address != null && address.length() > 0) {\n\t\tregistries = new ArrayList<RegistryConfig>();\n\t\t//使用\"|\"分隔注册中心，然后构造RegistryConfig对象\n\t\tString[] as = address.split(\"\\\\s*[|]+\\\\s*\");\n\t\tfor (String a : as) {\n\t\t    RegistryConfig registryConfig = new RegistryConfig();\n\t\t    registryConfig.setAddress(a);\n\t\t    registries.add(registryConfig);\n\t\t}\n\t    }\n\t}\n\tif ((registries == null || registries.isEmpty())) {\n\t    throw new IllegalStateException((getClass().getSimpleName().startsWith(\"Reference\")\n\t\t    ? \"No such any registry to refer service in consumer \"\n\t\t    : \"No such any registry to export service in provider \")\n\t\t    + NetUtils.getLocalHost()\n\t\t    + \" use dubbo version \"\n\t\t    + Version.getVersion()\n\t\t    + \", Please add <dubbo:registry address=\\\"...\\\" /> to your spring config. If you want unregister, please set <dubbo:service registry=\\\"N/A\\\" />\");\n\t}\n\tfor (RegistryConfig registryConfig : registries) {\n\t    //添加属性\n\t    appendProperties(registryConfig);\n\t}\n}\n```\n\n接下来我们看下Protocol的refer方法，在《Dubbo源码阅读之服务暴露》小节我们介绍过，将会生成Protocol$Adaptive类：\n```java\npublic class Protocol$Adaptive implements com.alibaba.dubbo.rpc.Protocol {\n\t/**\n\t * @param arg0 服务接口类\n\t * @param arg1 注册中心url\n\t */\n\tpublic com.alibaba.dubbo.rpc.Invoker refer(java.lang.Class arg0, com.alibaba.dubbo.common.URL arg1) throws com.alibaba.dubbo.rpc.RpcException {\n\t\tif (arg1 == null){\n\t\t\t//url参数不可以为空\n\t\t\tthrow new IllegalArgumentException(\"url == null\");\n\t\t}\n\t\t\n\t\tcom.alibaba.dubbo.common.URL url = arg1;\n\t\t\n\t\t//使用url的protocol属性值(这里为registry)，作为扩展名称，如果为空，则默认使用\"dubbo\"\n\t\tString extName = url.getProtocol() == null ? \"dubbo\" : url.getProtocol();\n\t\t\n\t\tif(extName == null) {\n\t\t\tthrow new IllegalStateException(\"Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(\" + url.toString() + \") use keys([protocol])\");\n\t\t}\n\t\t\n\t\t//获取扩展名称为extName的Protocol扩展实例(这里可能是被包装过的类)\n\t\tcom.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);\n\t\t\n\t\t//调用该extension实例的refer方法\n\t\treturn extension.refer(arg0, arg1);\n\t}\n}\n```\n这里和服务暴露时的流程一样，将会调用两个包装类ProtocolFilterWrapper和ProtocolListenerWrapper的refer方法。\n```java\npublic class ProtocolFilterWrapper implements Protocol {\n\t@Override\n\tpublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n\t\tif (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n\t\t    //这里将会调用ProtocolListenerWrapper类的refer方法\n\t\t    return protocol.refer(type, url);\n\t\t}\n\t\treturn buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);\n\t}\n}\n\npublic class ProtocolListenerWrapper implements Protocol {\n\t/**\n\t * @param type interface com.alibaba.dubbo.demo.DemoService\n\t * @param url  registry://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&dubbo=2.0.0&pid=1512&qos.port=33333&refer=application%3Ddemo-consumer%26check%3Dfalse%26dubbo%3D2.0.0%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D1512%26qos.port%3D33333%26register.ip%3D192.168.99.60%26side%3Dconsumer%26timestamp%3D1528340394760&registry=multicast&timestamp=1528340417091\n\t * @param <T>\n\t * @return\n\t * @throws RpcException\n\t */\n\t@Override\n\tpublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n\t\tif (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n\t\t    //这里将会调用RegistryProtocol类的refer方法\n\t\t    return protocol.refer(type, url);\n\t\t}\n\t\treturn new ListenerInvokerWrapper<T>(protocol.refer(type, url),\n\t\t\tCollections.unmodifiableList(\n\t\t\t\tExtensionLoader.getExtensionLoader(InvokerListener.class)\n\t\t\t\t\t.getActivateExtension(url, Constants.INVOKER_LISTENER_KEY)));\n\t}\n}\n```\nRegistryProtocol的refer方法：\n```java\n/**\n * @param type远程服务接口类型\n * @param url 远程服务的URL地址\n * registry://172.172.172.47:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&dubbo=2.0.0&pid=1172&qos.port=33333&refer=application%3Ddemo-consumer%26check%3Dfalse%26dubbo%3D2.0.0%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D1172%26qos.port%3D33333%26register.ip%3D192.168.99.60%26side%3Dconsumer%26timestamp%3D1535094943004&registry=zookeeper&timestamp=1535095022853\n * @return\n * @throws RpcException\n */\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n\t//生成注册中心url\n\turl = url.setProtocol(\n\t\t//设置协议，从url中的registry参数中获取注册时的协议(zookeeper)，没有获取到的话，则默认为dubbo协议\n\t\turl.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_REGISTRY)\n\t\t//然后移除registry参数\n\t).removeParameter(Constants.REGISTRY_KEY);\n\n\t//根据url获取注册中心\n\t//zookeeper://172.172.172.47:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&dubbo=2.0.0&pid=1172&qos.port=33333&refer=application%3Ddemo-consumer%26check%3Dfalse%26dubbo%3D2.0.0%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D1172%26qos.port%3D33333%26register.ip%3D192.168.99.60%26side%3Dconsumer%26timestamp%3D1535094943004&timestamp=1535095022853\n\tRegistry registry = registryFactory.getRegistry(url);\n\tif (RegistryService.class.equals(type)) {\n\t    return proxyFactory.getInvoker((T) registry, type, url);\n\t}\n\n\t//获取url中的refer参数，并转换成map\n\tMap<String, String> qs = StringUtils.parseQueryString(\n\t\turl.getParameterAndDecoded(Constants.REFER_KEY)\n\t);\n\t//获取map中的group参数\n\tString group = qs.get(Constants.GROUP_KEY);\n\tif (group != null && group.length() > 0) {\n\t    if ((Constants.COMMA_SPLIT_PATTERN.split(group)).length > 1\n\t\t    || \"*\".equals(group)) {\n\t\t//group=\"a,b\" or group=\"*\"\n\t\treturn doRefer(getMergeableCluster(), registry, type, url);\n\t    }\n\t}\n\treturn doRefer(cluster, registry, type, url);\n}\n\n/**\n *\n * @param cluster\n * @param registry 注册中心\n * @param type 远程服务接口类型\n * @param url 注册中心url\n * @return\n */\nprivate <T> Invoker<T> doRefer(Cluster cluster, Registry registry, Class<T> type, URL url) {\n\t//根据服务接口type和注册中心url创建RegistryDirectory对象(后面会分析该方法)\n\t//Directory代表多个Invoker,可以把它看成List<Invoker>，\n        //但与List不同的是,它的值可能是动态变化的,比如注册中心推送变更\n\tRegistryDirectory<T> directory = new RegistryDirectory<T>(type, url);\n\t//设置注册中心实例\n\tdirectory.setRegistry(registry);\n\t//设置协议\n\tdirectory.setProtocol(protocol);\n\t\n\t//refer参数指定的url的所有属性\n\tMap<String, String> parameters = new HashMap<String, String>(directory.getUrl().getParameters());\n\t\n\t//生成消费者url\n\t//consumer://192.168.99.60/com.alibaba.dubbo.demo.DemoService?application=demo-consumer&check=false&dubbo=2.0.0&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=1172&qos.port=33333&side=consumer&timestamp=1535094943004\n\tURL subscribeUrl = new URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), 0, type.getName(), parameters);\n\t\n\tif (!Constants.ANY_VALUE.equals(url.getServiceInterface())\n\t\t&& url.getParameter(Constants.REGISTER_KEY, true)) {\n\t    //注册消费者，添加category=consumers,check=false参数\n\t    registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,\n\t\t    Constants.CHECK_KEY, String.valueOf(false)));\n\t}\n\t\n\t//订阅此url\n\tdirectory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,\n\t\t//提供者 /dubbo/interfaceClass/providers\n\t\t//配置  /dubbo/interfaceClass/configurators\n\t\t//路由  /dubbo/interfaceClass/routers\n\t\tConstants.PROVIDERS_CATEGORY\n\t\t\t+ \",\" + Constants.CONFIGURATORS_CATEGORY\n\t\t\t+ \",\" + Constants.ROUTERS_CATEGORY));\n\t\n\t//Cluster将Directory中的多个Invoker伪装成一个Invoker,对上层透明,伪装过程包含了容错逻辑,调用失败后,重试另一个(后面会分析该方法)\n\tInvoker invoker = cluster.join(directory);\n\t\n\t//注册消费者\n\tProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);\n\treturn invoker;\n}\n```\n这里首先注册了消费者，然后订阅了相关目录(providers、configurations、routers)，当有相应服务提供者提供服务时，注册中心会通过notify通知到消费者，接着消费者会通过RegistryDirectory类异步更新本地缓存。\n注册消费者时，首先会调用AbstractRegistry类的register方法，将注册url保存起来，然后会调用FailbackRegistry类的register方法，在该方法中会调用doRegister方法(该方法调用失败的话，会稍后进行重试),最后会调用ZookeeperRegistry的doRegister方法，进行最终的注册。\n```java\n//ZookeeperRegistry类的doRegister方法\n@Override\nprotected void doRegister(URL url) {\n\ttry {\n\t    //执行注册 dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=5312&side=provider&timestamp=1534994264738\n\t    //根据url确定节点路径；根据url的dynamic参数确定是否是临时节点 /dubbo/com.alibaba.dubbo.demo.DemoService/providers/dubbo%3A%2F%2F192.168.99.60%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26dubbo%3D2.0.0%26generic%3Dfalse%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D5312%26side%3Dprovider%26timestamp%3D1534994264738\n\t    zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true));\n\t} catch (Throwable e) {\n\t    throw new RpcException(\"Failed to register \" + url + \" to zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e);\n\t}\n}\n```\n订阅时，会调用RegistryDirectory类的subscribe方法\n```java\npublic class RegistryDirectory<T> extends AbstractDirectory<T> implements NotifyListener {\n\n       /**\n\t* 订阅url\n\t* @param url 消费者url \n\t* consumer://192.168.99.60/com.alibaba.dubbo.demo.DemoService?application=demo-consumer&category=providers,configurators,routers&check=false&dubbo=2.0.0&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=1880&qos.port=33333&side=consumer&timestamp=1535449640995\n\t*/\n\tpublic void subscribe(URL url) {\n\t\t//设置消费者url(将url保存到AbstractDirectory父类中)\n\t\tsetConsumerUrl(url);\n\t\t\n\t\t//订阅该消费者url(this即为当前RegistryDirectory对象,它实现了NotifyListener接口)\n\t\t//首先调用AbstractRegistry的subscribe方法(保存订阅信息)\n\t\t//接着调用FailbackRegistry的subscribe方法(调用ZookeeperRegistry的doSubscribe方法，如果发生异常了会捕获到，然后保存下来稍后重试)\n\t\t//然后调用ZookeeperRegistry的doSubscribe方法(获取待通知urls，最后调用notify方法进行通知)\n\t\tregistry.subscribe(url, this);\n\t}\n}\n```\n我们简单看下ZookeeperRegistry类的doSubscribe方法，其中省略掉了一些代码\n```java\n//此listener参数就是上文创建的RegistryDirectory类\nprotected void doSubscribe(final URL url, final NotifyListener listener) {\n\tList<URL> urls = new ArrayList<URL>();\n\t//根据toCategoriesPath(url)方法获取到类别列表，然后遍历该列表\n\t//如：/dubbo/com.alibaba.dubbo.demo.DemoService/providers\n\tfor (String path : toCategoriesPath(url)) {\n\t    ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);\n\t    if (listeners == null) {\n\t\tzkListeners.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, ChildListener>());\n\t\tlisteners = zkListeners.get(url);\n\t    }\n\t    //根据dubbo的监听获取zk的监听\n\t    ChildListener zkListener = listeners.get(listener);\n\t    if (zkListener == null) {\n\t        //创建节点监听\n\t\tlisteners.putIfAbsent(listener, new ChildListener() {\n\t\t    @Override\n\t\t    public void childChanged(String parentPath, List<String> currentChilds) {\n\t\t\t//执行通知\n\t\t\tZookeeperRegistry.this.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds));\n\t\t    }\n\t\t});\n\t\tzkListener = listeners.get(listener);\n\t    }\n\t    //创建path节点,\n\t    //即：/dubbo/com.xxx.demoService/providers\n\t    //即：/dubbo/consumers  /dubbo/com.alibaba.dubbo.demo.DemoService/configurators\n\t    zkClient.create(path, false);\n\t    //为path节点添加zkListener监听(children变量即为该path节点的子节点数据)\n\t    List<String> children = zkClient.addChildListener(path, zkListener);\n\t    if (children != null) {\n\t        //节点数据(待通知列表)\n\t\t//empty://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&category=configurators&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=6504&side=provider&timestamp=1534927826842\n\t\turls.addAll(toUrlsWithEmpty(url, path, children));\n\t    }\n\t}\n\t//执行通知(urls即为待通知的消息列表)\n\tnotify(url, listener, urls);\n}\n```\n调用notify方法进行通知时,会先调用FailbackRegistry类的notify方法,内部会调用doNotify方法(调用失败的话,会保存失败信息,稍后重试)\n```java\n//FailbackRegistry类的notify\n//省略了一些不重要的代码\n@Override\nprotected void notify(URL url, NotifyListener listener, List<URL> urls) {\n\ttry {\n\t    //执行通知(将会调用父类AbstractRegistry中的notify方法)\n\t    doNotify(url, listener, urls);\n\t} catch (Exception t) {\n\t    //通知失败，添加到失败列表，定期重试\n\t    Map<NotifyListener, List<URL>> listeners = failedNotified.get(url);\n\t    if (listeners == null) {\n\t\tfailedNotified.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, List<URL>>());\n\t\tlisteners = failedNotified.get(url);\n\t    }\n\t    listeners.put(listener, urls);\n\t    logger.error(\"Failed to notify for subscribe \" + url + \", waiting for retry, cause: \" + t.getMessage(), t);\n\t}\n}\n```\n而doNotify方法最终会调用AbstractRegistry类的notify方法,在AbstractRegistry类的notify方法中,会根据category将待通知urls进行分组,然后挨个处理每一个category,并按照<订阅url服务唯一标识,空格分隔的多个待通知url>的形式，保存到本地properties文件中，最后调用RegistryDirectory类的notify方法将待通知列表categoryList下发给消费者。\n```java\n//AbstractRegistry类的notify方法\n//省略了一些不重要的代码\nprotected void notify(URL url, NotifyListener listener, List<URL> urls) {\n\t//<category,List<URL>>\n\tMap<String, List<URL>> result = new HashMap<String, List<URL>>();\n\t//遍历待通知urls，根据url中的category参数进行分组，保存到result中\n\tfor (URL u : urls) {\n\t    //url和u是否匹配(url的范围是否比u大)\n\t    if (UrlUtils.isMatch(url, u)) {\n\t\t//获取待通知url的category，默认值是providers\n\t\tString category = u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);\n\t\tList<URL> categoryList = result.get(category);\n\t\tif (categoryList == null) {\n\t\t    categoryList = new ArrayList<URL>();\n\t\t    result.put(category, categoryList);\n\t\t}\n\t\tcategoryList.add(u);\n\t    }\n\t}\n\tif (result.size() == 0) {\n\t    //类别待通知url列表为空，直接返回\n\t    return;\n\t}\n\t//下面会将notified中的url及其values.values中的URL保存到缓存文件中\n\tMap<String, List<URL>> categoryNotified = notified.get(url);\n\tif (categoryNotified == null) {\n\t    notified.putIfAbsent(url, new ConcurrentHashMap<String, List<URL>>());\n\t    categoryNotified = notified.get(url);\n\t}\n\tfor (Map.Entry<String, List<URL>> entry : result.entrySet()) {\n\t    //类别\n\t    String category = entry.getKey();\n\t    //类别待通知url列表\n\t    List<URL> categoryList = entry.getValue();\n\t    //保存<类别,类别待通知url列表>\n\t    categoryNotified.put(category, categoryList);\n\t    //保存注册中心缓存文件(将订阅url、待通知url列表保存到缓存文件)\n\t    saveProperties(url);\n\t    //触发通知给消费者(类别待通知url列表)，此listener就是RegistryDirectory类\n\t    listener.notify(categoryList);\n\t}\n}\n```\n然后我们来看RegistryDirectory类的notify方法\n```java\npublic synchronized void notify(List<URL> urls) {\n\tList<URL> invokerUrls = new ArrayList<URL>();\n\tList<URL> routerUrls = new ArrayList<URL>();\n\tList<URL> configuratorUrls = new ArrayList<URL>();\n\t//遍历待通知列表，根据category进行分组，并分别保存到上面定义的list列表中\n\tfor (URL url : urls) {\n\t    //获取url协议\n\t    String protocol = url.getProtocol();\n\t    //获取url分类\n\t    String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);\n\t    if (Constants.ROUTERS_CATEGORY.equals(category)\n\t\t    || Constants.ROUTE_PROTOCOL.equals(protocol)) {\n\t\t//添加路由url\n\t\trouterUrls.add(url);\n\t    } else if (Constants.CONFIGURATORS_CATEGORY.equals(category)\n\t\t    || Constants.OVERRIDE_PROTOCOL.equals(protocol)) {\n\t\t//添加配置url\n\t\tconfiguratorUrls.add(url);\n\t    } else if (Constants.PROVIDERS_CATEGORY.equals(category)) {\n\t\t//添加服务提供者url\n\t\tinvokerUrls.add(url);\n\t    } else {\n\t\t//不支持的分类\n\t\tlogger.warn(\"Unsupported category \" + category + \" in notified url: \" + url + \" from registry \" + getUrl().getAddress() + \" to consumer \" + NetUtils.getLocalHost());\n\t    }\n\t}\n\tif (configuratorUrls != null && !configuratorUrls.isEmpty()) {\n\t    //将url转换成Configurator类并保存(后面会分析该方法)\n\t    this.configurators = toConfigurators(configuratorUrls);\n\t}\n\tif (routerUrls != null && !routerUrls.isEmpty()) {\n\t    //将路由url转换成路由对象(后面会分析该方法)\n\t    List<Router> routers = toRouters(routerUrls);\n\t    if (routers != null) {\n\t\t//保存路由(后面会分析该方法)\n\t\tsetRouters(routers);\n\t    }\n\t}\n\tList<Configurator> localConfigurators = this.configurators;\n\t//合并override参数\n\tthis.overrideDirectoryUrl = directoryUrl;\n\tif (localConfigurators != null && !localConfigurators.isEmpty()) {\n\t    for (Configurator configurator : localConfigurators) {\n\t\t//根据configurator覆盖overrideDirectoryUrl中的属性，\n\t\t//或者将configurator中的属性添加到overrideDirectoryUrl中\n\t\tthis.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl);\n\t    }\n\t}\n\t//刷新Invoker(后面会分析该方法)\n\trefreshInvoker(invokerUrls);\n}\n\n```\n接下来，我们来挨个看下上面用到的方法\n\n#### 更新Configurator\n```java\n//将待通知url转换成Configurator\npublic static List<Configurator> toConfigurators(List<URL> urls) {\n\tif (urls == null || urls.isEmpty()) {\n\t    return Collections.emptyList();\n\t}\n\tList<Configurator> configurators = new ArrayList<Configurator>(urls.size());\n\t//遍历待通知url列表\n\tfor (URL url : urls) {\n\t    if (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) {\n\t\t//协议为empty，则清空configurators，并跳出循环\n\t\tconfigurators.clear();\n\t\tbreak;\n\t    }\n\t    //获取url所有参数\n\t    Map<String, String> override = new HashMap<String, String>(url.getParameters());\n\t    \n\t    //override的anyhost参数可以被自动添加\n\t    //它不可以改变对变化中的url的判断，因此需要移除掉anyhost参数\n\t    override.remove(Constants.ANYHOST_KEY);\n\t    if (override.size() == 0) {\n\t\tconfigurators.clear();\n\t\tcontinue;\n\t    }\n\t    //添加配置\n\t    configurators.add(configuratorFactory.getConfigurator(url));\n\t}\n\t//排序\n\tCollections.sort(configurators);\n\treturn configurators;\n}\n```\n\n#### 更新Router\n```java\n//将待通知url转换成Router对象\nprivate List<Router> toRouters(List<URL> urls) {\n\tList<Router> routers = new ArrayList<Router>();\n\tif (urls == null || urls.isEmpty()) {\n\t    return routers;\n\t}\n\tif (urls != null && !urls.isEmpty()) {\n\t    //遍历待通知url列表\n\t    for (URL url : urls) {\n\t\tif (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) {\n\t\t    //协议为empty的话，直接返回\n\t\t    continue;\n\t\t}\n\t\t//获取url的router参数，该参数标识了路由协议\n\t\tString routerType = url.getParameter(Constants.ROUTER_KEY);\n\t\tif (routerType != null && routerType.length() > 0) {\n\t\t    //设置路由协议\n\t\t    url = url.setProtocol(routerType);\n\t\t}\n\t\ttry {\n\t\t    //根据url获取路由实例\n\t\t    Router router = routerFactory.getRouter(url);\n\t\t    if (!routers.contains(router)) {\n\t\t\t//添加路由\n\t\t\trouters.add(router);\n\t\t    }\n\t\t} catch (Throwable t) {\n\t\t    logger.error(\"convert router url to router error, url: \" + url, t);\n\t\t}\n\t    }\n\t}\n\treturn routers;\n}\n\nprotected void setRouters(List<Router> routers) {\n\t//复制routers列表\n\trouters = routers == null ? new ArrayList<Router>() : new ArrayList<Router>(routers);\n\t\n\t//获取路由工厂的扩展名称\n\tString routerkey = url.getParameter(Constants.ROUTER_KEY);\n\tif (routerkey != null && routerkey.length() > 0) {\n\t    //根据 路由工厂扩展名 获取 路由工厂扩展实例\n\t    RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getExtension(routerkey);\n\t    //根据url获取路由实例，并放入routers\n\t    routers.add(routerFactory.getRouter(url));\n\t}\n\t//添加支持mock协议的invoker选择器\n\trouters.add(new MockInvokersSelector());\n\t//排序\n\tCollections.sort(routers);\n\t//保存最新的路由信息\n\tthis.routers = routers;\n}\n```\n#### 更新Invoker\n然后我们来看refreshInvoker方法\n```java\n/**\n * 将待通知invoker url转换成invoker Map，转换规则如下：\n * 1、如果url已经转换成invoker，则不再重新引用并直接从缓存中获取，并注意url中的任何参数更改都将被重新引用。\n * 2、如果传入的invoker列表不为空，则意味着这是最新的调用者列表\n * 3、如果传入的invoker列表为空，则意味着该规则只是一个override规则或者route规则，需要重新对比以决定是否需要重新引用\n */\nprivate void refreshInvoker(List<URL> invokerUrls) {\n\tif (invokerUrls != null && invokerUrls.size() == 1 && invokerUrls.get(0) != null\n\t\t&& Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) {\n\t    //empty协议\n\t    //禁止访问\n\t    this.forbidden = true;\n\t    this.methodInvokerMap = null;\n\t    //销毁所有的invokers\n\t    destroyAllInvokers();\n\t} else {\n\t    //允许访问\n\t    this.forbidden = false;\n\t    //记录当前的 urlInvokerMap\n\t    Map<String, Invoker<T>> oldUrlInvokerMap = this.urlInvokerMap;\n\t    if (invokerUrls.isEmpty() && this.cachedInvokerUrls != null) {\n\t\t//收到的invokerUrls为空，但是缓存中的不为空，则使用当前缓存中的invoker\n\t\tinvokerUrls.addAll(this.cachedInvokerUrls);\n\t    } else {\n\t\tthis.cachedInvokerUrls = new HashSet<URL>();\n\t\t//缓存invokerUrls列表，方便比较\n\t\tthis.cachedInvokerUrls.addAll(invokerUrls);\n\t    }\n\t    if (invokerUrls.isEmpty()) {\n\t\t//invoker url列表为空，直接返回\n\t\treturn;\n\t    }\n\t    //将invoker-url转换成invoker-map(后面会分析该方法)\n\t    Map<String, Invoker<T>> newUrlInvokerMap = toInvokers(invokerUrls);\n\t    \n\t    //建立 方法名与invoker的映射(后面会分析该方法)\n\t    Map<String, List<Invoker<T>>> newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap);\n\t   \n\t    //状态改变\n\t    if (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) {\n\t\t//转换发生错误\n\t\tlogger.error(new IllegalStateException(\"urls to invokers error .invokerUrls.size :\" + invokerUrls.size() + \", invoker.size :0. urls :\" + invokerUrls.toString()));\n\t\treturn;\n\t    }\n\t    //保存最新的 methodInvokerMap(后面会分析该方法)\n\t    this.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;\n\t    //保存最新的 urlInvokerMap\n\t    this.urlInvokerMap = newUrlInvokerMap;\n\t    try {\n\t\t//关闭未使用的invoker(后面会分析该方法)\n\t\tdestroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap);\n\t    } catch (Exception e) {\n\t\tlogger.warn(\"destroyUnusedInvokers error. \", e);\n\t    }\n\t}\n}\n```\n\n##### toInvokers方法\n```java\n/**\n * 将invoker-url转换成invoker，如果url已经被引用，将不会重新引用\n * @param urls 服务提供者url\n * dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=6640&side=provider&timestamp=1535449604077\n * @return invokers\n */\nprivate Map<String, Invoker<T>> toInvokers(List<URL> urls) {\n\tMap<String, Invoker<T>> newUrlInvokerMap = new HashMap<String, Invoker<T>>();\n\tif (urls == null || urls.isEmpty()) {\n\t    return newUrlInvokerMap;\n\t}\n\tSet<String> keys = new HashSet<String>();\n\t//获取当前url支持的协议\n\tString queryProtocols = this.queryMap.get(Constants.PROTOCOL_KEY);\n\t//遍历urls，检测每一个providerUrl是否满足当前调用者url的协议要求(queryProtocols)\n\tfor (URL providerUrl : urls) {\n\t    //如果在reference端配置了协议protocol，则只选择匹配的协议\n\t    if (queryProtocols != null && queryProtocols.length() > 0) {\n\t\tboolean accept = false;\n\t\t//可接受的协议数组\n\t\tString[] acceptProtocols = queryProtocols.split(\",\");\n\t\tfor (String acceptProtocol : acceptProtocols) {\n\t\t    if (providerUrl.getProtocol().equals(acceptProtocol)) {\n\t\t\t//如果该提供者url的协议在可接受的协议范围内，则跳出循环\n\t\t\taccept = true;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (!accept) {\n\t\t    //没找到，则判断下一个服务提供者\n\t\t    continue;\n\t\t}\n\t    }\n\t    if (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) {\n\t        //服务提供者协议为empty，则进行下次循环\n\t\tcontinue;\n\t    }\n\t    if (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) {\n\t\t//不支持的协议\n\t\tlogger.error(new IllegalStateException(\"Unsupported protocol \" + providerUrl.getProtocol() + \" in notified url: \" + providerUrl + \" from registry \" + getUrl().getAddress() + \" to consumer \" + NetUtils.getLocalHost()\n\t\t\t+ \", supported protocol: \" + ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));\n\t\tcontinue;\n\t    }\n\t    //合并url参数(后面会分析该方法)\n\t    URL url = mergeUrl(providerUrl);\n\t    \n\t    //url的参数已经排过序\n\t    //dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-consumer&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=1880&qos.port=33333&register.ip=192.168.99.60&remote.timestamp=1535449604077&side=consumer&timestamp=1535449640995\n\t    String key = url.toFullString();\n\t    if (keys.contains(key)) {\n\t\t//重复的url\n\t\tcontinue;\n\t    }\n\t    keys.add(key);\n\t    //缓存key是url，不与消费者端的参数合并，无论消费者如何组合参数，\n            //如果服务器url发生改变，则重新进行引用\n\t    Map<String, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap;\n\t    //根据缓存key获取invoker\n\t    Invoker<T> invoker = localUrlInvokerMap == null ? null : localUrlInvokerMap.get(key);\n\t    if (invoker == null) {\n\t\t//不在缓存中，重新引用\n\t\ttry {\n\t\t    boolean enabled = true;\n\t\t    //获取disabled参数、enabled参数，来判断是否可用\n\t\t    if (url.hasParameter(Constants.DISABLED_KEY)) {\n\t\t\tenabled = !url.getParameter(Constants.DISABLED_KEY, false);\n\t\t    } else {\n\t\t\tenabled = url.getParameter(Constants.ENABLED_KEY, true);\n\t\t    }\n\t\t    if (enabled) {\n\t\t\t//可以引用，重新引用(后面会介绍)\n\t\t\tinvoker = new InvokerDelegate<T>(\n\t\t\t        //根据服务接口、远程服务url重新引用\n\t\t\t\tprotocol.refer(serviceType, url),\n\t\t\t\turl,\n\t\t\t\tproviderUrl\n\t\t\t);\n\t\t    }\n\t\t} catch (Throwable t) {\n\t\t    logger.error(\"Failed to refer invoker for interface:\" + serviceType + \",url:(\" + url + \")\" + t.getMessage(), t);\n\t\t}\n\t\tif (invoker != null) {\n\t\t    //保存新的invoker到缓存\n\t\t    newUrlInvokerMap.put(key, invoker);\n\t\t}\n\t    } else {\n\t\tnewUrlInvokerMap.put(key, invoker);\n\t    }\n\t}\n\tkeys.clear();\n\treturn newUrlInvokerMap;\n}\n\n```\n##### toMethodInvokers方法\n\n```java\n/**\n * 获取Invoker和method之间的映射关系\n * @param invokersMap Invoker Map\n * @return Mapping relation between Invoker and method\n */\nprivate Map<String, List<Invoker<T>>> toMethodInvokers(Map<String, Invoker<T>> invokersMap) {\n\t//method与invoker列表的映射\n\tMap<String, List<Invoker<T>>> newMethodInvokerMap = new HashMap<String, List<Invoker<T>>>();\n\t\n\t// According to the methods classification declared by the provider URL,\n\t// the methods is compatible with the registry to execute the filtered methods\n\tList<Invoker<T>> invokersList = new ArrayList<Invoker<T>>();\n\t\n\tif (invokersMap != null && invokersMap.size() > 0) {\n\t    //遍历invokers\n\t    for (Invoker<T> invoker : invokersMap.values()) {\n\t\t//获取服务提供者方法列表\n\t\tString parameter = invoker.getUrl().getParameter(Constants.METHODS_KEY);\n\t\tif (parameter != null && parameter.length() > 0) {\n\t\t    //逗号分隔方法\n\t\t    String[] methods = Constants.COMMA_SPLIT_PATTERN.split(parameter);\n\t\t    if (methods != null && methods.length > 0) {\n\t\t\tfor (String method : methods) {\n\t\t\t    if (method != null && method.length() > 0 && !Constants.ANY_VALUE.equals(method)) {\n\t\t\t\t//通过method获取invoker列表\n\t\t\t\tList<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);\n\t\t\t\tif (methodInvokers == null) {\n\t\t\t\t    methodInvokers = new ArrayList<Invoker<T>>();\n\t\t\t\t    //添加方法、invoker映射\n\t\t\t\t    newMethodInvokerMap.put(method, methodInvokers);\n\t\t\t\t}\n\t\t\t\tmethodInvokers.add(invoker);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\t//添加invoker\n\t\tinvokersList.add(invoker);\n\t    }\n\t}\n\t//根据路由筛选InvokersList(后面会分析该方法)\n\tList<Invoker<T>> newInvokersList = route(invokersList, null);\n\t\n\t//保存<*,newInvokersList>\n\tnewMethodInvokerMap.put(Constants.ANY_VALUE, newInvokersList);\n\t\n\tif (serviceMethods != null && serviceMethods.length > 0) {\n\t    //遍历服务method列表,并从newMethodInvokerMap中获取该method对应的Invoker列表\n\t    //如果没有获取到，则将该method映射到newInvokersList列表上\n\t    for (String method : serviceMethods) {\n\t\tList<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);\n\t\tif (methodInvokers == null || methodInvokers.isEmpty()) {\n\t\t    methodInvokers = newInvokersList;\n\t\t}\n\t\t//根据路由筛选invoker列表，然后保存method、invokerList映射\n\t\tnewMethodInvokerMap.put(method, route(methodInvokers, method));\n\t    }\n\t}\n\tfor (String method : new HashSet<String>(newMethodInvokerMap.keySet())) {\n\t    List<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);\n\t    //排序invoker\n\t    Collections.sort(methodInvokers, InvokerComparator.getComparator());\n\t    //不可变集合\n\t    newMethodInvokerMap.put(method, Collections.unmodifiableList(methodInvokers));\n\t}\n\treturn Collections.unmodifiableMap(newMethodInvokerMap);\n}\n```\n###### route方法\n```java\n/**\n * 根据路由筛选InvokersList\n * Router 负责从多个 Invoker 中按路由规则选出子集，比如读写分离，应用隔离等\n * @param invokers\n * @param method\n * @return\n */\nprivate List<Invoker<T>> route(List<Invoker<T>> invokers, String method) {\n\t//创建Invocation对象\n\tInvocation invocation = new RpcInvocation(method, new Class<?>[0], new Object[0]);\n\t//获取路由列表\n\tList<Router> routers = getRouters();\n\tif (routers != null) {\n\t    for (Router router : routers) {\n\t\tif (router.getUrl() != null) {\n\t\t    //执行路由\n\t\t    invokers = router.route(invokers, getConsumerUrl(), invocation);\n\t\t}\n\t    }\n\t}\n\treturn invokers;\n}\n```\n\n##### toMergeMethodInvokerMap方法\n```java\nprivate Map<String, List<Invoker<T>>> toMergeMethodInvokerMap(Map<String, List<Invoker<T>>> methodMap) {\n\tMap<String, List<Invoker<T>>> result = new HashMap<String, List<Invoker<T>>>();\n\tfor (Map.Entry<String, List<Invoker<T>>> entry : methodMap.entrySet()) {\n\t    //当前方法名\n\t    String method = entry.getKey();\n\t    //当前invokers\n\t    List<Invoker<T>> invokers = entry.getValue();\n\t    //将invokers按照group进行分组，放入到groupMap中(<group,List<invokers>>)\n\t    Map<String, List<Invoker<T>>> groupMap = new HashMap<String, List<Invoker<T>>>();\n\t    for (Invoker<T> invoker : invokers) {\n\t\t//当前url的group\n\t\tString group = invoker.getUrl().getParameter(Constants.GROUP_KEY, \"\");\n\t\tList<Invoker<T>> groupInvokers = groupMap.get(group);\n\t\tif (groupInvokers == null) {\n\t\t    groupInvokers = new ArrayList<Invoker<T>>();\n\t\t    groupMap.put(group, groupInvokers);\n\t\t}\n\t\tgroupInvokers.add(invoker);\n\t    }\n\t    if (groupMap.size() == 1) {\n\t\t//只有一个group\n\t\tresult.put(method, groupMap.values().iterator().next());\n\t    } else if (groupMap.size() > 1) {\n\t\t//多个group的情况\n\t\tList<Invoker<T>> groupInvokers = new ArrayList<Invoker<T>>();\n\t\tfor (List<Invoker<T>> groupList : groupMap.values()) {\n\t\t    //针对每一个groupList创建一个StaticDirectory，然后生成一个invoker并放入groupInvokers中\n\t\t    groupInvokers.add(cluster.join(new StaticDirectory<T>(groupList)));\n\t\t}\n\t\tresult.put(method, groupInvokers);\n\t    } else {\n\t\t//没有group\n\t\tresult.put(method, invokers);\n\t    }\n\t}\n\treturn result;\n}\n```\n![](img/toMergeMethodInvokerMap.png)\n\n##### 销毁无用的invoker\n```java\n/**\n * 检测缓存中的invoker是否需要被销毁\n * 如果设置url属性：refer.autodestroy=false\n * invokers将会在不减少的情况下增加，可能会有一个引用泄露\n * @param oldUrlInvokerMap\n * @param newUrlInvokerMap\n */\nprivate void destroyUnusedInvokers(Map<String, Invoker<T>> oldUrlInvokerMap,Map<String, Invoker<T>> newUrlInvokerMap) {\n\tif (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) {\n\t    //关闭所有的invoker\n\t    destroyAllInvokers();\n\t    return;\n\t}\n\tList<String> deleted = null;\n\tif (oldUrlInvokerMap != null) {\n\t    Collection<Invoker<T>> newInvokers = newUrlInvokerMap.values();\n\t    for (Map.Entry<String, Invoker<T>> entry : oldUrlInvokerMap.entrySet()) {\n\t\tif (!newInvokers.contains(entry.getValue())) {\n\t\t    //老的invoker在新的invoker列表中不存在\n\t\t    if (deleted == null) {\n\t\t\tdeleted = new ArrayList<String>();\n\t\t    }\n\t\t    //标记该老的url，后面会进行删除\n\t\t    deleted.add(entry.getKey());\n\t\t}\n\t    }\n\t}\n\tif (deleted != null) {\n\t    for (String url : deleted) {\n\t\tif (url != null) {\n\t\t    //从老的invoker-map中移除该url，并关闭该老的invoker\n\t\t    Invoker<T> invoker = oldUrlInvokerMap.remove(url);\n\t\t    if (invoker != null) {\n\t\t\ttry {\n\t\t\t    //销毁该invoker\n\t\t\t    invoker.destroy();\n\t\t\t} catch (Exception e) {\n\t\t\t    logger.warn(\"destory invoker[\" + invoker.getUrl() + \"] faild. \" + e.getMessage(), e);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n}\n```\n#### 重新引用invoker\n\n接下来，我们来看看上面的toInvokers方法中，重新引用invoker的逻辑，即\n```java\nif (enabled) {\n\t//可以引用，重新引用\n\tinvoker = new InvokerDelegate<T>(\n\t\tprotocol.refer(serviceType, url),\n\t\turl,\n\t\tproviderUrl\n\t);\n}\n```\n这里会先调用ProtocolListenerWrapper类的refer方法,然后在该方法内会在调用ProtocolFilterWrapper类的refer方法\n```java\npublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n\tif (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n\t    return protocol.refer(type, url);\n\t}\n\treturn new ListenerInvokerWrapper<T>(\n\t        //调用ProtocolFilterWrapper类的refer方法获取到invoker\n\t\tprotocol.refer(type, url),\n\t\tCollections.unmodifiableList(\n\t\t      ExtensionLoader.getExtensionLoader(InvokerListener.class)\n\t\t\t\t     .getActivateExtension(url, Constants.INVOKER_LISTENER_KEY)\n\t));\n}\n```\n我们看下ProtocolFilterWrapper类的refer方法，在该方法内部会去调用DubboProtocol类的refer方法\n```java\n@Override\npublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n\tif (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n\t\treturn protocol.refer(type, url);\n\t}\n\t//构建invoker链\n\treturn buildInvokerChain(\n\t\t//调用DubboProtocol类的refer方法\n\t\tprotocol.refer(type, url), \n\t\t//reference.filter\n\t\tConstants.REFERENCE_FILTER_KEY, \n\t\t//consumer\n\t\tConstants.CONSUMER\n\t);\n}\n\n/**\n * 构建Invoker链\n * @param invoker\n * @param key  \n * @param group \n */\nprivate static <T> Invoker<T> buildInvokerChain(final Invoker<T> invoker,String key, String group) {\n\tInvoker<T> last = invoker;\n\t//获取过滤器：ConsumerContextFilter、FutureFilter、MonitorFilter\n\tList<Filter> filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);\n\tif (!filters.isEmpty()) {\n\t    for (int i = filters.size() - 1; i >= 0; i--) {\n\t\t//MonitorFilter、FutureFilter、ConsumerContextFilter\n\t\tfinal Filter filter = filters.get(i);\n\t\tfinal Invoker<T> next = last;\n\t\tlast = new Invoker<T>() {\n\t\t    @Override\n\t\t    public Class<T> getInterface() {\n\t\t\treturn invoker.getInterface();\n\t\t    }\n\t\t    @Override\n\t\t    public URL getUrl() {\n\t\t\treturn invoker.getUrl();\n\t\t    }\n\t\t    @Override\n\t\t    public boolean isAvailable() {\n\t\t\treturn invoker.isAvailable();\n\t\t    }\n\t\t    @Override\n\t\t    public Result invoke(Invocation invocation) throws RpcException {\n\t\t        //调用filter的invoke方法\n\t\t\treturn filter.invoke(next, invocation);\n\t\t    }\n\t\t    @Override\n\t\t    public void destroy() {\n\t\t\tinvoker.destroy();\n\t\t    }\n\t\t    @Override\n\t\t    public String toString() {\n\t\t\treturn invoker.toString();\n\t\t    }\n\t\t};\n\t    }\n\t}\n\treturn last;\n}\n```\nDubboProtocol类的refer方法\n```java\n/**\n * @param serviceType com.alibaba.dubbo.demo.DemoService\n * @param url \n * dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-consumer&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=5624&qos.port=33333&register.ip=192.168.99.60&remote.timestamp=1535531661191&side=consumer&timestamp=1535531690333\n */\n@Override\npublic <T> Invoker<T> refer(Class<T> serviceType, URL url) throws RpcException {\n\t//加载优化序列化类\n\toptimizeSerialization(url);\n\t\n\t//创建DubboInvoker\n\tDubboInvoker<T> invoker = new DubboInvoker<T>(\n\t\tserviceType,\n\t\turl,\n\t\t//创建客户端(后面小节会分析该方法)\n\t\tgetClients(url),\n\t\t//当前对象已创建的invoker集合\n\t\tinvokers\n\t);\n\t//将invoker保存到invokers集合中\n\tinvokers.add(invoker);\n\treturn invoker;\n}\n```\n该invoker中持有一个client对象，默认是NettyClient，后面小节会介绍该过程，最终生成的Invoker如下图，：\n![](img/InvokerChain.png)\n\n#### registerConsumer注册消费者\n\n最后调用ProviderConsumerRegTable类的registerConsumer方法注册消费者\n```java\npublic static ConcurrentHashMap<String, Set<ConsumerInvokerWrapper>> consumerInvokers = new ConcurrentHashMap<String, Set<ConsumerInvokerWrapper>>();\n\n/**\n * 注册消费者\n * @param invoker\n * @param registryUrl 注册中心url\n * @param consumerUrl 消费者url\n * @param registryDirectory\n */\npublic static void registerConsumer(Invoker invoker, URL registryUrl, URL consumerUrl, RegistryDirectory registryDirectory) {\n\t//创建ConsumerInvokerWrapper\n\tConsumerInvokerWrapper wrapperInvoker = new ConsumerInvokerWrapper(invoker, registryUrl, consumerUrl, registryDirectory);\n\t//服务唯一标识\n\tString serviceUniqueName = consumerUrl.getServiceKey();\n\t//根据服务唯一标识获取invokers\n\tSet<ConsumerInvokerWrapper> invokers = consumerInvokers.get(serviceUniqueName);\n\tif (invokers == null) {\n\t    consumerInvokers.putIfAbsent(serviceUniqueName, new ConcurrentHashSet<ConsumerInvokerWrapper>());\n\t    invokers = consumerInvokers.get(serviceUniqueName);\n\t}\n\t//添加wrapperInvoker到缓存\n\tinvokers.add(wrapperInvoker);\n}\n```\n\n到此为止，整个流程就介绍完毕了。下面小节将会介绍一下注册中心Registry。\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之注册中心-Zookeeper注册中心","url":"/blog/2018/08/23/Dubbo源码阅读之注册中心-Zookeeper注册中心/","content":">本小节讲解Zookeeper注册中心的实现\n\n\n### ZookeeperRegistry注册中心\n先来看下后面会用到的接口：\n```java\n/**\n * 节点监听\n */\npublic interface ChildListener {\n    /**\n     * 节点发生改变\n     * @param path\n     * @param children\n     */\n    void childChanged(String path, List<String> children);\n}\n/**\n * 连接状态监听器\n */\npublic interface StateListener {\n    //断开连接\n    int DISCONNECTED = 0;\n    //已连接\n    int CONNECTED = 1;\n    //重新连接\n    int RECONNECTED = 2;\n\n    /**\n     * 连接状态改变\n     * @param connected 状态值\n     */\n    void stateChanged(int connected);\n}\n```\n然后我们来看ZookeeperRegistry的实现,该类继承自FailbackRegistry,因此具备了发生异常时自动重试的能力\n```java\npublic class ZookeeperRegistry extends FailbackRegistry {\n\n    private final static Logger logger = LoggerFactory.getLogger(ZookeeperRegistry.class);\n\n    /**\n     * 默认的zk端口\n     */\n    private final static int DEFAULT_ZOOKEEPER_PORT = 2181;\n\n    /**\n     * 默认的zk根节点\n     */\n    private final static String DEFAULT_ROOT = \"dubbo\";\n\n    /**\n     * zk根节点，如：/dubbo\n     */\n    private final String root;\n\n    private final Set<String> anyServices = new ConcurrentHashSet<String>();\n\n    /**\n     * URL：订阅url,<节点监听事件>\n     */\n    private final ConcurrentMap<URL, ConcurrentMap<NotifyListener, ChildListener>>\n            zkListeners = new ConcurrentHashMap<URL, ConcurrentMap<NotifyListener, ChildListener>>();\n\n    /**\n     * zk客户端接口(支持多种客户端实现)\n     */\n    private final ZookeeperClient zkClient;\n\n    public ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) {\n        //设置注册中心url\n        super(url);\n        if (url.isAnyHost()) {\n            //host = 0.0.0.0 || anyhost = true\n            throw new IllegalStateException(\"registry address == null\");\n        }\n        //获取url参数group,标识zk根节点名称,默认为dubbo\n        String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);\n        if (!group.startsWith(Constants.PATH_SEPARATOR)) {\n            //添加前缀，如：/dubbo\n            group = Constants.PATH_SEPARATOR + group;\n        }\n        this.root = group;\n\n        //调用zookeeperTransporter接口的connect方法连接到zk客户端(后面会分析该方法)\n        zkClient = zookeeperTransporter.connect(url);\n\n        //添加节点变更事件到AbstractZookeeperClient父类中的缓存集合变量中\n        zkClient.addStateListener(new StateListener() {\n            @Override\n            public void stateChanged(int state) {\n                if (state == RECONNECTED) {\n                    try {\n                        //重连事件，进行恢复\n                        recover();\n                    } catch (Exception e) {\n                        logger.error(e.getMessage(), e);\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * 给zk地址附加默认端口号\n     * @param address\n     * @return\n     */\n    static String appendDefaultPort(String address) {\n        if (address != null && address.length() > 0) {\n            int i = address.indexOf(':');\n            if (i < 0) {\n                //添加zk默认端口2181，即：address:2181\n                return address + \":\" + DEFAULT_ZOOKEEPER_PORT;\n            } else if (Integer.parseInt(address.substring(i + 1)) == 0) {\n                //端口为0的话，则使用默认端口\n                return address.substring(0, i + 1) + DEFAULT_ZOOKEEPER_PORT;\n            }\n        }\n        return address;\n    }\n\n    @Override\n    public boolean isAvailable() {\n        //连接是否可用\n        return zkClient.isConnected();\n    }\n\n    @Override\n    public void destroy() {\n        super.destroy();\n        try {\n            //销毁客户端\n            zkClient.close();\n        } catch (Exception e) {\n            logger.warn(\"Failed to close zookeeper client \" + getUrl() + \", cause: \" + e.getMessage(), e);\n        }\n    }\n\n    @Override\n    protected void doRegister(URL url) {\n        try {\n            //执行注册 dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=5312&side=provider&timestamp=1534994264738\n            //根据url确定节点路径；根据url的dynamic参数确定是否是临时节点\n\t    //如：/dubbo/com.alibaba.dubbo.demo.DemoService/providers/dubbo%3A%2F%2F192.168.99.60%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26dubbo%3D2.0.0%26generic%3Dfalse%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D5312%26side%3Dprovider%26timestamp%3D1534994264738\n            //在zk上创建节点\n\t    zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true));\n        } catch (Throwable e) {\n            throw new RpcException(\"Failed to register \" + url + \" to zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e);\n        }\n    }\n\n    @Override\n    protected void doUnregister(URL url) {\n        try {\n            //执行取消注册\n            //删除url节点路径\n            zkClient.delete(toUrlPath(url));\n        } catch (Throwable e) {\n            throw new RpcException(\"Failed to unregister \" + url + \" to zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e);\n        }\n    }\n\n    @Override\n    protected void doUnsubscribe(URL url, NotifyListener listener) {\n        //执行取消订阅\n        //根据订阅url获取监听\n        ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);\n        if (listeners != null) {\n            //根据NotifyListener获取zk监听\n            ChildListener zkListener = listeners.get(listener);\n            if (zkListener != null) {\n                //从zk上移除节点监听\n                zkClient.removeChildListener(toUrlPath(url), zkListener);\n            }\n        }\n    }\n\n    /**\n     * 执行订阅\n     * @param url\n     * 例如： provider://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&category=configurators&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=6504&side=provider&timestamp=1534927826842\n     *       consumer://192.168.99.60/com.alibaba.dubbo.demo.DemoService?application=demo-consumer&category=providers,configurators,routers&check=false&dubbo=2.0.0&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=1880&qos.port=33333&side=consumer&timestamp=1535449640995\n     * @param listener 例如：OverrideListener\n     */\n    @Override\n    protected void doSubscribe(final URL url, final NotifyListener listener) {\n        try {\n            //执行订阅\n            //查看订阅url的interface属性是否=*\n            if (Constants.ANY_VALUE.equals(url.getServiceInterface())) {\n                String root = toRootPath();\n                //获取订阅url的监听列表\n                ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);\n                if (listeners == null) {\n                    zkListeners.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, ChildListener>());\n                    listeners = zkListeners.get(url);\n                }\n                //获取listener对应的zk监听器\n                ChildListener zkListener = listeners.get(listener);\n                if (zkListener == null) {\n                    //如果zk监听器为空，则新建一个，并放入zkListeners集合中\n                    listeners.putIfAbsent(listener, new ChildListener() {\n                        @Override\n                        public void childChanged(String parentPath, List<String> currentChilds) {\n                            for (String child : currentChilds) {\n                                child = URL.decode(child);\n                                if (!anyServices.contains(child)) {\n                                    //记录节点child\n                                    anyServices.add(child);\n                                    //订阅child\n                                    //添加interface = child\n                                    //添加check = false\n                                    subscribe(url.setPath(child).addParameters(Constants.INTERFACE_KEY,child,\n                                            Constants.CHECK_KEY, String.valueOf(false)), listener);\n                                }\n                            }\n                        }\n                    });\n                    zkListener = listeners.get(listener);\n                }\n                //创建root持久化节点\n                zkClient.create(root, false);\n                //添加root节点监听，services为root节点的子节点列表\n                List<String> services = zkClient.addChildListener(root, zkListener);\n                if (services != null && !services.isEmpty()) {\n                    for (String service : services) {\n                        //子节点\n                        service = URL.decode(service);\n                        anyServices.add(service);\n                        //订阅子节点\n                        subscribe(url.setPath(service).addParameters(Constants.INTERFACE_KEY, service,\n                                Constants.CHECK_KEY, String.valueOf(false)), listener);\n                    }\n                }\n            } else {\n                List<URL> urls = new ArrayList<URL>();\n                //遍历url的类别列表 /dubbo/com.alibaba.dubbo.demo.DemoService/configurators\n                for (String path : toCategoriesPath(url)) {\n\t\t    //根据订阅url获取监听\n                    ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);\n                    if (listeners == null) {\n                        zkListeners.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, ChildListener>());\n                        listeners = zkListeners.get(url);\n                    }\n                    ChildListener zkListener = listeners.get(listener);\n                    if (zkListener == null) {\n\t\t        //添加为空，则新建一个节点监听\n                        listeners.putIfAbsent(listener, new ChildListener() {\n                            @Override\n                            public void childChanged(String parentPath, List<String> currentChilds) {\n                                //执行通知\n                                ZookeeperRegistry.this.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds));\n                            }\n                        });\n                        zkListener = listeners.get(listener);\n                    }\n                    //创建path节点,\n                    //即：/dubbo/com.xxx.demoService/providers\n                    //即：/dubbo/consumers  /dubbo/com.alibaba.dubbo.demo.DemoService/configurators\n                    zkClient.create(path, false);\n                    //添加path节点监听zkListener\n                    List<String> children = zkClient.addChildListener(path, zkListener);\n                    if (children != null) {\n\t\t\t//empty://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&category=configurators&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=6504&side=provider&timestamp=1534927826842\n                        urls.addAll(toUrlsWithEmpty(url, path, children));\n                    }\n                }\n                //通知消费者(urls即为待通知的消息)\n                notify(url, listener, urls);\n            }\n        } catch (Throwable e) {\n            throw new RpcException(\"Failed to subscribe \" + url + \" to zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public List<URL> lookup(URL url) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"lookup url == null\");\n        }\n        try {\n            //找到的所有的子节点\n            List<String> providers = new ArrayList<String>();\n            //遍历url类别数组 /dubbo/com.alibaba.dubbo.demo.DemoService/providers\n            for (String path : toCategoriesPath(url)) {\n                //获取path节点的子节点\n                List<String> children = zkClient.getChildren(path);\n                if (children != null) {\n                    providers.addAll(children);\n                }\n            }\n            return toUrlsWithoutEmpty(url, providers);\n        } catch (Throwable e) {\n            throw new RpcException(\"Failed to lookup \" + url + \" from zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * 如果root = /,则返回 / ,否则返回 /dubbo/\n     * @return\n     */\n    private String toRootDir() {\n        if (root.equals(Constants.PATH_SEPARATOR)) {\n            return root;\n        }\n        return root + Constants.PATH_SEPARATOR;\n    }\n\n    private String toRootPath() {\n        return root;\n    }\n\n    /**\n     * 获取服务地址\n     * @param url\n     * @return  /dubbo/  或者 /dubbo/编码后的interface\n     */\n    private String toServicePath(URL url) {\n        String name = url.getServiceInterface();\n        if (Constants.ANY_VALUE.equals(name)) {\n            //interface = *，则返回: /dubbo/\n            return toRootPath();\n        }\n        //返回： /dubbo/编码后的interface\n        return toRootDir() + URL.encode(name);\n    }\n\n    /**\n     * 根据url获取类别数组\n     * @param url\n     * @return\n     */\n    private String[] toCategoriesPath(URL url) {\n        String[] categories;\n        if (Constants.ANY_VALUE.equals(url.getParameter(Constants.CATEGORY_KEY))) {\n            //url的category参数=*，则取所有的类别，即 categories = providers、consumers、routers、configurators\n            categories = new String[]{\n\t\t\tConstants.PROVIDERS_CATEGORY, \n\t\t\tConstants.CONSUMERS_CATEGORY,\n\t\t\tConstants.ROUTERS_CATEGORY, \n\t\t\tConstants.CONFIGURATORS_CATEGORY\n\t    };\n        } else {\n            //如果category参数为空，则取默认类别：providers\n            categories = url.getParameter(Constants.CATEGORY_KEY, new String[]{Constants.DEFAULT_CATEGORY});\n        }\n        String[] paths = new String[categories.length];\n        for (int i = 0; i < categories.length; i++) {\n            //例如：/dubbo/com.xxx.demoService/providers (interface != *)\n            //例如：/dubbo/providers (interface = *)\n            paths[i] = toServicePath(url) + Constants.PATH_SEPARATOR + categories[i];\n        }\n        return paths;\n    }\n\n    /**\n     * 获取url对应的类别地址\n     * /dubbo/com.alibaba.dubbo.demo.demoService/providers\n     * @param url\n     * @return\n     */\n    private String toCategoryPath(URL url) {\n        return toServicePath(url) + Constants.PATH_SEPARATOR + url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);\n    }\n\n    /**\n     * 获取url对应的url地址(将会在zk上创建该地址)\n     * @param url\n     * @return /dubbo/com.alibaba.dubbo.demo.DemoService/providers/dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=7112&side=provider&timestamp=1534931882323\n     */\n    private String toUrlPath(URL url) {\n        return toCategoryPath(url) + Constants.PATH_SEPARATOR + URL.encode(url.toFullString());\n    }\n\n    /**\n     * 返回值为空的话，不会返回默认值\n     * @param consumer\n     * @param providers\n     * @return\n     */\n    private List<URL> toUrlsWithoutEmpty(URL consumer, List<String> providers) {\n        List<URL> urls = new ArrayList<URL>();\n        if (providers != null && !providers.isEmpty()) {\n            for (String provider : providers) {\n                //解码\n                provider = URL.decode(provider);\n                if (provider.contains(\"://\")) {\n                    URL url = URL.valueOf(provider);\n                    //是否匹配\n                    if (UrlUtils.isMatch(consumer, url)) {\n                        urls.add(url);\n                    }\n                }\n            }\n        }\n        return urls;\n    }\n\n    /**\n     * 如果为空的话，则返回一个默认值\n     * @param consumer provider://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&category=configurators&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=6504&side=provider&timestamp=1534927826842\n     * @param path /dubbo/com.alibaba.dubbo.demo.DemoService/configurators\n     * @param providers\n     * @return\n     */\n    private List<URL> toUrlsWithEmpty(URL consumer, String path, List<String> providers) {\n        List<URL> urls = toUrlsWithoutEmpty(consumer, providers);\n        if (urls == null || urls.isEmpty()) {\n            int i = path.lastIndexOf('/');\n            //获取类别\n            String category = i < 0 ? path : path.substring(i + 1);\n            //设置empty协议，并设置category属性\n            URL empty = consumer.setProtocol(Constants.EMPTY_PROTOCOL).addParameter(Constants.CATEGORY_KEY, category);\n            urls.add(empty);\n        }\n        return urls;\n    }\n}\n```\n可以看到zk注册中心根据NotifyListener接口与RegistryDirectory类进行通信，通过notify方法通知消费者有更新。通过ZookeeperClient与Zookeeper进行交互。\n接下来，我们来看下是dubbo是如何通过工厂创建ZookeeperRegistry实例的。\n\n### Zookeeper注册中心工厂\n先来看下ZookeeperRegistryFactory类，该类继承自AbstractRegistryFactory，用来创建具体的ZookeeperRegistry实例\n```java\npublic class ZookeeperRegistryFactory extends AbstractRegistryFactory {\n\n    private ZookeeperTransporter zookeeperTransporter;\n\n    public void setZookeeperTransporter(ZookeeperTransporter zookeeperTransporter) {\n        this.zookeeperTransporter = zookeeperTransporter;\n    }\n   \n    /**\n     * @param url 注册中心url\n     */\n    @Override\n    public Registry createRegistry(URL url) {\n        //创建zk注册中心\n        return new ZookeeperRegistry(url, zookeeperTransporter);\n    }\n}\n```\nZookeeperTransporter是一个接口，dubbo支持多个zk客户端实现，例如Curator、ZkClient，该接口就是用来创建具体的客户端实现的，可以看到默认是使用curator客户端。\n```java\n@SPI(\"curator\")\npublic interface ZookeeperTransporter {\n    @Adaptive({Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY})\n    ZookeeperClient connect(URL url);\n}\n\npublic class CuratorZookeeperTransporter implements ZookeeperTransporter {\n    @Override\n    public ZookeeperClient connect(URL url) {\n        //返回Curator实现\n        return new CuratorZookeeperClient(url);\n    }\n}\n\npublic class ZkclientZookeeperTransporter implements ZookeeperTransporter {\n    @Override\n    public ZookeeperClient connect(URL url) {\n        //返回Zkclient实现\n        return new ZkclientZookeeperClient(url);\n    }\n}\n```\n下面我们就来看看各个ZookeeperClient的实现。\n\n#### ZookeeperClient接口\n该接口定义了一些针对zk的基本操作\n```java\npublic interface ZookeeperClient {\n    /**\n     * 创建一个节点\n     * @param path 节点路径\n     * @param ephemeral 是否临时节点\n     */\n    void create(String path, boolean ephemeral);\n\n    /**\n     * 删除一个节点\n     * @param path\n     */\n    void delete(String path);\n\n    /**\n     * 获取某个节点的子节点路径\n     * @param path\n     * @return\n     */\n    List<String> getChildren(String path);\n\n    /**\n     * 添加节点监听器\n     * @param path 节点路径\n     * @param listener 监听器\n     * @return\n     */\n    List<String> addChildListener(String path, ChildListener listener);\n\n    /**\n     * 移除节点监听器\n     * @param path\n     * @param listener\n     */\n    void removeChildListener(String path, ChildListener listener);\n\n    /**\n     * 添加变更事件监听\n     * @param listener\n     */\n    void addStateListener(StateListener listener);\n    /**\n     * 移除变更事件监听\n     */\n    void removeStateListener(StateListener listener);\n    /**\n     * 是否已连接\n     * @return\n     */\n    boolean isConnected();\n    /**\n     * 关闭\n     */\n    void close();\n    /**\n     * 获取注册中心url\n     */\n    URL getUrl();\n}\n```\n##### AbstractZookeeperClient抽象类\n```java\npublic abstract class AbstractZookeeperClient<TargetChildListener> implements ZookeeperClient {\n\n    protected static final Logger logger = LoggerFactory.getLogger(AbstractZookeeperClient.class);\n\n    /**\n     * 注册中心url\n     */\n    private final URL url;\n\n    /**\n     * 缓存监听\n     */\n    private final Set<StateListener> stateListeners = new CopyOnWriteArraySet<StateListener>();\n\n    /**\n     * 节点监听缓存\n     */\n    private final ConcurrentMap<String, ConcurrentMap<ChildListener, TargetChildListener>>\n            childListeners = new ConcurrentHashMap<String, ConcurrentMap<ChildListener, TargetChildListener>>();\n\n    /**\n     * 客户端是否已停止\n     */\n    private volatile boolean closed = false;\n\n    public AbstractZookeeperClient(URL url) {\n        this.url = url;\n    }\n\n    @Override\n    public URL getUrl() {\n        return url;\n    }\n\n    @Override\n    public void create(String path, boolean ephemeral) {\n        int i = path.lastIndexOf('/');\n        if (i > 0) {\n            //获取到父路径\n            String parentPath = path.substring(0, i);\n            if (!checkExists(parentPath)) {\n                //父路径不存在的话，进行递归创建\n                create(parentPath, false);\n            }\n        }\n        if (ephemeral) {\n            //创建临时节点\n            createEphemeral(path);\n        } else {\n            //创建持久节点\n            createPersistent(path);\n        }\n    }\n\n    @Override\n    public void addStateListener(StateListener listener) {\n        stateListeners.add(listener);\n    }\n    @Override\n    public void removeStateListener(StateListener listener) {\n        stateListeners.remove(listener);\n    }\n    public Set<StateListener> getSessionListeners() {\n        return stateListeners;\n    }\n    @Override\n    public List<String> addChildListener(String path, final ChildListener listener) {\n        //从缓存中获取path节点的监听\n        ConcurrentMap<ChildListener, TargetChildListener> listeners = childListeners.get(path);\n        if (listeners == null) {\n            childListeners.putIfAbsent(path, new ConcurrentHashMap<ChildListener, TargetChildListener>());\n            listeners = childListeners.get(path);\n        }\n        TargetChildListener targetListener = listeners.get(listener);\n        if (targetListener == null) {\n            //为节点path新创建一个监听，并放入listeners中\n            listeners.putIfAbsent(listener, createTargetChildListener(path, listener));\n            targetListener = listeners.get(listener);\n        }\n        //添加目标节点监听\n        return addTargetChildListener(path, targetListener);\n    }\n\n    @Override\n    public void removeChildListener(String path, ChildListener listener) {\n        //从缓存中获取path节点的监听\n        ConcurrentMap<ChildListener, TargetChildListener> listeners = childListeners.get(path);\n        if (listeners != null) {\n            //从缓存中移除监听listener\n            TargetChildListener targetListener = listeners.remove(listener);\n            if (targetListener != null) {\n                //移除目标节点的监听targetListener\n                removeTargetChildListener(path, targetListener);\n            }\n        }\n    }\n\n    /**\n     * 状态变更事件\n     * @param state\n     */\n    protected void stateChanged(int state) {\n        //遍历所有的监听器\n        for (StateListener sessionListener : getSessionListeners()) {\n\t    //执行变更事件\n            sessionListener.stateChanged(state);\n        }\n    }\n\n    @Override\n    public void close() {\n        if (closed) {\n\t    //已关闭\n            return;\n        }\n        closed = true;\n        try {\n            doClose();\n        } catch (Throwable t) {\n            logger.warn(t.getMessage(), t);\n        }\n    }\n    //************模板方法************\n    //关闭\n    protected abstract void doClose();\n    //创建持久节点\n    protected abstract void createPersistent(String path);\n    //创建临时节点\n    protected abstract void createEphemeral(String path);\n    //检测节点是否存在\n    protected abstract boolean checkExists(String path);\n    //创建目标节点监听\n    protected abstract TargetChildListener createTargetChildListener(String path, ChildListener listener);\n    //添加目标节点监听\n    protected abstract List<String> addTargetChildListener(String path, TargetChildListener listener);\n    //移除目标节点监听\n    protected abstract void removeTargetChildListener(String path, TargetChildListener listener);\n}\n```\n##### CuratorZookeeperClient实现\n```java\npublic class CuratorZookeeperClient extends AbstractZookeeperClient<CuratorWatcher> {\n    \n    //Curator客户端，对zk的操作都是由它来完成\n    private final CuratorFramework client;\n\n    public CuratorZookeeperClient(URL url) {\n        //设置注册中心url\n        super(url);\n        try {\n            CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()\n                    //指定注册中心url地址,多个地址使用逗号分隔\n                    .connectString(url.getBackupAddress())\n                    //设置重试策略，最大重试1次，重试间隔1000毫秒\n                    .retryPolicy(new RetryNTimes(1, 1000))\n                    //设置连接超时,单位ms,默认1500ms,这里设置5秒\n                    .connectionTimeoutMs(5000);\n            //获取url的username:password\n            String authority = url.getAuthority();\n            if (authority != null && authority.length() > 0) {\n                //添加授权\n                builder = builder.authorization(\"digest\", authority.getBytes());\n            }\n            //生成curator客户端\n            client = builder.build();\n            //监听客户端链接状态\n            client.getConnectionStateListenable().addListener(new ConnectionStateListener() {\n                @Override\n                public void stateChanged(CuratorFramework client, ConnectionState state) {\n                    if (state == ConnectionState.LOST) {\n                        //断开状态，则触发链接断开事件\n                        CuratorZookeeperClient.this.stateChanged(StateListener.DISCONNECTED);\n                    } else if (state == ConnectionState.CONNECTED) {\n                        //已连接状态，则触发链接事件\n                        CuratorZookeeperClient.this.stateChanged(StateListener.CONNECTED);\n                    } else if (state == ConnectionState.RECONNECTED) {\n                        //重连状态，则触发重连事件\n                        CuratorZookeeperClient.this.stateChanged(StateListener.RECONNECTED);\n                    }\n                }\n            });\n            //启动客户端\n            client.start();\n        } catch (Exception e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public void createPersistent(String path) {\n        try {\n            //创建持久化节点path\n            client.create().forPath(path);\n        } catch (NodeExistsException e) {\n        } catch (Exception e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public void createEphemeral(String path) {\n        try {\n            //创建临时节点path\n            client.create().withMode(CreateMode.EPHEMERAL).forPath(path);\n        } catch (NodeExistsException e) {\n        } catch (Exception e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public void delete(String path) {\n        try {\n            //删除节点path\n            client.delete().forPath(path);\n        } catch (NoNodeException e) {\n        } catch (Exception e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public List<String> getChildren(String path) {\n        try {\n            //获取path节点的子节点列表\n            return client.getChildren().forPath(path);\n        } catch (NoNodeException e) {\n            return null;\n        } catch (Exception e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public boolean checkExists(String path) {\n        try {\n            //检测path节点是否已存在\n            if (client.checkExists().forPath(path) != null) {\n                return true;\n            }\n        } catch (Exception e) {\n        }\n        return false;\n    }\n    @Override\n    public boolean isConnected() {\n        //是否已连接状态\n        return client.getZookeeperClient().isConnected();\n    }\n\n    @Override\n    public void doClose() {\n        //关闭客户端\n        client.close();\n    }\n\n    @Override\n    public CuratorWatcher createTargetChildListener(String path, ChildListener listener) {\n        //新创建一个目标节点监听\n        return new CuratorWatcherImpl(listener);\n    }\n\n    @Override\n    public List<String> addTargetChildListener(String path, CuratorWatcher listener) {\n        try {\n            //获取path子节点，并添加监听\n            return client.getChildren().usingWatcher(listener).forPath(path);\n        } catch (NoNodeException e) {\n            return null;\n        } catch (Exception e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public void removeTargetChildListener(String path, CuratorWatcher listener) {\n        //移除监听\n        ((CuratorWatcherImpl) listener).unwatch();\n    }\n   \n    /**\n     * 该内部类实现了CuratorWatcher接口\n     */\n    private class CuratorWatcherImpl implements CuratorWatcher {\n        //监听\n        private volatile ChildListener listener;\n        public CuratorWatcherImpl(ChildListener listener) {\n            this.listener = listener;\n        }\n        /**\n         * 取消监听\n         */\n        public void unwatch() {\n            this.listener = null;\n        }\n        @Override\n        public void process(WatchedEvent event) throws Exception {\n            if (listener != null) {\n                //变更节点\n                String path = event.getPath() == null ? \"\" : event.getPath();\n                //触发变更事件\n                listener.childChanged(path,\n                        //如果path为空，curator使用watcher将会抛出异常\n                        //如果客户端连接、断开连接服务器，zookeeper将会排队watched event事件\n                        StringUtils.isNotEmpty(path)\n                                //为path的子节点增加监听(当前CuratorWatcherImpl,只能使用1次)\n                                ? client.getChildren().usingWatcher(this).forPath(path)\n                                : Collections.<String>emptyList());\n            }\n        }\n    }\n}\n```\n##### ZkclientZookeeperClient实现\n```java\npublic class ZkclientZookeeperClient extends AbstractZookeeperClient<IZkChildListener> {\n    /**\n     * ZkClient包装类，下面的操作都会交给它来执行\n     */\n    private final ZkClientWrapper client;\n\n    private volatile KeeperState state = KeeperState.SyncConnected;\n\n    public ZkclientZookeeperClient(URL url) {\n        //设置注册中心地址\n        super(url);\n        //创建zkClient客户端\n        client = new ZkClientWrapper(url.getBackupAddress(), 30000);\n        //添加监听\n        client.addListener(new IZkStateListener() {\n            @Override\n            public void handleStateChanged(KeeperState state) throws Exception {\n\t\t//设置当前状态\n\t\tZkclientZookeeperClient.this.state = state;\n                if (state == KeeperState.Disconnected) {\n                    //触发断开连接事件\n                    stateChanged(StateListener.DISCONNECTED);\n                } else if (state == KeeperState.SyncConnected) {\n                    //触发连接成功事件\n                    stateChanged(StateListener.CONNECTED);\n                }\n            }\n            @Override\n            public void handleNewSession() throws Exception {\n                //触发重新连接事件\n                stateChanged(StateListener.RECONNECTED);\n            }\n        });\n        client.start();\n    }\n    @Override\n    public void createPersistent(String path) {\n        try {\n            client.createPersistent(path);\n        } catch (ZkNodeExistsException e) {\n        }\n    }\n    @Override\n    public void createEphemeral(String path) {\n        try {\n            client.createEphemeral(path);\n        } catch (ZkNodeExistsException e) {\n        }\n    }\n    @Override\n    public void delete(String path) {\n        try {\n            client.delete(path);\n        } catch (ZkNoNodeException e) {\n        }\n    }\n    @Override\n    public List<String> getChildren(String path) {\n        try {\n            return client.getChildren(path);\n        } catch (ZkNoNodeException e) {\n            return null;\n        }\n    }\n    @Override\n    public boolean checkExists(String path) {\n        try {\n            return client.exists(path);\n        } catch (Throwable t) {\n        }\n        return false;\n    }\n    @Override\n    public boolean isConnected() {\n        return state == KeeperState.SyncConnected;\n    }\n    @Override\n    public void doClose() {\n        client.close();\n    }\n    @Override\n    public IZkChildListener createTargetChildListener(String path, final ChildListener listener) {\n        return new IZkChildListener() {\n            @Override\n            public void handleChildChange(String parentPath, List<String> currentChilds) throws Exception {\n                //触发节点变更事件\n                listener.childChanged(parentPath, currentChilds);\n            }\n        };\n    }\n    @Override\n    public List<String> addTargetChildListener(String path, final IZkChildListener listener) {\n        return client.subscribeChildChanges(path, listener);\n    }\n    @Override\n    public void removeTargetChildListener(String path, IZkChildListener listener) {\n        client.unsubscribeChildChanges(path, listener);\n    }\n}\n```\n###### ZkClientWrapper包装类\nZkclient包装类可以在连接失效后自动监控连接的状态，使用方式与curator一致\n```java\npublic class ZkClientWrapper {\n\n    /**\n     * 获取客户端超时时间\n     */\n    private long timeout;\n    /**\n     * ZkClient客户端\n     */\n    private ZkClient client;\n    /**\n     * 当前状态\n     */\n    private volatile KeeperState state;\n\n    /**\n     * 可监听的FutureTask\n     */\n    private ListenableFutureTask<ZkClient> listenableFutureTask;\n    /**\n     * 客户端是否已启动\n     */\n    private volatile boolean started = false;\n\n    /**\n     * @param serverAddr 注册中心url\n     */\n    public ZkClientWrapper(final String serverAddr, long timeout) {\n        //设置超时\n        this.timeout = timeout;\n\n        //创建一个FutureTask，用来创建zkClient客户端\n        listenableFutureTask = ListenableFutureTask.create(new Callable<ZkClient>() {\n            @Override\n            public ZkClient call() throws Exception {\n\t        //创建ZkClient客户端\n                return new ZkClient(serverAddr, Integer.MAX_VALUE);\n            }\n        });\n    }\n   \n    /**\n     * 启动zkclient\n     */\n    public void start() {\n        if (!started) {\n            //新建守护线程，创建zkClient客户端\n            Thread connectThread = new Thread(listenableFutureTask);\n            connectThread.setName(\"DubboZkclientConnector\");\n            connectThread.setDaemon(true);\n            connectThread.start();\n            try {\n                //获取新创建的客户端\n                client = listenableFutureTask.get(timeout, TimeUnit.MILLISECONDS);\n            } catch (Throwable t) {\n\t        //获取client超时\n                logger.error(\"Timeout! zookeeper server can not be connected in : \" + timeout + \"ms!\", t);\n            }\n            started = true;\n        } else {\n            logger.warn(\"Zkclient has already been started!\");\n        }\n    }\n  \n    /**\n     * 添加监听listener\n     */\n    public void addListener(final IZkStateListener listener) {\n        //使用listenableFutureTask监听client的创建，client创建成功后在订阅该listener\n        listenableFutureTask.addListener(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    client = listenableFutureTask.get();\n                    //获取到客户端后，订阅listener\n                    client.subscribeStateChanges(listener);\n                } catch (InterruptedException e) {\n                    logger.warn(Thread.currentThread().getName() + \" was interrupted unexpectedly, which may cause unpredictable exception!\");\n                } catch (ExecutionException e) {\n                    logger.error(\"Got an exception when trying to create zkclient instance, can not connect to zookeeper server, please check!\", e);\n                }\n            }\n        });\n    }\n\n    public boolean isConnected() {\n        //是否已连接\n        return client != null && state == KeeperState.SyncConnected;\n    }\n\n    public void createPersistent(String path) {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        //创建持久化节点\n        client.createPersistent(path, true);\n    }\n\n    public void createEphemeral(String path) {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        //创建临时节点\n        client.createEphemeral(path);\n    }\n\n    public void delete(String path) {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        //删除节点\n        client.delete(path);\n    }\n\n    public List<String> getChildren(String path) {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        //获取path节点的子节点\n        return client.getChildren(path);\n    }\n\n    public boolean exists(String path) {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        //判断path节点是否存在\n        return client.exists(path);\n    }\n\n    public void close() {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        client.close();\n    }\n\n    public List<String> subscribeChildChanges(String path, final IZkChildListener listener) {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        //订阅path节点变更事件\n        return client.subscribeChildChanges(path, listener);\n    }\n\n    public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        //取消订阅path节点变更事件\n        client.unsubscribeChildChanges(path, listener);\n    }\n}\n```\n\n关于zk注册中心的内容就介绍到这里，下一小节介绍其他注册中心的实现。\n\n","tags":["dubbo"]},{"title":"《k8s权威指南》- 笔记","url":"/blog/2018/08/19/k8s权威指南-笔记/","content":"Kubernetes是基于容器技术，目的是实现资源动态管理，以及跨多个数据中心的资源利用率的最大化的分布式架构方案。如果我们的系统设计遵循k8s的设计思想，那么传统系统架构中那些和业务没有多大关系的底层代码和功能模块，都可以统统不用考虑，我们不必在头疼于服务监控、故障处理等模块的开发，使用k8s提供的解决方案，我们可以节省大量的开发成本，降低系统运维的难度。\nk8s具有完备的集群管理能力，支持多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务发现和注册机制、内建的负载均衡器、故障发现和自我修复、服务滚动升级和在线自动扩容、可扩展的资源自动调度机制、以及多粒度的资源配额管理能力。\n\n在介绍k8s基础知识前，我们先来看下k8s基础组件图，然后我们参考着图一起来讲解。\n![](img/k8s.png)\n\n### Master\nMaster是整个k8s集群的控制节点，负责整个集群的管理和控制，基本上所有的控制命令都需要发给它，由它来负责具体的执行过程，因此Master节点非常重要，建议使用独立的服务器来部署，高可用部署建议用3台服务器。\nMaster节点上运行着3个重要的进程：\n* kube-apiserver：提供Http Rest接口的服务进程，是k8s里所有资源增、删、改、查等操作的唯一入口，也是集群控制的入口进程。\n* kube-controller-manager：k8s里面所有资源对象的自动化控制中心。\n* kube-schedule：负责资源调度(Pod调度)的进程。\n另外，Master节点上还需要启动一个etcd服务，因为k8s里所有资源对象的数据全部都是保存在etcd里面的。\n\n### Node\n除了Master节点以外，k8s集群里的其他机器被称为Node节点，每个Node节点都会被Master节点分配一些工作负载(docker容器),当某个Node节点宕机时，其上的工作负载会被Master自动转移到其他Node节点上去。\n每个Node节点上同样运行着一组重要进程：\n* kubelet：负责Pod对应的容器的创建、启停等任务，同时与Master节点密切协作，实现集群管理的基本功能。\n* kube-proxy：实现k8s Service的通信与负载均衡机制的重要组件。\n* Docker Engine：docker引擎，负责本机docker容器的创建和管理工作。\nNode节点可以在运行期间动态添加到k8s集群中，前提是该节点正确启动了上述进程。默认情况下，kubelet会向Master节点注册自己，然后kubelet会定时的向Master节点汇报自身的情报信息，例如：操作系统版本、docker版本、机器CPU内存情况、以及当前有哪些Pod在运行。这样Master便会知道每个Node节点的资源使用情况，并实现高效均衡的资源调度策略。如果某个Node节点超过指定时间没有上报信息，会被Master节点判定为\"失联\"，该Node节点状态将会被标记为不可用(Not Ready),随后，Master会触发相应的自动流程，将不可用的Node节点上的工作负载转移到其他Node节点上。\n### Service\nService是k8s的核心，它其实就是微服务架构中的一个\"微服务\"，每个Service对象都有如下特征：\n* 拥有一个唯一指定的名称(比如mysql-server)\n* 拥有一个虚拟IP(Cluster IP、Service IP 或 VIP，由k8s分配)和端口号(服务的访问入口地址)\n* 能够提供某种远程服务能力\n* 被映射到了提供这种服务能力的一组容器应用上\nService的服务进程目前都基于Socket通信方式对外提供服务，比如Redis、Mysql、Tomcat，或者是实现了某个具体业务的一个特定的Tcp Server进程，虽然一个Service通常由多个相关的服务进程来提供服务，每个服务进程都有一个独立的Endpoint(IP + Port)访问点(例如Tomcat有服务端口和管理端口)，但k8s能够让我们通过Service(Cluster IP + Service Port)连接到指定的Service上，通过k8s内建的透明负载均衡和故障恢复机制，不管后端有多少服务进程，也不管某个服务进程是否会由于发生故障而重新部署到其他机器上，都不会影响到我们对服务的正常调用，更重要的是这个Service一旦创建成功，就不会在发生变化，这意味着，在k8s集群中，我们再也不用为了服务的IP地址变来变去的问题而头疼了。\n通过上图，我们可以看到，前端应用Pod通过Service的入口地址，访问到了该Service背后一组由Pod副本组成的集群实例。Service是通过Label Select标签选择器机制与其后端Pod副本集群关联起来的，而ReplicationController的作用实际上是保证Service的服务能力和服务质量始终处于预期的标准(根据ReplicationController的副本数量配置，k8s会保证启动相应副本数的容器)\n\n\n### Pod\n容器提供了强大隔离功能，k8s为了实现Service服务隔离设计了Pod对象，将每个服务进程包装到相应的Pod中，使其成为Pod中运行的一个容器，为了建立Service和Pod的关联关系，k8s首先给每个Pod贴上一个标签(Label),例如给运行Mysql的Pod贴上name=mysql标签，给运行redis的Pod贴上name=redis的标签，然后给相应的Service定义标签选择器(Label Selector)，比如Redis集群Service的标签选择器的选择条件为name=redis，那么该Redis集群Service将会作用于所有包含name=redis标签的Pod上,这样一来，就解决了Service和Pod的关联问题。\n通过上图，我们可以看到Pod运行在Node节点上，通常每个Node节点上可以运行几百个Pod，而且运行一个被称为\"根容器\"的Pause容器。因为在一组容器作为一个单元的情况下，我们很难对一个\"整体\"进行简单的判断，例如，一个容器挂掉了，那么此时算是整体死亡吗？是N/M的死亡率吗？引入业务无关且不易挂掉的Pause容器作为Pod的根容器，以它的状态代表整个容器组的状态，就简单的解决了这个问题。另外，Pod里的多个业务容器共享Pause容器的IP，共享Pause容器挂接的Volume，这样即简化了密切关联的业务容器之间的通信问题，也很好的解决了它们之间的文件共享问题。\nk8s为每个Pod都分配了一个唯一的Pod IP，一个Pod里的多个容器共享该Pod IP地址，k8s要求底层网络支持集群内任意两个Pod之间的TCP/IP直接通信，这通常采用\"虚拟二层网络\"技术来实现，例如：Flannel、Open vSwitch等，因此，我们需要牢记一点：在k8s里，一个Pod里的容器与另外主机上的Pod容器能够直接通信。\nPod分为两种类型：普通的Pod和静态的Pod，静态Pod比较特殊，它并不在k8s的etcd中存储，而是存在在某个具体的Node上的一个具体文件中，并且只在此Node上运行，而普通的Pod一旦创建，就会被放入etcd中存储，随后会被k8s的Master调度到某个具体的Node上进行绑定，随后该Pod被对应的Node上的kubelet进程实例化为一组相关的Docker容器并启动起来。在默认情况下，当Pod里的某个容器停止时，k8s会自动检测到这个问题并且重启该Pod(重启Pod里的所有容器)，如果Pod所在的Node宕机，则会将这个Node上的所有Pod重新调度到其他节点上运行。\n\n\nPod IP 加上容器的Port，就组成了Endpoint，它代表着此Pod里的一个服务进程的对外通信地址，一个Pod也存在着具有多个Endpoint的情况，比如当我们把Tomcat定义为一个Pod时，可以对外暴露管理端口和服务端口这两个Endpoint.\n\nk8s的Event是一个事件的记录，记录了事件的最早产生时间、最后重现事件、重复次数、发起者、类型，以及导致此事件的原因等众多信息，Event通常会关联到某个具体的资源对象上，是排查故障的重要参考信息。\n\n#### Service 和 Pod\n既然每个Pod都会被分配唯一的Pod IP，而且每个Pod都提供了一个独立的Endpoint(Pod IP + 容器Port)以被客户端访问，现在多个Pod副本就组成了一个集群来提供服务，那么客户端该如何来访问它们呢？\n一般的做法是部署一个负载均衡器，为这组Pod开启一个对外的服务端口如8000端口，并且将这些Pod的Endpoint列表加入8000端口的转发列表中，客户端就可以通过负载均衡器的对外IP地址+服务端口来访问此服务了，而客户端的请求最后会被转发到哪个Pod，则由负载均衡器的算法来决定。\nk8s也遵循了上述常规做法，运行在每个Node上的kube-proxy进程其实就是一个智能的软件负载均衡器，它负责把对Service的请求转发到后端的某个Pod实例上，并在内部实现服务的负载均衡和回话保持机制。但k8s发明了一种很巧妙的设计：Service不是共用一个负载均衡器的IP地址，而是每个Service被分配了一个全局唯一的虚拟的Cluster IP，这样一来，每个服务就变成了具备唯一IP地址的\"通信节点\"，服务调用就变成了最基础的TCP网络通信问题。\n我们知道Pod的Endpoint地址会随着Pod的销毁和重新创建而发生改变，因此新Pod的IP地址和旧Pod的IP地址不同。而Service的一旦被创建，k8s就会自动为它分配一个可用的Cluster IP，而且在Service的整个生命周期内，它的Cluster IP都不会发生改变，于是服务发现这个问题在k8s的架构里就得以轻松解决：只需要用Service的Name和Service的Cluster IP做一个DNS域名映射就可以完美解决问题。\n那么如何实现通过Service的Name来查找对应的Cluster IP呢？\n最早以前，k8s采用了Linux环境变量的方式，为每个Service生成一些对应的环境变量，并在每个Pod的容器启动时，自动注入这些环境变量，但是这样使用起来仍然不够直观。后来k8s通过Add-On增值包的方式引入了DNS系统，把Service的Name作为DNS的域名，这样一来，程序就可以直接使用Service的Name来建立通信了。\n\n#### 外部系统访问Service的问题\n我们再来看下k8s里面的三种IP：\n\n* Node IP\nNode节点的IP，是每个Node节点的物理网卡的IP，这是一个真实存在的物理网络，所有属于这个网络的服务器之间都能通过这个网络直接通信，不管它们中是否有不属于该k8s集群的节点。这也表明，k8s集群之外的节点想要访问k8s集群内的某个节点或者TCP/IP服务时，必须要通过Node IP进行通信。\n* Pod IP\nPod IP是每个Pod的IP地址，它是Docker Engine根据docker0网桥的IP地址段进行分配的，通常是一个虚拟的二层网络，前面我们说过，k8s要求位于不同Node上的Pod能够彼此直接通信，所以一个Pod里的容器访问另一个Pod里的容器，就是通过Pod IP所在的虚拟二层网络进行通信的，而真实的TCP/IP流量则是通过Node IP所在的物理网卡流出的。\n* Cluster IP\n它也是一个虚拟IP，仅作用于k8s的Service对象，并由k8s管理和分配IP地址(来源于Cluster IP地址池)。Cluster IP只能结合Service Port组成一个具体的通信端口，单独的Cluster IP不具备TCP/IP通信基础。\n\n通过上面的说明，我们明白了，Service的Cluster IP属于k8s集群内部的地址，无法在集群外部直接使用这个地址。那么用户该如何访问我们的tomcat-service呢？使用NodePort是解决上述问题最有效的方法。\nNodePort的实现方式是：在k8s集群里的每个Node上为需要外部访问的Service开启一个对应的TCP监听端口，外部系统只需要用任意一个Node的IP地址+具体的NodePort端口就可以访问该服务。假如我们配置了NodePort=31002，然后在任意的Node上运行netstat命令，就可以看到有NodePort端口被监听。\n\n\n### Label\n一个Label就是一个key=value的键值对，其中key和value由用户自己定义，Label可以附加到各种资源对象上，例如：Node、Pod、Servoce、Replication Controller等，一个资源对象可以定义任意数量的Label，同一个Label也可以添加到任意数量的资源对象上，Label可以在资源对象定义时确定，也可以在资源对象创建后动态添加或者删除。\n我们可以通过给指定的资源对象附加多个不同的Label来实现多维度的资源分组管理功能，以便于灵活方便的进行资源分配、调度、配置、部署等管理工作。例如：部署不同版本的应用到不同的环境中。\n一些常用的Label标签示例如下：\n* 版本标签：\"release\":\"stable\",\"release\":\"canary\"\n* 环境标签：\"env\":\"test\",\"env\":\"uat\",\"env\":\"pro\"\n给某个资源对象附加一些标签，随后我们可以通过Label Selector(标签选择器)查询和筛选拥有某些Label标签的资源对象。\n当前有两种Lavel Selector的表达式：基于等式的和基于集合的，例如：\n* name = redis-slave ，匹配所有拥有name = redis-slave标签的资源对象\n* env != pro，匹配所有不具有env = pro标签的资源对象\n* name in (redis-master,redis-slave)，匹配所有拥有name = redis-master 或者 name = redis-slave标签的资源对象\n* name not in (php)，匹配所有不具有name = php标签的资源对象\n可以通过使用多个Label Selector进行组合来实现复杂的条件选择，多个Label Selector使用逗号进行分割，几个条件之间是\"AND\"的关系，例如：\nname = redis-slave,env != pro\n\nLabel Selector在k8s中的有如下重要场景：\n* kube-contoller进程通过资源对象RC上定义的Label Selector来筛选要监控的Pod副本的数量，从而实现Pod副本的数量始终符合预期设定的全自动控制流程。\n* kube-proxy进程通过Service的Label Selector来选择对应的Pod，自动建立起每个Service到对应Pod的请求转发路由表，从而实现Service的智能路由负载均衡机制。\n* 通过对某些Node定义特定的Label，并且在Pod定义文件中使用NodeSelector这种标签调度策略，kube-schedule进程可以实现Pod\"定向调度\"的特性。\n总结：使用Label可以给资源对象创建多组标签，Label和Label Selector共同构成了k8s系统中最核心的应用模型，使得被管理对象能够被精细的分组管理，同时实现了整个集群的高可用性。\n\n\n### Replication Controller\n\nRC定义了一个期望的场景，即声明某种Pod的副本数量在任意时刻都符合某个预期值。所以RC的定义包括如下几个部分：\n* Pod期待的副本数\n* 用于筛选目标Pod的Label Selector\n* 当Pod的副本数量小于预期数量时，用户创建新Pod的Pod模板\n\n当我们定义了一个RC，并提交到k8s集群以后，Master节点上的Controller Manager组件就会得到通知，定期巡检系统中当前存活的目标Pod，并确保目标Pod的实例的数量刚好等于此Pod的期望值，如果有过多的Pod副本在运行，系统就会停掉一些Pod，否则系统会在创建一些Pod，通过RC，k8s实现了用户应用集群的高可用性，也大大减少了运维的手工操作。\n此外，在运行时，我们可以通过修改RC的副本数量，来实现Pod的动态缩放功能。\n需要注意的是，删除RC定义并不会影响通过该RC已创建好的Pod，为了删除所有的Pod，可以设置副本数为0，然后更新该RC，或者使用kubectl工具命令来一次性删除RC及其管理的Pod。\n当我们的应用升级时，通常会build一个新的Docker镜像，并用新的镜像版本来替换旧的版本的方式来达到目的。如果我们想要平滑的升级，即停止一台旧的，启动一台新的，在整个升级过程中，此消彼长，而运行中的Pod数量始终是10个，几分钟过后，当所有的Pod都已经是新版本时，升级过程完成。通过RC的机制，k8s可以很容易的实现\"滚动升级\"。\n在新版本中k8s新增加了一个Replica Set资源对象，它和RC唯一的区别是：Replica Set是基于集合的Label Selector，而RC是基于等式的Label Selector.当前我们很少单独使用Replica Set，它主要被Deployment这个更高层次的资源对象所使用，从而形成一整套Pod创建、删除、更新的编排机制，当我们使用Deployment时，无需关心它是如何创建和维护Replica Set的，这一切都是自动发生的.\n\n最后，我们总结下关于RC的一些特性和作用：\n* 在大多数情况下，我们通过定义一个RC实现Pod的创建过程及副本数量的自动控制\n* RC里包括完成的Pod定义模板\n* RC通过Label Selector机制实现对Pod副本的自动控制\n* 通过改变RC里的Pod副本数量，可以实现Pod的扩容和缩容功能\n* 通过改变RC里Pod模板中的镜像版本，可以实现Pod的滚动升级功能\n\n\n### Deployment\nDeployment是加强版的RC，它是为了更好的解决Pod的编排问题，在内部使用了Replica Set来实现相应的目的。Deployment的典型使用场景如下：\n* 创建一个Deployment对象来生成对应的Replica Set并完成Pod副本的创建过程。\n* 检查Deployment的状态来查看部署动作是否完成(Pod副本的数量是否达到预期的值)\n* 更新Deployment以创建新的Pod(比如镜像升级)\n* 如果当前Deployment不稳定，则回滚到一个早先的Deployment版本\n* 暂停Deployment以便于一次性修改多个Pod模板的配置项，之后在恢复Deployment，进行新的发布\n* 扩展Deployment以应对高负载\n* 查看Deployment的状态，以此作为发布是否成功的指标\n* 清理不再需要的旧版本的ReplicaSets\n其中Replica Set的名称以Deployment的名称为前缀，Pod的命名以Deployment对应的Replica Set的名字作为前缀，这种命名很清晰的表明了一个Replica Set创建了哪些Pod，对于Pod滚动升级这种复杂的过程来说，很容易进行排查错误。\n\n### Horizontal Pod Autoscaler\n前面我们提到，通过手工执行kubectl scale命令，可以实现Pod的扩容和缩容，但是这并不符合Google对k8s的定位目标————自动化、智能化，分布式系统应该可以根据当前负载的变化情况自动触发水平扩展或缩容的行为，因为这一过程可能是频繁发生的、不可预料的，所以手动来控制的方式不现实。\nHPA与RC、Deployment一样，也属于一种资源对象，通过追踪分析RC控制的所有目标Pod的负载变化情况，来确定是否需要针对性的调整目标Pod的副本数，这是HPA的实现原理，当前，HPA可以有如下两种方式作为Pod负载的度量指标：\n* CPUUtilizationPercentage\n* 应用程序自定义的度量指标，比如服务在每秒内的相应请求数(TPS或QPS)\nCPUUtilizationPercentage是一个算术平均值，即目标Pod所有副本自身的CPU利用率的平均值，一个Pod自身的CPU利用率是该Pod当前CPU的使用量(通常是一分钟内的平均值)除以它的Pod Request的值。比如：我们定义一个Pod的Pod Request为0.4，而当前Pod的CPU使用量为0.2，则它的CPU使用率为50%，如此一来，我们便可以算出来一个RC控制的所有Pod副本的CPU利用率的算术平均值了，如果某一时刻CPUUtilizationPercentage的值超过了80%，则意味着当前Pod的副本数很可能不足以支撑接下来更多的请求，需要进行动态扩容，而当请求高峰时段过去后，Pod的CPU利用率又会降下来，此时对应的Pod的副本数应该自动减少到一个合理的水平。\n\n### StatefulSet\n在k8s系统中，Pod的管理对象RC、Deployment、DaemonSet和Job都是无状态的服务。但现实中有很多服务是有状态的，比如Mysql集群、MongoDB集群、Akka集群、Zookeeper集群等，这些集群有如下共同点：\n* 每个节点都有一个固定的身份ID，通过这个ID，集群中的成员可以互相发现并进行通信\n* 集群的规模比较固定，不能随意变动\n* 即群里的每个节点都是有状态的，通常会持久化数据到永久存储中\n* 如果磁盘损坏，则集群里的某个节点无法正常运行，集群功能受损\n如果用RC/Deployment控制的Pod副本数的方式来实现上述有状态的集群，则我们会发现第一点是无法满足的，因为Pod的名称是随机产生的，Pod的IP地址也是在运行期才确定且可能有变动的，我们事先无法为每个Pod确定唯一不变的ID，另外，为了能够在其他节点上恢复某个失败的节点，这种集群中的Pod需要挂接某种共享存储，为了解决这个问题，k8s引入了StatefulSet这个新的资源对象，它有如下特性：\n* StatefulSet里的每个Pod都有稳定、唯一的网络标识，可以用来发现集群内的其他成员。假设StatefulSet的名字叫kafka，那么它的第一个Pod叫kakfa-0，第二个叫kafka-1，以此类推\n* StatefulSet控制的Pod副本的启停顺序是受控的，操作第n个Pod时，前n-1个Pod已经是运行且准备好的状态\n* StatefulSet里的Pod采用稳定的持久化存储卷，通过PV/PVC来实现，为了保护数据的安全，删除Pod时默认不会删除与StatefulSet相关的存储卷\nStatefulSet除了要与PV卷捆绑使用以存储Pod的状态数据，还要与Headless Service配合使用，即在每个StatefulSet的定义中要声明它属于哪个Headless Service。Headless Service与Service的区别在于，它没有Cluster IP，如果解析Headless Service的DNS域名，则返回的是该Service对应的全部Pod的Endpoint列表，StatefulSet在Headless Service的基础上又为StatefulSet控制的每一个Pod实例创建了一个DNS域名，域名格式如下：\n```shell\n$(podname).$(headless Service name)\n```\n比如一个3节点的Kafka的StatefulSet集群，对应的Headless Service的名称为kafka，StatefulSet的名称为kafka，则StatefulSet里面的3个Pod的DNS名称分别为：kafka-0.kafka、kafka-1.kafka、kafka-2.kafka，这些DNS名称可以直接在集群的配置文件中固定下来。\n\n### Volume\nVolume是Pod中能够被多个容器访问的共享目录，它与Docker中的Volume比较类似，但两者不能等价。首先，k8s中的Volume定义在Pod上，然后被一个Pod里面的多个容器挂载到具体的文件目录下；其次，k8s中的Volume与Pod的生命周期相同，但与容器的生命周期无关，当容器终止或者重启时，Volume中的数据也不会丢失。最后，k8s的Volume支持多种类型的Volume，例如：GlusterFS、Ceph等先进的分布式文件系统。\nVolume的使用比较简单，在大多少情况下，我们只需要先在Pod上声明一个Volume，然后在容器里引用该Volume，并挂载到容器里的某个目录上。\n除了可以让一个Pod里的多个容器共享文件、让容器的数据写到宿主机的磁盘上或者写文件到网络存储中，k8s的Volume还扩展出了一种非常有实用价值的功能，即容器配置文件集中化定义和管理，这是通过ConfigMap资源对象来实现的。\n### Persistent Volume\n之前我们提到的Volume是定义在Pod上的，属于计算资源的一部分，而网络存储是相对独立于计算资源而存在的一种实体资源，比如在使用虚拟机的情况下，我们通常会先定义一个网络存储，然后从中划出一个网盘并挂接到虚拟机上。PV(Persistent Volume)和与之相关联的PVC(Persistent Volume Claim)也起到了类似的作用.\nPV可以理解成k8s集群中某个网络存储中对应的一块存储，它与Volume类似，但是有如下区别：\n* PV只能是网络存储，不属于任何Node，但可以在每个Node上使用\n* PV并不是定义在Pod上的，而是独立于Pod之外定义\n* PV目前支持的类型包括：NFS、gcePersistentDisk、AWSElasticBlockStore、GlusterFS等\n如果某个Pod想要申请某种类型的PV，则需要先定义一个PVC对象，然后在Pod的Volume定义中引用上述PVC即可。\n另外PV是有状态的对象：\n* Available：空闲状态\n* Bound: 已经绑定到某个PVC上\n* Released：对应的PVC已经删除，但资源还没有被集群回收\n* Failed：PV自动回收失败\n\n### Namespace\nNamespace在很多情况下用于实现多租户的资源隔离，Namespace通过将集群内部的资源对象\"分配\"到不同的Namespace中，形成逻辑上分组的不同项目、小组或用户组，便于不同的分组在共享使用整个集群的资源的同时还能被分别管理。\n\nk8s集群在启动后，会创建一个名为\"default\"的Namespace，如果不特别指明Namespace，则用户创建的Pod、RC、Service都将被系统创建到这个默认的default名下。\n当我们为每个租户创建一个Namespace来实现多租户的资源隔离时，还能结合k8s的资源配额管理，限定不同租户能占用的资源，例如CPU使用量、内存使用量等。\n\n### Annotation\nAnnotation和Label类似，也是使用kv对定义，不同的是，Label有严格的命名规则，它定义的是k8s对象的元数据，并且用户Label Selector。而Annotation则是用户任意定义的附加信息，以便于外部工具进行查找。很多时候，k8s的模块自身会通过Annotation的方式标记资源对象的一些特殊信息。通常来说，用Annotation来记录如下信息：\n* build信息、release信息、Docker镜像信息等，例如时间戳、release id号、PR号、镜像hash值、docker registry地址等\n* 日志库、监控库、分析库等资源库的地址信息\n* 程序调试工具信息，例如工具名称、版本号等\n* 团队的联系信息，例如：手机号、负责人名称、网址等\n\n","tags":["k8s"]},{"title":"《Haskell趣学指南》- 笔记","url":"/blog/2018/08/19/Haskell趣学指南-笔记/","content":"\n### 模式匹配与递归\n\n### 类型\n\n### 类型类\n\n### 常用函数\n\n### Functor\n\n#### Functor定律\n\n### Applicative\n\n#### Applicative定律\n\n### Monoid\n#### Monoid定律\n\n### Monad\n\n#### Monad定律\n\n#### IO Monad\n\n#### Writer Monad\n\n#### Reader Monad\n\n#### State Monad\n\n#### Error Monad\n\n#### 自定义Monad\n\n\n","tags":["haskell"]},{"title":"Dubbo源码阅读之注册中心","url":"/blog/2018/08/17/Dubbo源码阅读之注册中心/","content":">注册中心是Dubbo实现服务化管理的核心组件,类似于目录服务的作用,主要用来存储Dubbo发布的服务信息(譬如提供者url串、路由信息等),Dubbo框架支持zookeeper、redis、multicast等注册中心,下面我们就详细看下Dubbo的注册中心是如何实现的。\n\n先来看下注册中心相关的类图\n![](img/registry.png)\n\n### Registry接口\n```java\npublic interface Registry extends Node, RegistryService {\n}\n```\n#### Node接口\n```java\npublic interface Node {\n    /**\n     * 获取url\n     * @return url.\n     */\n    URL getUrl();\n\n    /**\n     * 是否可用\n     * @return available.\n     */\n    boolean isAvailable();\n\n    /**\n     * 销毁\n     */\n    void destroy();\n}\n```\n\n#### RegistryService接口\n```java\npublic interface RegistryService {\n    /**\n     * 注册数据，例如：提供者服务，消费者服务，路由规则，覆盖规则和其他数据\n     * 注册时需要满足以下邀约：\n     * 1、当Url设置check = false参数时，注册失败时，异常不会抛出，并且会在后台重试，否则，异常将会抛出\n     * 2、当url设置dynamic=false参数时，它需要被永久存储，否则，当注册有异常退出时，它应该被自动删除掉\n     * 3、当url设置category=routers参数时，这意味着分类存储，默认的分类是提供者，并且数据可以通过分类部分得到通知\n     * 4、当注册中心重启，网络抖动，数据不可以丢失，包括自动从虚线中删除数据\n     * 5、允许具有相同URL但是参数不同的URL共存，他们不可以互相覆盖\n     *\n     * @param url 注册信息，不允许为空\n     * 例如：dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&application=kylin\n     */\n    void register(URL url);\n\n    /**\n     * 取消注册\n     * 1、如果它是dynamic=false的持久化存储数据，注册信息不可以发现时，会抛出IllegalStateException异常，\n     *    否则它是忽略的。\n     * 2、根据完整的url匹配进行取消注册\n     * @param url 注册信息,不可以为空 \n     * 例如： dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&application=kylin\n     */\n    void unregister(URL url);\n\n    /**\n     * 订阅符合条件的注册数据，并在注册数据发生改变时自动推送\n     *\n     * 1、当URL设置check=false参数时，当注册失败时，异常不会抛出，并在后台重试。\n     * 2、当url设置category=routers时，它只会通知指定的分类数据，多个分类用逗号分隔，\n     *      并允许使用*号匹配，这表明所有分类数据都已经订阅。\n     * 3、允许interface, group, version,classifier作为一个条件查询，\n     *      例如：interface=com.alibaba.foo.BarService&version=1.0.0\n     * 4、查询条件允许*号匹配，订阅所有接口的所有数据包的所有版本,\n     *      例如：interface=*&group=*&version=*&classifier=*\n     * 5、当注册中心重启、网络抖动时，有必要自动恢复订阅请求。\n     * 6、允许具有相同的url但是参数不同的URL共存,它们不可以互相覆盖\n     * 7、订阅的进程必须是阻塞的，当第一条通知完成后返回。\n     * @param url 订阅条件，不允许为空\n     * 例如: consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&application=kylin\n     * @param listener 变更事件的监听者，不可以为空\n     */\n    void subscribe(URL url, NotifyListener listener);\n\n    /**\n     * 取消订阅\n     *  1、如果没有订阅，直接忽略\n     *  2、取消订阅，需要URL全匹配\n     * @param url  订阅条件，不可以为空\n     * 例如： consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&application=kylin\n     * @param listener 变更事件的监听者,不允许为空\n     */\n    void unsubscribe(URL url, NotifyListener listener);\n\n    /**\n     * 查询符合条件的注册数据，对应于订阅的push模式，这是pull模式并只返回一个结果\n     * @param url 查询条件，不允许为空\n     *   e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&application=kylin\n     * @return 已注册的信息列表, 可能为空, 意义与{NotifyListener#notify(List<URL>)}的参数相同.\n     */\n    List<URL> lookup(URL url);\n}\n```\n\n### NotifyListener接口\n监听器，监听服务的变更\n```java\npublic interface NotifyListener {\n    /**\n     * 当收到服务更改的通知时触发该方法\n     * 1、始终是在服务接口和数据类型的纬度上通知。也就是说，不会通知属于一个服务的部分相同类型的数据，用户无需比较先前通知的结果\n     * 2、订阅时的第一个通知必须是服务所有类型的完整通知\n     * 3、在变更时，允许单独通知不同类型的数据，例如：providers, consumers, routers, overrides,它只允许通知其中一种类型，\n     *    但此类型的数据必须是完整的，而不是增量的\n     * 4、如果数据类型为空，则需要通过url数据的类别参数标识空协议\n     * 5、notifications保证通知的顺序(即registry的实现),例如：单线程推送、队列序列化、版本比较\n     * @param urls 已注册的信息列表,非空,这意味着，它和RegistryService#lookup(URL)方法的返回值相同.\n     */\n    void notify(List<URL> urls);\n}\n```\n\n### AbstractRegistry抽象类\n```java\npublic abstract class AbstractRegistry implements Registry {\n\n    /**\n     * URL地址分隔符，用来文件缓存，服务提供者URL分隔\n     * URL address separator, used in file cache, service provider URL separation\n     */\n    private static final char URL_SEPARATOR = ' ';\n    /**\n     * URL地址正则表达式分隔器，用来解析文件缓存中的服务提供者的URL列表\n     * 这里是空格分隔\n     * URL address separated regular expression for parsing the service provider URL list in the file cache\n     */\n    private static final String URL_SPLIT = \"\\\\s+\";\n    /**\n     * 日志输出\n     * Log output\n     */\n    protected final Logger logger = LoggerFactory.getLogger(getClass());\n    /**\n     * 本地磁盘缓存，其中key“value.registies”用来记录注册中心的列表。\n     * 其他的是通知服务提供者的列表\n     * Local disk cache, where the special key value.registies records the list of registry centers,\n     * and the others are the list of notified service providers\n     */\n    private final Properties properties = new Properties();\n    /**\n     * 文件缓存定时写线程\n     * File cache timing writing\n     */\n    private final ExecutorService registryCacheExecutor = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"DubboSaveRegistryCache\", true));\n    /**\n     * 是否同步保存文件\n     * Is it synchronized to save the file\n     */\n    private final boolean syncSaveFile;\n    /**\n     * 每次更新缓存文件时，都会自增，作为版本号\n     */\n    private final AtomicLong lastCacheChanged = new AtomicLong();\n    /**\n     * 已注册的地址\n     * 暴露的服务的URL集合，即export参数指定的URL\n     */\n    private final Set<URL> registered = new ConcurrentHashSet<URL>();\n    /**\n     * 已订阅的记录\n     * URL变化时，触发NotifyListener\n     * 例如：<服务提供者URL，OverrideListener>\n     */\n    private final ConcurrentMap<URL, Set<NotifyListener>> subscribed = new ConcurrentHashMap<URL, Set<NotifyListener>>();\n    /**\n     * 已通知的url\n     * 会将 <订阅url的服务唯一名称,待通知类别Url列表>写入注册中心缓存文件\n     * <订阅url,<待通知类别, 待通知类别Url列表>>\n     */\n    private final ConcurrentMap<URL, Map<String, List<URL>>> notified = new ConcurrentHashMap<URL, Map<String, List<URL>>>();\n\n    /**\n     * 注册中心URL\n     */\n    private URL registryUrl;\n    /**\n     * 本地磁盘缓存文件(dubbo注册中心缓存)\n     * Local disk cache file\n     */\n    private File file;\n\n    /**\n     *\n     * @param url multicast://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&dubbo=2.0.0&interface=com.alibaba.dubbo.registry.RegistryService&pid=3000&qos.port=22222&timestamp=1528800181027\n     */\n    public AbstractRegistry(URL url) {\n        //校验url不为空，并设置registryUrl = url\n        setUrl(url);\n        // Start file save timer\n        //是否同步保存文件，默认是异步\n        syncSaveFile = url.getParameter(Constants.REGISTRY_FILESAVE_SYNC_KEY, false);\n        //文件名，默认值是：C:\\Users\\Administrator/.dubbo/dubbo-registry-demo-provider-224.5.6.7:1234.cache\n        String filename = url.getParameter(Constants.FILE_KEY, System.getProperty(\"user.home\") + \"/.dubbo/dubbo-registry-\" + url.getParameter(Constants.APPLICATION_KEY) + \"-\" + url.getAddress() + \".cache\");\n        File file = null;\n        if (ConfigUtils.isNotEmpty(filename)) {\n            //创建文件目录\n            file = new File(filename);\n            if (!file.exists() && file.getParentFile() != null && !file.getParentFile().exists()) {\n                if (!file.getParentFile().mkdirs()) {\n                    throw new IllegalArgumentException(\"Invalid registry store file \" + file + \", cause: Failed to create directory \" + file.getParentFile() + \"!\");\n                }\n            }\n        }\n        this.file = file;\n        //加载注册中心缓存file\n        loadProperties();\n        //使用所有的url，进行通知\n        notify(url.getBackupUrls());\n    }\n\n\n    /**\n     * urls 为空的话，会根据url生成一个protocol = empty的URL放入urls并返回（即NotifyListener接口的第4条邀约）\n     * @param url 订阅url\n     * @param urls 注册中心url列表\n     * @return\n     */\n    protected static List<URL> filterEmpty(URL url, List<URL> urls) {\n        if (urls == null || urls.isEmpty()) {\n            //urls为空的话，则设置url的protocol = empty\n            List<URL> result = new ArrayList<URL>(1);\n            //设置protocol = empty\n            result.add(url.setProtocol(Constants.EMPTY_PROTOCOL));\n            return result;\n        }\n        return urls;\n    }\n\n    @Override\n    public URL getUrl() {\n        return registryUrl;\n    }\n\n    protected void setUrl(URL url) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"registry url == null\");\n        }\n\t//设置注册中心url\n        this.registryUrl = url;\n    }\n\n    public Set<URL> getRegistered() {\n        return registered;\n    }\n\n    public Map<URL, Set<NotifyListener>> getSubscribed() {\n        return subscribed;\n    }\n\n    public Map<URL, Map<String, List<URL>>> getNotified() {\n        return notified;\n    }\n\n    public File getCacheFile() {\n        return file;\n    }\n\n    public Properties getCacheProperties() {\n        return properties;\n    }\n\n    public AtomicLong getLastCacheChanged() {\n        return lastCacheChanged;\n    }\n\n    /**\n     * 保存注册中心缓存文件\n     * @param version 版本\n     */\n    public void doSaveProperties(long version) {\n        //如果version小与当前的版本号，说明在执行该方法时，lastCacheChanged又被更新了\n        //因此这里只需要直接返回,等待下一次执行\n        if (version < lastCacheChanged.get()) {\n            return;\n        }\n        if (file == null) {\n            return;\n        }\n        // Save\n        try {\n            //创建一个文件锁\n            File lockfile = new File(file.getAbsolutePath() + \".lock\");\n            if (!lockfile.exists()) {\n                lockfile.createNewFile();\n            }\n            RandomAccessFile raf = new RandomAccessFile(lockfile, \"rw\");\n            try {\n                FileChannel channel = raf.getChannel();\n                try {\n                    //获取排它锁\n                    FileLock lock = channel.tryLock();\n                    if (lock == null) {\n                        //不可以锁定注册中心缓存文件,忽略并稍后重试\n                        //可能多个java进程使用该文件，请配置：dubbo.registry.file=xxx.properties\n                        throw new IOException(\"Can not lock the registry cache file \" + file.getAbsolutePath() + \", ignore and retry later, maybe multi java process use the file, please config: dubbo.registry.file=xxx.properties\");\n                    }\n                    // Save\n                    try {\n                        //缓存文件不存在的话，新创建\n                        if (!file.exists()) {\n                            file.createNewFile();\n                        }\n                        FileOutputStream outputFile = new FileOutputStream(file);\n                        try {\n                            //保存properties文件\n                            properties.store(outputFile, \"Dubbo Registry Cache\");\n                        } finally {\n                            outputFile.close();\n                        }\n                    } finally {\n                        //释放锁\n                        lock.release();\n                    }\n                } finally {\n                    channel.close();\n                }\n            } finally {\n                raf.close();\n            }\n        } catch (Throwable e) {\n            if (version < lastCacheChanged.get()) {\n                return;\n            } else {\n                //如果version >= 当前版本的话，则执行异步保存properties文件\n                registryCacheExecutor.execute(new SaveProperties(lastCacheChanged.incrementAndGet()));\n            }\n            logger.warn(\"Failed to save registry store file, cause: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * 加载注册中心缓存文件\n     */\n    private void loadProperties() {\n        if (file != null && file.exists()) {\n            InputStream in = null;\n            try {\n                in = new FileInputStream(file);\n                properties.load(in);\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"Load registry store file \" + file + \", data: \" + properties);\n                }\n            } catch (Throwable e) {\n                logger.warn(\"Failed to load registry store file \" + file, e);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e) {\n                        logger.warn(e.getMessage(), e);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * 根据订阅url获取已缓存的待通知url列表\n     * 即从配置文件中找到属性key等于url.getServiceKey()的属性值\n     * @param url\n     * @return\n     */\n    public List<URL> getCacheUrls(URL url) {\n        for (Map.Entry<Object, Object> entry : properties.entrySet()) {\n            //订阅url的服务唯一名称\n            String key = (String) entry.getKey();\n            //类别待通知url列表，空格分隔\n            String value = (String) entry.getValue();\n\n            if (key != null && key.length() > 0 && key.equals(url.getServiceKey())\n                    //key的第一个字节是字母或者是下划线\n                    && (Character.isLetter(key.charAt(0)) || key.charAt(0) == '_')\n                    && value != null && value.length() > 0) {\n                //使用空格分隔value，拿到每一个url并放到List中\n                String[] arr = value.trim().split(URL_SPLIT);\n                List<URL> urls = new ArrayList<URL>();\n                for (String u : arr) {\n                    urls.add(URL.valueOf(u));\n                }\n                return urls;\n            }\n        }\n        return null;\n    }\n\n\n    @Override\n    public List<URL> lookup(URL url) {\n        List<URL> result = new ArrayList<URL>();\n        //根据订阅url获取已通知的url列表\n        Map<String, List<URL>> notifiedUrls = getNotified().get(url);\n        if (notifiedUrls != null && notifiedUrls.size() > 0) {\n            //notifiedUrls不为空\n            for (List<URL> urls : notifiedUrls.values()) {\n                for (URL u : urls) {\n                    //过滤掉protocol = empty的url\n                    if (!Constants.EMPTY_PROTOCOL.equals(u.getProtocol())) {\n                        result.add(u);\n                    }\n                }\n            }\n        } else {\n            final AtomicReference<List<URL>> reference = new AtomicReference<List<URL>>();\n            NotifyListener listener = new NotifyListener() {\n                @Override\n                public void notify(List<URL> urls) {\n                    reference.set(urls);\n                }\n            };\n            // 订阅逻辑保证第一次notify后再返回\n            subscribe(url, listener);\n            List<URL> urls = reference.get();\n            if (urls != null && !urls.isEmpty()) {\n                for (URL u : urls) {\n                    if (!Constants.EMPTY_PROTOCOL.equals(u.getProtocol())) {\n                        result.add(u);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public void register(URL url) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"register url == null\");\n        }\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Register: \" + url);\n        }\n        //保存注册url\n        registered.add(url);\n    }\n\n    @Override\n    public void unregister(URL url) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"unregister url == null\");\n        }\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Unregister: \" + url);\n        }\n        //取消注册url\n        registered.remove(url);\n    }\n\n    @Override\n    public void subscribe(URL url, NotifyListener listener) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"subscribe url == null\");\n        }\n        if (listener == null) {\n            throw new IllegalArgumentException(\"subscribe listener == null\");\n        }\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Subscribe: \" + url);\n        }\n        //保存订阅url\n        Set<NotifyListener> listeners = subscribed.get(url);\n        if (listeners == null) {\n            subscribed.putIfAbsent(url, new ConcurrentHashSet<NotifyListener>());\n            listeners = subscribed.get(url);\n        }\n        listeners.add(listener);\n    }\n\n    @Override\n    public void unsubscribe(URL url, NotifyListener listener) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"unsubscribe url == null\");\n        }\n        if (listener == null) {\n            throw new IllegalArgumentException(\"unsubscribe listener == null\");\n        }\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Unsubscribe: \" + url);\n        }\n        //取消订阅url的listener\n        Set<NotifyListener> listeners = subscribed.get(url);\n        if (listeners != null) {\n            listeners.remove(listener);\n        }\n    }\n\n    /**\n     * 恢复注册和订阅\n     * @throws Exception\n     */\n    protected void recover() throws Exception {\n        //获取已注册的地址\n        Set<URL> recoverRegistered = new HashSet<URL>(getRegistered());\n        if (!recoverRegistered.isEmpty()) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Recover register url \" + recoverRegistered);\n            }\n            for (URL url : recoverRegistered) {\n                //重新注册url\n                register(url);\n            }\n        }\n        //获取已订阅的记录\n        Map<URL, Set<NotifyListener>> recoverSubscribed = new HashMap<URL, Set<NotifyListener>>(getSubscribed());\n        if (!recoverSubscribed.isEmpty()) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Recover subscribe url \" + recoverSubscribed.keySet());\n            }\n            for (Map.Entry<URL, Set<NotifyListener>> entry : recoverSubscribed.entrySet()) {\n                URL url = entry.getKey();\n                for (NotifyListener listener : entry.getValue()) {\n                    //重新订阅\n                    subscribe(url, listener);\n                }\n            }\n        }\n    }\n\n    /**\n     * 通知\n     * @param urls 注册中心url\n     */\n    protected void notify(List<URL> urls) {\n        if (urls == null || urls.isEmpty()) {\n            return;\n        }\n        //遍历已订阅的记录（例如服务暴露时那里会订阅事件）\n        for (Map.Entry<URL, Set<NotifyListener>> entry : getSubscribed().entrySet()) {\n            //订阅url\n            URL url = entry.getKey();\n            //检测是否匹配\n            if (!UrlUtils.isMatch(url, urls.get(0))) {\n                continue;\n            }\n            Set<NotifyListener> listeners = entry.getValue();\n            if (listeners != null) {\n                for (NotifyListener listener : listeners) {\n                    try {\n                        //通知注册中心\n                        notify(url, listener, filterEmpty(url, urls));\n                    } catch (Throwable t) {\n                        logger.error(\"Failed to notify registry event, urls: \" + urls + \", cause: \" + t.getMessage(), t);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param url 订阅url\n     * provider://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&category=configurators&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=7444&side=provider&timestamp=1528870218728\n     * @param listener\n     * @param urls 待通知的urls\n     */\n    protected void notify(URL url, NotifyListener listener, List<URL> urls) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"notify url == null\");\n        }\n        if (listener == null) {\n            throw new IllegalArgumentException(\"notify listener == null\");\n        }\n        if ((urls == null || urls.isEmpty()) && !Constants.ANY_VALUE.equals(url.getServiceInterface())) {\n            logger.warn(\"Ignore empty notify urls for subscribe url \" + url);\n            return;\n        }\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Notify urls for subscribe url \" + url + \", urls: \" + urls);\n        }\n        //<category,List<URL>>\n        Map<String, List<URL>> result = new HashMap<String, List<URL>>();\n        //遍历待通知urls，根据url中的category参数进行分组，保存到result中\n        for (URL u : urls) {\n            //url和u是否匹配(url的范围是否比u大)\n            if (UrlUtils.isMatch(url, u)) {\n                //获取待通知url的category，默认值是providers\n                String category = u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);\n                List<URL> categoryList = result.get(category);\n                if (categoryList == null) {\n                    categoryList = new ArrayList<URL>();\n                    result.put(category, categoryList);\n                }\n                categoryList.add(u);\n            }\n        }\n        if (result.size() == 0) {\n            //类别待通知url列表为空，直接返回\n            return;\n        }\n        //下面会将notified中的url及其values.values中的URL保存到缓存文件中\n        Map<String, List<URL>> categoryNotified = notified.get(url);\n        if (categoryNotified == null) {\n            notified.putIfAbsent(url, new ConcurrentHashMap<String, List<URL>>());\n            categoryNotified = notified.get(url);\n        }\n        for (Map.Entry<String, List<URL>> entry : result.entrySet()) {\n            //类别\n            String category = entry.getKey();\n            //类别待通知url列表\n            List<URL> categoryList = entry.getValue();\n            //保存<类别,类别待通知url列表>\n            categoryNotified.put(category, categoryList);\n            //保存注册中心缓存文件(将订阅url、待通知url列表保存到缓存文件)\n            saveProperties(url);\n            //触发通知(类别待通知url列表)\n            listener.notify(categoryList);\n        }\n    }\n\n    /**\n     * 保存注册中心缓存文件\n     * @param url 订阅url\n     */\n    private void saveProperties(URL url) {\n        if (file == null) {\n            return;\n        }\n        try {\n            //保存待通知url\n            StringBuilder buf = new StringBuilder();\n            //根据订阅url获取类别map\n            Map<String, List<URL>> categoryNotified = notified.get(url);\n            if (categoryNotified != null) {\n                //遍历类别待通知url列表\n                for (List<URL> us : categoryNotified.values()) {\n                    for (URL u : us) {\n                        //将待通知url添加到buf中，多个地址使用空格分隔\n                        if (buf.length() > 0) {\n                            buf.append(URL_SEPARATOR);\n                        }\n                        buf.append(u.toFullString());\n                    }\n                }\n            }\n            //保存配置到properties文件<订阅url的服务唯一名称标识,类别待通知url列表>\n            properties.setProperty(url.getServiceKey(), buf.toString());\n            //获取版本号\n            long version = lastCacheChanged.incrementAndGet();\n            if (syncSaveFile) {\n                //同步保存缓存文件\n                doSaveProperties(version);\n            } else {\n                //异步保存缓存文件\n                registryCacheExecutor.execute(new SaveProperties(version));\n            }\n        } catch (Throwable t) {\n            logger.warn(t.getMessage(), t);\n        }\n    }\n\n    @Override\n    public void destroy() {\n        if (logger.isInfoEnabled()) {\n            //销毁注册中心\n            logger.info(\"Destroy registry:\" + getUrl());\n        }\n        Set<URL> destroyRegistered = new HashSet<URL>(getRegistered());\n        if (!destroyRegistered.isEmpty()) {\n            //遍历已注册的url\n            for (URL url : new HashSet<URL>(getRegistered())) {\n                if (url.getParameter(Constants.DYNAMIC_KEY, true)) {\n                    try {\n                        //url的dynamic = true，取消注册url\n                        unregister(url);\n                        if (logger.isInfoEnabled()) {\n                            logger.info(\"Destroy unregister url \" + url);\n                        }\n                    } catch (Throwable t) {\n                        logger.warn(\"Failed to unregister url \" + url + \" to registry \" + getUrl() + \" on destroy, cause: \" + t.getMessage(), t);\n                    }\n                }\n            }\n        }\n        Map<URL, Set<NotifyListener>> destroySubscribed = new HashMap<URL, Set<NotifyListener>>(getSubscribed());\n        if (!destroySubscribed.isEmpty()) {\n            //遍历已订阅的，挨个取消订阅\n            for (Map.Entry<URL, Set<NotifyListener>> entry : destroySubscribed.entrySet()) {\n                //订阅的url\n                URL url = entry.getKey();\n                for (NotifyListener listener : entry.getValue()) {\n                    try {\n                        //取消订阅url\n                        unsubscribe(url, listener);\n                        if (logger.isInfoEnabled()) {\n                            logger.info(\"Destroy unsubscribe url \" + url);\n                        }\n                    } catch (Throwable t) {\n                        logger.warn(\"Failed to unsubscribe url \" + url + \" to registry \" + getUrl() + \" on destroy, cause: \" + t.getMessage(), t);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getUrl().toString();\n    }\n\n    /**\n     * 异步保存缓存文件的线程\n     */\n    private class SaveProperties implements Runnable {\n        private long version;\n        private SaveProperties(long version) {\n            this.version = version;\n        }\n        @Override\n        public void run() {\n            doSaveProperties(version);\n        }\n    }\n}\n```\n\n### FailbackRegistry抽象类\nFailbackRegistry抽象类增加了失败重试功能，MulticastRegistry、ZookeeperRegistry等都继承自它.\n```java\npublic abstract class FailbackRegistry extends AbstractRegistry {\n\n    /**\n     * 注册中心失败重试线程\n     */\n    private final ScheduledExecutorService retryExecutor =\n            Executors.newScheduledThreadPool(1,\n                    new NamedThreadFactory(\"DubboRegistryFailedRetryTimer\", true));\n\n    /**\n     * 用于失败重试的定时器，定期检查是有失败的请求，如果有，则无限重试\n     */\n    private final ScheduledFuture<?> retryFuture;\n\n    /**\n     * 注册失败的URL列表\n     */\n    private final Set<URL> failedRegistered = new ConcurrentHashSet<URL>();\n\n    /**\n     * 取消注册失败的URL列表\n     */\n    private final Set<URL> failedUnregistered = new ConcurrentHashSet<URL>();\n\n    /**\n     * 订阅失败的记录\n     * <订阅url，监听>\n     */\n    private final ConcurrentMap<URL, Set<NotifyListener>> failedSubscribed = new ConcurrentHashMap<URL, Set<NotifyListener>>();\n\n    /**\n     * 取消订阅失败的记录\n     * <订阅url，监听>\n     */\n    private final ConcurrentMap<URL, Set<NotifyListener>> failedUnsubscribed = new ConcurrentHashMap<URL, Set<NotifyListener>>();\n\n    /**\n     * 通知失败的URL\n     */\n    private final ConcurrentMap<URL, Map<NotifyListener, List<URL>>> failedNotified = new ConcurrentHashMap<URL, Map<NotifyListener, List<URL>>>();\n\n    public FailbackRegistry(URL url) {\n        //设置注册中心url\n        super(url);\n        //获取url对应的重试间隔时间，默认值是5秒\n        int retryPeriod = url.getParameter(Constants.REGISTRY_RETRY_PERIOD_KEY, Constants.DEFAULT_REGISTRY_RETRY_PERIOD);\n        this.retryFuture = retryExecutor.scheduleWithFixedDelay(new Runnable() {\n            @Override\n            public void run() {\n                //检测并连接到注册中心\n                try {\n\t\t    //执行重试\n                    retry();\n                } catch (Throwable t) {\n                    logger.error(\"Unexpected error occur at failed retry, cause: \" + t.getMessage(), t);\n                }\n            }\n        }, retryPeriod, retryPeriod, TimeUnit.MILLISECONDS);\n    }\n\n    public Future<?> getRetryFuture() {\n        return retryFuture;\n    }\n\n    public Set<URL> getFailedRegistered() {\n        return failedRegistered;\n    }\n\n    public Set<URL> getFailedUnregistered() {\n        return failedUnregistered;\n    }\n\n    public Map<URL, Set<NotifyListener>> getFailedSubscribed() {\n        return failedSubscribed;\n    }\n\n    public Map<URL, Set<NotifyListener>> getFailedUnsubscribed() {\n        return failedUnsubscribed;\n    }\n\n    public Map<URL, Map<NotifyListener, List<URL>>> getFailedNotified() {\n        return failedNotified;\n    }\n\n    /**\n     * 添加订阅失败的记录\n     * @param url 订阅url\n     * @param listener\n     */\n    private void addFailedSubscribed(URL url, NotifyListener listener) {\n        Set<NotifyListener> listeners = failedSubscribed.get(url);\n        if (listeners == null) {\n            failedSubscribed.putIfAbsent(url, new ConcurrentHashSet<NotifyListener>());\n            listeners = failedSubscribed.get(url);\n        }\n        listeners.add(listener);\n    }\n\n    /**\n     * 移除订阅失败的记录（从三个列表中都移除）\n     * @param url 订阅url\n     * @param listener\n     */\n    private void removeFailedSubscribed(URL url, NotifyListener listener) {\n        //订阅失败的记录\n        Set<NotifyListener> listeners = failedSubscribed.get(url);\n        if (listeners != null) {\n            listeners.remove(listener);\n        }\n        //取消订阅失败的记录\n        listeners = failedUnsubscribed.get(url);\n        if (listeners != null) {\n            listeners.remove(listener);\n        }\n        //通知失败的记录\n        Map<NotifyListener, List<URL>> notified = failedNotified.get(url);\n        if (notified != null) {\n            notified.remove(listener);\n        }\n    }\n\n    @Override\n    public void register(URL url) {\n        //保存url到集合缓存中\n        super.register(url);\n        //从已失败的记录中移除该url\n        failedRegistered.remove(url);\n        failedUnregistered.remove(url);\n        try {\n            //向服务端发送注册请求\n            doRegister(url);\n        } catch (Exception e) {\n            Throwable t = e;\n\n            //注册中心url以及服务提供者url中的check = true且url不是消费端\n            boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)\n                    && url.getParameter(Constants.CHECK_KEY, true)\n                    && !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());\n            //判断是否需要跳过故障恢复(SkipFailbackWrapperException异常只是作为标记)\n            boolean skipFailback = t instanceof SkipFailbackWrapperException;\n            if (check || skipFailback) {\n                //如果启动检测或者跳过故障恢复的话，则直接抛出异常\n                if (skipFailback) {\n                    t = t.getCause();\n                }\n                //注册url到注册中心发生失败\n                throw new IllegalStateException(\"Failed to register \" + url + \" to registry \" + getUrl().getAddress() + \", cause: \" + t.getMessage(), t);\n            } else {\n                logger.error(\"Failed to register \" + url + \", waiting for retry, cause: \" + t.getMessage(), t);\n            }\n            //注册失败的话，将url保存到注册失败列表中，定期重试\n            failedRegistered.add(url);\n        }\n    }\n\n    @Override\n    public void unregister(URL url) {\n        //从缓存集合中移除该url\n        super.unregister(url);\n        //从失败列表中移除该url\n        failedRegistered.remove(url);\n        failedUnregistered.remove(url);\n        try {\n            //向服务端发送取消注册请求\n            doUnregister(url);\n        } catch (Exception e) {\n            Throwable t = e;\n            //判断是否启动检测\n            boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)\n                    && url.getParameter(Constants.CHECK_KEY, true)\n                    //非消费者\n                    && !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());\n            //是否跳过故障恢复\n            boolean skipFailback = t instanceof SkipFailbackWrapperException;\n            if (check || skipFailback) {\n                if (skipFailback) {\n                    t = t.getCause();\n                }\n                //直接抛出异常\n                throw new IllegalStateException(\"Failed to unregister \" + url + \" to registry \" + getUrl().getAddress() + \", cause: \" + t.getMessage(), t);\n            } else {\n                //取消注册url执行失败，等待重试\n                logger.error(\"Failed to unregister \" + url + \", waiting for retry, cause: \" + t.getMessage(), t);\n            }\n            //将失败的url保存到失败列表，等待定期重试\n            failedUnregistered.add(url);\n        }\n    }\n\n    @Override\n    public void subscribe(URL url, NotifyListener listener) {\n        //将订阅保存到集合缓存\n        super.subscribe(url, listener);\n        //从失败列表中移除该订阅记录\n        removeFailedSubscribed(url, listener);\n        try {\n            //向服务端发送订阅请求\n            doSubscribe(url, listener);\n        } catch (Exception e) {\n            Throwable t = e;\n            //订阅失败的话，则从缓存文件中获取该订阅url对应的注册中心url列表(即类别待通知url列表)\n            List<URL> urls = getCacheUrls(url);\n            if (urls != null && !urls.isEmpty()) {\n                //触发通知\n                notify(url, listener, urls);\n                //订阅失败，将使用缓存列表\n                logger.error(\"Failed to subscribe \" + url + \", Using cached list: \" + urls + \" from cache file: \" + getUrl().getParameter(Constants.FILE_KEY, System.getProperty(\"user.home\") + \"/dubbo-registry-\" + url.getHost() + \".cache\") + \", cause: \" + t.getMessage(), t);\n            } else {\n                //是否启动检测\n                boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)\n                        && url.getParameter(Constants.CHECK_KEY, true);\n                //是否跳过故障恢复\n                boolean skipFailback = t instanceof SkipFailbackWrapperException;\n                if (check || skipFailback) {\n                    if (skipFailback) {\n                        t = t.getCause();\n                    }\n                    throw new IllegalStateException(\"Failed to subscribe \" + url + \", cause: \" + t.getMessage(), t);\n                } else {\n                    //订阅失败，等待重试\n                    logger.error(\"Failed to subscribe \" + url + \", waiting for retry, cause: \" + t.getMessage(), t);\n                }\n            }\n            //添加到订阅失败列表，请求重试\n            addFailedSubscribed(url, listener);\n        }\n    }\n\n    @Override\n    public void unsubscribe(URL url, NotifyListener listener) {\n        //将订阅从集合缓存中移除\n        super.unsubscribe(url, listener);\n        //从失败列表中移除订阅\n        removeFailedSubscribed(url, listener);\n        try {\n            //向服务端发送取消订阅请求\n            doUnsubscribe(url, listener);\n        } catch (Exception e) {\n            Throwable t = e;\n            //是否启动检测\n            boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)\n                    && url.getParameter(Constants.CHECK_KEY, true);\n            //是否跳过故障恢复\n            boolean skipFailback = t instanceof SkipFailbackWrapperException;\n            if (check || skipFailback) {\n                if (skipFailback) {\n                    t = t.getCause();\n                }\n                throw new IllegalStateException(\"Failed to unsubscribe \" + url + \" to registry \" + getUrl().getAddress() + \", cause: \" + t.getMessage(), t);\n            } else {\n                //取消订阅失败，等待重试\n                logger.error(\"Failed to unsubscribe \" + url + \", waiting for retry, cause: \" + t.getMessage(), t);\n            }\n            //添加到失败列表中，定期重试\n            Set<NotifyListener> listeners = failedUnsubscribed.get(url);\n            if (listeners == null) {\n                failedUnsubscribed.putIfAbsent(url, new ConcurrentHashSet<NotifyListener>());\n                listeners = failedUnsubscribed.get(url);\n            }\n            listeners.add(listener);\n        }\n    }\n\n    @Override\n    protected void notify(URL url, NotifyListener listener, List<URL> urls) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"notify url == null\");\n        }\n        if (listener == null) {\n            throw new IllegalArgumentException(\"notify listener == null\");\n        }\n        try {\n            //执行通知(调用父类中的notify方法)\n            doNotify(url, listener, urls);\n        } catch (Exception t) {\n            //通知失败，添加到失败列表，定期重试\n            Map<NotifyListener, List<URL>> listeners = failedNotified.get(url);\n            if (listeners == null) {\n                failedNotified.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, List<URL>>());\n                listeners = failedNotified.get(url);\n            }\n            listeners.put(listener, urls);\n            logger.error(\"Failed to notify for subscribe \" + url + \", waiting for retry, cause: \" + t.getMessage(), t);\n        }\n    }\n\n    protected void doNotify(URL url, NotifyListener listener, List<URL> urls) {\n        super.notify(url, listener, urls);\n    }\n\n    @Override\n    protected void recover() throws Exception {\n        //获取已注册列表\n        Set<URL> recoverRegistered = new HashSet<URL>(getRegistered());\n        if (!recoverRegistered.isEmpty()) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Recover register url \" + recoverRegistered);\n            }\n            //将已注册的添加到失败列表中，等待恢复\n            for (URL url : recoverRegistered) {\n                failedRegistered.add(url);\n            }\n        }\n        //获取已订阅的列表\n        Map<URL, Set<NotifyListener>> recoverSubscribed = new HashMap<URL, Set<NotifyListener>>(getSubscribed());\n        if (!recoverSubscribed.isEmpty()) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Recover subscribe url \" + recoverSubscribed.keySet());\n            }\n            for (Map.Entry<URL, Set<NotifyListener>> entry : recoverSubscribed.entrySet()) {\n                URL url = entry.getKey();\n                for (NotifyListener listener : entry.getValue()) {\n                    //将已订阅的添加到失败列表中，等待恢复\n                    addFailedSubscribed(url, listener);\n                }\n            }\n        }\n    }\n\n    /**\n     * 重试 之前操作失败的 记录\n     */\n    protected void retry() {\n        if (!failedRegistered.isEmpty()) {\n            //处理注册失败的数据(重新注册)\n            Set<URL> failed = new HashSet<URL>(failedRegistered);\n            if (failed.size() > 0) {\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"Retry register \" + failed);\n                }\n                try {\n                    for (URL url : failed) {\n                        try {\n                            //重试注册\n                            doRegister(url);\n                            //重新注册成功，则将其从失败列表中移除\n                            failedRegistered.remove(url);\n                        } catch (Throwable t) {\n                            // Ignore all the exceptions and wait for the next retry\n                            //忽略所有的异常，等待下次重试\n                            logger.warn(\"Failed to retry register \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                        }\n                    }\n                } catch (Throwable t) {\n                    logger.warn(\"Failed to retry register \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n        if (!failedUnregistered.isEmpty()) {\n            //处理取消注册失败的数据(重新执行取消注册)\n            Set<URL> failed = new HashSet<URL>(failedUnregistered);\n            if (!failed.isEmpty()) {\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"Retry unregister \" + failed);\n                }\n                try {\n                    for (URL url : failed) {\n                        try {\n                            //重试取消注册\n                            doUnregister(url);\n                            //重试成功，则从失败列表中移除出去\n                            failedUnregistered.remove(url);\n                        } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\n                            logger.warn(\"Failed to retry unregister  \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                        }\n                    }\n                } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\n                    logger.warn(\"Failed to retry unregister  \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n        if (!failedSubscribed.isEmpty()) {\n            //处理订阅失败的数据\n            Map<URL, Set<NotifyListener>> failed = new HashMap<URL, Set<NotifyListener>>(failedSubscribed);\n            for (Map.Entry<URL, Set<NotifyListener>> entry : new HashMap<URL, Set<NotifyListener>>(failed).entrySet()) {\n                if (entry.getValue() == null || entry.getValue().size() == 0) {\n                    //将待通知url列表为空的数据移除出去\n                    failed.remove(entry.getKey());\n                }\n            }\n            if (failed.size() > 0) {\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"Retry subscribe \" + failed);\n                }\n                try {\n                    for (Map.Entry<URL, Set<NotifyListener>> entry : failed.entrySet()) {\n                        URL url = entry.getKey();\n                        Set<NotifyListener> listeners = entry.getValue();\n                        for (NotifyListener listener : listeners) {\n                            try {\n                                //重试订阅\n                                doSubscribe(url, listener);\n                                //订阅成功，从失败列表中移除出去\n                                listeners.remove(listener);\n                            } catch (Throwable t) {\n                                logger.warn(\"Failed to retry subscribe \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                            }\n                        }\n                    }\n                } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\n                    logger.warn(\"Failed to retry subscribe \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n        if (!failedUnsubscribed.isEmpty()) {\n            //处理取消订阅失败的数据\n            Map<URL, Set<NotifyListener>> failed = new HashMap<URL, Set<NotifyListener>>(failedUnsubscribed);\n            for (Map.Entry<URL, Set<NotifyListener>> entry : new HashMap<URL, Set<NotifyListener>>(failed).entrySet()) {\n                if (entry.getValue() == null || entry.getValue().isEmpty()) {\n                    //将待通知url列表为空的数据移除出去\n                    failed.remove(entry.getKey());\n                }\n            }\n            if (failed.size() > 0) {\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"Retry unsubscribe \" + failed);\n                }\n                try {\n                    for (Map.Entry<URL, Set<NotifyListener>> entry : failed.entrySet()) {\n                        URL url = entry.getKey();\n                        Set<NotifyListener> listeners = entry.getValue();\n                        for (NotifyListener listener : listeners) {\n                            try {\n                                //重试取消订阅\n                                doUnsubscribe(url, listener);\n                                //重试成功，从失败列表中移除\n                                listeners.remove(listener);\n                            } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\n                                logger.warn(\"Failed to retry unsubscribe \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                            }\n                        }\n                    }\n                } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\n                    logger.warn(\"Failed to retry unsubscribe \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n        if (!failedNotified.isEmpty()) {\n            //处理通知失败的数据\n            Map<URL, Map<NotifyListener, List<URL>>> failed = new HashMap<URL, Map<NotifyListener, List<URL>>>(failedNotified);\n            for (Map.Entry<URL, Map<NotifyListener, List<URL>>> entry : new HashMap<URL, Map<NotifyListener, List<URL>>>(failed).entrySet()) {\n                if (entry.getValue() == null || entry.getValue().size() == 0) {\n                    failed.remove(entry.getKey());\n                }\n            }\n            if (failed.size() > 0) {\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"Retry notify \" + failed);\n                }\n                try {\n                    for (Map<NotifyListener, List<URL>> values : failed.values()) {\n                        for (Map.Entry<NotifyListener, List<URL>> entry : values.entrySet()) {\n                            try {\n                                NotifyListener listener = entry.getKey();\n                                List<URL> urls = entry.getValue();\n                                //重试通知\n                                listener.notify(urls);\n                                //重试成功，从失败列表中移除\n                                values.remove(listener);\n                            } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\n                                logger.warn(\"Failed to retry notify \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                            }\n                        }\n                    }\n                } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\n                    logger.warn(\"Failed to retry notify \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void destroy() {\n        //调用父类的销毁逻辑,取消注册等\n        super.destroy();\n        try {\n            //停止定时重试线程\n            retryFuture.cancel(true);\n        } catch (Throwable t) {\n            logger.warn(t.getMessage(), t);\n        }\n    }\n\n    // ==== Template method ====\n\n    /**\n     * 注册\n     * @param url\n     */\n    protected abstract void doRegister(URL url);\n\n    /**\n     * 取消注册\n     * @param url\n     */\n    protected abstract void doUnregister(URL url);\n\n    /**\n     * 订阅\n     * @param url\n     * @param listener\n     */\n    protected abstract void doSubscribe(URL url, NotifyListener listener);\n\n    /**\n     * 取消订阅\n     * @param url\n     * @param listener\n     */\n    protected abstract void doUnsubscribe(URL url, NotifyListener listener);\n}\n```\n\n#### DubboRegistry类\n```java\npublic class DubboRegistry extends FailbackRegistry {\n\n    private final static Logger logger = LoggerFactory.getLogger(DubboRegistry.class);\n\n    /**\n     * 重新连接检测周期：3秒\n     */\n    private static final int RECONNECT_PERIOD_DEFAULT = 3 * 1000;\n\n    /**\n     * 重新连接定时线程\n     */\n    private final ScheduledExecutorService scheduledExecutorService =\n            Executors.newScheduledThreadPool(1, new NamedThreadFactory(\"DubboRegistryReconnectTimer\", true));\n\n    /**\n     * 重新连接定时器，定期检查连接是否可用，如果不可用，无限重连\n     */\n    private final ScheduledFuture<?> reconnectFuture;\n\n    /**\n     * 客户端获取处理的锁\n     * 锁定客户端实例的创建过程，防止重复客户端\n     */\n    private final ReentrantLock clientLock = new ReentrantLock();\n\n    private final Invoker<RegistryService> registryInvoker;\n    \n    /**\n     * 注册中心\n     */\n    private final RegistryService registryService;\n\n    public DubboRegistry(Invoker<RegistryService> registryInvoker, RegistryService registryService) {\n        //设置注册中心url（registryInvoker.getUrl()）\n        super(registryInvoker.getUrl());\n        this.registryInvoker = registryInvoker;\n        this.registryService = registryService;\n        // 启动重连线程\n        int reconnectPeriod = registryInvoker.getUrl()\n                .getParameter(Constants.REGISTRY_RECONNECT_PERIOD_KEY, RECONNECT_PERIOD_DEFAULT);\n        reconnectFuture = scheduledExecutorService.scheduleWithFixedDelay(new Runnable() {\n            @Override\n            public void run() {\n                //检测并连接到注册中心\n                try {\n                    connect();\n                } catch (Throwable t) { \n                    logger.error(\"Unexpected error occur at reconnect, cause: \" + t.getMessage(), t);\n                }\n            }\n        }, reconnectPeriod, reconnectPeriod, TimeUnit.MILLISECONDS);\n    }\n    \n    /**\n     * 连接到注册中心\n     */\n    protected final void connect() {\n        try {\n            //检测是否是已连接的\n            if (isAvailable()) {\n                return;\n            }\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Reconnect to registry \" + getUrl());\n            }\n            //连接前先上锁\n            clientLock.lock();\n            try {\n                // Double check whether or not it is connected\n                //再次检测是否已连接\n                if (isAvailable()) {\n                    return;\n                }\n                //执行恢复\n                recover();\n            } finally {\n                //释放锁\n                clientLock.unlock();\n            }\n        } catch (Throwable t) {\n            // 如果设置了check = true，则直接抛异常，否则忽略异常，等待下次重试\n            if (getUrl().getParameter(Constants.CHECK_KEY, true)) {\n                if (t instanceof RuntimeException) {\n                    throw (RuntimeException) t;\n                }\n                throw new RuntimeException(t.getMessage(), t);\n            }\n            logger.error(\"Failed to connect to registry \" + getUrl().getAddress() + \" from provider/consumer \" + NetUtils.getLocalHost() + \" use dubbo \" + Version.getVersion() + \", cause: \" + t.getMessage(), t);\n        }\n    }\n\n    @Override\n    public boolean isAvailable() {\n        //registryInvoker为空的话说明不可用，直接返回\n        if (registryInvoker == null) {\n            return false;\n        }\n        return registryInvoker.isAvailable();\n    }\n\n    @Override\n    public void destroy() {\n        super.destroy();\n        try {\n            if (!reconnectFuture.isCancelled()) {\n                //取消重连定时器\n                reconnectFuture.cancel(true);\n            }\n        } catch (Throwable t) {\n            logger.warn(\"Failed to cancel reconnect timer\", t);\n        }\n        //销毁registryInvoker\n        registryInvoker.destroy();\n    }\n\n    @Override\n    protected void doRegister(URL url) {\n        //交由registryService来完成\n        registryService.register(url);\n    }\n\n    @Override\n    protected void doUnregister(URL url) {\n        registryService.unregister(url);\n    }\n\n    @Override\n    protected void doSubscribe(URL url, NotifyListener listener) {\n        registryService.subscribe(url, listener);\n    }\n\n    @Override\n    protected void doUnsubscribe(URL url, NotifyListener listener) {\n        registryService.unsubscribe(url, listener);\n    }\n\n    @Override\n    public List<URL> lookup(URL url) {\n        return registryService.lookup(url);\n    }\n}\n```\nFailbackRegistry的注册中心实现类，如ZookeeperRegistry类等，将会在单独的小节进行详细讲解，这里就先不介绍了。\n\n### RegistryFactory接口\n```java\n@SPI(\"dubbo\")\npublic interface RegistryFactory {\n    /**\n     * 根据url获取注册中心实例\n     *\n     * 1、当设置check=false时，链接不会检测，除此之外当断开连接时将会抛异常\n     * 2、支持URL上的username:password授权认证\n     * 3、支持backup=10.20.153.10配置候选注册中心集群地址\n     * 4、支持file=registry.cache本地磁盘文件缓存\n     * 5、支持timeout=1000请求超时配置\n     * 6、支持session=60000配置session超时或者到期设置\n     * @param url 注册中心地址，不允许为空\n     * @return 注册中心引用，永不返回空值\n     */\n    @Adaptive({\"protocol\"})\n    Registry getRegistry(URL url);\n}\n```\n#### AbstractRegistryFactory抽象类\n```java\npublic abstract class AbstractRegistryFactory implements RegistryFactory {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractRegistryFactory.class);\n\n    /**\n     * 用来锁定获取注册中心实例时的过程\n     */\n    private static final ReentrantLock LOCK = new ReentrantLock();\n\n    /**\n     * 注册中心集合\n     * Map<RegistryAddress, Registry>\n     * key = multicast://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService\n     */\n    private static final Map<String, Registry> REGISTRIES = new ConcurrentHashMap<String, Registry>();\n\n    /**\n     * 获取所有注册中心\n     * @return all registries\n     */\n    public static Collection<Registry> getRegistries() {\n        return Collections.unmodifiableCollection(REGISTRIES.values());\n    }\n\n    /**\n     * 关闭所有创建的注册中心\n     */\n    public static void destroyAll() {\n        //锁定注册中心关闭过程\n        LOCK.lock();\n        try {\n            for (Registry registry : getRegistries()) {\n                try {\n                    //调用destroy()方法进行销毁\n                    registry.destroy();\n                } catch (Throwable e) {\n                    LOGGER.error(e.getMessage(), e);\n                }\n            }\n            //清理缓存\n            REGISTRIES.clear();\n        } finally {\n            //释放锁\n            LOCK.unlock();\n        }\n    }\n\n    @Override\n    public Registry getRegistry(URL url) {\n        //设置path属性\n        url = url.setPath(RegistryService.class.getName())\n                //添加interface = com.alibaba.dubbo.registry.RegistryService\n                .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName())\n                //移除export、refer参数\n                .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY);\n        //key = multicast://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService\n        String key = url.toServiceString();\n        // Lock the registry access process to ensure a single instance of the registry\n        //加锁,确保该key对应的注册中心为单例\n        LOCK.lock();\n        try {\n            Registry registry = REGISTRIES.get(key);\n            if (registry != null) {\n                //缓存中存在，直接返回\n                return registry;\n            }\n            //根据url创建注册中心实例，这里由子类来实现\n            registry = createRegistry(url);\n            if (registry == null) {\n\t        //创建失败\n                throw new IllegalStateException(\"Can not create registry \" + url);\n            }\n            //放入缓存，并返回\n            REGISTRIES.put(key, registry);\n            return registry;\n        } finally {\n            // 释放锁\n            LOCK.unlock();\n        }\n    }\n\n    /**\n     * 创建注册中心实例\n     * @param url 注册中心url\n     * @return\n     */\n    protected abstract Registry createRegistry(URL url);\n}\n```\nAbstractRegistryFactory的实现类，如ZookeeperRegistryFactory等类，将在相关的小节单独介绍，这里就不多介绍了。\n\n### Directory接口\n接下来我们看看那Directory接口相关的内容\n```java\npublic interface Directory<T> extends Node {\n\n    /**\n     * 获取服务类型\n     */\n    Class<T> getInterface();\n\n    /**\n     * 获取invokers列表\n     */\n    List<Invoker<T>> list(Invocation invocation) throws RpcException;\n}\n```\n\n#### AbstractDirectory抽象类\n```java\npublic abstract class AbstractDirectory<T> implements Directory<T> {\n    \n    /**\n     * 注册中心url\n     */\n    private final URL url;\n\n    /**\n     * Directory是否已销毁\n     */\n    private volatile boolean destroyed = false;\n\n    /**\n     * 消费者url\n     */\n    private volatile URL consumerUrl;\n\n    /**\n     * 路由列表\n     */\n    private volatile List<Router> routers;\n\n    public AbstractDirectory(URL url, URL consumerUrl, List<Router> routers) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"url == null\");\n        }\n        this.url = url;\n        this.consumerUrl = consumerUrl;\n        //设置路由\n        setRouters(routers);\n    }\n\t\n    /**\n     * 从此list方法返回的InvokerList，已经被Routers过滤\n     */\n    @Override\n    public List<Invoker<T>> list(Invocation invocation) throws RpcException {\n        if (destroyed) {\n            throw new RpcException(\"Directory already destroyed .url: \" + getUrl());\n        }\n        //根据invocation获取invokers列表(根据方法名查询缓存methodInvokerMap)\n        List<Invoker<T>> invokers = doList(invocation);\n        List<Router> localRouters = this.routers;\n        if (localRouters != null && !localRouters.isEmpty()) {\n\t    //遍历路由\n            for (Router router : localRouters) {\n                try {\n                    if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) {\n\t\t\t//如果url的runtime配置为true,则每次都会进行route\n\t\t\t//执行路由，进行过滤\n                        invokers = router.route(invokers, getConsumerUrl(), invocation);\n                    }\n                } catch (Throwable t) {\n                    logger.error(\"Failed to execute router: \" + getUrl() + \", cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n        return invokers;\n    }\n\n    /**\n     * 设置路由\n     * 1、添加：收到notify通知的routers、当前url的router参数、new MockInvokersSelector()\n     * 2、将routers排序\n     * 3、缓存routers\n     * @param routers 收到notify通知的routers\n     */\n    protected void setRouters(List<Router> routers) {\n        routers = routers == null ? new ArrayList<Router>() : new ArrayList<Router>(routers);\n        //获取路由工厂扩展名称\n        String routerkey = url.getParameter(Constants.ROUTER_KEY);\n        if (routerkey != null && routerkey.length() > 0) {\n            //根据路由工厂扩展名获取扩展实例\n            RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getExtension(routerkey);\n            //根据url获取路由实例，并放入routers\n            routers.add(routerFactory.getRouter(url));\n        }\n        //添加支持mock协议的invoker选择器\n        routers.add(new MockInvokersSelector());\n        //排序\n        Collections.sort(routers);\n        this.routers = routers;\n    }\n    /**\n     * 根据invocation获取invokers列表\n     * @param invocation\n     * @return\n     * @throws RpcException\n     */\n    protected abstract List<Invoker<T>> doList(Invocation invocation) throws RpcException;\n}\n```\n#### RegistryDirectory实现类\n该实现类，我们在上一小节《Dubbo源码阅读之服务引用》中已经详细介绍过，这里只简单看下剩余的方法\n```java\npublic class RegistryDirectory<T> extends AbstractDirectory<T> implements NotifyListener {\n\n    //缓存 <服务url, Invoker>\n    private volatile Map<String, Invoker<T>> urlInvokerMap;\n\n    //缓存 <服务方法名称,List<Invoker>>\n    private volatile Map<String, List<Invoker<T>>> methodInvokerMap;\n\n    /**\n     * 通过调用方法名从本地缓存中找到invokers\n     * @param invocation\n     * @return\n     */\n    @Override\n    public List<Invoker<T>> doList(Invocation invocation) {\n        if (forbidden) {\n            //1、没有服务提供者。 2、服务提供者被禁用\n            throw new RpcException(RpcException.FORBIDDEN_EXCEPTION,\n                \"No provider available from registry \" + getUrl().getAddress() + \" for service \" + getConsumerUrl().getServiceKey() + \" on consumer \" +  NetUtils.getLocalHost()\n                        + \" use dubbo version \" + Version.getVersion() + \", please check status of providers(disabled, not registered or in blacklist).\");\n        }\n        List<Invoker<T>> invokers = null;\n        Map<String, List<Invoker<T>>> localMethodInvokerMap = this.methodInvokerMap;\n        if (localMethodInvokerMap != null && localMethodInvokerMap.size() > 0) {\n            //获取调用的方法名称\n            String methodName = RpcUtils.getMethodName(invocation);\n            //获取调用的方法参数\n            Object[] args = RpcUtils.getArguments(invocation);\n            if (args != null && args.length > 0 && args[0] != null \n\t\t\t&& (args[0] instanceof String || args[0].getClass().isEnum())) {\n                //第一个参数是字符串类型或者枚举类型\n                //可以根据第一个参数枚举路由\n                invokers = localMethodInvokerMap.get(methodName + \".\" + args[0]);\n            }\n            if (invokers == null) {\n                //通过方法名称查询\n                invokers = localMethodInvokerMap.get(methodName);\n            }\n            if (invokers == null) {\n                //通过*查询\n                invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);\n            }\n            if (invokers == null) {\n                //遍历本地缓存，找到最后一个invokers\n                Iterator<List<Invoker<T>>> iterator = localMethodInvokerMap.values().iterator();\n                if (iterator.hasNext()) {\n                    invokers = iterator.next();\n                }\n            }\n        }\n        return invokers == null ? new ArrayList<Invoker<T>>(0) : invokers;\n    }\n\n    @Override\n    public boolean isAvailable() {\n        if (isDestroyed()) {\n            return false;\n        }\n        Map<String, Invoker<T>> localUrlInvokerMap = urlInvokerMap;\n        if (localUrlInvokerMap != null && localUrlInvokerMap.size() > 0) {\n            for (Invoker<T> invoker : new ArrayList<Invoker<T>>(localUrlInvokerMap.values())) {\n                if (invoker.isAvailable()) {\n                    //本地缓存中的invoker，如果有一个可用，就返回可用\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * 关闭所有的invokers\n     */\n    private void destroyAllInvokers() {\n        Map<String, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap;\n        if (localUrlInvokerMap != null) {\n            for (Invoker<T> invoker : new ArrayList<Invoker<T>>(localUrlInvokerMap.values())) {\n                try {\n\t\t    //销毁invoker\n                    invoker.destroy();\n                } catch (Throwable t) {\n                    logger.warn(\"Failed to destroy service \" + serviceKey + \" to provider \" + invoker.getUrl(), t);\n                }\n            }\n            //清空缓存\n            localUrlInvokerMap.clear();\n        }\n        methodInvokerMap = null;\n    }\n}\n\n````\n#### StaticDirectory实现类\n静态目录服务,它的所有Invoker通过构造函数传入,在服务消费方引用服务的时候,服务对多注册中心进行引用时,将Invokers集合直接传入StaticDirectory构造器,再由Cluster伪装成一个Invoker\n```java\npublic class ReferenceConfig<T> extends AbstractReferenceConfig {\n\n\tprivate T createProxy(Map<String, String> map) {\n\t\t// 省略其他代码.....\n\t\tfor (URL url : urls) {\n\t\t    //记录\"远程引用\"\n\t\t    invokers.add(refprotocol.refer(interfaceClass, url));\n\t\t    if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n\t\t\t// use last registry url\n\t\t\t//使用最后注册的url\n\t\t\tregistryURL = url;\n\t\t    }\n\t\t}\n\t\tif (registryURL != null) {\n\t\t    //有注册中心协议的URL\n\t\t    //使用AvailableCluster\n\t\t    URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);\n\t\t    invoker = cluster.join(new StaticDirectory(u, invokers));\n\t\t} else { \n\t\t    //不是注册中心的url\n\t\t    invoker = cluster.join(new StaticDirectory(invokers));\n\t\t}\n\t}\n}\n```\n来看看实现\n```java\npublic class StaticDirectory<T> extends AbstractDirectory<T> {\n\n    private final List<Invoker<T>> invokers;\n\n    public StaticDirectory(URL url, List<Invoker<T>> invokers, List<Router> routers) {\n        \n\tsuper(url == null && invokers != null && !invokers.isEmpty() ? invokers.get(0).getUrl() : url, routers);\n        \n\tif (invokers == null || invokers.isEmpty()) {\n            throw new IllegalArgumentException(\"invokers == null\");\n        }\n        \n\tthis.invokers = invokers;\n    }\n\n    @Override\n    public Class<T> getInterface() {\n        return invokers.get(0).getInterface();\n    }\n\n    @Override\n    public boolean isAvailable() {\n        if (isDestroyed()) {\n            return false;\n        }\n        for (Invoker<T> invoker : invokers) {\n            //是否可用\n            if (invoker.isAvailable()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public void destroy() {\n        if (isDestroyed()) {\n\t    //已经销毁，直接返回\n            return;\n        }\n        super.destroy();\n        for (Invoker<T> invoker : invokers) {\n            //销毁\n            invoker.destroy();\n        }\n        invokers.clear();\n    }\n\n    @Override\n    protected List<Invoker<T>> doList(Invocation invocation) throws RpcException {\n        //返回构造方法传入的invokers集合\n        return invokers;\n    }\n\n}\n```\n这一小节就先介绍到这里，后面我们详细介绍各个注册中心实现。\n\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之服务暴露","url":"/blog/2018/08/16/Dubbo源码阅读之服务暴露/","content":">本小节详细介绍dubbo服务的暴露，可以先看下之前的文章《Dubbo源码阅读之集成Spring(0201)》\n\n### ServiceConfig类变量\n在ServiceConfig类中定义了如下变量，下文中会用到，我们先简单看下：\n```java\n//代理工厂\nprivate static final ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();\n\n//Protocol实例\nprivate static final Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();\n\n/**\n * dubbo协议服务URL\n * 记录暴露的服务URL\n * dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=192.168.99.60&bind.port=20880&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=4328&qos.port=22222&side=provider&timestamp=1528278313225\n */\nprivate final List<URL> urls = new ArrayList<URL>();\n\n/**\n * 记录暴露的服务端点\n * subscribeUrl = provider://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&category=configurators&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=4328&side=provider&timestamp=1528278313225\n * registerUrl = dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=192.168.99.60&bind.port=20880&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=4328&qos.port=22222&side=provider&timestamp=1528278313225\n */\nprivate final List<Exporter<?>> exporters = new ArrayList<Exporter<?>>();\n```\n\n\n首先我们先来了解下ProxyFactory接口\n\n### ProxyFactory接口\n\n#### getInvoker方法\n\ngetInvoker方法是在ProxyFactory接口中定义的。ProxyFactory接口相关类图如下：\n![](img/ProxyFactory.png)\n\n```java\n/**\n * 代理工厂\n */\n@SPI(\"javassist\")\npublic interface ProxyFactory {\n    /**\n     * 创建代理\n     * @param invoker\n     * @return proxy\n     */\n    @Adaptive({Constants.PROXY_KEY})\n    <T> T getProxy(Invoker<T> invoker) throws RpcException;\n\n    /**\n     * 创建invoker\n     * @param <T>\n     * @param proxy 接口实现类或者代理类\n     * @param type 接口类型\n     * @param url 注册中心url，本地为injvm\n     * @return invoker\n     */\n    @Adaptive({Constants.PROXY_KEY})\n    <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException;\n}\n\n/**\n * 抽象ProxyFactory\n */\npublic abstract class AbstractProxyFactory implements ProxyFactory {\n    @Override\n    public <T> T getProxy(Invoker<T> invoker) throws RpcException {\n        //接口数组\n        Class<?>[] interfaces = null;\n        //获取url的interfaces参数的值\n        String config = invoker.getUrl().getParameter(\"interfaces\");\n        if (config != null && config.length() > 0) {\n            //使用逗号\",\"分隔interfaces参数值\n            String[] types = Constants.COMMA_SPLIT_PATTERN.split(config);\n            if (types != null && types.length > 0) {\n                //这里会将\"远程服务接口类、EchoService类\"放入到接口数组中\n                interfaces = new Class<?>[types.length + 2];\n                interfaces[0] = invoker.getInterface();\n                interfaces[1] = EchoService.class;\n                //然后将\"interfaces参数的值\"放入到接口数组\n                for (int i = 0; i < types.length; i++) {\n                    interfaces[i + 1] = ReflectUtils.forName(types[i]);\n                }\n            }\n        }\n        if (interfaces == null) {\n            //interfaces数组为空的话，则将远程服务接口类、EchoService类放入到接口数组中\n            interfaces = new Class<?>[]{invoker.getInterface(), EchoService.class};\n        }\n        //然后调用子类体实现来获取代理类\n        return getProxy(invoker, interfaces);\n    }\n\n    /**\n     * 获取代理类\n     * @param invoker\n     * @param types  远程服务接口类数组：\n     *               invoker.getInterface()、\n     *               EchoService.class、\n     *               invoker.getUrl().getParameter(\"interfaces\")\n     * @param <T>\n     * @return\n     */\n    public abstract <T> T getProxy(Invoker<T> invoker, Class<?>[] types);\n}\n\n/**\n * jdk动态代理\n */\npublic class JdkProxyFactory extends AbstractProxyFactory {\n\n    @Override\n    public <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {\n        //为interfaces这些接口生成代理类\n        return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),\n                interfaces, new InvokerInvocationHandler(invoker));\n    }\n\n    @Override\n    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {\n\t//返回AbstractProxyInvoker抽象类（该类后面的小节会详细介绍）\n        return new AbstractProxyInvoker<T>(proxy, type, url) {\n\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class<?>[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n\n                //根据方法名称methodName和参数类型parameterTypes获取到指定方法\n                Method method = proxy.getClass().getMethod(methodName, parameterTypes);\n\n                //使用参数arguments调用该代理类的method方法\n                return method.invoke(proxy, arguments);\n            }\n        };\n    }\n}\n\n/**\n * 使用Javassist\n */\npublic class JavassistProxyFactory extends AbstractProxyFactory {\n\n    @Override\n    public <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {\n        //为interfaces这些接口生成代理类(后面会分析Proxy类，这是dubbo自己定义的类)\n        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));\n    }\n\n    @Override\n    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {\n        \n\t// TODO Wrapper类不能正确处理带$的类名\n        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);\n        \n\t//返回AbstractProxyInvoker抽象类（该类后面的小节会详细介绍）\n        return new AbstractProxyInvoker<T>(proxy, type, url) {\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class<?>[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n\n                //使用Wrapper包装类类调用远程服务方法\n                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);\n            }\n        };\n    }\n}\n```\n在JavassistProxyFactory类的getInvoker方法实现中，会为相应的接口类(例如：com.alibaba.dubbo.demo.DemoService)生成包装类，生成的逻辑会在单独的小节介绍，这里只简单看下大概生成的类。\n#### Wrapper包装类\n```java\npublic class com.alibaba.dubbo.common.bytecode.Wrapper0 extends Wrapper{\n\tpublic Wrapper0(){}\n\t//属性名称数组\n\tpublic static String[] pns;\n\n\t//<属性名称，属性类型>\n\tpublic static java.util.Map pts;\n\t\n\t//所有方法名称数组\n\tpublic static String[] mns;\n\t\n\t//已声明的方法名称数组\n\tpublic static String[] dmns;\n\t\n\t//针对每个方法都会定义一个mts数组变量\n\tpublic static Class[] mts0;\n\n\tpublic String[] getPropertyNames(){ \n\t\treturn pns; \n\t}\n\tpublic boolean hasProperty(String n){\n\t\treturn pts.containsKey($1); \n\t}\n\tpublic Class getPropertyType(String n){ \n\t\treturn (Class)pts.get($1); \n\t}\n\tpublic String[] getMethodNames(){ \n\t\treturn mns; \n\t}\n\tpublic String[] getDeclaredMethodNames(){ \n\t\treturn dmns; \n\t}\n\tpublic void setPropertyValue(Object o, String n, Object v){ \n\t\tcom.alibaba.dubbo.demo.DemoService w; \n\t\ttry{ \n\t\t\tw = ((com.alibaba.dubbo.demo.DemoService)$1); \n\t\t}catch(Throwable e){ \n\t\t\tthrow new IllegalArgumentException(e); \n\t\t} \n\t\tthrow new com.alibaba.dubbo.common.bytecode.NoSuchPropertyException(\"Not found property \\\"\"+$2+\"\\\" filed or setter method in class com.alibaba.dubbo.demo.DemoService.\"); \n\t}\n\tpublic Object getPropertyValue(Object o, String n){ \n\t\tcom.alibaba.dubbo.demo.DemoService w; \n\t\ttry{ \n\t\t\tw = ((com.alibaba.dubbo.demo.DemoService)$1); \n\t\t}catch(Throwable e){ \n\t\t\tthrow new IllegalArgumentException(e); \n\t\t} \n\t\tthrow new com.alibaba.dubbo.common.bytecode.NoSuchPropertyException(\"Not found property \\\"\"+$2+\"\\\" filed or setter method in class com.alibaba.dubbo.demo.DemoService.\"); \n\t}\n\t/**\n\t * 执行服务接口的方法\n\t * $1/$2/$3/$4分别对应相应下标的参数\n\t * @param o 服务接口实例\n\t * @param n 服务接口方法名\n\t * @param p 服务接口方法参数\n\t * @param v 服务接口方法参数值\n\t * @return 服务接口调用返回值\n\t */\n\tpublic Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws java.lang.reflect.InvocationTargetException{\n\t\tcom.alibaba.dubbo.demo.DemoService w; \n\t\ttry{ \n\t\t\tw = ((com.alibaba.dubbo.demo.DemoService)$1); \n\t\t}catch(Throwable e){ \n\t\t\tthrow new IllegalArgumentException(e); \n\t\t} \n\t\ttry{ \n\t\t\t//方法名称为sayHello 并且 只有一个参数\n\t\t\tif(\"sayHello\".equals($2) && $3.length == 1){  \n\t\t\t\t//调用接口方法sayHello\n\t\t\t\treturn ($w)w.sayHello((java.lang.String)$4[0]);\n\t\t\t} \n\t\t} catch(Throwable e) {      \n\t\t\tthrow new java.lang.reflect.InvocationTargetException(e);  \n\t\t} \n\t\tthrow new com.alibaba.dubbo.common.bytecode.NoSuchMethodException(\"Not found method \\\"\"+$2+\"\\\" in class com.alibaba.dubbo.demo.DemoService.\"); \n\t}\n}\n```\n\n### 暴露到注册中心\n\n我们先看下DelegateProviderMetaDataInvoker类。\n```java\n/**\n * DelegateProviderMetaDataInvoker类实现了invoker接口\n * 并且持有一个Invoker变量，操作都会委托给该变量\n */\npublic class DelegateProviderMetaDataInvoker<T> implements Invoker {\n    protected final Invoker<T> invoker;\n    private ServiceConfig metadata;\n\n    public DelegateProviderMetaDataInvoker(Invoker<T> invoker,ServiceConfig metadata) {\n        this.invoker = invoker;\n        this.metadata = metadata;\n    }\n\n    @Override\n    public Class<T> getInterface() {\n        return invoker.getInterface();\n    }\n\n    @Override\n    public URL getUrl() {\n        return invoker.getUrl();\n    }\n\n    @Override\n    public boolean isAvailable() {\n        return invoker.isAvailable();\n    }\n\n    @Override\n    public Result invoke(Invocation invocation) throws RpcException {\n        return invoker.invoke(invocation);\n    }\n\n    @Override\n    public void destroy() {\n        invoker.destroy();\n    }\n\n    public ServiceConfig getMetadata() {\n        return metadata;\n    }\n}\n```\n#### Protocol接口的export方法\n\n先来看下Protocol接口的定义，其export方法和refer方法存在@Adaptive注解。\n```java\n/**\n * 协议\n * Protocol. (API/SPI, Singleton, ThreadSafe)\n */\n@SPI(\"dubbo\")\npublic interface Protocol {\n\n    /**\n     * 当用户没有配置端口时，获取默认端口\n     * @return default port\n     */\n    int getDefaultPort();\n\n    /**\n     * 为远程调用暴露服务\n     * 1、接收到请求后协议应该记录请求源地址，通过: RpcContext.getContext().setRemoteAddress()\n     * 2、export()方法必须是幂等的，也就是说，暴露同一个URL的invoker两次时，调用1次和2次没有什么不同\n     * 3、传入的Invoker实例由框架实现并传入，协议不需要关心\n     *\n     * @param <T>     服务类型\n     * @param invoker 服务invoker\n     * @return 暴露服务的exporter引用，用来以后取消暴露服务\n     * @throws RpcException 当暴露服务出错时抛出，比如端口已占用\n     */\n    @Adaptive\n    <T> Exporter<T> export(Invoker<T> invoker) throws RpcException;\n\n    /**\n     * 引用一个远程服务\n     * 1、当用户调用 refer()所返回的 Invoker对象的invoke()时，协议需相应执行同URL远端export()传入的Invoker对象的invoke()方法.\n     * 2、refer()返回的Invoker由协议实现，一般来说，协议需要在此Invoker中发送远程请求。\n     * 3、当URL中设置了check=false时，这个实现不可以抛出异常，而是尝试着从连接失败中恢复\n     * @param T 远程服务类型\n     * @param type 远程服务接口类型\n     * @param url 远程服务的URL地址\n     * @return 执行服务的本地代理\n     * @throws RpcException when there's any error while connecting to the service provider\n     */\n    @Adaptive\n    <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException;\n\n    /**\n     * 销毁协议\n     * 1、取消该协议所有已经暴露和引用的服务\n     * 2、释放协议所有占用的资源，如：链接、端口等\n     * 3、协议在释放后，依然能暴露和引用新的服务\n     */\n    void destroy();\n}\n\n可以看到export方法是定义在Protocol接口中的，我们是通过ExtensionLoader类获取到Protocol的自适应扩展实例的，因此我们在调用export方法进行服务暴露时，实际上调用的是自适应扩展实例的export方法：\n```java\n//自适应扩展实现类\nProtocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();\n\n//获取invoker对象\nInvoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));\n//将invoker和当前对象(ServiceBean)包装成DelegateProviderMetaDataInvoker对象\nDelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\n//调用自适应扩展实现类的export方法\nExporter<?> exporter = protocol.export(wrapperInvoker);\n```\n那么，在获取自适应扩展实例时都进行了哪些操作呢？我们在《Dubbo源码阅读之SPI扩展机制》文章中介绍过Dubbo的SPI机制，这里就不再详细介绍了，只简单说明下是如何获取到Protocol实例的。\n首先我们我们通过ExtensionLoader.getExtensionLoader(Protocol.class)调用，获取到了Protocol的扩展加载器，然后调用它的getAdaptiveExtension()方法拿到自适应扩展实例(Dubbo为它自动生成的一个类，后面介绍)，在此过程中，会先去扫描3个相关路径找到所有的Protocol扩展实现类定义，\n最终会找到如下定义：\n```java\n#扩展名称=扩展实现类\nregistry=com.alibaba.dubbo.registry.integration.RegistryProtocol\nmock=com.alibaba.dubbo.rpc.support.MockProtocol\ninjvm=com.alibaba.dubbo.rpc.protocol.injvm.InjvmProtocol\ndubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol\n#Protocol包装类\nfilter=com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper\nlistener=com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper\n```\n\n然后检查每个扩展实现类，如果没有找到存在@Adaptive注解的扩展类，则Dubbo会为其生成一个自适应扩展类，生成的实现类如下：\n```java\n/**\n * 生成的实现类名为：Protocol$Adaptive，实现了Protocol接口\n * 只有接口方法上标有@Adaptive注解，才会为其生成实现，\n * 例如，Protocol接口的destroy()方法没有@Adaptive注解，因此下面的方法实现中直接抛了异常\n */\npublic class Protocol$Adaptive implements com.alibaba.dubbo.rpc.Protocol {\n\t\n\tpublic void destroy() {\n\t\t//提示 Protocol接口的destroy()方法没有@Adaptive注解，因此不支持\n\t\tthrow new UnsupportedOperationException(\"method public abstract void com.alibaba.dubbo.rpc.Protocol.destroy() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!\");\n\t}\n\t\n\tpublic int getDefaultPort() {\n\t\t//提示 Protocol接口的getDefaultPort()方法没有@Adaptive注解，因此不支持\n\t\tthrow new UnsupportedOperationException(\"method public abstract int com.alibaba.dubbo.rpc.Protocol.getDefaultPort() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!\");\n\t}\n\t\n\t/**\n\t * @param arg0 服务接口类\n\t * @param arg1 注册中心url\n\t */\n\tpublic com.alibaba.dubbo.rpc.Invoker refer(java.lang.Class arg0, com.alibaba.dubbo.common.URL arg1) throws com.alibaba.dubbo.rpc.RpcException {\n\t\tif (arg1 == null){\n\t\t\t//url参数不可以为空\n\t\t\tthrow new IllegalArgumentException(\"url == null\");\n\t\t}\n\t\t\n\t\tcom.alibaba.dubbo.common.URL url = arg1;\n\t\t\n\t\t//使用url的protocol属性值(这里为registry)，作为扩展名称，如果为空，则默认使用\"dubbo\"\n\t\tString extName = url.getProtocol() == null ? \"dubbo\" : url.getProtocol();\n\t\t\n\t\tif(extName == null) {\n\t\t\tthrow new IllegalStateException(\"Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(\" + url.toString() + \") use keys([protocol])\");\n\t\t}\n\t\t\n\t\t//获取扩展名称为extName的Protocol扩展实例\n\t\tcom.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);\n\t\t\n\t\t//调用该extension实例的refer方法\n\t\treturn extension.refer(arg0, arg1);\n\t}\n\t\t\n\tpublic com.alibaba.dubbo.rpc.Exporter export(com.alibaba.dubbo.rpc.Invoker arg0) throws com.alibaba.dubbo.rpc.RpcException {\n\t\tif (arg0 == null){\n\t\t    throw new IllegalArgumentException(\"com.alibaba.dubbo.rpc.Invoker argument == null\");\n\t\t} \n\t\t\n\t\tif (arg0.getUrl() == null) {\n\t\t    throw new IllegalArgumentException(\"com.alibaba.dubbo.rpc.Invoker argument getUrl() == null\");\n\t\t}\n\t\t\n\t\tcom.alibaba.dubbo.common.URL url = arg0.getUrl();\n\t\t\n\t\t//使用url的protocol属性值(这里为registry)，作为扩展名称，如果为空，则默认使用\"dubbo\"\n\t\tString extName = ( url.getProtocol() == null ? \"dubbo\" : url.getProtocol() );\n\t\t\n\t\tif(extName == null) {\n\t\t\tthrow new IllegalStateException(\"Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(\" + url.toString() + \") use keys([protocol])\");\n\t\t}\n\t\t\n\t\t//获取扩展名称为extName的Protocol扩展实例（此扩展实例已经被包装类包装过）\n\t\tcom.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);\n\t\t\n\t\t//调用该extension实例的export方法(包装类的export方法)\n\t\treturn extension.export(arg0);\n\t}\n}\n```\n在上面我们说到，调用export方法实际上是调用自适应扩展实现类的export方法，我们来看下其实现。\n首先校验invoker参数不可以为空，然后校验invoker对象的getUrl()方法返回的URL对象不可以为空，然后我们使用URL对象的protocol属性作为扩展名称extName(提示：在上一节的loadRegistries(boolean provider)加载注册中心url列表方法中，我们设置了注册中心url的protocol属性值为\"registry\")，然后根据扩展名称extName获取到真正的Protocol扩展实例(RegistryProtocol,然后RegistryProtocol会被包装)，最后调用该Protocol扩展实例的export方法。\n通过生成的自适应扩展实现类，我们可以根据不同的扩展名称调用不同的扩展实例。\n在getExtension(extName)方法中，获取到相应的扩展实例后(RegistryProtocol)，Dubbo会再去查看下该扩展是否存在相应的包装类，在上面我们扫描出来Protocol接口存在2个包装类，ProtocolFilterWrapper和ProtocolListenerWrapper，接着Dubbo会创建包装类的实例，并将刚才生成RegistryProtocol扩展实例通过构造函数参数传递到包装类中，通过包装类，Dubbo就实现了功能增强。\n因此，现在我们再回过头来看下export方法的调用：首先是调用自适应扩展实现类的export方法，在export方法内部，根据扩展名称获取到真实的扩展实例RegistryProtocol，然后又通过两个包装类将真实的扩展实例进行了包装，最后调用的是包装类的export方法。\n具体的调用链我们已经分析完了，现在我们来看下对应的代码。\n```java\n/**\n * 根据扩展名称创建扩展实例后，会获取包装类，将扩展实例进行包装\n */\nprivate T createExtension(String name) {\n\t//根据扩展名称name获取扩展实现类clazz\n\tClass<?> clazz = getExtensionClasses().get(name);\n\tif (clazz == null) {\n\t    //扩展实现类为空，则抛出异常\n\t    throw findException(name);\n\t}\n\ttry {\n\t    //先从缓存中获取扩展实现类的实例，如果没有获取到，则新建一个并放入缓存。\n\t    T instance = (T) EXTENSION_INSTANCES.get(clazz);\n\t    if (instance == null) {\n\t\tEXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());\n\t\tinstance = (T) EXTENSION_INSTANCES.get(clazz);\n\t    }\n\t    //处理扩展实现类实例的依赖注入\n\t    injectExtension(instance);\n\n\t    //获取到type接口的所有包装类\n\t    Set<Class<?>> wrapperClasses = cachedWrapperClasses;\n\t    if (wrapperClasses != null && !wrapperClasses.isEmpty()) {\n\t\t//遍历包装类\n\t\tfor (Class<?> wrapperClass : wrapperClasses) {\n\t\t    //包装类通过构造方法创建实例，然后进行依赖注入\n\t\t    instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));\n\t\t}\n\t    }\n\t    return instance;\n\t} catch (Throwable t) {\n\t    throw new IllegalStateException(\"Extension instance(name: \" + name + \", class: \" +\n\t\t    type + \")  could not be instantiated: \" + t.getMessage(), t);\n\t}\n}\n\npublic class ProtocolFilterWrapper implements Protocol {\n\t\n    //根据上面的分析，这里的protocol是ProtocolListenerWrapper\n    private final Protocol protocol;\n\n    public ProtocolFilterWrapper(Protocol protocol) {\n        if (protocol == null) {\n            throw new IllegalArgumentException(\"protocol == null\");\n        }\n        this.protocol = protocol;\n    }\n    \n    @Override\n    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n        \n        if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) {\n\t    //如果url的protocol属性为registry，则调用protocol的export方法\n            return protocol.export(invoker);\n        }\n        return protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));\n    }\n    //.....省略其他方法....\n}\n\n\npublic class ProtocolListenerWrapper implements Protocol{\n\t\n    //根据上面的分析，这里的protocol是RegistryProtocol\n    private final Protocol protocol;\n\n    public ProtocolListenerWrapper(Protocol protocol) {\n        if (protocol == null) {\n            throw new IllegalArgumentException(\"protocol == null\");\n        }\n        this.protocol = protocol;\n    }\n    \n     @Override\n    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n        if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) {\n\t    //如果url的protocol属性为registry，则调用protocol的export方法\n            return protocol.export(invoker);\n        }\n        return new ListenerExporterWrapper<T>(protocol.export(invoker),\n                Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener.class)\n                        .getActivateExtension(invoker.getUrl(), Constants.EXPORTER_LISTENER_KEY)));\n    }\n}\n```\n经过我们的分析，最终会调用RegistryProtocol的export方法进行服务暴露，接下来，我们就来分析下该方法。\n```java\n\n//获取invoker对象\nInvoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));\n\n//将invoker和当前对象(ServiceBean)包装成DelegateProviderMetaDataInvoker对象\nDelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\n\n\n/**\n * 通过invoker的url(即注册中心url)获取providerUrl的地址（即服务暴露的url）\n * @param origininvoker\n * @return\n */\nprivate URL getProviderUrl(final Invoker<?> origininvoker) {\n\t//获取参数export指定的服务地址\n\tString export = origininvoker.getUrl().getParameterAndDecoded(Constants.EXPORT_KEY);\n\tif (export == null || export.length() == 0) {\n\t    //注册中心服务暴露url为空\n\t    throw new IllegalArgumentException(\"The registry export url is null! registry: \" + origininvoker.getUrl());\n\t}\n\t//根据url字符串生成URL对象\n\tURL providerUrl = URL.valueOf(export);\n\treturn providerUrl;\n}\n\n/**\n * 获取originInvoker对象对应的缓存key（移除了dynamic、enabled属性的服务提供者url）\n */\nprivate String getCacheKey(final Invoker<?> originInvoker) {\n\t//获取服务暴露的url，即export参数对应的url\n\tURL providerUrl = getProviderUrl(originInvoker);\n\t//移除dynamic、enabled参数，剩下的url作为缓存key\n\tString key = providerUrl.removeParameters(\"dynamic\", \"enabled\").toFullString();\n\treturn key;\n}\n\n/**\n * 获取注册中心url(如果是注册中心协议，则修改了protocol属性值，属性值为url的registry参数值，并移除url的registry参数)\n * @param originInvoker\n * @return\n */\nprivate URL getRegistryUrl(Invoker<?> originInvoker) {\n\t//注册中心url\n\tURL registryUrl = originInvoker.getUrl();\n\t\n\tif (Constants.REGISTRY_PROTOCOL.equals(registryUrl.getProtocol())) {\n\t    //如果registryUrl的protocol属性为\"registry\"，则获取registryUrl的registry参数值，如果没有获取到，则默认protocol = dubbo\n\t    //这里获取到protocol = multicast\n\t    String protocol = registryUrl.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_DIRECTORY);\n\t    //设置registryUrl的protocol属性值，并移除registry参数\n\t    registryUrl = registryUrl.setProtocol(protocol).removeParameter(Constants.REGISTRY_KEY);\n\t}\n\treturn registryUrl;\n}\n\n/**\n *\n * 基于invoker的地址获取一个注册中心的实例\n * @param originInvoker\n * @return\n */\nprivate Registry getRegistry(final Invoker<?> originInvoker) {\n\tURL registryUrl = getRegistryUrl(originInvoker);\n\t//获取实例\n\treturn registryFactory.getRegistry(registryUrl);\n}\n\n/**\n * 返回注册到注册中心的地址并过滤一次url参数(即服务提供者url)\n * @param originInvoker\n * @return\n */\nprivate URL getRegistedProviderUrl(final Invoker<?> originInvoker) {\n\t//服务暴露的url，即export参数指定的url\n\tURL providerUrl = getProviderUrl(originInvoker);\n\n\t//在注册中心中看到的服务地址\n\tfinal URL registedProviderUrl = providerUrl.removeParameters(\n\t\t\t//删除不需要输出的参数key\n\t\t\tgetFilteredKeys(providerUrl)\n\t\t)\n\t\t//移除监控\n\t\t.removeParameter(Constants.MONITOR_KEY)\n\t\t//移除绑定ip、port\n\t\t.removeParameter(Constants.BIND_IP_KEY)\n\t\t.removeParameter(Constants.BIND_PORT_KEY)\n\t\t//移除qos\n\t\t.removeParameter(QOS_ENABLE)\n\t\t.removeParameter(QOS_PORT)\n\t\t.removeParameter(ACCEPT_FOREIGN_IP);\n\t\n\treturn registedProviderUrl;\n}\n\n/**\n * 服务暴露\n * originInvoker参数就是上面我们创建的wrapperInvoker\n */\n@Override\npublic <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcException {\n\t//暴露invoker(后面会分析该方法)\n\tfinal ExporterChangeableWrapper<T> exporter = doLocalExport(originInvoker);\n\t\n\t//获取注册中心地址,如：multicast://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&dubbo=2.0.0&export=dubbo%3A%2F%2F192.168.99.60%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26bind.ip%3D192.168.99.60%26bind.port%3D20880%26dubbo%3D2.0.0%26generic%3Dfalse%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D7520%26qos.port%3D22222%26side%3Dprovider%26timestamp%3D1528784828723&pid=7520&qos.port=22222&timestamp=1528784779675\n\tURL registryUrl = getRegistryUrl(originInvoker);\n\n\t//获取注册中心实例\n\tfinal Registry registry = getRegistry(originInvoker);\n\t\n\t//注册中心url的export参数指定的url(服务提供者url)，去掉了一些key\n\tfinal URL registedProviderUrl = getRegistedProviderUrl(originInvoker);\n\t\n\t//判断是否延迟发布，默认是true\n\tboolean register = registedProviderUrl.getParameter(\"register\", true);\n\t\n\t//注册服务提供者(保存到map缓存中)\n\tProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registedProviderUrl);\n\n\tif (register) {\n\t    //registryUrl注册中心url，registedProviderUrl服务提供者url\n\t    //获取注册中心，并将服务提供者注册到注册中心\n\t    register(registryUrl, registedProviderUrl);\n\t    \n\t    //根据originInvoker获取到ProviderInvokerWrapper并标识isReg = true\n\t    ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true);\n\t}\n\n\t// 当提供者订阅时，会影响一个场景，即同一JVM即暴露服务，又引用同一服务。\n\t// 因为subscribed使用服务的名称作为缓存key，它会导致订阅信息被覆盖\n\t//如：provider://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&category=configurators&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=5452&side=provider&timestamp=1528789631708\n\tfinal URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);\n\t\n\t//创建OverrideListener对象(后面小节会介绍)\n\tfinal OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);\n\t\n\t//保存overrideSubscribeUrl和overrideSubscribeListener\n\toverrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);\n\t\n\t//订阅服务(后面注册中心小节会介绍)\n\tregistry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);\n\t\n\t//确保每次发布时都返回一个新的exporter实例\n\treturn new DestroyableExporter<T>(exporter, originInvoker, overrideSubscribeUrl, registedProviderUrl);\n}\n\n/**\n * subscribedOverrideUrl\n * @param registedProviderUrl 服务提供者url\n * @return\n */\nprivate URL getSubscribedOverrideUrl(URL registedProviderUrl) {\n\t//设置protocol = provider,修改前 protocol = dubbo\n\t//设置category = configurators\n\t//设置check = false\n\treturn registedProviderUrl.setProtocol(Constants.PROVIDER_PROTOCOL)\n\t\t.addParameters(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY,\n\t\t\tConstants.CHECK_KEY, String.valueOf(false));\n}\n\n/**\n * 通过registryUrl获取注册中心，然后将服务提供者url注册到注册中心\n * @param registryUrl 注册中心url\n * @param registedProviderUrl 服务提供者url\n */\npublic void register(URL registryUrl, URL registedProviderUrl) {\n\t//根据注册中心url 获取注册中心实例\n\tRegistry registry = registryFactory.getRegistry(registryUrl);\n\t//注册 服务提供者 到注册中心\n\tregistry.register(registedProviderUrl);\n}\n\n/**\n * 为了解决RMI反复暴露端口冲突的问题，已经暴露的服务不需要再次暴露\n * <providerurl,exporter>\n */\nprivate final Map<String, ExporterChangeableWrapper<?>> bounds = new ConcurrentHashMap<String, ExporterChangeableWrapper<?>>();\n\n/**\n * <服务提供者url,NotifyListener>\n */\nprivate final Map<URL, NotifyListener> overrideListeners = new ConcurrentHashMap<URL, NotifyListener>();\n\n/**\n * 暴露originInvoker\n */\nprivate <T> ExporterChangeableWrapper<T> doLocalExport(final Invoker<T> originInvoker) {\n\t//获取缓存key\n\tString key = getCacheKey(originInvoker);\n\t\n\t//先检查是否暴露过，没有暴露过的话，则进行暴露\n\tExporterChangeableWrapper<T> exporter = (ExporterChangeableWrapper<T>) bounds.get(key);\n\tif (exporter == null) {\n\t    synchronized (bounds) {\n\t\texporter = (ExporterChangeableWrapper<T>) bounds.get(key);\n\t\tif (exporter == null) {\n\t\t    //根据originInvoker，及其服务提供者url，创建InvokerDelegete对象\n\t\t    final Invoker<?> invokerDelegete = new InvokerDelegete<T>(originInvoker, getProviderUrl(originInvoker));\n\t\t   \n\t\t    //1、因为invokerDelegete对象的getUrl方法将会返回服务提供者url，其protocol属性将会返回扩展名称dubbo，因此这里会调用DubboProtocol的export方法进行暴露\n\t\t    //2、创建ExporterChangeableWrapper对象\n\t\t    exporter = new ExporterChangeableWrapper<T>((Exporter<T>) protocol.export(invokerDelegete), originInvoker);\n\t\t    \n\t\t    //dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=192.168.99.60&bind.port=20880&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=6440&qos.port=22222&side=provider&timestamp=1528789363848\n\t\t    //URL url = exporter.getInvoker().getUrl();\n\t\t    //放入缓存\n\t\t    bounds.put(key, exporter);\n\t\t}\n\t    }\n\t}\n\treturn exporter;\n}\n\n/**\n * Invoker委托类\n */\npublic static class InvokerDelegete<T> extends InvokerWrapper<T> {\n\n\tprivate final Invoker<T> invoker;\n\n\t/**\n\t * @param invoker\n\t * @param url   服务提供者url\n\t */\n\tpublic InvokerDelegete(Invoker<T> invoker, URL url) {\n\t    super(invoker, url);\n\t    this.invoker = invoker;\n\t}\n\n\tpublic Invoker<T> getInvoker() {\n\t    if (invoker instanceof InvokerDelegete) {\n\t\treturn ((InvokerDelegete<T>) invoker).getInvoker();\n\t    } else {\n\t\treturn invoker;\n\t    }\n\t}\n}\n\n/**\n * exporter代理\n * 建立通过protocol已暴露的exporter和已返回的exporter的对应关系\n * 并且可以在覆盖时修改关系\n */\nprivate class ExporterChangeableWrapper<T> implements Exporter<T> {\n\n\tprivate final Invoker<T> originInvoker;\n\n\t//protocol.export(invokerDelegete)返回的Exporter\n\tprivate Exporter<T> exporter;\n\n\tpublic ExporterChangeableWrapper(Exporter<T> exporter, Invoker<T> originInvoker) {\n\t    this.exporter = exporter;\n\t    this.originInvoker = originInvoker;\n\t}\n\n\tpublic Invoker<T> getOriginInvoker() {\n\t    return originInvoker;\n\t}\n\n\t@Override\n\tpublic Invoker<T> getInvoker() {\n\t    return exporter.getInvoker();\n\t}\n\n\tpublic void setExporter(Exporter<T> exporter) {\n\t    this.exporter = exporter;\n\t}\n\n\t@Override\n\tpublic void unexport() {\n\t    String key = getCacheKey(this.originInvoker);\n\t    bounds.remove(key);\n\t    exporter.unexport();\n\t}\n}\n\n/**\n * 可销毁的Exporter\n */\nstatic private class DestroyableExporter<T> implements Exporter<T> {\n\t\n\tpublic static final ExecutorService executor = Executors.newSingleThreadExecutor(new NamedThreadFactory(\"Exporter-Unexport\", true));\n\n\tprivate Exporter<T> exporter;\n\tprivate Invoker<T> originInvoker;\n\n\t//overrideSubscribeUrl 订阅的url\n\tprivate URL subscribeUrl; \n\t\n\t//registedProviderUrl 注册的服务提供者url\n\tprivate URL registerUrl;\n\n\tpublic DestroyableExporter(Exporter<T> exporter, Invoker<T> originInvoker, URL subscribeUrl, URL registerUrl) {\n\t    this.exporter = exporter;\n\t    this.originInvoker = originInvoker;\n\t    this.subscribeUrl = subscribeUrl;\n\t    this.registerUrl = registerUrl;\n\t}\n\n\t@Override\n\tpublic Invoker<T> getInvoker() {\n\t    return exporter.getInvoker();\n\t}\n\n\t@Override\n\tpublic void unexport() {\n\t    //获取注册中心实例\n\t    Registry registry = RegistryProtocol.INSTANCE.getRegistry(originInvoker);\n\t    try {\n\t        //取消注册registerUrl\n\t\tregistry.unregister(registerUrl);\n\t    } catch (Throwable t) {\n\t\tlogger.warn(t.getMessage(), t);\n\t    }\n\t    try {\n\t        //移除监听\n\t\tNotifyListener listener = RegistryProtocol.INSTANCE.overrideListeners.remove(subscribeUrl);\n\t\t//取消订阅subscribeUrl\n\t\tregistry.unsubscribe(subscribeUrl, listener);\n\t    } catch (Throwable t) {\n\t\tlogger.warn(t.getMessage(), t);\n\t    }\n\t    //提交线程，取消暴露服务\n\t    executor.submit(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t    try {\n\t\t        //取消暴露服务时，等待注册中心通知所有的消费者的超时时间\n\t\t\tint timeout = ConfigUtils.getServerShutdownTimeout();\n\t\t\tif (timeout > 0) {\n\t\t\t    logger.info(\"Waiting \" + timeout + \"ms for registry to notify all consumers before unexport. Usually, this is called when you use dubbo API\");\n\t\t\t    Thread.sleep(timeout);\n\t\t\t}\n\t\t\t//取消暴露服务\n\t\t\texporter.unexport();\n\t\t    } catch (Throwable t) {\n\t\t\tlogger.warn(t.getMessage(), t);\n\t\t    }\n\t\t}\n\t    });\n\t}\n}\n```\n\nProviderConsumerRegTable类用来保存注册的服务提供者和消费者\n```java\npublic class ProviderConsumerRegTable {\n    /**\n     * <服务唯一名称,Set<服务提供者执行器>>\n     */\n    public static ConcurrentHashMap<String, Set<ProviderInvokerWrapper>> providerInvokers = new ConcurrentHashMap<String, Set<ProviderInvokerWrapper>>();\n    public static ConcurrentHashMap<String, Set<ConsumerInvokerWrapper>> consumerInvokers = new ConcurrentHashMap<String, Set<ConsumerInvokerWrapper>>();\n\n    /**\n     * 注册服务提供者\n     * @param invoker\n     * @param registryUrl 注册中心地址\n     * @param providerUrl 服务提供者url\n     */\n    public static void registerProvider(Invoker invoker, URL registryUrl, URL providerUrl) {\n\t//创建ProviderInvokerWrapper实例\n        ProviderInvokerWrapper wrapperInvoker = new ProviderInvokerWrapper(invoker, registryUrl, providerUrl);\n        \n\t//获取服务唯一名称标识\n        String serviceUniqueName = providerUrl.getServiceKey();\n\t\n\t//根据serviceUniqueName从缓存中获取\n\tSet<ProviderInvokerWrapper> invokers = providerInvokers.get(serviceUniqueName);\n        \n\tif (invokers == null) {\n            providerInvokers.putIfAbsent(serviceUniqueName, new ConcurrentHashSet<ProviderInvokerWrapper>());\n            invokers = providerInvokers.get(serviceUniqueName);\n        }\n        invokers.add(wrapperInvoker);\n    }\n}\n\n/**\n * 通过invoker 获取相应的ProviderInvokerWrapper\n * @param invoker\n * @return\n */\npublic static ProviderInvokerWrapper getProviderWrapper(Invoker invoker) {\n\t//获取服务提供者url\n\tURL providerUrl = invoker.getUrl();\n\tif (Constants.REGISTRY_PROTOCOL.equals(providerUrl.getProtocol())) {\n\t    //获取export参数的值，即(服务提供者url)\n\t    providerUrl = URL.valueOf(providerUrl.getParameterAndDecoded(Constants.EXPORT_KEY));\n\t}\n\t//获取服务唯一标识\n\tString serviceUniqueName = providerUrl.getServiceKey();\n\t//根据服务唯一标识获取invokers\n\tSet<ProviderInvokerWrapper> invokers = providerInvokers.get(serviceUniqueName);\n\tif (invokers == null) {\n\t    return null;\n\t}\n\tfor (ProviderInvokerWrapper providerWrapper : invokers) {\n\t    Invoker providerInvoker = providerWrapper.getInvoker();\n\t    //通过invoker获取providerWrapper\n\t    if (providerInvoker == invoker) {\n\t\treturn providerWrapper;\n\t    }\n\t}\n\treturn null;\n}\n\n\n/**\n * 重新暴露修改了url的invoker\n * @param originInvoker\n * @param newInvokerUrl\n */\n@SuppressWarnings(\"unchecked\")\nprivate <T> void doChangeLocalExport(final Invoker<T> originInvoker, URL newInvokerUrl) {\n        //获取originInvoker对应的缓存key\n\tString key = getCacheKey(originInvoker);\n\n\t//从缓存中获取该exporter\n\tfinal ExporterChangeableWrapper<T> exporter = (ExporterChangeableWrapper<T>) bounds.get(key);\n\t\n\tif (exporter == null) {\n\t    logger.warn(new IllegalStateException(\"error state, exporter should not be null\"));\n\t} else {\n\t    //重新生成invokerDelegete\n\t    final Invoker<T> invokerDelegete = new InvokerDelegete<T>(originInvoker, newInvokerUrl);\n\t    //重新暴露服务\n\t    exporter.setExporter(protocol.export(invokerDelegete));\n\t}\n}\n```\n\n接下来我们看下OverrideListener类\n```java\n/**\n * 1、确保由registryProtocol返回的exporter可以被正常销毁\n * 2、通知后，无需重新注册到注册中心\n * 3、通过暴露方法传递invoker，最好是exporter的invoker\n */\nprivate class OverrideListener implements NotifyListener {\n\t/**\n\t * 已订阅的url\n\t * protocol = provider\n\t */\n\tprivate final URL subscribeUrl;\n\n\tprivate final Invoker originInvoker;\n\n\tpublic OverrideListener(URL subscribeUrl, Invoker originalInvoker) {\n\t    this.subscribeUrl = subscribeUrl;\n\t    this.originInvoker = originalInvoker;\n\t}\n\n\t/**\n\t * 通知\n\t * @param urls 已注册的信息列表，它总是非空。这意味着与RegistryService#lookup(URL)有相同的返回值\n\t */\n\t@Override\n\tpublic synchronized void notify(List<URL> urls) {\n\t    logger.debug(\"original override urls: \" + urls);\n\t    \n\t    //获取匹配到的url\n\t    List<URL> matchedUrls = getMatchedUrls(urls, subscribeUrl);\n\t    logger.debug(\"subscribe url: \" + subscribeUrl + \", override urls: \" + matchedUrls);\n\n\t    //没有匹配到结果，直接返回\n\t    if (matchedUrls.isEmpty()) {\n\t\treturn;\n\t    }\n\t\t\n\t    //根据匹配的url生成configurators列表(后面小节会分析该方法)\n\t    List<Configurator> configurators = RegistryDirectory.toConfigurators(matchedUrls);\n\n\t    final Invoker<?> invoker;\n\t    if (originInvoker instanceof InvokerDelegete) {\n\t        //委托类，调用getInvoker()方法获取invoker\n\t\tinvoker = ((InvokerDelegete<?>) originInvoker).getInvoker();\n\t    } else {\n\t\tinvoker = originInvoker;\n\t    }\n\n\t    //originUrl即export参数对应的url(原始服务提供者url)\n\t    URL originUrl = RegistryProtocol.this.getProviderUrl(invoker);\n\t    \n\t    //这里的exporter就是在上步的doLocalExport()方法中生成的\n\t    String key = getCacheKey(originInvoker);\n\n\t    //根据缓存key从缓存中获取exporter\n\t    ExporterChangeableWrapper<?> exporter = bounds.get(key);\n\t    if (exporter == null) {\n\t\tlogger.warn(new IllegalStateException(\"error state, exporter should not be null\"));\n\t\treturn;\n\t    }\n\t    \n\t    //当前的url(旧的服务暴露的url)，可能已经合并了很多次\n\t    URL currentUrl = exporter.getInvoker().getUrl();\n\t   \n\t    //合并配置，生成新的服务暴露url\n\t    URL newUrl = getConfigedInvokerUrl(configurators, originUrl);\n\t    \n\t    if (!currentUrl.equals(newUrl)) {\n\t\t//已暴露的服务提供者url已经发生改变，重新暴露\n\t\tRegistryProtocol.this.doChangeLocalExport(originInvoker, newUrl);\n\n\t\tlogger.info(\"exported provider url changed, origin url: \" + originUrl + \", old export url: \" + currentUrl + \", new export url: \" + newUrl);\n\t    }\n\t}\n\t\n\t/**\n\t * 获取匹配的url\n\t * @param configuratorUrls\n\t * @param currentSubscribe 当前已订阅的url\n\t */\n\tprivate List<URL> getMatchedUrls(List<URL> configuratorUrls, URL currentSubscribe) {\n\t    List<URL> result = new ArrayList<URL>();\n\t    \n\t    for (URL url : configuratorUrls) {\n\t\tURL overrideUrl = url;\n\t\t//与旧版本兼容\n\t\tif (url.getParameter(Constants.CATEGORY_KEY) == null && Constants.OVERRIDE_PROTOCOL.equals(url.getProtocol())) {\n\t\t    //url的category参数为空，并且url协议为override时，则新增url的category参数 = configurators\n\t\t    overrideUrl = url.addParameter(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY);\n\t\t}\n\n\t\t//检测url是否可以应用到当前服务\n\t\t//consumerUrl,providerUrl\n\t\tif (UrlUtils.isMatch(currentSubscribe, overrideUrl)) {\n\t\t    //匹配，则将该url保存\n\t\t    result.add(url);\n\t\t}\n\t    }\n\t    return result;\n\t}\n\n\t/**\n\t * 合并configurators的url，返回新的url\n\t * @param configurators\n\t * @param url 原始服务提供者url\n\t * @return\n\t */\n\tprivate URL getConfigedInvokerUrl(List<Configurator> configurators, URL url) {\n\t    for (Configurator configurator : configurators) {\n\t        //配置url\n\t\turl = configurator.configure(url);\n\t    }\n\t    return url;\n\t}\n}\n```\n\n最后我们来看下DubboProtocol的export方法\n\n```java\n/**\n * 保存发布的服务\n * <URL的serviceKey,Exporter>\n * 通过key可以获取到服务发布对象DubboExporter，\n * 然后通过DubboExporter的getInvoker方法得到服务调用对象Invoker,从而调用服务\n */\nprotected final Map<String, Exporter<?>> exporterMap = new ConcurrentHashMap<String, Exporter<?>>();\n\n/**\n * 消费者端为调度事件暴露一个存根服务\n * <servicekey,stubmethods>\n */\nprivate final ConcurrentMap<String, String> stubServiceMethodsMap = new ConcurrentHashMap<String, String>();\n\n\n/**\n *\n * @param invoker 即新创建的InvokerDelegete对象\n */\n@Override\npublic <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n\t\n\t//服务提供者url\n\t//dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=192.168.99.60&bind.port=20880&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=7520&qos.port=22222&side=provider&timestamp=1528784828723\n\tURL url = invoker.getUrl();\n\n\t// 获取服务名称，格式为：group/ServiceName:version:port\n\t// 这里group和version没有设置，因此key = com.alibaba.dubbo.demo.DemoService:20880\n\tString key = serviceKey(url);\n\t\n\t//生成key值之后，结合Invoker和exportMap生成服务暴露对象exporter，\n\t//然后将生成的服务暴露对象exporter作为value值放入map中，从而实现服务发布\n\tDubboExporter<T> exporter = new DubboExporter<T>(invoker, key, exporterMap);\n\texporterMap.put(key, exporter);\n\n\t//为调度事件暴露一个存根服务，默认false\n\tBoolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);\n\t\n\t//是否是回调服务\n\tBoolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, false);\n\tif (isStubSupportEvent && !isCallbackservice) {\n\t    //存根服务方法\n\t    String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);\n\t    if (stubServiceMethods == null || stubServiceMethods.length() == 0) {\n\t\tif (logger.isWarnEnabled()) {\n\t\t    //设置了存根代理支持事件，但是没有发现存根方法\n\t\t    logger.warn(new IllegalStateException(\"consumer [\" + url.getParameter(Constants.INTERFACE_KEY) +\n\t\t\t    \"], has set stubproxy support event ,but no stub methods founded.\"));\n\t\t}\n\t    } else {\n\t\t//保存存根方法\n\t\tstubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);\n\t    }\n\t}\n\t//开启服务\n\topenServer(url);\n\t//优化序列化(加载优化序列化类,后面小节会详细介绍)\n\toptimizeSerialization(url);\n\t//返回exporter\n\treturn exporter;\n}\n\n/**\n * 保存已创建的服务器\n * <地址address，ExchangeServer>\n */\nprivate final Map<String, ExchangeServer> serverMap = new ConcurrentHashMap<String, ExchangeServer>();\n\n/**\n * 开启服务(后面会小节会详解讲解)\n * @param url\n */\nprivate void openServer(URL url) {\n\t//获取服务地址\n\tString key = url.getAddress();\n\t\n\t//客户端可以暴露一个只能服务端调用的服务\n\tboolean isServer = url.getParameter(Constants.IS_SERVER_KEY, true);\n\t\n\tif (isServer) {\n\t    //先从缓存中获取下该服务地址key对应的服务器\n\t    ExchangeServer server = serverMap.get(key);\n\t    if (server == null) {\n\t\t//创建服务器，并放入缓存\n\t\tserverMap.put(key, createServer(url));\n\t    } else {\n\t\t//服务器支持重置，与override一起使用\n\t\t//重置服务器\n\t\tserver.reset(url);\n\t    }\n\t}\n}\n\n\n/**\n * 创建服务器\n * @param url 服务提供者url\n * @return\n */\nprivate ExchangeServer createServer(URL url) {\n\t//当服务器关闭时，发送readonly事件，默认情况下，是启用的。\n\turl = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString());\n\t\n\t//默认情况下，启用心跳\n\turl = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));\n\t\n\t//获取Transporter扩展，默认使用netty\n\tString str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);\n\n\tif (str != null && str.length() > 0 && !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) {\n\t    //不支持的服务器类型\n\t    throw new RpcException(\"Unsupported server type: \" + str + \", url: \" + url);\n\t}\n\t//在url中添加codec=dubbo\n\turl = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);\n\t\n\tExchangeServer server;\n\ttry {\n\t    //Exchangers门面 绑定到服务器\n\t    server = Exchangers.bind(url, requestHandler);\n\t} catch (RemotingException e) {\n\t    throw new RpcException(\"Fail to start server(url: \" + url + \") \" + e.getMessage(), e);\n\t}\n\t\n\t//获取客户端扩展名称\n\tstr = url.getParameter(Constants.CLIENT_KEY);\n\t\n\tif (str != null && str.length() > 0) {\n\t    //获取支持的Transporter扩展名称列表\n\t    Set<String> supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();\n\t    if (!supportedTypes.contains(str)) {\n\t\t//不支持的客户端类型\n\t\tthrow new RpcException(\"Unsupported client type: \" + str);\n\t    }\n\t}\n\treturn server;\n}\n```\n\n\n### 暴露到本地\n\n主要的方法调用protocol.export上文我们已经介绍过了，这里就不再介绍了。\n\n```java\n/**\n * 暴露服务到本地注册中心\n * @param url 服务暴露的url\n */\nprivate void exportLocal(URL url) {\n\tif (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) {\n\t    //例如：injvm://127.0.0.1/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=192.168.99.60&bind.port=20880&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=4328&qos.port=22222&side=provider&timestamp=1528278313225\n\t    URL local = URL.valueOf(url.toFullString())\n\t\t    //设置injvm协议\n\t\t    .setProtocol(Constants.LOCAL_PROTOCOL)\n\t\t    //设置本地地址\n\t\t    .setHost(LOCALHOST)\n\t\t    //设置端口\n\t\t    .setPort(0);\n\n\t    //获取到实现类ref的Class对象，然后将它放入到ThreadLocal中\n\t    ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref));\n\n\t    //暴露服务(后面会分析export方法)\n\t    Exporter<?> exporter = protocol.export(\n\t\t    proxyFactory.getInvoker(ref, (Class) interfaceClass, local)\n\t    );\n\n\t    //保存暴露的服务到本地变量中\n\t    exporters.add(exporter);\n\t    logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to local registry\");\n\t}\n}\n```\n\n到此，关于服务暴露的内容，我们就介绍完毕了，下一小节，介绍如果引用服务.\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之集成Spring外部化配置(03)","url":"/blog/2018/08/08/Dubbo源码阅读之集成Spring-03外部化配置/","content":">这一小节，我们来看下支持外部化配置的相关类，因为本系列文章主要关注源码，具体的映射规则就不在介绍了，可以参考: https://zhuanlan.zhihu.com/p/32557951\n\n### 支持的注解\n\n#### DubboComponentScan注解\n@Import是Spring提供的注解，可以通过导入的方式将实例添加到BeanFactory中，不了解的童鞋可以去我的博客里面找一下，有单独的文章介绍。\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Import(DubboComponentScanRegistrar.class)\npublic @interface DubboComponentScan {\n\n    /**\n     * basePackages() 别名，例如，可以使用 @DubboComponentScan(\"org.my.pkg\") 替代 @DubboComponentScan(basePackages=\"org.my.pkg\")\n     * Alias for the {@link #basePackages()} attribute. Allows for more concise annotation\n     * declarations e.g.: {@code @DubboComponentScan(\"org.my.pkg\")} instead of\n     * {@code @DubboComponentScan(basePackages=\"org.my.pkg\")}.\n     *\n     * @return the base packages to scan\n     */\n    String[] value() default {};\n\n    /**\n     * 被标注@Service注解的类所在基础包路径\n     * @return the base packages to scan\n     */\n    String[] basePackages() default {};\n\n    /**\n     * 类型安全，用来替代 basePackages()\n     * @return the base packages to scan\n     */\n    Class<?>[] basePackageClasses() default {};\n}\n```\n然后我们看下DubboComponentScanRegistrar类，该类负责注册ServiceAnnotationBeanPostProcessor和ReferenceAnnotationBeanPostProcessor到BeanFactory\n```java\n/**\n * 实现了ImportBeanDefinitionRegistrar接口，允许我们注册特定的bean到Spring中\n * Dubbo {@link DubboComponentScan} Bean Registrar\n *\n * @see Service\n * @see DubboComponentScan\n * @see ImportBeanDefinitionRegistrar\n * @see ServiceAnnotationBeanPostProcessor\n * @see ReferenceAnnotationBeanPostProcessor\n * @since 2.5.7\n */\npublic class DubboComponentScanRegistrar implements ImportBeanDefinitionRegistrar {\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n\n        //获取待扫描的基础包路径\n        Set<String> packagesToScan = getPackagesToScan(importingClassMetadata);\n\n        //注册ServiceAnnotationBeanPostProcessor\n        registerServiceAnnotationBeanPostProcessor(packagesToScan, registry);\n        //注册ReferenceAnnotationBeanPostProcessor\n        registerReferenceAnnotationBeanPostProcessor(registry);\n\n    }\n\n    /**\n     * 注册ServiceAnnotationBeanPostProcessor类\n     *\n     * @param packagesToScan 待扫描的包路径，没有处理placeholders\n     * @param registry       {@link BeanDefinitionRegistry}\n     * @since 2.5.8\n     */\n    private void registerServiceAnnotationBeanPostProcessor(Set<String> packagesToScan,\n                                                            BeanDefinitionRegistry registry) {\n\n        BeanDefinitionBuilder builder = rootBeanDefinition(ServiceAnnotationBeanPostProcessor.class);\n        builder.addConstructorArgValue(packagesToScan);\n        builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();\n        //生成beanName并执行注册\n        BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry);\n\n    }\n\n    /**\n     * 注册ReferenceAnnotationBeanPostProcessor类\n     * @param registry {@link BeanDefinitionRegistry}\n     */\n    private void registerReferenceAnnotationBeanPostProcessor(BeanDefinitionRegistry registry) {\n\n        // Register @Reference Annotation Bean Processor\n        BeanRegistrar.registerInfrastructureBean(registry,\n                ReferenceAnnotationBeanPostProcessor.BEAN_NAME,\n                ReferenceAnnotationBeanPostProcessor.class);\n\n    }\n\n    /**\n     * 获取待扫描的基础包路径\n     * @param metadata\n     * @return\n     */\n    private Set<String> getPackagesToScan(AnnotationMetadata metadata) {\n        //获取@DubboComponentScan注解属性\n        AnnotationAttributes attributes = AnnotationAttributes.fromMap(\n                metadata.getAnnotationAttributes(DubboComponentScan.class.getName())\n        );\n        String[] basePackages = attributes.getStringArray(\"basePackages\");\n        Class<?>[] basePackageClasses = attributes.getClassArray(\"basePackageClasses\");\n        String[] value = attributes.getStringArray(\"value\");\n        //将basePackages、basePackageClasses、value属性指定的值合并起来\n        Set<String> packagesToScan = new LinkedHashSet<String>(Arrays.asList(value));\n        packagesToScan.addAll(Arrays.asList(basePackages));\n        for (Class<?> basePackageClass : basePackageClasses) {\n            //通过basePackageClass获取包名\n            packagesToScan.add(ClassUtils.getPackageName(basePackageClass));\n        }\n        if (packagesToScan.isEmpty()) {\n            //如果没有配置基础包路径的话，则取包名作为基础包路径\n            return Collections.singleton(ClassUtils.getPackageName(metadata.getClassName()));\n        }\n        return packagesToScan;\n    }\n}\n```\n\n#### EnableDubboConfig注解\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\n@Import(DubboConfigConfigurationSelector.class)\npublic @interface EnableDubboConfig {\n    /**\n     * 表明是否绑定到多个Spring-Bean,默认是false\n     */\n    boolean multiple() default false;\n}\n\n/**\n * 该类实现了ImportSelector接口，此接口是Spring中导入外部配置的核心接口，有兴趣的读者可以去了解下，这里就不多做介绍了。\n * Dubbo {@link AbstractConfig Config} Registrar\n * @see EnableDubboConfig\n * @see DubboConfigConfiguration\n * @since 2.5.8\n */\npublic class DubboConfigConfigurationSelector implements ImportSelector, Ordered {\n\n    /**\n     * 要导入到Spring容器中的组件全类名\n     * @param importingClassMetadata\n     * @return\n     */\n    @Override\n    public String[] selectImports(AnnotationMetadata importingClassMetadata) {\n\n        AnnotationAttributes attributes = AnnotationAttributes.fromMap(\n                importingClassMetadata\n                        .getAnnotationAttributes(EnableDubboConfig.class.getName())\n        );\n\n        //是否绑定到多个Spring-Bean\n        boolean multiple = attributes.getBoolean(\"multiple\");\n\n        if (multiple) {\n            //返回多dubbo配置bean绑定\n            return of(DubboConfigConfiguration.Multiple.class.getName());\n        } else {\n            return of(DubboConfigConfiguration.Single.class.getName());\n        }\n    }\n\n    private static <T> T[] of(T... values) {\n        return values;\n    }\n\n    @Override\n    public int getOrder() {\n        return HIGHEST_PRECEDENCE;\n    }\n}\n\n\npublic class DubboConfigConfiguration {\n\n    /**\n     * 单Dubbo配置Bean绑定\n     * Single Dubbo {@link AbstractConfig Config} Bean Binding\n     */\n    @EnableDubboConfigBindings({\n            @EnableDubboConfigBinding(prefix = \"dubbo.application\", type = ApplicationConfig.class),\n            @EnableDubboConfigBinding(prefix = \"dubbo.module\", type = ModuleConfig.class),\n            @EnableDubboConfigBinding(prefix = \"dubbo.registry\", type = RegistryConfig.class),\n            @EnableDubboConfigBinding(prefix = \"dubbo.protocol\", type = ProtocolConfig.class),\n            @EnableDubboConfigBinding(prefix = \"dubbo.monitor\", type = MonitorConfig.class),\n            @EnableDubboConfigBinding(prefix = \"dubbo.provider\", type = ProviderConfig.class),\n            @EnableDubboConfigBinding(prefix = \"dubbo.consumer\", type = ConsumerConfig.class)\n    })\n    public static class Single {\n\n    }\n\n    /**\n     * 多Dubbo配置Bean绑定\n     * Multiple Dubbo {@link AbstractConfig Config} Bean Binding\n     */\n    @EnableDubboConfigBindings({\n            @EnableDubboConfigBinding(prefix = \"dubbo.applications\", type = ApplicationConfig.class, multiple = true),\n            @EnableDubboConfigBinding(prefix = \"dubbo.modules\", type = ModuleConfig.class, multiple = true),\n            @EnableDubboConfigBinding(prefix = \"dubbo.registries\", type = RegistryConfig.class, multiple = true),\n            @EnableDubboConfigBinding(prefix = \"dubbo.protocols\", type = ProtocolConfig.class, multiple = true),\n            @EnableDubboConfigBinding(prefix = \"dubbo.monitors\", type = MonitorConfig.class, multiple = true),\n            @EnableDubboConfigBinding(prefix = \"dubbo.providers\", type = ProviderConfig.class, multiple = true),\n            @EnableDubboConfigBinding(prefix = \"dubbo.consumers\", type = ConsumerConfig.class, multiple = true)\n    })\n    public static class Multiple {\n\n    }\n}\n```\n使用方式:\n```java\n//将以下内容的外部化配置文件物理路径为：classpath:/META-INF/multiple-config.properties:\n#多Dubbo配置Bean绑定\n## dubbo.applications\ndubbo.applications.applicationBean.name = dubbo-demo-application\ndubbo.applications.applicationBean2.name = dubbo-demo-application2\ndubbo.applications.applicationBean3.name = dubbo-demo-application3\n\n//新建配置类DubboMultipleConfiguration\n@EnableDubboConfig(multiple = true)\n@PropertySource(\"META-INF/multiple-config.properties\")\nprivate static class DubboMultipleConfiguration {\n\n} \n\n\n//测试类\npublic class DubboConfigurationBootstrap {\n\tpublic static void main(String[] args) {\n\t\t//创建配置上下文\n\t\tAnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\n\t\t//注册当前配置 Bean\n       \t\tcontext.register(DubboMultipleConfiguration.class);\n       \t\tcontext.refresh();\n\n\t\t//获取ApplicationConfig Bean：\"applicationBean\"、\"applicationBean2\" 和 \"applicationBean3\"\n\t\tApplicationConfig applicationBean = context.getBean(\"applicationBean\", ApplicationConfig.class);\n\t\tApplicationConfig applicationBean2 = context.getBean(\"applicationBean2\", ApplicationConfig.class);\n\t\tApplicationConfig applicationBean3 = context.getBean(\"applicationBean3\", ApplicationConfig.class);\n\n\t\tSystem.out.printf(\"applicationBean.name = %s \\n\", applicationBean.getName());\n\t\tSystem.out.printf(\"applicationBean2.name = %s \\n\", applicationBean2.getName());\n\t\tSystem.out.printf(\"applicationBean3.name = %s \\n\", applicationBean3.getName());\n\t}\n}\n```\n\n#### @EnableDubboConfigBinding/@EnableDubboConfigBindings注解\n@EnableDubboConfig适合绝大多数外部化配置场景,然而无论是单Bean绑定,还是多Bean绑定,其外部化配置属性前缀是固化的,如dubbo.application以及dubbo.applications.\n当应用需要自定义外部化配置属性前缀,@EnableDubboConfigBinding能提供更大的弹性，支持单个外部化配置属性前缀(prefix)与Dubbo配置Bean类型(AbstractConfig子类)绑定,如果需要多次绑定时,可使用@EnableDubboConfigBindings.\n@EnableDubboConfigBinding在支持外部化配置属性与Dubbo配置类绑定时,与Dubbo过去的映射行为不同,被绑定的Dubbo配置类将会提升为Spring Bean,无需提前装配Dubbo配置类.同时,支持多Dubbo配置Bean装配.其Bean的绑定规则与@EnableDubboConfig一致.\n\n##### @EnableDubboConfigBinding注解\n\n```java\n@Target({ElementType.TYPE, ElementType.ANNOTATION_TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Import(DubboConfigBindingRegistrar.class)\npublic @interface EnableDubboConfigBinding {\n\n    /**\n     * 指定待绑定Dubbo配置类的外部化配置属性的前缀,比如dubbo.application为 ApplicationConfig的外部化配置属性的前缀.\n     * prefix()支持占位符(Placeholder),\n     * 并且其关联前缀值是否以\".\"作为结尾字符是可选的,即\"dubbo.application\"与\"dubbo.application.\"效果相同\n     * 例如：\"dubbo.application.\" 或 \"dubbo.application\"\n     * The name prefix of the properties that are valid to bind to {@link AbstractConfig Dubbo Config}.\n     *\n     * @return the name prefix of the properties to bind\n     */\n    String prefix();\n\n    /**\n     * 绑定的Dubbo配置类型,即Dubbo配置类,所有AbstractConfig的子类都可以\n     * @return The binding type of {@link AbstractConfig Dubbo Config}.\n     * @see AbstractConfig\n     * @see ApplicationConfig\n     * @see ModuleConfig\n     * @see RegistryConfig\n     */\n    Class<? extends AbstractConfig> type();\n\n    /**\n     * 是否需要将prefix()作为多个type()类型的Spring Bean外部化配置属性,默认值为false\n     * It indicates whether {@link #prefix()} binding to multiple Spring Beans.\n     *\n     * @return the default value is <code>false</code>\n     */\n    boolean multiple() default false;\n}\n\n\n/**\n * 实现了ImportBeanDefinitionRegistrar接口，允许我们注册特定的bean到Spring中\n * {@link AbstractConfig Dubbo Config} binding Bean registrar\n *\n * @see EnableDubboConfigBinding\n * @see DubboConfigBindingBeanPostProcessor\n * @since 2.5.8\n */\npublic class DubboConfigBindingRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware {\n\n    private final Log log = LogFactory.getLog(getClass());\n\n    private ConfigurableEnvironment environment;\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n\n        //获取@EnableDubboConfigBinding注解\n        AnnotationAttributes attributes = AnnotationAttributes.fromMap(\n                importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBinding.class.getName()));\n        //处理@EnableDubboConfigBinding注解属性并注册bean\n        registerBeanDefinitions(attributes, registry);\n    }\n\n    /**\n     * 读取@EnableDubboConfigBinding注解属性值，然后注册bean\n     * @param attributes\n     * @param registry\n     */\n    protected void registerBeanDefinitions(AnnotationAttributes attributes, BeanDefinitionRegistry registry) {\n\n        //获取@EnableDubboConfigBinding注解的prefix属性，并处理占位符\n        String prefix = environment.resolvePlaceholders(attributes.getString(\"prefix\"));\n        //获取@EnableDubboConfigBinding注解的type属性\n        Class<? extends AbstractConfig> configClass = attributes.getClass(\"type\");\n        //获取@EnableDubboConfigBinding注解的multiple属性\n        boolean multiple = attributes.getBoolean(\"multiple\");\n        //注册Dubbo配置bean\n        registerDubboConfigBeans(prefix, configClass, multiple, registry);\n    }\n\n    /**\n     * 注册bean\n     * @param prefix 属性前缀\n     * @param configClass 待配置的config类\n     * @param multiple\n     * @param registry\n     */\n    private void registerDubboConfigBeans(String prefix,\n                                          Class<? extends AbstractConfig> configClass,\n                                          boolean multiple,\n                                          BeanDefinitionRegistry registry) {\n\n        /**\n         * @Configuration\n           @PropertySource(value = \"classpath:resources.properties\", ignoreResourceNotFound = false)\n           public class AppConfig { }\n         */\n        //根据prefix从配置文件中找到相关的属性值\n        //多bean绑定：\n        //prefix:\n        //  applications.prefix = dubbo.apps.\n        //properties:\n        //  applicationBean.name = dubbo-demo-application\n        //  applicationBean2.name = dubbo-demo-application2\n        //单bean绑定：prefix = dubbo.module.\n        //  dubbo.module.id = moduleBean  =>  id = moduleBean\n        //  dubbo.module.name = dubbo-demo-module => name = dubbo-demo-module\n        Map<String, String> properties = getSubProperties(environment.getPropertySources(), prefix);\n\n        //如果没有配置属性的话，则直接返回\n        if (CollectionUtils.isEmpty(properties)) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"There is no property for binding to dubbo config class [\" + configClass.getName()\n                        + \"] within prefix [\" + prefix + \"]\");\n            }\n            return;\n        }\n\n        //获取bean名称列表(即外部配置文件中配置的)\n        Set<String> beanNames = multiple ? resolveMultipleBeanNames(properties) :\n                Collections.singleton(resolveSingleBeanName(properties, configClass, registry));\n        //遍历bean名称列表\n        for (String beanName : beanNames) {\n            //最终注册bean的地方\n            registerDubboConfigBean(beanName, configClass, registry);\n            //注册DubboConfigBindingBeanPostProcessor类\n            registerDubboConfigBindingBeanPostProcessor(prefix, beanName, multiple, registry);\n        }\n    }\n\n    /**\n     * 使用beanName注册bean：configClass\n     * @param beanName\n     * @param configClass 配置类\n     * @param registry\n     */\n    private void registerDubboConfigBean(String beanName, Class<? extends AbstractConfig> configClass,\n                                         BeanDefinitionRegistry registry) {\n\n        BeanDefinitionBuilder builder = rootBeanDefinition(configClass);\n        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();\n        //使用beanName注册bean：configClass\n        registry.registerBeanDefinition(beanName, beanDefinition);\n        if (log.isInfoEnabled()) {\n            log.info(\"The dubbo config bean definition [name : \" + beanName + \", class : \" + configClass.getName() +\n                    \"] has been registered.\");\n        }\n    }\n\n    /**\n     * 注册DubboConfigBindingBeanPostProcessor类\n     * 用来处理dubbo config bean\n     * @param prefix  属性前缀\n     * @param beanName 已注册的config配置类的beanName\n     * @param multiple \n     * @param registry\n     */\n    private void registerDubboConfigBindingBeanPostProcessor(String prefix, String beanName, boolean multiple,\n                                                             BeanDefinitionRegistry registry) {\n\n        Class<?> processorClass = DubboConfigBindingBeanPostProcessor.class;\n        \n        BeanDefinitionBuilder builder = rootBeanDefinition(processorClass);\n        \n        //如果是multiple的话，则最终前缀：prefix+\".\"+beanName\n        //否则的话，最终前缀：prefix\n        String actualPrefix = multiple ? normalizePrefix(prefix) + beanName : prefix;\n        \n        //通过构造函数注入属性：prefix、beanName\n        builder.addConstructorArgValue(actualPrefix).addConstructorArgValue(beanName);\n        //获取beanDefinition\n        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();\n        //设置不可代理\n        beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n        //注册DubboConfigBindingBeanPostProcessor\n        registerWithGeneratedName(beanDefinition, registry);\n\n        if (log.isInfoEnabled()) {\n            log.info(\"The BeanPostProcessor bean definition [\" + processorClass.getName()\n                    + \"] for dubbo config bean [name : \" + beanName + \"] has been registered.\");\n        }\n    }\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        Assert.isInstanceOf(ConfigurableEnvironment.class, environment);\n        this.environment = (ConfigurableEnvironment) environment;\n    }\n\n    /**\n     * 处理多个bean名称\n     * @param properties 如：\n     *          applicationBean.name = dubbo-demo-application\n     *          applicationBean2.name = dubbo-demo-application2\n     * @return applicationBean、applicationBean2\n     */\n    private Set<String> resolveMultipleBeanNames(Map<String, String> properties) {\n        //保存已解决的beanNames\n        Set<String> beanNames = new LinkedHashSet<String>();\n        //遍历所有的属性名：applicationBean.name、applicationBean2.name\n        for (String propertyName : properties.keySet()) {\n            //获取\".\"符号在属性名中第一次出现的位置\n            //即判断是否存在\".\"\n            int index = propertyName.indexOf(\".\");\n            if (index > 0) {\n                //获取bean名称：applicationBean、applicationBean2\n                String beanName = propertyName.substring(0, index);\n                //保存bean名称\n                beanNames.add(beanName);\n            }\n        }\n        return beanNames;\n    }\n\n    /**\n     * 处理单个bean名称\n     * @param properties 如：\n     *      dubbo.module.id = moduleBean  =>  id = moduleBean\n     *      dubbo.module.name = dubbo-demo-module => name = dubbo-demo-module\n     * @param configClass dubbo配置类\n     * @param registry\n     * @return\n     */\n    private String resolveSingleBeanName(Map<String, String> properties,\n                                         Class<? extends AbstractConfig> configClass,\n                                         BeanDefinitionRegistry registry) {\n        //获取id属性作为bean的名称\n        String beanName = properties.get(\"id\");\n        if (!StringUtils.hasText(beanName)) {\n            //id属性为空的话\n            BeanDefinitionBuilder builder = rootBeanDefinition(configClass);\n            //则使用工具类生成bean名称\n            beanName = BeanDefinitionReaderUtils.generateBeanName(\n                    builder.getRawBeanDefinition(), registry\n            );\n        }\n        return beanName;\n    }\n}\n```\n可以看到，为每个注册的Config-bean都注册了一个DubboConfigBindingBeanPostProcessor类，现在我们看下DubboConfigBindingBeanPostProcessor类，该类实现了BeanPostProcessor接口,\n实现该接口，可以在bean实例化前后，增加一些自己的逻辑处理，同时也实现了InitializingBean接口.\n```java\n/**\n * Dubbo Config Binding {@link BeanPostProcessor}\n *\n * @see EnableDubboConfigBinding\n * @see DubboConfigBindingRegistrar\n * @since 2.5.8\n */\npublic class DubboConfigBindingBeanPostProcessor implements BeanPostProcessor, ApplicationContextAware, InitializingBean {\n\n    /**\n     * 配置属性的前缀\n     */\n    private final String prefix;\n\n    /**\n     * 绑定的Config配置类的beanName\n     */\n    private final String beanName;\n\n    private DubboConfigBinder dubboConfigBinder;\n\n    private ApplicationContext applicationContext;\n\n    /**\n     * 是否忽略未知字段\n     */\n    private boolean ignoreUnknownFields = true;\n\n    /**\n     * 是否忽略无效字段\n     */\n    private boolean ignoreInvalidFields = true;\n\n    /**\n     * @param prefix   配置属性的前缀\n     * @param beanName 绑定的Config配置类的beanName\n     */\n    public DubboConfigBindingBeanPostProcessor(String prefix, String beanName) {\n        Assert.notNull(prefix, \"The prefix of Configuration Properties must not be null\");\n        Assert.notNull(beanName, \"The name of bean must not be null\");\n        this.prefix = prefix;\n        this.beanName = beanName;\n    }\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        //如果当前实例化的bean的beanName和该处理器保存的beanName相同的话,说明是该实例化bean对应的处理器\n        //这个在之前介绍DubboConfigBindingRegistrar类时有介绍\n        if (beanName.equals(this.beanName) && bean instanceof AbstractConfig) {\n            AbstractConfig dubboConfig = (AbstractConfig) bean;\n            //通过prefix绑定beanName的属性\n            dubboConfigBinder.bind(prefix, dubboConfig);\n            if (log.isInfoEnabled()) {\n                log.info(\"The properties of bean [name : \" + beanName + \"] have been binding by prefix of \" +\n                        \"configuration properties : \" + prefix);\n            }\n        }\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        return bean;\n    }\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        if (dubboConfigBinder == null) {\n            try {\n                //先从BeanFactory中获取DubboConfigBinder实例\n                dubboConfigBinder = applicationContext.getBean(DubboConfigBinder.class);\n            } catch (BeansException ignored) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"DubboConfigBinder Bean can't be found in ApplicationContext.\");\n                }\n                //使用默认实现\n                dubboConfigBinder = createDubboConfigBinder(applicationContext.getEnvironment());\n            }\n        }\n        //设置是否忽略未知字段、无效字段\n        dubboConfigBinder.setIgnoreUnknownFields(ignoreUnknownFields);\n        dubboConfigBinder.setIgnoreInvalidFields(ignoreInvalidFields);\n    }\n\n    /**\n     * 创建DubboConfigBinder实例(默认实现)\n     * @param environment\n     * @return {@link DefaultDubboConfigBinder}\n     */\n    protected DubboConfigBinder createDubboConfigBinder(Environment environment) {\n        DefaultDubboConfigBinder defaultDubboConfigBinder = new DefaultDubboConfigBinder();\n        defaultDubboConfigBinder.setEnvironment(environment);\n        return defaultDubboConfigBinder;\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        this.applicationContext = applicationContext;\n    }\n}\n```\n然后我们看下使用到的DubboConfigBinder接口\n```java\npublic interface DubboConfigBinder extends EnvironmentAware {\n    /**\n     * 设置是否忽略未知字段，即是否忽略在目标对象中没有相应字段的绑定参数。默认值是“true”\n     * 设置为false，可以强制所有的绑定的参数在目标对象中必须有一个相应的字段\n     *\n     * Set whether to ignore unknown fields, that is, whether to ignore bind\n     * parameters that do not have corresponding fields in the target object.\n     * <p>Default is \"true\". Turn this off to enforce that all bind parameters\n     * must have a matching field in the target object.\n     * @see #bind\n     */\n    void setIgnoreUnknownFields(boolean ignoreUnknownFields);\n\n    /**\n     * 是否忽略无效字段，即是否忽略在目标对象中存在相应字段，但是不可访问的绑定参数\n     * 默认为“false”\n     * Set whether to ignore invalid fields, that is, whether to ignore bind\n     * parameters that have corresponding fields in the target object which are\n     * not accessible (for example because of null values in the nested path).\n     * <p>Default is \"false\".\n     *\n     * @see #bind\n     */\n    void setIgnoreInvalidFields(boolean ignoreInvalidFields);\n\n    /**\n     * 以指定的前缀绑定相关属性到Dubbo配置对象中\n     * Bind the properties to Dubbo Config Object under specified prefix.\n     *\n     * @param prefix 属性前缀\n     * @param dubboConfig dubboConfig配置类实例\n     */\n    <C extends AbstractConfig> void bind(String prefix, C dubboConfig);\n}\n\n//抽象类\npublic abstract class AbstractDubboConfigBinder implements DubboConfigBinder {\n\n    /**\n     * 属性配置\n     */\n    private Iterable<PropertySource<?>> propertySources;\n\n    private boolean ignoreUnknownFields = true;\n\n    private boolean ignoreInvalidFields = false;\n\n    /**\n     * 获取多个PropertySource\n     */\n    protected Iterable<PropertySource<?>> getPropertySources() {\n        return propertySources;\n    }\n\n    public boolean isIgnoreUnknownFields() {\n        return ignoreUnknownFields;\n    }\n\n    @Override\n    public void setIgnoreUnknownFields(boolean ignoreUnknownFields) {\n        this.ignoreUnknownFields = ignoreUnknownFields;\n    }\n\n    public boolean isIgnoreInvalidFields() {\n        return ignoreInvalidFields;\n    }\n\n    @Override\n    public void setIgnoreInvalidFields(boolean ignoreInvalidFields) {\n        this.ignoreInvalidFields = ignoreInvalidFields;\n    }\n\n    @Override\n    public final void setEnvironment(Environment environment) {\n        if (environment instanceof ConfigurableEnvironment) {\n            //从environment中获取propertySources\n            this.propertySources = ((ConfigurableEnvironment) environment).getPropertySources();\n        }\n    }\n}\n\n\n/**\n * 默认实现 基于Spring的DataBinder\n */\npublic class DefaultDubboConfigBinder extends AbstractDubboConfigBinder {\n\n    @Override\n    public <C extends AbstractConfig> void bind(String prefix, C dubboConfig) {\n        //创建DataBinder实例，绑定dubboConfig配置类\n        DataBinder dataBinder = new DataBinder(dubboConfig);\n        // Set ignored*\n        //设置是否忽略无效字段、未知字段\n        dataBinder.setIgnoreInvalidFields(isIgnoreInvalidFields());\n        dataBinder.setIgnoreUnknownFields(isIgnoreUnknownFields());\n        //从PropertySources中获取指定前缀的属性\n        Map<String, String> properties = getSubProperties(getPropertySources(), prefix);\n        //将Map转换成MutablePropertyValues对象\n        MutablePropertyValues propertyValues = new MutablePropertyValues(properties);\n        // 进行绑定\n        dataBinder.bind(propertyValues);\n    }\n}\n```\n然后看下工具类PropertySourcesUtils中的getSubProperties方法：\n```java\n/**\n * 根据属性前缀，获取所有相关的属性和属性值\n * Get Sub {@link Properties}\n * @param propertySources {@link PropertySource} Iterable\n * @param prefix          the prefix of property name\n * @return Map<String,String>\n * @see Properties\n*/\npublic static Map<String, String> getSubProperties(Iterable<PropertySource<?>> propertySources, String prefix) {\n\tMap<String, String> subProperties = new LinkedHashMap<String, String>();\n\t//规范化前缀,即前缀结尾处补上\".\"符号\n\tString normalizedPrefix = normalizePrefix(prefix);\n\t//遍历每一个PropertySource\n\tfor (PropertySource<?> source : propertySources) {\n\t    if (source instanceof EnumerablePropertySource) {\n\t\t//遍历属性名称列表，找到以normalizedPrefix开头的属性名称\n\t\t//applications.prefix = dubbo.apps.\n\t\t//dubbo.apps.applicationBean.name = dubbo-demo-application\n\t\t//dubbo.apps.applicationBean2.name = dubbo-demo-application2\n\n\t\tfor (String name : ((EnumerablePropertySource<?>) source).getPropertyNames()) {\n\t\t    if (name.startsWith(normalizedPrefix)) {\n\t\t\t//截取子名称，如：subName = applicationBean.name/applicationBean2.name\n\t\t\tString subName = name.substring(normalizedPrefix.length());\n\t\t\t//更加属性名称name获取属性值value\n\t\t\tObject value = source.getProperty(name);\n\t\t\t//保存applicationBean.name = dubbo-demo-application\n\t\t\t//保存applicationBean2.name = dubbo-demo-application2\n\t\t\tsubProperties.put(subName, String.valueOf(value));\n\t\t    }\n\t\t}\n\t    }\n\t}\n\treturn subProperties;\n}\n```\n\n##### @EnableDubboConfigBindings注解\n该注解支持配置多个@EnableDubboConfigBinding注解\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Import(DubboConfigBindingsRegistrar.class)\npublic @interface EnableDubboConfigBindings {\n    /**\n     * The value of {@link EnableDubboConfigBindings}\n     * @return non-null\n     */\n    EnableDubboConfigBinding[] value();\n}\n\n\npublic class DubboConfigBindingsRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware {\n\n    private ConfigurableEnvironment environment;\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n\n        //获取@EnableDubboConfigBindings注解的属性值\n        AnnotationAttributes attributes = AnnotationAttributes.fromMap(\n                importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBindings.class.getName()));\n\n        AnnotationAttributes[] annotationAttributes = attributes.getAnnotationArray(\"value\");\n\n        //构造DubboConfigBindingRegistrar对象\n        DubboConfigBindingRegistrar registrar = new DubboConfigBindingRegistrar();\n        registrar.setEnvironment(environment);\n        //遍历@EnableDubboConfigBinding列表,处理每一个@EnableDubboConfigBinding注解\n        for (AnnotationAttributes element : annotationAttributes) {\n            //注册DubboConfigBindingRegistrar类\n            registrar.registerBeanDefinitions(element, registry);\n        }\n    }\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        Assert.isInstanceOf(ConfigurableEnvironment.class, environment);\n        this.environment = (ConfigurableEnvironment) environment;\n    }\n}\n```\n简单看下使用:\n```java\n//将以下内容的外部化配置文件物理路径为：classpath:/META-INF/bindings.properties\n# classpath:/META-INF/bindings.properties\n## 占位符值 : ApplicationConfig 外部配置属性前缀\napplications.prefix = dubbo.apps.\n\n## 多 ApplicationConfig Bean 绑定\ndubbo.apps.applicationBean.name = dubbo-demo-application\ndubbo.apps.applicationBean2.name = dubbo-demo-application2\ndubbo.apps.applicationBean3.name = dubbo-demo-application3\n\n## 单 ModuleConfig Bean 绑定\ndubbo.module.id = moduleBean\ndubbo.module.name = dubbo-demo-module\n\n## 单 RegistryConfig Bean 绑定\ndubbo.registry.address = zookeeper://192.168.99.100:32770\n\n\n/**\n * 新建一个DubboConfiguration类作为Dubbo配置Bean，添加@EnableDubboConfigBinding注解进行绑定\n * 然后配置@PropertySource注解指定外部配置文件\n */\n@EnableDubboConfigBindings({\n@EnableDubboConfigBinding(prefix = \"${applications.prefix}\",\n               type = ApplicationConfig.class, multiple = true), //多ApplicationConfig Bean绑定\n@EnableDubboConfigBinding(prefix = \"dubbo.module\", //不带\".\"后缀\n               type = ModuleConfig.class), //单ModuleConfig Bean绑定\n@EnableDubboConfigBinding(prefix = \"dubbo.registry.\", //带\".\"后缀\n               type = RegistryConfig.class) //单RegistryConfig Bean绑定\n})\n@PropertySource(\"META-INF/bindings.properties\")\n@Configuration\npublic class DubboConfiguration {\n\n}\n\n//新建测试类\npublic class DubboConfigurationBootstrap {\n\n\tpublic static void main(String[] args) {\n\t\t//创建配置上下文\n\t\tAnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\n\t\t//注册当前配置 Bean\n\t\tcontext.register(DubboConfiguration.class);\n\t\tcontext.refresh();\n\n\t\t//获取ApplicationConfig Bean：\"applicationBean\"、\"applicationBean2\" 和 \"applicationBean3\"\n\t\tApplicationConfig applicationBean = context.getBean(\"applicationBean\", ApplicationConfig.class);\n\t\tApplicationConfig applicationBean2 = context.getBean(\"applicationBean2\", ApplicationConfig.class);\n\t\tApplicationConfig applicationBean3 = context.getBean(\"applicationBean3\", ApplicationConfig.class);\n\t\t\n\t\t//applicationBean.name = dubbo-demo-application \n\t\t//applicationBean2.name = dubbo-demo-application2 \n\t\tcapplicationBean3.name = dubbo-demo-application3 \n\t\tSystem.out.printf(\"applicationBean.name = %s \\n\", applicationBean.getName());\n\t\tSystem.out.printf(\"applicationBean2.name = %s \\n\", applicationBean2.getName());\n\t\tSystem.out.printf(\"applicationBean3.name = %s \\n\", applicationBean3.getName());\n\n\t\t//获取ModuleConfig Bean：\"moduleBean\"\n\t\tModuleConfig moduleBean = context.getBean(\"moduleBean\", ModuleConfig.class);\n\t\t//moduleBean.name = dubbo-demo-module \n\t\tSystem.out.printf(\"moduleBean.name = %s \\n\", moduleBean.getName()); \n\n\t\t//获取RegistryConfig Bean\n\t\tRegistryConfig registry = context.getBean(RegistryConfig.class);\n\t\t//registry.address = zookeeper://192.168.99.100:32770 \n\t\tSystem.out.printf(\"registry.address = %s \\n\", registry.getAddress());\n\t}\n}\n```\n\n#### @EnableDubbo注解\n该注解等同于组合使用@DubboComponentScan和@EnableDubboConfig，上文已经介绍过，这里就不多介绍了。\n```java\n/**\n * 启用Dubbo组件作为SpringBean\n * 等同于组合使用@DubboComponentScan和@EnableDubboConfig\n */\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\n@EnableDubboConfig\n@DubboComponentScan\npublic @interface EnableDubbo {\n\n    /**\n     * 扫描@Service基础包路径\n     * Base packages to scan for annotated @Service classes.\n     * <p>\n     * Use {@link #scanBasePackageClasses()} for a type-safe alternative to String-based\n     * package names.\n     *\n     * @return the base packages to scan\n     * @see DubboComponentScan#basePackages()\n     */\n    @AliasFor(annotation = DubboComponentScan.class, attribute = \"basePackages\")\n    String[] scanBasePackages() default {};\n\n    /**\n     * Type-safe alternative to {@link #scanBasePackages()} for specifying the packages to\n     * scan for annotated @Service classes. The package of each class specified will be\n     * scanned.\n     *\n     * @return classes from the base packages to scan\n     * @see DubboComponentScan#basePackageClasses\n     */\n    @AliasFor(annotation = DubboComponentScan.class, attribute = \"basePackageClasses\")\n    Class<?>[] scanBasePackageClasses() default {};\n\n\n    /**\n     *\n     * It indicates whether {@link AbstractConfig} binding to multiple Spring Beans.\n     *\n     * @return the default value is <code>false</code>\n     * @see EnableDubboConfig#multiple()\n     */\n    @AliasFor(annotation = EnableDubboConfig.class, attribute = \"multiple\")\n    boolean multipleConfig() default false;\n}\n```\n\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之集成Spring注解解析(0202)","url":"/blog/2018/08/07/Dubbo源码阅读之集成Spring-0202注解解析/","content":">本小节将会介绍ReferenceAnnotationBeanPostProcessor类的实现\n\n### ReferenceAnnotationBeanPostProcessor类\n该类用来处理@Reference注解，它实现了BeanPostProcessor接口,实现postProcessPropertyValues方法可以处理每一个属性\n```java\npublic class ReferenceAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter\n        implements MergedBeanDefinitionPostProcessor, PriorityOrdered, ApplicationContextAware,BeanClassLoaderAware, DisposableBean {\n\n    /**\n     * ReferenceAnnotationBeanPostProcessor的bean-name\n     */\n    public static final String BEAN_NAME = \"referenceAnnotationBeanPostProcessor\";\n\n    private ApplicationContext applicationContext;\n\n    private ClassLoader classLoader;\n\n    /**\n     * beanName/className,ReferenceInjectionMetadata\n     */\n    private final ConcurrentMap<String, ReferenceInjectionMetadata> injectionMetadataCache =\n            new ConcurrentHashMap<String, ReferenceInjectionMetadata>(256);\n\n    /**\n     * cacheKey,referenceBean\n     */\n    private final ConcurrentMap<String, ReferenceBean<?>> referenceBeansCache =\n            new ConcurrentHashMap<String, ReferenceBean<?>>();\n\n    /**\n     * 设置某个属性时调用\n     * @param pvs\n     * @param pds\n     * @param bean\n     * @param beanName\n     * @return\n     * @throws BeanCreationException\n     */\n    @Override\n    public PropertyValues postProcessPropertyValues(\n            PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeanCreationException {\n        //获取bean的@Reference元数据信息\n        InjectionMetadata metadata = findReferenceMetadata(beanName, bean.getClass(), pvs);\n        try {\n            //对Bean的属性进行自动注入\n            //最终会调用内部类ReferenceFieldElement和ReferenceMethodElement的inject方法(后面会介绍)\n            metadata.inject(bean, beanName, pvs);\n        } catch (BeanCreationException ex) {\n            throw ex;\n        } catch (Throwable ex) {\n            throw new BeanCreationException(beanName, \"Injection of @Reference dependencies failed\", ex);\n        }\n        return pvs;\n    }\n\n    /**\n     * 获取clazz的@Reference元数据信息\n     * @param beanName 当前bean的名称\n     * @param clazz    当前bean的class\n     * @param pvs      当前bean的属性\n     * @return\n     */\n    private InjectionMetadata findReferenceMetadata(String beanName, Class<?> clazz, PropertyValues pvs) {\n        // Fall back to class name as cache key, for backwards compatibility with custom callers.\n        //使用beanName或者当前bean的类名称作为cacheKey\n        String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());\n        // 先从缓存中查询该cacheKey\n        ReferenceInjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);\n        //是否需要刷新(metadata == null || metadata.targetClass != clazz;则需要刷新)\n        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n            synchronized (this.injectionMetadataCache) {\n                metadata = this.injectionMetadataCache.get(cacheKey);\n                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n                    if (metadata != null) {\n                        metadata.clear(pvs);\n                    }\n                    try {\n                        //获取clazz中被@Reference注解标注的元数据信息(字段、方法)\n                        metadata = buildReferenceMetadata(clazz);\n                        //放入缓存\n                        this.injectionMetadataCache.put(cacheKey, metadata);\n                    } catch (NoClassDefFoundError err) {\n                        throw new IllegalStateException(\"Failed to introspect bean class [\" + clazz.getName() +\n                                \"] for reference metadata: could not find class that it depends on\", err);\n                    }\n                }\n            }\n        }\n        return metadata;\n    }\n\n    /**\n     * 获取beanClass类中被@Reference注解标注的方法和字段\n     * @param beanClass\n     * @return\n     */\n    private ReferenceInjectionMetadata buildReferenceMetadata(final Class<?> beanClass) {\n        //查到beanClass中存在@Reference注解的字段\n        Collection<ReferenceFieldElement> fieldElements = findFieldReferenceMetadata(beanClass);\n        //查到beanClass中存在@Reference注解的方法\n        Collection<ReferenceMethodElement> methodElements = findMethodReferenceMetadata(beanClass);\n        //创建新的元数据信息\n        return new ReferenceInjectionMetadata(beanClass, fieldElements, methodElements);\n    }\n\n\n    /**\n     * 从给定的类中查询到所有标注@Reference注解的字段\n     * 然后根据该字段和@Reference注解\n     * 创建ReferenceFieldElement类(InjectionMetadata.InjectedElement的子类)\n     * @param beanClass 当前bean的class\n     * @return non-null\n     */\n    private List<ReferenceFieldElement> findFieldReferenceMetadata(final Class<?> beanClass) {\n\n        final List<ReferenceFieldElement> elements = new LinkedList<ReferenceFieldElement>();\n        //操作字段时执行的回调\n        ReflectionUtils.doWithFields(beanClass, new ReflectionUtils.FieldCallback() {\n            @Override\n            public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException {\n                //获取字段上的@Reference注解\n                Reference reference = getAnnotation(field, Reference.class);\n                //是否存在@Reference注解\n                if (reference != null) {\n                    if (Modifier.isStatic(field.getModifiers())) {\n                        if (logger.isWarnEnabled()) {\n                            //@Reference不支持静态字段字段\n                            logger.warn(\"@Reference annotation is not supported on static fields: \" + field);\n                        }\n                        return;\n                    }\n                    //根据字段和@Reference注解创建ReferenceFieldElement对象,并保存\n                    elements.add(new ReferenceFieldElement(field, reference));\n                }\n            }\n        });\n        return elements;\n    }\n\n    /**\n     * 从标注@Reference注解的方法上找到（InjectionMetadata.InjectedElement）元数据\n     * @param beanClass 目标bean的class\n     * @return non-null {@link List}\n     */\n    private List<ReferenceMethodElement> findMethodReferenceMetadata(final Class<?> beanClass) {\n\n        final List<ReferenceMethodElement> elements = new LinkedList<ReferenceMethodElement>();\n\n        //操作方法时调用\n        ReflectionUtils.doWithMethods(beanClass, new ReflectionUtils.MethodCallback() {\n            @Override\n            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {\n\n                //获取桥接方法(https://blog.csdn.net/mhmyqn/article/details/47342577)\n                Method bridgedMethod = findBridgedMethod(method);\n\n                //参数和返回类型签名相同返回true\n                if (!isVisibilityBridgeMethodPair(method, bridgedMethod)) {\n                    return;\n                }\n                //从桥接方法上找到@Reference注解\n                Reference reference = findAnnotation(bridgedMethod, Reference.class);\n\n                //ClassUtils.getMostSpecificMethod\n                //通过给定的方法(可能来自接口)和当前反射调用中使用的目标类,找到相应的目标方法\n                if (reference != null && method.equals(ClassUtils.getMostSpecificMethod(method, beanClass))) {\n                    if (Modifier.isStatic(method.getModifiers())) {\n                        if (logger.isWarnEnabled()) {\n                            //@Reference不支持static方法\n                            logger.warn(\"@Reference annotation is not supported on static methods: \" + method);\n                        }\n                        return;\n                    }\n                    if (method.getParameterTypes().length == 0) {\n                        //@Reference注解只能用于带参数的方法\n                        if (logger.isWarnEnabled()) {\n                            logger.warn(\"@Reference  annotation should only be used on methods with parameters: \" +\n                                    method);\n                        }\n                    }\n                    //获取bridgedMethod方法的属性描述\n                    PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, beanClass);\n                    //创建ReferenceMethodElement对象，并保存\n                    elements.add(new ReferenceMethodElement(method, pd, reference));\n                }\n            }\n        });\n        return elements;\n    }\n\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        this.applicationContext = applicationContext;\n    }\n\n    @Override\n    public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n        if (beanType != null) {\n            InjectionMetadata metadata = findReferenceMetadata(beanName, beanType, null);\n            metadata.checkConfigMembers(beanDefinition);\n        }\n    }\n\n    @Override\n    public int getOrder() {\n        return LOWEST_PRECEDENCE;\n    }\n\n    @Override\n    public void destroy() throws Exception {\n\n        for (ReferenceBean referenceBean : referenceBeansCache.values()) {\n            if (logger.isInfoEnabled()) {\n                logger.info(referenceBean + \" was destroying!\");\n            }\n            //销毁referenceBean\n            referenceBean.destroy();\n        }\n        //清空injectionMetadataCache/referenceBeansCache\n        injectionMetadataCache.clear();\n        referenceBeansCache.clear();\n\n        if (logger.isInfoEnabled()) {\n            logger.info(getClass() + \" was destroying!\");\n        }\n    }\n\n    @Override\n    public void setBeanClassLoader(ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    /**\n     * 获取所有的ReferenceBean\n     * @return non-null {@link Collection}\n     * @since 2.5.9\n     */\n    public Collection<ReferenceBean<?>> getReferenceBeans() {\n        return this.referenceBeansCache.values();\n    }\n```\n##### ReferenceInjectionMetadata内部类\n```java\n    /**\n     * {@link Reference} {@link InjectionMetadata} implementation\n     *\n     * @since 2.5.11\n     */\n    private static class ReferenceInjectionMetadata extends InjectionMetadata {\n\n        private final Collection<ReferenceFieldElement> fieldElements;\n\n        private final Collection<ReferenceMethodElement> methodElements;\n\n        /**\n         * @param targetClass 目标类\n         * @param fieldElements 存在@Reference注解的字段\n         * @param methodElements 存在@Reference注解的方法\n         */\n        public ReferenceInjectionMetadata(Class<?> targetClass, Collection<ReferenceFieldElement> fieldElements,\n                                          Collection<ReferenceMethodElement> methodElements) {\n            super(targetClass, combine(fieldElements, methodElements));\n            this.fieldElements = fieldElements;\n            this.methodElements = methodElements;\n        }\n\n        /**\n         * 将fieldElements和methodElements进行合并\n         * @param elements\n         * @param <T>\n         * @return\n         */\n        private static <T> Collection<T> combine(Collection<? extends T>... elements) {\n            List<T> allElements = new ArrayList<T>();\n            for (Collection<? extends T> e : elements) {\n                allElements.addAll(e);\n            }\n            return allElements;\n        }\n\n        public Collection<ReferenceFieldElement> getFieldElements() {\n            return fieldElements;\n        }\n\n        public Collection<ReferenceMethodElement> getMethodElements() {\n            return methodElements;\n        }\n    }\n```\n\n##### ReferenceMethodElement内部类\n```java\n   /**\n     * 内部类，方法元数据，最终会调用该类的inject方法进行注入\n     */\n    private class ReferenceMethodElement extends InjectionMetadata.InjectedElement {\n\n        /**\n         * 标注@Reference注解的方法\n         */\n        private final Method method;\n\n        private final Reference reference;\n\t\n\t/**\n\t * 新生成的referenceBean\n\t */\n        private volatile ReferenceBean<?> referenceBean;\n\n        /**\n         * @param method\n         * @param pd 方法属性描述符\n         * @param reference\n         */\n        protected ReferenceMethodElement(Method method, PropertyDescriptor pd, Reference reference) {\n            super(method, pd);\n            this.method = method;\n            this.reference = reference;\n        }\n\n        @Override\n        protected void inject(Object bean, String beanName, PropertyValues pvs) throws Throwable {\n            //获取referenceClass\n            Class<?> referenceClass = pd.getPropertyType();\n            //获取referenceClass对应的referenceBean\n            referenceBean = buildReferenceBean(reference, referenceClass);\n\n            ReflectionUtils.makeAccessible(method);\n            //调用bean的method，注入依赖\n            method.invoke(bean, referenceBean.getObject());\n        }\n    }\n```\n##### ReferenceFieldElement内部类\n```java\n    /**\n     * 内部类，字段元数据，最终会调用该类的inject方法进行注入\n     */\n    private class ReferenceFieldElement extends InjectionMetadata.InjectedElement {\n        /**\n         * 标注@Reference注解的字段\n         */\n        private final Field field;\n\n        private final Reference reference;\n\n        private volatile ReferenceBean<?> referenceBean;\n\n        protected ReferenceFieldElement(Field field, Reference reference) {\n            super(field, null);\n            this.field = field;\n            this.reference = reference;\n        }\n\n        /**\n         * 注入\n         * @param bean  目标bean\n         * @param beanName 目标bean-name\n         * @param pvs\n         * @throws Throwable\n         */\n        @Override\n        protected void inject(Object bean, String beanName, PropertyValues pvs) throws Throwable {\n\n            //被@Reference注解标识的字段的类型\n            Class<?> referenceClass = field.getType();\n            //获取referenceClass对应的referenceBean\n            referenceBean = buildReferenceBean(reference, referenceClass);\n\n            ReflectionUtils.makeAccessible(field);\n            //注入依赖到目标bean中\n            field.set(bean, referenceBean.getObject());\n        }\n    }\n```\n##### buildReferenceBean方法\n```java\n    /**\n     * 根据@Reference注解和referenceClass生成ReferenceBean\n     * @param reference\n     * @param referenceClass 被@Reference注解标注的字段类型\n     * @return\n     * @throws Exception\n     */\n    private ReferenceBean<?> buildReferenceBean(Reference reference, Class<?> referenceClass) throws Exception {\n\n        //根据@Reference注解和referenceClass 生成缓存key\n        String referenceBeanCacheKey = generateReferenceBeanCacheKey(reference, referenceClass);\n\n        //先从缓存中获取ReferenceBean\n        ReferenceBean<?> referenceBean = referenceBeansCache.get(referenceBeanCacheKey);\n\n        if (referenceBean == null) {\n            //生成一个referenceBean并放入缓存(后面会分析该方法)\n            ReferenceBeanBuilder beanBuilder = ReferenceBeanBuilder\n                    .create(reference, classLoader, applicationContext)\n                    .interfaceClass(referenceClass);\n            referenceBean = beanBuilder.build();\n            referenceBeansCache.putIfAbsent(referenceBeanCacheKey, referenceBean);\n        }\n        return referenceBean;\n\n    }\n```\n```java\n    /**\n     * 为ReferenceBean创建一个缓存key\n     * @param reference {@link Reference}\n     * @param beanClass {@link Class}\n     * @return\n     */\n    private String generateReferenceBeanCacheKey(Reference reference, Class<?> beanClass) {\n        //获取接口名称(后面会分析该方法)\n        String interfaceName = resolveInterfaceName(reference, beanClass);\n        //生成缓存key\n        String key = reference.url() + \"/\" + interfaceName +\n                \"/\" + reference.version() +\n                \"/\" + reference.group();\n\n        Environment environment = applicationContext.getEnvironment();\n        //处理占位符\n        key = environment.resolvePlaceholders(key);\n        return key;\n    }\n\n    /**\n     * 获取接口名称interfaceName\n     * 先从@Reference注解属性找，找不到则取被注解的接口变量名称\n     * @param reference @Reference注解\n     * @param beanClass 被@Reference注解标注的类\n     * @return\n     * @throws IllegalStateException\n     */\n    private static String resolveInterfaceName(Reference reference, Class<?> beanClass)\n            throws IllegalStateException {\n\n        String interfaceName;\n        if (!\"\".equals(reference.interfaceName())) {\n            // @Reference注解的interfaceName属性不为空\n            interfaceName = reference.interfaceName();\n        } else if (!void.class.equals(reference.interfaceClass())) {\n            // @Reference注解的interfaceClass属性不为void\n            interfaceName = reference.interfaceClass().getName();\n        } else if (beanClass.isInterface()) {\n            // 被@Reference注解标注的类是接口类型\n            interfaceName = beanClass.getName();\n        } else {\n            //@Reference没有定义interfaceClass/interfaceName属性，beanClass不是一个接口\n            throw new IllegalStateException(\n                    \"The @Reference undefined interfaceClass or interfaceName, and the property type \"\n                            + beanClass.getName() + \" is not a interface.\");\n        }\n        return interfaceName;\n    }\n\n\n    /**\n     * 获取<field,ReferenceBean>\n     *\n     * @return non-null {@link Map}\n     * @since 2.5.11\n     */\n    public Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> getInjectedFieldReferenceBeanMap() {\n\n        Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> injectedElementReferenceBeanMap =\n                new LinkedHashMap<InjectionMetadata.InjectedElement, ReferenceBean<?>>();\n        for (ReferenceInjectionMetadata metadata : injectionMetadataCache.values()) {\n            Collection<ReferenceFieldElement> fieldElements = metadata.getFieldElements();\n            for (ReferenceFieldElement fieldElement : fieldElements) {\n                injectedElementReferenceBeanMap.put(fieldElement, fieldElement.referenceBean);\n            }\n        }\n        return injectedElementReferenceBeanMap;\n    }\n\n    /**\n     * 获取<方法，ReferenceBean>\n     * @return non-null {@link Map}\n     * @since 2.5.11\n     */\n    public Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> getInjectedMethodReferenceBeanMap() {\n\n        Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> injectedElementReferenceBeanMap =\n                new LinkedHashMap<InjectionMetadata.InjectedElement, ReferenceBean<?>>();\n\n        for (ReferenceInjectionMetadata metadata : injectionMetadataCache.values()) {\n            Collection<ReferenceMethodElement> methodElements = metadata.getMethodElements();\n            for (ReferenceMethodElement methodElement : methodElements) {\n                injectedElementReferenceBeanMap.put(methodElement, methodElement.referenceBean);\n            }\n        }\n        return injectedElementReferenceBeanMap;\n    }\n}\n```\n\n##### AbstractAnnotationConfigBeanBuilder类\n接下来我们看下ReferenceBean的创建\n\n```java\n//创建ReferenceBean\nReferenceBeanBuilder beanBuilder = ReferenceBeanBuilder\n          //create方法创建了ReferenceBeanBuilder实例\n\t  .create(reference, classLoader, applicationContext)\n\t  //设置referenceClass\n          .interfaceClass(referenceClass);\n//build方法创建ReferenceBean类\nReferenceBean<?> referenceBean = beanBuilder.build();\n```\n\n我们是通过ReferenceBeanBuilder类创建ReferenceBean的，而ReferenceBeanBuilder继承自AbstractAnnotationConfigBeanBuilder,\nAbstractAnnotationConfigBeanBuilder定义了创建配置bean的算法骨架(即build模板方法)，其他步骤都由子类ReferenceBeanBuilder负责实现。\n```java\n/**\n * Annotation bean配置构造器\n * Abstract Configurable {@link Annotation} Bean Builder\n * @since 2.5.7\n */\nabstract class AbstractAnnotationConfigBeanBuilder<A extends Annotation, B extends AbstractInterfaceConfig> {\n\n    protected final Log logger = LogFactory.getLog(getClass());\n\n    /**\n     * 注解\n     */\n    protected final A annotation;\n\n    protected final ApplicationContext applicationContext;\n\n    protected final ClassLoader classLoader;\n\n    protected Object bean;\n\n    /**\n     * 接口类\n     */\n    protected Class<?> interfaceClass;\n\n    protected AbstractAnnotationConfigBeanBuilder(A annotation, ClassLoader classLoader,\n                                                  ApplicationContext applicationContext) {\n        Assert.notNull(annotation, \"The Annotation must not be null!\");\n        Assert.notNull(classLoader, \"The ClassLoader must not be null!\");\n        Assert.notNull(applicationContext, \"The ApplicationContext must not be null!\");\n        this.annotation = annotation;\n        this.applicationContext = applicationContext;\n        this.classLoader = classLoader;\n    }\n\n    /**\n     * Build {@link B}\n     * @return non-null\n     * @throws Exception\n     */\n    public final B build() throws Exception {\n        //检测依赖\n        checkDependencies();\n        //构建B（子类实现）\n        B bean = doBuild();\n        //配置B\n        configureBean(bean);\n\n        if (logger.isInfoEnabled()) {\n            logger.info(bean + \" has been built.\");\n        }\n        return bean;\n\n    }\n\n    private void checkDependencies() {\n\n    }\n\n    /**\n     * Builds {@link B Bean}\n     *\n     * @return {@link B Bean}\n     */\n    protected abstract B doBuild();\n\n\n    protected void configureBean(B bean) throws Exception {\n\n        //子类实现\n        preConfigureBean(annotation, bean);\n\n        //配置RegistryConfig(即将RegistryConfig实例注入到B对象中)\n        configureRegistryConfigs(bean);\n\n        //配置MonitorConfig\n        configureMonitorConfig(bean);\n\n        //配置ApplicationConfig\n        configureApplicationConfig(bean);\n\n        //配置ModuleConfig\n        configureModuleConfig(bean);\n\n        //子类实现\n        postConfigureBean(annotation, bean);\n    }\n\n    protected abstract void preConfigureBean(A annotation, B bean) throws Exception;\n\n\n    /**\n     * 配置RegistryConfig\n     * @param bean\n     */\n    private void configureRegistryConfigs(B bean) {\n        //获取RegistryConfig的bean-names\n        String[] registryConfigBeanIds = resolveRegistryConfigBeanNames(annotation);\n        //根据bean-names从工厂中获取RegistryConfig实例\n        List<RegistryConfig> registryConfigs = getBeans(applicationContext, registryConfigBeanIds, RegistryConfig.class);\n        //将registryConfigs注入到B中\n        bean.setRegistries(registryConfigs);\n    }\n\n    /**\n     * 配置MonitorConfig\n     * @param bean\n     */\n    private void configureMonitorConfig(B bean) {\n        //获取MonitorConfig的bean-names\n        String monitorBeanName = resolveMonitorConfigBeanName(annotation);\n        //获取monitorConfig实例\n        MonitorConfig monitorConfig = getOptionalBean(applicationContext, monitorBeanName, MonitorConfig.class);\n        //将registryConfigs注入到B中\n        bean.setMonitor(monitorConfig);\n\n    }\n\n    /**\n     * 配置ApplicationConfig\n     * @param bean\n     */\n    private void configureApplicationConfig(B bean) {\n        //获取ApplicationConfig的bean-names\n        String applicationConfigBeanName = resolveApplicationConfigBeanName(annotation);\n\n        ApplicationConfig applicationConfig =\n                getOptionalBean(applicationContext, applicationConfigBeanName, ApplicationConfig.class);\n\n        bean.setApplication(applicationConfig);\n    }\n\n    /**\n     * 配置ModuleConfig\n     * @param bean\n     */\n    private void configureModuleConfig(B bean) {\n        //获取ModuleConfig的bean-names\n        String moduleConfigBeanName = resolveModuleConfigBeanName(annotation);\n\n        ModuleConfig moduleConfig =\n                getOptionalBean(applicationContext, moduleConfigBeanName, ModuleConfig.class);\n\n        bean.setModule(moduleConfig);\n\n    }\n\n    /**\n     * Resolves the bean name of {@link ModuleConfig}\n     *\n     * @param annotation {@link A}\n     * @return\n     */\n    protected abstract String resolveModuleConfigBeanName(A annotation);\n\n    /**\n     * Resolves the bean name of {@link ApplicationConfig}\n     *\n     * @param annotation {@link A}\n     * @return\n     */\n    protected abstract String resolveApplicationConfigBeanName(A annotation);\n\n\n    /**\n     * Resolves the bean ids of {@link com.alibaba.dubbo.config.RegistryConfig}\n     *\n     * @param annotation {@link A}\n     * @return non-empty array\n     */\n    protected abstract String[] resolveRegistryConfigBeanNames(A annotation);\n\n    /**\n     * Resolves the bean name of {@link MonitorConfig}\n     *\n     * @param annotation {@link A}\n     * @return\n     */\n    protected abstract String resolveMonitorConfigBeanName(A annotation);\n\n    /**\n     * Configures Bean\n     *\n     * @param annotation\n     * @param bean\n     */\n    protected abstract void postConfigureBean(A annotation, B bean) throws Exception;\n\n\n    public <T extends AbstractAnnotationConfigBeanBuilder<A, B>> T bean(Object bean) {\n        this.bean = bean;\n        return (T) this;\n    }\n\n    public <T extends AbstractAnnotationConfigBeanBuilder<A, B>> T interfaceClass(Class<?> interfaceClass) {\n        this.interfaceClass = interfaceClass;\n        return (T) this;\n    }\n}\n```\n##### ReferenceBeanBuilder实现类\n\n我们接下来看ReferenceBeanBuilder实现类\n```java\n/**\n * ReferenceBean 构造器\n */\nclass ReferenceBeanBuilder extends AbstractAnnotationConfigBeanBuilder<Reference, ReferenceBean> {\n\t\n    private ReferenceBeanBuilder(Reference annotation, ClassLoader classLoader, ApplicationContext applicationContext) {\n        super(annotation, classLoader, applicationContext);\n    }\n\n    /**\n     * 设置referenceBean实例的interfaceClass属性\n     * @param reference\n     * @param referenceBean\n     */\n    private void configureInterface(Reference reference, ReferenceBean referenceBean) {\n\n        //获取@Reference注解的interfaceClass属性\n        Class<?> interfaceClass = reference.interfaceClass();\n\n        if (void.class.equals(interfaceClass)) {\n            interfaceClass = null;\n            //interfaceClass属性没有配置,则取interfaceName属性\n            String interfaceClassName = reference.interfaceName();\n            if (StringUtils.hasText(interfaceClassName)) {\n                if (ClassUtils.isPresent(interfaceClassName, classLoader)) {\n                    //加载interfaceClassName类，作为interfaceClass\n                    interfaceClass = ClassUtils.resolveClassName(interfaceClassName, classLoader);\n                }\n            }\n        }\n        if (interfaceClass == null) {\n            //如果@Reference注解没有配置interfaceClass属性和interfaceName属性\n            //则使用创建对象时使用的interfaceClass\n            interfaceClass = this.interfaceClass;\n        }\n        //校验interfaceClass是接口类型\n        Assert.isTrue(interfaceClass.isInterface(),\n                \"The class of field or method that was annotated @Reference is not an interface!\");\n        //设置referenceBean对象的interfaceClass\n        referenceBean.setInterface(interfaceClass);\n    }\n\n\n    /**\n     * 设置referenceBean实例的consumer属性\n     * @param reference\n     * @param referenceBean\n     */\n    private void configureConsumerConfig(Reference reference, ReferenceBean<?> referenceBean) {\n        //获取@Reference注解的consumer属性\n        String consumerBeanName = reference.consumer();\n        //从工厂中获取ConsumerConfig实例\n        ConsumerConfig consumerConfig = getOptionalBean(applicationContext, consumerBeanName, ConsumerConfig.class);\n        //设置referenceBean实例的consumer属性\n        referenceBean.setConsumer(consumerConfig);\n    }\n\n    @Override\n    protected ReferenceBean doBuild() {\n        //创建ReferenceBean对象\n        return new ReferenceBean<Object>();\n    }\n\n    @Override\n    protected void preConfigureBean(Reference reference, ReferenceBean referenceBean) {\n        Assert.notNull(interfaceClass, \"The interface class must set first!\");\n\n        //根据referenceBean创建数据绑定对象\n        DataBinder dataBinder = new DataBinder(referenceBean);\n        //设置转换器\n        dataBinder.setConversionService(getConversionService());\n        //忽略的属性名称\n        String[] ignoreAttributeNames = of(\"application\", \"module\", \"consumer\", \"monitor\", \"registry\");\n        //dataBinder.setDisallowedFields(ignoreAttributeNames)\n        //绑定注解属性\n        dataBinder.bind(new AnnotationPropertyValuesAdapter(reference, applicationContext.getEnvironment(), ignoreAttributeNames));\n    }\n\n    /**\n     * 获取ConversionService\n     * @return\n     */\n    private ConversionService getConversionService() {\n        //创建默认转换器\n        DefaultConversionService conversionService = new DefaultConversionService();\n        //添加StringArray到String的转换\n        conversionService.addConverter(new StringArrayToStringConverter());\n        //添加StringArray到Map的转换\n        conversionService.addConverter(new StringArrayToMapConverter());\n        return conversionService;\n    }\n\n\n    @Override\n    protected String resolveModuleConfigBeanName(Reference annotation) {\n        //获取@Reference注解的module属性\n        return annotation.module();\n    }\n\n    @Override\n    protected String resolveApplicationConfigBeanName(Reference annotation) {\n        //获取@Reference注解的application属性\n        return annotation.application();\n    }\n\n    @Override\n    protected String[] resolveRegistryConfigBeanNames(Reference annotation) {\n        //获取@Reference注解的registry属性\n        return annotation.registry();\n    }\n\n    @Override\n    protected String resolveMonitorConfigBeanName(Reference annotation) {\n        //获取@Reference注解的monitor属性\n        return annotation.monitor();\n    }\n\n    @Override\n    protected void postConfigureBean(Reference annotation, ReferenceBean bean) throws Exception {\n\n        //设置applicationContext属性\n        bean.setApplicationContext(applicationContext);\n        //设置interfaceClass属性\n        configureInterface(annotation, bean);\n        //设置consumer属性\n        configureConsumerConfig(annotation, bean);\n        //属性都设置完了，开始调用bean的afterPropertiesSet方法(可见ReferenceBean实现了InitializingBean接口)\n        //在afterPropertiesSet()方法中会校验consumer/application/module/registry/monitor等属性是否为空，\n\t//为空的话,会从Spring容器中再次获取下,并重新赋值,然后会根据配置是否立即初始化该bean\n\tbean.afterPropertiesSet();\n    }\n\n    /**\n     * 创建ReferenceBeanBuilder实例\n     * @param annotation\n     * @param classLoader\n     * @param applicationContext\n     * @return\n     */\n    public static ReferenceBeanBuilder create(Reference annotation, ClassLoader classLoader,\n                                              ApplicationContext applicationContext) {\n        return new ReferenceBeanBuilder(annotation, classLoader, applicationContext);\n    }\n}\n```\n\n##### ReferenceBean类\n\n接下来来看ReferenceBean类,该类继承自ReferenceConfig类,并实现了FactoryBean接口。\n```java\n/**\n * ReferenceFactoryBean\n * @export\n */\npublic class ReferenceBean<T> extends ReferenceConfig<T> implements FactoryBean,\n        ApplicationContextAware, InitializingBean, DisposableBean {\n\n    private transient ApplicationContext applicationContext;\n\n    public ReferenceBean() {\n        super();\n    }\n\n    public ReferenceBean(Reference reference) {\n        //调用父类构造方法，在父类构造方法中会调用appendAnnotation方法处理@Reference注解的属性\n        super(reference);\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) {\n        this.applicationContext = applicationContext;\n        //将applicationContext添加到SpringExtensionFactory中\n        //SPI那一章节，我们介绍过SpringExtensionFactory类\n        SpringExtensionFactory.addApplicationContext(applicationContext);\n    }\n\n    @Override\n    public Object getObject() throws Exception {\n        //获取对象实例，调用父类中的get方法进行初始化\n        return get();\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        //调用父类中的getInterfaceClass方法获取对象类型(后面会分析该方法)\n        return getInterfaceClass();\n    }\n\n    @Override\n    @Parameter(excluded = true)\n    public boolean isSingleton() {\n        return true;\n    }\n\n    @Override\n    @SuppressWarnings({\"unchecked\"})\n    public void afterPropertiesSet() throws Exception {\n        //如果没有配置Consumer\n        if (getConsumer() == null) {\n            //获取IOC容器中的ConsumerConfig（只获取单例类型的）\n            Map<String, ConsumerConfig> consumerConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ConsumerConfig.class, false, false);\n            if (consumerConfigMap != null && consumerConfigMap.size() > 0) {\n                ConsumerConfig consumerConfig = null;\n                for (ConsumerConfig config : consumerConfigMap.values()) {\n                    //检查是否有重复的consumer配置(default属性)\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        if (consumerConfig != null) {\n                            throw new IllegalStateException(\"Duplicate consumer configs: \" + consumerConfig + \" and \" + config);\n                        }\n                        consumerConfig = config;\n                    }\n                }\n                if (consumerConfig != null) {\n                    //配置bean的consumer属性\n                    setConsumer(consumerConfig);\n                }\n            }\n        }\n        if (getApplication() == null\n                && (getConsumer() == null || getConsumer().getApplication() == null)) {\n            //从IOC容器中获取ApplicationConfig\n            Map<String, ApplicationConfig> applicationConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, false, false);\n            if (applicationConfigMap != null && applicationConfigMap.size() > 0) {\n                ApplicationConfig applicationConfig = null;\n                for (ApplicationConfig config : applicationConfigMap.values()) {\n                    //检测是否有重复的配置(default属性)\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        if (applicationConfig != null) {\n                            throw new IllegalStateException(\"Duplicate application configs: \" + applicationConfig + \" and \" + config);\n                        }\n                        applicationConfig = config;\n                    }\n                }\n                if (applicationConfig != null) {\n                    //设置bean的ApplicationConfig属性\n                    setApplication(applicationConfig);\n                }\n            }\n        }\n        if (getModule() == null\n                && (getConsumer() == null || getConsumer().getModule() == null)) {\n            //从IOC容器中获取ModuleConfig\n            Map<String, ModuleConfig> moduleConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, false, false);\n            if (moduleConfigMap != null && moduleConfigMap.size() > 0) {\n                ModuleConfig moduleConfig = null;\n                for (ModuleConfig config : moduleConfigMap.values()) {\n                    //检测是否有重复的moduleConfig\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        if (moduleConfig != null) {\n                            throw new IllegalStateException(\"Duplicate module configs: \" + moduleConfig + \" and \" + config);\n                        }\n                        moduleConfig = config;\n                    }\n                }\n                if (moduleConfig != null) {\n                    //设置module属性\n                    setModule(moduleConfig);\n                }\n            }\n        }\n        if ((getRegistries() == null || getRegistries().isEmpty())\n                && (getConsumer() == null || getConsumer().getRegistries() == null || getConsumer().getRegistries().isEmpty())\n                && (getApplication() == null || getApplication().getRegistries() == null || getApplication().getRegistries().isEmpty())) {\n            //从IOC容器中获取RegistryConfig\n            Map<String, RegistryConfig> registryConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, false, false);\n            if (registryConfigMap != null && registryConfigMap.size() > 0) {\n                List<RegistryConfig> registryConfigs = new ArrayList<RegistryConfig>();\n                        registryConfigs.add(config);\n                    }\n                }\n                if (registryConfigs != null && !registryConfigs.isEmpty()) {\n                    //设置registries属性\n                    super.setRegistries(registryConfigs);\n                }\n            }\n        }\n        if (getMonitor() == null\n                && (getConsumer() == null || getConsumer().getMonitor() == null)\n                && (getApplication() == null || getApplication().getMonitor() == null)) {\n            //从IOC容器中获取MonitorConfig\n            Map<String, MonitorConfig> monitorConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig.class, false, false);\n            if (monitorConfigMap != null && monitorConfigMap.size() > 0) {\n                MonitorConfig monitorConfig = null;\n                for (MonitorConfig config : monitorConfigMap.values()) {\n                    //检测是否有重复的MonitorConfig\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        if (monitorConfig != null) {\n                            throw new IllegalStateException(\"Duplicate monitor configs: \" + monitorConfig + \" and \" + config);\n                        }\n                        monitorConfig = config;\n                    }\n                }\n                if (monitorConfig != null) {\n                    //设置MonitorConfig属性\n                    setMonitor(monitorConfig);\n                }\n            }\n        }\n        //获取是否 立即初始化 属性init\n        Boolean b = isInit();\n        if (b == null && getConsumer() != null) {\n            //从ConsumerConfig属性中获取init\n            b = getConsumer().isInit();\n        }\n        if (b != null && b.booleanValue()) {\n            //执行初始化\n            getObject();\n        }\n    }\n\n    @Override\n    public void destroy() {\n        // do nothing\n    }\n}\n```\n接下来，我们来看下父类ReferenceConfig中的方法\n```java\n/**\n* 获取服务接口类\n* interfaceClass > GenericService.class > interfaceName\n* @return\n*/\npublic Class<?> getInterfaceClass() {\n\t//interfaceClass属性不为空，直接返回\n\tif (interfaceClass != null) {\n\t    return interfaceClass;\n\t}\n\t//Reference或者Consumer的generic属性为true，则使用GenericService类\n\tif (isGeneric()\n\t\t|| (getConsumer() != null && getConsumer().isGeneric())) {\n\t    return GenericService.class;\n\t}\n\ttry {\n\t    if (interfaceName != null && interfaceName.length() > 0) {\n\t\t//interfaceName属性不为空，加载该类\n\t\tthis.interfaceClass = Class.forName(interfaceName, true, Thread.currentThread()\n\t\t\t.getContextClassLoader());\n\t    }\n\t} catch (ClassNotFoundException t) {\n\t    throw new IllegalStateException(t.getMessage(), t);\n\t}\n\treturn interfaceClass;\n}\n\n\n/**\n * 是否已销毁\n */\nprivate transient volatile boolean destroyed;\n\n/**\n * 接口代理引用\n * interface proxy reference\n */\nprivate transient volatile T ref;\n\n\n/**\n * 获取接口代理引用\n */\npublic synchronized T get() {\n        //判断是否已经销毁\n        if (destroyed) {\n            throw new IllegalStateException(\"Already destroyed!\");\n        }\n        if (ref == null) {\n            //初始化\n            init();\n        }\n        return ref;\n}\n```\n\n#### init方法\n该init方法会生成接口代理引用ref。\n```java\npublic synchronized T get() {\n        //判断是否已经销毁\n        if (destroyed) {\n            throw new IllegalStateException(\"Already destroyed!\");\n        }\n        if (ref == null) {\n            //初始化\n            init();\n        }\n        return ref;\n}\n\nprivate void init() {\n\t//已经初始化过的话，则返回\n\tif (initialized) {\n\t    return;\n\t}\n\tinitialized = true;\n\t//检测是否配置了interface属性\n\tif (interfaceName == null || interfaceName.length() == 0) {\n\t    throw new IllegalStateException(\"<dubbo:reference interface=\\\"\\\" /> interface not allow null!\");\n\t}\n\t//获取Consumer的全局配置(设置ConsumerConfig对象的属性)(后面会分析该方法)\n\tcheckDefault();\n\t//加载当前ReferenceConfig对象(即ReferenceBean)的属性信息(后面会分析该方法)\n\tappendProperties(this);\n\t//当前ReferenceConfig没有配置generic属性的话，则使用Consumer的generic属性配置\n\tif (getGeneric() == null && getConsumer() != null) {\n\t    //设置generic属性\n\t    setGeneric(getConsumer().getGeneric());\n\t}\n\t//(generic ！= null) && (generic = “true” || \"nativejava\" || \"bean\") ProtocolUtils.isGeneric返回true\n\tif (ProtocolUtils.isGeneric(getGeneric())) {\n\t    //如果配置了使用通用接口，则设置服务接口类为GenericService类\n\t    interfaceClass = GenericService.class;\n\t} else {\n\t    //否则根据interfaceName加载服务接口类\n\t    try {\n\t\tinterfaceClass = Class.forName(interfaceName, true, Thread.currentThread()\n\t\t\t.getContextClassLoader());\n\t    } catch (ClassNotFoundException e) {\n\t\tthrow new IllegalStateException(e.getMessage(), e);\n\t    }\n\t    //检测methods方法是否都存在于接口服务类interfaceClass中(后面会分析该方法)\n\t    checkInterfaceAndMethods(interfaceClass, methods);\n\t}\n\t//1、根据服务接口名称从系统配置中查找resolve：即通过-DinterfaceName=resolve配置\n\t//2、resolve为空，则加载dubbo.resolve.file文件,从resolveFile中加载resolve\n\t//   a、从系统配置文件中加载resolve文件：即-Ddubbo.resolve.file=xxx配置\n\t//   b、使用dubbo的默认resolve文件：${user.home}/dubbo-resolve.properties\n\tString resolve = System.getProperty(interfaceName);\n\tString resolveFile = null;\n\tif (resolve == null || resolve.length() == 0) {\n\t    resolveFile = System.getProperty(\"dubbo.resolve.file\");\n\t    if (resolveFile == null || resolveFile.length() == 0) {\n\t\t//没有配置resolveFile的话，则使用dubbo默认的resolve文件\n\t\t//如：System.getProperty(\"user.home\") = C:\\Users\\Administrator\n\t\t//resolveFile = userResolveFile = C:\\Users\\Administrator\\dubbo-resolve.properties\n\t\tFile userResolveFile = new File(new File(System.getProperty(\"user.home\")), \"dubbo-resolve.properties\");\n\t\tif (userResolveFile.exists()) {\n\t\t    resolveFile = userResolveFile.getAbsolutePath();\n\t\t}\n\t    }\n\t    //加载resolveFile文件\n\t    if (resolveFile != null && resolveFile.length() > 0) {\n\t\tProperties properties = new Properties();\n\t\tFileInputStream fis = null;\n\t\ttry {\n\t\t    fis = new FileInputStream(new File(resolveFile));\n\t\t    properties.load(fis);\n\t\t} catch (IOException e) {\n\t\t    throw new IllegalStateException(\"Unload \" + resolveFile + \", cause: \" + e.getMessage(), e);\n\t\t} finally {\n\t\t    try {\n\t\t\tif (null != fis) {\n\t\t\t    fis.close();\n\t\t\t}\n\t\t    } catch (IOException e) {\n\t\t\tlogger.warn(e.getMessage(), e);\n\t\t    }\n\t\t}\n\t\t//从resolveFile配置文件中加载resolve\n\t\tresolve = properties.getProperty(interfaceName);\n\t    }\n\t}\n\tif (resolve != null && resolve.length() > 0) {\n\t    url = resolve;\n\t    if (logger.isWarnEnabled()) {\n\t\tif (resolveFile != null && resolveFile.length() > 0) {\n\t\t    //使用默认dubbo resolve file\n\t\t    logger.warn(\"Using default dubbo resolve file \" + resolveFile + \" replace \" + interfaceName + \"\" + resolve + \" to p2p invoke remote service.\");\n\t\t} else {\n\t\t    //可以使用-DinterfaceName=resolve配置p2p\n\t\t    logger.warn(\"Using -D\" + interfaceName + \"=\" + resolve + \" to p2p invoke remote service.\");\n\t\t}\n\t    }\n\t}\n\t//加载注册中心、监控中心优先级\n\t//consumer > module > application\n\tif (consumer != null) {\n\t    if (application == null) {\n\t\tapplication = consumer.getApplication();\n\t    }\n\t    if (module == null) {\n\t\tmodule = consumer.getModule();\n\t    }\n\t    if (registries == null) {\n\t\tregistries = consumer.getRegistries();\n\t    }\n\t    if (monitor == null) {\n\t\tmonitor = consumer.getMonitor();\n\t    }\n\t}\n\tif (module != null) {\n\t    if (registries == null) {\n\t\tregistries = module.getRegistries();\n\t    }\n\t    if (monitor == null) {\n\t\tmonitor = module.getMonitor();\n\t    }\n\t}\n\tif (application != null) {\n\t    //<dubbo:application name=\"demo-consumer\" qosPort=\"33333\" id=\"demo-consumer\" />\n\t    if (registries == null) {\n\t\tregistries = application.getRegistries();\n\t    }\n\t    if (monitor == null) {\n\t\tmonitor = application.getMonitor();\n\t    }\n\t}\n\t//检测Application配置(后面会分析该方法)\n\tcheckApplication();\n\t//检测Stub和Mock(后面会分析该方法)\n\tcheckStubAndMock(interfaceClass);\n\n\t//记录Consumer端的服务接口相关信息\n\tMap<String, String> map = new HashMap<String, String>();\n\t//保存方法属性的attributes\n\tMap<Object, Object> attributes = new HashMap<Object, Object>();\n\t//设置消费者端\n\tmap.put(Constants.SIDE_KEY, Constants.CONSUMER_SIDE);\n\t//设置dubbo版本\n\tmap.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());\n\t//设置时间戳\n\tmap.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n\tif (ConfigUtils.getPid() > 0) {\n\t    //设置父进程id\n\t    map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n\t}\n\tif (!isGeneric()) {\n\t    //不是通用泛型接口，则获取revision属性,默认等于version属性\n\t    String revision = Version.getVersion(interfaceClass, version);\n\t    if (revision != null && revision.length() > 0) {\n\t\tmap.put(\"revision\", revision);\n\t    }\n\t    //获取包装类，然后获取服务接口中的方法名称数组(后面会分析该方法)\n\t    String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();\n\t    if (methods.length == 0) {\n\t\t//在服务接口中，没有找到方法，则设置属性：methods = *\n\t\tlogger.warn(\"NO method found in service interface \" + interfaceClass.getName());\n\t\tmap.put(\"methods\", Constants.ANY_VALUE);\n\t    } else {\n\t\t//设置methods=逗号分隔的方法name\n\t\tmap.put(\"methods\", StringUtils.join(new HashSet<String>(Arrays.asList(methods)), \",\"));\n\t    }\n\t}\n\t//设置interface属性\n\tmap.put(Constants.INTERFACE_KEY, interfaceName);\n\t//添加附加参数(后面会分析该方法)\n\tappendParameters(map, application);\n\tappendParameters(map, module);\n\tappendParameters(map, consumer, Constants.DEFAULT_KEY);\n\tappendParameters(map, this);\n\t//获取服务前缀：group/interface:version\n\tString prefix = StringUtils.getServiceKey(map);\n\t//处理引用的方法列表\n\tif (methods != null && !methods.isEmpty()) {\n\t    for (MethodConfig method : methods) {\n\t\t//附加参数(后面会分析该方法)\n\t\tappendParameters(map, method, method.getName());\n\t\t//处理方法重试\n\t\tString retryKey = method.getName() + \".retry\";\n\t\tif (map.containsKey(retryKey)) {\n\t\t    //将属性retryKey从map中移除\n\t\t    String retryValue = map.remove(retryKey);\n\t\t    if (\"false\".equals(retryValue)) {\n\t\t\t//属性retryKey的值为false,则添加新的属性到map中(即禁用方法重试)\n\t\t\tmap.put(method.getName() + \".retries\", \"0\");\n\t\t    }\n\t\t}\n\t\t//附加属性(后面会分析该方法)\n\t\tappendAttributes(attributes, method, prefix + \".\" + method.getName());\n\t\t//attributes保存的是方法名，调用checkAndConvertImplicitConfig方法后将会保存Method实例\n\t\tcheckAndConvertImplicitConfig(method, map, attributes);\n\t    }\n\t}\n\t//从系统配置属性中获取：注册到注册中心的ip\n\tString hostToRegistry = ConfigUtils.getSystemProperty(Constants.DUBBO_IP_TO_REGISTRY);\n\tif (hostToRegistry == null || hostToRegistry.length() == 0) {\n\t    //获取本地地址,如：192.168.99.60\n\t    hostToRegistry = NetUtils.getLocalHost();\n\t} else if (isInvalidLocalHost(hostToRegistry)) {\n\t    //无效的地址\n\t    throw new IllegalArgumentException(\"Specified invalid registry ip from property:\" + Constants.DUBBO_IP_TO_REGISTRY + \", value:\" + hostToRegistry);\n\t}\n\t//设置属性：注册到注册中心的ip\n\tmap.put(Constants.REGISTER_IP_KEY, hostToRegistry);\n\n\t//保存方法属性到系统上下文中\n\tStaticContext.getSystemContext().putAll(attributes);\n\t\n\t//根据服务接口及其属性创建代理(后面会分析该方法)\n\tref = createProxy(map);\n\t\n\t//构造ConsumerModel对象,getUniqueServiceName()生成唯一服务名称\n\tConsumerModel consumerModel = new ConsumerModel(getUniqueServiceName(), this, ref, interfaceClass.getMethods());\n\t\n\t//根据服务名称注册消费者(后面会分析该方法)\n\tApplicationModel.initConsumerModel(getUniqueServiceName(), consumerModel);\n}\n```\n接下来，我们看上面使用到的方法\n\n##### checkDefault方法\n获取Consumer的全局配置\n```java\nprivate void checkDefault() {\n        if (consumer == null) {\n\t    //consumer为空，会新创建一个ConsumerConfig对象\n            consumer = new ConsumerConfig();\n        }\n\t//调用appendProperties方法\n        appendProperties(consumer);\n}\n```\n##### appendProperties方法\n该方法在init方法中大量出现，我们先看下它的实现，它是定义在AbstractConfig抽象类中的静态方法，参数是AbstractConfig类型。\n```java\n/**\n * 附加属性\n * 找到config的所有的setXXX方法，然后切割出属性XXX，然后从系统配置/dubbo配置文件中获取到属性的值，\n * 然后执行setXXX方法把属性值设置到config对象中\n * @param config\n */\nprotected static void appendProperties(AbstractConfig config) {\n\tif (config == null) {\n\t   //config为空，直接返回\n\t   return;\n\t}\n\t//生成前缀，如： dubbo.monitor.\n\tString prefix = \"dubbo.\" + getTagName(config.getClass()) + \".\";\n\t//获取config类的所有方法\n\tMethod[] methods = config.getClass().getMethods();\n\t//遍历方法列表\n\tfor (Method method : methods) {\n\t    try {\n\t\tString name = method.getName();\n\t\t//方法名长度>3，以set开头，修饰符是public，参数个数=1，参数类型是原始类型\n\t\tif (name.length() > 3 && name.startsWith(\"set\") && Modifier.isPublic(method.getModifiers())\n\t\t\t&& method.getParameterTypes().length == 1 && isPrimitive(method.getParameterTypes()[0])) {\n\t\t    //转换方法名称为属性名称，如：setFirstName将会转换成first.name\n\t\t    //例如：property = default\n\t\t    String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), \".\");\n\n\t\t    //1、从系统配置中获取：prefix + id + property\n\t\t    //2、从系统配置中获取：prefix + property\n\t\t    //3、从config类中找到属性get方法或者is方法，然后执行该方法\n\t\t\t//3.1、从config配置中获取 prefix + id + property属性\n\t\t\t//3.2、从config配置中获取 prefix + property属性\n\t\t\t//3.3、根据prefix + property获取旧版属性legacyKey,然后根据legacyKey从config配置中获取\n\t\t    //ConfigUtils.getProperty(后面会分析该方法)\n\t\t    //如果属性值value不为空的话，则调用该set方法，将属性设置到config对象中，整个方法流程执行结束\n\t\t\t\n\t\t    String value = null;\n\t\t    if (config.getId() != null && config.getId().length() > 0) {\n\t\t\t//如果id属性不为空，则属性名称为：prefix + id + property\n\t\t\t//例如：pn = dubbo.monitor.\"id\".default\n\t\t\tString pn = prefix + config.getId() + \".\" + property;\n\t\t\t//从系统配置中获取属性pn的值value\n\t\t\tvalue = System.getProperty(pn);\n\t\t\tif (!StringUtils.isBlank(value)) {\n\t\t\t    //如果系统中设置了pn属性，则使用该属性值\n\t\t\t    logger.info(\"Use System Property \" + pn + \" to config dubbo\");\n\t\t\t}\n\t\t    }\n\t\t    if (value == null || value.length() == 0) {\n\t\t\t//属性名称为：prefix + property\n\t\t\t//例如：dubbo.monitor.default\n\t\t\tString pn = prefix + property;\n\t\t\t//获取属性pn的系统属性值value\n\t\t\tvalue = System.getProperty(pn);\n\t\t\tif (!StringUtils.isBlank(value)) {\n\t\t\t    logger.info(\"Use System Property \" + pn + \" to config dubbo\");\n\t\t\t}\n\t\t    }\n\t\t    if (value == null || value.length() == 0) {\n\t\t\tMethod getter;\n\t\t\ttry {\n\t\t\t    //获取当前属性的get方法\n\t\t\t    getter = config.getClass().getMethod(\"get\" + name.substring(3), new Class<?>[0]);\n\t\t\t} catch (NoSuchMethodException e) {\n\t\t\t    try {\n\t\t\t\t//get方法不存在的话，则获取下is方法\n\t\t\t\tgetter = config.getClass().getMethod(\"is\" + name.substring(3), new Class<?>[0]);\n\t\t\t    } catch (NoSuchMethodException e2) {\n\t\t\t\tgetter = null;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (getter != null) {\n\t\t\t    //执行config对象的属性的getter方法，结果为空的话\n\t\t\t    if (getter.invoke(config, new Object[0]) == null) {\n\t\t\t\tif (config.getId() != null && config.getId().length() > 0) {\n\t\t\t\t    //id属性不为空\n\t\t\t\t    //如：dubbo.monitor.\"id\".default\n\t\t\t\t    value = ConfigUtils.getProperty(prefix + config.getId() + \".\" + property);\n\t\t\t\t}\n\t\t\t\tif (value == null || value.length() == 0) {\n\t\t\t\t    //如：dubbo.monitor.default\n\t\t\t\t    value = ConfigUtils.getProperty(prefix + property);\n\t\t\t\t}\n\t\t\t\tif (value == null || value.length() == 0) {\n\t\t\t\t    //从旧版属性中获取(如：dubbo.monitor.default)\n\t\t\t\t    String legacyKey = legacyProperties.get(prefix + property);\n\t\t\t\t    if (legacyKey != null && legacyKey.length() > 0) {\n\t\t\t\t\t//转换旧版属性值\n\t\t\t\t\tvalue = convertLegacyValue(legacyKey, ConfigUtils.getProperty(legacyKey));\n\t\t\t\t    }\n\t\t\t\t}\n\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (value != null && value.length() > 0) {\n\t\t\t//如果属性值不为空的话，则使用属性值作为参数执行config类的method方法\n\t\t\tmethod.invoke(\n\t\t\t\tconfig,\n\t\t\t\tnew Object[]{\n\t\t\t\t\t//转换原始类型\n\t\t\t\t\tconvertPrimitive(method.getParameterTypes()[0], value)\n\t\t\t\t}\n\n\t\t\t);\n\t\t    }\n\t\t}\n\t    } catch (Exception e) {\n\t\tlogger.error(e.getMessage(), e);\n\t    }\n\t}\n}\n```\n\n##### checkInterfaceAndMethods方法\n```java\n/**\n* 判断方法methods是否都在服务接口类中存在\n* @param interfaceClass 服务接口类\n* @param methods 引用的服务接口方法\n*/\nprotected void checkInterfaceAndMethods(Class<?> interfaceClass, List<MethodConfig> methods) {\n\tif (interfaceClass == null) {\n\t    //服务接口不可以为空\n\t    throw new IllegalStateException(\"interface not allow null!\");\n\t}\n\tif (!interfaceClass.isInterface()) {\n\t    // interfaceClass必须为接口类型\n\t    throw new IllegalStateException(\"The interface class \" + interfaceClass + \" is not a interface!\");\n\t}\n\t// 检查methods方法是否存在于interfaceClass接口中\n\tif (methods != null && !methods.isEmpty()) {\n\t    //遍历引用的方法\n\t    for (MethodConfig methodBean : methods) {\n\t\t//方法名\n\t\tString methodName = methodBean.getName();\n\t\tif (methodName == null || methodName.length() == 0) {\n\t\t    //<dubbo:method>标签的name属性必须设置\n\t\t    throw new IllegalStateException(\"<dubbo:method> name attribute is required! Please check: <dubbo:service interface=\\\"\" + interfaceClass.getName() + \"\\\" ... ><dubbo:method name=\\\"\\\" ... /></<dubbo:reference>\");\n\t\t}\n\t\tboolean hasMethod = false;\n\t\tfor (java.lang.reflect.Method method : interfaceClass.getMethods()) {\n\t\t    //方法名一样，则认为存在该方法\n\t\t    if (method.getName().equals(methodName)) {\n\t\t\thasMethod = true;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (!hasMethod) {\n\t\t    //引用的方法在服务接口中不存在\n\t\t    throw new IllegalStateException(\"The interface \" + interfaceClass.getName()\n\t\t\t    + \" not found method \" + methodName);\n\t\t}\n\t    }\n\t}\n}\n```\n##### checkApplication方法\n该方法用来验证application,application为空的话，会新建ApplicationConfig对象\n```java\nprotected void checkApplication() {\n\t// 处理兼容\n\tif (application == null) {\n\t    //从配置文件中加载application.name属性\n\t    String applicationName = ConfigUtils.getProperty(\"dubbo.application.name\");\n\t    if (applicationName != null && applicationName.length() > 0) {\n\t\t//新创建一个ApplicationConfig对象\n\t\tapplication = new ApplicationConfig();\n\t    }\n\t}\n\tif (application == null) {\n\t    //需要配置 <dubbo:application name=\\\"...\\\" />\n\t    throw new IllegalStateException(\n\t\t    \"No such application config! Please add <dubbo:application name=\\\"...\\\" /> to your spring config.\");\n\t}\n\t//添加application的属性\n\tappendProperties(application);\n\t//获取配置: 服务停止时的等待时间(优先获取SHUTDOWN_WAIT_KEY属性，在获取SHUTDOWN_WAIT_SECONDS_KEY(废弃))\n\tString wait = ConfigUtils.getProperty(Constants.SHUTDOWN_WAIT_KEY);\n\tif (wait != null && wait.trim().length() > 0) {\n\t    //设置到系统配置中\n\t    System.setProperty(Constants.SHUTDOWN_WAIT_KEY, wait.trim());\n\t} else {\n\t    wait = ConfigUtils.getProperty(Constants.SHUTDOWN_WAIT_SECONDS_KEY);\n\t    if (wait != null && wait.trim().length() > 0) {\n\t\tSystem.setProperty(Constants.SHUTDOWN_WAIT_SECONDS_KEY, wait.trim());\n\t    }\n\t}\n}\n```\n\n##### checkStubAndMock方法\n该方法用来检测: 服务接口本地实现类、服务接口本地存根类、mock\n```java\n/**\n* 检测local/stub/mock的配置是否正确\n* local/stub/mock(mock 可配置为\"return \")应该为interfaceClass或者为interfaceClass子类\n* @param interfaceClass 服务接口类\n*/\nprotected void checkStubAndMock(Class<?> interfaceClass) {\n\t//处理服务接口本地实现类\n\tif (ConfigUtils.isNotEmpty(local)) {\n\t    //如果local = true或者local = default(即local属性配置),则本地实现类名为：接口名称+Local,否则本地实现类名为：local属性\n\t    //加载本地实现类\n\t    Class<?> localClass = ConfigUtils.isDefault(local) ? ReflectUtils.forName(interfaceClass.getName() + \"Local\") : ReflectUtils.forName(local);\n\t    //检查本地实现类是否实现了服务接口\n\t    if (!interfaceClass.isAssignableFrom(localClass)) {\n\t\tthrow new IllegalStateException(\"The local implementation class \" + localClass.getName() + \" not implement interface \" + interfaceClass.getName());\n\t    }\n\t    try {\n\t\t//检测本地实现类中是否存在相应的构造方法，即：public 本地实现类名 (服务接口名){}\n\t\tReflectUtils.findConstructor(localClass, interfaceClass);\n\t    } catch (NoSuchMethodException e) {\n\t\tthrow new IllegalStateException(\"No such constructor \\\"public \" + localClass.getSimpleName() + \"(\" + interfaceClass.getName() + \")\\\" in local implementation class \" + localClass.getName());\n\t    }\n\t}\n\t//处理服务接口本地存根类\n\tif (ConfigUtils.isNotEmpty(stub)) {\n\t    //如果stub = true或者stub = default(即stub属性)，则本地存根类名为：接口名称+Stub,否则本地存根类名为：stub属性\n\t    //加载本地存根类\n\t    Class<?> localClass = ConfigUtils.isDefault(stub) ? ReflectUtils.forName(interfaceClass.getName() + \"Stub\") : ReflectUtils.forName(stub);\n\t    //检测本地存根类是否实现了服务接口\n\t    if (!interfaceClass.isAssignableFrom(localClass)) {\n\t\tthrow new IllegalStateException(\"The local implementation class \" + localClass.getName() + \" not implement interface \" + interfaceClass.getName());\n\t    }\n\t    try {\n\t\t//检测本地存根类是否存在相应的构造方法, 即：public 本地存根类名 (服务接口名){}\n\t\tReflectUtils.findConstructor(localClass, interfaceClass);\n\t    } catch (NoSuchMethodException e) {\n\t\tthrow new IllegalStateException(\"No such constructor \\\"public \" + localClass.getSimpleName() + \"(\" + interfaceClass.getName() + \")\\\" in local implementation class \" + localClass.getName());\n\t    }\n\t}\n\t//处理mock\n\tif (ConfigUtils.isNotEmpty(mock)) {\n\t    //判断mock属性是否以\"return \"开头\n\t    if (mock.startsWith(Constants.RETURN_PREFIX)) {\n\t\t//获取到\"return \"之后的值\n\t\tString value = mock.substring(Constants.RETURN_PREFIX.length());\n\t\ttry {\n\t\t    //解析mock值\n\t\t    MockInvoker.parseMockValue(value);\n\t\t} catch (Exception e) {\n\t\t    throw new IllegalStateException(\"Illegal mock json value in <dubbo:service ... mock=\\\"\" + mock + \"\\\" />\");\n\t\t}\n\t    } else {\n\t\t//获取mock类\n\t\t//如果mock = true或者mock = default(即mock属性)，则本地存根类名为：接口名称+Mock,否则本地存根类名为：mock属性\n\t\tClass<?> mockClass = ConfigUtils.isDefault(mock) ? ReflectUtils.forName(interfaceClass.getName() + \"Mock\") : ReflectUtils.forName(mock);\n\t\t//检测mock类是否实现了服务接口\n\t\tif (!interfaceClass.isAssignableFrom(mockClass)) {\n\t\t    throw new IllegalStateException(\"The mock implementation class \" + mockClass.getName() + \" not implement interface \" + interfaceClass.getName());\n\t\t}\n\t\ttry {\n\t\t    //检测默认构造方法，即：pulic mock类名 () {}\n\t\t    mockClass.getConstructor(new Class<?>[0]);\n\t\t} catch (NoSuchMethodException e) {\n\t\t    throw new IllegalStateException(\"No such empty constructor \\\"public \" + mockClass.getSimpleName() + \"()\\\" in mock implementation class \" + mockClass.getName());\n\t\t}\n\t    }\n\t}\n}\n```\n##### appendParameters方法\n```java\n/**\n* 附加参数\n* 1、获取config对象的方法列表，\n* 2、找到getXXX或者isXXX方法或者getParameters方法(会通过方法上的@Parameter注解判断是否需要过滤该属性)\n* 3、然后执行该方法，拿到方法返回值(会通过方法上的@Parameter注解判断是否需要编码及追加)。\n* 然后将属性(@Parameter注解配置或者通过getXXX获取，如果配置了prefix，则属性为: prefix.属性)\n* 以及值保存到parameters中\n*\n* @param parameters 当前参数Map\n* @param config  目标配置对象\n* @param prefix 属性配置前缀\n*/\nprotected static void appendParameters(Map<String, String> parameters, Object config, String prefix) {\n\tif (config == null) {\n\t    return;\n\t}\n\t//获取配置类config的所有方法\n\tMethod[] methods = config.getClass().getMethods();\n\tfor (Method method : methods) {\n\t    try {\n\t\tString name = method.getName();\n\t\t//方法名以get或者is开头，并且方法名不为getClass，并且存在public修饰符\n\t\t//并且不存在参数，并且方法返回类型为原始类型\n\t\tif ((name.startsWith(\"get\") || name.startsWith(\"is\"))\n\t\t\t&& !\"getClass\".equals(name)\n\t\t\t&& Modifier.isPublic(method.getModifiers())\n\t\t\t&& method.getParameterTypes().length == 0\n\t\t\t&& isPrimitive(method.getReturnType())) {\n\t\t    //获取方法上的@Parameter注解\n\t\t    Parameter parameter = method.getAnnotation(Parameter.class);\n\t\t    if (method.getReturnType() == Object.class || parameter != null && parameter.excluded()) {\n\t\t\t//如果当前方法的返回类型为Object，或者该方法存在@Parameter注解且excluded属性值为true\n\t\t\t//则跳过该方法，即忽略该属性\n\t\t\tcontinue;\n\t\t    }\n\t\t    int i = name.startsWith(\"get\") ? 3 : 2;\n\t\t    //根据方法名获取到属性名，如：getFirstName被转换成：first.name\n\t\t    String prop = StringUtils.camelToSplitName(name.substring(i, i + 1).toLowerCase() + name.substring(i + 1), \".\");\n\t\t    //key为@Parameter注解的key属性或者为根据当前方法名截取到的属性名\n\t\t    String key;\n\t\t    if (parameter != null && parameter.key() != null && parameter.key().length() > 0) {\n\t\t\t//如果@Parameter注解的key属性不为空，则使用key属性\n\t\t\tkey = parameter.key();\n\t\t    } else {\n\t\t\t//否则使用prop作为key\n\t\t\tkey = prop;\n\t\t    }\n\t\t    //执行config对象的method方法，获取到方法返回值\n\t\t    Object value = method.invoke(config, new Object[0]);\n\t\t    //将方法返回值转换成字符串，并去掉空格\n\t\t    String str = String.valueOf(value).trim();\n\t\t    if (value != null && str.length() > 0) {\n\t\t\t//方法返回值不为空\n\t\t\tif (parameter != null && parameter.escaped()) {\n\t\t\t    //根据@Parameter注解的escaped属性来决定是否需要对属性值进行编码\n\t\t\t    str = URL.encode(str);\n\t\t\t}\n\t\t\tif (parameter != null && parameter.append()) {\n\t\t\t    //如果配置了@Parameter注解的append属性为true\n\t\t\t    //则从参数Map中获取key对应的值pre\n\t\t\t    String pre = parameters.get(Constants.DEFAULT_KEY + \".\" + key);\n\t\t\t    if (pre != null && pre.length() > 0) {\n\t\t\t\t//追加方法返回值\n\t\t\t\tstr = pre + \",\" + str;\n\t\t\t    }\n\t\t\t    pre = parameters.get(key);\n\t\t\t    if (pre != null && pre.length() > 0) {\n\t\t\t\t//追加方法返回值\n\t\t\t\tstr = pre + \",\" + str;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (prefix != null && prefix.length() > 0) {\n\t\t\t    //如果前缀不为空，则拼接key\n\t\t\t    key = prefix + \".\" + key;\n\t\t\t}\n\t\t\t//将key、value保存到参数Map中\n\t\t\tparameters.put(key, str);\n\t\t    } else if (parameter != null && parameter.required()) {\n\t\t\t//如果方法返回值为空，且@Parameter注解的required属性为true\n\t\t\t//则抛出异常，提示config类的key属性的值为空\n\t\t\tthrow new IllegalStateException(config.getClass().getSimpleName() + \".\" + key + \" == null\");\n\t\t    }\n\t\t} else if (\"getParameters\".equals(name)\n\t\t\t&& Modifier.isPublic(method.getModifiers())\n\t\t\t&& method.getParameterTypes().length == 0\n\t\t\t&& method.getReturnType() == Map.class) {\n\t\t    //方法名称为getParameters，且方法有public修饰符，且参数为空，且方法返回值为Map\n\t\t    //则执行config对象的getParameters方法，获取到返回值Map\n\t\t    Map<String, String> map = (Map<String, String>) method.invoke(config, new Object[0]);\n\t\t    if (map != null && map.size() > 0) {\n\t\t\t//格式化前缀，前缀以“.”结尾\n\t\t\tString pre = (prefix != null && prefix.length() > 0 ? prefix + \".\" : \"\");\n\t\t\t//遍历getParameters方法返回值\n\t\t\tfor (Map.Entry<String, String> entry : map.entrySet()) {\n\t\t\t    //将属性以及属性值保存到parameters中\n\t\t\t    parameters.put(pre + entry.getKey().replace('-', '.'), entry.getValue());\n\t\t\t}\n\t\t    }\n\t\t}\n\t    } catch (Exception e) {\n\t\tthrow new IllegalStateException(e.getMessage(), e);\n\t    }\n\t}\n}\n```\n\n##### appendAttributes方法\n```java\n/**\n* 附加属性\n* 1、获取config对象的getXXX或者isXXX方法(会通过方法上的@Parameter注解判断是否需要过滤该属性)，\n* 然后调用该方法获取返回值value。\n* 2、然后根据@Parameter注解的key属性或者当前方法名称(取消get/is前缀)作为key（prefix+\".\"+key），\n* 3、最终将key和value保存到parameters中\n* @param parameters 保存方法属性\n* @param config MethodConfig等对象\n* @param prefix\n*/\nprotected static void appendAttributes(Map<Object, Object> parameters, Object config, String prefix) {\n\tif (config == null) {\n\t    return;\n\t}\n\tMethod[] methods = config.getClass().getMethods();\n\t//遍历config对象的方法\n\tfor (Method method : methods) {\n\t    try {\n\t\t//方法名\n\t\tString name = method.getName();\n\t\t//找到get方法或者is方法\n\t\tif ((name.startsWith(\"get\") || name.startsWith(\"is\"))\n\t\t\t&& !\"getClass\".equals(name)\n\t\t\t&& Modifier.isPublic(method.getModifiers())\n\t\t\t&& method.getParameterTypes().length == 0\n\t\t\t&& isPrimitive(method.getReturnType())) {\n\t\t    //获取方法上的@Parameter注解\n\t\t    Parameter parameter = method.getAnnotation(Parameter.class);\n\t\t    if (parameter == null || !parameter.attribute()) {\n\t\t\t//如果该方法没有@Parameter注解，或者@Parameter注解的attribute属性为false\n\t\t\t//则跳过该方法\n\t\t\tcontinue;\n\t\t    }\n\t\t    //优先获取@Parameter注解的key属性，否则获取当前方法名(去掉get或者is前缀)\n\t\t    String key;\n\t\t    if (parameter.key() != null && parameter.key().length() > 0) {\n\t\t\tkey = parameter.key();\n\t\t    } else {\n\t\t\tint i = name.startsWith(\"get\") ? 3 : 2;\n\t\t\tkey = name.substring(i, i + 1).toLowerCase() + name.substring(i + 1);\n\t\t    }\n\t\t    //执行config对象的当前方法，获取方法返回值\n\t\t    Object value = method.invoke(config, new Object[0]);\n\t\t    if (value != null) {\n\t\t\tif (prefix != null && prefix.length() > 0) {\n\t\t\t    //前缀不为空的话，拼接上前缀\n\t\t\t    key = prefix + \".\" + key;\n\t\t\t}\n\t\t\t//将属性和属性值放到parameters中\n\t\t\tparameters.put(key, value);\n\t\t    }\n\t\t}\n\t    } catch (Exception e) {\n\t\tthrow new IllegalStateException(e.getMessage(), e);\n\t    }\n\t}\n}\n```\n##### checkAndConvertImplicitConfig方法\n```java\n/**\n* 处理onreturn、onthrow、oninvoke属性，将attributes中的value，从\"方法名称\"转换成\"方法对象\"\n* 如：将<onReturnMethodKey,onReturnMethod方法名>转换为<onReturnMethodKey,onReturnMethod方法对象>\n* @param method 当前方法配置\n* @param map 当前所有属性map\n* @param attributes 当前方法的属性map\n*/\nprivate static void checkAndConvertImplicitConfig(MethodConfig method, Map<String, String> map, Map<Object, Object> attributes) {\n\t//检测配置冲突\n\tif (Boolean.FALSE.equals(method.isReturn()) && (method.getOnreturn() != null || method.getOnthrow() != null)) {\n\t    //当设置了onreturn或者onthrow时，必须同时设置isReturn为true\n\t    throw new IllegalStateException(\"method config error : return attribute must be set true when onreturn or onthrow has been setted.\");\n\t}\n\n\t//attributes存的是<onReturnMethodKey,onReturnMethod方法名>\n\t//经过转换后存的是<onReturnMethodKey,onReturnMethod方法类>\n\n\t//onReturnMethodKey是属性key\n\tString onReturnMethodKey = StaticContext.getKey(map, method.getName(), Constants.ON_RETURN_METHOD_KEY);\n\t//从attributes中获取属性onReturnMethodKey对应的值(方法名)\n\tObject onReturnMethod = attributes.get(onReturnMethodKey);\n\tif (onReturnMethod != null && onReturnMethod instanceof String) {\n\t    //getMethodByName方法根据方法名onReturnMethod从类method.getOnreturn().getClass()中找到相应的方法\n\t    attributes.put(onReturnMethodKey, getMethodByName(method.getOnreturn().getClass(), onReturnMethod.toString()));\n\t}\n\t//下面的类似\n\t//convert onthrow methodName to Method\n\tString onThrowMethodKey = StaticContext.getKey(map, method.getName(), Constants.ON_THROW_METHOD_KEY);\n\tObject onThrowMethod = attributes.get(onThrowMethodKey);\n\tif (onThrowMethod != null && onThrowMethod instanceof String) {\n\t    attributes.put(onThrowMethodKey, getMethodByName(method.getOnthrow().getClass(), onThrowMethod.toString()));\n\t}\n\t//convert oninvoke methodName to Method\n\tString onInvokeMethodKey = StaticContext.getKey(map, method.getName(), Constants.ON_INVOKE_METHOD_KEY);\n\tObject onInvokeMethod = attributes.get(onInvokeMethodKey);\n\tif (onInvokeMethod != null && onInvokeMethod instanceof String) {\n\t    attributes.put(onInvokeMethodKey, getMethodByName(method.getOninvoke().getClass(), onInvokeMethod.toString()));\n\t}\n}\n```\n\n##### StaticContext类\ninit方法中，最终会将方法的属性添加到StaticContext中\n```java\nStaticContext.getSystemContext().putAll(attributes);\n\n\n/**\n * 系统上下文，只是框架内部使用\n * System context, for internal use only\n */\npublic class StaticContext extends ConcurrentHashMap<Object, Object> {\n    private static final long serialVersionUID = 1L;\n    private static final String SYSTEMNAME = \"system\";\n    private static final ConcurrentMap<String, StaticContext> context_map = new ConcurrentHashMap<String, StaticContext>();\n    private String name;\n\n    private StaticContext(String name) {\n        super();\n        this.name = name;\n    }\n\n    /**\n     * 获取系统上下文,即key为system\n     * @return\n     */\n    public static StaticContext getSystemContext() {\n        return getContext(SYSTEMNAME);\n    }\n\n    /**\n     * 根据name获取上下文\n     * @param name\n     * @return\n     */\n    public static StaticContext getContext(String name) {\n        //通过name从context_map中获取StaticContext\n        StaticContext appContext = context_map.get(name);\n        if (appContext == null) {\n            //没有获取到StaticContext，则为name新建一个StaticContext，然后放入context_map中\n            appContext = context_map.putIfAbsent(name, new StaticContext(name));\n            if (appContext == null) {\n                appContext = context_map.get(name);\n            }\n        }\n        return appContext;\n    }\n\n    /**\n     * 从context_map中移除name对应的上下文\n     * @param name\n     * @return\n     */\n    public static StaticContext remove(String name) {\n        return context_map.remove(name);\n    }\n\n    public static String getKey(URL url, String methodName, String suffix) {\n        return getKey(url.getServiceKey(), methodName, suffix);\n    }\n\n    public static String getKey(Map<String, String> paras, String methodName, String suffix) {\n        return getKey(StringUtils.getServiceKey(paras), methodName, suffix);\n    }\n\n    /**\n     * 获取唯一标识\n     * @param servicekey 服务唯一标识\n     * @param methodName 方法名\n     * @param suffix  前缀\n     * @return\n     */\n    private static String getKey(String servicekey, String methodName, String suffix) {\n        StringBuffer sb = new StringBuffer().append(servicekey).append(\".\").append(methodName).append(\".\").append(suffix);\n        return sb.toString();\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n```\n\n##### getUniqueServiceName方法\n```java\n/**\n* 获取唯一服务名称（group和version可以为空）\n* group/interfaceName:version\n* @return\n*/\n@Parameter(excluded = true)\npublic String getUniqueServiceName() {\n\tStringBuilder buf = new StringBuilder();\n\tif (group != null && group.length() > 0) {\n\t    buf.append(group).append(\"/\");\n\t}\n\tbuf.append(interfaceName);\n\tif (version != null && version.length() > 0) {\n\t    buf.append(\":\").append(version);\n\t}\n\treturn buf.toString();\n}\n```\n##### ConsumerModel类\n```java\npublic class ConsumerModel {\n    /**\n     * 元数据(即ReferenceBean实例)\n     */\n    private ReferenceConfig metadata;\n    /**\n     * 代理对象\n     */\n    private Object proxyObject;\n    /**\n     * 唯一的服务接口名称\n     */\n    private String serviceName;\n\n    private final Map<Method, ConsumerMethodModel> methodModels = new IdentityHashMap<Method, ConsumerMethodModel>();\n\n    public ConsumerModel(String serviceName,ReferenceConfig metadata, Object proxyObject, Method[] methods) {\n        this.serviceName = serviceName;\n        this.metadata = metadata;\n        this.proxyObject = proxyObject;\n\n        if (proxyObject != null) {\n            //代理对象不为空,遍历服务接口方法列表，创建ConsumerMethodModel类\n            for (Method method : methods) {\n                //<服务接口方法，ConsumerMethodModel<服务接口方法,metadata实例>>\n                methodModels.put(method, new ConsumerMethodModel(method, metadata));\n            }\n        }\n    }\n\n    /**\n     * Return service metadata for consumer\n     * @return service metadata\n     */\n    public ReferenceConfig getMetadata() {\n        return metadata;\n    }\n\n    public Object getProxyObject() {\n        return proxyObject;\n    }\n\n    /**\n     * 获取消费者端的给定方法的MethodModel\n     * Return method model for the given method on consumer side\n     *\n     * @param method method object\n     * @return method model\n     */\n    public ConsumerMethodModel getMethodModel(Method method) {\n        return methodModels.get(method);\n    }\n\n    /**\n     * 获取当前服务的所有方法MethodModel\n     * Return all method models for the current service\n     *\n     * @return method model list\n     */\n    public List<ConsumerMethodModel> getAllMethods() {\n        return new ArrayList<ConsumerMethodModel>(methodModels.values());\n    }\n\n    public String getServiceName() {\n        return serviceName;\n    }\n}\n```\n\n##### ApplicationModel类\n接下来我们简单看下ApplicationModel.initConsumerModel(getUniqueServiceName(), consumerModel);\n```java\n/**\n* 将服务的ConsumerModel方法保存到本地Map中\n* @param serviceName\n* @param consumerModel\n* @return\n*/\npublic static boolean initConsumerModel(String serviceName, ConsumerModel consumerModel) {\n\tif (consumedServices.putIfAbsent(serviceName, consumerModel) != null) {\n\t    logger.warn(\"Already register the same consumer:\" + serviceName);\n\t    return false;\n\t}\n\treturn true;\n}\n```\n\ninit方法我们还剩下两个方法没有讲解：\n1、 ref = createProxy(map); 即创建代理对象\n2、String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames(); 即包装类\n\n计划这两个方法留着后面的章节(讲完注册中心等章节后)在讲解。\n\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之集成Spring注解解析(0201)","url":"/blog/2018/08/05/Dubbo源码阅读之集成Spring-0201注解解析/","content":">本小节介绍Annotation的解析\n\n### AnnotationBeanDefinitionParser解析类\n\n```java\n该类继承自AbstractSingleBeanDefinitionParser抽象类，该抽象类规范了注册bean的骨架(即模板方法)，我们只需要实现getBeanClass方法指定待注册的bean，以及实现doParse方法表明如何解析类。\npublic class AnnotationBeanDefinitionParser extends AbstractSingleBeanDefinitionParser {\n\n    /**\n     * 解析：<dubbo:annotation package=\"\"/>\n     * @param element\n     * @param parserContext\n     * @param builder\n     */\n    @Override\n    protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {\n        //获取配置的package属性\n        String packageToScan = element.getAttribute(\"package\");\n        //逗号分隔package\n        String[] packagesToScan = trimArrayElements(commaDelimitedListToStringArray(packageToScan));\n\n        //通过构造函数设置ServiceAnnotationBeanPostProcessor类的packagesToScan属性\n        builder.addConstructorArgValue(packagesToScan);\n        //标识为基础设施类，防止该bean被代理\n        builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\n        //注册@ReferenceAnnotationBeanPostProcessor\n        registerReferenceAnnotationBeanPostProcessor(parserContext.getRegistry());\n\n    }\n\n    @Override\n    protected boolean shouldGenerateIdAsFallback() {\n        return true;\n    }\n\n    /**\n     * 注册ReferenceAnnotationBeanPostProcessor类\n     * 该类用来处理@Reference\n     * Registers {@link ReferenceAnnotationBeanPostProcessor} into {@link BeanFactory}\n     * @param registry {@link BeanDefinitionRegistry}\n     */\n    private void registerReferenceAnnotationBeanPostProcessor(BeanDefinitionRegistry registry) {\n        // Register @Reference Annotation Bean Processor\n        BeanRegistrar.registerInfrastructureBean(registry,\n                ReferenceAnnotationBeanPostProcessor.BEAN_NAME,\n                ReferenceAnnotationBeanPostProcessor.class);\n    }\n\n    @Override\n    protected Class<?> getBeanClass(Element element) {\n        //解析注册ServiceAnnotationBeanPostProcessor类\n        return ServiceAnnotationBeanPostProcessor.class;\n    }\n}\n```\n我们将ServiceAnnotationBeanPostProcessor类和ReferenceAnnotationBeanPostProcessor类注册到了Bean工厂中了，接下来我们将用两小节(0201/0202)来介绍这两个类的实现，先来看ServiceAnnotationBeanPostProcessor类的实现(0201)，ReferenceAnnotationBeanPostProcessor类放到(0202)小节介绍\n\n\n#### ServiceAnnotationBeanPostProcessor类实现\n接下来我们来分析下ServiceAnnotationBeanPostProcessor类,该类用来处理@Service注解，它实现了BeanDefinitionRegistryPostProcessor接口,实现它的postProcessBeanDefinitionRegistry方法允许我们实现自定义的注册bean定义的逻辑。同时也实现了几个以Aware为结尾的接口，例如BeanClassLoaderAware，实现了这些接口后，则ServiceAnnotationBeanPostProcessor类被实例化后将会获取相对应的资源。\n```java\npublic class ServiceAnnotationBeanPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware,\n        ResourceLoaderAware, BeanClassLoaderAware {\n\n    //分隔符\t\n    private static final String SEPARATOR = \":\";\n\n    //扫描的包路径(上面的小节介绍过，注册该bean时，会扫描包路径)\n    private final Set<String> packagesToScan;\n    \n    //实现EnvironmentAware接口，实例化后会自动注入\n    private Environment environment;\n\n    private ResourceLoader resourceLoader;\n\n    private ClassLoader classLoader;\n \n    //构造方法，参数是需要扫描的包路径\n    public ServiceAnnotationBeanPostProcessor(String... packagesToScan) {\n        this(Arrays.asList(packagesToScan));\n    }\n\n    public ServiceAnnotationBeanPostProcessor(Collection<String> packagesToScan) {\n        this(new LinkedHashSet<String>(packagesToScan));\n    }\n\n    public ServiceAnnotationBeanPostProcessor(Set<String> packagesToScan) {\n        //保存包路径\n\tthis.packagesToScan = packagesToScan;\n    }\n\t\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n\t//处理待扫描包里面的占位符(后面会分析该方法)\n        Set<String> resolvedPackagesToScan = resolvePackagesToScan(packagesToScan);\n        \n        if (!CollectionUtils.isEmpty(resolvedPackagesToScan)) {\n            //扫描包，找到存在@Service注解的类，然后注册它(后面会分析该方法)\n\t    registerServiceBeans(resolvedPackagesToScan, registry);\n        } else {\n            if (logger.isWarnEnabled()) {\n                //没有配置带扫描的包路径，将会忽略ServiceBean的注册\n                logger.warn(\"packagesToScan is empty , ServiceBean registry will be ignored!\");\n            }\n        }\n    }\n   \n    /**\n     * 处理带扫描包里面的占位符\n     * @param packagesToScan\n     * @return\n     */\n    private Set<String> resolvePackagesToScan(Set<String> packagesToScan) {\n        Set<String> resolvedPackagesToScan = new LinkedHashSet<String>(packagesToScan.size());\n        //遍历带扫描的包\n        for (String packageToScan : packagesToScan) {\n            if (StringUtils.hasText(packageToScan)) {\n                //通过environment解决占位符\n                String resolvedPackageToScan = environment.resolvePlaceholders(packageToScan.trim());\n                resolvedPackagesToScan.add(resolvedPackageToScan);\n            }\n        }\n        return resolvedPackagesToScan;\n    }\n   \n    /**\n     * 注册存在@Service注解的类\n     * @param packagesToScan 待扫描的基础包路径\n     * @param registry       {@link BeanDefinitionRegistry}\n     */\n    private void registerServiceBeans(Set<String> packagesToScan, BeanDefinitionRegistry registry) {\n\n\t//创建扫描器，用来扫描指定的包路径(后面会介绍该类)\n        DubboClassPathBeanDefinitionScanner scanner =\n                new DubboClassPathBeanDefinitionScanner(registry, environment, resourceLoader);\n\n\t//获取BeanNameGenerator实例用来生成bean name(后面会介绍该方法)\n        BeanNameGenerator beanNameGenerator = resolveBeanNameGenerator(registry);\n        \n\t//将BeanNameGenerator设置到扫描器\n        scanner.setBeanNameGenerator(beanNameGenerator);\n        \n        //设置过滤器，只扫描存在@Service注解的\n        scanner.addIncludeFilter(new AnnotationTypeFilter(Service.class));\n\n\t//遍历基础包\n        for (String packageToScan : packagesToScan) {\n\n            // 首先注册@Service bean\n            scanner.scan(packageToScan);\n\n            // 找到该包下所有存在@Service的BeanDefinition(不论是否是@ComponentScan扫描的)，\n\t    //然后为该bean生成beanName，并将该beanName和BeanDefinition包装成BeanDefinitionHolder（后面会分析该方法）\n            Set<BeanDefinitionHolder> beanDefinitionHolders =\n                    findServiceBeanDefinitionHolders(scanner, packageToScan, registry, beanNameGenerator);\n\n            if (!CollectionUtils.isEmpty(beanDefinitionHolders)) {\n                \n\t\t//遍历beanDefinitionHolders\n                for (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) {\n\t\t    //根据@Service注解 和 beanDefinition  注册ServiceBean类(后面会分析该方法)\n                    registerServiceBean(beanDefinitionHolder, registry, scanner);\n                }\n\n                if (logger.isInfoEnabled()) {\n\t\t    //输出扫描出来的@Service bean的数量，以及扫描的包路径\n                    logger.info(beanDefinitionHolders.size() + \" annotated Dubbo's @Service Components { \" +\n                            beanDefinitionHolders +\n                            \" } were scanned under package[\" + packageToScan + \"]\");\n                }\n            } else {\n                //没有扫描到\n                if (logger.isWarnEnabled()) {\n                    logger.warn(\"No Spring Bean annotating Dubbo's @Service was found under package[\"\n                            + packageToScan + \"]\");\n                }\n            }\n        }\n    }\n\n    /**\n     * 获取BeanNameGenerator\n     * @since 2.5.8\n     */\n    private BeanNameGenerator resolveBeanNameGenerator(BeanDefinitionRegistry registry) {\n\n        BeanNameGenerator beanNameGenerator = null;\n\n        if (registry instanceof SingletonBeanRegistry) {\n\t    //单例bean\n            SingletonBeanRegistry singletonBeanRegistry = SingletonBeanRegistry.class.cast(registry);\n\t    //获取beanName生成器\n            beanNameGenerator = (BeanNameGenerator) singletonBeanRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n        }\n        if (beanNameGenerator == null) {\n            if (logger.isInfoEnabled()) {\n\n                logger.info(\"BeanNameGenerator bean can't be found in BeanFactory with name [\"\n                        + CONFIGURATION_BEAN_NAME_GENERATOR + \"]\");\n                logger.info(\"BeanNameGenerator will be a instance of \" +\n                        AnnotationBeanNameGenerator.class.getName() +\n                        \" , it maybe a potential problem on bean name generation.\");\n            }\n\t    //使用AnnotationBeanNameGenerator\n            beanNameGenerator = new AnnotationBeanNameGenerator();\n        }\n        return beanNameGenerator;\n    }\n\n    /**\n     * 扫描包路径，通过过滤器找到存在@Service注解的bean，然后为该bean生成beanName，\n     * 然后将该beanName和beanDefinition封装成BeanDefinitionHolder对象，返回BeanDefinitionHolder列表\n     */\n    private Set<BeanDefinitionHolder> findServiceBeanDefinitionHolders(\n            ClassPathBeanDefinitionScanner scanner, String packageToScan, BeanDefinitionRegistry registry,\n            BeanNameGenerator beanNameGenerator) {\n \t\n\t//扫描基础包，查询候选组件（通过过滤器过滤出来的，即存在@Service注解的bean）\n        Set<BeanDefinition> beanDefinitions = scanner.findCandidateComponents(packageToScan);\n\n        Set<BeanDefinitionHolder> beanDefinitionHolders = new LinkedHashSet<BeanDefinitionHolder>(beanDefinitions.size());\n\n        for (BeanDefinition beanDefinition : beanDefinitions) {\n\t    //根据beanDefinition生成bean名称\n            String beanName = beanNameGenerator.generateBeanName(beanDefinition, registry);\n           \n\t    //根据beanName和beanDefinition创建BeanDefinitionHolder对象\n\t    BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(beanDefinition, beanName);\n           \n\t    //保存到列表\t\n\t    beanDefinitionHolders.add(beanDefinitionHolder);\n        }\n        return beanDefinitionHolders;\n    }\n\n    /**\n     * 根据@Service注解 和 beanDefinition  注册ServiceBean类\n     * Registers {@link ServiceBean} from new annotated {@link Service} {@link BeanDefinition}\n     */\n    private void registerServiceBean(BeanDefinitionHolder beanDefinitionHolder, BeanDefinitionRegistry registry,\n                                     DubboClassPathBeanDefinitionScanner scanner) {\n\t\n\t//从beanDefinitionHolder中获取beanName，然后加载该类(后面会分析该方法)\n        Class<?> beanClass = resolveClass(beanDefinitionHolder);\n\n\t//查询该bean的@Service注解(后面会分析该方法)\n        Service service = findAnnotation(beanClass, Service.class);\n\t\t\n\t//获取interfaceClass接口(后面会分析该方法)\n        Class<?> interfaceClass = resolveServiceInterfaceClass(beanClass, service);\n\t\n\t//获取bean的名称\n        String annotatedServiceBeanName = beanDefinitionHolder.getBeanName();\n\t\n\t//构建ServiceBean定义(后面会分析该方法)\n        AbstractBeanDefinition serviceBeanDefinition =\n                buildServiceBeanDefinition(service, interfaceClass, annotatedServiceBeanName);\n\t\n        //生成ServiceBean的beanName(后面会分析该方法)\n        String beanName = generateServiceBeanName(service, interfaceClass, annotatedServiceBeanName);\n\n\t//检测重复的候选bean\n        if (scanner.checkCandidate(beanName, serviceBeanDefinition)) {\n\t    //注解ServiceBean\n            registry.registerBeanDefinition(beanName, serviceBeanDefinition);\n\n            if (logger.isInfoEnabled()) {\n                logger.warn(\"The BeanDefinition[\" + serviceBeanDefinition +\n                        \"] of ServiceBean has been registered with name : \" + beanName);\n            }\n        } else {\n\t    //发现重复的bean定义，@DubboComponentScan多次扫描到同一个包？\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"The Duplicated BeanDefinition[\" + serviceBeanDefinition +\n                        \"] of ServiceBean[ bean name : \" + beanName +\n                        \"] was be found , Did @DubboComponentScan scan to same package in many times?\");\n            }\n        }\n    }\n\n    /**\n     * 生成ServiceBean的bean name\n     *\n     * @param service  @Service注解\n     * @param interfaceClass 存在@Service注解的类的接口\n     * @param annotatedServiceBeanName 存在@Service注解的Bean name\n     * @return ServiceBean@interfaceClassName#annotatedServiceBeanName\n     * @since 2.5.9\n     */\n    private String generateServiceBeanName(Service service, Class<?> interfaceClass, String annotatedServiceBeanName) {\n\t//添加\"ServiceBean\"\n        StringBuilder beanNameBuilder = new StringBuilder(ServiceBean.class.getSimpleName());\n\n\t//添加分隔符\":\" 和 annotatedServiceBeanName \n        beanNameBuilder.append(SEPARATOR).append(annotatedServiceBeanName);\n\n        //获取接口的全限定名\n        String interfaceClassName = interfaceClass.getName();\n  \n        //添加分隔符\":\" 和 interfaceClassName\n        beanNameBuilder.append(SEPARATOR).append(interfaceClassName);\n       \n  \t//获取@Service注解的version属性\n        String version = service.version();\n\t\n        if (StringUtils.hasText(version)) {\n            //添加分隔符\":\" 和 version\n\t    beanNameBuilder.append(SEPARATOR).append(version);\n        }\n\t\n\t//获取Service的group属性\n        String group = service.group();\n        if (StringUtils.hasText(group)) {\n\t    //添加分隔符\":\" 和 group\n            beanNameBuilder.append(SEPARATOR).append(group);\n        }\n\t//返回生成的bean名称\n        return beanNameBuilder.toString();\n    }\n\n    /**\n     * 处理@Service注解里的interfaceClass()，该interfaceClass不可以为空，并且必须是接口类型\n     * 1、获取@Service注解中的interfaceClass()\n     * 2、获取@Service注解中的interfaceName()，并加载\n     * 3、获取@Service注解类的第1个接口\n     * @param annotatedServiceBeanClass 存在@Service注解的类\n     * @param service @Service注解\n     * @return\n     */\n    private Class<?> resolveServiceInterfaceClass(Class<?> annotatedServiceBeanClass, Service service) {\n        \n\t//interfaceClass默认为@Service注解的interfaceClass属性\n        Class<?> interfaceClass = service.interfaceClass();\n\t\n\t\n        if (void.class.equals(interfaceClass)) {\n\t    //@Service注解的interfaceClass属性为空\n            interfaceClass = null;\n\t\t\n\t    //获取@Service注解的interfaceName属性\n            String interfaceClassName = service.interfaceName();\n            if (StringUtils.hasText(interfaceClassName)) {\n\t\t//判断是否存在interfaceClassName类\n                if (ClassUtils.isPresent(interfaceClassName, classLoader)) {\n\t\t    //加载interfaceClassName类，并赋值给interfaceClass\n                    interfaceClass = resolveClassName(interfaceClassName, classLoader);\n                }\n            }\n        }\n\n        if (interfaceClass == null) {\n\t    //获取该类的所有接口\n            Class<?>[] allInterfaces = annotatedServiceBeanClass.getInterfaces();\n            if (allInterfaces.length > 0) {\n\t\t//取第一个接口，赋值给interfaceClass\n                interfaceClass = allInterfaces[0];\n            }\n\n        }\n\t//验证不为空，且interfaceClass为接口\n        Assert.notNull(interfaceClass,\n                \"@Service interfaceClass() or interfaceName() or interface class must be present!\");\n\n        Assert.isTrue(interfaceClass.isInterface(),\n                \"The type that was annotated @Service is not an interface!\");\n\n        return interfaceClass;\n    }\n\t\n    private Class<?> resolveClass(BeanDefinitionHolder beanDefinitionHolder) {\n\t//获取bean定义\n        BeanDefinition beanDefinition = beanDefinitionHolder.getBeanDefinition();\n        return resolveClass(beanDefinition);\n\n    }\n\t\n    /**\n     * 加载类\n     */\n    private Class<?> resolveClass(BeanDefinition beanDefinition) {\n\t//获取bean的类名\n        String beanClassName = beanDefinition.getBeanClassName();\n \t//加载该类\t\n        return resolveClassName(beanClassName, classLoader);\n    }\n\n    /**\n     * 构建ServiceBean定义\n     * @param service  @Service注解\n     * @param interfaceClass 接口类\n     * @param annotatedServiceBeanName 存在@Service注解的类的bean name\n     */\n    private AbstractBeanDefinition buildServiceBeanDefinition(Service service, Class<?> interfaceClass,\n                                                              String annotatedServiceBeanName) {\n\t\n\t//获取ServiceBean的BeanDefinition构造器\n        BeanDefinitionBuilder builder = rootBeanDefinition(ServiceBean.class);\n\t\n\t//获取BeanDefinition\n        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();\n\t\n\t//获取ServiceBean的属性\n        MutablePropertyValues propertyValues = beanDefinition.getPropertyValues();\n\n\t//忽略的属性名称,这些属性的值后面会设置，从@Service注解中获取\n        String[] ignoreAttributeNames = of(\"provider\", \"monitor\", \"application\", \"module\", \"registry\", \"protocol\", \"interface\");\n\t\n\t//添加属性值(后面会介绍该类)\n        propertyValues.addPropertyValues(new AnnotationPropertyValuesAdapter(service, environment, ignoreAttributeNames));\n\n        //为ServiceBean添加ref属性，属性值为annotatedServiceBeanName(即存在@Service注解的bean name)(后面会分析该方法)\t\n        addPropertyReference(builder, \"ref\", annotatedServiceBeanName);\n        //为ServiceBean添加interface属性，属性值为interfaceClass接口的名称\n        builder.addPropertyValue(\"interface\", interfaceClass.getName());\n\n\t//获取@Service注解的provider属性(即com.alibaba.dubbo.config.ProviderConfig)\n        String providerConfigBeanName = service.provider();\n        if (StringUtils.hasText(providerConfigBeanName)) {\n\t    //为ServiceBean添加provider属性，属性值为providerConfigBeanName\n            addPropertyReference(builder, \"provider\", providerConfigBeanName);\n        }\n\n        //获取@Service注解的monitor属性(即com.alibaba.dubbo.config.MonitorConfig)\n\tString monitorConfigBeanName = service.monitor();\n        if (StringUtils.hasText(monitorConfigBeanName)) {\n\t    //为ServiceBean添加monitor属性，属性值为monitorConfigBeanName\n            addPropertyReference(builder, \"monitor\", monitorConfigBeanName);\n        }\n\n\t//获取@Service注解的application属性(即com.alibaba.dubbo.config.ApplicationConfig)\n        String applicationConfigBeanName = service.application();\n        if (StringUtils.hasText(applicationConfigBeanName)) {\n\t    //为ServiceBean添加application属性，属性值为applicationConfigBeanName\n            addPropertyReference(builder, \"application\", applicationConfigBeanName);\n        }\n\n\t//获取@Service注解的module属性(即com.alibaba.dubbo.config.ModuleConfig)\n\tString moduleConfigBeanName = service.module();\n        if (StringUtils.hasText(moduleConfigBeanName)) {\n\t    //为ServiceBean添加module属性，属性值为moduleConfigBeanName\n            addPropertyReference(builder, \"module\", moduleConfigBeanName);\n        }\n\n\n\t//获取@Service注解的registry属性(即com.alibaba.dubbo.config.RegistryConfig)\n        String[] registryConfigBeanNames = service.registry();\n\t//遍历registryConfigBeanNames，处理占位符，然后包装成RuntimeBeanReference并返回(后面会分析该方法)\n        List<RuntimeBeanReference> registryRuntimeBeanReferences = toRuntimeBeanReferences(registryConfigBeanNames);\n\n        if (!registryRuntimeBeanReferences.isEmpty()) {\n            //为ServiceBean添加registries属性\n\t    builder.addPropertyValue(\"registries\", registryRuntimeBeanReferences);\n        }\n\n        //获取@Service的protocol属性(即com.alibaba.dubbo.config.ProtocolConfig)\n\tString[] protocolConfigBeanNames = service.protocol();\n\t//处理占位符\n        List<RuntimeBeanReference> protocolRuntimeBeanReferences = toRuntimeBeanReferences(protocolConfigBeanNames);\n\n        if (!protocolRuntimeBeanReferences.isEmpty()) {\n            //为ServiceBean添加protocols属性\n\t    builder.addPropertyValue(\"protocols\", protocolRuntimeBeanReferences);\n        }\n\t//返回@ServiceBean定义\n        return builder.getBeanDefinition();\n    }\n\n\t\n    /**\n     * 处理占位符，并包装成包装成RuntimeBeanReference对象\n     * @param beanNames\n     * @return\n     */\n    private ManagedList<RuntimeBeanReference> toRuntimeBeanReferences(String... beanNames) {\n        ManagedList<RuntimeBeanReference> runtimeBeanReferences = new ManagedList<RuntimeBeanReference>();\n        if (!ObjectUtils.isEmpty(beanNames)) {\n            //遍历bean names\n            for (String beanName : beanNames) {\n\t\t//解决占位符\n                String resolvedBeanName = environment.resolvePlaceholders(beanName);\n\t\t//将beanName包装成RuntimeBeanReference对象\n                runtimeBeanReferences.add(new RuntimeBeanReference(resolvedBeanName));\n            }\n        }\n        return runtimeBeanReferences;\n    }\n    \n    /**\n     * 为ServiceBean添加propertyName属性，属性值为beanName\n     * @param builder ServiceBean定义构造器\n     * @param propertyName 属性名称\n     * @param beanName 存在@Service直接的bean name\n     */\n    private void addPropertyReference(BeanDefinitionBuilder builder, String propertyName, String beanName) {\n        //处理占位符\n\tString resolvedBeanName = environment.resolvePlaceholders(beanName);\n        //为ServiceBean添加propertyName属性，属性值为resolvedBeanName\n\tbuilder.addPropertyReference(propertyName, resolvedBeanName);\n    }\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        this.environment = environment;\n    }\n\n    @Override\n    public void setResourceLoader(ResourceLoader resourceLoader) {\n        this.resourceLoader = resourceLoader;\n    }\n\n    @Override\n    public void setBeanClassLoader(ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n}\n```\n我们再看下用到的其他类\n##### DubboClassPathBeanDefinitionScanner\n该类继承自ClassPathBeanDefinitionScanner,它提供自动扫描功能,根据提供的基础包路径,扫描classpath下该基础包路径,找到符合条件的类并注册为Spring的一个Bean,\n默认情况下,ClassPathBeanDefinitionScanner将会扫描所有用Spring指定了的注解标识的类,包括@Component、@Service、@Repository、@Controller,\n也可以对扫描的机制进行配置,设置一些Filter,只有满足Filter的类才能被注册为Bean.\n```java\npublic class DubboClassPathBeanDefinitionScanner extends ClassPathBeanDefinitionScanner {\n\n    public DubboClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry,\n                                               boolean useDefaultFilters,\n                                               Environment environment,\n                                               ResourceLoader resourceLoader) {\n        super(registry, useDefaultFilters);\n        \n\tsetEnvironment(environment);\n\n        setResourceLoader(resourceLoader);\n\n\t//会调用AnnotationConfigUtils类的registerAnnotationConfigProcessors方法\n        registerAnnotationConfigProcessors(registry);\n    }\n    public DubboClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry,\n                                               Environment environment,\n                                               ResourceLoader resourceLoader) {\n        this(registry, false, environment, resourceLoader);\n    }\n\n    @Override\n    public Set<BeanDefinitionHolder> doScan(String... basePackages) {\n        return super.doScan(basePackages);\n    }\n\n    @Override\n    public boolean checkCandidate(String beanName, BeanDefinition beanDefinition) throws IllegalStateException {\n        //检测beanName是否已经存在\n        return super.checkCandidate(beanName, beanDefinition);\n    }\n}\n```\n接下来我们看下AnnotationConfigUtils类的registerAnnotationConfigProcessors方法\n```java\npublic static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(\n\t\t\tBeanDefinitionRegistry registry, Object source) {\n\n\t//···省略···\n\tSet<BeanDefinitionHolder> beanDefs = new LinkedHashSet(4);\n\tRootBeanDefinition def;\n\n\t//注册ConfigurationClassPostProcessor\n\tif (!registry.containsBeanDefinition(\"org.springframework.context.annotation.internalConfigurationAnnotationProcessor\")) {\n\t    //1.在spring使用AnnotationConfigBeanDefinitionParser解析xml文件的时候  也就是配置annotation-config的时候\n            //2.启动在AnnotationConfigApplicationContext容器的时候\n\t    def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);\n\t    def.setSource(source);\n\t    beanDefs.add(registerPostProcessor(registry, def, \"org.springframework.context.annotation.internalConfigurationAnnotationProcessor\"));\n\t}\n\t\n\t//注册AutowiredAnnotationBeanPostProcessor \n\tif (!registry.containsBeanDefinition(\"org.springframework.context.annotation.internalAutowiredAnnotationProcessor\")) {\n\t    def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);\n\t    def.setSource(source);\n\t    beanDefs.add(registerPostProcessor(registry, def, \"org.springframework.context.annotation.internalAutowiredAnnotationProcessor\"));\n\t}\n\n\t//···省略···\n\treturn beanDefs;\n}\n```\n##### AnnotationPropertyValuesAdapter\n该类实现了Spring的PropertyValues接口，此接口是PropertyValue的集合管理类,用来储存键值对.MutablePropertyValues是其常用实现类\n在该适配器内部就是用了MutablePropertyValues实现类来进行操作。\n```java\n//我们在上文构建ServiceBean定义的时候会创建AnnotationPropertyValuesAdapter类，相关代码如下：\n//String[] ignoreAttributeNames = of(\"provider\", \"monitor\", \"application\", \"module\", \"registry\", \"protocol\", \"interface\");\n//propertyValues.addPropertyValues(new AnnotationPropertyValuesAdapter(service, environment, ignoreAttributeNames));\n//其中service参数是@Service注解，而environment参数类实现了PropertyResolver接口\n\n\nclass AnnotationPropertyValuesAdapter implements PropertyValues {\n     \n    //传过来的注解\n    private final Annotation annotation;\n    \n    //属性解决器,规范了解析底层任意property资源的接口\n    private final PropertyResolver propertyResolver;\n\n    //是否忽略默认值\n    private final boolean ignoreDefaultValue;\n\t\n    //委托类,即MutablePropertyValues\n    private final PropertyValues delegate;\n\n    public AnnotationPropertyValuesAdapter(Annotation annotation, PropertyResolver propertyResolver, boolean ignoreDefaultValue, String... ignoreAttributeNames) {\n        this.annotation = annotation;\n        this.propertyResolver = propertyResolver;\n        this.ignoreDefaultValue = ignoreDefaultValue;\n        //生成MutablePropertyValues\n        this.delegate = adapt(annotation, ignoreDefaultValue, ignoreAttributeNames);\n    }\n\n    public AnnotationPropertyValuesAdapter(Annotation annotation, PropertyResolver propertyResolver, String... ignoreAttributeNames) {\n        this(annotation, propertyResolver, true, ignoreAttributeNames);\n    }\n\n    private PropertyValues adapt(Annotation annotation, boolean ignoreDefaultValue, String... ignoreAttributeNames) {\n        //创建MutablePropertyValues类(后面会分析该方法getAttributes()\n\treturn new MutablePropertyValues(getAttributes(annotation, propertyResolver, ignoreDefaultValue, ignoreAttributeNames));\n    }\n\n    public Annotation getAnnotation() {\n        return annotation;\n    }\n\n    public boolean isIgnoreDefaultValue() {\n        return ignoreDefaultValue;\n    }\n\n    @Override\n    public PropertyValue[] getPropertyValues() {\n\t//调用委托类的方法\n        return delegate.getPropertyValues();\n    }\n\n    @Override\n    public PropertyValue getPropertyValue(String propertyName) {\n        //调用委托类的方法获取属性值\n        return delegate.getPropertyValue(propertyName);\n    }\n\n    @Override\n    public PropertyValues changesSince(PropertyValues old) {\n        return delegate.changesSince(old);\n    }\n\n    @Override\n    public boolean contains(String propertyName) {\n        return delegate.contains(propertyName);\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return delegate.isEmpty();\n    }\n}\n```\n下面我们看下AnnotationUtils.getAttributes方法\n```java\n/**\n * 获取注解的属性集合\n * @param annotation   注解\n * @param propertyResolver 属性解决器\n *    1、根据属性名称获取属性值（替换后的）\n *    2、替换${propertyName:defaultValue}格式的占位符为实际值\n * @param ignoreDefaultValue 是否忽略默认值\n * @param ignoreAttributeNames 需要忽略的属性名\n * @return <属性名，属性值>\n */\npublic static Map<String, Object> getAttributes(Annotation annotation,\n\t\t\t\t\t    PropertyResolver propertyResolver,\n\t\t\t\t\t    boolean ignoreDefaultValue,\n\t\t\t\t\t    String... ignoreAttributeNames) {\n\t\n\t//需要忽略的属性名\n\tSet<String> ignoreAttributeNamesSet = new HashSet<String>(arrayToList(ignoreAttributeNames));\n\n\t//获取annotation注解的属性map(调用的Spring的AnnotationUtils.getAnnotationAttributes方法)\n\tMap<String, Object> attributes = getAnnotationAttributes(annotation);\n\t//属性名,真实属性值\n\tMap<String, Object> actualAttributes = new LinkedHashMap<String, Object>();\n\t\n\t//是否需要处理占位符\n\tboolean requiredResolve = propertyResolver != null;\n\n\tfor (Map.Entry<String, Object> entry : attributes.entrySet()) {\n\t    //属性名称\n\t    String attributeName = entry.getKey();\n\t    //属性值\n\t    Object attributeValue = entry.getValue();\n\n\t    //忽略默认属性值\n\t    if (ignoreDefaultValue && nullSafeEquals(attributeValue, getDefaultValue(annotation, attributeName))) {\n\t\t//属性值和默认值相等，则跳过该属性\n\t\tcontinue;\n\t    }\n\n\t    //忽略属性名\n\t    if (ignoreAttributeNamesSet.contains(attributeName)) {\n\t\t//如果待忽略的属性名列表包含该属性名，则跳过该属性\n\t\tcontinue;\n\t    }\n\n\t    // 处理占位符,属性值为字符串类型\n\t    if (requiredResolve && attributeValue instanceof String) {\n\t\t//获取真实属性值\n\t\tString resolvedValue = propertyResolver.resolvePlaceholders(valueOf(attributeValue));\n\t\t//格式化真实属性值\n\t\tattributeValue = trimAllWhitespace(resolvedValue);\n\t    }\n\t    //保存属性名和真实属性值\n\t    actualAttributes.put(attributeName, attributeValue);\n\t}\n\treturn actualAttributes;\n}\n```\n\n##### ServiceBean类\n在上面的内容中，我们完成了ServiceBean类的注册，现在我们详细看看ServiceBean类.该类继承自ServiceConfig类，并且实现了众多Spring接口\n```java\n/**\n * ServiceFactoryBean\n * InitializingBean接口在bean实例化完成后将会自动调用afterPropertiesSet方法\n * DisposableBean接口在bean销毁之前调用destroy方法\n * ApplicationContextAware接口在bean实例化完成后将会注入ApplicationContext属性\n * ApplicationListener接口Spring容器初始化完成后会回调onApplicationEvent方法\n * BeanNameAware接口注入bean名称\n *\n * @export\n */\npublic class ServiceBean<T> extends ServiceConfig<T> implements InitializingBean, DisposableBean, ApplicationContextAware, ApplicationListener<ContextRefreshedEvent>, BeanNameAware {\n\n    private static final long serialVersionUID = 213195494150089726L;\n\n\n    private static transient ApplicationContext SPRING_CONTEXT;\n\n    /**\n     * @Service注解\n     */\n    private final transient Service service;\n\n    private transient ApplicationContext applicationContext;\n\n    private transient String beanName;\n\n    /**\n     * 是否支持ApplicationListener\n     */\n    private transient boolean supportedApplicationListener;\n\n    public ServiceBean() {\n        super();\n        this.service = null;\n    }\n\n    public ServiceBean(Service service) {\n        super(service);\n        this.service = service;\n    }\n\n    /**\n     * 获取Spring ApplicationContext\n     * @return\n     */\n    public static ApplicationContext getSpringContext() {\n        return SPRING_CONTEXT;\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) {\n        //设置ApplicationContext\n        this.applicationContext = applicationContext;\n        SpringExtensionFactory.addApplicationContext(applicationContext);\n        if (applicationContext != null) {\n            SPRING_CONTEXT = applicationContext;\n            try {\n                //backward compatibility to spring 2.0.1\n                //从applicationContext中获取到addApplicationListener方法\n                Method method = applicationContext.getClass().getMethod(\"addApplicationListener\", new Class<?>[]{ApplicationListener.class});\n                //调用applicationContext的addApplicationListener方法，将当前对象添加进去\n                method.invoke(applicationContext, new Object[]{this});\n                //设置支持ApplicationListener\n                supportedApplicationListener = true;\n            } catch (Throwable t) {\n                if (applicationContext instanceof AbstractApplicationContext) {\n                    try {\n                        // 向后兼容\n                        // backward compatibility to spring 2.0.1\n                        Method method = AbstractApplicationContext.class.getDeclaredMethod(\"addListener\", new Class<?>[]{ApplicationListener.class});\n                        if (!method.isAccessible()) {\n                            method.setAccessible(true);\n                        }\n                        method.invoke(applicationContext, new Object[]{this});\n                        supportedApplicationListener = true;\n                    } catch (Throwable t2) {\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void setBeanName(String name) {\n        this.beanName = name;\n    }\n\n    public Service getService() {\n        return service;\n    }\n\n    @Override\n    public void onApplicationEvent(ContextRefreshedEvent event) {\n\t//没有配置delay，或者delay = -1\n        if (isDelay() && !isExported() && !isUnexported()) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"The service ready on spring started. service: \" + getInterface());\n            }\n            //暴露服务(后面会分析该方法)\n            export();\n        }\n    }\n\n    /**\n     * 两种情况：\n     * 1、设置了延迟暴露(delay != null && delay != -1)，dubbo在Spring实例化bean的时候会对实现了InitializingBean的类进行回调，\n     * 回调方法是afterPropertySet()，如果设置了延迟暴露，dubbo在这个方法中进行服务的发布。\n     * 2、没有设置延迟或者延迟为-1，dubbo会在Spring实例化完bean之后，\n     * 在刷新容器最后一步发布ContextRefreshEvent事件的时候，\n     * 通知实现了ApplicationListener的类进行回调onApplicationEvent，dubbo会在这个方法中发布服务\n     * @return\n     */\n    private boolean isDelay() {\n        //获取delay属性\n        Integer delay = getDelay();\n        //获取服务提供者\n        ProviderConfig provider = getProvider();\n        if (delay == null && provider != null) {\n            //delay属性为空，则取服务提供者的delay属性\n            delay = provider.getDelay();\n        }\n        //(支持spring监听事件 && 没有设置延迟或者延迟为-1) 则返回true\n        return supportedApplicationListener && (delay == null || delay == -1);\n    }\n\n\t\n    /**\n     * 1、会判断ServiceBean的ProviderConfig、ApplicationConfig、ModuleConfig、List<RegistryConfig>、MonitorConfig、List<ProtocolConfig>属性是否为空，为空的话，从Spring容器中获取，然后进行赋值，其中还会检测是否存在重复的配置(default属性)\n     * 2、接着会判断并设置path属性(使用beanName)\n     * 3、根据delay属性判断是否需要暴露服务\n     */\n    @Override\n    @SuppressWarnings({\"unchecked\", \"deprecation\"})\n    public void afterPropertiesSet() throws Exception {\n        //没有配置Provider\n        if (getProvider() == null) {\n            //从IOC容器中获取到所有的Provider\n            Map<String, ProviderConfig> providerConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProviderConfig.class, false, false);\n            if (providerConfigMap != null && providerConfigMap.size() > 0) {\n                //从IOC容器中获取到所有的Protocol\n                Map<String, ProtocolConfig> protocolConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, false, false);\n                if ((protocolConfigMap == null || protocolConfigMap.size() == 0)\n                        && providerConfigMap.size() > 1) {\n                    // backward compatibility\n                    //如果没有配置Protocol，但是存在Provider的话，遍历Provider列表\n                    //从Provider列表中找到isDefault属性为true的Provider，并保存起来\n                    List<ProviderConfig> providerConfigs = new ArrayList<ProviderConfig>();\n                    for (ProviderConfig config : providerConfigMap.values()) {\n                        if (config.isDefault() != null && config.isDefault().booleanValue()) {\n                            //找到default为true的Provider\n                            providerConfigs.add(config);\n                        }\n                    }\n                    if (!providerConfigs.isEmpty()) {\n                        //根据Provider构造Protocol(废弃方法)\n                        setProviders(providerConfigs);\n                    }\n                } else {\n                    ProviderConfig providerConfig = null;\n                    //从provider列表中找到default属性为null或者为true的provider，如果找到多个则抛异常\n                    for (ProviderConfig config : providerConfigMap.values()) {\n                        //没有配置isDefault属性或者isDefault = true\n                        //检测是否存在重复的Provider配置\n                        if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                            if (providerConfig != null) {\n                                throw new IllegalStateException(\"Duplicate provider configs: \" + providerConfig + \" and \" + config);\n                            }\n                            providerConfig = config;\n                        }\n                    }\n                    if (providerConfig != null) {\n                        //设置Provider\n                        setProvider(providerConfig);\n                    }\n                }\n            }\n        }\n        if (getApplication() == null\n                && (getProvider() == null || getProvider().getApplication() == null)) {\n            //从IOC容器中找到所有的ApplicationConfig\n            Map<String, ApplicationConfig> applicationConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, false, false);\n            if (applicationConfigMap != null && applicationConfigMap.size() > 0) {\n                ApplicationConfig applicationConfig = null;\n                //检测是否存在重复的Application配置(default属性为null或者为true)\n                for (ApplicationConfig config : applicationConfigMap.values()) {\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        if (applicationConfig != null) {\n                            throw new IllegalStateException(\"Duplicate application configs: \" + applicationConfig + \" and \" + config);\n                        }\n                        applicationConfig = config;\n                    }\n                }\n                if (applicationConfig != null) {\n                    setApplication(applicationConfig);\n                }\n            }\n        }\n        if (getModule() == null\n                && (getProvider() == null || getProvider().getModule() == null)) {\n            //从IOC容器中找到所有的ModuleConfig\n            Map<String, ModuleConfig> moduleConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, false, false);\n            if (moduleConfigMap != null && moduleConfigMap.size() > 0) {\n                ModuleConfig moduleConfig = null;\n                //检测是否存在重复的Module配置(default属性为null或者为true)\n                for (ModuleConfig config : moduleConfigMap.values()) {\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        if (moduleConfig != null) {\n                            throw new IllegalStateException(\"Duplicate module configs: \" + moduleConfig + \" and \" + config);\n                        }\n                        moduleConfig = config;\n                    }\n                }\n                if (moduleConfig != null) {\n                    setModule(moduleConfig);\n                }\n            }\n        }\n        //register为空或者Provider中的register为空或者Application中的register为空\n        if ((getRegistries() == null || getRegistries().isEmpty())\n                && (getProvider() == null || getProvider().getRegistries() == null || getProvider().getRegistries().isEmpty())\n                && (getApplication() == null || getApplication().getRegistries() == null || getApplication().getRegistries().isEmpty())) {\n            //从IOC容器中获取RegistryConfig\n            Map<String, RegistryConfig> registryConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, false, false);\n            if (registryConfigMap != null && registryConfigMap.size() > 0) {\n                List<RegistryConfig> registryConfigs = new ArrayList<RegistryConfig>();\n                //遍历registry列表，从中找到default属性为null或者为true的registry，并保存起来\n                for (RegistryConfig config : registryConfigMap.values()) {\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        registryConfigs.add(config);\n                    }\n                }\n                if (registryConfigs != null && !registryConfigs.isEmpty()) {\n                    super.setRegistries(registryConfigs);\n                }\n            }\n        }\n        if (getMonitor() == null\n                && (getProvider() == null || getProvider().getMonitor() == null)\n                && (getApplication() == null || getApplication().getMonitor() == null)) {\n            Map<String, MonitorConfig> monitorConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig.class, false, false);\n            if (monitorConfigMap != null && monitorConfigMap.size() > 0) {\n                MonitorConfig monitorConfig = null;\n                //检测是否存在重复的monitor配置(default属性为空或者为true)\n                for (MonitorConfig config : monitorConfigMap.values()) {\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        if (monitorConfig != null) {\n                            throw new IllegalStateException(\"Duplicate monitor configs: \" + monitorConfig + \" and \" + config);\n                        }\n                        monitorConfig = config;\n                    }\n                }\n                if (monitorConfig != null) {\n\t\t    //设置monitor\n                    setMonitor(monitorConfig);\n                }\n            }\n        }\n        if ((getProtocols() == null || getProtocols().isEmpty())\n                && (getProvider() == null || getProvider().getProtocols() == null || getProvider().getProtocols().isEmpty())) {\n            //从IOC容器中获取ProtocolConfig\n            Map<String, ProtocolConfig> protocolConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, false, false);\n            if (protocolConfigMap != null && protocolConfigMap.size() > 0) {\n                List<ProtocolConfig> protocolConfigs = new ArrayList<ProtocolConfig>();\n                //遍历Protocol列表，从中找到default属性为空，或者为true的Protocol，并保存起来\n                for (ProtocolConfig config : protocolConfigMap.values()) {\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        protocolConfigs.add(config);\n                    }\n                }\n                if (protocolConfigs != null && !protocolConfigs.isEmpty()) {\n                    super.setProtocols(protocolConfigs);\n                }\n            }\n        }\n        if (getPath() == null || getPath().length() == 0) {\n            //path服务名称为空的话\n            if (beanName != null && beanName.length() > 0\n                    && getInterface() != null && getInterface().length() > 0\n                    && beanName.startsWith(getInterface())) {\n                //使用beanName作为服务名称\n                setPath(beanName);\n            }\n        }\n        if (!isDelay()) {\n            //配置了delay属性，暴露服务(后面会分析该方法)\n            export();\n        }\n    }\n\n    @Override\n    public void destroy() throws Exception {\n        // This will only be called for singleton scope bean, and expected to be called by spring shutdown hook when BeanFactory/ApplicationContext destroys.\n        // We will guarantee dubbo related resources being released with dubbo shutdown hook.\n        //unexport();\n    }\n\n    // merged from dubbox\n    @Override\n    protected Class getServiceClass(T ref) {\n        if (AopUtils.isAopProxy(ref)) {\n            //从Aop代理类中获取到目标对象\n            return AopUtils.getTargetClass(ref);\n        }\n        return super.getServiceClass(ref);\n    }\n}\n```\n###### export方法\nexport方法是定义在ServiceBean的父类ServiceConfig中的\n```java\npublic synchronized void export() {\n\tif (provider != null) {\n\t    if (export == null) {\n\t\t//export属性为空的话，则获取provider中的export属性\n\t\texport = provider.getExport();\n\t    }\n\t    if (delay == null) {\n\t\t//delay属性为空的话，则获取provider中的delay属性\n\t\tdelay = provider.getDelay();\n\t    }\n\t}\n\tif (export != null && !export) {\n\t    //如果不暴露服务，直接返回\n\t    return;\n\t}\n\n\tif (delay != null && delay > 0) {\n\t    //delay大于0的话，会启动线程，延迟暴露服务\n\t    delayExportExecutor.schedule(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t    doExport();\n\t\t}\n\t    }, delay, TimeUnit.MILLISECONDS);\n\t} else {\n\t    //直接暴露服务\n\t    doExport();\n\t}\n}\n```\n可以看到最终会调用doExport方法进行服务暴露\n```java\nprotected synchronized void doExport() {\n\tif (unexported) {\n\t    //检测是否已经取消服务暴露\n\t    throw new IllegalStateException(\"Already unexported!\");\n\t}\n\tif (exported) {\n\t    //已经暴露过服务，直接返回\n\t    return;\n\t}\n\texported = true;\n\t//检查服务接口interface属性是否配置\n\tif (interfaceName == null || interfaceName.length() == 0) {\n\t    throw new IllegalStateException(\"<dubbo:service interface=\\\"\\\" /> interface not allow null!\");\n\t}\n\t//检测ProviderConfig是否已配置，没有配置则进行配置(此方法在\"Dubbo源码阅读之集成Spring(03)\"中介绍过)\n\tcheckDefault();\n\tif (provider != null) {\n\t    //从provider中获取缺失的配置\n\t    if (application == null) {\n\t\tapplication = provider.getApplication();\n\t    }\n\t    if (module == null) {\n\t\tmodule = provider.getModule();\n\t    }\n\t    if (registries == null) {\n\t\tregistries = provider.getRegistries();\n\t    }\n\t    if (monitor == null) {\n\t\tmonitor = provider.getMonitor();\n\t    }\n\t    if (protocols == null) {\n\t\tprotocols = provider.getProtocols();\n\t    }\n\t}\n\tif (module != null) {\n\t    //从module中获取注册中心和监控中心\n\t    if (registries == null) {\n\t\tregistries = module.getRegistries();\n\t    }\n\t    if (monitor == null) {\n\t\tmonitor = module.getMonitor();\n\t    }\n\t}\n\tif (application != null) {\n\t    //从application中获取注册中心和监控中心\n\t    if (registries == null) {\n\t\tregistries = application.getRegistries();\n\t    }\n\t    if (monitor == null) {\n\t\tmonitor = application.getMonitor();\n\t    }\n\t}\n\t//获取服务接口类interfaceClass\n\tif (ref instanceof GenericService) {\n\t    //服务接口为GenericService类型\n\t    interfaceClass = GenericService.class;\n\t    if (StringUtils.isEmpty(generic)) {\n\t\t//generic属性为空的话，则设置为true\n\t\tgeneric = Boolean.TRUE.toString();\n\t    }\n\t} else {\n\t    try {\n\t\t//加载interfaceName类\n\t\tinterfaceClass = Class.forName(interfaceName, true, Thread.currentThread()\n\t\t\t.getContextClassLoader());\n\t    } catch (ClassNotFoundException e) {\n\t\tthrow new IllegalStateException(e.getMessage(), e);\n\t    }\n\t    //检测方法列表methods是否都在接口interfaceClass中存在\n\t    checkInterfaceAndMethods(interfaceClass, methods);\n\t    //校验ref类(ref不可以为空，并且实现了interfaceClass接口)\n\t    checkRef();\n\t    //将generic属性设置成false\n\t    generic = Boolean.FALSE.toString();\n\t}\n\t//处理服务接口本地实现类\n\tif (local != null) {\n\t    if (\"true\".equals(local)) {\n\t\t//默认情况下，实现类名称为：interfaceName + \"Local\"\n\t\tlocal = interfaceName + \"Local\";\n\t    }\n\t    Class<?> localClass;\n\t    try {\n\t\t//加载实现类\n\t\tlocalClass = ClassHelper.forNameWithThreadContextClassLoader(local);\n\t    } catch (ClassNotFoundException e) {\t\n\t\t//没有找到该实现类\n\t\tthrow new IllegalStateException(e.getMessage(), e);\n\t    }\n\t    //校验服务接口本地实现类是否实现了interfaceClass接口\n\t    if (!interfaceClass.isAssignableFrom(localClass)) {\n\t\tthrow new IllegalStateException(\"The local implementation class \" + localClass.getName() + \" not implement interface \" + interfaceName);\n\t    }\n\t}\n\t//处理服务接口本地存根实现类\n\tif (stub != null) {\n\t    if (\"true\".equals(stub)) {\n\t\t//默认情况下，实现类名称为：interfaceName + \"Stub\"\n\t\tstub = interfaceName + \"Stub\";\n\t    }\n\t    Class<?> stubClass;\n\t    try {\n\t\t//加载实现类\n\t\tstubClass = ClassHelper.forNameWithThreadContextClassLoader(stub);\n\t    } catch (ClassNotFoundException e) {\n\t\tthrow new IllegalStateException(e.getMessage(), e);\n\t    }\n\t    //校验该存根类是否实现了interfaceClass接口\n\t    if (!interfaceClass.isAssignableFrom(stubClass)) {\n\t\tthrow new IllegalStateException(\"The stub implementation class \" + stubClass.getName() + \" not implement interface \" + interfaceName);\n\t    }\n\t}\n\t//检测ApplicationConfig是否为空(会调用appendProperties方法添加属性，该方法在之前博文介绍过)\n\tcheckApplication();\n\t//检测注册中心list是否为空(从配置文件中获取dubbo.registry.address属性，然后创建RegistryConfig对象，添加属性，放入到list中)\n\tcheckRegistry();\n\t//检测协议protocols是否为空，如果为空且provider不为空，则先从provider对象中获取\n\t//然后遍历protocols，处理name(name为空，则设置为dubbo)并添加属性。\n\tcheckProtocol();\n\t//为ServiceBean对象添加属性\n\tappendProperties(this);\n\t//检测local/stub/mock配置是否正确\n\t//local/stub/mock(mock 可配置为\"return \")应该为interfaceClass或者为interfaceClass子类\n\tcheckStubAndMock(interfaceClass);\n\t//服务名称path为空的话，则设置为interfaceName\n\tif (path == null || path.length() == 0) {\n\t    path = interfaceName;\n\t}\n\t//暴露url(后面会分析该方法)\n\tdoExportUrls();\n\t//根据服务唯一名称、当前ServiceBean实例、ref 创建ProviderModel实例(后面会分析)\n\tProviderModel providerModel = new ProviderModel(getUniqueServiceName(), this, ref);\n\t//根据服务唯一名称，注册提供者服务，即放到类ApplicationModel中的变量名为providedServices的map中\n\tApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);\n}\n```\n\n###### doExportUrls方法\n该方法内部会调用loadRegistries方法构造注册中心url地址，然后调用doExportUrlsFor1Protocol方法进行服务url的暴露。\n```java\n/**\n * 暴露url\n *\nprivate void doExportUrls() {\n\t//构造注册中心地址(后面会分析该方法)\n\t//例如：registry://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&dubbo=2.0.0&pid=6384&qos.port=22222&registry=multicast&timestamp=1528347455956\n\tList<URL> registryURLs = loadRegistries(true);\n\t\n\t//例如：<dubbo:protocol name=\"dubbo\" port=\"20880\" id=\"dubbo\" />\n\tfor (ProtocolConfig protocolConfig : protocols) {\n\t    //暴露服务url\t\n\t    doExportUrlsFor1Protocol(protocolConfig, registryURLs);\n\t}\n}\n\n/**\n * 构造注册中心URL\n * 优先使用系统配置中的注册中心列表，如果没有配置，则使用RegistryConfig中配置的\n * @param provider 是否是提供者\n * @return\n */\nprotected List<URL> loadRegistries(boolean provider) {\n\t//检测registries变量(即ArrayList<RegistryConfig>。<dubbo:registry address=\"...\" />）\n\tcheckRegistry();\n\tList<URL> registryList = new ArrayList<URL>();\n\t//遍历registries\n\tif (registries != null && !registries.isEmpty()) {\n\t    for (RegistryConfig config : registries) {\n\t\t//获取当前注册中心地址\n\t\tString address = config.getAddress();\n\t\tif (address == null || address.length() == 0) {\n\t\t    //将address设置为*\n\t\t    address = Constants.ANYHOST_VALUE;\n\t\t}\n\t\t//从系统属性中获取注册中心地址\n\t\tString sysaddress = System.getProperty(\"dubbo.registry.address\");\n\t\tif (sysaddress != null && sysaddress.length() > 0) {\n\t\t    //如果系统注册中心地址不为空，则优先使用系统注册中心地址\n\t\t    address = sysaddress;\n\t\t}\n\t\tif (address != null && address.length() > 0\n\t\t\t&& !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) {\n\t\t    //地址可用\n\n\t\t    Map<String, String> map = new HashMap<String, String>();\n\t\t    //附加参数，即找到application、config类中的属性，并添加到map中\n\t\t    appendParameters(map, application);\n\t\t    appendParameters(map, config);\n\t\t    //添加服务名称\n\t\t    map.put(\"path\", RegistryService.class.getName());\n\t\t    //添加dubbo版本\n\t\t    map.put(\"dubbo\", Version.getVersion());\n\t\t    //添加时间戳\n\t\t    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n\t\t    if (ConfigUtils.getPid() > 0) {\n\t\t\t//添加pid\n\t\t\tmap.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n\t\t    }\n\t\t    //添加protocol\n\t\t    if (!map.containsKey(\"protocol\")) {\n\t\t\t//存在扩展名称为remote的RegistryFactory，则设置protocol属性为remote，否则设置为dubbo\n\t\t\tif (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension(\"remote\")) {\n\t\t\t    map.put(\"protocol\", \"remote\");\n\t\t\t} else {\n\t\t\t    map.put(\"protocol\", \"dubbo\");\n\t\t\t}\n\t\t    }\n\t\t    //根据当前注册中心地址和map生产url列表（后面会分析该方法）\n\t\t    List<URL> urls = UrlUtils.parseURLs(address, map);\n\t\t    for (URL url : urls) {\n\t\t\t//向url中添加registry参数，参数值为url的protocol属性(例如：registry=multicast)\n\t\t\turl = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());\n\t\t\t//重新设置url的protocol属性值为“registry”(后面暴露服务时，将会使用该protocol属性值作为扩展名称，获取对应的Protocol实例，因此将会使用RegistryProtocol实例，下一节会详细分析)\n\t\t\turl = url.setProtocol(Constants.REGISTRY_PROTOCOL);\n\t\t\tif ((provider && url.getParameter(Constants.REGISTER_KEY, true))\n\t\t\t\t|| (!provider && url.getParameter(Constants.SUBSCRIBE_KEY, true))) {\n\t\t\t    //提供者 && url中的register参数值为true\n\t\t\t    //不是提供者 && url中的subscribe参数值为true\n\t\t\t    //则将该url添加到registryList列表中\n\t\t\t    registryList.add(url);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\treturn registryList;\n}\n\n/**\n * @param address 注册中心地址列表(\"|\"或者\";\"分隔)\n * @param defaults map参数\n * @return\n */\npublic static List<URL> parseURLs(String address, Map<String, String> defaults) {\n        if (address == null || address.length() == 0) {\n\t    //注册中心地址为空，返回null\n            return null;\n        }\n        //通过“|”或者“;”分隔注册中心地址\n        String[] addresses = Constants.REGISTRY_SPLIT_PATTERN.split(address);\n        if (addresses == null || addresses.length == 0) {\n            return null;\n        }\n        List<URL> registries = new ArrayList<URL>();\n\t//遍历每一个注册中心地址\n        for (String addr : addresses) {\n            //通过注册中心地址addr和map参数构造注册中心URL对象（后面会分析方法）\n            registries.add(parseURL(addr, defaults));\n        }\n\t//返回注册中心地址url列表\n        return registries;\n}\n\n/**\n * 生成注册中心URL\n * 1、根据注册中心地址address生成url字符串(处理备用地址)\n * 2、从defaults集合中获取属性(protocol、username、password、port、path)默认值\n * 3、根据defaults新生成集合defaultParameters，并移除(protocol、username、password、port、path)属性\n * 4、根据url字符串生成URL对象，并获取该URL对象的属性值(protocol、username、password、port、path、parameters),\n *    其中parameters属性值是新生成的一个map。\n * 5、判断URL对象的这些属性值(protocol、username、password、port、path、parameters)是否为空，如果为空，则使用属性默认值，并标识发生了改变。\n * 6、如果发生了改变。则根据新的属性值重新生成一个URL对象并返回。\n * @param address 注册中心地址(可能是多个，使用\",\"分隔)\n * @param defaults map参数\n * @return\n */\npublic static URL parseURL(String address, Map<String, String> defaults) {\n\tif (address == null || address.length() == 0) {\n\t    return null;\n\t}\n\t//该url最终会被解析成URL对象\n\tString url;\n\tif (address.indexOf(\"://\") >= 0) {\n\t    //该注册中心地址包含\"://\"\n\t    url = address;\n\t} else {\n\t    //使用逗号\",\"分隔address地址\n\t    String[] addresses = Constants.COMMA_SPLIT_PATTERN.split(address);\n\t    //将addresses数组第1个元素赋值给url\n\t    url = addresses[0];\n\t    if (addresses.length > 1) {\n\t\t//遍历addresses数组后面的元素(即查看是否存在备用的注册中心地址)\n\t\t//backup记录注册中心备用地址\n\t\tStringBuilder backup = new StringBuilder();\n\t\tfor (int i = 1; i < addresses.length; i++) {\n\t\t    if (i > 1) {\n\t\t\tbackup.append(\",\");\n\t\t    }\n\t\t    backup.append(addresses[i]);\n\t\t}\n\t\t//将注册中心备用地址添加到url的backup参数中\n\t\turl += \"?\" + Constants.BACKUP_KEY + \"=\" + backup.toString();\n\t    }\n\t}\n\t//从defaults中获取protocol属性\n\tString defaultProtocol = defaults == null ? null : defaults.get(\"protocol\");\n\tif (defaultProtocol == null || defaultProtocol.length() == 0) {\n\t    //如果protocol属性值为空，则设置为dubbo\n\t    defaultProtocol = \"dubbo\";\n\t}\n\t//从defaults中获取username属性和password属性\n\tString defaultUsername = defaults == null ? null : defaults.get(\"username\");\n\tString defaultPassword = defaults == null ? null : defaults.get(\"password\");\n\t//从defaults中获取port属性\n\tint defaultPort = StringUtils.parseInteger(defaults == null ? null : defaults.get(\"port\"));\n\t//从defaults中获取path属性\n\tString defaultPath = defaults == null ? null : defaults.get(\"path\");\n\t//根据defaults新生成一个map集合defaultParameters\n\tMap<String, String> defaultParameters = defaults == null ? null : new HashMap<String, String>(defaults);\n\tif (defaultParameters != null) {\n\t    //移除defaultParameters集合中的以下属性\n\t    defaultParameters.remove(\"protocol\");\n\t    defaultParameters.remove(\"username\");\n\t    defaultParameters.remove(\"password\");\n\t    defaultParameters.remove(\"host\");\n\t    defaultParameters.remove(\"port\");\n\t    defaultParameters.remove(\"path\");\n\t}\n\t//根据url字符串生成URL对象\n\tURL u = URL.valueOf(url);\n\t//如果新生成的URL中的某属性值为空，且该属性的默认值不为空，则意味着发生了改变，changed会被设置为true\n\tboolean changed = false;\n\t\n\t//获取URL对象中的protocol、username、password、host、port、path属性\n\tString protocol = u.getProtocol();\n\tString username = u.getUsername();\n\tString password = u.getPassword();\n\tString host = u.getHost();\n\tint port = u.getPort();\n\tString path = u.getPath();\n\t\n\t//获取URL对象的参数map\n\tMap<String, String> parameters = new HashMap<String, String>(u.getParameters());\n\tif ((protocol == null || protocol.length() == 0) && defaultProtocol != null && defaultProtocol.length() > 0) {\n\t    changed = true;\n\t    //使用protocol默认值设置URL的protocol属性\n\t    protocol = defaultProtocol;\n\t}\n\tif ((username == null || username.length() == 0) && defaultUsername != null && defaultUsername.length() > 0) {\n\t    changed = true;\n\t    //使用username默认值设置URL的username属性\n\t    username = defaultUsername;\n\t}\n\tif ((password == null || password.length() == 0) && defaultPassword != null && defaultPassword.length() > 0) {\n\t    changed = true;\n\t    //使用password默认值设置URL的password属性\n\t    password = defaultPassword;\n\t}\n\t/*if (u.isAnyHost() || u.isLocalHost()) {\n\t    changed = true;\n\t    host = NetUtils.getLocalHost();\n\t}*/\n\tif (port <= 0) {\n\t    //URL的port属性值小于0，且默认的port值大于0，则使用defaultPort设置URL的port属性\n\t    if (defaultPort > 0) {\n\t\tchanged = true;\n\t\tport = defaultPort;\n\t    } else {\n\t\t//默认port如果也小于0的话，则设置URL的port属性为9090\n\t\tchanged = true;\n\t\tport = 9090;\n\t    }\n\t}\n\tif (path == null || path.length() == 0) {\n\t    //使用默认服务名称设置URL的path属性\n\t    if (defaultPath != null && defaultPath.length() > 0) {\n\t\tchanged = true;\n\t\tpath = defaultPath;\n\t    }\n\t}\n\t//遍历默认参数集合\n\tif (defaultParameters != null && defaultParameters.size() > 0) {\n\t    for (Map.Entry<String, String> entry : defaultParameters.entrySet()) {\n\t\t//默认参数key\n\t\tString key = entry.getKey();\n\t\t//默认参数值defaultValue\n\t\tString defaultValue = entry.getValue();\n\t\tif (defaultValue != null && defaultValue.length() > 0) {\n\t\t    //查看URL参数集合中该参数key对应的值\n\t\t    String value = parameters.get(key);\n\t\t    if (value == null || value.length() == 0) {\n\t\t\t//如果URL中的参数值为空，则使用该参数key的默认值defaultValue\n\t\t\tchanged = true;\n\t\t\tparameters.put(key, defaultValue);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (changed) {\n\t    //当前URL的属性值发送改变了，则重新生成一个URL对象\n\t    u = new URL(protocol, username, password, host, port, path, parameters);\n\t}\n\treturn u;\n}\n```\n加载注册中心URL地址的方法分析完了，我们再来看doExportUrlsFor1Protocol方法\n```java\n/**\n * 暴露服务Url到各个注册中心\n * 1、map装配参数\n * 2、利用map中的参数构建URL，为暴露服务做准备\n * 3、根据范围选择是暴露本地服务，还是暴露远程服务\n * 4、根据代理工厂生成服务代理对象invoker\n * 5、根据配置的协议，暴露服务代理\n * @param protocolConfig 例如: <dubbo:protocol name=\"dubbo\" port=\"20880\" id=\"dubbo\" />\n * @param registryURLs 例如: registry://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&dubbo=2.0.0&pid=4328&qos.port=22222&registry=multicast&timestamp=1528278313174\n */\nprivate void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> registryURLs) {\n\t//获取协议名称\n\tString name = protocolConfig.getName();\n\tif (name == null || name.length() == 0) {\n\t    name = \"dubbo\";\n\t}\n\tMap<String, String> map = new HashMap<String, String>();\n\t//添加side参数，值为provider，标识服务提供端\n\tmap.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);\n\t//添加dubbo版本\n\tmap.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());\n\t//添加时间戳\n\tmap.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n\tif (ConfigUtils.getPid() > 0) {\n\t    //添加pid\n\t    map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n\t}\n\t//添加参数到map\n\tappendParameters(map, application);\n\tappendParameters(map, module);\n\tappendParameters(map, provider, Constants.DEFAULT_KEY);\n\tappendParameters(map, protocolConfig);\n\t//当前ServiceConfig(ServiceBean)\n\tappendParameters(map, this);\n\n\tif (methods != null && !methods.isEmpty()) {\n\t    //遍历服务方法\n\t    for (MethodConfig method : methods) {\n\t\t//将method的属性添加到map中\n\t\tappendParameters(map, method, method.getName());\n\t\t//设置方法重试次数(retryKey是map的key)\n\t\tString retryKey = method.getName() + \".retry\";\n\t\tif (map.containsKey(retryKey)) {\n\t\t    String retryValue = map.remove(retryKey);\n\t\t    if (\"false\".equals(retryValue)) {\n\t\t        //retryValue值为false的话，说明不启用重试\n\t\t\tmap.put(method.getName() + \".retries\", \"0\");\n\t\t    }\n\t\t}\n\t\t//获取当前服务方法的参数\n\t\tList<ArgumentConfig> arguments = method.getArguments();\n\t\tif (arguments != null && !arguments.isEmpty()) {\n\t\t    //遍历当前服务方法的参数配置\n\t\t    for (ArgumentConfig argument : arguments) {\n\t\t\tif (argument.getType() != null && argument.getType().length() > 0) {\n\t\t\t    //遍历服务接口的方法列表\n\t\t\t    Method[] methods = interfaceClass.getMethods();\n\t\t\t    if (methods != null && methods.length > 0) {\n\t\t\t\tfor (int i = 0; i < methods.length; i++) {\n\t\t\t\t    //方法名\n\t\t\t\t    String methodName = methods[i].getName();\n\t\t\t\t    if (methodName.equals(method.getName())) {\n\t\t\t\t\t//方法名称一样,获取方法参数类型数组\n\t\t\t\t\tClass<?>[] argtypes = methods[i].getParameterTypes();\n\t\t\t\t\t// one callback in the method\n\t\t\t\t\tif (argument.getIndex() != -1) {\n\t\t\t\t\t    //校验参数的类型是否匹配\n\t\t\t\t\t    if (argtypes[argument.getIndex()].getName().equals(argument.getType())) {\n\t\t\t\t\t\t//将方法的参数的属性添加到map，前缀为：方法名.参数索引\n\t\t\t\t\t\tappendParameters(map, argument, method.getName() + \".\" + argument.getIndex());\n\t\t\t\t\t    } else {\n\t\t\t\t\t\t//参数配置错误，索引和类型不匹配\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"argument config error : the index attribute and type attribute not match :index :\" + argument.getIndex() + \", type:\" + argument.getType());\n\t\t\t\t\t    }\n\t\t\t\t\t} else {\n\t\t\t\t\t    // multiple callbacks in the method\n\t\t\t\t\t    for (int j = 0; j < argtypes.length; j++) {\n\t\t\t\t\t\t//当前参数类型\n\t\t\t\t\t\tClass<?> argclazz = argtypes[j];\n\t\t\t\t\t\t//参数类型名称匹配\n\t\t\t\t\t\tif (argclazz.getName().equals(argument.getType())) {\n\t\t\t\t\t\t    appendParameters(map, argument, method.getName() + \".\" + j);\n\t\t\t\t\t\t    if (argument.getIndex() != -1 && argument.getIndex() != j) {\n\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"argument config error : the index attribute and type attribute not match :index :\" + argument.getIndex() + \", type:\" + argument.getType());\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t}\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t} else if (argument.getIndex() != -1) {\n\t\t\t    appendParameters(map, argument, method.getName() + \".\" + argument.getIndex());\n\t\t\t} else {\n\t\t\t    //<dubbo:argument index='0' .../> or <dubbo:argument type=xxx .../>\n\t\t\t    throw new IllegalArgumentException(\"argument config must set index or type attribute.eg: <dubbo:argument index='0' .../> or <dubbo:argument type=xxx .../>\");\n\t\t\t}\n\n\t\t    }\n\t\t}\n\t    } // end of methods for\n\t}\n\t//(generic ！= null) && (generic = “true” || \"nativejava\" || \"bean\") 返回 true\n\tif (ProtocolUtils.isGeneric(generic)) {\n\t    //添加generic参数\n\t    map.put(Constants.GENERIC_KEY, generic);\n\t    //添加methods参数，值为\"*\"\n\t    map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);\n\t} else {\n\t    String revision = Version.getVersion(interfaceClass, version);\n\t    if (revision != null && revision.length() > 0) {\n\t        //添加版本\n\t\tmap.put(\"revision\", revision);\n\t    }\n\t    //生成interfaceClass类的包装类，获取方法名称\n\t    String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();\n\t    if (methods.length == 0) {\n\t\t//服务接口中没有发现方法定义\n\t\tlogger.warn(\"NO method found in service interface \" + interfaceClass.getName());\n\t\t//添加methods参数，值为\"*\"\n\t\tmap.put(Constants.METHODS_KEY, Constants.ANY_VALUE);\n\t    } else {\n\t\t//添加methods参数，值为逗号分隔的方法名称\n\t\tmap.put(Constants.METHODS_KEY, StringUtils.join(new HashSet<String>(Arrays.asList(methods)), \",\"));\n\t    }\n\t}\n\tif (!ConfigUtils.isEmpty(token)) {\n\t    //token为true或者token为default，则isDefault方法返回true\n\t    if (ConfigUtils.isDefault(token)) {\n\t\t//添加token参数，值为uuid\n\t\tmap.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());\n\t    } else {\n\t\t//添加token参数\n\t\tmap.put(Constants.TOKEN_KEY, token);\n\t    }\n\t}\n\t//判断协议名称是否为\"injvm\"\n\tif (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) {\n\t    //本地协议，不注册\n\t    protocolConfig.setRegister(false);\n\t    //添加notify参数，值为false\n\t    map.put(\"notify\", \"false\");\n\t}\n\t//暴露服务\n\t//获取上下文地址\n\tString contextPath = protocolConfig.getContextpath();\n\tif ((contextPath == null || contextPath.length() == 0) && provider != null) {\n\t    //获取provider对象配置的上下文地址\n\t    contextPath = provider.getContextpath();\n\t}\n\t//获取注册ip(后面会分析该方法)\n\tString host = this.findConfigedHosts(protocolConfig, registryURLs, map);\n\t//获取注册端口(后面会分析该方法)\n\tInteger port = this.findConfigedPorts(protocolConfig, name, map);\n\t//根据协议名称name、主机host、端口port、上下文、map参数构建URL对象(服务暴露的url地址)\n\t//例如url：dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=192.168.99.60&bind.port=20880&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=7184&qos.port=22222&side=provider&timestamp=1528347825839\n\tURL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? \"\" : contextPath + \"/\") + path, map);\n\t//查看ConfiguratorFactory(override/absent)是否存在url.getProtocol()扩展，存在的话，则配置该url对象\n\t//override会覆盖参数配置，absent只有参数不存在时才会添加(后面的章节会介绍该扩展)\n\tif (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class).hasExtension(url.getProtocol())) {\n\t    url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)\n\t\t    .getExtension(url.getProtocol()).getConfigurator(url).configure(url);\n\t}\n\t//获取url的scope参数\n\tString scope = url.getParameter(Constants.SCOPE_KEY);\n\t\n\t//只有scope != none 时才会暴露服务，scope = null时会同时暴露本地服务和远程服务\n\tif (!Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) {\n\t    //scope != remote 暴露本地服务\n\t    if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) {\n\t\t//本地暴露(后面小节会分析该方法)\n\t\texportLocal(url);\n\t    }\n\t    if (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) {\n\t         //scope != local 暴露到远程\n\t\tif (logger.isInfoEnabled()) {\n\t\t    //暴露dubbo服务interfaceClass到url\n\t\t    logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to url \" + url);\n\t\t}\n\t\tif (registryURLs != null && !registryURLs.isEmpty()) {\n\t\t    //注册中心地址registryURLs不为空，则遍历注册中心地址，将服务暴露到各个注册中心\n\t\t    for (URL registryURL : registryURLs) {\n\t\t\t\n\t\t\t//添加dynamic参数到url中，参数值从当前注册中心的参数中获取\n\t\t\turl = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));\n\t\t\t\n\t\t\t//构造监控url(后面会分析该方法)\n\t\t\tURL monitorUrl = loadMonitor(registryURL);\n\t\t\tif (monitorUrl != null) {\n\t\t\t    //添加monitor参数(编码)到url中\n\t\t\t    url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());\n\t\t\t}\n\t\t\t\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t    //注册dubbo服务 interfaceClass的url 到注册中心registryURL上\n\t\t\t    logger.info(\"Register dubbo service \" + interfaceClass.getName() + \" url \" + url + \" to registry \" + registryURL);\n\t\t\t}\n\t\t\t\n\t\t\t//registryURL地址上添加export参数，参数值为服务暴露的url(即interfaceClass的url)\n\t\t\t//根据ref、interfaceClass、registryURL创建服务代理对象Invoker(后面小节会分析该方法)\n\t\t\tInvoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));\n\t\t\t\n\t\t\t//将invoker和当前对象this包装成DelegateProviderMetaDataInvoker对象(后面小节会分析该方法)\n\t\t\tDelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\t\t\t\n\t\t\t//在此处开始暴露服务\n\t\t\t//调用export方法暴露服务，得到exporter对象(后面小节会分析该方法)\n\t\t\tExporter<?> exporter = protocol.export(wrapperInvoker);\n\t\t\t//保存暴露的服务到本地变量exporters中\n\t\t\texporters.add(exporter);\n\t\t    }\n\t\t} else {\n\t\t    //注册中心地址registryURLs为空\n\t\t    Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);\n\t\t    DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\t\t    Exporter<?> exporter = protocol.export(wrapperInvoker);\n\t\t    exporters.add(exporter);\n\t\t}\n\t    }\n\t}\n\t//保存暴露的服务url\n\tthis.urls.add(url);\n}\n```\n我们依次看下上面用到的方法: findConfigedHosts、findConfigedPorts、loadMonitor\nexportLocal、getInvoker、export方法将在后面的章节(Dubbo源码阅读之服务暴露)进行详细介绍。\n```java\n/**\n * 为服务提供者 获取注册ip和绑定ip，可以单独配置\n * Register & bind IP address for service provider, can be configured separately.\n * Configuration priority:\n * environment variables -> java system properties -> host property in config file ->\n * /etc/hosts -> default network address -> first available network address\n * @param protocolConfig\n * @param registryURLs\n * @param map\n * @return 注册ip\n */\nprivate String findConfigedHosts(ProtocolConfig protocolConfig, List<URL> registryURLs, Map<String, String> map) {\n\tboolean anyhost = false;\n\t//从系统配置中获取获取绑定ip\n\tString hostToBind = getValueFromConfig(protocolConfig, Constants.DUBBO_IP_TO_BIND);\n\tif (hostToBind != null && hostToBind.length() > 0 && isInvalidLocalHost(hostToBind)) {\n\t    //无效的ip\n\t    throw new IllegalArgumentException(\"Specified invalid bind ip from property:\" + Constants.DUBBO_IP_TO_BIND + \", value:\" + hostToBind);\n\t}\n\tif (hostToBind == null || hostToBind.length() == 0) {\n\t    //从协议配置中获取服务ip地址\n\t    hostToBind = protocolConfig.getHost();\n\t    if (provider != null && (hostToBind == null || hostToBind.length() == 0)) {\n\t\t//从服务提供者中获取服务ip地址\n\t\thostToBind = provider.getHost();\n\t    }\n\t    if (isInvalidLocalHost(hostToBind)) {\n\t\t//仍然是无效的地址，则设置anyhost=true\n\t\tanyhost = true;\n\t\ttry {\n\t\t    //获取本地地址\n\t\t    hostToBind = InetAddress.getLocalHost().getHostAddress();\n\t\t} catch (UnknownHostException e) {\n\t\t    logger.warn(e.getMessage(), e);\n\t\t}\n\t\tif (isInvalidLocalHost(hostToBind)) {\n\t\t    //仍然是无效的地址，遍历注册中心url列表\n\t\t    if (registryURLs != null && !registryURLs.isEmpty()) {\n\t\t\tfor (URL registryURL : registryURLs) {\n\t\t\t    if (Constants.MULTICAST.equalsIgnoreCase(registryURL.getParameter(\"registry\"))) {\n\t\t\t\t// 跳过组播registry，因为我们不可以通过Socket连接到它\n\t\t\t\tcontinue;\n\t\t\t    }\n\t\t\t    try {\n\t\t\t\tSocket socket = new Socket();\n\t\t\t\ttry {\n\t\t\t\t    //根据注册中心host和port构建SocketAddress\n\t\t\t\t    SocketAddress addr = new InetSocketAddress(registryURL.getHost(), registryURL.getPort());\n\t\t\t\t    //连接到该地址\n\t\t\t\t    socket.connect(addr, 1000);\n\t\t\t\t    //连接成功的话，则获取到绑定地址，并跳出循环\n\t\t\t\t    hostToBind = socket.getLocalAddress().getHostAddress();\n\t\t\t\t    break;\n\t\t\t\t} finally {\n\t\t\t\t    try {\n\t\t\t\t\tsocket.close();\n\t\t\t\t    } catch (Throwable e) {\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    } catch (Exception e) {\n\t\t\t\tlogger.warn(e.getMessage(), e);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (isInvalidLocalHost(hostToBind)) {\n\t\t\t//仍然为无效本地地址的话，则使用本地地址\n\t\t\thostToBind = getLocalHost();\n\t\t    }\n\t\t}\n\t    }\n\t}\n\t//添加bind.ip参数\n\tmap.put(Constants.BIND_IP_KEY, hostToBind);\n\t// 默认情况下，注册ip不用于绑定ip\n\t// 获取注册ip\n\tString hostToRegistry = getValueFromConfig(protocolConfig, Constants.DUBBO_IP_TO_REGISTRY);\n\tif (hostToRegistry != null && hostToRegistry.length() > 0 && isInvalidLocalHost(hostToRegistry)) {\n\t    throw new IllegalArgumentException(\"Specified invalid registry ip from property:\" + Constants.DUBBO_IP_TO_REGISTRY + \", value:\" + hostToRegistry);\n\t} else if (hostToRegistry == null || hostToRegistry.length() == 0) {\n\t    //默认情况下，绑定ip用于注册ip\n\t    hostToRegistry = hostToBind;\n\t}\n\t//添加anyhost参数\n\tmap.put(Constants.ANYHOST_KEY, String.valueOf(anyhost));\n\treturn hostToRegistry;\n}\n\n/**\n * 为服务提供者 获取注册端口和绑定端口\n * Register port and bind port for the provider, can be configured separately\n * Configuration priority:\n * environment variable -> java system properties -> port property in protocol config file\n * -> protocol default port\n * @param protocolConfig\n * @param name\n * @return 注册端口\n */\nprivate Integer findConfigedPorts(ProtocolConfig protocolConfig, String name, Map<String, String> map) {\n\tInteger portToBind = null;\n\n\t//从系统配置中获取绑定端口\n\tString port = getValueFromConfig(protocolConfig, Constants.DUBBO_PORT_TO_BIND);\n\tportToBind = parsePort(port);\n\n\tif (portToBind == null) {\n\t    //从协议配置中获取绑定端口\n\t    portToBind = protocolConfig.getPort();\n\t    if (provider != null && (portToBind == null || portToBind == 0)) {\n\t\t//从服务提供者中获取绑定端口\n\t\tportToBind = provider.getPort();\n\t    }\n\t    //根据协议名称获取默认绑定端口\n\t    final int defaultPort = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(name).getDefaultPort();\n\t    if (portToBind == null || portToBind == 0) {\n\t\tportToBind = defaultPort;\n\t    }\n\t    if (portToBind == null || portToBind <= 0) {\n\t\t//获取随机端口\n\t\tportToBind = getRandomPort(name);\n\t\tif (portToBind == null || portToBind < 0) {\n\t\t    //获取可用端口\n\t\t    portToBind = getAvailablePort(defaultPort);\n\t\t    //设置随机端口(放入map缓存)\n\t\t    putRandomPort(name, portToBind);\n\t\t}\n\t\tlogger.warn(\"Use random available port(\" + portToBind + \") for protocol \" + name);\n\t    }\n\t}\n\t//保存绑定端口，稍后用作url的key\n\tmap.put(Constants.BIND_PORT_KEY, String.valueOf(portToBind));\n\t// registry port, not used as bind port by default\n\tString portToRegistryStr = getValueFromConfig(protocolConfig, Constants.DUBBO_PORT_TO_REGISTRY);\n\tInteger portToRegistry = parsePort(portToRegistryStr);\n\tif (portToRegistry == null) {\n\t    //注册端口使用绑定端口\n\t    portToRegistry = portToBind;\n\t}\n\treturn portToRegistry;\n}\n\n/**\n * 构造监控URL\n * @param registryURL 注册中心URL\n * @return\n */\nprotected URL loadMonitor(URL registryURL) {\n\tif (monitor == null) {\n\t    //获取监控地址、监控协议配置\n\t    String monitorAddress = ConfigUtils.getProperty(\"dubbo.monitor.address\");\n\t    String monitorProtocol = ConfigUtils.getProperty(\"dubbo.monitor.protocol\");\n\t    if ((monitorAddress == null || monitorAddress.length() == 0) && (monitorProtocol == null || monitorProtocol.length() == 0)) {\n\t\t//如果监控地址和监控协议为空，则返回Null\n\t\treturn null;\n\t    }\n\t    //构造监控配置对象(地址、协议)\n\t    monitor = new MonitorConfig();\n\t    if (monitorAddress != null && monitorAddress.length() > 0) {\n\t\tmonitor.setAddress(monitorAddress);\n\t    }\n\t    if (monitorProtocol != null && monitorProtocol.length() > 0) {\n\t\tmonitor.setProtocol(monitorProtocol);\n\t    }\n\t}\n\t//添加属性\n\tappendProperties(monitor);\n\t//参数\n\tMap<String, String> map = new HashMap<String, String>();\n\t//添加interface参数\n\tmap.put(Constants.INTERFACE_KEY, MonitorService.class.getName());\n\t//添加dubbo版本\n\tmap.put(\"dubbo\", Version.getVersion());\n\t//添加时间戳\n\tmap.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n\tif (ConfigUtils.getPid() > 0) {\n\t    //添加pid\n\t    map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n\t}\n\t//添加monitor属性\n\tappendParameters(map, monitor);\n\t//获取monitor地址，优先使用系统配置值\n\tString address = monitor.getAddress();\n\tString sysaddress = System.getProperty(\"dubbo.monitor.address\");\n\tif (sysaddress != null && sysaddress.length() > 0) {\n\t    address = sysaddress;\n\t}\n\tif (ConfigUtils.isNotEmpty(address)) {\n\t    if (!map.containsKey(Constants.PROTOCOL_KEY)) {\n\t\t//协议地址不为空，且map中不包含protocol属性时，则设置protocol\n\t\tif (ExtensionLoader.getExtensionLoader(MonitorFactory.class).hasExtension(\"logstat\")) {\n\t\t    //包含logstat扩展\n\t\t    map.put(Constants.PROTOCOL_KEY, \"logstat\");\n\t\t} else {\n\t\t    //添加protocol属性\n\t\t    map.put(Constants.PROTOCOL_KEY, \"dubbo\");\n\t\t}\n\t    }\n\t    //生成URL对象\n\t    return UrlUtils.parseURL(address, map);\n\t} else if (Constants.REGISTRY_PROTOCOL.equals(monitor.getProtocol()) && registryURL != null) {\n\t    //监控address为空\n\t    //registryURL不为空，且monitor的协议为registry注册中心协议\n\t    return registryURL.setProtocol(\"dubbo\")\n\t\t    //添加protocol属性为registry\n\t\t    .addParameter(Constants.PROTOCOL_KEY, \"registry\")\n\t\t    //添加refer属性，属性值为map参数\n\t\t    .addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map));\n\t}\n\treturn null;\n}\n```\n\n由于本小节主要是讲ServiceAnnotationBeanPostProcessor类实现，关于服务暴露的内容将会放到下一小节介绍。\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之集成Spring-标签解析(02)","url":"/blog/2018/08/04/Dubbo源码阅读之集成Spring-02标签解析/","content":">本小节将会介绍dubbo标签的解析.\n\n上节讲到Dubbo解析标签的类是DubboBeanDefinitionParser,现在我们就来分析下该类,该类实现了Spring的BeanDefinitionParser接口，我们需要实现它的parse方法:\n\n### DubboBeanDefinitionParser解析类\n```java\npublic class DubboBeanDefinitionParser implements BeanDefinitionParser{\n \n    private static final Pattern GROUP_AND_VERION = Pattern.compile(\"^[\\\\-.0-9_a-zA-Z]+(\\\\:[\\\\-.0-9_a-zA-Z]+)?$\");\n    \n    //带解析实例化的bean类\n    private final Class<?> beanClass;\n    \n    //是否必填\n    private final boolean required;\n\n    public DubboBeanDefinitionParser(Class<?> beanClass, boolean required) {\n        this.beanClass = beanClass;\n        this.required = required;\n    }\n\n    @Override\n    public BeanDefinition parse(Element element, ParserContext parserContext) {\n        //调用了内部的parse方法\n        return parse(element, parserContext, beanClass, required);\n    }\n   \n    private static BeanDefinition parse(Element element, ParserContext parserContext,\n                                        Class<?> beanClass, boolean required) {\n        //创建RootBeanDefinition实例\n        RootBeanDefinition beanDefinition = new RootBeanDefinition();\n        //设置要实例化的类\n        beanDefinition.setBeanClass(beanClass);\n        //是否延迟初始化\n        beanDefinition.setLazyInit(false);\n        \n        //获取元素的id属性作为bean的id\n        String id = element.getAttribute(\"id\");\n        if ((id == null || id.length() == 0) && required) {\n            //如果id属性为空，并且是必填的，则取元素的name属性\n            String generatedBeanName = element.getAttribute(\"name\");\n            if (generatedBeanName == null || generatedBeanName.length() == 0) {\n                //如果name属性为空，则生成一个bean名称\n                //判断当前要实例化的bean类是否是ProtocolConfig类（即当前是否为<dubbo:protocol>标签）\n                if (ProtocolConfig.class.equals(beanClass)) {\n                    //当前是ProtocolConfig类，则设置bean名称为dubbo\n                    generatedBeanName = \"dubbo\";\n                } else {\n                    //不是ProtocolConfig类,则使用interface属性做为bean的名称\n                    generatedBeanName = element.getAttribute(\"interface\");\n                }\n            }\n            //如果bean名称为空，则使用当前实例化的类的名称\n            if (generatedBeanName == null || generatedBeanName.length() == 0) {\n                generatedBeanName = beanClass.getName();\n            }\n            //同时将bean的id属性设置为bean的名称\n            id = generatedBeanName;\n            int counter = 2;\n            //如果上下文中已经存在该id，则对该bean的id做防重处理\n            while (parserContext.getRegistry().containsBeanDefinition(id)) {\n                id = generatedBeanName + (counter++);\n            }\n        }\n        if (id != null && id.length() > 0) {\n            //如果id属性不为空，则校验Spring中是否已存在该id\n            if (parserContext.getRegistry().containsBeanDefinition(id)) {\n                throw new IllegalStateException(\"Duplicate spring bean id \" + id);\n            }\n            //通过id注册该bean\n            parserContext.getRegistry().registerBeanDefinition(id, beanDefinition);\n            //设置bean的id属性值\n            beanDefinition.getPropertyValues().addPropertyValue(\"id\", id);\n        }\n        //进一步解析<dubbo:protocol/>标签\n        //如：<dubbo:protocol name=\"dubbo\" port=\"20880\"/>\n        if (ProtocolConfig.class.equals(beanClass)) {\n            //如果当前要实例化的bean是ProtocolConfig类，则遍历Spring所有已经注册的bean的名称\n            for (String name : parserContext.getRegistry().getBeanDefinitionNames()) {\n                //根据bean名称获取已注册的bean定义\n                BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name);\n                //查看已注册的bean定义中是否存在protocol属性\n                PropertyValue property = definition.getPropertyValues().getPropertyValue(\"protocol\");\n                if (property != null) {\n                    //存在protocol属性，则获取protocol属性值\n                    Object value = property.getValue();\n                    //如果protocol属性值为ProtocolConfig类型，并且当前实例化的bean的id等于protocol属性值的name属性值的话，\n                    //则将当前实例化的bean包装成RuntimeBeanReference类型\n                    //然后将已注册的bean的protocol属性的值设为刚才新创建的RuntimeBeanReference\n                    //也就是说将当前解析的bean（ProtocolConfig）设置到其他已注册的bean的protocol属性中\n                    if (value instanceof ProtocolConfig && id.equals(((ProtocolConfig) value).getName())) {\n                        definition.getPropertyValues().addPropertyValue(\"protocol\", new RuntimeBeanReference(id));\n                    }\n                }\n            }\n        } else if (ServiceBean.class.equals(beanClass)) {\n            //进一步解析<dubbo:service/>标签，这里的逻辑就是处理下面的第二种配置\n            //如：<dubbo:service protocol=\"dubbo\" ref=\"userService\" interface=\"org.dubbo.service.UserInterface\" retries=\"0\" />\n            //   <bean id=\"userService\" class=\"org.dubbo.service.impl.UserServiceImpl\" />\n            //和如下配置相同\n            //<dubbo:service interface=\"org.dubbo.service.UserInterface\" class=\"org.dubbo.service.impl.UserServiceImpl\" protocol=\"dubbo\" retries=\"0\">\n            //   <property name=\"name\" value=\"dubbo\" ref=\"\"/>\n            //   <property name=\"age\" value=\"5\" ref=\"\"/>\n            //</dubbo:service>\n\n            //如果当前要实例化的bean是ServiceBean类,则获取class属性并解析\n            String className = element.getAttribute(\"class\");\n            if (className != null && className.length() > 0) {\n                //如果class属性不为空，则实例化该class属性指定的类\n                RootBeanDefinition classDefinition = new RootBeanDefinition();\n                classDefinition.setBeanClass(ReflectUtils.forName(className));\n                classDefinition.setLazyInit(false);\n                //解析子标签元素(即上面例子中的property属性)(后面会介绍parseProperties方法)\n                parseProperties(element.getChildNodes(), classDefinition);\n                //为当前待实例化的bean定义增加ref属性值（即class属性对应的bean，id为 beanId + impl）\n                beanDefinition.getPropertyValues().addPropertyValue(\"ref\", new BeanDefinitionHolder(classDefinition, id + \"Impl\"));\n            }\n        } else if (ProviderConfig.class.equals(beanClass)) {\n            //进一步处理<dubbo:provider/>标签(后面会分析parseNested方法)\n            parseNested(element, parserContext, ServiceBean.class, true, \"service\", \"provider\", id, beanDefinition);\n        } else if (ConsumerConfig.class.equals(beanClass)) {\n            //进一步处理<dubbo:consumer/>标签的子标签<dubbo:reference/>\n            parseNested(element, parserContext, ReferenceBean.class, false, \"reference\", \"consumer\", id, beanDefinition);\n        }\n        \n\t//当前待实例化的bean的所有的属性(通过set方法获取到)\n        Set<String> props = new HashSet<String>();\n        ManagedMap parameters = null;\n        //遍历待实例化类的所有方法,找到set方法\n        for (Method setter : beanClass.getMethods()) {\n            \n            String name = setter.getName();\n            \n            //找到set方法，条件如下：方法名长度大于3，以set开头，是public修饰符，参数类型长度为1\n            if (name.length() > 3 && name.startsWith(\"set\")\n                    && Modifier.isPublic(setter.getModifiers())\n                    && setter.getParameterTypes().length == 1) {\n               \n                 //获取参数类型\n                Class<?> type = setter.getParameterTypes()[0];\n\n                //如setFirstName(String firstName)方法\n                //将会得到property=first-name\n                String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), \"-\");\n          \n\t        //将属性名称添加到props集合中\n                props.add(property);\n               \n                //获取到属性的get方法\n                Method getter = null;\n               \n                try {\n                    getter = beanClass.getMethod(\"get\" + name.substring(3), new Class<?>[0]);\n                } catch (NoSuchMethodException e) {\n                    try {\n                        //如果没有找到get方法，则尝试找到isXXX方法\n                        getter = beanClass.getMethod(\"is\" + name.substring(3), new Class<?>[0]);\n                    } catch (NoSuchMethodException e2) {\n                    }\n                }\n                if (getter == null\n                        || !Modifier.isPublic(getter.getModifiers())\n                        || !type.equals(getter.getReturnType())) {\n                    //如果get方法为空、不是public限定符、或者get方法返回值和set方法参数类型不一致的话，\n                    //则跳过该property的处理，进行下一个property的处理\n                    continue;\n                }\n                if (\"parameters\".equals(property)) {\n                    //如果当前property为parameters，则解析当前元素的子元素(<dubbo:parameter>标签)(后面会分析parseParameters方法)\n                    parameters = parseParameters(element.getChildNodes(), beanDefinition);\n                } else if (\"methods\".equals(property)) {\n                    //如果当前property为methods，则解析当前元素的子元素(<dubbo:method>标签)(后面会分析parseMethods方法)\n                    parseMethods(id, element.getChildNodes(), beanDefinition, parserContext);\n                } else if (\"arguments\".equals(property)) {\n                    //如果当前property为arguments，则解析当前元素的子元素(<dubbo:argument>标签)(后面会分析parseArguments方法)\n                    parseArguments(id, element.getChildNodes(), beanDefinition, parserContext);\n                } else {\n                    //从xml定义中获取property属性值\n                    String value = element.getAttribute(property);\n                    if (value != null) {\n                        value = value.trim();\n                        if (value.length() > 0) {\n                            if (\"registry\".equals(property) && RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(value)) {\n                                //如果当前属性为registry，并且属性值为N/A\n                                //则为当前bean定义添加属性registry，并且属性值为RegistryConfig对象(该对象的address属性值为不可用)\n                                RegistryConfig registryConfig = new RegistryConfig();\n                                registryConfig.setAddress(RegistryConfig.NO_AVAILABLE);\n                                beanDefinition.getPropertyValues().addPropertyValue(property, registryConfig);\n                            } else if (\"registry\".equals(property) && value.indexOf(',') != -1) {\n                                //如果当前属性为registry，并且属性值包含逗号\",\",即有多个值，则进一步解析(后面会分析parseMultiRef方法)\n                                parseMultiRef(\"registries\", value, beanDefinition, parserContext);\n                            } else if (\"provider\".equals(property) && value.indexOf(',') != -1) {\n                                //如果当前属性为providers，并且属性值包含逗号\",\",即有多个值，则进一步解析\n                                parseMultiRef(\"providers\", value, beanDefinition, parserContext);\n                            } else if (\"protocol\".equals(property) && value.indexOf(',') != -1) {\n                                //如果当前属性为protocol，并且属性值包含逗号\",\",即有多个值，则进一步解析\n                                parseMultiRef(\"protocols\", value, beanDefinition, parserContext);\n                            } else {\n                                Object reference;\n                                //判断set方法的参数类型是否是原始类型\n                                if (isPrimitive(type)) {\n                                     if (\"async\".equals(property) && \"false\".equals(value)\n                                            || \"timeout\".equals(property) && \"0\".equals(value)\n                                            || \"delay\".equals(property) && \"0\".equals(value)\n                                            || \"version\".equals(property) && \"0.0.0\".equals(value)\n                                            || \"stat\".equals(property) && \"-1\".equals(value)\n                                            || \"reliable\".equals(property) && \"false\".equals(value)) {\n                                        // backward compatibility for the default value in old version's xsd\n                                        //兼容老版本\n\t\t\t\t\tvalue = null;\n                                    }\n\t\t\t\t    //原始类型，直接只用xml中配置的属性值\n                                    reference = value;\n                                } else if (\"protocol\".equals(property)\n                                        //属性名为protocol，并且当前存在该属性值对应的扩展\n                                        && ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(value)\n                                        //当前上下文不包含扩展的bean定义\n                                        //该扩展bean的类名称不等于ProtocolConfig类名称\n                                        && (!parserContext.getRegistry().containsBeanDefinition(value)\n                                        || !ProtocolConfig.class.getName().equals(parserContext.getRegistry().getBeanDefinition(value).getBeanClassName()))) {\n                                    //如果元素标签名称为dubbo:provider，则提示使用dubbo:protocol进行替换\n                                    if (\"dubbo:provider\".equals(element.getTagName())) {\n                                        logger.warn(\"Recommended replace <dubbo:provider protocol=\\\"\" + value + \"\\\" ... /> to <dubbo:protocol name=\\\"\" + value + \"\\\" ... />\");\n                                    }\n                                    // backward compatibility 向后兼容\n                                    // 设置协议名称为value\n                                    ProtocolConfig protocol = new ProtocolConfig();\n                                    protocol.setName(value);\n                                    //设置reference值为protocol\n                                    reference = protocol;\n                                } else if (\"onreturn\".equals(property)) {\n                                    //获取\".\"在属性值中最后出现的位置\n                                    int index = value.lastIndexOf(\".\");\n                                    \n \t\t\t\t     //截取value从首字符到index字符\n                                    String returnRef = value.substring(0, index);\n                                    \n\t\t\t\t    //从index+1字符开始进行截取\n                                    String returnMethod = value.substring(index + 1);\n\t\t\t\t\t\n\t\t\t\t    //包装成RuntimeBeanReference\n                                    reference = new RuntimeBeanReference(returnRef);\n                                    \n \t\t\t\t    //为当前bean定义增加属性onreturnMethod\n                                    beanDefinition.getPropertyValues().addPropertyValue(\"onreturnMethod\", returnMethod);\n                                } else if (\"onthrow\".equals(property)) {\n                                   //处理onthrow属性 \n\t\t\t\t   int index = value.lastIndexOf(\".\");\n                                   String throwRef = value.substring(0, index);\n                                   String throwMethod = value.substring(index + 1);\n                                    \n\t\t\t\t   reference = new RuntimeBeanReference(throwRef);\n                                   \n\t\t\t\t    //为当前bean定义增加属性onthrowMethod\n                                    beanDefinition.getPropertyValues().addPropertyValue(\"onthrowMethod\", throwMethod);\n                                } else if (\"oninvoke\".equals(property)) {\n                                    int index = value.lastIndexOf(\".\");\n                                    String invokeRef = value.substring(0, index);\n                                    String invokeRefMethod = value.substring(index + 1);\n                                    \n\t\t\t\t    reference = new RuntimeBeanReference(invokeRef);\n                                    //为当前bean定义增加属性oninvokeMethod\n                                    beanDefinition.getPropertyValues().addPropertyValue(\"oninvokeMethod\", invokeRefMethod);\n                                }else {\n                                    //如果当前属性为ref，并且当前上下文中包含属性值value对应的bean定义\n                                    if (\"ref\".equals(property) && parserContext.getRegistry().containsBeanDefinition(value)) {\n                                        //获取属性值value对应的bean定义\n                                        BeanDefinition refBean = parserContext.getRegistry().getBeanDefinition(value);\n                                        //检测是否是单例\n                                        if (!refBean.isSingleton()) {\n                                            //暴露的服务ref值必须是单例\n                                            throw new IllegalStateException(\"The exported service ref \" + value + \" must be singleton! Please set the \" + value + \" bean scope to singleton, eg: <bean id=\\\"\" + value + \"\\\" scope=\\\"singleton\\\" ...>\");\n                                        }\n                                    }\n                                    reference = new RuntimeBeanReference(value);\n                                }\n                                //为当前bean定义添加属性property，属性值为reference\n                                beanDefinition.getPropertyValues().addPropertyValue(property, reference);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        //获取元素的所有属性\n        NamedNodeMap attributes = element.getAttributes();\n\t//属性数量\n        int len = attributes.getLength();\n        //遍历所有属性，看看是否有不再set属性集合中的元素，如果有，则将他们添加到自定义参数map中，然后设置当前待实例化bean的parameters参数\n        for (int i = 0; i < len; i++) {\n            Node node = attributes.item(i);\n            String name = node.getLocalName();\n            //如果当前set属性集合中不包含该属性，则将该属性以及属性值添加到自定义parameters中\n            if (!props.contains(name)) {\n                if (parameters == null) {\n                    parameters = new ManagedMap();\n                }\n                //获取该节点属性值\n                String value = node.getNodeValue();\n                //将值包装成TypedStringValue类型，并放入自定义参数map中\n                parameters.put(name, new TypedStringValue(value, String.class));\n            }\n        }\n        if (parameters != null) {\n            //为当前bean定义添加属性parameters\n            beanDefinition.getPropertyValues().addPropertyValue(\"parameters\", parameters);\n        }\n\t//返回bean定义\n        return beanDefinition;\n    }\n\n}\n```\n#### parseProperties方法\n\n```java\n/**\n* 解析子标签元素\n* @param nodeList\n* @param beanDefinition 待实例化的bean\n*/\nprivate static void parseProperties(NodeList nodeList, RootBeanDefinition beanDefinition) {\n\t\n\t//<dubbo:service interface=\"org.dubbo.service.UserInterface\" class=\"org.dubbo.service.impl.UserService\" protocol=\"dubbo\" retries=\"0\">\n   \t//\t<property name=\"name\" value=\"dubbo\" ref=\"\"/>\n   \t//\t<property name=\"age\" value=\"5\" ref=\"\"/>\n\t//</dubbo:service>\n\tif (nodeList != null && nodeList.getLength() > 0) {\n\t   //遍历所有property节点 \n\t   for (int i = 0; i < nodeList.getLength(); i++) {\n\t\t//当前节点\n\t\tNode node = nodeList.item(i);\n\t\tif (node instanceof Element) {\n\t\t    //如果节点名称为property或者节点限定名称为property\n\t\t    if (\"property\".equals(node.getNodeName())\n\t\t\t    || \"property\".equals(node.getLocalName())) {\n\t\t\t\n\t\t\t//获取property节点的name属性\n\t\t\tString name = ((Element) node).getAttribute(\"name\");\n\t\t\tif (name != null && name.length() > 0) {\n\t\t\t    //获取property节点的value属性\n\t\t\t    String value = ((Element) node).getAttribute(\"value\");\n\t\t\t   \n\t\t\t    //获取property节点的ref属性\n\t\t\t    String ref = ((Element) node).getAttribute(\"ref\");\n\t\t\t    \n\t\t\t    if (value != null && value.length() > 0) {\n\t\t\t\t//为bean定义设置属性以及属性值\n\t\t\t\tbeanDefinition.getPropertyValues().addPropertyValue(name, value);\n\t\t\t    } else if (ref != null && ref.length() > 0) {\n\t\t\t\t//为bean定义设置属性以及属性值（引用）\n\t\t\t\tbeanDefinition.getPropertyValues().addPropertyValue(name, new RuntimeBeanReference(ref));\n\t\t\t    } else {\n\t\t\t\t//不支持的子标签\n\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported <property name=\\\"\" + name + \"\\\"> sub tag, Only supported <property name=\\\"\" + name + \"\\\" ref=\\\"...\\\" /> or <property name=\\\"\" + name + \"\\\" value=\\\"...\\\" />\");\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n}\n```\n\n#### parseNested方法\n\n```java\nparseNested(element, parserContext, ServiceBean.class, true, \"service\", \"provider\", id, beanDefinition);\nparseNested(element, parserContext, ReferenceBean.class, false, \"reference\", \"consumer\", id, beanDefinition);\n\n\n\n/**\n* 解析嵌套标签\n* 即：\n*   <dubbo:provider>\n*        <dubbo:service interface=\"\">\n*            <dubbo:method name=\"\"></dubbo:method>\n*        </dubbo:service>\n*        <dubbo:service interface=\"\">\n*            <dubbo:method name=\"\"></dubbo:method>\n*        </dubbo:service>\n*   </dubbo:provider>\n* @param element  当前元素：<dubbo:provider>\n* @param parserContext 上下文\n* @param beanClass  ServiceBean.class/ReferenceBean.class\n* @param required   true/false\n* @param tag   标签      service/reference\n* @param property 属性   provider/consumer\n* @param ref   待实例化bean的Id\n* @param beanDefinition 待实例化bean定义\n*/\nprivate static void parseNested(Element element, ParserContext parserContext, Class<?> beanClass,\n\t\t\t    boolean required, String tag, String property, \n\t\t\t    String ref,BeanDefinition beanDefinition) {\n        //获取当前元素的子节点\n\tNodeList nodeList = element.getChildNodes();\n\tif (nodeList != null && nodeList.getLength() > 0) {\n\t    boolean first = true;\n\t    //遍历子节点\n\t    for (int i = 0; i < nodeList.getLength(); i++) {\n\t\t//当前子节点\n\t\tNode node = nodeList.item(i);\n\t\tif (node instanceof Element) {\n\t\t    //如果当前子节点的名称等于tag\n\t\t    if (tag.equals(node.getNodeName())\n\t\t\t    || tag.equals(node.getLocalName())) {\n\t\t\t//是否第一个子节点\n\t\t\tif (first) {\n\t\t\t    first = false;\n\t\t\t    //获取当前元素default属性\n\t\t\t    String isDefault = element.getAttribute(\"default\");\n\t\t\t    if (isDefault == null || isDefault.length() == 0) {\n\t\t\t\t//如果default属性为空，则为bean定义增加default属性，并将属性值设置成false\n\t\t\t\tbeanDefinition.getPropertyValues().addPropertyValue(\"default\", \"false\");\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t        //调用parse方法递归解析beanClass（即ServiceBean.class/ReferenceBean.class）\n\t\t\tBeanDefinition subDefinition = parse((Element) node, parserContext, beanClass, required);\n\t\t\t\n\t\t\t//如果子bean不为空，且ref不为空，则为子bean增加property属性(provider/consumer)(即将父bean设置进去,ref参数)\n\t\t\tif (subDefinition != null && ref != null && ref.length() > 0) {\n\t\t\t    subDefinition.getPropertyValues().addPropertyValue(property, new RuntimeBeanReference(ref));\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n}\n```\n#### parseParameters方法\n```java\n/**\n* 当前property为parameters，解析参数标签 <dubbo:parameter>\n* @param nodeList 所有子节点列表\n* @param beanDefinition 当前待实例化的bean\n* @return 自定义参数集合\n*/\nprivate static ManagedMap parseParameters(NodeList nodeList, RootBeanDefinition beanDefinition) {\n\tif (nodeList != null && nodeList.getLength() > 0) {\n\t    \n\t    ManagedMap parameters = null;\n            \n\t    //遍历子节点\n\t    for (int i = 0; i < nodeList.getLength(); i++) {\n\t\t\n\t\tNode node = nodeList.item(i);\n\t\t\n\t\tif (node instanceof Element) {\n\t\t    \n\t\t    //如果子节点名称是parameter\n\t\t    if (\"parameter\".equals(node.getNodeName())\n\t\t\t    || \"parameter\".equals(node.getLocalName())) {\n\t\t\t\n\t\t\tif (parameters == null) {\n\t\t\t    parameters = new ManagedMap();\n\t\t\t}\n\t\t\t\n\t\t\t//获取子节点的key属性、value属性、hide属性\n\t\t\tString key = ((Element) node).getAttribute(\"key\");\n\t\t\tString value = ((Element) node).getAttribute(\"value\");\n\t\t\tboolean hide = \"true\".equals(((Element) node).getAttribute(\"hide\"));\n\t\t\t\n\t\t\tif (hide) {\n\t\t\t    //如果需要隐藏的话，则修改key属性的值\n\t\t\t    key = Constants.HIDE_KEY_PREFIX + key;\n\t\t\t}\n\t\t\t\n\t\t\t//保存参数信息\n\t\t\tparameters.put(key, new TypedStringValue(value, String.class));\n\t\t    }\n\t\t}\n\t    }\n\t    return parameters;\n\t}\n\treturn null;\n}\n```\n\n#### parseMethods方法\n```java\n\n/**\n *\n * 当前property为methods，解析<dubbo:method>标签\n * @param id 当前待实例化的bean-id\n * @param nodeList 所有子节点列表\n * @param beanDefinition 待实例化bean\n * @param parserContext\n */\nprivate static void parseMethods(String id, NodeList nodeList, \n\t\t\t\tRootBeanDefinition beanDefinition,\n\t\t\t\tParserContext parserContext) {\n\n\tif (nodeList != null && nodeList.getLength() > 0) {\n\t    ManagedList methods = null;\n\t    \n\t    //遍历子节点列表\n\t    for (int i = 0; i < nodeList.getLength(); i++) {\n\t\t\n\t\tNode node = nodeList.item(i);\n\t\t\n\t\tif (node instanceof Element) {\n        if (ProtocolConfig.class.equals(beanClass)) {\n            //如果当前要实例化的bean是ProtocolConfig类，则遍历Spring所有已经注册的bean的名称\n            for (String name : parserContext.getRegistry().getBeanDefinitionNames()) {\n                //根据bean名称获取已注册的bean定义\n                BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name);\n                //查看已注册的bean定义中是否存在protocol属性\n                PropertyValue property = definition.getPropertyValues().getPropertyValue(\"protocol\");\n                if (property != null) {\n                    //存在protocol属性，则获取protocol属性值\n                    Object value = property.getValue();\n                    //如果protocol属性值为ProtocolConfig类型，并且当前实例化的bean的id等于protocol属性值的name属性值的话，\n                    //则将当前实例化的bean包装成RuntimeBeanReference类型\n                    //然后将已注册的bean的protocol属性的值设为刚才新创建的RuntimeBeanReference\n                    //也就是说将当前解析的bean（ProtocolConfig）设置到其他已注册的bean的protocol属性中\n                    if (value instanceof ProtocolConfig && id.equals(((ProtocolConfig) value).getName())) {\n                        definition.getPropertyValues().addPropertyValue(\"protocol\", new RuntimeBeanReference(id));\n                    }\n                }\n            }\n        } else if (ServiceBean.class.equals(beanClass)) {\n            //进一步解析<dubbo:service/>标签，这里的逻辑就是处理下面的第二种配置\n            //如：<dubbo:service protocol=\"dubbo\" ref=\"userService\" interface=\"org.dubbo.service.UserInterface\" retries=\"0\" />\n            //   <bean id=\"userService\" class=\"org.dubbo.service.impl.UserServiceImpl\" />\n            //和如下配置相同\n            //<dubbo:service interface=\"org.dubbo.service.UserInterface\" class=\"org.dubbo.service.impl.UserServiceImpl\" protocol=\"dubbo\" retries=\"0\">\n            //   <property name=\"name\" value=\"dubbo\" ref=\"\"/>\n            //   <property name=\"age\" value=\"5\" ref=\"\"/>\n            //</dubbo:service>\n\n            //如果当前要实例化的bean是ServiceBean类,则获取class属性并解析\n            String className = element.getAttribute(\"class\");\n            if (className != null && className.length() > 0) {\n                //如果class属性不为空，则实例化该class属性指定的类\n                RootBeanDefinition classDefinition = new RootBeanDefinition();\n                classDefinition.setBeanClass(ReflectUtils.forName(className));\n                classDefinition.setLazyInit(false);\n                //解析子标签元素(即上面例子中的property属性)(后面会介绍parseProperties方法)\n                parseProperties(element.getChildNodes(), classDefinition);\n                //为当前待实例化的bean定义增加ref属性值（即class属性对应的bean，id为 beanId + impl）\n                beanDefinition.getPropertyValues().addPropertyValue(\"ref\", new BeanDefinitionHolder(classDefinition, id + \"Impl\"));\n            }\n        } else if (ProviderConfig.class.equals(beanClass)) {\n            //进一步处理<dubbo:provider/>标签(后面会分析parseNested方法)\n            parseNested(element, parserContext, ServiceBean.class, true, \"service\", \"provider\", id, beanDefinition);\n        } else if (ConsumerConfig.class.equals(beanClass)) {\n            //进一步处理<dubbo:consumer/>标签的子标签<dubbo:reference/>\n            parseNested(element, parserContext, ReferenceBean.class, false, \"reference\", \"consumer\", id, beanDefinition);\n        }\n        \n\t//当前待实例化的bean的所有的属性(通过set方法获取到)\n        Set<String> props = new HashSet<String>();\n        ManagedMap parameters = null;\n        //遍历待实例化类的所有方法,找到set方法\n        for (Method setter : beanClass.getMethods()) {\n            \n            String name = setter.getName();\n            \n            //找到set方法，条件如下：方法名长度大于3，以set开头，是public修饰符，参数类型长度为1\n            if (name.length() > 3 && name.startsWith(\"set\")\n                    && Modifier.isPublic(setter.getModifiers())\n                    && setter.getParameterTypes().length == 1) {\n               \n                 //获取参数类型\n                Class<?> type = setter.getParameterTypes()[0];\n\n                //如setFirstName(String firstName)方法\n                //将会得到property=first-name\n                String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), \"-\");\n          \n\t        //将属性名称添加到props集合中\n                props.add(property);\n               \n                //获取到属性的get方法\n                Method getter = null;\n               \n                try {\n                    getter = beanClass.getMethod(\"get\" + name.substring(3), new Class<?>[0]);\n                } catch (NoSuchMethodException e) {\n                    try {\n                        //如果没有找到get方法，则尝试找到isXXX方法\n                        getter = beanClass.getMethod(\"is\" + name.substring(3), new Class<?>[0]);\n                    } catch (NoSuchMethodException e2) {\n                    }\n                }\n                if (getter == null\n                        || !Modifier.isPublic(getter.getModifiers())\n                        || !type.equals(getter.getReturnType())) {\n                    //如果get方法为空、不是public限定符、或者get方法返回值和set方法参数类型不一致的话，\n                    //则跳过该property的处理，进行下一个property的处理\n                    continue;\n                }\n                if (\"parameters\".equals(property)) {\n                    //如果当前property为parameters，则解析当前元素的子元素(<dubbo:parameter>标签)(后面会分析parseParameters方法)\n                    parameters = parseParameters(element.getChildNodes(), beanDefinition);\n                } else if (\"methods\".equals(property)) {\n                    //如果当前property为methods，则解析当前元素的子元素(<dubbo:method>标签)(后面会分析parseMethods方法)\n                    parseMethods(id, element.getChildNodes(), beanDefinition, parserContext);\n                } else if (\"arguments\".equals(property)) {\n                    //如果当前property为arguments，则解析当前元素的子元素(<dubbo:argument>标签)(后面会分析parseArguments方法)\n                    parseArguments(id, element.getChildNodes(), beanDefinition, parserContext);\n                } else {\n                    //从xml定义中获取property属性值\n                    String value = element.getAttribute(property);\n                    if (value != null) {\n                        value = value.trim();\n                        if (value.length() > 0) {\n                            if (\"registry\".equals(property) && RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(value)) {\n                                //如果当前属性为registry，并且属性值为N/A\n                                //则为当前bean定义添加属性registry，并且属性值为RegistryConfig对象(该对象的address属性值为不可用)\n                                RegistryConfig registryConfig = new RegistryConfig();\n                                registryConfig.setAddress(RegistryConfig.NO_AVAILABLE);\n                                beanDefinition.getPropertyValues().addPropertyValue(property, registryConfig);\n                            } else if (\"registry\".equals(property) && value.indexOf(',') != -1) {\n                                //如果当前属性为registry，并且属性值包含逗号\",\",即有多个值，则进一步解析(后面会分析parseMultiRef方法)\n                                parseMultiRef(\"registries\", value, beanDefinition, parserContext);\n                            } else if (\"provider\".equals(property) && value.indexOf(',') != -1) {\n                                //如果当前属性为providers，并且属性值包含逗号\",\",即有多个值，则进一步解析\n                                parseMultiRef(\"providers\", value, beanDefinition, parserContext);\n                            } else if (\"protocol\".equals(property) && value.indexOf(',') != -1) {\n                                //如果当前属性为protocol，并且属性值包含逗号\",\",即有多个值，则进一步解析\n                                parseMultiRef(\"protocols\", value, beanDefinition, parserContext);\n                            } else {\n                                Object reference;\n                                //判断set方法的参数类型是否是原始类型\n                                if (isPrimitive(type)) {\n                                     if (\"async\".equals(property) && \"false\".equals(value)\n                                            || \"timeout\".equals(property) && \"0\".equals(value)\n\t\t\t    \n\t\t    //当前节点的名称为\"method\"\n\t\t    if (\"method\".equals(node.getNodeName()) || \"method\".equals(node.getLocalName())) {\n\t\t\t\n\t\t\t//获取当前节点的name属性\n\t\t\tString methodName = element.getAttribute(\"name\");\n\t\t\t\n\t\t\tif (methodName == null || methodName.length() == 0) {\n\t\t\t    //name属性不可以为空\n\t\t\t    throw new IllegalStateException(\"<dubbo:method> name attribute == null\");\n\t\t\t}\n\t\t\t\n\t\t\tif (methods == null) {\n\t\t\t    methods = new ManagedList();\n\t\t\t}\n\t\t\t\n\t\t\t//调用parse方法递归解析MethodConfig.class\n\t\t\tBeanDefinition methodBeanDefinition = parse(((Element) node),\n\t\t\t\tparserContext, \n\t\t\t\tMethodConfig.class, \n\t\t\t\tfalse\n\t\t\t);\n\t\t\t\n\t\t\t//新生成的bean的名称\n\t\t\tString name = id + \".\" + methodName;\n\t\t\t\n\t\t\t//将bean名称和bean定义关联起来\n\t\t\tBeanDefinitionHolder methodBeanDefinitionHolder = new BeanDefinitionHolder(\n\t\t\t\tmethodBeanDefinition, name);\n\t\t\t//保存新生成的bean\n\t\t\tmethods.add(methodBeanDefinitionHolder);\n\t\t    }\n\t\t}\n\t    }\n\t    if (methods != null) {\n\t\t//为待实例化的bean添加methods属性\n\t\tbeanDefinition.getPropertyValues().addPropertyValue(\"methods\", methods);\n\t    }\n\t}\n}\n\n```\n\n#### parseArguments方法\n```java\n/**\n* 当前property为arguments，解析<dubbo:argument>标签\n* @param id  当前待实例化的bean-id\n* @param nodeList 子节点列表\n* @param beanDefinition 当前待实例化的bean\n* @param parserContext\n*/\nprivate static void parseArguments(String id, NodeList nodeList, RootBeanDefinition beanDefinition,\n\t\t\t       ParserContext parserContext) {\n\n\tif (nodeList != null && nodeList.getLength() > 0) {\n\t    \n\t    ManagedList arguments = null;\n\n\t    //遍历子节点\n\t    for (int i = 0; i < nodeList.getLength(); i++) {\n\t\t\n\t\tNode node = nodeList.item(i);\n\n\t\tif (node instanceof Element) {\n\t\t    \n\t\t    Element element = (Element) node;\n\n\t\t    //当前子节点名称为argument\n\t\t    if (\"argument\".equals(node.getNodeName()) || \"argument\".equals(node.getLocalName())) {\n\t\t\t\n\t\t\t//获取当前子节点的index属性\n\t\t\tString argumentIndex = element.getAttribute(\"index\");\n\t\t\t\n\t\t\tif (arguments == null) {\n\t\t\t    arguments = new ManagedList();\n\t\t\t}\n\n\t\t\t//调用parse方法递归解析ArgumentConfig.class\n\t\t\tBeanDefinition argumentBeanDefinition = parse(((Element) node),\n\t\t\t\tparserContext, \n\t\t\t\tArgumentConfig.class, \n\t\t\t\tfalse\n\t\t\t);\n\n\t\t\t//新生成的bean的名称\n\t\t\tString name = id + \".\" + argumentIndex;\n\n\t\t\t//将新生成的bean名称和bean定义关联起来\n\t\t\tBeanDefinitionHolder argumentBeanDefinitionHolder = new BeanDefinitionHolder(\n\t\t\t\targumentBeanDefinition, name);\n        if (!beanDefinitionRegistry.containsBeanDefinition(beanName)) {\n            //该bean还没有注册的话，则进行注册\n\t    RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType);\n            \n\t    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n            \n\t    beanDefinitionRegistry.registerBeanDefinition(beanName, beanDefinition);\n        }\n    }\n}\n```\n\nDubboBeanDefinitionParser解析类就介绍完毕了，最后给一个的parse方法的处理流程图.\n![](img/DubboBeanDefinitionParser.png)\n\n\n\n\n\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之集成Spring标签配置类(01)","url":"/blog/2018/08/04/Dubbo源码阅读之集成Spring-01标签配置类/","content":"\n>本小节将会介绍下如何在Spring环境中使用Dubbo，以及Dubbo标签实体类\n\n* Spring中使用Dubbo的Demo\n* Dubbo标签解析\n\n\n### Spring中使用Dubbo的Demo\n我们先来看下Dubbo源码中dubbo-demo包中的例子。\n\n#### dubbo-demo-api\n首先在dubbo-demo-api模块中定义了一个接口：\n```java\npublic interface DemoService {\n    String sayHello(String name);\n}\n```\n\n然后在dubbo-demo-provider模块和dubbo-demo-consumer模块中分别引入dubbo-demo-api模块。\n\n#### dubbo-demo-provider\n我们先来看下dubbo-demo-provider服务提供端,新建一个DemoService接口的实现类DemoServiceImpl：\n```java\npublic class DemoServiceImpl implements DemoService {\n    @Override\n    public String sayHello(String name) {\n        System.out.println(\"[\" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()) + \"] Hello \" + name + \", request from consumer: \" + RpcContext.getContext().getRemoteAddress());\n        return \"Hello \" + name + \", response from provider: \" + RpcContext.getContext().getLocalAddress();\n    }\n}\n```\n然后在Spring配置文件中进行配置：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\"\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd\n       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\">\n    \n    <dubbo:application name=\"demo-provider\"/>\n    \n    <dubbo:registry address=\"multicast://224.5.6.7:1234\"/>\n    \n    <dubbo:protocol name=\"dubbo\" port=\"20880\"/>\n    \n    <bean id=\"demoService\" class=\"com.alibaba.dubbo.demo.provider.DemoServiceImpl\"/>\n    \n    <!--暴露服务-->\n    <dubbo:service interface=\"com.alibaba.dubbo.demo.DemoService\" ref=\"demoService\"/>\n</beans>\n```\n可以看到我们首先在配置文件中引入了dubbo自定义的schema文件，然后我们就可以在配置文件中使用dubbo自定义的标签了。这些标签我们后面会讲解。\n接下来我们新建一个Provider类，该类用来加载Spring配置文件，同时也启动了我们的服务器：\n```java\npublic class Provider {\n\n    public static void main(String[] args) throws Exception {\n        System.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n        //加载Spring配置\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{\"META-INF/spring/dubbo-demo-provider.xml\"});\n        context.start();\n        System.in.read(); // press any key to exit\n    }\n}\n```\n\n#### dubbo-demo-consumer\n\n我们在消费者端同样需要配置Spring配置文件：\n```xml\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\"\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd\n       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\">\n\n    <dubbo:application name=\"demo-consumer\"/>\n\n    <dubbo:registry address=\"multicast://224.5.6.7:1234\"/>\n    \n    <!--引用DemoService服务-->\n    <dubbo:reference id=\"demoService\" check=\"false\" interface=\"com.alibaba.dubbo.demo.DemoService\"/>\n\n</beans>\n```\n接着我们新建一个Consumer类：\n```java\npublic class Consumer {\n\n    public static void main(String[] args) {\n        System.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{\"META-INF/spring/dubbo-demo-consumer.xml\"});\n        context.start();\n\n        //获取远程服务代理\n        DemoService demoService = (DemoService) context.getBean(\"demoService\");\n       \n        while (true) {\n            try {\n                Thread.sleep(1000);\n                //调用远程服务方法\n                String hello = demoService.sayHello(\"world\");\n                //输出调用结果\n                System.out.println(hello);\n            } catch (Throwable throwable) {\n                throwable.printStackTrace();\n            }\n        }\n    }\n}\n```\n启动起来服务器和客户端，我们就可以看到输出结果了。经过上面的例子，我们可以看到使用Dubbo调用远程服务就像调用本地的服务一样简单。后面我们将详细介绍Dubbo是如何做到这些的。\n\n\n### Dubbo标签解析\n\n总体上Dubbo是通过自定义Spring标签，然后解析这些标签，将这些标签属性映射成一个个配置类，接着将这些类配置到Spring工厂，交给Spring容器来管理的方式来和Spring整合到一起的。\n这部分源码主要在dubbo-config包中，我们先看下Spring自定义标签的机制以及Dubbo标签对应的实体类，下一小节在具体分析如何解析标签。\n\n#### Spring自定义标签\n在dubbo-config-spring模块的resources目录下有三个文件，分别为：dubbo.xsd、spring.handlers、spring.schemas。\ndubbo.xsd文件中定义了所有支持的dubbo标签，spring.schemas文件中则指定了dubbo.xsd文件：\n```java\nhttp\\://dubbo.apache.org/schema/dubbo/dubbo.xsd=META-INF/dubbo.xsd\n```\n因此，我们需要分别在服务器、客户端的spring配置文件中引入该xsd文件，才可以使用dubbo标签。\n而spring.handlers文件中则指定了解析dubbo标签的类:\n```java\nhttp\\://dubbo.apache.org/schema/dubbo=com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler\n```\n我们就以com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler类作为入口，看看dubbo是如何解析标签的。\n\n我们来看下DubboNamespaceHandler类，该类继承自Spring的NamespaceHandlerSupport类，通过实现init方法来将dubbo标签节点和解析类进行关联：\n```java\npublic class DubboNamespaceHandler extends NamespaceHandlerSupport {\n    static {\n        //检测是否有重复的DubboNamespaceHandler类，这里不会抛异常，只会打印错误日志\n        Version.checkDuplicate(DubboNamespaceHandler.class);\n    }\n\n    /**\n     * 将节点名和解析类关联起来，NamespaceHandler通过节点名会找到相应的解析类\n     */\n    @Override\n    public void init() {\n        registerBeanDefinitionParser(\"application\", new DubboBeanDefinitionParser(ApplicationConfig.class, true));\n        registerBeanDefinitionParser(\"module\", new DubboBeanDefinitionParser(ModuleConfig.class, true));\n        registerBeanDefinitionParser(\"registry\", new DubboBeanDefinitionParser(RegistryConfig.class, true));\n        registerBeanDefinitionParser(\"monitor\", new DubboBeanDefinitionParser(MonitorConfig.class, true));\n        registerBeanDefinitionParser(\"provider\", new DubboBeanDefinitionParser(ProviderConfig.class, true));\n        registerBeanDefinitionParser(\"consumer\", new DubboBeanDefinitionParser(ConsumerConfig.class, true));\n        registerBeanDefinitionParser(\"protocol\", new DubboBeanDefinitionParser(ProtocolConfig.class, true));\n        registerBeanDefinitionParser(\"service\", new DubboBeanDefinitionParser(ServiceBean.class, true));\n        registerBeanDefinitionParser(\"reference\", new DubboBeanDefinitionParser(ReferenceBean.class, false));\n        registerBeanDefinitionParser(\"annotation\", new AnnotationBeanDefinitionParser());\n    }\n}\n```\n可以看到这里定义了dubbo标签的解析类DubboBeanDefinitionParser，同时也定义了该标签对应的bean(即xxxConfig类、xxxBean类)，这些bean最终交由Spring容器来管理。在介绍它们之前，我们先看一些通用的注解类,这些注解可以添加在bean类中的方法上，在解析标签的时候会用上这些注解。\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD})\npublic @interface Parameter {\n\n    String key() default \"\";\n\n    boolean required() default false;\n\n    /**\n     * 是否排除该方法\n     * @return\n     */\n    boolean excluded() default false;\n\n    /**\n     * 是否编码\n     * @return\n     */\n    boolean escaped() default false;\n\n    /**\n     * 属性为false的话，则不执行附加属性方法\n     * @return\n     */\n    boolean attribute() default false;\n\n    boolean append() default false;\n}\n```\n\n#### Dubbo标签对应的实体类\n在dubbo-config-api模块下的com.alibaba.dubbo.config包中定义了dubbo标签对应的实体类，我们先了解下这些实体类，然后再看如何解析它们。\n\n##### ApplicationConfig\n我们对照着使用方法一起看下：\n```xml\n <!--dubbo:application中可配置的属性都定义在ApplicationConfig实体类中-->\n <dubbo:application name=\"demo-provider\"/>\n```\nApplicationConfig类继承自AbstractConfig抽象类，该抽象类提供了一些解析配置的公共方法。\n```java\npublic class ApplicationConfig extends AbstractConfig {\n\n    private static final long serialVersionUID = 5508512956753757169L;\n\n    /**\n     * 服务治理（必填）\n     * 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样，\n     * 此参数不是匹配条件，你当前项目叫什么名字就填什么，和提供者消费者角色无关\n     * application\n     */\n    private String name;\n\n    /**\n     * 服务治理\n     * 当前应用模块版本\n     * application.version\n     */\n    private String version;\n\n    /**\n     * 服务治理\n     * 应用负责人，用于服务治理，请填写负责人公司邮箱前缀\n     * owner\n     */\n    private String owner;\n\n    /**\n     * 服务治理\n     * 组织名称(BU或部门)，用于注册中心区分服务来源，此配置项建议不要使用autoconfig，直接写死在配 置中，比如 china,intl,itu,crm,asc,dw,aliexpress 等\n     * organization\n     */\n    private String organization;\n\n    /**\n     * 服务治理\n     * 用于服务分层对应的架构。如，intl、china。不同的架构使用不同的分层\n     * architecture\n     */\n    private String architecture;\n\n    /**\n     * 服务治理\n     * 环境，例如：dev、test、production\n     * environment\n     */\n    private String environment;\n\n    /**\n     * 性能优化（javassist）\n     * Java字节码编译器，用于动态类的生成，可选：jdk或javassist\n     * compiler \n     */\n    private String compiler;\n\n    /**\n     * 性能优化（slf4j）\n     * 日志输出方式，可选： slf4j,jcl,log4j,jdk\n     * logger\n     */\n    private String logger;\n\n    /**\n     * 注册中心列表\n     */\n    private List<RegistryConfig> registries;\n\n    /**\n     * 监控中心\n     */\n    private MonitorConfig monitor;\n\n    /**\n     * 是否是默认的\n     */\n    private Boolean isDefault;\n\n    /**\n     * 保存线程转储的目录\n     */\n    private String dumpDirectory;\n\n    /**\n     * 是否启用qos\n     */\n    private Boolean qosEnable;\n\n    /**\n     * qos端口\n     */\n    private Integer qosPort;\n    /**\n     * 是否可以接受国外ip\n     */\n    private Boolean qosAcceptForeignIp;\n\n    /**\n     *  自定义参数\n     */\n    private Map<String, String> parameters;\n\n    public ApplicationConfig() {\n    }\n\n    public ApplicationConfig(String name) {\n        setName(name);\n    }\n\n    @Parameter(key = Constants.APPLICATION_KEY, required = true)\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        checkName(\"name\", name);\n        this.name = name;\n        if (id == null || id.length() == 0) {\n            id = name;\n        }\n    }\n\n    @Parameter(key = \"application.version\")\n    public String getVersion() {\n        return version;\n    }\n    public void setCompiler(String compiler) {\n        this.compiler = compiler;\n        AdaptiveCompiler.setDefaultCompiler(compiler);\n    }\n    public void setLogger(String logger) {\n        this.logger = logger;\n        LoggerFactory.setLoggerAdapter(logger);\n    }\n    // ...省略其他相似方法\n}\n```\n##### ModuleConfig\n```java\npublic class ModuleConfig extends AbstractConfig {\n\n    private static final long serialVersionUID = 5508512956753757169L;\n\n    /**\n     * 服务治理（必填）\n     * 当前模块名称，用于注册中心计算模块间依赖关系\n     * module\n     */\n    private String name;\n\n    /**\n     * 服务治理\n     * 当前模块的版本\n     * module.version\n     */\n    private String version;\n\n    /**\n     * 服务治理\n     * 模块负责人，用于服务治理，请填 写负责人公司邮箱前缀\n     * owner\n     */\n    private String owner;\n\n    /**\n     * 服务治理\n     * 组织名称(BU或部门)，用于注册中心区分服务来源，此配置项建议不要使用autoconfig，直接写死在配 置中，比如 china,intl,itu,crm,asc,dw,aliexpress 等\n     * organization\n     */\n    private String organization;\n\n    /**\n     * 注册中心列表\n     * registry centers\n     */\n    private List<RegistryConfig> registries;\n\n    /**\n     * 监控中心\n     * monitor center\n     */\n    private MonitorConfig monitor;\n\n    /**\n     * 是否是默认\n     */\n    private Boolean isDefault;\n\n    public ModuleConfig(String name) {\n        setName(name);\n    }\n\n    @Parameter(key = \"module\", required = true)\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        checkName(\"name\", name);\n        this.name = name;\n        //id为空的话，使用name的值\n        if (id == null || id.length() == 0) {\n            id = name;\n        }\n    }\n\n    @Parameter(key = \"module.version\")\n    public String getVersion() {\n        return version;\n    }\n    \n    public void setOwner(String owner) {\n        checkName(\"owner\", owner);\n        this.owner = owner;\n    }\n    \n    public void setOrganization(String organization) {\n        checkName(\"organization\", organization);\n        this.organization = organization;\n    }\n\n    public RegistryConfig getRegistry() {\n        return registries == null || registries.isEmpty() ? null : registries.get(0);\n    }\n\n    public void setRegistry(RegistryConfig registry) {\n        List<RegistryConfig> registries = new ArrayList<RegistryConfig>(1);\n        registries.add(registry);\n        this.registries = registries;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public void setRegistries(List<? extends RegistryConfig> registries) {\n        this.registries = (List<RegistryConfig>) registries;\n    }\n    // ...省略其他类似get、set方法\n}\n```\n\n##### RegistryConfig\n注册中心配置，如果有多个不同的注册中心，可以声明多个 <dubbo:registry> 标签，并在 <dubbo:service> 或 <dubbo:reference> 的 registry 属性指定使用的注册中心.\n```java\npublic class RegistryConfig extends AbstractConfig {\n\n    /**\n     * 不可用标识\n     */\n    public static final String NO_AVAILABLE = \"N/A\";\n\n    /**\n     * 服务发现（必填）\n     * 注册中心服务器地址，如果地址没有端口缺省为9090，同一集群内的多个地址用逗号分隔，如：ip:port,ip:port\n     * 不同集群的注册中心，请配置多个 <dubbo:registry> 标签\n     * <host:port>\n     */\n    private String address;\n\n    /**\n     * 服务治理\n     * 登录注册中心用户名，如果注册中心不需要验证可不填\n     * <username>\n     */\n    private String username;\n\n    /**\n     * 服务治理\n     * 登录注册中心密码，如果注册中心不需要验证可不填\n     * <password>\n     */\n    private String password;\n\n    /**\n     * 服务发现\n     * 注册中心默认端口,当address没有带端口时使用此端口做为缺省值\n     * <port>\n     */\n    private Integer port;\n\n    /**\n     * 服务发现(dubbo)\n     * 注册中心地址协议,支持dubbo,http,local三种协议,分别表示: dubbo地址,http地址,本地注册中心\n     * <protocol>\n     */\n    private String protocol;\n\n    /**\n     * 性能调优(netty)\n     * 网络传输方式，可选mina,netty\n     * registry.transporter\n     */\n    private String transporter;\n\n    private String server;\n\n    private String client;\n    \n    private String cluster;\n\n    private String group;\n\n    private String version;\n\n    /**\n     * 性能调优(5000)\n     * 注册中心请求超时时间(毫秒)\n     * registry.timeout\t\n     */\n    private Integer timeout;\n\n    /** \n     * 性能调优(60000)\n     * 注册中心会话超时时间(毫秒)，用于检测提供者非正常断线后的脏数据，比如用心跳检测的实现，此时间就是心跳间隔，不同注册中心实现不一样\n     * registry.session\n     */\n    private Integer session;\n\n    /**\n     * 服务治理\n     * 使用文件缓存注 册中心地址列表及服务提供者列表，应用重启时将基于此文件恢复，注意：两个注册中心不能使用同一文件存储\n     * registry.file\n     */\n    private String file;\n\n    /**\n     * 性能调优(0)\n     * 停止时等待通知完成时间(毫秒)\n     * registry.wait\n     */\n    private Integer wait;\n\n    /**\n     * 服务治理(true)\n     * 在启动时，是否检测注册中心是否可用\n     * check\n     */\n    private Boolean check;\n\n    /**\n     * 服务治理(true)\n     * 服务是否动态注册，如果设为 false，注册后将显示后disable状态，需人工启用，并且服务提供者停止时，也不会自动取消册，需人工禁用\n     * dynamic\n     */\n    private Boolean dynamic;\n\n    /**\n     * 服务治理（true）\n     * 是否向此注册中心注册服务，如果设为false，将只订阅，不注册\n     * register\n     */\n    private Boolean register;\n\n    /**\n     * 服务治理（true）\n     * 是否向此注册中心订阅服务，如果设为false，将只注册，不订阅\n     * subscribe \n     */\n    private Boolean subscribe;\n\n    /**\n     * 自定义参数\n     */\n    private Map<String, String> parameters;\n\n    /**\n     * 是否是默认\n     */\n    private Boolean isDefault;\n\n    public RegistryConfig() {\n    }\n\n    public static void destroyAll() {\n        AbstractRegistryFactory.destroyAll();\n    }\n\n    public void setProtocol(String protocol) {\n        checkName(\"protocol\", protocol);\n        this.protocol = protocol;\n    }\n\n    @Parameter(excluded = true)\n    public String getAddress() {\n        return address;\n    }\n\n    public void setUsername(String username) {\n        checkName(\"username\", username);\n        this.username = username;\n    }\n\n    public void setFile(String file) {\n        checkPathLength(\"file\", file);\n        this.file = file;\n    }\n\n    public void setTransporter(String transporter) { \n        checkName(\"transporter\", transporter);\n        this.transporter = transporter;\n    }\n\n    public void setServer(String server) {\n        checkName(\"server\", server);\n        this.server = server;\n    }\n\n    public void setClient(String client) {\n        checkName(\"client\", client);\n        this.client = client;\n    }\n\n}\n```\n##### MonitorConfig\n```java\npublic class MonitorConfig extends AbstractConfig {\n\n    /**\n     * 服务治理(dubbo)\n     * 监控中心协议，如果为protocol=”registry”，表示从注册中心发现监控中心地址，否则直连监控中心\n     * protocol\n     */\n    private String protocol;\n    \n    /**\n     * 服务治理(N/A)\n     * 直连监控中心服务器地址，address=”10.20.130.230:12080”\n     * <url>\n     */\n    private String address;\n\n    private String username;\n\n    private String password;\n\n    private String group;\n\n    private String version;\n\n    private String interval;\n\n    private Map<String, String> parameters;\n\n    private Boolean isDefault;\n\n    public MonitorConfig(String address) {\n        this.address = address;\n    }\n\n    @Parameter(excluded = true)\n    public String getAddress() {\n        return address;\n    }\n\n    @Parameter(excluded = true)\n    public String getProtocol() {\n        return protocol;\n    }\n\n    @Parameter(excluded = true)\n    public String getUsername() {\n        return username;\n    }\n    @Parameter(excluded = true)\n    public String getPassword() {\n        return password;\n    }\n\n    public void setParameters(Map<String, String> parameters) {\n        checkParameterName(parameters);\n        this.parameters = parameters;\n    }\n\n}\n```\n##### ProviderConfig\n该类继承自AbstractServiceConfig类\n```java\npublic class ProviderConfig extends AbstractServiceConfig {\n\n    //如果没有设置协议的属性值，那么默认值将会生效\n    /**\n     * 服务ip地址（当有多个网卡可用时使用）(自动查找本机IP)\n     * <host>\n     */\n    private String host;\n\n    /**\n     * 服务端口\n     * port\n     */\n    private Integer port;\n\n    /**\n     * 上下文路径\n     * contextpath\n     */\n    private String contextpath;\n\n    /**\n     * 线程池(fixed)\n     * threadpool\n     */\n    private String threadpool;\n\n    /**\n     * 线程池大小（固定大小）\n     */\n    private Integer threads;\n\n    /**\n     * IO线程池大小（CPU数+1）\n     * iothreads\n     */\n    private Integer iothreads;\n\n    /**\n     * 线程池队列长度(0)\n     * queues\n     */\n    private Integer queues;\n\n    /**\n     * 最大可接受的连接(0)\n     * accepts\n     */\n    private Integer accepts;\n\n    /**\n     * 协议编解码器（dubbo）\n     * codec\n     */\n    private String codec;\n\n    /**\n     * 编码（UTF-8）\n     * charset\n     */\n    private String charset;\n\n    /**\n     * payload最大长度(88388608(=8M))\n     * payload\n     */\n    private Integer payload;\n\n    /**\n     * buffer大小(8192)\n     * buffer\n     */\n    private Integer buffer;\n\n    /**\n     * transporter\n     */\n    private String transporter;\n\n    /**\n     * how information gets exchanged\n     */\n    private String exchanger;\n\n    /**\n     * 性能调优\n     * 线程调度模式\n     * 协议的消息派发方式，用于指定线程模型，比如：dubbo协议的all,direct,message,execution,connection等\n     */\n    private String dispatcher;\n\n    /**\n     * networker\n     */\n    private String networker;\n\n    /**\n     * 服务器实现\n     * dubbo协议缺省 为netty，http协议缺省为servlet\n     * server\n     */\n    private String server;\n\n    /**\n     * 客户端实现\n     * dubbo协议缺省 为netty\n     * client\n     */\n    private String client;\n\n    /**\n     * 支持telnet命令,逗号分割\n     */\n    private String telnet;\n\n    /**\n     * 命令行提示符\n     */\n    private String prompt;\n\n    /**\n     * 状态检测\n     */\n    private String status;\n\n    /**\n     * 停止的时候等待多久\n     */\n    private Integer wait;\n\n    private Boolean isDefault;\n\n    @Parameter(excluded = true)\n    public Boolean isDefault() {\n        return isDefault;\n    }\n\n    @Parameter(excluded = true)\n    public String getHost() {\n        return host;\n    }\n\n    @Parameter(excluded = true)\n    public Integer getPort() {\n        return port;\n    }\n\n    @Parameter(excluded = true)\n    public String getContextpath() {\n        return contextpath;\n    }\n\n    public void setContextpath(String contextpath) {\n        checkPathName(\"contextpath\", contextpath);\n        this.contextpath = contextpath;\n    }\n\n    public void setThreadpool(String threadpool) {\n        checkExtension(ThreadPool.class, \"threadpool\", threadpool);\n        this.threadpool = threadpool;\n    }\n\n    public void setTelnet(String telnet) {\n        checkMultiExtension(TelnetHandler.class, \"telnet\", telnet);\n        this.telnet = telnet;\n    }\n\n    @Parameter(escaped = true)\n    public String getPrompt() {\n        return prompt;\n    }\n    public void setStatus(String status) {\n        checkMultiExtension(StatusChecker.class, \"status\", status);\n        this.status = status;\n    }\n\n    @Override\n    public String getCluster() {\n        return super.getCluster();\n    }\n\n    @Override\n    public Integer getConnections() {\n        return super.getConnections();\n    }\n\n    @Override\n    public Integer getTimeout() {\n        return super.getTimeout();\n    }\n\n    @Override\n    public Integer getRetries() {\n        return super.getRetries();\n    }\n\n    @Override\n    public String getLoadbalance() {\n        return super.getLoadbalance();\n    }\n\n    @Override\n    public Boolean isAsync() {\n        return super.isAsync();\n    }\n\n    @Override\n    public Integer getActives() {\n        return super.getActives();\n    }\n\n    public void setTransporter(String transporter) {\n        checkExtension(Transporter.class, \"transporter\", transporter);\n        this.transporter = transporter;\n    }\n\n    public void setExchanger(String exchanger) {\n        checkExtension(Exchanger.class, \"exchanger\", exchanger);\n        this.exchanger = exchanger;\n    }\n\n    public void setDispatcher(String dispatcher) {\n        checkExtension(Dispatcher.class, Constants.DISPATCHER_KEY, exchanger);\n        checkExtension(Dispatcher.class, \"dispather\", exchanger);\n        this.dispatcher = dispatcher;\n    }\n}\n```\n##### AbstractMethodConfig\n该抽象类继承自AbstractConfig\n```java\npublic abstract class AbstractMethodConfig extends AbstractConfig {\n\n    /**\n     * 远程调用超时(1000毫秒)\n     * timeout for remote invocation in milliseconds\n     */\n    protected Integer timeout;\n\n    /**\n     * 重试次数（2）\n     */\n    protected Integer retries;\n\n    /**\n     * 最大并发调用(0)\n     * max concurrent invocations\n     */\n    protected Integer actives;\n\n    /**\n     * 负载均衡（random）\n     */\n    protected String loadbalance;\n\n    /**\n     * 是否异步\n     */\n    protected Boolean async;\n\n    /**\n     * 是否确认异步发送\n     */\n    protected Boolean sent;\n\n    /**\n     * 当服务调用失败时，被调用的mack类的名字\n     * mock\n     */\n    protected String mock;\n\n    /**\n     * 合并\n     */\n    protected String merger;\n\n    /**\n     * 缓存\n     */\n    protected String cache;\n\n    /**\n     * 验证\n     */\n    protected String validation;\n\n    /**\n     * 自定义参数\n     */\n    protected Map<String, String> parameters;\n\n    public void setLoadbalance(String loadbalance) {\n        checkExtension(LoadBalance.class, \"loadbalance\", loadbalance);\n        this.loadbalance = loadbalance;\n    }\n\n    @Parameter(escaped = true)\n    public String getMock() {\n        return mock;\n    }\n\n    public void setMock(Boolean mock) {\n        if (mock == null) {\n            setMock((String) null);\n        } else {\n            setMock(String.valueOf(mock));\n        }\n    }\n\n    public void setMock(String mock) {\n        if (mock != null && mock.startsWith(Constants.RETURN_PREFIX)) {\n            checkLength(\"mock\", mock);\n        } else {\n            checkName(\"mock\", mock);\n        }\n        this.mock = mock;\n    }\n}\n```\n\n##### AbstractInterfaceConfig\n该类继承自AbstractMethodConfig\n```java\npublic abstract class AbstractInterfaceConfig extends AbstractMethodConfig {\n\n    /**\n     * 服务接口的本地实现类名称\n     */\n    protected String local;\n\n    /**\n     * 服务接口的本地存根类名称\n     */\n    protected String stub;\n\n    /**\n     * 服务监控\n     */\n    protected MonitorConfig monitor;\n\n    /**\n     * 代理类型\n     */\n    protected String proxy;\n\n    /**\n     * 性能调优（failover）\n     * 集群方式，可选：failover/failfast/failsafe/failback/forking\n     * default.cluster\n     */\n    protected String cluster;\n\n    /**\n     * 过滤器\n     */\n    protected String filter;\n\n    /**\n     * 监听器\n     */\n    protected String listener;\n\n    /**\n     * 所有者\n     */\n    protected String owner;\n\n    /**\n     * 连接限制，0标识共享连接（0）\n     * 否则它定义委托给当前服务的连接\n     * default.connections\t\n     */\n    protected Integer connections;\n\n    protected String layer;\n\n    /**\n     * application配置\n     */\n    protected ApplicationConfig application;\n\n    /**\n     *  module配置\n     */\n    protected ModuleConfig module;\n\n    /**\n     * 注册中心内地址\n     * <dubbo:registry address=\"multicast://224.5.6.7:1234\" id=\"com.alibaba.dubbo.config.RegistryConfig\" />\n     */\n    protected List<RegistryConfig> registries;\n\n    /**\n     * 连接事件\n     * connection events\n     */\n    protected String onconnect;\n\n    /**\n     * 断开连接事件\n     * disconnection events\n     */\n    protected String ondisconnect;\n\n    /**\n     * 回调限制\n     * callback limits\n     */\n    private Integer callbacks;\n\n    /**\n     * 引用/暴露服务的作用域\n     * 如果它是local，则意味着只在当前虚拟机中进行搜索\n     */\n    private String scope;\n\n    public void setStub(Boolean stub) {\n        if (stub == null) {\n            setStub((String) null);\n        } else {\n            setStub(String.valueOf(stub));\n        }\n    }\n\n    public void setStub(String stub) {\n        checkName(\"stub\", stub);\n        this.stub = stub;\n    }\n\n    public void setCluster(String cluster) {\n        checkExtension(Cluster.class, \"cluster\", cluster);\n        this.cluster = cluster;\n    }\n\n    public void setProxy(String proxy) {\n        checkExtension(ProxyFactory.class, \"proxy\", proxy);\n        this.proxy = proxy;\n    }\n\n    @Parameter(key = Constants.REFERENCE_FILTER_KEY, append = true)\n    public String getFilter() {\n        return filter;\n    }\n\n    public void setFilter(String filter) {\n        checkMultiExtension(Filter.class, \"filter\", filter);\n        this.filter = filter;\n    }\n\n    @Parameter(key = Constants.INVOKER_LISTENER_KEY, append = true)\n    public String getListener() {\n        return listener;\n    }\n\n    public void setListener(String listener) {\n        checkMultiExtension(InvokerListener.class, \"listener\", listener);\n        this.listener = listener;\n    }\n    public void setLayer(String layer) {\n        checkNameHasSymbol(\"layer\", layer);\n        this.layer = layer;\n    }\n\n    public RegistryConfig getRegistry() {\n        return registries == null || registries.isEmpty() ? null : registries.get(0);\n    }\n\n    public void setRegistry(RegistryConfig registry) {\n        List<RegistryConfig> registries = new ArrayList<RegistryConfig>(1);\n        registries.add(registry);\n        this.registries = registries;\n    }\n    //省略其他方法...后面会介绍\n}\n```\n##### AbstractServiceConfig\n该抽象类继承自AbstractInterfaceConfig\n```java\npublic abstract class AbstractServiceConfig extends AbstractInterfaceConfig {\n\n\n    /**\n     * 版本(0.0.0)\n     */\n    protected String version;\n\n    /**\n     * 组\n     */\n    protected String group;\n\n    /**\n     * 服务是否被弃用\n     */\n    protected Boolean deprecated;\n\n    /**\n     * 延迟暴露\n     */\n    protected Integer delay;\n\n    /**\n     * 是否暴露服务\n     */\n    protected Boolean export;\n\n    /**\n     * 权重\n     */\n    protected Integer weight;\n\n    /**\n     * 文档中心\n     */\n    protected String document;\n\n    /**\n     * 是否在注册中心注册为动态服务(true)\n     */\n    protected Boolean dynamic;\n\n    /**\n     * 是否使用token\n     */\n    protected String token;\n\n    /**\n     * 访问日志\n     * access log\n     */\n    protected String accesslog;\n    protected List<ProtocolConfig> protocols;\n    /**\n     * 允许最大执行时间\n     * max allowed execute times\n     */\n    private Integer executes;\n    /**\n     * 是否注册\n     * whether to register\n     */\n    private Boolean register;\n\n    /**\n     * 根据指定的稳定吞吐率和预热期来创建RateLimiter\n     * warm up period\n     */\n    private Integer warmup;\n\n    /**\n     * dubbo协议缺省为hessian2， rmi协议缺省为java，http协议缺省为json\n     * serialization\n     */\n    private String serialization;\n\n\n    public void setVersion(String version) {\n        checkKey(\"version\", version);\n        this.version = version;\n    }\n\n    public void setGroup(String group) {\n        checkKey(\"group\", group);\n        this.group = group;\n    }\n\n    @Parameter(escaped = true)\n    public String getDocument() {\n        return document;\n    }\n\n    public void setToken(String token) {\n        checkName(\"token\", token);\n        this.token = token;\n    }\n\n    public void setToken(Boolean token) {\n        if (token == null) {\n            setToken((String) null);\n        } else {\n            setToken(String.valueOf(token));\n        }\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public void setProtocols(List<? extends ProtocolConfig> protocols) {\n        this.protocols = (List<ProtocolConfig>) protocols;\n    }\n\n    public ProtocolConfig getProtocol() {\n        return protocols == null || protocols.isEmpty() ? null : protocols.get(0);\n    }\n\n    public void setProtocol(ProtocolConfig protocol) {\n        this.protocols = Arrays.asList(new ProtocolConfig[]{protocol});\n    }\n\n    public void setAccesslog(Boolean accesslog) {\n        if (accesslog == null) {\n            setAccesslog((String) null);\n        } else {\n            setAccesslog(String.valueOf(accesslog));\n        }\n    }\n\n    @Override\n    @Parameter(key = Constants.SERVICE_FILTER_KEY, append = true)\n    public String getFilter() {\n        return super.getFilter();\n    }\n\n    @Override\n    @Parameter(key = Constants.EXPORTER_LISTENER_KEY, append = true)\n    public String getListener() {\n        return super.getListener();\n    }\n\n    @Override\n    public void setListener(String listener) {\n        checkMultiExtension(ExporterListener.class, \"listener\", listener);\n        super.setListener(listener);\n    }\n}\n\n```\n##### ConsumerConfig\n```java\npublic class ConsumerConfig extends AbstractReferenceConfig {\n\n    private Boolean isDefault;\n\n    /**\n     * 使用的网络框架客户端：netty, mina, etc\n     */\n    private String client;\n\n    @Override\n    public void setTimeout(Integer timeout) {\n        super.setTimeout(timeout);\n        //设置rmi超时时间\n        String rmiTimeout = System.getProperty(\"sun.rmi.transport.tcp.responseTimeout\");\n        if (timeout != null && timeout > 0\n                && (rmiTimeout == null || rmiTimeout.length() == 0)) {\n            System.setProperty(\"sun.rmi.transport.tcp.responseTimeout\", String.valueOf(timeout));\n        }\n    }\n}\n```\n##### AbstractReferenceConfig\n```java\npublic abstract class AbstractReferenceConfig extends AbstractInterfaceConfig {\n\n    //如果Reference的属性没有配置，则默认值将会生效\n\n    /**\n     * 检测服务提供者是否存在\n     */\n    protected Boolean check;\n\n    /**\n     * 1、是否立即初始化，如果为true,bean加载时会立即调用消费者初始化\n     * 2、消费者bean被使用者调用时，调用getObject->get->init\n     */\n    protected Boolean init;\n\n    /**\n     * 是否使用缺省泛化接口\n     */\n    protected String generic;\n\n    /**\n     * scope = local\n     * 是否从当前虚拟机中查找reference的实例\n     * whether to find reference's instance from the current JVM\n     */\n    protected Boolean injvm;\n\n    /**\n     * 惰性创建连接\n     * lazy create connection\n     */\n    protected Boolean lazy;\n\n    /**\n     * 重连\n     */\n    protected String reconnect;\n\t\n    protected Boolean sticky;\n\n    /**\n     * stub中是否支持事件\n     * Constants.DEFAULT_STUB_EVENT\n     */\n    protected Boolean stubevent;\n\n    /**\n     * 默认版本\n     */\n    protected String version;\n\n    protected String group;\n\n    @Parameter(excluded = true)\n    public Boolean isGeneric() {\n        return ProtocolUtils.isGeneric(generic);\n    }\n\n    public void setGeneric(Boolean generic) {\n        if (generic != null) {\n            this.generic = generic.toString();\n        }\n    }\n\n    @Override\n    @Parameter(key = Constants.REFERENCE_FILTER_KEY, append = true)\n    public String getFilter() {\n        return super.getFilter();\n    }\n\n    @Override\n    @Parameter(key = Constants.INVOKER_LISTENER_KEY, append = true)\n    public String getListener() {\n        return super.getListener();\n    }\n\n    @Override\n    public void setListener(String listener) {\n        checkMultiExtension(InvokerListener.class, \"listener\", listener);\n        super.setListener(listener);\n    }\n\n    @Parameter(key = Constants.LAZY_CONNECT_KEY)\n    public Boolean getLazy() {\n        return lazy;\n    }\n\n    @Override\n    public void setOnconnect(String onconnect) {\n        if (onconnect != null && onconnect.length() > 0) {\n            this.stubevent = true;\n        }\n        super.setOnconnect(onconnect);\n    }\n\n    @Override\n    public void setOndisconnect(String ondisconnect) {\n        if (ondisconnect != null && ondisconnect.length() > 0) {\n            this.stubevent = true;\n        }\n        super.setOndisconnect(ondisconnect);\n    }\n\n    @Parameter(key = Constants.STUB_EVENT_KEY)\n    public Boolean getStubevent() {\n        return stubevent;\n    }\n\n    @Parameter(key = Constants.RECONNECT_KEY)\n    public String getReconnect() {\n        return reconnect;\n    }\n\n    @Parameter(key = Constants.CLUSTER_STICKY_KEY)\n    public Boolean getSticky() {\n        return sticky;\n    }\n}\n```\n\n##### ProtocolConfig\n```java\npublic class ProtocolConfig extends AbstractConfig {\n\n    private static final long serialVersionUID = 6913423882496634749L;\n\n    /**\n     * 性能调优(必填dubbo)\n     * 协议名称\n     * \t<protocol>\n     */\n    private String name;\n\n    /**\n     * 服务发现(自动查找本机IP)\n     * 服务主机名，多网卡选择或指定VIP及域名时使用，为空则自动查找本机IP，-建议不要配置，让Dubbo自动获取本机IP\n     * host\n     */\n    private String host;\n\n    /**\n     * 服务端口\n     * dubbo协议缺省端口为20880,rmi协议缺省端口为1099,http 和hessian协议缺省端口为80\n     * 如果配置为-1 或者没有配置port，则会分配一个没有被占用的端口\n     * Dubbo 2.4.0+，分配的端口在协议缺省端口的基础上增长，确保端口段可控\n     * <port>\n     */\n    private Integer port;\n\n    /**\n     * 服务发现\n     * 提供者上下文路径，为服务path的前缀\n     * <path>\n     */\n    private String contextpath;\n\n    /**\n     * 性能调优（fixed）\n     * 线程池类型，可选：fixed/cached\n     * threadpool\n     */\n    private String threadpool;\n\n    /**\n     * 性能调优(100)\n     * 服务线程池大小(固定大小)\n     * threads\n     */\n    private Integer threads;\n\n    /**\n     * 性能调优(cpu个数+1)\n     * IO线程池大小（固定大小）\n     */\n    private Integer iothreads;\n\n    /**\n     * 性能调优(0)\n     * 线程池队列大小，当线程池满时，排队等待执行的队列大小，\n     * 建议不要设置，当线程程池时应立即失败，重试其它服务提供机器，而不是排队，除非有特殊需求\n     * queues\n     */\n    private Integer queues;\n\n    /**\n     * 性能调优(0)\n     * 服务提供方最大可接受连接数\n     * accepts \n     */\n    private Integer accepts;\n\n    /**\n     * 性能调优(dubbo)\n     * 协议编码方式\n     * codec\n     */\n    private String codec;\n\n    /**\n     * 性能调优(dubbo协议缺省为hessian2，rmi协议缺省为java，http协议 缺省为json)\n     * 协议序列化方式，当协议支持多种序列化方式时使用，比如：dubbo协议的dubbo,hessian2,java,compactedjava，以及http协议的json等\n     * serialization\n     */\n    private String serialization;\n\n    /**\n     * 序列化编码(UTF-8)\n     * charset\n     */\n    private String charset;\n\n    /**\n     * 性能调优(88388608(=8M))\n     * 请求及响应数据包大小限制，单位：字节\n     * payload\n     */\n    private Integer payload;\n\n    /**\n     * 性能调优(8192)\n     * 网络读写缓冲区大小\n     * buffer\n     */\n    private Integer buffer;\n\n    /**\n     * 性能调优（0）\n     * 心跳间隔，对于长连接，当物理层断开时，比如拔网线，TCP的FIN消息来不及发送，\n     * 对方收不到断开事件，此时需要心跳来帮助检查连接是否已断开\n     * heartbeat\n     */\n    private Integer heartbeat;\n\n    /**\n     * 服务治理\n     * 设为true，将向logger中输出访问日志，也可填写访问日志文件路径，直接把访问日志输出到指定文件\n     * accesslog\n     */\n    private String accesslog;\n\t\n    /**\n     * 性能调优(dubbo协议缺省为netty)\n     * 协议的服务端和客户端实现类型，比如：dubbo协议的mina,netty等，可以分拆为server和client配置\n     * transporter\n     */\n    private String transporter;\n\n    private String exchanger;\n\n    /**\n     * 性能(dubbo协议缺省为all)\n     * 协议的消息派发方式，用于指定线程模型，比如：dubbo协议的all,direct,message,execution,connection等\n     * dispatcher\n     */\n    private String dispatcher;\n\n    /**\n     * networker\n     */\n    private String networker;\n\n    /**\n     * 性能调优(dubbo协议缺省为netty，http协议缺省为servlet)\n     * 协议的服务器端实现类型，比如：dubbo协议的mina,netty等，http协议的jetty,servlet等\n     * server\n     */\n    private String server;\n\n    /**\n     * 性能调优(协议缺省为netty)\n     * 客户端实现\n     * client\n     */\n    private String client;\n\n    /**\n     * 服务治理\n     * 支持的telnet命令，逗号分隔\n     * telnet\n     */\n    private String telnet;\n\n    /**\n     * 命令行提示\n     */\n    private String prompt;\n\n    /**\n     * 状态检测\n     */\n    private String status;\n\n    /**\n     * 服务治理（true）\n     * 该协议的服务是否注册到注册中心\n     */\n    private Boolean register;\n\n    /**\n     * 是否长连接\n     * TODO add this to provider config\n     */\n    private Boolean keepAlive;\n\n    /**\n     * TODO add this to provider config\n     */\n    private String optimizer;\n\n    private String extension;\n\n    private Map<String, String> parameters;\n\n    private Boolean isDefault;\n  \n    /**\n     * 是否已经销毁\n     */\n    private static final AtomicBoolean destroyed = new AtomicBoolean(false);\n\n    public ProtocolConfig() {\n    }\n\n    public ProtocolConfig(String name) {\n        setName(name);\n    }\n\n    public ProtocolConfig(String name, int port) {\n        setName(name);\n        setPort(port);\n    }\n\n    @Parameter(excluded = true)\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        checkName(\"name\", name);\n        this.name = name;\n        if (id == null || id.length() == 0) {\n            id = name;\n        }\n    }\n\n    @Parameter(excluded = true)\n    public String getHost() {\n        return host;\n    }\n\n    @Parameter(excluded = true)\n    public Integer getPort() {\n        return port;\n    }\n\n    @Parameter(excluded = true)\n    public String getContextpath() {\n        return contextpath;\n    }\n\n    public void setContextpath(String contextpath) {\n        checkPathName(\"contextpath\", contextpath);\n        this.contextpath = contextpath;\n    }\n\n    public void setThreadpool(String threadpool) {\n        checkExtension(ThreadPool.class, \"threadpool\", threadpool);\n        this.threadpool = threadpool;\n    }\n\n    public void setCodec(String codec) {\n        if (\"dubbo\".equals(name)) {\n            checkMultiExtension(Codec.class, \"codec\", codec);\n        }\n        this.codec = codec;\n    }\n\n    public void setSerialization(String serialization) {\n        if (\"dubbo\".equals(name)) {\n            checkMultiExtension(Serialization.class, \"serialization\", serialization);\n        }\n        this.serialization = serialization;\n    }\n\n    public void setServer(String server) {\n        if (\"dubbo\".equals(name)) {\n            checkMultiExtension(Transporter.class, \"server\", server);\n        }\n        this.server = server;\n    }\n\n    public void setClient(String client) {\n        if (\"dubbo\".equals(name)) {\n            checkMultiExtension(Transporter.class, \"client\", client);\n        }\n        this.client = client;\n    }\n\n    public void setTelnet(String telnet) {\n        checkMultiExtension(TelnetHandler.class, \"telnet\", telnet);\n        this.telnet = telnet;\n    }\n\n    @Parameter(escaped = true)\n    public String getPrompt() {\n        return prompt;\n    }\n\n    public void setStatus(String status) {\n        checkMultiExtension(StatusChecker.class, \"status\", status);\n        this.status = status;\n    }\n\n    public void setTransporter(String transporter) {\n        checkExtension(Transporter.class, \"transporter\", transporter);\n        this.transporter = transporter;\n    }\n\n    public void setExchanger(String exchanger) {\n        checkExtension(Exchanger.class, \"exchanger\", exchanger);\n        this.exchanger = exchanger;\n    }\n\n    public void setDispatcher(String dispatcher) {\n        checkExtension(Dispatcher.class, \"dispacther\", dispatcher);\n        this.dispatcher = dispatcher;\n    }\n\n    public void destory() {\n        if (name != null) {\n\t    //获取Protocol扩展实例，然后调用destroy方法\n            ExtensionLoader.getExtensionLoader(Protocol.class)\n                    .getExtension(name)\n                    .destroy();\n        }\n    }\n}\n```\n##### ServiceConfig\n```java\npublic class ServiceConfig<T> extends AbstractServiceConfig {\n\n    /**\n     * 服务发现\n     * 服务接口名称\n     */\n    private String interfaceName;\n   \n    /**\n     * 服务接口类\n     */\n    private Class<?> interfaceClass;\n   \n    /**\n     * 服务发现(必填)\n     * 服务对象实现引用\n     */\n    private T ref;\n    \n    /**\n     * 服务发现(缺省为接口名)\n     * 服务路径(注意：1.0不支持自定义路径，总是使用接口名，如果有1.0调 2.0，配置服务路径可能不兼容\n     * <path>\n     */\n    private String path;\n    \n    /**\n     * 服务方法配置\n     */\n    private List<MethodConfig> methods;\n   \n    /**\n     * 提供者\n     */\n    private ProviderConfig provider;\n\n\n    /**\n     * 泛化接口\n     */\n    private volatile String generic;\n}\n\n```\n##### ReferenceConfig\n```java\npublic class ReferenceConfig<T> extends AbstractReferenceConfig {\n\n    /**\n     * 引用的接口名称\n     */\n    private String interfaceName;\n\n    /**\n     * 引用的接口类\n     */\n    private Class<?> interfaceClass;\n    \n    /**\n     * 客户端类型\n     */\n    private String client;\n    \n    /**\n     * 点对点调用url\n     */\n    private String url;\n    \n    /**\n     * 引用接口方法配置\n     */\n    private List<MethodConfig> methods;\n    \n    /**\n     * 默认配置\n     */\n    private ConsumerConfig consumer;\n    \n    /**\n     * 协议\n     */\n    private String protocol;\n\n    /**\n     * 接口代理引用\n     * interface proxy reference\n     */\n    private transient volatile T ref;\n\n    private transient volatile Invoker<?> invoker;\n\n    /**\n     * 是否已初始化\n     */\n    private transient volatile boolean initialized;\n\n    /**\n     * 是否已销毁\n     */\n    private transient volatile boolean destroyed;\n}\n```\n\n### 覆盖和优先级\n以timeout为例，这里按照优先级从高到低排列(retries,loadbalance, actives也应用相同的规则)：\n* 方法级别，接口级别，默认/全局级别\n* 相同的级别下，消费者比提供者有更高的优先级\n![](img/level.jpg)\n\n这一小节我们就先介绍到这里，下一小节开始介绍具体的解析逻辑。\n\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之Logger模块","url":"/blog/2018/07/31/Dubbo源码阅读之Logger模块/","content":">本文主要分析Dubbo是如何封装常用的日志框架的，以及在Dubbo中如何使用日志。\n\n在com.alibaba.dubbo.common.logger包中定义了如下几个和日志相关的类和接口：\n\n* Level枚举类\n* Logger接口\n* LoggerAdapter接口\n* LoggerFactory类\n\n### Level枚举类\n该枚举类从低到高定义了如下几个日志级别：\n```java\nALL,TRACE,DEBUG,INFO,WARN,ERROR,OFF\n```\n### Logger接口\n该接口定义了一些输出相应级别日志的方法，如：\n```JAVA\npublic interface Logger {\n\t//输出debug级别日志\n\tpublic void debug(Throwable e);\n\tpublic void debug(String msg, Throwable e);\n\tpublic boolean isDebugEnabled();\n\n\t//省略其他类似方法\n\t...\n}\n```\n### LoggerAdapter接口\n该接口为Logger提供者，定义了获取Logger、设置level级别、设置logger文件等方法,SPI注解我们后面的章节会详细介绍:\n```JAVA\n@SPI\npublic interface LoggerAdapter{\n    //获取Logger\n    Logger getLogger(Class<?> key);\n    //获取Logger\n    Logger getLogger(String key);\n    //获取当前logger日志级别\n    Level getLevel();\n    //设置当前logger级别\n    void setLevel(Level level);\n    //获取当前logger文件\n    File getFile();\n    //设置当前logger文件\n    void setFile(File file);\n}\n```\n### JdkLogger/JdkLoggerAdapter例子\n如果需要将日志框架集成到Dubbo中，需要实现上面定义的Logger接口和LoggerAdapter接口。\nDubbo默认已经集成了commons-logging、java.util.logging.Logger、org.apache.log4j.Logger、org.slf4j.Logger。\n作为例子，我们看下jdkLogger，其他的都类似。\n```JAVA\n//JdkLogger实现了Dubbo框架定义的Logger接口\npublic class JdkLogger implements Logger {\n\n    //持有java.util.logging.Logger实例\t\n    private final java.util.logging.Logger logger;\n\n    public JdkLogger(java.util.logging.Logger logger) {\n\t//构造方法，设置logger实例\n        this.logger = logger;\n    }\n\n    //实现了Logger接口中定义的方法\n    //都是委托给了java.util.logging.Logger实例来打印相应级别的日志\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.log(Level.INFO, msg, e);\n    }\n    \n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    } \n     \n    //省略其他类似方法\n    ...\n}\n\n//JdkLoggerAdapter实现了Dubbo框架定义的LoggerAdapter接口\npublic class JdkLoggerAdapter implements LoggerAdapter {\n\t\n\t//全局日志名称\n\tprivate static final String GLOBAL_LOGGER_NAME = \"global\";\n\t\n\t//存放日志的文件\n\tprivate File file;\n\t\t\n\t//该构造方法读取jdk日志配置文件logging.properties，设置日志文件file\n\tpublic JdkLoggerAdapter() {\n\t\ttry {\n\t\t    //获取jdk日志配置文件logging.properties\n\t\t    InputStream in = Thread.currentThread()\n\t\t\t    .getContextClassLoader()\n\t\t\t    .getResourceAsStream(\"logging.properties\");\n\t\t    if (in != null) {\n\t\t\t//读取配置\n\t\t\tLogManager.getLogManager().readConfiguration(in);\n\t\t    } else {\n\t\t\t//在classpath中没找到jdk日志配置文件logging.properties\n\t\t\tSystem.err.println(\"No such logging.properties in classpath for jdk logging config!\");\n\t\t    }\n\t\t} catch (Throwable t) {\n\t\t    System.err.println(\"Failed to load logging.properties in classpath for jdk logging config, cause: \" + t.getMessage());\n\t\t}\n\t\ttry {\n\t\t    //获取与此Logger关联的Handlers\n\t\t    Handler[] handlers =\n\t\t\t    java.util.logging.Logger.getLogger(GLOBAL_LOGGER_NAME)\n\t\t\t\t    .getHandlers();\n\t\t    for (Handler handler : handlers) {\n\t\t\tif (handler instanceof FileHandler) {\n\t\t\t    FileHandler fileHandler = (FileHandler) handler;\n\t\t\t    //通过反射找到files字段\n\t\t\t    Field field = fileHandler.getClass().getField(\"files\");\n\t\t\t    //获取fileHandler对象的field字段的值\n\t\t\t    File[] files = (File[]) field.get(fileHandler);\n\t\t\t    if (files != null && files.length > 0) {\n\t\t\t\t//设置file，即日志文件\n\t\t\t\tfile = files[0];\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t} catch (Throwable t) {\n\t\t}\n\t }\n\t\t\n\t //getLogger方法，返回一个JdkLogger对象，构造JdkLogger对象时传入了java.util.logging.Logger的Logger\n\t @Override\n\t public Logger getLogger(Class<?> key) {\n\t        //将最终使用的日志框架包装成了Dubbo的Logger对象\n\t\treturn new JdkLogger(java.util.logging.Logger.getLogger(key == null ? \"\" : key.getName()));\n\t }\n\n\t //返回日志文件\n\t @Override\n\t public File getFile() {\n\t\treturn file;\n\t }\n\n\t //获取日志级别\n\t @Override\n\t public Level getLevel() {\n\t        //这里通过fromJdkLevel方法将jdk的logger级别转换成了dubbo定义的level级别\n\t\treturn fromJdkLevel(java.util.logging.Logger.getLogger(GLOBAL_LOGGER_NAME).getLevel());\n\t }\n\n         //设置日志级别\n         @Override\n\t public void setLevel(Level level) {\n\t         //这里通过toJdkLevel方法将dubbo定义的level级别转换成了jdk的logger级别\n\t\tjava.util.logging.Logger.getLogger(GLOBAL_LOGGER_NAME).setLevel(toJdkLevel(level));\n\t }\n\n\t //fromJdkLevel和toJdkLevel方法比较简单，这里就不列出来了\n}\n```\n\n### LoggerFactory类\n该类是Logger工厂，定义了获取Logger的静态方法，需要使用日志时都是直接操作该类拿到Logger。\nLOGGERS和LOGGER_ADAPTER静态变量后面会介绍。\n```\npublic class LoggerFactory {\n\n    //缓存已创建Logger的类<类名称，该类对应的Logger>\n    private static final ConcurrentMap<String, FailsafeLogger> LOGGERS =\n            new ConcurrentHashMap<String, FailsafeLogger>();\n    \n    //当前使用的日志框架\n    private static volatile LoggerAdapter LOGGER_ADAPTER;\n}\n```\n例如在ScriptRouter类中，可以这样使用:\n```\npublic class ScriptRouter{\n\tprivate static final Logger logger = LoggerFactory.getLogger(ScriptRouter.class);\n\tpublic void error(){\n\t\tlogger.debug(\"route error , rule has been ignored\");\n\t}\n}\n```\n接下来，我们看下LoggerFactory中的getLogger方法定义：\n```java\npublic static Logger getLogger(Class<?> key) {\n        //根据name从LOGGERS缓存中获取FailsafeLogger\n        FailsafeLogger logger = LOGGERS.get(key.getName());\n        if (logger == null) {\n            //如果logger为空，则为类key创建一个FailsafeLogger，并放入缓存LOGGERS\n            LOGGERS.putIfAbsent(key.getName(), new FailsafeLogger(LOGGER_ADAPTER.getLogger(key)));\n            logger = LOGGERS.get(key.getName());\n        }\n        return logger;\n}\n```\n获取Logger时，我们是从LOGGERS变量中获取的，可见LOGGERS是用来缓存我们已创建的Logger对象的。\n而创建FailsafeLogger对象时，我们是根据key从LOGGER_ADAPTER变量中获取的Logger。\n由此可知，我们是通过LOGGER_ADAPTER变量(即LoggerAdapter接口)的getLogger(key)方法获取到了最终使用的日志框架，然后包装成了FailsafeLogger变量缓存起来。\n我们先来大概看下FailsafeLogger类的定义，然后在看下LOGGER_ADAPTER变量是在何时被赋值的。\n```java\npublic class FailsafeLogger implements Logger{\n\t\n     //包含了最终日志框架的logger\n     private Logger logger;\n\n     public FailsafeLogger(Logger logger) {\n        this.logger = logger;\n     }\n     \n     //在日志信息上附加dubbo上下文信息，如：dubbo版本、主机地址\n     private String appendContextMessage(String msg) {\n        return \" [DUBBO] \" + msg + \", dubbo version: \" + Version.getVersion() + \", current host: \" + NetUtils.getLocalHost();\n     }\n\n     @Override\n     public void info(String msg) {\n        try {\n\t    //输出附加了上下文信息的日志\n            logger.info(appendContextMessage(msg));\n        } catch (Throwable t) {\n        }\n     }\n\n     @Override\n     public boolean isInfoEnabled() {\n        try {\n            return logger.isInfoEnabled();\n        } catch (Throwable t) {\n            return false;\n        }\n     }\n     \n     //省略其他类似方法\n     ...\n}\n```\n我们在来看下LOGGER_ADAPTER变量是如何被赋值的，实际上，在LoggerFactory类初始化时，便会试着设置当前使用的日志框架：\n```java\nstatic {\n        //从JVM系统属性中获取配置的日志框架，即通过：java -Ddubbo.application.logger=slf4j配置\n        String logger = System.getProperty(\"dubbo.application.logger\");\n        if (\"slf4j\".equals(logger)) {\n            //如果是slf4j，则设置当前使用的日志框架为Slf4jLoggerAdapter\n            setLoggerAdapter(new Slf4jLoggerAdapter());\n        } else if (\"jcl\".equals(logger)) {\n            setLoggerAdapter(new JclLoggerAdapter());\n        } else if (\"log4j\".equals(logger)) {\n            setLoggerAdapter(new Log4jLoggerAdapter());\n        } else if (\"jdk\".equals(logger)) {\n            setLoggerAdapter(new JdkLoggerAdapter());\n        } else {\n            //如果没有匹配到，则挨个尝试可用的日志框架\n            try {\n                setLoggerAdapter(new Log4jLoggerAdapter());\n            } catch (Throwable e1) {\n                try {\n                    setLoggerAdapter(new Slf4jLoggerAdapter());\n                } catch (Throwable e2) {\n                    try {\n                        setLoggerAdapter(new JclLoggerAdapter());\n                    } catch (Throwable e3) {\n                        setLoggerAdapter(new JdkLoggerAdapter());\n                    }\n                }\n            }\n        }\n}\n\n//设置并修改当前使用的LoggerAdapter\npublic static void setLoggerAdapter(LoggerAdapter loggerAdapter) {\n        if (loggerAdapter != null) {\n            //首先获取LoggerFactory类的Logger\n            Logger logger = loggerAdapter.getLogger(LoggerFactory.class.getName());\n            //然后输出即将使用的logger：loggerAdapter\n            logger.info(\"using logger: \" + loggerAdapter.getClass().getName());\n            //设置LOGGER_ADAPTER变量为loggerAdapter\n            LoggerFactory.LOGGER_ADAPTER = loggerAdapter;\n            //遍历已创建logger的类列表，然后修改logger为新设置的loggerAdapter\n            for (Map.Entry<String, FailsafeLogger> entry : LOGGERS.entrySet()) {\n                //设置FailsafeLogger的logger为loggerAdapter创建的logger\n                entry.getValue().setLogger(LOGGER_ADAPTER.getLogger(entry.getKey()));\n            }\n        }\n}\n\n//获取当前日志级别\npublic static Level getLevel() {\n       //返回LOGGER_ADAPTER的日志级别\n       return LOGGER_ADAPTER.getLevel();\n}\n\n//设置当前日志级别\npublic static void setLevel(Level level) {\n       LOGGER_ADAPTER.setLevel(level);\n}\n\n//获取当前日志文件\npublic static File getFile() {\n        return LOGGER_ADAPTER.getFile();\n}\n```\n\n到此，我们就介绍完Dubbo-Logger相关的内容了，Dubbo作为常用的中间件，集成了可选的日志框架，是非常值得我们学习，最后，给一个类图加深下理解。\n\n![](img/log.png)\n\n\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之SPI扩展机制","url":"/blog/2018/07/31/Dubbo源码阅读之SPI扩展机制/","content":">本文主要分析Dubbo的SPI扩展机制。\n\n* [Java的SPI机制](https://docs.oracle.com/javase/1.5.0/docs/guide/jar/jar.html#Service%20Provider)\n* Dubbo的SPI机制\n\n### Java的SPI机制\nSPI全称为(Service Provider Interface)，是JDK内置的一种服务提供发现机制。通过SPI服务加载机制进行服务的注册和发现，可以实现基于接口的编程，避免在Java代码中写死服务的提供者，实现多个模块的解耦。\n根据Java的SPI规范，我们可以定义一个服务接口，具体的实现由对应的实现者（Service Provider服务提供者）提供，然后在使用的时候只要根据SPI的规范去获取对应的服务提供者的服务实现即可。我们看一个简单的例子：\n```java\npackage java.spi;\npublic interface Developer {\n    public String getPrograme();\n}\n\npackage java.spi;\npublic class JavaDeveloper implements Developer {\n    @Override\n    public String getPrograme() {\n        return \"Java\";\n    }\n}\n\npackage java.spi;\npublic class PerlDeveloper implements Developer {\n    @Override\n    public String getPrograme() {\n        return \"Perl\";\n    }\n}\n```\n然后在META-INF\\services目录下创建名为java.spi.Developer的文件，文件内容是接口实现类的全限定名：\n```java\njava.spi.JavaDeveloper\njava.spi.PerlDeveloper\n```\n将文件导出为jar包，新建一个项目，在项目中导入该jar,然后新建一个测试类：\n```java\nimport java.util.ServiceLoader;\nimport cn.edu.knowledge.spi.Developer;\npublic class Test {\n    public static void main(String[] arg) {\n         ServiceLoader<Developer> serviceLoader = ServiceLoader.load(Developer.class);\n\t for (Developer developer : Developer) {\n\t        //将会输出: I use Java; I use Perl;\n\t\tSystem.out.println(\"I use \"+developer.getPrograme());\n\t }\n    }\n}\n```\n\n### Dubbo的SPI机制\nDubbo的扩展点加载是对JDK内置的SPI机制的一种加强。继续使用上面的例子介绍，\nMETA-INF\\services\\java.spi.Developer文件中的内容将会变为key=value形式：\n```java\njava=java.spi.JavaDeveloper\nperl=java.spi.PerlDeveloper\n```\n其中，key为扩展名称，value为扩展实例。扩展配置文件修改为这样子是因为，如果扩展实现中的方法或者静态字段引用了第三方库，而第三方库不存在时，那么这个类将会初始化失败，在这种情况下，如果使用以前的格式，Dubbo不可以弄清楚扩展的id，因此不可以映射这个扩展的异常信息。\n例如：\n无法加载扩展(\"mina\"),当用户配置使用mina，Dubbo将会抱怨无法加载扩展，而不是报告提取哪一个扩展实现失败及原因。\n\n与Java标准SPI相比，Dubbo SPI又增加了如下功能：\n* Dubbo可以通过getExtension（String key）只加载某一个想要的扩展，Java的SPI机制则需要加载全部的实现类。\n* 对于扩展实现IOC依赖注入功能，如果扩展实现A含有setB()方法，而接口B有B1和B2两个具体的实现，此时Dubbo并不会具体注入B1或者B2，而是会注入一个自动生成的接口B实现：B$Adpative，该实现者能够根据参数的不同，自动引用B1或者B2来完成相应的功能。\n* 对扩展采用装饰器模式进行功能增强。\n\n### Dubbo SPI相关接口\n#### SPI接口\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE})\npublic @interface SPI {\n    //默认扩展名称\n    String value() default \"\";\n}\n```\n当接口上表明了@SPI注解时，Dubbo将会依次从如下目录中读取相应的扩展点：\nMETA-INF/dubbo/internal/\nMETA-INF/dubbo/\nMETA-INF/services/\n\n#### Adaptive接口\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD})\npublic @interface Adaptive {\n    String[] value() default {};\n}\n```\nExtensionLoader注入依赖扩展实例时，该接口为其提供了有用的信息。\nvalue方法决定要注入哪个目标扩展。目标扩展由URL中传递的参数决定，value方法提供了url上的参数名称。如果在URL中没有找到指定的参数名称，则将使用默认的扩展（在其接口上的@SPI注解中进行指定）。\n例如,给定字符串：value={\"key1\", \"key2\"}，如果在URL中发现参数key1，则使用参数key1的值作为扩展名称，如果在URL中没有发现参数key1或者参数key1的值为空，则尝试使用参数key2的值作为扩展名称，如果key2也不存在，则使用默认的扩展，否则抛异常。\n如果默认的扩展名称在@SPI注解中没有提供，则使用规则生成一个name，这个name将用作URL中的搜索参数。规则为：将接口类名从大写字符开始分成几个部分, 并将各部分用点 \".\" 分开。\n例如：com.alibaba.dubbo.xxx.YyyInvokerWrapper，则生成的name为yyy.invoker.wrapper，将会使用该name从url中进行搜索。\n\n#### Activate接口\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD})\npublic @interface Activate {\n    /**\n     * 当group数组中有一个group匹配时，就激活当前扩展。\n     * 将使用传递给ExtensionLoader#getActivateExtension(URL, String, String)方法的group(第三个参数)来和该注解的group进行匹配\n     */\n    String[] group() default {};\n\n    /**\n     * 当指定的key出现在URL的参数中时，则激活当前扩展 \n     * 例如：给定@Activate(\"cache, validation\")时，只有url中出现cache或者validation参数时，才会激活当前扩展\n     */\n    String[] value() default {};\n    \n    //相对顺序 扩展列表中的哪些扩展将要放到当前扩展前面\n    String[] before() default {};\n\n    //相对顺序 扩展列表中的哪些扩展将要放到当前扩展后面\n    String[] after() default {};\n    \n    //绝对顺序\n    int order() default 0;\n}\n```\n用于激活扩展。此注解对于使用给定条件自动激活某些扩展是非常有用的，比如：如果有多个Filter实现，@Activate可以用来加载某些Filter。\nSPI提供者可以调用ExtensionLoader#getActivateExtension(URL, String, String)方法找到所有符合条件的activated扩展。\n\n#### ExtensionFactory接口\n```\n@SPI\npublic interface ExtensionFactory {\n    /**\n     * 获取扩展实现类实例\n     * Get extension.\n     * @param type object type. 扩展接口类型\n     * @param name object name. 扩展名称\n     * @return object instance. 返回扩展实例\n     */\n    <T> T getExtension(Class<T> type, String name);\n}\n```\n该接口根据扩展类型和扩展名称获取扩展实例。可以看到该接口声明上也加上了@SPI注解，说明存在多种实现，Dubbo提供了三种实现，分别为AdaptiveExtensionFactory、SpiExtensionFactory、SpringExtensionFactory，后面会详细介绍具体实现。\n\n\n### ExtensionLoader类\nExtensionLoader类用来处理Dubbo扩展,里面定义了大量的实用方法，该类支持以下主要功能：\n\n* 自动注入依赖扩展\n* 在wrapper中，自动包装扩展\n* 默认扩展是一个adaptive实例\n\nExtensionLoader类代码量比较多，我们先来看下ExtensionLoader类的getExtensionLoader方法，通过该方法可以得到指定扩展类型接口的扩展加载器，\n例如我们想要得到ProxyFactory类型的ExtensionLoader，可以这样做：\n```java\nExtensionLoader<ProxyFactory> loader = ExtensionLoader.getExtensionLoader(ProxyFactory.class);\n```\n#### getExtensionLoader方法\n我们来看getExtensionLoader方法:\n```java\n/**\n * 获取扩展类型接口的扩展加载器\n * 1、校验扩展类型\n * 2、从缓存中获取扩展类型对应的扩展加载器\n * 3、缓存中不存在，则新建一个并放入缓存\n */\npublic static <T> ExtensionLoader<T> getExtensionLoader(Class<T> type) {\n        //扩展类型不可以为空\n        if (type == null) {\n            throw new IllegalArgumentException(\"Extension type == null\");\n        }\n\t//扩展类型必须为接口\n        if (!type.isInterface()) {\n            throw new IllegalArgumentException(\"Extension type(\" + type + \") is not interface!\");\n        }\n\t//检测扩展类型接口是否是一个扩展点，判断依据是：接口必须有@SPI注解\n        if (!withExtensionAnnotation(type)) {\n            throw new IllegalArgumentException(\"Extension type(\" + type +\n                    \") is not extension, because WITHOUT @\" + SPI.class.getSimpleName() + \" Annotation!\");\n        }\n        //首先从缓存中获取该扩展类型的ExtensionLoader\n        ExtensionLoader<T> loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);\n        if (loader == null) {\n            //缓存中不存在，则为扩展类型type新建一个ExtensionLoader，并放入缓存\n            EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader<T>(type));\n            loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);\n        }\n\t//返回扩展类型的ExtensionLoader\n        return loader;\n}\n\n/**\n * 私有构造方法\n */\nprivate ExtensionLoader(Class<?> type) {\n        //保存扩展类型接口\n        this.type = type;\n        //ExtensionFactory接口的扩展实现类不需要进行注入依赖，因此这里将objectFactory设置成null\n\t//其他扩展接口可能依赖其他扩展接口，因此需要进行依赖注入，通过objectFactory可以获取到某个扩展类型的扩展实例\n        objectFactory = (type == ExtensionFactory.class ? null :\n                    ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()\n        );\n}\n```\n其中type和objectFactory是ExtensionLoader类中定义的实例变量,EXTENSION_LOADERS缓存是静态常量：\n```java\n/**\n * 扩展接口的类型\n */\nprivate final Class<?> type;\n\n/**\n * 扩展工厂，通过扩展工厂可以获取到某个扩展类型的扩展实例\n */\nprivate final ExtensionFactory objectFactory;\n\n/**\n * 每个扩展类型接口(即带有@SPI注解的接口)，都有一个相对应的ExtensionLoader实例\n * <扩展类型接口，ExtensionLoader实例>\n */\nprivate static final ConcurrentMap<Class<?>, ExtensionLoader<?>> EXTENSION_LOADERS =\n\t\tnew ConcurrentHashMap<Class<?>, ExtensionLoader<?>>();\n```\n#### getExtension方法\n有了ExtensionLoader实例后，就可以通过该实例的getExtension(String name)方法加载扩展类型的指定实例：\n```java\n/**\n * 通过扩展名称name获取扩展实例\n */\npublic T getExtension(String name) {\n\t//扩展名称不可以为空\n        if (name == null || name.length() == 0) {\n            throw new IllegalArgumentException(\"Extension name == null\");\n        }\n        if (\"true\".equals(name)) {\n            //name = true 返回默认扩展实例（后面会分析该方法）\n            return getDefaultExtension();\n        }\n\t//根据扩展名称从cachedInstances实例变量中获取扩展实例\n\t//扩展实例被放入到Holder对象中，Holder类是一个持有值的助手类，提供了get/set方法\n        Holder<Object> holder = cachedInstances.get(name);\n        if (holder == null) {\n            //缓存中不存在的话，则为扩展名称name新建一个Holder实例。\n            cachedInstances.putIfAbsent(name, new Holder<Object>());\n            holder = cachedInstances.get(name);\n        }\n\t//从holder对象中获取到扩展名称name对应的扩展实例\n        Object instance = holder.get();\n        if (instance == null) {\n\t    //扩展实例为空，则为扩展名称name新建一个扩展实例并放入Holder对象中。\n\t    //这里可能会存在多个线程同时访问，因此需要同步创建扩展实例\n            synchronized (holder) {\n\t        //再次判断holder对象中的扩展实例是否为空\n                instance = holder.get();\n                if (instance == null) {\n                    //根据扩展名称name创建扩展实例（后面会分析该方法）\n                    instance = createExtension(name);\n\t\t    //放入缓存\n                    holder.set(instance);\n                }\n            }\n        }\n\t//返回扩展实例\n        return (T) instance;\n}\n```\n在看getDefaultExtension方法和createExtension方法之前，我们先看下上面getExtension方法中出现的变量定义：\n```java\n/**\n * 缓存 <扩展名称，扩展实例>\n */\nprivate final ConcurrentMap<String, Holder<Object>> cachedInstances =\n    new ConcurrentHashMap<String, Holder<Object>>();\n\n/**\n * 持有一个值的助手类\n */\npublic class Holder<T> {\n\n    private volatile T value;\n\n    public void set(T value) {\n        this.value = value;\n    }\n    public T get() {\n        return value;\n    }\n}\n```\n#### getDefaultExtension方法\n接下来我们来看getDefaultExtension方法，该方法用来获取默认扩展实例。在该方法内部又调用了多个方法，我们一步步来分析，分析完整个流程后，我们在看createExtension方法.\n```java\n/**\n * 返回默认扩展实例，如果没有配置默认扩展名称(@SPI注解上配置的)，则返回null\n */\npublic T getDefaultExtension() {\n        //获取扩展接口type对应的扩展实现类集合(后面会分析该方法)\n\tgetExtensionClasses();\n\t//判断cachedDefaultName变量是否为空\n\t//cachedDefaultName变量是在getExtensionClasses()方法中进行赋值的，我们稍后去看\n\tif (null == cachedDefaultName || cachedDefaultName.length() == 0 || \"true\".equals(cachedDefaultName)) {\n\t\treturn null;\n\t}\n\t//获取默认扩展名称对应的扩展实例\n\treturn getExtension(cachedDefaultName);\n}\n```\n#### getExtensionClasses方法(加载扩展实现类)\n```java\n/**\n * 获取扩展接口type对应的扩展实现类集合，先从缓存获取，缓存没有的话，再去重新加载\n * @return\n */\nprivate Map<String, Class<?>> getExtensionClasses() {\n\t//先从cachedClasses缓存中获取\n\tMap<String, Class<?>> classes = cachedClasses.get();\n\tif (classes == null) {\n\t\t//缓存中为空，同步加载\n\t\tsynchronized (cachedClasses) {\n\t\t\t//再次判断\n\t\t\tclasses = cachedClasses.get();\n\t\t\tif (classes == null) {\n\t\t\t\t//重新加载扩展实现类（后面会分析该方法）\n\t\t\t\tclasses = loadExtensionClasses();\n\t\t\t\t//放入缓存\n\t\t\t\tcachedClasses.set(classes);\n\t\t\t}\n\t\t}\n\t}\n\treturn classes;\n}\n\n/**\n * 默认扩展名称,@SPI注解上配置的值\n */\nprivate String cachedDefaultName;\n\n/**\n * 用来缓存扩展接口type对应的所有扩展实现类\n * <扩展名称，扩展实现类>\n */\nprivate final Holder<Map<String, Class<?>>> cachedClasses = new Holder<Map<String, Class<?>>>();\n\n\n/**\n * 加载扩展接口type对应的所有扩展实现类\n * 在getExtensionClasses中会进行同步\n * synchronized in getExtensionClasses\n * @return\n */\nprivate Map<String, Class<?>> loadExtensionClasses() {\n\t//获取扩展接口type上的@SPI注解\n\tfinal SPI defaultAnnotation = type.getAnnotation(SPI.class);\n\tif (defaultAnnotation != null) {\n\t\t//存在@SPI注解，则获取注解值(即默认扩展名称)\n\t\tString value = defaultAnnotation.value();\n\t\tif ((value = value.trim()).length() > 0) {\n\t\t\t//使用逗号分隔扩展名称\n\t\t\tString[] names = NAME_SEPARATOR.split(value);\n\t\t\tif (names.length > 1) {\n\t\t\t    //存在多个默认扩展名称，则抛异常\n\t\t\t    throw new IllegalStateException(\"more than 1 default extension name on extension \" + type.getName()\n\t\t\t\t    + \": \" + Arrays.toString(names));\n\t\t\t}\n\t\t\tif (names.length == 1) {\n\t\t\t    //保存默认扩展名称到cachedDefaultName\n\t\t\t    cachedDefaultName = names[0];\n\t\t\t}\n\t\t}\n\t}\n\t//开始加载扩展类，依次从3个目录进行加载,保存到extensionClasses中\n\tMap<String, Class<?>> extensionClasses = new HashMap<String, Class<?>>();\n\t//目录看下面的常量定义(后面会分析该方法)\n\tloadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY);\n\tloadDirectory(extensionClasses, DUBBO_DIRECTORY);\n\tloadDirectory(extensionClasses, SERVICES_DIRECTORY);\n\treturn extensionClasses;\n}\n\n/**\n * 扩展所在目录\n */\nprivate static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n\nprivate static final String DUBBO_DIRECTORY = \"META-INF/dubbo/\";\n\nprivate static final String DUBBO_INTERNAL_DIRECTORY = DUBBO_DIRECTORY + \"internal/\";\n\n/**\n * 获取ExtensionLoader的类加载器\n * @return\n */\nprivate static ClassLoader findClassLoader() {\n\treturn ExtensionLoader.class.getClassLoader();\n}\n\n/**\n * 扫描相应目录，加载扩展并保存到extensionClasses集合\n * @param extensionClasses 保存扩展类的Map集合\n * @param dir  扫描目录\n */\nprivate void loadDirectory(Map<String, Class<?>> extensionClasses, String dir) {\n\t//待加载的文件名，如：fileName = META-INF/dubbo/internal/com.alibaba.dubbo.rpc.ProxyFactory\n\tString fileName = dir + type.getName();\n\ttry {\n\t    Enumeration<java.net.URL> urls;\n\t    //获取ExtensionLoader类加载器(后面会分析该方法)\n\t    ClassLoader classLoader = findClassLoader();\n\t    if (classLoader != null) {\n\t\t//当前类加载器不为空，加载该文件\n\t\turls = classLoader.getResources(fileName);\n\t    } else {\n\t\t//当前类加载器为空，则从用来加载类的搜索路径中查找改文件\n\t\turls = ClassLoader.getSystemResources(fileName);\n\t    }\n\t    if (urls != null) {\n\t\twhile (urls.hasMoreElements()) {\n\t\t    //获取到资源定位符\n\t\t    java.net.URL resourceURL = urls.nextElement();\n\t\t    //加载资源,即读取并解析配置文件，然后加载类(后面会分析该方法)\n\t\t    loadResource(extensionClasses, classLoader, resourceURL);\n\t\t}\n\t    }\n\t} catch (Throwable t) {\n\t    logger.error(\"Exception when load extension class(interface: \" +\n\t\t    type + \", description file: \" + fileName + \").\", t);\n\t}\n}\n\n/**\n * 解析配置文件，然后加载扩展类\n * @param extensionClasses 保存扩展类的集合\n * @param classLoader  类加载器\n * @param resourceURL  资源定位符\n */\nprivate void loadResource(Map<String, Class<?>> extensionClasses, ClassLoader classLoader, java.net.URL resourceURL) {\n\ttry {\n\t    BufferedReader reader = new BufferedReader(new InputStreamReader(resourceURL.openStream(), \"utf-8\"));\n\t    try {\n\t\tString line;\n\t\t//读取配置文件每一行\n\t\twhile ((line = reader.readLine()) != null) {\n\t\t    //判断当前行是否包含#号，#号后面的内容都是注释，需要去掉\n\t\t    final int ci = line.indexOf('#');\n\t\t    if (ci >= 0) {\n\t\t\t//截取#号之前的内容，并重新设置line\n\t\t\tline = line.substring(0, ci);\n\t\t    }\n\t\t    line = line.trim();\n\t\t    if (line.length() > 0) {\n\t\t\ttry {\n\t\t\t    String name = null;\n\t\t\t    //当前行是否包含=号\n\t\t\t    int i = line.indexOf('=');\n\t\t\t    if (i > 0) {\n\t\t\t\t//当前行存在=号，则使用=号分隔line，获取到key-value(line)\n\t\t\t\t//name就是key，即定义的扩展名称\n\t\t\t\t//line就是value，即定义的扩展实现类全限定名\n\t\t\t\tname = line.substring(0, i).trim();\n\t\t\t\tline = line.substring(i + 1).trim();\n\t\t\t    }\n\t\t\t    //如果line不等于空，则需要加载该扩展实现类\n\t\t\t    if (line.length() > 0) {\n\t\t\t\t//加载扩展实现类(后面会分析该方法)\n\t\t\t\tloadClass(\n\t\t\t\t\textensionClasses,\n\t\t\t\t\tresourceURL,\n\t\t\t\t\t//加载扩展实现类\n\t\t\t\t\tClass.forName(line, true, classLoader),\n\t\t\t\t\tname\n\t\t\t\t);\n\t\t\t    }\n\t\t\t} catch (Throwable t) {\n\t\t\t    IllegalStateException e = new IllegalStateException(\"Failed to load extension class(interface: \" + type + \", class line: \" + line + \") in \" + resourceURL + \", cause: \" + t.getMessage(), t);\n\t\t\t    //解析行出错，记录错误行到exceptions实例变量中\n\t\t\t    exceptions.put(line, e);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    } finally {\n\t\treader.close();\n\t    }\n\t} catch (Throwable t) {\n\t    logger.error(\"Exception when load extension class(interface: \" +\n\t\t    type + \", class file: \" + resourceURL + \") in \" + resourceURL, t);\n\t}\n}\n\n/**\n * 保存解析配置文件发生的异常信息\n * <当前key-value行，异常信息>\n */\nprivate Map<String, IllegalStateException> exceptions = new ConcurrentHashMap<String, IllegalStateException>();\n\n/**\n * 当前扩展类型接口type对应的扩展自适应类\n * 即存在@Adaptive注解的扩展实现类\n * 每个扩展类型接口type只能有一个实现类有@Adaptive注解，如果多个扩展实现类都有@Adaptive，则会抛异常\n */\nprivate volatile Class<?> cachedAdaptiveClass = null;\n\n/**\n * 如果扩展实现类是一个包装类，\n * 则会将该该实现类添加到cachedWrapperClasses集合中\n */\nprivate Set<Class<?>> cachedWrapperClasses;\n\n/**\n * 扩展名称正则表达式，将会使用该正则表达式切割扩展名称name，即使用逗号分隔\n */\nprivate static final Pattern NAME_SEPARATOR = Pattern.compile(\"\\\\s*[,]+\\\\s*\");\n\n/**\n * 缓存<扩展名称，Activate注解>\n * 如果是逗号分隔的多个name，则取第1个扩展名称name\n * Activate为当前扩展实现类上的@Activate注解\n */\nprivate final Map<String, Activate> cachedActivates = new ConcurrentHashMap<String, Activate>();\n\n/**\n * 缓存<扩展实现类，扩展名称>\n */\nprivate final ConcurrentMap<Class<?>, String> cachedNames = new ConcurrentHashMap<Class<?>, String>();\n\n\n/**\n * 加载扩展实现类\n * @param extensionClasses 保存扩展实现类的map\n * @param resourceURL 资源文件定位符\n * @param clazz 扩展实现类，即实现了type接口的类\n * @param name  扩展名称，即配置文件中的key\n * @throws NoSuchMethodException\n */\nprivate void loadClass(Map<String, Class<?>> extensionClasses,\n\t\t   java.net.URL resourceURL,\n\t\t   Class<?> clazz,\n\t\t   String name) throws NoSuchMethodException {\n\t//检测实现类clazz是否是type的子类型，即clazz是否实现了接口type\n\tif (!type.isAssignableFrom(clazz)) {\n\t    throw new IllegalStateException(\"Error when load extension class(interface: \" +\n\t\t    type + \", class line: \" + clazz.getName() + \"), class \"\n\t\t    + clazz.getName() + \"is not subtype of interface.\");\n\t}\n\t//检测实现类clazz是否有@Adaptive注解\n\tif (clazz.isAnnotationPresent(Adaptive.class)) {\n\t    if (cachedAdaptiveClass == null) {\n\t        //cachedAdaptiveClass变量为空，则将cachedAdaptiveClass赋值为clazz\n\t\tcachedAdaptiveClass = clazz;\n\t    } else if (!cachedAdaptiveClass.equals(clazz)) {\n\t        //cachedAdaptiveClass变量不为空，则判断cachedAdaptiveClass是否和当前实现类class是否是同一个\n\t\t//如果不是同一个，则抛异常：每个扩展类型type不可以存在多个自适应扩展类\n\t\tthrow new IllegalStateException(\"More than 1 adaptive class found: \"\n\t\t\t+ cachedAdaptiveClass.getClass().getName()\n\t\t\t+ \", \" + clazz.getClass().getName());\n\t    }\n\t} else if (isWrapperClass(clazz)) {\n\t    //实现类clazz是包装类(后面会分析该方法)\n\t    Set<Class<?>> wrappers = cachedWrapperClasses;\n\t    if (wrappers == null) {\n\t\tcachedWrapperClasses = new ConcurrentHashSet<Class<?>>();\n\t\twrappers = cachedWrapperClasses;\n\t    }\n\t    //将该扩展实现类添加到包装类集合中\n\t    wrappers.add(clazz);\n\t} else {\n\t    //检测该实现类是否有默认构造方法\n\t    clazz.getConstructor();\n\t    if (name == null || name.length() == 0) {\n\t\t//扩展名称name为空时，则根据规则重新设置name(后面会分析该方法)\n\t\tname = findAnnotationName(clazz);\n\t\tif (name == null || name.length() == 0) {\n\t\t    //name仍然为空\n\t\t    if (clazz.getSimpleName().length() > type.getSimpleName().length()\n\t\t\t    && clazz.getSimpleName().endsWith(type.getSimpleName())) {\n\t\t\t//如果当前扩展实现类的类名以扩展接口type的名称结尾，则截取接口类名称之前的部分作为name，并转换成小写\n\t\t\t//例如：当clazz = JavassistProxyFactory，type = ProxyFactory时，则name = javassist\n\t\t\tname = clazz.getSimpleName().substring(0, clazz.getSimpleName().length() - type.getSimpleName().length()).toLowerCase();\n\t\t    } else {\n\t\t\t//扩展实现类class没有对应的扩展名称，抛异常\n\t\t\tthrow new IllegalStateException(\"No such extension name for the class \" + clazz.getName() + \" in the config \" + resourceURL);\n\t\t    }\n\t\t}\n\t    }\n\t    //使用逗号分隔扩展名称name\n\t    String[] names = NAME_SEPARATOR.split(name);\n\t    if (names != null && names.length > 0) {\n\t        //获取扩展实现类上的@Activate注解\n\t\tActivate activate = clazz.getAnnotation(Activate.class);\n\t\tif (activate != null) {\n\t\t    //存在@Activate注解\n\t\t    //则将第1个扩展名称和@Activate注解缓存起来\n\t\t    cachedActivates.put(names[0], activate);\n\t\t}\n\t\t//遍历扩展名称\n\t\tfor (String n : names) {\n\t\t    if (!cachedNames.containsKey(clazz)) {\n\t\t\t//如果<扩展实现类,name>缓存中不包含该扩展实现类,则保存到缓存\n\t\t\tcachedNames.put(clazz, n);\n\t\t    }\n\t\t    //通过扩展名称n从扩展实现类集合中获取扩展实现类c\n\t\t    Class<?> c = extensionClasses.get(n);\n\t\t    if (c == null) {\n\t\t\t//扩展实现类c不存在，则保存<扩展名称n，扩展实现类clazz>到缓存\n\t\t\textensionClasses.put(n, clazz);\n\t\t    } else if (c != clazz) {\n\t\t\t//一个扩展名称对应多个扩展实现类，则抛异常\n\t\t\tthrow new IllegalStateException(\"Duplicate extension \" + type.getName() + \" name \" + n + \" on \" + c.getName() + \" and \" + clazz.getName());\n\t\t    }\n\t\t}\n\t    }\n\t}\n}\n\n/**\n * 检测扩展实例类clazz是否是包装类。\n * 判断依据是：扩展实现类clazz中有一个接收扩展接口(type接口)作为参数的构造方法\n * @param clazz 扩展实现类\n * @return\n */\nprivate boolean isWrapperClass(Class<?> clazz) {\n\ttry {\n\t    clazz.getConstructor(type);\n\t    return true;\n\t} catch (NoSuchMethodException e) {\n\t    return false;\n\t}\n}\n```\n加载扩展类型接口type对应的扩展实现类流程到此就全部结束了(即上文中介绍的getExtensionClasses()方法流程)。\n\n#### createExtension方法(创建扩展实现类实例)\n我们回到上文中遗留的createExtension(name)方法，看看是如何根据扩展名称name创建扩展实现类实例的。\n```java\n/**\n * 根据扩展名称name创建扩展实现类实例\n * @param name 扩展名称\n * @return 扩展实现类实例\n */\n@SuppressWarnings(\"unchecked\")\nprivate T createExtension(String name) {\n\t//根据扩展名称name获取扩展实现类clazz\n\t//getExtensionClasses()方法我们上文已经介绍过了，拿到扩展类型接口type对应的所有扩展实现类\n\tClass<?> clazz = getExtensionClasses().get(name);\n\tif (clazz == null) {\n\t    //根据扩展名称没有获取到扩展实现类，则抛出异常\n\t    throw findException(name);\n\t}\n\ttry {\n\t    //先从缓存中获取扩展实现类的实例\n\t    T instance = (T) EXTENSION_INSTANCES.get(clazz);\n\t    if (instance == null) {\n\t        //如果没有获取到实例，则新建一个实现类clazz的实例并放入缓存。\n\t\tEXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());\n\t\tinstance = (T) EXTENSION_INSTANCES.get(clazz);\n\t    }\n\t    //处理实现类实例的依赖注入(后面会分析该方法)\n\t    injectExtension(instance);\n\t    //处理包装类\n\t    Set<Class<?>> wrapperClasses = cachedWrapperClasses;\n\t    if (wrapperClasses != null && !wrapperClasses.isEmpty()) {\n\t        //当前扩展接口type存在包装类扩展实现类\n\t\t//遍历包装类列表\n\t\tfor (Class<?> wrapperClass : wrapperClasses) {\n\t\t    //通过参数为type接口的构造方法创建包装类实例(将当前实例instance传递进去)，然后处理包装类的依赖注入\n\t\t    //这里可能会有多个包装类，依次进行包装\n\t\t    instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));\n\t\t}\n\t    }\n\t    //返回扩展实例\n\t    return instance;\n\t} catch (Throwable t) {\n\t    throw new IllegalStateException(\"Extension instance(name: \" + name + \", class: \" +\n\t\t    type + \")  could not be instantiated: \" + t.getMessage(), t);\n\t}\n}\n\n/**\n * 处理扩展实现类实例instance的依赖项，进行依赖注入\n * 通过set方法注入依赖项\n * @param instance 扩展实现类的实例\n * @return\n */\nprivate T injectExtension(T instance) {\n\ttry {\n\t    //判断加载器是否为空\n\t    if (objectFactory != null) {\n\t        //遍历实现类中的方法\n\t\tfor (Method method : instance.getClass().getMethods()) {\n\t\t    //找到参数长度为1、public修饰符的set方法\n\t\t    if (method.getName().startsWith(\"set\")\n\t\t\t    && method.getParameterTypes().length == 1\n\t\t\t    && Modifier.isPublic(method.getModifiers())) {\n\t\t\t//获取set方法的参数类型\n\t\t\tClass<?> pt = method.getParameterTypes()[0];\n\t\t\ttry {\n\t\t\t    //截取set方法的方法名，去掉\"set\"字符，并将余下的字符转换成小写字母，作为属性\n\t\t\t    String property = method.getName().length() > 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : \"\";\n\t\t\t    //从扩展工厂中找到该依赖项实例(pt为依赖项的类型，property为依赖项的名称)\n\t\t\t    Object object = objectFactory.getExtension(pt, property);\n\t\t\t    if (object != null) {\n\t\t\t\t//依赖项实例存在的话，通过该set方法则将该依赖项实例注入到扩展实现类实例instance中\n\t\t\t\tmethod.invoke(instance, object);\n\t\t\t    }\n\t\t\t} catch (Exception e) {\n\t\t\t    logger.error(\"fail to inject via method \" + method.getName()\n\t\t\t\t    + \" of interface \" + type.getName() + \": \" + e.getMessage(), e);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t} catch (Exception e) {\n\t    logger.error(e.getMessage(), e);\n\t}\n\t//返回扩展实现类的实例\n\treturn instance;\n}\n```\n以上便是获取扩展实例的过程，最终会将扩展实例放入到缓存变量cachedInstances中,即<扩展名称，扩展实例>。\n\n#### getActivateExtension方法\n接下来我们在看下ExtensionLoader类中的getActivateExtension方法，通过该方法可以得到已启用的扩展列表\n```java\n/**\n * key为url中标识扩展名称的参数\n */\npublic List<T> getActivateExtension(URL url, String key) {\n\t//调用了下面的重载方法\n\treturn getActivateExtension(url, key, null);\n}\n\npublic List<T> getActivateExtension(URL url, String key, String group) {\n\t//从url中获取参数key对应的值(即获取扩展名称)\n\tString value = url.getParameter(key);\n\t//调用了下面的重载方法\n\treturn getActivateExtension(\n\t\turl, \n\t\tvalue == null || value.length() == 0 ? null : Constants.COMMA_SPLIT_PATTERN.split(value), \n\t\tgroup\n\t);\n}\n\n/**\n * 获取已启用的扩展列表\n * url \n * values为扩展名称列表\n * group为配置的组\n */\npublic List<T> getActivateExtension(URL url, String[] values, String group) {\n\tList<T> exts = new ArrayList<T>();\n\t//扩展名称数组\n\tList<String> names = values == null ? new ArrayList<String>(0) : Arrays.asList(values);\n\t//names是否包含-default\n\tif (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) {\n\t    //先获取下扩展接口type的扩展实现类集合(上文介绍过该方法)\n\t    //执行getExtensionClasses方法时，会将存在@Activate注解的实现类缓存起来：<扩展名称，Activate注解>\n\t    getExtensionClasses();\n\t    //遍历cachedActivates集合\n\t    for (Map.Entry<String, Activate> entry : cachedActivates.entrySet()) {\n\t\t//扩展名称\n\t\tString name = entry.getKey();\n\t\t//@Activate注解\n\t\tActivate activate = entry.getValue();\n\t\t//group是否匹配(后面会分析该方法)\n\t\tif (isMatchGroup(group, activate.group())) {\n\t\t    //根据扩展名称name获取扩展实例\n\t\t    T ext = getExtension(name);\n\t\t    if (!names.contains(name)\n\t\t\t    && !names.contains(Constants.REMOVE_VALUE_PREFIX + name)\n\t\t\t    && isActive(activate, url)) {\n\t\t\t//当扩展名称数组不包含该扩展名name，并且不包含-name，并且已激活时，\n\t\t\t//将当前扩展实例添加到返回结果集中\n\t\t\texts.add(ext);\n\t\t    }\n\t\t}\n\t    }\n\t    //按照配置的before()和after()/order()进行排序\n\t    Collections.sort(exts, ActivateComparator.COMPARATOR);\n\t}\n\tList<T> usrs = new ArrayList<T>();\n\tfor (int i = 0; i < names.size(); i++) {\n\t    //当前扩展名称name\n\t    String name = names.get(i);\n\t    if (!name.startsWith(Constants.REMOVE_VALUE_PREFIX)\n\t\t    //当前扩展名称name不是以-开头，并且扩展名称数组names不包含-name时，\n\t\t    && !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) {\n\t\tif (Constants.DEFAULT_KEY.equals(name)) {\n\t\t    //当前扩展名称name=default\n\t\t    if (!usrs.isEmpty()) {\n\t\t        //usrs不为空，将usrs集合添加到exts头部\n\t\t\texts.addAll(0, usrs);\n\t\t\t//清空usrs\n\t\t\tusrs.clear();\n\t\t    }\n\t\t} else {\n\t\t    //当前扩展名称name != default时，获取该name的扩展实例，并存起来\n\t\t    T ext = getExtension(name);\n\t\t    usrs.add(ext);\n\t\t}\n\t    }\n\t}\n\tif (!usrs.isEmpty()) {\n\t    exts.addAll(usrs);\n\t}\n\treturn exts;\n}\n\n/**\n * group是否匹配\n * 1、group为空，则匹配\n * 2、group在groups中存在，则匹配\n * @param group\n * @param groups @Activate中配置的group数组\n * @return\n */\nprivate boolean isMatchGroup(String group, String[] groups) {\n\tif (group == null || group.length() == 0) {\n\t    return true;\n\t}\n\tif (groups != null && groups.length > 0) {\n\t    for (String g : groups) {\n\t\tif (group.equals(g)) {\n\t\t    return true;\n\t\t}\n\t    }\n\t}\n\treturn false;\n}\n/**\n * 是否已激活\n * 1、@activate没有配置value()\n * 2、@Activate中配置的value()在url的参数列表中存在,且url参数对应的value不为空\n * @param activate\n * @param url\n * @return\n */\nprivate boolean isActive(Activate activate, URL url) {\n        //获取@Activate注解中配置的keys\n\tString[] keys = activate.value();\n\tif (keys.length == 0) {\n\t    return true;\n\t}\n\tfor (String key : keys) {\n\t    for (Map.Entry<String, String> entry : url.getParameters().entrySet()) {\n\t\tString k = entry.getKey();\n\t\tString v = entry.getValue();\n\t\tif ((k.equals(key) || k.endsWith(\".\" + key))\n\t\t\t&& ConfigUtils.isNotEmpty(v)) {\n\t\t    return true;\n\t\t}\n\t    }\n\t}\n\treturn false;\n}\n```\n\n#### getAdaptiveExtension方法\n接下来看下getAdaptiveExtension方法，该方法用来获取扩展接口type对应的自适应扩展实例。\n```java\n\n/**\n * 缓存的自适应实例\n */\nprivate final Holder<Object> cachedAdaptiveInstance = new Holder<Object>();\n\n/**\n * 记录创建自适应扩展实例时发生的异常\n */\nprivate volatile Throwable createAdaptiveInstanceError;\n\n\n/**\n * 获取扩展接口type的自适应扩展实例\n */\npublic T getAdaptiveExtension() {\n\t//先从缓存中获取\n\tObject instance = cachedAdaptiveInstance.get();\n\tif (instance == null) {\n\t    //缓存中不存在\n\t    //判断createAdaptiveInstanceError变量是否为空，不为空说明之前创建自适应实例时发生了异常\n\t    if (createAdaptiveInstanceError == null) {\n\t        //没有发生异常，同步创建自适应扩展实例\n\t\tsynchronized (cachedAdaptiveInstance) {\n\t\t    //再次验证缓存中是否存在该实例\n\t\t    instance = cachedAdaptiveInstance.get();\n\t\t    if (instance == null) {\n\t\t\ttry {\n\t\t\t    //创建自适应扩展实例(后面会分析该方法)\n\t\t\t    instance = createAdaptiveExtension();\n\t\t\t    //将创建好的实例保存进缓存\n\t\t\t    cachedAdaptiveInstance.set(instance);\n\t\t\t} catch (Throwable t) {\n\t\t\t    //创建实例时发生异常，记录异常\n\t\t\t    createAdaptiveInstanceError = t;\n\t\t\t    throw new IllegalStateException(\"fail to create adaptive instance: \" + t.toString(), t);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    } else {\n\t\tthrow new IllegalStateException(\"fail to create adaptive instance: \" + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);\n\t    }\n\t}\n\treturn (T) instance;\n}\n\n/**\n * 为扩展接口type创建自适应扩展实例，并处理依赖注入\n * @return\n */\nprivate T createAdaptiveExtension() {\n\ttry {\n\t    //在这里调用了getAdaptiveExtensionClass方法获取到自适应扩展类，然后生成实例\n\t    return injectExtension((T) getAdaptiveExtensionClass().newInstance());\n\t} catch (Exception e) {\n\t    throw new IllegalStateException(\"Can not create adaptive extension \" + type + \", cause: \" + e.getMessage(), e);\n\t}\n}\n\n/**\n * 获取扩展接口type的自适应扩展类\n * @return\n */\nprivate Class<?> getAdaptiveExtensionClass() {\n        //加载扩展接口type对应的所有扩展实现类(上文介绍过该方法)\n\tgetExtensionClasses();\n\t//查看缓存中是否已经存在扩展接口type对应的自适应扩展类，如果存在，则直接返回(调用getExtensionClasses方法时，会去设置cachedAdaptiveClass值)\n\tif (cachedAdaptiveClass != null) {\n\t    return cachedAdaptiveClass;\n\t}\n\t//不存在的话，为该扩展接口type创建一个自适应扩展类(后面会分析该方法)\n\treturn cachedAdaptiveClass = createAdaptiveExtensionClass();\n}\n\n/**\n * 扩展接口type不存在自适应扩展类的时候，dubbo默认会为其创建\n * 创建条件：type接口的方法中必须有一个带@Adaptive注解的方法dubbo才会创建自适应扩展类\n * @return\n */\nprivate Class<?> createAdaptiveExtensionClass() {\n\t//生成自适应扩展实现类的代码(后面会分析该方法)\n\tString code = createAdaptiveExtensionClassCode();\n\t//获取类加载器\n\tClassLoader classLoader = findClassLoader();\n\t//获取Compiler自适应扩展实例\n\tcom.alibaba.dubbo.common.compiler.Compiler compiler =\n\t\tExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class)\n\t\t\t.getAdaptiveExtension();\n\t//编译code(后面会分析该方法)\n\treturn compiler.compile(code, classLoader);\n}\n```\n\n接下来的createAdaptiveExtensionClassCode方法比较长，在分析之前，我们先来看下ProxyFactory接口，我们将使用该接口作为例子(即假设当前扩展接口type为ProxyFactory),配合着该方法一起看：\n```java\n@SPI(\"javassist\")\npublic interface ProxyFactory {\n    \n    //@Adaptive({\"proxy\"})\n    @Adaptive({Constants.PROXY_KEY})\n    <T> T getProxy(Invoker<T> invoker) throws RpcException;\n   \n    @Adaptive({Constants.PROXY_KEY})\n    <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException;\n```\n可以看到该接口上添加了@SPI(\"javassist\")注解、接口方法上添加了@Adaptive({Constants.PROXY_KEY})\n\n```java\n/**\n* 为扩展接口type生成自适应扩展类的类代码\n* 假设 type = com.alibaba.dubbo.rpc.ProxyFactory\n* @return\n*/\nprivate String createAdaptiveExtensionClassCode() {\n\tStringBuilder codeBuilder = new StringBuilder();\n\t//获取扩展接口type的方法列表，查看方法上是否存在@Adaptive注解，\n\t//如果不存在@Adaptive注解，则不用生成自适应扩展类\n\tMethod[] methods = type.getMethods();\n\tboolean hasAdaptiveAnnotation = false;\n\tfor (Method m : methods) {\n\t    if (m.isAnnotationPresent(Adaptive.class)) {\n\t\thasAdaptiveAnnotation = true;\n\t\tbreak;\n\t    }\n\t}\n\t// 不存在带有@Adaptive注解的方法，因此不需要生成自适应扩展类\n\tif (!hasAdaptiveAnnotation) {\n\t    throw new IllegalStateException(\"No adaptive method on extension \" + type.getName() + \", refuse to create the adaptive class!\");\n\t}\n\t//添加包声明：type扩展接口所在包包名\n\t//package com.alibaba.dubbo.rpc;\n\tcodeBuilder.append(\"package \").append(type.getPackage().getName()).append(\";\");\n\n\t//import com.alibaba.dubbo.common.extension.ExtensionLoader;\n\tcodeBuilder.append(\"\\nimport \").append(ExtensionLoader.class.getName()).append(\";\");\n\t\n\t//可以看到生成的实现类名称为ProxyFactory$Adaptive，实现了ProxyFactory接口\n\t//public class com.alibaba.dubbo.rpc.ProxyFactory$Adaptive implements com.alibaba.dubbo.rpc.ProxyFactory{\n\tcodeBuilder.append(\"\\npublic class \")\n\t\t.append(type.getSimpleName())\n\t\t.append(\"$Adaptive\")\n\t\t.append(\" implements \")\n\t\t.append(type.getCanonicalName()).append(\" {\");\n\n\t//遍历type接口的方法\n\tfor (Method method : methods) {\n\t    //接口方法返回类型\n\t    Class<?> rt = method.getReturnType();\n\t    //接口方法参数类型数组\n\t    Class<?>[] pts = method.getParameterTypes();\n\t    //接口方法异常类型数组\n\t    Class<?>[] ets = method.getExceptionTypes();\n\t   \n\t    //判断当前方法上是否存在@Adaptive注解\n\t    Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class);\n            //方法内容\n\t    StringBuilder code = new StringBuilder(512);\n\t    if (adaptiveAnnotation == null) {\n\t\t//添加异常：type接口的当前方法不是一个adaptive方法\n\t\tcode.append(\"throw new UnsupportedOperationException(\\\"method \")\n\t\t\t.append(method.toString()).append(\" of interface \")\n\t\t\t.append(type.getName()).append(\" is not adaptive method!\\\");\");\n\t    } else {\n\t\t//获取到的当前方法的\"URL类型参数/返回URL类型的get方法的参数\"的下标（在当前方法参数中的下标）\n\t\tint urlTypeIndex = -1;\n\t\t//遍历当前方法参数\n\t\tfor (int i = 0; i < pts.length; ++i) {\n\t\t    if (pts[i].equals(URL.class)) {\n\t\t        //第i个下标是URL类型的参数\n\t\t\turlTypeIndex = i;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (urlTypeIndex != -1) {\n\t\t    //从当前方法参数中找到了URL类型的参数\n\t\t    //添加\"校验Url类型参数是否为空\"的code\n\t\t    String s = String.format(\"\\nif (arg%d == null) throw new IllegalArgumentException(\\\"url == null\\\");\",\n\t\t\t    urlTypeIndex);\n\t\t    code.append(s);\n\t\t    \n\t\t    //添加\"声明url类型的变量\"的code\n\t\t    //URL url = arg{$urlTypeIndex}\n\t\t    s = String.format(\"\\n%s url = arg%d;\", URL.class.getName(), urlTypeIndex);\n\t\t    code.append(s);\n\t\t}else {\n\t\t    //从当前方法参数中没有找到URL类型的参数\n\t\t    //返回URL类型的get方法的名称\n\t\t    String attribMethod = null;\n\n\t\t    //遍历参数列表，查询每个参数的方法列表，查找返回URL类型的get方法\n\t\t    LBL_PTS:\n\t\t    //遍历当前方法参数\n\t\t    for (int i = 0; i < pts.length; ++i) {\n\t\t\t//遍历方法第i个参数的所有方法\n\t\t\tMethod[] ms = pts[i].getMethods();\n\t\t\tfor (Method m : ms) {\n\t\t\t    //当前方法名\n\t\t\t    String name = m.getName();\n\t\t\t    //当前方法没有参数，且返回值是URL类型，以get开头或者长度>3,且是public修饰，没有static修饰\n\t\t\t    if ((name.startsWith(\"get\") || name.length() > 3)\n\t\t\t\t    && Modifier.isPublic(m.getModifiers())\n\t\t\t\t    && !Modifier.isStatic(m.getModifiers())\n\t\t\t\t    && m.getParameterTypes().length == 0\n\t\t\t\t    && m.getReturnType() == URL.class) {\n\t\t\t\t//方法的第i个参数是\"返回URL类型的get方法\"\n\t\t\t\turlTypeIndex = i;\n\t\t\t\t//“返回URL类型的get方法的名称”\n\t\t\t\tattribMethod = name;\n\t\t\t\t//跳转到LBL_PTS\n\t\t\t\tbreak LBL_PTS;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (attribMethod == null) {\n\t\t\t//没有找到返回URL类型的方法，抛异常\n\t\t\tthrow new IllegalStateException(\"fail to create adaptive class for interface \" + type.getName()\n\t\t\t\t+ \": not found url parameter or url attribute in parameters of method \" + method.getName());\n\t\t    }\n\t\t\t\n\t\t    //添加“方法第urlTypeIndex个参数为空的判断”\n\t\t    String s = String.format(\"\\nif (arg%d == null) throw new IllegalArgumentException(\\\"%s argument == null\\\");\",\n\t\t\t    urlTypeIndex, pts[urlTypeIndex].getName());\n\t\t    code.append(s);\n\t\t\t\n\t\t    //添加“方法第urlTypeIndex个参数的attribMethod方法的返回值为空的判断”\n\t\t    s = String.format(\"\\nif (arg%d.%s() == null) throw new IllegalArgumentException(\\\"%s argument %s() == null\\\");\",\n\t\t\t    urlTypeIndex, attribMethod, pts[urlTypeIndex].getName(), attribMethod);\n\t\t    code.append(s);\n\n\t\t    //添加：com.alibaba.dubbo.common.URL url = arg{$urlTypeIndex}.attribMethod();\n\t\t    s = String.format(\"%s url = arg%d.%s();\", URL.class.getName(), urlTypeIndex, attribMethod);\n\t\t    code.append(s);\n\t\t}\n\t\t//@Adaptive注解的value值\n\t\tString[] value = adaptiveAnnotation.value();\n\t\tif (value.length == 0) {\n\t\t    //没有设置value，则根据扩展接口名称按照一定规则生成value\n\t\t    //如：ProxyFactory 将生成value：proxy.factory\n\t\t    //则charArray = [P,r,o,x,y,F,a,c,t,o,r,y]\n\t\t    char[] charArray = type.getSimpleName().toCharArray();\n\t\t    StringBuilder sb = new StringBuilder(128);\n\t\t    for (int i = 0; i < charArray.length; i++) {\n\t\t\tif (Character.isUpperCase(charArray[i])) {\n\t\t\t    //当前字符是大写的\n\t\t\t    if (i != 0) {\n\t\t\t        //当前字符不是第1个字符，则添加“.”到sb中\n\t\t\t\tsb.append(\".\");\n\t\t\t    }\n\t\t\t    //将当前字符转为小写，并添加到sb中\n\t\t\t    sb.append(Character.toLowerCase(charArray[i]));\n\t\t\t} else {\n\t\t\t    //当前字符是小写的，直接添加到sb中\n\t\t\t    sb.append(charArray[i]);\n\t\t\t}\n\t\t    }\n\t\t    //生成的value = [{\"proxy.factory\"}]\n\t\t    value = new String[]{sb.toString()};\n\t\t}\n\t\t//当前方法中是否存在Invocation类型的参数\n\t\tboolean hasInvocation = false;\n\t\tfor (int i = 0; i < pts.length; ++i) {\n\t\t    //当前方法的第i个参数名称是否为“com.alibaba.dubbo.rpc.Invocation”\n\t\t    if (pts[i].getName().equals(\"com.alibaba.dubbo.rpc.Invocation\")) {\n\t\t\t//添加\"校验参数Invocation是否为空\"的code\n\t\t\tString s = String.format(\"\\nif (arg%d == null) throw new IllegalArgumentException(\\\"invocation == null\\\");\", i);\n\t\t\tcode.append(s);\n\t\t\t//添加\"获取方法名\"的code\n\t\t\ts = String.format(\"\\nString methodName = arg%d.getMethodName();\", i);\n\t\t\tcode.append(s);\n\t\t\t//标识 存在Invocation类型的参数\n\t\t\thasInvocation = true;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t//@SPI注解上配置的值，默认扩展名称\n\t\tString defaultExtName = cachedDefaultName;\n\t\tString getNameCode = null;\n\t\t//遍历@Adaptive注解的value数组\n\t\tfor (int i = value.length - 1; i >= 0; --i) {\n\t\t    if (i == value.length - 1) {\n\t\t        //当前i为value的最后1个元素\n\t\t\tif (null != defaultExtName) {\n\t\t\t    //默认扩展名称不为空，如果没有获取到值，则会使用默认值\n\t\t\t    //第i个元素是否等于protocol\n\t\t\t    if (!\"protocol\".equals(value[i])) {\n\t\t\t\tif (hasInvocation) {\n\t\t\t\t    //存在Invocation类型的参数\n\t\t\t\t    //调用url的getMethodParameter方法，获取value[i]对应的扩展名，如果为空，则取默认扩展名defaultExtName\n\t\t\t\t    getNameCode = String.format(\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName);\n\t\t\t\t} else {\n\t\t\t\t    //不存在Invocation类型的参数\n\t\t\t\t    //从url的value[i]参数中(当前例子为proxy)获取扩展名，如果没有获取到，则使用默认扩展名javassist\n\t\t\t\t    //url.getParameter(\"proxy\",\"javassist\")\n\t\t\t\t    getNameCode = String.format(\"url.getParameter(\\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName);\n\t\t\t\t}\n\t\t\t    } else {\n\t\t\t        //第i个元素等于protocol\n\t\t\t\t//从url中获取protocol属性值，如果没有获取到，则使用默认扩展名defaultExtName\n\t\t\t\tgetNameCode = String.format(\"( url.getProtocol() == null ? \\\"%s\\\" : url.getProtocol() )\", defaultExtName);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    //默认扩展名称为空，如果没有获取到值，则不会使用默认值\n\t\t\t    if (!\"protocol\".equals(value[i])) {\n\t\t\t\tif (hasInvocation) {\n\t\t\t\t    getNameCode = String.format(\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName);\n\t\t\t\t} else {\n\t\t\t\t    //从url中获取参数value[i]对应的值\n\t\t\t\t    getNameCode = String.format(\"url.getParameter(\\\"%s\\\")\", value[i]);\n\t\t\t\t}\n\t\t\t    } else {\n\t\t\t        //从url中获取protocol属性值\n\t\t\t\tgetNameCode = \"url.getProtocol()\";\n\t\t\t    }\n\t\t\t}\n\t\t    } else {\n\t\t        //当前第i个元素不是value最后一个元素\n\t\t\tif (!\"protocol\".equals(value[i])) {\n\t\t\t    if (hasInvocation) {\n\t\t\t\tgetNameCode = String.format(\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName);\n\t\t\t    } else {\n\t\t\t\tgetNameCode = String.format(\"url.getParameter(\\\"%s\\\", %s)\", value[i], getNameCode);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    getNameCode = String.format(\"url.getProtocol() == null ? (%s) : url.getProtocol()\", getNameCode);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\t\n\t\t//添加：String extName = url.getParameter(\"proxy\", \"javassist\");\n\t\t//获取扩展名\n\t\tcode.append(\"\\nString extName = \").append(getNameCode).append(\";\");\n\t\t\n\t\t//添加“校验扩展名不为空”的code\n\t\tString s = String.format(\"\\nif(extName == null) \" +\n\t\t\t\t\"throw new IllegalStateException(\\\"Fail to get extension(%s) name from url(\\\" + url.toString() + \\\") use keys(%s)\\\");\",\n\t\t\ttype.getName(), Arrays.toString(value));\n\t\tcode.append(s);\n\n\t\t//添加\"根据扩展名获取扩展实例\"的code\n\t\t//com.alibaba.dubbo.rpc.ProxyFactory extension = (com.alibaba.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.ProxyFactory.class).getExtension(extName) ;\n\t\ts = String.format(\"\\n%s extension = (%<s)%s.getExtensionLoader(%s.class).getExtension(extName);\",\n\t\t\ttype.getName(), ExtensionLoader.class.getSimpleName(), type.getName());\n\t\tcode.append(s);\n\n\t\t//处理返回值\n\t\tif (!rt.equals(void.class)) {\n\t\t    //返回值不是void类型\n\t\t    code.append(\"\\nreturn \");\n\t\t}\n\n\t\t//例如：return extension.getInvoker(arg0);\n\t\t//这里的逻辑就是：根据扩展名称的不同获取相应的扩展实现，然后调用方法，并返回\n\t\ts = String.format(\"extension.%s(\", method.getName());\n\t\t//先填写调用信息\n\t\tcode.append(s);\n\t\t\n\t\t//遍历当前方法参数，添加方法参数\n\t\tfor (int i = 0; i < pts.length; i++) {\n\t\t    if (i != 0) {\n\t\t\tcode.append(\", \");\n\t\t    }\n\t\t    code.append(\"arg\").append(i);\n\t\t}\n\t\tcode.append(\");\");\n\t    }\n\n\t    //生成方法签名code\n\t    //如：public java.lang.Object getProxy(com.alibaba.dubbo.rpc.Invoker arg0) throws com.alibaba.dubbo.rpc.RpcException\n\t    codeBuilder.append(\"\\npublic \")\n\t\t    .append(rt.getCanonicalName())\n\t\t    .append(\" \")\n\t\t    .append(method.getName())\n\t\t    .append(\"(\");\n\n            //添加参数\n\t    for (int i = 0; i < pts.length; i++) {\n\t\tif (i > 0) {\n\t\t    codeBuilder.append(\", \");\n\t\t}\n\t\tcodeBuilder.append(pts[i].getCanonicalName());\n\t\tcodeBuilder.append(\" \");\n\t\tcodeBuilder.append(\"arg\").append(i);\n\t    }\n\t    codeBuilder.append(\")\");\n\n\t    //添加异常\n\t    if (ets.length > 0) {\n\t\tcodeBuilder.append(\" throws \");\n\t\tfor (int i = 0; i < ets.length; i++) {\n\t\t    if (i > 0) {\n\t\t\tcodeBuilder.append(\", \");\n\t\t    }\n\t\t    codeBuilder.append(ets[i].getCanonicalName());\n\t\t}\n\t    }\n\t   \n\t    codeBuilder.append(\" {\");\n\t     //将方法code添加到方法代码块中\n\t    codeBuilder.append(code.toString());\n\t    codeBuilder.append(\"\\n}\");\n\t}\n\tcodeBuilder.append(\"\\n}\");\n\tif (logger.isDebugEnabled()) {\n\t    logger.debug(codeBuilder.toString());\n\t}\n\t//返回生产的code\n\treturn codeBuilder.toString();\n}\n```\n以type = com.alibaba.dubbo.rpc.ProxyFactory为例子，生成的代码大概如下所示:\n```java\npackage com.alibaba.dubbo.rpc;\nimport com.alibaba.dubbo.common.extension.ExtensionLoader;\n\npublic class ProxyFactory$Adaptive implements com.alibaba.dubbo.rpc.ProxyFactory {\n\n    public java.lang.Object getProxy(com.alibaba.dubbo.rpc.Invoker arg0) throws com.alibaba.dubbo.rpc.RpcException {\n\t if (arg0 == null){\n\t    throw new IllegalArgumentException(\"com.alibaba.dubbo.rpc.Invoker argument == null\");\n\t }\n\t if (arg0.getUrl() == null) {\n\t    throw new IllegalArgumentException(\"com.alibaba.dubbo.rpc.Invoker argument getUrl() == null\");\n\t }\n\t com.alibaba.dubbo.common.URL url = arg0.getUrl();\n\t String extName = url.getParameter(\"proxy\", \"javassist\");\n\t if(extName == null) {\n\t    throw new IllegalStateException(\"Fail to get extension(com.alibaba.dubbo.rpc.ProxyFactory) name from url(\" + url.toString() + \") use keys([proxy])\");\n\t }\n\t com.alibaba.dubbo.rpc.ProxyFactory extension = (com.alibaba.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.ProxyFactory.class).getExtension(extName);\n\t return extension.getProxy(arg0);\n    }\n\n    public com.alibaba.dubbo.rpc.Invoker getInvoker(java.lang.Object arg0, java.lang.Class arg1, com.alibaba.dubbo.common.URL arg2) throws com.alibaba.dubbo.rpc.RpcException {\n\tif (arg2 == null) {\n\t    throw new IllegalArgumentException(\"url == null\");\n\t}\n\tcom.alibaba.dubbo.common.URL url = arg2;\n\tString extName = url.getParameter(\"proxy\", \"javassist\");\n\tif(extName == null){\n\t    throw new IllegalStateException(\"Fail to get extension(com.alibaba.dubbo.rpc.ProxyFactory) name from url(\" + url.toString() + \") use keys([proxy])\");\n\t}\n\tcom.alibaba.dubbo.rpc.ProxyFactory extension = (com.alibaba.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.ProxyFactory.class).getExtension(extName);\n\treturn extension.getInvoker(arg0, arg1, arg2);\n    }\n}\n```\n以上就是生成自适应实现类的全部内容，生成好代码后，会交由Compiler扩展进行编译得到Class对象，然后在本小节开头介绍的createAdaptiveExtension()方法中进行实例化，并进行依赖注入。\n本文内容过多，Compiler编译的部分就放到后面的博文中在介绍了。另外ExtensionLoader类中也提供了很多辅助方法，内容比较简单，在这里就不详细介绍了。\n\n### ExtensionFactory工厂实现\n```\n@SPI\npublic interface ExtensionFactory {\n    /**\n     * 获取扩展实现类实例\n     * Get extension.\n     * @param type object type. 扩展接口类型\n     * @param name object name. 扩展名称\n     * @return object instance. 返回扩展实例\n     */\n    <T> T getExtension(Class<T> type, String name);\n}\n```\n该接口根据扩展类型和扩展名称获取扩展实例。可以看到该接口声明上也加上了@SPI注解，说明存在多种实现，Dubbo提供了三种实现，分别为AdaptiveExtensionFactory、SpiExtensionFactory、SpringExtensionFactory.\n\n#### SpringExtensionFactory\n```java\npublic class SpringExtensionFactory implements ExtensionFactory {\n\n    /**\n     * 保存所有的ApplicationContext上下文对象\n     */\n    private static final Set<ApplicationContext> contexts = new ConcurrentHashSet<ApplicationContext>();\n\n    /**\n     * 添加ApplicationContext\n     */\n    public static void addApplicationContext(ApplicationContext context) {\n        contexts.add(context);\n    }\n\n    /**\n     * 移除ApplicationContext\n     */\n    public static void removeApplicationContext(ApplicationContext context) {\n        contexts.remove(context);\n    }\n\n    @Override\n    public <T> T getExtension(Class<T> type, String name) {\n        //遍历所有的context\n        for (ApplicationContext context : contexts) {\n            //判断该context上下文是否包含此bean\n            if (context.containsBean(name)) {\n                //根据名称获取context中的bean\n                Object bean = context.getBean(name);\n                //判断该bean是否是type类型的实例，如果是的话，则返回该bean\n                if (type.isInstance(bean)) {\n                    return (T) bean;\n                }\n            }\n        }\n        return null;\n    }\n}\n```\n\n#### SpiExtensionFactory\n\n```java\npublic class SpiExtensionFactory implements ExtensionFactory {\n\n    @Override\n    public <T> T getExtension(Class<T> type, String name) {\n        //判断类型type是否是接口，并且存在@SPI注解\n        if (type.isInterface() && type.isAnnotationPresent(SPI.class)) {\n            //获取扩展接口type的扩展加载器\n            ExtensionLoader<T> loader = ExtensionLoader.getExtensionLoader(type);\n\t    //通过扩展加载器获取接口type支持的所有扩展的名称列表\n            if (!loader.getSupportedExtensions().isEmpty()) {\n                //返回自适应扩展实例\n                return loader.getAdaptiveExtension();\n            }\n        }\n        return null;\n    }\n}\n```\n\n#### AdaptiveExtensionFactory\n该ExtensionFactory实现存在@Adaptive注解，因此它是自适应实现。\n\n```java\n@Adaptive\npublic class AdaptiveExtensionFactory implements ExtensionFactory {\n\n    /**\n     * ExtensionFactory扩展实现类实例集合\n     */\n    private final List<ExtensionFactory> factories;\n\n    public AdaptiveExtensionFactory() {\n        //获取ExtensionFactory.class对应的扩展加载器\n        ExtensionLoader<ExtensionFactory> loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);\n        \n        List<ExtensionFactory> list = new ArrayList<ExtensionFactory>();\n        \n        //遍历扩展接口ExtensionFactory支持的扩展名称列表(spi、spring)\n        for (String name : loader.getSupportedExtensions()) {\n            //根据扩展名称name加载扩展实现类实例\n            list.add(loader.getExtension(name));\n        }\n        factories = Collections.unmodifiableList(list);\n    }\n\n    /**\n     * 自适应的扩展工厂，挨个遍历spring和spi，从中查询指定类型的实例\n     * @param type object type. 扩展接口类型\n     * @param name object name. 扩展名称\n     * @param <T>\n     * @return\n     */\n    @Override\n    public <T> T getExtension(Class<T> type, String name) {\n        //遍历ExtensionFactory实现类集合，从中挨个查找指定类型的扩展\n        for (ExtensionFactory factory : factories) {\n            //获取type类型的扩展实例\n            T extension = factory.getExtension(type, name);\n            if (extension != null) {\n               //实例不为空，返回实例 \n               return extension;\n            }\n        }\n        return null;\n    }\n}\n```\n\n到此，关于SPI的实现就全部介绍完了，下一小节将会介绍和Sping集成相关的内容。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["dubbo"]},{"title":"Spring注解之@Import注解","url":"/blog/2018/07/30/Spring注解之-Import注解/","content":">本小节介绍Spring提供的@Import注解\n\n* @Import注解的作用\n* @Import注解的定义\n* @Import注解的使用\n\n### @Import注解的作用\n表示要导入1个或多个@Configuration配置类。提供了与Spring XML中的<import/>元素等效的作用.\n@Import注解允许我们使用导入的方式将实例添加到Spring BeanFactory中.允许我们导入@Configuration类、ImportSelector接口和ImportBeanDefinitionRegistrar接口的实现类,类似于AnnotationConfigApplicationContext类的register方法。\n\n### @Import注解的定义\n可以看到该注解只可以使用在类上.\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Import {\n\t/**\n\t * {@link Configuration}, {@link ImportSelector}, {@link ImportBeanDefinitionRegistrar}\n\t * or regular component classes to import.\n\t */\n\tClass<?>[] value();\n}\n```\n### @Import注解的使用\n\n接下来，我们分别介绍这三种使用方式,我们先创建一些测试类和测试方法:\n```java\npackage org.dubbo.import;\npublic class A{}\n\npublic class B{}\n\npublic class C{}\n\npublic class D{}\n\n//测试方法\npublic static void main(String args[]){\n   //创建配置上下文\n   AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\n   //注册当前配置 Bean\n   context.register(DubboConfiguration.class);\n   context.refresh();\n   \n   //获取所有已注册的beanNames\n   String[] beanNames = context.getBeanDefinitionNames();\n   for(String beanName : beanNames){\n       //输出beanNames\n       System.out.println(\"beanName -> \"+ beanName);\n   }\n}\n```\n\n#### Configuration方式\n```java\n@Import({A.class,B.class})\n@Configuration\npublic class DubboConfig{} \n```\n执行测试方法，将会输出：\n```java\nbeanName -> DubboConfig\nbeanName -> org.dubbo.import.A\nbeanName -> org.dubbo.import.B\n```\n\n#### 实现ImportSelector接口方式\n```java\n/**\n * ImportSelector实现类\n */\npublic class DubboImportSelector implements ImportSelector{\n    public String[] selectImports(AnnotationMetadata metadata) {\n        return new String[]{\"org.dubbo.import.C\"};\n    }\n}\n\n/**\n * 修改配置\n */\n@Import({A.class,B.class,DubboImportSelector.class})\n@Configuration\npublic class DubboConfig{}\n```\n\n执行测试方法，将会输出：\n```java\nbeanName -> DubboConfig\nbeanName -> org.dubbo.import.A\nbeanName -> org.dubbo.import.B\nbeanName -> org.dubbo.import.C\n```\n\n#### 实现ImportBeanDefinitionRegistrar接口方式\n\n```java\n/**\n *\n * ImportBeanDefinitionRegistrar实现类\n */\npublic class DubboImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar{\n    \n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata metadata,BeanDefinitionRegistry registry) {\n        //创建一个D类的rootBeanDefinition对象\n        RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(D.class);\n        //注册beanName=d的bean\n        registry.registerBeanDefinition(\"d\", rootBeanDefinition);\n    }\n}\n\n/**\n * 修改配置\n */\n@Import({A.class,B.class,DubboImportSelector.class,DubboImportBeanDefinitionRegistrar.class})\n@Configuration\npublic class DubboConfig{}\n```\n\n然后执行测试方法，将会输出：\n```java\nbeanName -> DubboConfig\nbeanName -> org.dubbo.import.A\nbeanName -> org.dubbo.import.B\nbeanName -> org.dubbo.import.C\nbeanName -> org.dubbo.import.D\n```\n\n可以看到，我们成功将A/B/C/D添加到了BeanFactory中.\n","tags":["spring"]},{"title":"自己动手实现Idea插件","url":"/blog/2018/07/29/自己动手实现Idea插件/","content":">在阅读开源项目源代码的时候，会时常一起读作者写的注释来理解代码的意图，对于英文不好的码农来说实在是比较吃力，或者当我们在写代码的时候，为了一个变量名称纠结半天时，都会需要一个强大的词典来支持我们的工作，用有道词典的话，启动过慢、电脑太卡、来回切换屏幕会感觉很不爽还好Idea提供了强大的插件扩展能力，能让我们在集成开发环境中嵌入翻译引擎，当然只要有足够的想象力，可以在Idea集成环境中开发各种插件，自定义自己的开发环境，比如下面的炫酷插件\n![](img/1.gif)\n本文就向大家介绍一下如何开发一个Idea翻译插件。\n首先，打开Idea集成开发环境，然后新建一个Idea plugin项目：\n![](img/2.jpg)\n然后输入项目名称，以及项目位置，并点击Finish按钮完成创建：\n![](img/3.jpg)\n创建好项目以后，结构如下图：\n![](img/4.jpg)\n然后我们在src目录下创建一个easy.form的包，并在该包路径下创建一个名称为TranslationForm的 GUI Form：\n![](img/5.jpg)\n![](img/6.jpg)\n此时，Idea会自动帮我们生成一个TranslationForm.form文件和一个TranslationForm类。我们可以通过在TranslationForm.form文件中拖拽组件迅速构建一个配置面板（玩过Visual Studio的童鞋一定对这个功能很熟悉了），与此同时，Idea会自动在TranslationForm类中生成相应的组件元素：\n![](img/7.jpg)\n在这里，我们新创建了一个主面板JPanel，然后在该面板下创建了6个子元素JRadioButton单选按钮，以及一个标签JLabel。现在挑一个单选按钮讲解下，其他的都类似：\n![](img/8.jpg)\nButton Group选项是定义一个按钮组，我们这里定义了一个engineGroup的按钮组，用来对按钮进行归组。field name选项就是将要在TranslationForm类中动态创建的变量名称，text就是显示的文本，selected标识是否默认选中，enabled标识是否启用，这里只简单设置了这几个选项，还有其他丰富的选项，有兴趣的童鞋可以自行研究尝试。\n接下来我们看下我们的TranslationForm类：\n![](img/9.jpg)\n可以看到Idea为我们的各个组件元素都自动生成相对应的变量，同时，我们也自定义了一个selectValue变量（用来保存当前值）和currentSelectButton变量（用来保存当前选中的按钮），再来看下该类中的方法：\n![](img/10.jpg)\n在构造函数中，我们定义了一个监听器用来监听当前用户选择的选项，并保存起来，后文会用到。\n组件开发完毕,我们再来看下配置。\n如何让Idea能够保存起来我们的配置，以便下次启动时能够自动加载用户相应的配置，其实，刚创建完项目后，在resources/META-INF/目录下会生成一个plugin.xml文件：\n![](img/11.jpg)\n![](img/12.jpg)\n![](img/13.jpg)\n在extensions标签下，我们指定了实例easy.config.TranslationConfig类以及实现实现类easy.config.TranslationSetting，该实现类就是用来管理我们的配置信息的。在application-components标签下，我们定义了easy.idea.MyPluginRegistration实现类，Idea组件是插件整合的基础概念，有三种组件类型：application-level、project-level和module-level。 Application-level组件在IDEA启动时就被创建并初始化。在action标签下的add-to-group中的group-id很重要，它指定了你的插件在整个idea界面上的入口，这个值可以指定的很多（比如代码区域的右键菜单、编辑器顶部的菜单）。action节点中重要的是class和text，class是指定插件的入口action，一般情况下，一个插件定义一个就行了，相当于main函数吧，而text是指定插件的具体的名称，就是点击这个text然后执行class指定的类。\n我们先来看下MyPluginRegistration类，在这里我们简单的注册了我们的ToChineseAction类：\n![](img/14.jpg)\n我们再来看下TranslationSetting类，该类实现了PersistentStateComponent接口，这样组件的状态将会自动保存和加载：\n![](img/15.jpg)\n我们指定了@State和@Storage注解，这样组件的状态将会保存到一个XML文件中。在该类我们定义了一个engine的变量，用来保存当前用户选择的翻译引擎（谷歌、欧米等），同时提供了getState方法、loadState方法来设置获取配置。其中Constant.ELEMENT_NAME就是\"TranslationSetting\"，Constant.ELEMENT_ATTR_NAME就是\"engine\"，是我们自己定义的变量。\n\n我们再来看下TranslationConfig类：\n![](img/16.jpg)\n在该类中，我们定义了TranslationForm类和TranslationSetting类的变量。isModified方法是用来判断选项是否被修改过（如：我们是否更换了翻译引擎）。getDisplayName是在配置面板上显示的名称，如：\n![](img/17.jpg)\napply方法是用来将设置用户选择的翻译引擎，reset方法是重置用户选择项：\n![](img/18.jpg)\ncreateComponent方法是用来创建组件：\n![](img/19.jpg)\n现在我们来看下ToChineseAction类：\n![](img/20.jpg)\n在该类中持有一个TranslationSetting类的引用，用来获取当前用户选择的翻译引擎。我们首先获取代码编辑区对象，然后判断用户是否选中了一些文本，如果选中了文本，则获取到选中的内容，然后调用formatText方法将没用的干扰文本去掉，最后获取翻译引擎，执行翻译，并将翻译结果以气泡的方式展示出来。\n![](img/21.jpg)\n效果如下：\n![](img/22.jpg)\n我们再来看下ToEnglishAction类，该类和ToChineseAction类似，唯一的不同就是提示面板不一样：该类是先弹出来一个框提示用户输入中文，然后将中文翻译成相应的英文：\n![](img/23.jpg)\n效果如下：\n![](img/24.jpg)\n![](img/25.jpg)\n关于Idea插件开发的部分就介绍完毕了，具体怎么执行翻译的呢？有兴趣的可以去看下源码(https://github.com/limengyu1990/easy-translation)，这里就不多介绍了，同时可以去Idea官方插件库中下载该插件试用：\n![](img/26.jpg)\n","tags":["plugin"]},{"title":"ScalaSTM官网翻译","url":"/blog/2018/07/29/ScalaSTM官网翻译/","content":"\n### 欢迎\n欢迎来自 Scala STM 的创造者。我们已经为 scala 构建了一个轻量级的软件事务性内存, 灵感来自于Haskell STMs和Clojure, 同时利用了Scala 的力量和性能。\nScalaSTM 是一个没有依赖关系的单一 JAR, 包括\n* 支持多个 STM 实现的 API\n* 基于 CCSTM 的参考实现\n* 可扩展的并发sets和maps(具有快速快照), 可以在事务内部或外部使用\n\nScalaSTM 提供一个可变单元称为一个Ref，如果使用不可变对象和 Ref-s构建共享数据结构, 则可以从多个threads或actors访问该结构。没有同步、没有死锁或争用条件以及良好的可伸缩性。包括并发sets和maps, 我们也有一个更容易和更安全的替代wait和notifyAll。\n\n### 介绍\n#### STM是什么？\nSTM（软件事务性内存）是介于代码的关键部分 (atomic原子块) 和程序堆之间的中介。STM 在atomic原子块中读取和写入过程中进行干预, 允许它检查and/or避免干扰其他线程。如果多个线程的负载和存储变得交错, 则将回滚该atomic原子块的所有写入, 然后重试整个块。如果关键部分的访问不是交错的, 则它就像是以原子的样子完成的, 并且可以提交原子块。其他threads或actors只能看到已提交的更改。\nSTMs 使用乐观并发控制。他们乐观地认为, atomic原子块将能够并行运行, 然后备份和重试, 如果推测是不正确的。保留旧版本的数据以便备份可能会带来一些开销, 但乐观并发通常比其他方法具有更好的可伸缩性。\n\n#### ScalaSTM - 没有魔力\n有几个雄心勃勃的尝试来创建 STMs, 可以并行运行现有的顺序命令代码。这是一项难度很大的任务, 需要大量的魔力, 因为对 STM 的调用需要插入到一个atomic原子块内的非final字段或数组元素的每个负载和存储中。良好的性能也很难, 因为大量的读写。\nScalaSTM API 通过只管理 Ref-s, 避免了对魔力的需要。这意味着要管理的内存位置较少, 因此不需要字节码检测或编译器修改。就像在Haskell和Clojure中 一样, Ref 的效用通过语言对不可变数据结构的良好支持被放大。ScalaSTM 还包括可在事务中使用的并发sets和maps。\n\n#### ScalaSTM是给谁的呢？\nScalaSTM 是程序员用来协调threads或actors对共享数据的访问。在服务器中, 这可能是活动连接或缓存的列表。在客户端中, 这可能是部分结果或工作线程状态。\n\n优点：\n* 说出你的意思。你编写atomic原子, ScalaSTM 原子执行它没有deadlocks 或者 races。不需要将锁映射到数据。嵌套的原子块做了正确的事情, 所以你可以从简单的开始构造复杂的线程安全的操作。\n* 读取规模。系统中的所有线程都可以在不相互干扰的情况下读取数据。乐观算法比悲观方法更好地利用了现代架构上的缓存。\n* 异常自动触发清理。如果atomic原子块引发异常, 则所有 Ref-s 都将重置为其原始状态。(如果愿意, 可以更改此默认值）\n* 等待复杂的条件是容易的。如果一个atomic原子块找不到它要查找的状态, 它可以调用重试备份并等待其任何输入更改。如果有多种方式标识成功, 你可以将它们链接起来，ScalaSTM 将尝试他们所有。\n* 简单。ScalaSTM 只是一个独立的库, 所以它不会影响应用程序中不使用它的部分。这意味着可以将其包含在框架或隐藏组件中。\n缺点：\n* 每次读或写两个额外字符。如果 x 是 Ref, 则 x () 读取其值, x () = v 写入它的值。\n* 单线程开销。在大多数情况下, 当程序实际上没有并行运行时, STMs 的速度会减慢。我们已经得到了实际成本相当低, 所以对于大多数使用者来说这不会是一个问题。即使在单线程程序中，回滚也非常有用，以便在异常情况下自动清除。\n* 回滚与I/O混合的不是很好。只会自动撤消对 Ref-s 的更改。ScalaSTM API 提供了hooks , 因此您可以执行手动补偿或数据库集成, 但无法撤回数据包或像素。当然, 当你持有一个锁的时候你可能不应该做I/O。\n\n### 快速开始\n作为一个简单的例子,我们将构建一个可以被多个线程或actor安全使用的双向链表。我们将会教我们的列表如何成为一个阻塞队列,然后我们将添加从多个队列中选择下一个可用元素的能力。\n\n#### 安装\n如果你使用sbt，把下面的依赖添加到你的工程中build.sbt文件中，\n然后运行sbt update\nMaven2的配置可以从如下链接获取：https://nbronson.github.io/scala-stm/releases.html\n\n#### 对共享变量使用Ref\n在我们的可变链表中， 我们需要每个节点的下一个和上一个指针是线程安全的。通常， 如果一个线程可能在另一个线程访问它 (读取或写入) 的同时写一个变量，那么STM需要通过Ref来参与。\nRef是单个的可变单元，还有事务性集合(如TMap和Tset)，它们是scala.collection.mutable.集合的替代品.\n![](img/1.jpg)\n为了让代码更简单，我们通过一个额外的header节点使列表循环，在创建时，这个header节点的next节点和prev节点指向自身，next节点和prev节点总是非空的。\n\n#### 用atomic包装你的代码\n如果 x 是 Ref, 则 x () 获取存储在 x 中的值, x () = v 将其设置为值 v。\n只能在atomic代码块内读取和写入Ref-s。这在编译时通过要求可用的隐式InTxn 值来进行检查，Atomic代码块是一个需要一个lnTxn参数的函数，因此可以通过将参数标记为隐式的来满足此要求。\n![](img/2.jpg)\n\n#### 组合atomic操作\nAtomic代码块嵌套，因此你可以通过一个简单的开始构建复合操作.\n![](img/3.jpg)\n\n#### 优化单一操作事务\nRef.single返回一个Ref.View类型的实例，这个行为就像原始的Ref只是它也可以在一个atomic代码块之外访问。Ref.View上的每一个方法都类似于单操作事务，因此name.Ref.View提供了多种执行读写的方法，例如swap，compareAndSet和transform。如果一个atomic块只访问一个Ref，那么使用Ref.View可能会更简洁、更高效。\n![](img/4.jpg)\n\n#### 等待条件变化\n当一个atomic代码块无法在当前输入状态下完成时使用retry关键字。在atomic代码块内调用retry将导致它回滚，等待它的一个输入更改，然后重试执行。这大致类似于调用wait等待ScalaSTM 自动生成相匹配 notifyAll 的调用。作为其实现乐观并发的一部分，STM跟踪了一个atomic代码块的read集合，Ref-s的集合已在事务期间读取（即在事务过程中读取的 Ref-s 集合），这意味着STM可以有效的阻塞当前线程，直到另一个线程已经写入其read集合中的一个元素，在这段时间内，可以重试该atomic代码块，这使得等待复杂的条件变得微不足道，并可避免丢失唤醒。\n为了演示，我们将会添加一个函数到我们的列表，等待直到这个列表是非空的，然后移除并返回第一个元素：\n![](img/5.jpg)\n\n#### 等待多个事件\n在atomic代码块结束后重试的另一种方法是提供另一种选择。你可以用 orAtomic去链接atomic代码块;如果上层的调用retry, 则会尝试较低的替代方案。这就允许你组合功能如使用retry阻塞或者从一个阻塞行为中进行转换。\n例如，我们可以通过提供一个可选方案并使用阻塞版本的removeFirst 来构造一个返回Option的方法：\n![](img/6.jpg)\n这样也很容易从一个返回故障代码的函数切换到返回一个块的函数，下面的select方法阻塞直到他的输入是非空的，然后从列表中移除并返回第一个元素：\n![](img/7.jpg)\n\n#### 当心回滚\n在乐观并发能够成功之前, ScalaSTM 可能需要多次尝试一个atomic代码块，任何对 STM 的调用都可能会发现故障并触发回滚和重试。如果本地非 Ref 变量的生存期长于atomic代码块， 则不会回滚, 因此应该避免它们。不过, 只在atomic代码块的内部或仅在外部使用的局部变量是很好的。\n\n下面，badToString 是不正确的， 因为它在atomic代码块的外部和内部使用可变 StringBuilder。返回值将会明确提到列表中的所有元素, 但它其中的一些内容可能会出现两次或更多次。\ntoString是正确的, 因为对于每次atomic尝试它都使用一个新的 StringBuilder。\n![](img/8.jpg)\n\n#### 查看源代码\n此列表示例是 GitHub 上源代码的一部分: ConcurrentIntList.scala\n文章来源：https://nbronson.github.io/scala-stm/quick_start.html\n示例源代码：https://github.com/nbronson/scala-stm/blob/master/src/test/scala/scala/concurrent/stm/examples/ConcurrentIntList.scala\n\n### 真人秀哲学家Demo\n\nDijkstra 创建了餐厅哲学家的问题, 作为并发系统中的死锁的例子 (维基百科上的用餐哲学家)。每个哲学家必须拿起两个叉子吃他的饭, 但没有足够的叉子, 他们都吃一次。哲学家必须有某种策略, 以确保他们不都拿起一分叉, 然后永远等待一秒钟。\n许多解决方案都可能避免死锁, 但 STM 提供了一个特别简单的方法。ScalaSTM 的atomic原子块提供了一种方法, 让哲学家同时拿起两个叉子, 这是大多数实现者不可用的能力。\n![](img/9.jpg)\n这表明当结合重试时，Ref [Boolean] 表现的可以像锁一样。\n\n#### 添加一个摄像头\n在这个时代, 食客们更有可能不得不在真人秀节目上比在闭门的情况下为叉子而战。与基于信号量或代理的解决方案不同, STM 解决方案可以很容易地添加摄像头的外部透视图。在实际系统中, 外部视图可能来自管理控制台 (读取和写入)、检查点线程或 GUI 组件。\n\n#### 记录所有权\n首先, 我们将更改叉子, 以便他们使用一个选项来记录所有者的存在和所有者的名称。请注意, 当使用Ref工厂方法创建 Ref[Option[String]] 时, 我们需要强制 类型为\"None\" 。如果我们没有这样做, 那么所有者将最终作为一个 Ref [None], 这不是很有用。\n我们还将给每个哲学家一个名称和一个 Ref[Int] 来记录他们的进展。为方便起见, Ref和Ref.View为具有关联Numeric[A] 的类型 A 提供就地算术运算 (如+=)。\n![](img/10.jpg)\n\n#### 捕获快照\n捕捉系统状态的图像现在就像遍历原子块中的叉子和哲学家一样容易。事务不能访问在原子块外声明的可变对象 (或 var), 这一点很重要。下面的可变 StringBuilder 是在原子块内创建的, 所以它是安全的。\n![](img/11.jpg)\n\n#### Demo全部源码\n此示例的完整源可用作 github 的 ScalaSTM 源的一部分: RealityShowPhilosophers.scala.它包括一个摄像头线程, 它可以一秒钟打印图像60次, 以及处理线程停止。\n下面是运行 RealityShowPhilosophers 的摘录。注意, 因为叉子被拾起并且立刻被放下, 摄像头从未观察一个哲学家只拿着一个叉子。\n![](img/12.jpg)\n\n#### 异常\n当原子块引发异常时会发生什么情况？STM 社区中存在关于是否应回滚或提交事务的辩论。ScalaSTM 使用一种混合的方法来尝试做正确的事情。\n\n#### 异常 -> 回滚 + 重新抛出\n如果atomic原子块引发异常, ScalaSTM 将其回滚, 然后重新抛出该异常。当异常被再次引发时, atomic原子块将被左回滚。对于表示实际错误的异常, 这是一个很好的默认行为, 因为它防止了任何共享数据结构的损坏。\n\n\n#### 控制流异常 –> 提交 + 重新抛出\n有时, 异常表示非本地控制转移, 而不是一个意外的错误。在这种情况下, 应该提交事务。ScalaSTM 测试每个异常转义一个atomic原子块以确定哪个行为是合适的 (查看scaladoc文档TxnExecutor.isControlFlow了解更多)。默认情况下, 扩展 scala.util.control.ControlThrowable 的所有异常都被视为控制流。\n\n#### 异常和嵌套\n以前有关异常处理的规则适用于嵌套事务。这意味着在提交外部事务时可能会回滚嵌套事务。例如, 在下面的代码运行后, 最后将保存值 \"outer\"：\n![](img/13.jpg)\n为了使嵌套更廉价, ScalaSTM 尝试将所有嵌套级别拼合成一个顶级事务。如果内部事务引发异常, 则没有足够的信息来执行部分回滚, 因此 ScalaSTM 将以精确嵌套的模式重新启动整个事务。此优化称为包容。\n\n#### 语法速查表 \nRef, Ref.View and atomic\n![](img/14.jpg)\n\n\n\n\n\n\n","tags":["STM"]},{"title":"FSM状态机","url":"/blog/2018/07/29/FSM状态机/","content":"> 本文主要讲解如何使用状态模式来消除大量的if-else条件判断代码\n\n在我们的App中，订单模块会有很多的状态，例如待付款、付款中、已预约、已取消、已评价等。我们抽一个取消的流程来看下，取消时需要判断当前状态是否允许取消，伪代码如下：\n![](img/1.jpg)\n\n如果状态类型很少的话，这样子判断还可以，一旦我们的状态类型多起来的话，那么我们这里就会是一大堆的if-else条件判断，不仅难以阅读，而且维护起来容易出错。\n我们有三种方式来重构这样的代码：\n* 设计模式之状态模式\n* 领域驱动设计之状态建模\n* 状态机\n\n### 设计模式之状态模式\n![](img/2.jpg)\n其中State是状态接口，ConcreteState是各个具体的状态实现。我们在这里定义个订单状态接口OrderState：\n![](img/3.jpg)\n![](img/4.jpg)\n![](img/5.jpg)\n\n可以看到不是每个状态都能够支持所有操作的，例如：支付中的状态不可以进行支付操作；未支付的状态不可以进行退款操作等。当然我们可以创建一个抽象类AbstractOrderState，把操作的默认实现都放进去，具体的状态实现只覆盖自己能进行的操作。\n然后我们定义一个Context，即订单实体类Order，它持有一个State字段，通过State实现所有的状态转换逻辑：\n![](img/6.jpg)\n通过状态模式，可以省略一大堆条件判断，逻辑实现起来更清晰。\n\n\n### 领域驱动设计之状态建模\n在领域驱动设计中，我们可以定义一些操作接口，然后将每种状态的订单都定义为一个实体类，让这些实体类实现需要的操作接口：\n![](img/7.jpg)\n\n### 状态机\n不管是状态模式还是状态实体，多个状态之间的转换，还是分散在各个状态的实现里的。其实所有的状态转换都可以概括为：\n```scala\nState(S) x Event(E) -> Actions (A), State(S')\n```\n即如果当前状态为S，接收到一个事件E，则执行动作A，同时状态转换为S‘。\nAkka 框架实现了一个有限状态机FSM，它定义了强有力的DSL语法，可以把状态转换和业务处理逻辑分离开来。我们这节主要讲解下Akka FSM的使用。我们先假设我们的订单流程如下面流程图所示：\n![](img/8.jpg)\n然后我们定义一些状态，OrderState继承自FSMState：\n![](img/11.jpg)\n![](img/12.jpg)\n![](img/13.jpg)\n然后我们定义一些Command和DomainEvent。DomainEvent将会被写入日志，它与Command的关系是：我们可以给FSM发送Command，FSM执行Command时会产生DomainEvent，然后这些产生的DomainEvent会被写入日志：\n![](img/14.jpg)\n![](img/15.jpg)\n然后我们定义我们的状态数据：\n![](img/16.jpg)\n然后我们创建我们的状态机MedicalOrderFSM：\n![](img/17.jpg)\n可以看到我们的状态机继承自PersistentFSM trait，我们看下PersistentFSM trait：\n![](img/18.jpg)\nPersistentFSM继承了PersistentActor，说明它具备了事件持久化和日志恢复能力。继承的另一个类型PersistentFSMBase是FSM trait的重新定义，针对状态机的持久化特性设计了一套持久化状态转换的DSL。三个类参数S,D,E分别代表状态类型（State）、状态数据（Data）、领域事件（Event），与FSM比较：PersistentFSM除增加了event参数外，State类型是以FSMState类型为基础的，方便对State进行序列化（serialization）.\n![](img/19.jpg)\n然后我们就可以使用DSL来定义我们的状态机处理流程：\n```scala\nstartWith(initState,initData)  //定义状态机起始状态\nwhen(stateA) {...}   //处理各种状态\nwhen(stateB) {...}\nwhenUnhandled {...}   //处理共性状态\nonTransition {...}  //状态转变跟踪\n```\n状态转换是通过stay(保持当前状态)、goto(到下一个状态)、stop(停止)实现的：\n![](img/20.jpg)\n可以看到stay是通过goto来实现的：\n![](img/21.jpg)\n我们挑一个看下：\n![](img/22.jpg)\n状态机默认状态为InitState，他可以处理CreateOrderCommand，然后跳转到WaitingPayState状态(待支付)，然后应用CreateOrderEvent事件。\n只有状态转换（即InitState转换成WaitingPayState）和数据转换都成功（即CreateOrderEvent执行成功），状态机的本次状态流程才会最终完成，任何一个执行失败，都会执行回滚。这里执行成功后，我们调用saveStateSnapshot保存当前快照，用来重启后状态恢复。\n然后我们定义一个Tracker Actor用来处理事件流：\n![](img/23.jpg)\n然后我们可以测试下我们的状态机，因为actor是轻量级的，因此我们的一个订单交由一个actor来处理，每个actor大概有30字节，1G的内存可以有上百万的actor：\n![](img/24.jpg)\n![](img/25.jpg)\n\n可以看到我们创建了两个订单，状态由“初始状态0“变成了“待支付3“。\n![](img/26.jpg)\n然后对订单支付，可以看到支付成后，状态由“待支付3“变成了“已支付4”。\n我们的状态机状态数据会异步的写到外部存储中，这里使用的是mysql-async组件：\n![](img/27.jpg)\n今天就先简单介绍到这里，后面有时间会分享下Akka FSM的源码。\n\n\n","tags":["akka"]},{"title":"Metasploit渗透测试","url":"/blog/2018/07/28/Metasploit渗透测试/","content":">Metasploit渗透测试系列教程\n\n","tags":["渗透测试"]}]