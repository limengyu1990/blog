[{"title":"Plutus-Pioneer-lesson-05","url":"/blog/2021/05/06/Plutus-Pioneer-lesson-05/","tags":["Pioneer"]},{"title":"Plutus-Pioneer-lesson-04","url":"/blog/2021/04/27/Plutus-Pioneer-lesson-04/","content":"> 本节课内容主要讲解Monads，并在最后介绍了EmulatorTrace Monad和Contract Monad.\n\n### 发现规律\n\n#### Maybe\n\n```haskell\ndata Maybe a = Nothing | Just a\n```\n\n`Maybe`可以在成功时返回`Just`，失败时返回`Nothing`.\n\n```haskell\n\nimport Text.Read (readMaybe)\n\n-- 从字符串中读取指定类型的数据，如果没有读取到则返回Nothing\nreadMaybe :: Read a => String -> Maybe a\n\n-- 在repl中练习\n\n-- λ > readMaybe \"12\" :: Maybe Int\n-- Just 12\n\n-- λ > readMaybe \"\\\"hello world\\\"\" :: Maybe String\n-- Just \"hello world\"\n\n-- λ > readMaybe \"a\" :: Maybe Char\n-- Nothing\n\n-- λ > readMaybe \"'a'\" :: Maybe Char\n-- Just 'a'\n\n-- foo函数接收三个字符串参数，并从中解析出数字，然后计算他们的和\n-- 如果有一个没有解析出数字，就返回Nothing\nfoo :: String -> String -> String -> Maybe Int\nfoo x y z = case readMaybe x of\n    -- 1.如果x解析结果为Nothing，则直接返回Nothing\n    Nothing -> Nothing\n    -- 2.如果x解析结果不是Nothing的话，再去检查y是不是Nothing\n    Just k  -> case readMaybe y of\n        Nothing -> Nothing\n        -- 3.如果y解析结果不是Nothing的话，再去检查z是不是Nothing\n        Just l  -> case readMaybe z of\n            Nothing -> Nothing\n            -- 4.如果z解析结果不是Nothing的话，则累加xyz的结果并返回\n            Just m  -> Just (k + l + m)\n\n-- 注意: \n-- 从foo函数1/2/3/4等步骤可以观察到:\n--   每一步都是在检查当前Maybe(例如: readMaybe x)值是不是Nothing,\n--   如果是Nothing就直接返回，不是Nothing则执行下一步操作流程.\n-- \n-- 因此我们可以把该操作流程抽象成一个通用函数bindMaybe: \n--   接收一个参数a(上一步解析出来的结果)，返回下一个Maybe值b\nbindMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b\nbindMaybe Nothing  _ = Nothing\nbindMaybe (Just x) f = f x\n\n-- 使用我们的抽象函数bindMaybe来重写foo函数:\nfoo' :: String -> String -> String -> Maybe Int\nfoo' x y z = readMaybe x `bindMaybe` \\k ->\n             readMaybe y `bindMaybe` \\l ->\n             readMaybe z `bindMaybe` \\m ->\n             Just (k + l + m)\n\n\n-- 再一次重写foo函数\n-- 我们稍后再看threeInts函数\nfoo'' :: String -> String -> String -> Maybe Int\nfoo'' x y z = threeInts (readMaybe x) (readMaybe y) (readMaybe z)\n```\n\n#### Either\n\n与`Maybe`类相比，`Either`类可以在失败时提供更多错误信息.\n`Either`类定义如下, 失败时返回`Left`, 成功时返回`Right`:\n```haskell\ndata Either a b = Left a | Right b\n```\n\n```haskell\n-- 与readMaybe类似，成功时将返回Right, 失败时返回Left，并附带错误原因\nreadEither :: Read a => String -> Either String a\nreadEither s = case readMaybe s of\n    Nothing -> Left $ \"can't parse: \" ++ s\n    Just a  -> Right a\n\n-- 使用readEither来从字符串中解析数字\nfoo :: String -> String -> String -> Either String Int\nfoo x y z = case readEither x of\n    Left err -> Left err\n    -- 解析x成功，接着尝试解析y\n    Right k  -> case readEither y of\n        Left err -> Left err\n        -- 解析y成功，接着尝试解析z\n        Right l  -> case readEither z of\n            Left err -> Left err\n            -- 解析z成功，返回xyz的累加结果\n            Right m  -> Right (k + l + m)\n\n-- 与bindMaybe类似:\n-- 先从Either String a中解析a，\n-- 如果解析出来a，则调用函数: (a -> Either String b)，否则返回Left\nbindEither :: Either String a -> (a -> Either String b) -> Either String b\nbindEither (Left err) _ = Left err\nbindEither (Right x)  f = f x\n\n-- 使用bindEither重写foo函数\nfoo' :: String -> String -> String -> Either String Int\nfoo' x y z = readEither x `bindEither` \\k ->\n             readEither y `bindEither` \\l ->\n             readEither z `bindEither` \\m ->\n             Right (k + l + m)\n\n-- 使用threeInts重写foo函数\nfoo'' :: String -> String -> String -> Either String Int\nfoo'' x y z = threeInts (readEither x) (readEither y) (readEither z)\n\n```\n\n#### Writer\n\n`Writer` 可以让我们在做计算的同时收集一些日志，并汇集成一个log附加到结果上. \n\n```haskell\nimport Control.Monad\n\ndata Writer a = Writer a [String]\n    deriving Show\n\nnumber :: Int -> Writer Int\nnumber n = Writer n $ [\"number: \" ++ show n]\n\n-- 可以忽略一些结果(使用单元类型`()`)，只记录日志\ntell :: [String] -> Writer ()\ntell = Writer ()\n\nfoo :: Writer Int -> Writer Int -> Writer Int -> Writer Int\nfoo (Writer k xs) (Writer l ys) (Writer m zs) =\n  let\n    s = k + l + m\n    -- 记录3个数字的总和\n    Writer _ us = tell [\"sum: \" ++ show s]\n  in\n    -- 记录结果s和计算时的日志信息\n    Writer s $ xs ++ ys ++ zs ++ us\n\nbindWriter :: Writer a -> (a -> Writer b) -> Writer b\nbindWriter (Writer a xs) f =\n  let\n    -- 从`Writer a`中取出结果`a`, \n    -- 然后使用`a`调用函数(a -> Writer b)取得下一个结果`b`\n    Writer b ys = f a\n  in\n    -- 记录最终结果b，并累加上次和下次的记录\n    Writer b $ xs ++ ys\n\n-- 使用bindWriter重写foo函数\nfoo' :: Writer Int -> Writer Int -> Writer Int -> Writer Int\nfoo' x y z = x `bindWriter` \\k ->\n             y `bindWriter` \\l ->\n             z `bindWriter` \\m ->\n             let s = k + l + m\n             in tell [\"sum: \" ++ show s] `bindWriter` \\_ ->\n                Writer s []\n\n-- -- 使用threeInts重写foo函数\nfoo'' :: Writer Int -> Writer Int -> Writer Int -> Writer Int\nfoo'' x y z = do\n    s <- threeInts x y z\n    tell [\"sum: \" ++ show s]\n    return s\n\n-- 将自定义的Writer实现为Functor/Applicative/Monad\ninstance Functor Writer where\n    -- fmap :: Functor f => (a -> b) -> f a -> f b\n    -- liftM :: Monad m => (a1 -> r) -> m a1 -> m r\n    fmap = liftM\n\ninstance Applicative Writer where\n    -- pure :: Applicative f => a -> f a\n    -- return :: Monad m => a -> m a\n    pure = return\n    -- ap :: Monad m => m (a -> b) -> m a -> m b\n    -- (<*>) :: Applicative f => f (a -> b) -> f a -> f b\n    (<*>) = ap\n\ninstance Monad Writer where\n    return a = Writer a []\n    (>>=) = bindWriter\n```\n\n### 引出Monad\n\n```haskell\n\n-- Monad类型类 定义\nclass Applicative m => Monad m where\n  (>>=) :: m a -> (a -> m b) -> m b\n  (>>) :: m a -> m b -> m b\n  return :: a -> m a\n  {-# MINIMAL (>>=) #-}\n\n-- (>>=)      :: IO a            -> (a -> IO b)            -> IO b\n-- 上一小节我们定义的3个函数:\n-- bindMaybe  :: Maybe a         -> (a -> Maybe b)         -> Maybe b\n-- bindEither :: Either String a -> (a -> Either String b) -> Either String b\n-- bindWriter :: Writer a        -> (a -> Writer b)        -> Writer b\n\n-- return              :: a -> IO a\n-- 上一小节我们使用的类型:\n-- Just                :: a -> Maybe a\n-- Right               :: a -> Either String a\n-- (\\a -> Writer a []) :: a -> Writer a\n```\n\n可以观察到我们定义的三个函数`bindMaybe`/`bindEither`/`bindWriter`与`(>>=)`函数是非常相似的，都是从一个上下文中取出一个值`a`，然后应用一个函数，得到一个新值`b`，然后放进上下文中并返回.\n\n而`Just`/`Right`/`(\\a -> Writer a [])`与`return`函数很相似，都是将一个值`a`放进到当前上下文中.\n\n由于`Maybe`/`Either`/`Writer`都是`Monad`类型类的实例，因此我们可以使用`(>>=)`函数和`return`函数来代替我们的自定义函数。\n\n我们可以定义一个通用函数`threeInts`，然后使用`Monad`来限定参数类型:\n\n```haskell\nthreeInts :: Monad m => m Int -> m Int -> m Int -> m Int\nthreeInts mx my mz =\n    mx >>= \\k ->\n    my >>= \\l ->\n    mz >>= \\m ->\n    let s = k + l + m in return s\n\n-- 使用do语句\nthreeInts' :: Monad m => m Int -> m Int -> m Int -> m Int\nthreeInts' mx my mz = do\n    k <- mx\n    l <- my\n    m <- mz\n    let s = k + l + m\n    return s\n```\n\n然后我们就可以使用`threeInts`函数重写`foo`函数了，具体实现参见上一小节的`foo''`函数.\n\n### Plutus中的一些Monads\n\n#### EmulatorTrace Monad\n\n```haskell\nimport Plutus.Trace.Emulator\nimport Plutus.Contract.Trace\nimport Plutus.V1.Ledger.Value\n\n-- 标识一个钱包\nnewtype Wallet = Wallet {getWallet :: Integer}\n\n-- <货币符号，<token名称，金额>>\nnewtype Value = Value {getValue :: PlutusTx.AssocMap.Map\n      CurrencySymbol (PlutusTx.AssocMap.Map TokenName Integer)\n   }\n\n-- 钱包及其值\ntype InitialDistribution =\n    Map Wallet Value\n\n-- λ > defaultDist :: InitialDistribution\n-- λ > defaultDistFor :: [Wallet] -> InitialDistribution\n-- λ > defaultDistFor [Wallet 1]\n-- fromList [(Wallet 1,Value (Map [(,Map [(\"\",100000000)])]))]\n\ntype InitialChainState =\n  Either InitialDistribution Ledger.Blockchain.Block\n\n-- 模拟器配置\ndata EmulatorConfig = EmulatorConfig {\n    _initialChainState :: InitialChainState\n  }\n\n-- 运行跟踪\nrunEmulatorTrace :: EmulatorConfig \n    -> EmulatorTrace ()\n    -> ([EmulatorEvent], \n        Maybe EmulatorErr, \n        EmulatorState)\n\n-- 使用默认配置运行跟踪\nrunEmulatorTraceIO :: EmulatorTrace () -> IO ()\n\n-- λ > \n-- λ > -- 构建一个模拟器配置\n-- λ > :t EmulatorConfig $ Left defaultDist\n-- EmulatorConfig $ Left defaultDist :: EmulatorConfig\n-- λ > \n-- λ > runEmulatorTrace (EmulatorConfig $ Left defaultDist) $ return ()\n-- λ > \n-- λ > runEmulatorTraceIO $ return ()\n-- λ > \n```\n\n打开`~/haskell/plutus-pioneer-program/code/week04/src/Week04/Trace.hs`文件, \n我们可以使用上面介绍的类型，来编写一些代码:\n\n```haskell\n\n-- EmulatorTrace a\n\n-- 运行跟踪\ntest :: IO ()\ntest = runEmulatorTraceIO myTrace\n\nmyTrace :: EmulatorTrace ()\nmyTrace = do\n    -- endpoints是我们上节课声明的游乐场端点(即: Contract合同)\n    h1 <- activateContractWallet (Wallet 1) endpoints\n    h2 <- activateContractWallet (Wallet 2) endpoints\n    -- 使用钱包1调用give端点，并传递GiveParams参数\n    callEndpoint @\"give\" h1 $ GiveParams\n        { gpBeneficiary = pubKeyHash $ walletPubKey $ Wallet 2 -- ^ 受益人的公钥哈希\n        , gpDeadline    = Slot 20   -- ^ 截止日期\n        , gpAmount      = 1000      -- ^ 资金\n        }\n    -- 等到slot 20\n    void $ waitUntilSlot 20\n    -- 钱包2调用grab端点，抓取资金\n    callEndpoint @\"grab\" h2 ()\n    -- 等待1个slot\n    -- void $ waitNSlots 1\n    s <- waitNSlots 1\n    -- 输出日志\n    Extras.logInfo $ \"reached slot \" ++ show s\n```\n\n#### Contract Monad\n\n打开`~/haskell/plutus-pioneer-program/code/week04/src/Week04/Contract.hs`文件:\n\n```haskell\n-- w 类似writer monad，可以用来记录一些信息\n-- s 合同schema, 可以获取区块链信息的能力\n-- e 标识异常类型\n-- a 标识计算结果\n-- Contract w s e a\n\n-- 第1个合同示例(抛出异常)\n-- myContract1 :: Contract () BlockchainActions Text ()\n-- myContract1 = Contract.logInfo @String \"Hello from the contract!\"\n\nmyContract1 :: Contract () BlockchainActions Text ()\nmyContract1 = do\n    -- 抛出异常\n    void $ Contract.throwError \"BOOM!\"\n    Contract.logInfo @String \"Hello from the contract!\"\n\nmyTrace1 :: EmulatorTrace ()\nmyTrace1 = void $ activateContractWallet (Wallet 1) myContract1\n\ntest1 :: IO ()\ntest1 = runEmulatorTraceIO myTrace1\n\n-- 第2个合同示例(捕获合同错误)\n-- logError :: ToJSON a => a -> Contract w s e ()\n-- handleError :: (e -> Contract w s e' a) -> Contract w s e a -> Contract w s e' a\nmyContract2 :: Contract () BlockchainActions Void ()\nmyContract2 = Contract.handleError\n    (\\err -> Contract.logError $ \"Caught error: \" ++ unpack err)\n    myContract1\n\nmyTrace2 :: EmulatorTrace ()\nmyTrace2 = void $ activateContractWallet (Wallet 1) myContract2\n\ntest2 :: IO ()\ntest2 = runEmulatorTraceIO myTrace2\n\n-- 第3个合同示例(获取端点信息)\n-- 自定义端点\ntype MySchema = BlockchainActions .\\/ Endpoint \"foo\" Int\n\nmyContract3 :: Contract () MySchema Text ()\nmyContract3 = do\n    -- 获取端点信息\n    n <- endpoint @\"foo\"\n    -- 将会打印出获取到的参数值: 42\n    Contract.logInfo n\n\nmyTrace3 :: EmulatorTrace ()\nmyTrace3 = do\n    -- 钱包1\n    h <- activateContractWallet (Wallet 1) myContract3\n    -- 调用端点foo, 并传入参数42\n    callEndpoint @\"foo\" h 42\n\ntest3 :: IO ()\ntest3 = runEmulatorTraceIO myTrace3\n\n-- 第4个合同示例(使用monoid来累加日志信息)\n-- class Semigroup a => Monoid a where\n--   mempty :: a\n--   mappend :: a -> a -> a\n--   mconcat :: [a] -> a\n--   {-# MINIMAL mempty #-}\n\n-- λ > mempty :: [Int]\n-- []\n-- λ > mappend [1, 2, 3 :: Int] [4, 5, 6]\n-- [1,2,3,4,5,6]\n\nmyContract4 :: Contract [Int] BlockchainActions Text ()\nmyContract4 = do\n    void $ Contract.waitNSlots 10\n    -- 记录合同状态\n    tell [1]\n    void $ Contract.waitNSlots 10\n    tell [2]\n    void $ Contract.waitNSlots 10\n\nmyTrace4 :: EmulatorTrace ()\nmyTrace4 = do\n    h <- activateContractWallet (Wallet 1) myContract4\n\n    void $ Emulator.waitNSlots 5\n    -- 通过observableState获取合同状态\n    xs <- observableState h\n    -- 输出当前合同状态\n    Extras.logInfo $ show xs -- ^ []\n\n    void $ Emulator.waitNSlots 10\n    ys <- observableState h\n    Extras.logInfo $ show ys -- ^ [1]\n\n    void $ Emulator.waitNSlots 10\n    zs <- observableState h\n    Extras.logInfo $ show zs -- ^ [1, 2]\n\ntest4 :: IO ()\ntest4 = runEmulatorTraceIO myTrace4\n\n```\n\n### 作业\n\n> Trace逻辑: 通过`Wallet 1`调用`pay`端点两次，每次都以`Wallet 2`作为收件人，但金额由这两个参数给定。在每个端点调用之后，应该有一个`slot`的延迟。\n\n打开`~/haskell/plutus-pioneer-program/code/week04/src/Week04/Homework.hs`文件:\n\n```haskell\ndata PayParams = PayParams\n    { ppRecipient :: PubKeyHash\n    , ppLovelace  :: Integer\n    } deriving (Show, Generic, FromJSON, ToJSON)\n\ntype PaySchema = BlockchainActions .\\/ Endpoint \"pay\" PayParams\n\n-- mustPayToPubKey 使用公钥锁定值\n-- lovelaceValueOf :: Integer -> Value\npayContract :: Contract () PaySchema Text ()\npayContract = forever $ do\n    pp <- endpoint @\"pay\"\n    let tx = mustPayToPubKey (ppRecipient pp) $ lovelaceValueOf $ ppLovelace pp\n    void $ submitTx tx\n\n-- 支持错误处理程序\npayContractHandle :: Contract () PaySchema Text ()\npayContractHandle = forever $ do\n    pp <- endpoint @\"pay\"\n    let tx = mustPayToPubKey (ppRecipient pp) $ lovelaceValueOf $ ppLovelace pp\n        errorHandler = \\t -> Contract.logInfo @Text (\"Error submiting the trasaction!: \" <> t)\n    -- 注意，错误必须在合同内处理！否则，错误只检测一次.\n    errorHandler `handleError` void (submitTx tx)\n\n-- A trace that invokes the pay endpoint of payContract on Wallet 1 twice, each time with Wallet 2 as\n-- recipient, but with amounts given by the two arguments. There should be a delay of one slot\n-- after each endpoint call.\n\n-- 修改payTrace，使其接受合同参数，以便使合同的两个版本都受支持(有和没有错误处理程序)\npayTrace :: Contract () PaySchema Text () -> Integer -> Integer -> EmulatorTrace ()\npayTrace c x y = do\n    let w2 = Wallet 2\n        recipient = pubKeyHash $ walletPubKey w2\n        p1 = PayParams recipient x\n        p2 = PayParams recipient y\n    -- 开启合同新实例\n    h1 <- Wallet 1 `activateContractWallet` c\n    -- 使用钱包1调用pay端点，并将钱包2作为参数传入\n    callEndpoint @\"pay\" h1 p1\n    -- 等待1个slot时间\n    void $ Emulator.waitNSlots 1\n     -- 再次使用钱包1调用pay端点，并将钱包2作为参数传入\n    callEndpoint @\"pay\" h1 p2\n    -- 等待1个slot时间\n    void $ Emulator.waitNSlots 1\n\npayTest1 :: IO ()\npayTest1 = runEmulatorTraceIO $ payTrace payContract 1000000 2000000\n\npayTest2 :: IO ()\npayTest2 = runEmulatorTraceIO $ payTrace payContractHandle 1000000000 2000000\n```","tags":["Monad"]},{"title":"Plutus-Pioneer-lesson-03","url":"/blog/2021/04/20/Plutus-Pioneer-lesson-03/","content":"\n## 准备工作\n\n### 切换Plutus项目到特定commit id\n前两节课使用的`commit id`是`3746610e53654a1167aeb4c6294c6096d16b0502`(`week02/cabal.project`).\n\n```shell\n# 查看commit id(3aa86304e9bfc425667051a8a94db73fcdc38878)\nhead -30 ~/haskell/plutus-pioneer-program/code/week03/cabal.project\noutput: 3aa86304e9bfc425667051a8a94db73fcdc38878\n\n# 检出commit id\ncd ～/haskell/plutus\ngit checkout 3aa86304e9bfc425667051a8a94db73fcdc38878\n\n# 启动nix-shell\nnix-shell\n\n# 进入到教程目录\ncd ~/haskell/plutus-pioneer-program/code/week03/\n```\n\n### Plutus一些变更\n\n旧的类型      |   新的类型\n---          |   ---\nValidatorCtx | ScriptContext\nvalCtxTxInfo | scriptContextTxInfo\ntxInInfoWitness | (txOutDatumHash . txInInfoResolved)\ntxInInfoValue | (txOutValue . txInInfoResolved)\nTxOutInfo | TxOut\ntxOutType | txOutDatumHash\nPayToPubKey | Nothing\nPayToScript | Just\nPubKeyAddress | pubKeyHashAddress\nScriptAddress | scriptHashAddress\n\n例如, `Week02/IsData.hs`文件的第37-39行:\n```haskell\n{-# INLINABLE mkValidator #-}\nmkValidator :: () \n                -> MySillyRedeemer \n                -- 旧的 ValidatorCtx\n                -> ValidatorCtx \n                -> Bool\nmkValidator () (MySillyRedeemer r) _ = \n        traceIfFalse \"wrong redeemer\" $ r == 42\n```\n现在变更为了:\n```haskell\n{-# INLINABLE mkValidator #-}\nmkValidator :: () \n                -> MySillyRedeemer\n                -- 新的 ScriptContext\n                -> ScriptContext \n                -> Bool\nmkValidator () (MySillyRedeemer r) _ = traceIfFalse \"wrong redeemer\" $ r == 42\n```\n\n另外`Week02/IsData.hs`文件的第53-60行:\n```haskell\nvalidator :: Validator\nvalidator = Scripts.validatorScript inst\n\n-- 去掉\nvalHash :: Ledger.ValidatorHash\nvalHash = Scripts.validatorHash validator\n\n-- 去掉\nscrAddress :: Ledger.Address\nscrAddress = ScriptAddress valHash\n\n-- 增加\nscrAddress :: Ledger.Address\n-- 注意: 小写的 scriptAddress\nscrAddress = scriptAddress validator\n```\n现在可以不用自己使用`valHash`创建脚本哈希，然后使用`scrAddress`生成脚本地址，只需要使用上面更改后的`scrAddress`函数代替即可.\n\n## 类型详情\n\n本小节将会查看源代码，来了解一些常用类型的使用.\n\n### [ScriptContext](https://github.com/input-output-hk/plutus/blob/master/plutus-ledger-api/src/Plutus/V1/Ledger/Contexts.hs)\n```haskell\n-- ScriptContext定义\ndata ScriptContext = ScriptContext{\n    scriptContextTxInfo :: TxInfo,\n    scriptContextPurpose :: ScriptPurpose\n}\n\n-- | 待处理交易的输入\ndata TxInInfo = TxInInfo\n    { txInInfoOutRef   :: TxOutRef\n    , txInInfoResolved :: TxOut\n    } deriving (Generic)\n\n-- | 当前正在运行的脚本的目的\ndata ScriptPurpose\n    = Minting CurrencySymbol        -- ^ 铸造\n    | Spending TxOutRef             -- ^ 花费\n    | Rewarding StakingCredential   -- ^ 奖励\n    | Certifying DCert              -- ^ 认证\n\n-- | 待处理的交易。这是由验证程序脚本看到的视图，因此省略了一些详细信息。\ndata TxInfo = TxInfo\n    { txInfoInputs      :: [TxInInfo] -- ^ 交易的输入信息\n    , txInfoInputsFees  :: [TxInInfo] -- ^ 指定支付费用的交易输入\n    , txInfoOutputs     :: [TxOut] -- ^ 交易的输出信息\n    , txInfoFee         :: Value -- ^ 这笔交易支付的费用\n    , txInfoForge       :: Value -- ^ 该交易铸造的'值'\n    , txInfoDCert       :: [DCert] -- ^ 此交易中包含的证书摘要\n    , txInfoWdrl        :: [(StakingCredential, Integer)] -- ^ 提款\n    , txInfoValidRange  :: SlotRange -- ^ 交易的有效范围\n    , txInfoSignatories :: [PubKeyHash] -- ^ Signatures provided with the transaction, attested that they all signed the tx\n    , txInfoData        :: [(DatumHash, Datum)]\n    , txInfoId          :: TxId\n    -- ^ 待处理交易的散列(不包括witnesses见证人)\n    } deriving (Generic)\n```\n`txInfoSignatories`持有该合同交易中所有钱包的多个`PubKeyHashes`, 这对于检查每个人是否都是他们所说的人很重要。\n\n`txInfoValidRange`持有一个`SlotRange`，它定义了交易在什么时候有效，例如，你可能想要持有`ADA`直到某个特定的时间才可以`redeem`(赎回)，或者您可能希望使`redeeming`(赎回)的选项失效等.\n\n\n### [SlotRange](https://github.com/input-output-hk/plutus/blob/master/plutus-ledger-api/src/Plutus/V1/Ledger/Slot.hs)\n\n```haskell\n-- | slot范围\ntype SlotRange = Interval Slot\n\n-- | Slot本质上是个数字\n-- | 这是一个很好的时间代理，因为在Cardano区块链上，slot以恒定的速率走过\nnewtype Slot = Slot { getSlot :: Integer }\n```\n\n`SlotRange`实际上是`Interval Slot`的别名.\n\n### [Interval间隔](https://github.com/input-output-hk/plutus/blob/master/plutus-ledger-api/src/Plutus/V1/Ledger/Interval.hs)\n\n`Interval`就是一个`Slot`的范围，从`From`到`To`:\n```haskell\ndata Interval a = Interval { \n        ivFrom :: LowerBound a, \n        ivTo :: UpperBound a \n    }\n\n-- | 一个Neg(负无穷大)和Pos(正无穷大)的集合\n-- | Finite(有限的)\ndata Extended a = NegInf | Finite a | PosInf\n```\n`Interval`在任意一边都可以是无界的，`From`不一定是一个特定的`slot`，它也可能是时间的开始(`NegInf`)，尽管实际上这不会超过我们的`Genesis slot`(创世)，因为这是我们的起始`slot`; `To`也是一样，也可以分别定义为时间的结束(`PosInf`）\n\n\n#### 构造 Interval\n\n```haskell\n-- `interval a b` 包括所有大于或等于a且小于b的值.\n-- 因此，它包括a，但不包括b\ninterval :: a -> a -> Interval a\ninterval s s' = Interval (lowerBound s) (upperBound s')\n\n-- 只有一个从a到a的slot\nsingleton :: a -> Interval a\nsingleton s = interval s s\n\n-- 包含所有大于或等于a的值，所以从a到无穷大\nfrom :: a -> Interval a\nfrom s = Interval (lowerBound s) (UpperBound PosInf True)\n\n-- 包括所有小于a的值 \nto :: a -> Interval a\nto s = Interval (LowerBound NegInf True) (upperBound s)\n\n-- | 这是一个覆盖每个slot的Interval\nalways :: Interval a\nalways = Interval (LowerBound NegInf True) (UpperBound PosInf True)\n\n-- | 一个空的间隔\nnever :: Interval a\nnever = Interval (LowerBound PosInf True) (UpperBound NegInf True)\n```\n\n#### 校验 Interval\n\n上一小节我们了解到了如何创建`Interval`, 这一小节我们来看看如何校验`Interval`:\n\n```haskell\n-- | 检查值a是否是在一个间隔内\nmember :: Ord a => a -> Interval a -> Bool\nmember a i = i `contains` singleton a\n\n-- | 检查两个间隔是否重叠，即是否有一个值是两个间隔的成员\noverlaps :: Ord a => Interval a -> Interval a -> Bool\noverlaps l r = isEmpty (l `intersection` r)\n\n-- | `intersection a b`: 包含在a和b(如果存在)中的最大间隔\nintersection :: Ord a => Interval a -> Interval a -> Interval a\nintersection (Interval l1 h1) (Interval l2 h2) = Interval (max l1 l2) (min h1 h2)\n\n-- | `hull a b`: 包含a和b的最小间隔\nhull :: Ord a => Interval a -> Interval a -> Interval a\nhull (Interval l1 h1) (Interval l2 h2) = Interval (min l1 l2) (max h1 h2)\n\n-- | 如果间隔b完全包含在a中，则@a `contains` b@为true.\n-- | 也就是说，如果对于每个条目s，\n-- | 如果`member s b`(s在b间隔内)，则`member s a`(s也一定在a间隔内)\ncontains :: Ord a => Interval a -> Interval a -> Bool\ncontains (Interval l1 h1) (Interval l2 h2) = l1 <= l2 && h2 <= h1\n\n-- | 检查一个间隔是否是空的\nisEmpty :: Ord a => Interval a -> Bool\nisEmpty (Interval (LowerBound v1 in1) (UpperBound v2 in2)) = case v1 `compare` v2 of\n    LT -> True\n    GT -> False\n    EQ -> not (in1 && in2)\n\n-- | 检查值是否早于间隔的开端\nbefore :: Ord a => a -> Interval a -> Bool\nbefore h (Interval f _) = lowerBound h < f\n\n-- | 检查值是否晚于间隔的结尾\nafter :: Ord a => a -> Interval a -> Bool\nafter h (Interval _ t) = upperBound h > t\n```\n\n#### 测试 Interval\n```shell\n# 进入到课程03目录\ncd ~/haskell/plutus-pioneer-program/code/week03\n\n# 启动repl\ncabal repl\n```\n\n```haskell\nλ > -- 导入模块\nλ > import Plutus.V1.Ledger.Interval\nλ > \nλ > -- Interval {ivFrom = LowerBound (Finite 0) True, ivTo = UpperBound (Finite 10) True}\nλ > a = interval 0 (10 :: Integer)\nλ > \nλ > b = interval 1 (5 :: Integer)\nλ > c = interval 0 (11 :: Integer)\nλ >\nλ > a `contains` b\nTrue\nλ > a `contains` c\nFalse\nλ > \nλ > 0 `member` a\nTrue\nλ > \nλ > 11 `member` a\nFalse\nλ > \nλ > -- Interval {ivFrom = LowerBound (Finite 3) True, ivTo = UpperBound (Finite 3) True}\nλ > a1 = singleton (3 :: Integer)\nλ >\nλ > 10 `member` (interval 0 (10 :: Integer))\nTrue\nλ >\nλ > 10 `member` (interval 10 (11 :: Integer))\nTrue\nλ >\nλ > intersection (interval 9 (10 :: Integer)) (interval 10 (11 :: Integer))\nInterval {ivFrom = LowerBound (Finite 10) True, ivTo = UpperBound (Finite 10) True}\nλ >\nλ > overlaps (interval 0 (10 :: Integer)) (interval 10 (11 :: Integer))\nFalse\nλ > \nλ > isEmpty $ intersection (interval 9 (10 :: Integer)) (interval 8 (11 :: Integer))\nTrue\nλ > \nλ > isEmpty $ intersection (interval 9 (10 :: Integer)) (interval 10 (11 :: Integer))\nFalse\nλ > \nλ > intersection (interval 0 (10 :: Integer)) (interval 8 (12 :: Integer))\nInterval {ivFrom = LowerBound (Finite 8) True, ivTo = UpperBound (Finite 10) True}\nλ > \nλ > intersection (interval 9 (10 :: Integer)) (interval 8 (12 :: Integer))\nInterval {ivFrom = LowerBound (Finite 9) True, ivTo = UpperBound (Finite 10) True}\nλ > \nλ > hull (interval 0 (10 :: Integer)) (interval 8 (12 :: Integer))\nInterval {ivFrom = LowerBound (Finite 0) True, ivTo = UpperBound (Finite 12) True}\nλ > \nλ > hull (interval 9 (10 :: Integer)) (interval 8 (12 :: Integer))\nInterval {ivFrom = LowerBound (Finite 8) True, ivTo = UpperBound (Finite 12) True}\nλ > \nλ > from (5 :: Integer)\nInterval {ivFrom = LowerBound (Finite 5) True, ivTo = UpperBound PosInf True}\nλ > \nλ > to (5 :: Integer)\nInterval {ivFrom = LowerBound NegInf True, ivTo = UpperBound (Finite 5) True}\nλ > \nλ > from $ 1 + Slot 4\nInterval {ivFrom = LowerBound (Finite (Slot {getSlot = 5})) True, ivTo = UpperBound PosInf True}\nλ >\n```\n\n## 课程\n\n> 课程合同的内容是: 允许钱包发送`ada`，然后该`ada`将被存储，只能在特定的时间(`slot`)之后并且只能由特定的钱包来抓取.\n> 从第3周开始游乐场增加了10个`lovelaces`的交易费用.\n\n通过游乐场打开\n`plutus-pioneer-program/code/week03/Vesting.hs`文件.\n\n我们设置初始余额为1000个`lovelaces`:\n\n![](01.png)\n\n然后设置以下`action`序列:\n\n![](02.png)\n\n`getPubKeyHash`字段的值我们没有设置(钱包2的公钥哈希值)，我们可以通过两个方法获取到该值:\n\n* 将`getPubKeyHash`字段的值留空，然后执行'评估'操作，就可以在`genesis slot (0)`处，看到两个钱包的`pubkeyhash`:\n![](03.png)\n\n* 使用`repl`命令行\n\n```haskell\nλ > -- 导入模块\nλ > import Wallet.Emulator\nλ > import Ledger\nλ >\nλ > -- 接收一个钱包参数，返回其公钥\nλ > :t walletPubKey\nλ > walletPubKey :: Wallet -> PubKey\nλ >\nλ > -- 基于钱包公钥，生成hash\nλ > :t pubKeyHash\nλ > pubKeyHash :: PubKey -> PubKeyHash\nλ > \nλ > -- 获取钱包2的公钥哈希值\nλ > pubKeyHash $ walletPubKey $ Wallet 2\n39f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f\nλ > \n```\n\n得到钱包2的公钥哈希后，将它填入到`getPubKeyHash`字段，重新评估就可以了.\n\n* `genesis slot (slot 0)` 将会分别给两个钱包1000个初始`lovelaces` \n* `Slot 1` 放置100个`lovelace`由钱包2抓取(指定的10个`slot`通过后)\n\n费用: 10个`lovelaces`.\n\n目前钱包1剩下: \n```shell\n1000 - 费用 10 - vesting 100 = 890个lovelaces\n```\n目前脚本有: 100个`lovelaces`:\n\n![](04.png)\n\n等待10个`slot`后，钱包2将会抓取到100个`lovelaces`:\n\n![](05.png)\n\n可以看到，抓取操作也支付了10个`lovelaces`费用，钱包2最终得到90个`lovelaces`.\n\n### Vesting源码解读\n\n玩耍过该合同后，我们来看下它的源代码,\n查看`~/haskell/plutus-pioneer-program/code/week03/Vesting.hs`文件:\n\n```haskell\n\n-- Datum数据\ndata VestingDatum = VestingDatum\n    { beneficiary :: PubKeyHash -- ^ 受益人的公钥hash，在我们例子中是: 钱包2\n    , deadline    :: Slot -- 截止时间，在我们例子中是: slot 10\n    } deriving Show\n\n-- 验证器\nmkValidator :: VestingDatum -> () -> ScriptContext -> Bool\nmkValidator dat () ctx =\n    traceIfFalse \"beneficiary's signature missing\" checkSig &&\n    traceIfFalse \"deadline not reached\"            checkDeadline\nwhere\n    -- 从上下文中获取交易信息\n    info :: TxInfo\n    info = scriptContextTxInfo ctx\n\n    -- 检查受益人的签名是否在交易的公钥哈希列表中存在\n    checkSig :: Bool\n    checkSig = beneficiary dat `elem` txInfoSignatories info\n\n    -- 检查截止时间(包含所有大于等于截止时间的值)\n    -- 是否完全包含`txInfoValidRange`(交易的有效范围)\n    checkDeadline :: Bool\n    checkDeadline = from (deadline dat) `contains` txInfoValidRange info\n```\n\n### Parameterized\n\n查看`~/haskell/plutus-pioneer-program/code/week03/Parameterized.hs`文件, 该文件与上一小节的`Vesting.hs`文件基本上一样，唯一区别是我们不再使用`VestingDatum`类来持有我们的受益人和截止日期字段，而是使用一个额外的参数来调用我们的`validator`(验证器)，在本例中是使用`VestingParam`. 它包含与`VestingDatum`相同的数据，只是现在通过参数化它，得到了一个关键的区别.\n\n如果没有参数化功能，这个智能合约就只有一个实例，现在，我们可以很容易地拥有同一个合约的多个实例，这些实例只是具有不同的参数(`VestingParam`).\n\n```haskell\n-- VestingParam 定义\ndata VestingParam = VestingParam\n    { beneficiary :: PubKeyHash\n    , deadline    :: Slot\n    } deriving Show\n\nPlutusTx.unstableMakeIsData ''VestingParam\n-- 使VestingParam实现lift\nPlutusTx.makeLift ''VestingParam\n\n-- 新增了一个VestingParam参数\nmkValidator :: VestingParam -> () -> () -> ScriptContext -> Bool\nmkValidator = ... -- 和之前的代码一致\n\n-- 样板代码\ndata Vesting\ninstance Scripts.ScriptType Vesting where\n    -- 将Datum 设置为()单元类型\n    type instance DatumType Vesting = ()\n    type instance RedeemerType Vesting = ()\n\ninst :: VestingParam -> Scripts.ScriptInstance Vesting\ninst p = Scripts.validator @Vesting\n    -- 重要变化在这里\n    ($$(PlutusTx.compile [|| mkValidator ||]) `PlutusTx.applyCode` PlutusTx.liftCode p)\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    -- 将Datum 设置为()单元类型\n    wrap = Scripts.wrapValidator @() @()\n\n-- 接收了 VestingParam 参数\nvalidator :: VestingParam -> Validator\nvalidator = Scripts.validatorScript . inst\n\n-- 接收了 VestingParam 参数\nscrAddress :: VestingParam -> Ledger.Address\nscrAddress = scriptAddress . validator\n```\n\n`PlutusTx.compile`函数是一个以`Haskell`代码为参数的函数，您可以使用`quote`(引用)将其提供给它，如果没有`quote`，`GHC`将尝试处理/编译`mkValidator`而不是将`Haskell`代码原样传递给`compile`函数.\n\n在`PlutusTx.compile [|| mkValidator ||]`中`mkValidator`将会被转换成`Plutus`代码，这是`Plutus`已编译的代码，然而`validator`是一个期待额外参数(`VestingParam`)的函数，但是`VestingParam`是`Haskell`代码，而我们已编译的函数是`Plutus`已编译代码，因此，我们使用`liftCode`来提升/转换/序列化，以便`Plutus`已编译代码可以理解/处理参数。\n\n现在我们有了一个编译成`Plutus`代码的函数(`validator`)，然后使用`PlutusTx.liftCode`将`VestingParam`参数提升到它的`Plutus`表示形式，最后我们只需要使用`PlutusTx.applyCode`函数将这个参数应用到函数。\n\n当编译器处理这个过程时，`splice`(拼接)的结果将是`Plutus`代码，但将其编码/表示/序列化为`Haskell`代码/数据，以供`validator`函数获取。\n\n## 作业\n\n### 作业1\n\n> 这应该验证受益人1是否已经签署了交易并且当前`slot`是在截止日期之前或截止日期时，或者受益人2是否已经签署了交易并且截止日期已经过去。\n\n* 受益人1 -> 在这种情况下为钱包2，在截止日期过去之前，我们发送ada的钱包来赎回.\n* 受益人2 -> 在这种情况下为钱包1，发送ada的钱包，如果在截止日期之前没有取回，我们想取回我们的ada(否则将在本合同中永远丢失）\n\n打开`~/haskell/plutus-pioneer-program/code/week03/Homework1.hs`文件:\n\n```haskell\n\ndata VestingDatum = VestingDatum\n    { beneficiary1 :: PubKeyHash -- ^ 受益人1\n    , beneficiary2 :: PubKeyHash -- ^ 受益人2\n    , deadline     :: Slot       -- ^ 截止日期\n    } deriving Show\n\nmkValidator :: VestingDatum -> () -> ScriptContext -> Bool\n-- mkValidator _ _ _ = False -- FIX ME!\nmkValidator dat () ctx\n    -- to获取所有小于(截止日期)的值\n    -- 我们希望能在(截止日期)前抓取到资金\n    | (beneficiary1 dat `elem` sigs) && (to (deadline dat) `contains` range) = True\n    -- from获取所有大于等于(1 + deadline dat)的值\n    -- 截止日期已经过去\n    | (beneficiary2 dat `elem` sigs) && (from (1 + deadline dat) `contains` range) = True\n    | otherwise = False\nwhere\n    -- 获取交易信息\n    info :: TxInfo\n    info = scriptContextTxInfo ctx\n\n    -- 获取签名信息\n    sigs :: [PubKeyHash]\n    sigs = txInfoSignatories info\n\n    -- 获取交易有效范围\n    range :: SlotRange\n    range = txInfoValidRange info\n```\n\n### 作业2\n\n打开`~/shell/plutus-pioneer-program/code/week03/Homework2.hs`文件:\n\n```haskell\n-- 接收一个PubKeyHash参数和一个包含Slot的Datum参数\nmkValidator :: PubKeyHash -> Slot -> () -> ScriptContext -> Bool\nmkValidator _ _ _ _ = False -- FIX ME!\n\ndata Vesting\ninstance Scripts.ScriptType Vesting where\n    -- 设置Datum类型为Slot\n    type instance DatumType Vesting = Slot\n    type instance RedeemerType Vesting = ()\n\ninst :: PubKeyHash -> Scripts.ScriptInstance Vesting\ninst = undefined -- IMPLEMENT ME!\n\nvalidator :: PubKeyHash -> Validator\nvalidator = undefined -- IMPLEMENT ME!\n\nscrAddress :: PubKeyHash -> Ledger.Address\nscrAddress = undefined -- IMPLEMENT ME!\n```\n\n我们必须用一个参数(`PubKeyHash`)和一个包含`Slot`的`Datum`参数来实现一个`validator`.\n\n在`parameterized.hs`中，这两个值都位于`VestingParam`中，而现在它们都是单独的值，一个作为`parameter`，一个作为`Datum`.\n\n```haskell\nmkValidator :: PubKeyHash -> Slot -> () -> ScriptContext -> Bool\nmkValidator pkh s () ctx =\n    traceIfFalse \"beneficiary's signature missing\" checkSig &&\n    traceIfFalse \"deadline not reached\" checkDeadline\nwhere\n    info :: TxInfo\n    info = scriptContextTxInfo ctx\n\n    checkSig :: Bool\n    checkSig = pkh `elem` txInfoSignatories info\n\n    checkDeadline :: Bool\n    checkDeadline = from s `contains` txInfoValidRange info\n\ninst :: PubKeyHash -> Scripts.ScriptInstance Vesting\ninst p = Scripts.validator @Vesting\n    ($$(PlutusTx.compile [|| mkValidator ||]) `PlutusTx.applyCode` PlutusTx.liftCode p)\n    $$(PlutusTx.compile [|| wrap ||])\nwhere\n    -- 将 datum 设置为 @Slot\n    wrap = Scripts.wrapValidator @Slot @()\n\nvalidator :: PubKeyHash -> Validator\nvalidator = Scripts.validatorScript . inst\n\nscrAddress :: PubKeyHash -> Ledger.Address\nscrAddress = scriptAddress . validator\n```\n\n","tags":["Parameterized Contracts"]},{"title":"Plutus-Pioneer-lesson-02","url":"/blog/2021/04/13/Plutus-Pioneer-lesson-02/","content":"\n> 第二节课的合同内容为: 钱包1将向脚本`gift`(赠送)一些`lovelaces`, 然后钱包2尝试`grab`(夺取)脚本中锁定的资金. 另外这节课的主题是`Validator`(验证器), \b我们将会介绍其参数.\n\n### 礼物\n通过游乐场运行`Gift.hs`脚本.\n然后设置动作序列: 钱包1赠送3个`lovelaces`给脚本, 然后脚本2尝试夺取资金:\n\n![](01.png)\n\n根据合同执行结果可以看到，钱包1现在剩下7个`lovelaces`, 而钱包2现在拥有13个`lovelaces`.\n\n![](02.png)\n\n现在所有人都可以抢夺脚本中的资金，但是通常我们不想这样，因此我们需要`Validator`(验证器脚本)来进行控制。\n\n### 低级别，无类型的\b，链上验证脚本\n#### mkValidator函数\n\n```haskell\n-- Gift.hs文件的30-32行\n{-# INLINABLE mkValidator #-}\nmkValidator :: Data -> Data -> Data -> ()\nmkValidator _ _ _ = ()\n```\n\n`mkValidator`函数需要3个[Data](https://github.com/input-output-hk/plutus/blob/master/plutus-tx/src/PlutusTx/Data.hs)类型(后面介绍)的参数，然后返回`()`单元类型.\n函数实现中的`_`表示我们不关心参数值是什么，然后总是返回`()`.\n`{-# INLINABLE mkValidator #-}`此标注是为了让编译器知道函数`mkValidator`可以用作内联函数.\n三个参数分别为`Datum`,`Redeemer`和`Context`:\n\n* `Datum`只是包含在`UTxO`内部的一条数据，因此可用于将状态保持在智能合约中。可用于向`Validator`脚本提供更多信息(例如，也可用于针对`Redeemer`进行验证)\n \n* `Redeemer data`是由想要花费一些硬币的人提供的。在验证器逻辑内部，我们可以使用此数据执行一些检查。例如，如果某人想要访问合同中查看的资金，则他可能需要提供密码或其他内容(这取决于您的用例).`Redeemer`是一种逻辑，用于验证`UTXO`是否可以被`spent`(花费)/`burned`(烧掉)等, 用于验证调用脚本的用户是否可以解锁资金(例如，用于解锁的密码).\n\n* `Context` 只是被验证的交易，由`validator`节点提供。它包含有关交易的信息，您可以访问交易的输入和输出以及进行交易的人。\n\n#### Validator Script(验证程序脚本)\n\n```haskell\n-- Gift.hs文件的34-35行\nvalidator :: Validator\nvalidator = mkValidatorScript $$(PlutusTx.compile [|| mkValidator ||])\n\n-- [||..||] 的类型为 Q (TExp a)\n-- compile函数的签名\ncompile :: Q (TExp a) -> Q (TExp (CompiledCode a))\n\n-- mkValidatorScript函数的签名\nmkValidatorScript :: CompiledCode (Data -> Data -> Data -> ()) -> Validator\nmkValidatorScript = Validator . fromCompiledCode\n```\n为了使`mkValidator`函数可以在区块链上生效，我们需要把它编译为`Plutus Core`代码. `PlutusTx.compile`函数需要一段代码(由`Haskell`数据类型表示，该数据类型具有所有`Haskell`语法构造的显式构造函数)。您可以通过手工创建该类型的值来显式传递该参数，但这非常繁琐。相反，您可以使用`Oxford bracket`(准引用)来引用`Haskell`值(如本例中的`mkValidator`,因此需要`{-# INLINABLE mkValidator #-}`标注)，并将其转换为语法表示形式。\n在`PlutusTx.compile [|| mkValidator ||]`中，`mkValidator`将转换为`Plutus`代码, 这是`Plutus`已编译的代码.\n\n#### Script Address(脚本地址)\n\n我们需要基于我们刚创建的`validator`脚本，生成一个`hash`:\n```haskell\n-- Gift.hs文件的37-38行\nvalHash :: Ledger.ValidatorHash\nvalHash = Scripts.validatorHash validator\n```\n\n有了`hash`以后，我们可以生成脚本地址:\n\n```haskell\n-- Gift.hs文件的40-41行\nscrAddress :: Ledger.Address\nscrAddress = ScriptAddress valHash\n```\n\n#### 钱包代码\n从`Gift.hs`文件的43行开始:\n```haskell\n-- Gift.hs文件的40-41行\ntype GiftSchema =\nBlockchainActions\n    .\\/ Endpoint \"give\" Integer\n    .\\/ Endpoint \"grab\" ()\n```\n这里定义了我们的端点`give`(赠送)和`grab`(抓取)，其中`give`接收一个`Integer`类型的参数.\n在游乐场中，我们可以使用这两个端点.\n\n#### 错误处理(烧掉)\n\n`~/haskell/plutus-pioneer-program/code/week02/src/Week02/Burn.hs`文件的第31-33行:\n```haskell\n{-# INLINABLE mkValidator #-}\nmkValidator :: Data -> Data -> Data -> ()\nmkValidator _ _ _ = traceError \"NO WAY!\"\n```\n您仍然可以通过`give`端点将资金发送到该脚本中，但是该验证器总是返回错误`NO WAY!`, 因此您将永远无法在从该脚本中取出资金，从本质上说，这将烧掉发送到该脚本到资金，因为它只接收资金，但不释放资金。\n\n#### FortyTwo\n`～/haskell/plutus-pioneer-program/code/week02/src/Week02/FortyTwo.hs`文件的第31-33行:\n```haskell\n{-# INLINABLE mkValidator #-}\nmkValidator :: Data -> Data -> Data -> ()\nmkValidator _ r _\n    | r == I 42 = ()\n    | otherwise = traceError \"wrong redeemer\"\n```\n在该例子中，我们检查第二个参数`Redeemer`的值是否为42，如果是，则校验通过，否则抛出错误异常.\n这里为`I 42`,是因为我们使用的是`Data`类型(后面介绍)\n\n\n### 高级别的，类型化的，链上验证脚本\n`～/haskell/plutus-pioneer-program/code/week02/src/Week02/Typed.hs`文件的第31-33行:\n```haskell\n{-# INLINABLE mkValidator #-}\nmkValidator :: () -> Integer -> ValidatorCtx -> Bool\nmkValidator () r _\n    | r == 42   = True\n    | otherwise = False\n```\n该示例中，我们使用指定类型的参数，不再使用`Data`类型。\n* `Datum`接收`()`单元类型的参数.\n* `Redeemer`接收`Integer`类型的参数(同时，我们不再使用`I 42`进行比较判断, 而是使用`42`).\n* `Context`接收`ValidatorCtx`类型的参数.\n* 验证器现在返回`Bool`类型，`True`为成功，`False`为失败(之前返回的是`()`单元类型).\n\n```haskell\n-- Typed.hs的38-48行，还有一些样板代码\ndata Typed\ninstance Scripts.ScriptType Typed where\n    -- 这里设置Datum类型为()\n    type instance DatumType Typed = ()\n    -- 这里设置Redeemer类型为Integer\n    type instance RedeemerType Typed = Integer\n\ninst :: Scripts.ScriptInstance Typed\ninst = Scripts.validator @Typed\n    $$(PlutusTx.compile [|| mkValidator ||])\n    $$(PlutusTx.compile [|| wrap ||])\nwhere\n    -- 这里设置为: @() 和 @Integer\n    wrap = Scripts.wrapValidator @() @Integer\n```\n\n#### 自定义数据类型\n\n`～/haskell/plutus-pioneer-program/code/week02/src/Week02/IsData.hs`文件的第37-39行:\n```haskell\n{-# INLINABLE mkValidator #-}\nmkValidator :: () \n        -> MySillyRedeemer \n        -> ValidatorCtx\n        -> Bool\nmkValidator () (MySillyRedeemer r) _ = \n        traceIfFalse \"wrong redeemer\" $ r == 42\n```\n在此示例中，我们创建了自己的`Redeemer`类型: `MySillyRedeemer`, 另外我们还使用了`traceIfFalse`函数, 意思是: 如果`r`不等于42的话，将引发错误.\n\n\n```haskell\n-- IsData.hs文件的第32-33行，是MySillyRedeemer类型的声明\nnewtype MySillyRedeemer = MySillyRedeemer Integer\n    deriving Show\n\n-- IsData.hs文件的第35行，是说 将MySillyRedeemer作为Data类型\nPlutusTx.unstableMakeIsData ''MySillyRedeemer\n\n-- IsData.hs文件的第41-51行，同样为一些样板代码\ndata Typed\ninstance Scripts.ScriptType Typed where\n    -- 这里设置Datum类型为()\n    type instance DatumType Typed = ()\n     -- 这里设置Redeemer类型为MySillyRedeemer\n    type instance RedeemerType Typed = MySillyRedeemer\n\ninst :: Scripts.ScriptInstance Typed\ninst = Scripts.validator @Typed\n    $$(PlutusTx.compile [|| mkValidator ||])\n    $$(PlutusTx.compile [|| wrap ||])\nwhere\n    -- 这里设置为: @() 和 @MySillyRedeemer\n    wrap = Scripts.wrapValidator @() @MySillyRedeemer\n```\n\n### 作业1\n文件 `~/haskell/plutus-pioneer-program/code/week02/src/Week02/Homework1.hs`\n\n修复如下`FIX ME`代码:\n\n```haskell\n{-# INLINABLE mkValidator #-}\n-- 当且仅当`redeemer`中的两个布尔值相等时，这应该是有效的！\nmkValidator :: () -> (Bool, Bool) -> ValidatorCtx -> Bool\n--mkValidator _ _ _ = True -- FIX ME!\n-- 包含两个Bool类型的元组，因此这里只需要判断a和b是否相等就行了\nmkValidator () (a, b) _ = traceIfFalse \"wrong redeemer\" $ a == b\n\n-- 如下是一些样板代码\n\ndata Typed\ninstance Scripts.ScriptType Typed where\n-- Implement the instance!\n    -- 设置DatumT类型为()\n    -- 设置Redeemer类型为(Bool, Bool)\n    type instance DatumType Typed = ()\n    type instance RedeemerType Typed = (Bool, Bool)\n\ninst :: Scripts.ScriptInstance Typed\n-- inst = undefined -- FIX ME!\ninst = Scripts.validator @Typed\n    $$(PlutusTx.compile [|| mkValidator ||])\n    $$(PlutusTx.compile [|| wrap ||])\n    where\n        -- 设置为 @()和 @(Bool, Bool)\n        wrap = Scripts.wrapValidator @() @(Bool, Bool)\n\n-- 生成验证器脚本\nvalidator :: Validator\n-- validator = undefined -- FIX ME!\nvalidator = Scripts.validatorScript inst\n\n-- 生成脚本hash\nvalHash :: Ledger.ValidatorHash\n-- valHash = undefined -- FIX ME!\nvalHash = Scripts.validatorHash validator\n\n-- 生成脚本地址\nscrAddress :: Ledger.Address\n-- scrAddress = undefined -- FIX ME!\nscrAddress = ScriptAddress valHash\n\n-- 增加游乐场端点\ntype GiftSchema =\n    BlockchainActions\n        .\\/ Endpoint \"give\" Integer\n        .\\/ Endpoint \"grab\" (Bool, Bool)\n```\n\n再次测试合同，现在只有两个`Bool`类型值相同，才能抓取资金成功，否则将会失败.\n\n![](03.png)\n\n### 作业2\n文件 `~/haskell/plutus-pioneer-program/code/week02/src/Week02/Homework2.hs`\n\n与作业1类似，只是作业2使用了自定义类型`MyRedeemer`:\n```haskell\n-- Homework2.hs文件的第36-39行定义了MyRedeemer类型\ndata MyRedeemer = MyRedeemer\n    { flag1 :: Bool\n    , flag2 :: Bool\n    } deriving (Generic, FromJSON, ToJSON, ToSchema)\n```\n\n只需要判断`flag1`和`flag2`是否相等:\n```haskell\nmkValidator :: () -> MyRedeemer -> ValidatorCtx -> Bool\nmkValidator () (MyRedeemer a b) _ = \n    traceIfFalse \"wrong redeemer\" $ a == b\n```\n\n然后修改样板代码:\n\n```haskell\ndata Typed\ninstance Scripts.ScriptType Typed where\n    type instance DatumType Typed = ()\n    type instance RedeemerType Typed = MyRedeemer\n\ninst :: Scripts.ScriptInstance Typed\ninst = Scripts.validator @Typed\n    $$(PlutusTx.compile [|| mkValidator ||])\n    $$(PlutusTx.compile [|| wrap ||])\n    where\n        wrap = Scripts.wrapValidator @() @MyRedeemer\n\nvalidator :: Validator\nvalidator = Scripts.validatorScript inst\n\nvalHash :: Ledger.ValidatorHash\nvalHash = Scripts.validatorHash validator\n\nscrAddress :: Ledger.Address\nscrAddress = ScriptAddress valHash\n\ntype GiftSchema =\n    BlockchainActions\n        .\\/ Endpoint \"give\" Integer\n        .\\/ Endpoint \"grab\" MyRedeemer\n```\n\n然后可以在操作上尝试:\n\n![](04.png)\n\n### 其他\n\n#### Data类型\n`Data`类型来自`PlutusTx`模块.\n\n```shell\n# 进入到plutus目录启动nix-shell\ncd ~/haskell/plutus\nnix-shell\n\n# 进入到week02目录\ncd ~/haskell/plutus-pioneer-program/code/week02\ncabal repl\n```\n\n```haskell\n-- 导入PlutusTx模块\nλ > import PlutusTx\n-- 查看Data类型\nλ >:i Data\ntype Data :: *\ndata Data\n  = Constr Integer [Data]\n  | Map [(Data, Data)]\n  | List [Data]\n  | I Integer\n  | B bytestring-0.10.10.0:Data.ByteString.Internal.ByteString\n  \t-- Defined in ‘PlutusTx.Data’\ninstance Eq Data -- Defined in ‘PlutusTx.Data’\ninstance Ord Data -- Defined in ‘PlutusTx.Data’\ninstance Show Data -- Defined in ‘PlutusTx.Data’\ninstance IsData Data -- Defined in ‘PlutusTx.IsData.Class’\nλ >\nλ > -- Integer\nλ > myInteger = I 1\nλ > :t myInteger\nmyInteger :: Data\nλ >\nλ > -- Bytestring\nλ > :set -XOverloadedStrings\nλ > myByteString = B \"Hello World\"\nλ > :t myByteString\nmyByteString :: Data\nλ >\nλ > -- List\nλ > myList = List [I 2, I 4, I 6]\nλ > :t myList\nmyList :: Data\nλ > myList\nList [I 2, I 4, I 6]\nλ >\nλ > -- Map\nλ > myMap = Map [(B \"Lang\", B \"Haskell\"), (B \"country\", B \"Plutus\")]\nλ >\nλ > myMap\nMap [(B \"Lang\",B \"Haskell\"),(B \"country\",B \"Plutus\")]\nλ > :t myMap\nmyMap :: Data\nλ >\n```\n\n#### Template Haskell\n\n```haskell\n{-# LANGUAGE TemplateHaskell #-}\n\nvalidator :: Validator\nvalidator = mkValidatorScript \n              $$(PlutusTx.compile [|| mkValidator ||])\n```\n\n`Template Haskell`是一种语言扩展，它用宏功能扩展`Haskell`程序，宏只是输出程序的程序，它们在编译时执行，宏生成的代码(在一个叫做宏扩展的过程中)被编译，就像您自己编写该代码一样，并且将结果放置在定义它的位置。\n\n宏通常由`splices`(拼接)`($$(...))`和`quotes`(引号)`([|| ... ||]])`组成，`splices`用于将节表示为宏，`quotes`内部使用`quotes`来引用程序中的其他`Haskell`代码.\n\n`[||..||])`为引用`类型化的表达式`.\n\n`$$(..)`是`typed splice`的`TH`语法。拼接是将生成的语法插入我们的程序的过程。`splice`构造器接受一个表示语法树的表达式，对其进行求值，然后将产生的语法插入发生拼接的位置。","tags":["Redeemer"]},{"title":"Plutus-Pioneer-lesson-01","url":"/blog/2021/04/08/Plutus-Pioneer-lesson-01/","content":"\n> Plutus Pioneer创新计划旨在在Cardano生态系统内招募和培训开发人员，以便在今年晚些时候将Plutus部署到Cardano主网时为他们做好充分的准备。本次课程为期10周，每周2发布新的课程，该课程涵盖: 函数与数据类型/类型类/Monads/Template Haskell/Plutus游乐场/EUTXO模型/链上与链下代码/Minting策略/状态机/Plutus应用框架/案例研究与实践练习等。于此同时，为了奖励参与者为参加此课程而付出的努力，并对完成整个计划并取得成功的Pioneers进行认证。这些Plutus Pioneer证书将被表示为不可替代的令牌(在测试网上)，并被Plutus合同锁定。Pioneers可以通过构建适当的交易来解锁其个人令牌来证明自己的知识和资格。\n\n## 环境配置\n这里介绍`macos`环境，`windows`环境可以使用`wsl-linux`.\n\n### nix\n```shell\n# 安装nix\nsh <(curl -L https://nixos.org/nix/install) --darwin-use-unencrypted-nix-store-volume\n\n# 编辑~/.config/nix/nix.conf文件，设置 IOHK 二进制缓存\nsubstituters        = https://hydra.iohk.io https://iohk.cachix.org https://cache.nixos.org/\ntrusted-public-keys = hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ= iohk.cachix.org-1:DpRUyj7h7V830dp/i6Nti+NEO2/nhblbov/8MW7Rqoo= cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY=\n\nsandbox = true\nextra-sandbox-paths = /System/Library/Frameworks /System/Library/PrivateFrameworks /usr/lib /private/tmp /private/var/tmp /usr/bin/env\n```\n\n### 课程01\n\n```shell\n# 例如: 安装在用户主目录的haskell文件夹下\ncd ~/haskell\n\n# clone 课程仓库(pioneer)\ngit clone https://github.com/input-output-hk/plutus-pioneer-program.git\n\n# clone plutus项目\ngit clone https://github.com/input-output-hk/plutus.git\n\n# 查看commit id(3746610e53654a1167aeb4c6294c6096d16b0502)\nhead -30 ~/haskell/plutus-pioneer-program/code/week01/cabal.project\noutput: 3746610e53654a1167aeb4c6294c6096d16b0502\n\n# 进入到plutus目录, 检出特定commit id\ncd ~/haskell/plutus\ngit checkout 3746610e53654a1167aeb4c6294c6096d16b0502\n# 构建plutus\nnix build -f default.nix plutus.haskell.packages.plutus-core.components.library\n\n# 启动nix环境\nnix-shell #(wait for it to load)\n\n# 进入到课程01目录，构建\ncd ~/haskell/plutus-pioneer-program/code/week1/\ncabal update\ncabal build\n```\n\n## 启动游乐场\n完成上述步骤后，可以启动游乐场:\n\n```shell\n# 新开一个终端，启动服务器\ncd ~/haskell/plutus/plutus-playground-server\nnix-shell # (wait for it to load)\nplutus-playground-server\n\n# 再打开一个终端，启动客户端\ncd ~/haskell/plutus/plutus-playground-client\nnix-shell # (wait for it to load)\nnpm run start\n\n# 打开浏览器: \nhttps://localhost:8009/\n```\n\n## 第一节课\n\n启动模拟器后，将默认代码删除，然后将`~/haskell/plutus-pioneer-program/code/week01/src/Week01/EnglishAuction.hs`文件的内容拷贝进来，并将模块导入的相关代码删除:\n```haskell\n-- 删除如下代码\nmodule Week01.EnglishAuction\n    ( Auction (..)\n    , StartParams (..), BidParams (..), CloseParams (..)\n    , AuctionSchema\n    , start, bid, close\n    , endpoints\n    , schemas\n    , ensureKnownCurrencies\n    , printJson\n    , printSchemas\n    , registeredKnownCurrencies\n    , stage\n    ) where\n```\n\n点击`compile`按钮，编译合同代码。\n点击`simulate`按钮，将会模拟该合同。\n\n课程01的合同代码逻辑为:\n钱包1准备拍卖`NFT`令牌(1`T`)，钱包2和钱包3将竞标(通过`添加钱包`按钮可以增加更多钱包).\n每个钱包都有`bid`(出价)，`close`(关闭)，`start`(启动)三个按钮。\n* `bid`   -> 出价`x` `lovelaces`\n* `start` -> 使用`getSlot`(竞价持续多长时间)和`spMinBid`(最小`lovelaces`限制)来启动竞标过程\n* `close` -> 关闭竞标，将`NFT`令牌给到最高出价者\n\n默认每个钱包都有10个`lovelaces`和10个`T`, 钱包1将会发起拍卖，因此我们将钱包1的`T`改为1，钱包2和钱包3的`T`改为0:\n![](01.png)\n\n### 拍卖流程\n1. 因为钱包1将会拍卖自己的令牌`T`，因此我们需要为钱包1增加一个`start`动作(点击钱包1的`start`按钮)，并设置相应参数:\n* getSlot: 20(竞标将在`slot`20上`close`)\n* spMinBid: 3(至少需要3个`lovelaces`)\n* spCurrency: 66(`T`令牌的货币符号, 将在以后的课程中进行解释)\n* spToken: `T`(令牌)\n\n![](02.png)\n\n1. 然后我们需要添加一个`wait`动作(1`slot`), 这将使所有`action`有时间执行。\n\n![](03.png)\n\n3. 现在钱包2将出价3个`lovelaces`来开始竞标。\n点击钱包2上的`bid`按钮，然后使用以下参数更新操作:\n\n* spCurrency: 66(`T`令牌的货币符号, 将在以后的课程中进行解释)\n* spToken: `T`(令牌)\n* bpBid: 3(出价多少个`lovelaces`)\n\n![](04.png)\n\n4. 然后再次增加一个`wait`动作(1`slot`)\n![](03.png)\n\n1. 然后钱包3开始出价(点击钱包3上的`bid`按钮)(使用5个`lovelaces`):\n![](05.png)\n\n6. 然后我们再次增加一个`wait`动作，选择`wait until`,然后填写`20 slot`(注意: 在第1步时，我们已设置在20 `slot`时`close`竞标过程)\n![](06.png)\n\n7. 然后，我们还需要为钱包1增加一个`close`动作，来确定最终投标顺序.\n![](07.png)\n\n8. 最后，在增加一个`wait`动作(1`slot`)\n![](03.png)\n\n### 评估\n完成如上过程后，我们需要点击`Evaluate`按钮来完成评估。\n你将会看到如下各个`slots`内容:\n![](08.png)\n\n* Slot 0, Tx 0 \n  * `Genesis`(创始)`slot`, 在这将会设置所有内容: 钱包1有1个`T`和10个`lovelaces`, 钱包2和钱包3分别有10个`lovelaces`\n* Slot 1, Tx 0 \n  * `start`动作，这是钱包1将它的1`T`转移到合同中的地方\n* Slot 2, Tx 0 \n  * 钱包2出价3个`lovelaces`, 此时合同中有1个`T`和3个`lovelaces`.\n* Slot 3, Tx 0\n  * 钱包3出价5个`lovelaces`, 此时合同中有1个`T`和5个`lovelaces`, 钱包2的3个`lovelaces`已被退回\n* Slot 20, Tx 0\n  * 钱包3赢得最终的竞标，得到了1个`T`, 钱包1得到了5个`lovelaces`. 此时合同中没有任何东西，它已经将所有东西交给了其合法所有者.\n\n检查`Final balances`，可以看到最终结果，钱包3现在有1个`T`:\n![](09.png)\n\n## 其他\n> `Cardano`的时间划分为了几个`epoch`(纪元)，然后每个`epoch`再次被划分为`slots`(插槽),`slot`是可以创建`block`(块)的较短时间段, `Ouroboros`股权证明算法，为每个`slot`随机分配一个`stake pool`(股份池), 然后，所谓的`slot leader`为此`slot`创建相应的`block`, 在创建`epoch`之前，已经进行了`slot leader`的选举。每个`slot`通常都包含一个`block`，但是如果所选的池性能不好，则可能不时有一个空`slot`。对于`Cardano`协议，空`slot`是可以的，但是大多数`block`必须在一个`epoch`期间生成，以保持有保证的安全性。每20秒有一个`slot`，每个`epoch`包含21600个`slots`。因此，每5天就有一个新`epoch`。\n\n![](10.png)\n\n`/`表示空`slot`\n\n>`Cardano`的设计方式是可以并行运行多个`epoch`。如果假设单线程性能为每秒`X`个事务，并且并行运行另一个`epoch`，那么现在的性能是原来每秒事务量的两倍。如果并行运行另一个`epoch`，则性能将变为每秒原始事务量的3倍，依此类推。您可以并行运行多达`N`个`epoch`，无论网络的需求是什么。`N`仅受网络吞吐量的限制。这使得`Cardano`具有高度的可扩展性.\n\n![](11.png)","tags":["拍卖"]},{"title":"状态模式","url":"/blog/2021/02/21/状态模式/","content":"\n### 状态模式\n\n#### 定义\n**状态模式**允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。\n\n#### 案例\n\n```java\n\npublic class Machine {\n    // 等待接收保单\n    private final static int WAIT_ING = 0;\n    // 解析中\n    private final static int PARSE_ING = 1;\n    // 智能核保中\n    private final static int SMART_UNDERWRITE = 2;\n    // 通知核保结果\n    private final static int NOTIFY_RESULT = 10;\n    \n    // 人保\n    // private final static int MANUAL_UNDERWRITE = 3;\n\n    // 当前状态\n    private int state = WAIT_ORDER;\n\n    // 保单号\n    String orderNum = \"\";\n\n    public Machine(){\n        this.orderNum = orderNum;\n        // 接收到新保单，设置状态为解析中\n        if(StringUtils.isNotEmpty(orderNum)){\n            state = PARSE_ING;\n        }\n    }\n\n    /**新保单**/\n    public void newOrder(String orderNum){\n       this.orderNum = orderNum;\n       this.state = PARSE_ING;\n    }\n\n    public void handler(){\n        if(state == WAIT_ING){\n            print \"没有保单可以处理\"\n\n        }else if(state == PARSE_ING){\n            // 解析中\n            state = SMART_UNDERWRITE;\n\n        }else if(state == SMART_UNDERWRITE){\n            // 智核中\n            state = NOTIFY_RESULT;\n        }\n        // else if(state == MANUAL_UNDERWRITE){\n        //     // 人核中\n        //     state = NOTIFY_RESULT;\n\n        // }\n        else if(state == NOTIFY_RESULT){\n            // 通知核保结果\n            sendNotify();\n        }\n    }\n\n    /**重新执行智核**/\n    public void reSmartUnderWrite(){\n         if(state == WAIT_ING){\n            print \"不可以重新执行智核\"\n        }else if(state == PARSE_ING){\n           print \"不可以重新执行智核\"\n\n        }else if(state == SMART_UNDERWRITE){\n           print \"正在执行智核，稍后重试\"\n        }else if(state == MANUAL_UNDERWRITE){\n            state = SMART_UNDERWRITE;\n            print \"回退到智核成功\"\n        }else if(state == NOTIFY_RESULT){\n            print \"已通知，不可以重新执行智核\"\n        }\n    }\n\n    /**发送通知**/\n    public void sendNotify(){\n        if(state == NOTIFY_RESULT){\n            int result = push();\n            if(result.ok()){\n                print \"push success\";\n            }else{\n                print \"push error\";\n            }\n        }else if(){\n\n        }else if(){\n\n        }\n    }\n\n    public void monitor(){\n        print \"当前状态: \"+ state;\n    }\n\n    /**测试**/\n    public static void main(String[] args) { \n       Machine machine = new Machine();\n       machine.monitor();\n\n       machine.newOrder(\"1000\");\n       machine.handler();\n       machine.monitor();\n       machine.handler();\n    }\n}\n\n```\n\n#### 使用状态模式\n```java\npublic class Machine {\n    // 等待接收保单\n    State waitOrderState;\n    // 解析中\n    State parseState;\n    // 智能核保中\n    State smartUnderwriteState;\n    // 通知核保结果\n    State notifyResultState;\n    // 人保\n    State manualUnderwriteState;\n\n    // 当前状态\n    State state = waitOrderState;\n\n    // 保单号\n    String orderNum = \"\";\n\n    public Machine(){\n       waitOrderState = new WaitOrderState(this);\n       parseState = new ParseState(this);\n       smartUnderwriteState = new SmartUnderwriteState(this);\n       notifyResultState = new NotifyResultState(this);\n       manualUnderwriteState = new ManualUnderwriteState(this);\n    }\n\n    void changeState(State state){\n        this.state = state;\n    }\n\n    /**新保单**/\n    public void newOrder(String orderNum){\n       state.newOrder(orderNum);\n    }\n\n    public void handler(){\n        state.handler();\n    }\n\n    /**重新执行智核**/\n    public void reSmartUnderWrite(){\n        state.reSmartUnderWrite();\n    }\n\n    /**发送通知**/\n    public void sendNotify(){\n        state.sendNotify();\n    }\n\n    public void monitor(){\n        print \"当前状态: \"+ state;\n    }\n\n    /**测试**/\n    public static void main(String[] args) { \n       Machine machine = new Machine();\n       machine.monitor();\n\n       machine.newOrder(\"1000\");\n       machine.handler();\n       machine.monitor();\n       machine.handler();\n    }\n}\n```\n\n```java\npublic interface State {\n    void newOrder(String orderNum);\n    void reSmartUnderWrite();\n    void sendNotify();\n    void handler();\n}\n\npublic class WaitOrderState implements State{\n    Machine machine;\n    public WaitOrderState(Machine machine){\n        this.machine = machine;\n    }\n    void newOrder(String orderNum){\n        print \"收到新保单请求\";\n        handler();\n    }\n    void reSmartUnderWrite(){\n        throw new UnsupportedOperationException(\"不支持该操作\");\n    }\n    void sendNotify(){\n        throw new UnsupportedOperationException(\"不支持该操作\");\n    }\n    void handler(){\n        // ... 处理逻辑 ...\n        machine.changeState(machine.getParseState());\n    }\n}\n\npublic class ParseState implements State{\n    Machine machine;\n    void newOrder(String orderNum){\n        throw new UnsupportedOperationException(\"不支持该操作\");\n    }\n    void reSmartUnderWrite(){\n        throw new UnsupportedOperationException(\"不支持该操作\");\n    }\n    void sendNotify(){\n        throw new UnsupportedOperationException(\"不支持该操作\");\n    }\n    void handler(){\n        // ... 处理逻辑 ...\n        // 进入到智核状态\n        machine.changeState(machine.getSmartUnderwriteState());\n    }\n}\n\npublic class SmartUnderwriteState implements State{\n    Machine machine;\n    void newOrder(String orderNum){\n        throw new UnsupportedOperationException(\"不支持该操作\");\n    }\n    void reSmartUnderWrite(){\n        throw new UnsupportedOperationException(\"不支持该操作\");\n    }\n    void sendNotify(){\n        throw new UnsupportedOperationException(\"不支持该操作\");\n    }\n    void handler(){\n        // ... 处理逻辑 ...\n        if(enableManual()){\n            // 开启人核，进入到人核状态\n            machine.changeState(machine.getManualUnderwriteState());\n        }else{\n            // 未开启人核，进入到推送状态\n            machine.changeState(machine.getNotifyResultState());    \n        }\n    }\n}\n\npublic class ManualUnderwriteState implements State{\n    Machine machine;\n    void newOrder(String orderNum){\n        throw new UnsupportedOperationException(\"不支持该操作\");\n    }\n    void reSmartUnderWrite(){\n        print \"重新执行智核\";\n        // ... 处理逻辑 ...\n        // 进入到智核状态\n        machine.changeState(machine.getSmartUnderwriteState());\n    }\n    void sendNotify(){\n        throw new UnsupportedOperationException(\"不支持该操作\");\n    }\n    void handler(){\n        // ... 处理逻辑 ...\n        // 进入到推送状态\n        machine.changeState(machine.getNotifyResultState());\n    }\n}\n\npublic class NotifyResultState implements State{\n    Machine machine;\n    void newOrder(String orderNum){\n        throw new UnsupportedOperationException(\"不支持该操作\");\n    }\n    void reSmartUnderWrite(){\n        throw new UnsupportedOperationException(\"不支持该操作\");\n    }\n    void sendNotify(){\n        print \"发送通知\";\n    }\n     void handler(){\n        // ... 处理逻辑 ...\n        // 进入到其他状态\n        machine.changeState(machine.getWaitOrderState());\n    }\n}\n```\n\n#### 类图\n\n![](状态模式/class-graph.png)\n\n##### 套用类图\n\n![](状态模式/demo-graph.png)\n\n\n#### 策略模式/模版方法/状态模式\n\n* 策略模式 \n  * 将可以互换的行为封装起来，然后使用委托的方法，决定使用哪一个\n* 模版方法\n  * 由子类决定如何实现算法中的某些步骤\n* 状态模式\n  * 封装基于状态的行为，并将行为委托到当前状态\n\n\n","tags":["重构"]},{"title":"装饰者模式","url":"/blog/2021/02/21/装饰者模式/","content":"\n### 装饰者模式\n\n#### 常见使用场景\n\n* 扩展一个类的功能，或者为该类添加一些附加职责\n* 对象需要动态添加或者撤销功能\n\n#### 案例\n\n```java\n/**裸险**/\npublic class NakedInsurance {\n\n    /**包含的责任项**/\n    protected String getDuty() {\n        return \"身故\";\n    }\n\n    /**价格**/\n    protected BigDecimal getPrice() {\n        return new BigDecimal(10.00);\n    }\n}\n\n/**半险**/\npublic class HalfInsurance extends NakedInsurance {\n\n    @Override\n    protected String getDuty() {\n        return super.getDuty() + \"/重大疾病\";\n    }\n\n    @Override\n    protected BigDecimal getPrice() {\n        return super.getPrice().add(new BigDecimal(10.00));\n    }\n}\n\n/**全险**/\npublic class FullInsurance extends HalfInsurance {\n\n    @Override\n    protected String getDuty() {\n        return super.getDuty() + \"/意外医疗/意外伤害/住院医疗/住院补贴\";\n    }\n\n    @Override\n    protected BigDecimal getPrice() {\n        return super.getPrice().add(new BigDecimal(40.00));\n    }\n}\n\n/**两次半险**/\npublic class TwiceHalfInsurance extends HalfInsurance {\n\n    @Override\n    protected String getDuty() {\n        return super.getDuty() + super.getDuty();\n    }\n\n    @Override\n    protected BigDecimal getPrice() {\n        return super.getPrice().add(super.getPrice());\n    }\n}\n```\n\n#### 使用装饰者重构\n\n```java\n/**抽象保险类**/\npublic abstract class AbstractInsurance {\n    // 责任项\n    protected abstract String getDuty();\n    // 价格\n    protected abstract BigDecimal getPrice();\n}\n\n/**基础-裸险**/\npublic class NakedInsurance extends AbstractInsurance {\n\n    @Override\n    protected String getDuty() {\n        return \"身故\";\n    }\n\n    @Override\n    protected BigDecimal getPrice() {\n        return new BigDecimal(10.00);\n    }\n}\n\n/**抽象装饰者**/\npublic class InsuranceDecorator extends AbstractInsurance {\n    /**持有AbstractInsurance引用**/\n    private AbstractInsurance abstractInsurance;\n\n    public InsuranceDecorator(AbstractInsurance abstractInsurance) {\n        this.abstractInsurance = abstractInsurance;\n    }\n\n    @Override\n    protected String getDuty() {\n        return this.abstractInsurance.getDuty();\n    }\n\n    @Override\n    protected BigDecimal getPrice() {\n        return this.abstractInsurance.getPrice();\n    }\n}\n\n/**半险装饰者**/\npublic class HalfDecorator extends InsuranceDecorator {\n    public HalfDecorator(AbstractInsurance abstractInsurance) {\n        super(abstractInsurance);\n    }\n\n    @Override\n    protected String getDuty() {\n        return super.getDuty() + \"/重大疾病\";\n    }\n\n    @Override\n    protected BigDecimal getPrice() {\n        return super.getPrice().add(new BigDecimal(10.00));\n    }\n}\n\n/**全险装饰者**/\npublic class FullDecorator extends InsuranceDecorator {\n    public FullDecorator(AbstractInsurance abstractInsurance) {\n        super(abstractInsurance);\n    }\n\n    @Override\n    protected String getDuty() {\n        return super.getDuty() + \"/意外医疗/意外伤害/住院医疗/住院补贴\";\n    }\n\n    @Override\n    protected BigDecimal getPrice() {\n        return super.getPrice().add(new BigDecimal(40.00));\n    }\n}\n\n/**测试**/\npublic static void main(String[] args) { \n    // 裸险\n    AbstractInsurance abstractInsurance = new NakedInsurance();\n    // 半险\n    abstractInsurance = new HalfDecorator(abstractInsurance);\n    // 半险 x 1\n    abstractInsurance = new HalfDecorator(abstractInsurance);\n    // 全险\n    abstractInsurance = new FullDecorator(abstractInsurance);\n    // 全险 x 1\n    abstractInsurance = new FullDecorator(abstractInsurance);\n    System.out.println(abstractInsurance.getDuty() + \", 总价: \" + abstractInsurance.getPrice().doubleValue());\n}\n```\n\n#### 类图\n\n![](装饰者模式/class-graph.png)\n\n##### 套用类图\n\n![](装饰者模式/demo-graph.png)","tags":["装饰者模式"]},{"title":"Raspberry4B-Svn-Gitea-Drone-CI/CD","url":"/blog/2020/08/02/Raspberry4B-Svn-Gitea-Drone-CI-CD/","content":"\n## 树莓派配置\n\n* 官方系统烧录工具[Raspberry Pi Imager](https://www.raspberrypi.org/downloads/)\n\n* [Debian-Pi-Aarch64](https://github.com/openfans-community-offical/Debian-Pi-Aarch64/blob/master/README_zh.md#3-5%E6%97%A0%E7%BA%BF%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E)系统\n* [Fing](https://play.google.com/store/apps/details?id=com.overlook.android.fing)手机网络工具\n  \n烧录完系统以后,修改`/boot/wpa_supplicant.conf`文件，配置无线网络:\n```json\ncountry=CN\nctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\nupdate_config=1\n\n## ssid是你的无线Wifi名称，psk是你无线Wifi的密码\nnetwork={\n    ssid=\"your-wifi1-ssid\"\n    psk=\"wifi1-password\"\n    priority=1\n    id_str=\"wifi-1\"\n}\n```\n然后将`SD`卡插入到树莓派上，接上电源。\n\n该系统默认初始化时会自动重启3次，我们可以使用下载的[Fing](https://play.google.com/store/apps/details?id=com.overlook.android.fing)网络工具，将手机接入相同的`wifi`网络，进行扫描，即可发现树莓派的`ip`地址。\n\n通过`ssh pi@树莓派ip`进行连接，系统默认用户是`pi`, 默认密码是: `raspberry`。\n\n![](pi.png)\n![](pi2.png)\n\n## Git操作SVN仓库\n\n![](svg.png)\n\n<!-- \n    puml\n    Note right of 本地SVN: 使用svn命令操作SVN仓库\n    本地SVN<-远程SVN仓库: svn checkout svn://xxx/trunk/xxx\\nsvn add test.md\\nsvn commit\n    Note right of 远程SVN仓库: 使用git命令操作SVN仓库\n    本地Git<-远程SVN仓库: git svn clone svn://xxx/trunk/xxx\\ngit svn rebase\\ngit svn barnch/tag xxx\\ngit add .\\ngit commit\\ngit svn dcommit\n\n    本地Git->本地gitea分支: git checkout -b gitea\n\n    本地gitea分支->远程gitea仓库: git merge master \\ngit push -u origin HEAD:master\n-->\n\n## docker-compose.yml配置\n\n### gitea\n如下是`gitea(1.13.0)`的`docker-compose.yml`配置:\n```yml\nversion: \"3.7\"\nservices:\n  # 配置gitea使用mysql\n  aix_mysql:\n    image: mysql:5.7\n    restart: \"no\"\n    container_name: aix_mysql\n    environment:\n      - MYSQL_ROOT_PASSWORD=gitea123456\n      - MYSQL_DATABASE=gitea\n      - MYSQL_USER=gitea\n      - MYSQL_PASSWORD=gitea123456\n    networks:\n      - aixnet\n    volumes:\n      - /Users/limengyu/docker/aix/mysql/conf/my.cnf:/etc/mysql/my.cnf:rw\n      - /Users/limengyu/docker/aix/mysql/data:/var/lib/mysql/:rw\n      - /Users/limengyu/docker/aix/mysql/logs:/var/log/mysql/:rw\n\n  aix_memcache:\n    image: memcached:alpine\n    container_name: aix_memcache\n    restart: \"no\"\n    networks:\n      - aixnet\n\n  aix_gitea:\n    image: gitea/gitea:latest\n    restart: \"no\"\n    container_name: aix_gitea\n    # 环境变量配置(在下面)\n    env_file:\n      - .env\n    networks:\n      - aixnet\n    ports:\n      - \"$GITEA_WEB_PORT:3000\"\n      - \"$GITEA_SSH_PORT:22\"\n    environment:\n      - DOMAIN=$SERVER_IP\n      - SSH_DOMAIN=$SERVER_IP\n      - SSH_PORT=$GITEA_SSH_PORT\n      - SSH_LISTEN_PORT=22\n      - ROOT_URL=$GITEA_WEB_URL\n    volumes:\n      - /Users/limengyu/docker/aix/gitea:/data:rw\n\nnetworks:\n  aixnet:\n```\n\n### drone\n\n下面是`drone(1.8.0)`的`docker-compose.yml`配置，可以和上面的合在一起，我这里拆开了。\n`drone`可以使用`mysql`也可以使用`postgresql`,官方文档称针对`postgresql`有优化，这里给出一个使用的例子:\n```yml\nversion: \"3.7\"\nservices:\n  # drone使用postgresql\n  aix_pg:\n   restart: \"no\"\n   image: postgres:latest\n   container_name: aix_pg\n   privileged: true\n   ports:\n     - 5432:5432\n   # 环境变量配置(在下面)\n   env_file:\n     - .pg.env\n   networks:\n      - aixnet\n   volumes:\n     - /Users/limengyu/docker/aix/pg/data:/var/lib/postgresql/data:rw\n\n  aix_drone_server:\n    image: drone/drone:latest\n    container_name: aix_drone_server\n    ports:\n      - \"$DRONE_HTTP_PORT:80\"\n      - \"$DRONE_HTTPS_PORT:443\"\n    # 环境变量配置(在下面)\n    env_file:\n      - .drone.env\n      - .drone-rpc.env\n      - .env\n    networks:\n      - aixnet\n    volumes:\n      - /Users/limengyu/docker/aix/drone:/var/lib/drone/:rw\n      - /var/run/docker.sock:/var/run/docker.sock:rw\n    restart: \"no\"\n    environment:\n      - DRONE_LOGS_DEBUG=true\n      - DRONE_LOGS_PRETTY=true\n      - DRONE_LOGS_COLOR=true\n      - DRONE_LOGS_TRACE=false\n      # 配置对应的postgres数据库信息\n      - DRONE_DATABASE_DRIVER=postgres\n      - DRONE_DATABASE_DATASOURCE=postgres://drone:drone123456@aix_pg:5432/drone?sslmode=disable\n      - DRONE_GITEA_SKIP_VERIFY=false\n      - DRONE_TLS_AUTOCERT=false\n      - DRONE_GIT_ALWAYS_AUTH=false\n      #- DRONE_RUNNER_CAPACITY=2\n      - DRONE_SERVER_HOST=${SERVER_IP}:${DRONE_HTTP_PORT}\n      # 配置对应的gitea仓库地址\n      - DRONE_GITEA_SERVER=http://${SERVER_IP}:${GITEA_WEB_PORT}\n\n  aix_drone_agent:\n    image: drone/drone-runner-docker:1\n    container_name: aix_drone_agent\n    # 环境变量配置(在下面)\n    env_file:\n      - .runner.env\n      - .drone-rpc.env\n      - .env\n    ports:\n      - \"$DRONE_RUNNER_PORT:3000\"\n    restart: \"no\"\n    networks:\n      - aixnet\n    depends_on:\n      - aix_drone_server\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:rw\n    environment:\n      - DRONE_RPC_HOST=aix_drone_server\n      - DRONE_RPC_SERVER=http://aix_drone_server\n      - DRONE_DEBUG=true\n      - DRONE_LOGS_DEBUG=true\n      - DRONE_LOGS_PRETTY=true\n      - DRONE_LOGS_NOCOLOR=false\n\nnetworks:\n  aixnet:\n```\n\n### 环境变量\n以下是环境变量配置\n\n#### .evn\n```json\n// 本机ip\nSERVER_IP=192.168.2.86\n\n// gitea端口配置\nGITEA_WEB_PORT=8080\nGITEA_SSH_PORT=22\n\n// drone端口配置\nDRONE_HTTP_PORT=8090\nDRONE_HTTPS_PORT=8091\n// drone-runner端口配置\nDRONE_RUNNER_PORT=8082\n\n//gitea web地址\nGITEA_WEB_URL=http://192.168.2.86:8080\n```\n\n#### .drone.env\n```json\n// oauth2使用，配置gitea时会配置\nDRONE_GITEA_CLIENT_ID=740c33b5-ae14-4284-be76-592bc05ae1b9\nDRONE_GITEA_CLIENT_SECRET=L4nxg5X-_acodbQ4TWHPR3qqhGRwE3U7NfbN--2hCNQ=\n// 使用http\nDRONE_SERVER_PROTO=http\n// aixbx用户是在配置gitea时配置的，下面会看到\nDRONE_USER_CREATE=username:aixbx,admin:true\n```\n\n#### .drone-rpc.env \n`drone-server`和`drone-runner`共用,可以通过`openssl rand -hex 16`生成:\n```json\nDRONE_RPC_SECRET=da19cfd2-33ed-44d2-8e60-5c987e780f36\n```\n\n#### .pg.env\n```json\n// 数据库\nPOSTGRES_USER=drone\nPOSTGRES_PASSWORD=drone123456\nPOSTGRES_DB=drone\n```\n\n#### .runner.env\n```json\nDRONE_RUNNER_NAME=runner-agent\n```\n\n### 启动\n在`docker-compose.yml`所在目录执行:\n```\ndocker-compose up -d\n```\n\n### 启动报错排查\nTODO\n\n\n## gitea配置\n打开上面配置的`${GITEA_WEB_URL}`地址(即`http://192.168.2.86:8080`)，进入到`gitea`初始化页面进行配置:\n\n![](gitea_mysql.png)\n![](gitea_admin.png)\n\n* 数据库选择`mysql`，数据库主机修改为`aix_mysql:3306`，`aix_mysql`是上面配置的`container_name`. 用户名和密码修改为上面`docker-compose.yml`中配置的`gitea/gitea123456`。\n* 管理员用户名配置为上面`.drone.env`中配置的`aixbx`用户，密码自己设置一下，然后填写好邮箱并保存。\n\n经过如上步骤后，`gitea`就初始化完成了，接着我们去`gitea`中配置下`drone`的`OAuth2`信息。\n![](gitea_drone.png)\n\n* 应用名称录入: `drone`\n* 重定向url录入`drone`的地址: `http://192.168.2.86:8090/login`(我们的例子地址)\n* 上面的钥匙`drone`，是我已经授权了一个例子，点击`撤销`,可以撤销授权.\n\n保存后就可以看到生成的`客户端ID`和`客户端秘钥`，这两个需要配置到上文中的`.drone.env`环境变量文件中(`DRONE_GITEA_CLIENT_ID`和`DRONE_GITEA_CLIENT_SECRET`):\n![](gitea_drone2.png)\n\n\n接着我们在`gitea`中新建一个测试仓库`gitea-drone-demo`:\n![](gitea_demo.png)\n\n其他不用填写，保存。然后我们的`gitea`配置告一段落，下面登陆到`drone`进行配置。\n\n## drone配置\n打开`http://192.168.2.86:8090`，首先会提示`OAuth2`授权，点击确定即可进入到`drone`页面:\n![](drone_index.png)\n\n点击`sync`，就可以看到我们在`gitea`中新创建的测试仓库，然后点击`ACTIVATE`就可以激活该仓库。\n\n![](drone_init.png)\n将`Trusted`钩上并保存。\n\n![](drone_secret.png)\n设置`username`:`pi`, `password`:`123456`。\n稍后我们在编写`.drone.yml`文件时就可以直接使用`username`和`password`了。\n\n经过如上配置我们就配置好`drone`了，接下来我们就可以编写`.drone.yml`文件了，`drone`是根据`.drone.yml`文件来进行编排的。每个项目中都有一个`.drone.yml`文件.\n\n## .drone.yml配置\n在我们的项目根目录下新建`.drone.yml`文件:\n```yml\n---\nkind: pipeline\ntype: docker\nname: gitea-drone-demo\n\n# 设置当前工作目录，下面的每一步都会基于该目录执行相应命令\nworkspace:\n  base: /app\n  path: git/drone/gitea-drone-demo\n\n# 禁用默认的git clone命令\nclone:\n  disable: true\n\nsteps:\n  # 拉取我们的项目代码\n  - name: git clone\n    image: alpine/git\n    commands:\n    - git clone $DRONE_GIT_HTTP_URL ./\n\n  # 编译我们的项目\n  - name: maven compile\n    image: maven:3.6.2-jdk-8\n    volumes:\n    - name: cache\n      path: /root/.m2\n    commands:\n    - mvn clean install -DskipTests=true -Dmaven.javadoc.skip=true -B -V\n\n  # 编译好以后通过scp将我们的war包上传到树莓派中\n  - name: scp upload\n    image: appleboy/drone-scp\n    settings:\n      # 树莓派地址\n      host: 192.168.2.138\n      port: 22\n      # 使用上面drone中配置的secret变量\n      username:\n        from_secret: username\n      password:\n        from_secret: password\n      # 上传到目标机器的指定目录\n      target: /home/pi/${DRONE_REPO_NAME}\n      strip_components: 1\n      rm: true\n      # 需要上传的文件(可以看到，我们会上传4个文件到目标机器，后面会看到具体内容)\n      source: \n        - ./target/${DRONE_REPO_NAME}.war\n        - ./Dockerfile\n        - ./deploy.sh\n        - ./start.sh\n\n  # 通过ssh在目标机器上执行指定命令\n  - name: ssh deploy\n    image: appleboy/drone-ssh\n    settings:\n      # 树莓派地址\n      host: 192.168.2.138\n      port: 22\n      username:\n        from_secret: username\n      password:\n        from_secret: password\n      # 执行的命令\n      script:\n        - cd /home/pi/${DRONE_REPO_NAME}\n        - mv ./target/${DRONE_REPO_NAME}.war .\n        - sh deploy.sh \n  \n  # 部署完成后，通过企业微信进行通知\n  # - name: wechat notify\n  #   image: clem109/drone-wechat\n  #   secrets: [plugin_corpid, plugin_corp_secret, plugin_agent_id]\n  #   title: ${DRONE_REPO_NAME}\n  #   description: \"Build Number: ${DRONE_BUILD_NUMBER} failed. ${DRONE_COMMIT_AUTHOR} please fix. Check the results here: ${DRONE_BUILD_LINK} \"\n  #   msg_url: ${DRONE_BUILD_LINK}\n  #   btn_txt: btn\n  #   when:\n  #     status: [ failure ]\n\nvolumes:\n  - name: cache\n    host:\n      path: /Users/limengyu/.m2\n\n# master分支时触发\ntrigger:\n  branch:\n    - master\n```\n\n`deploy.sh`文件:\n```sh\n#!/bin/sh\n\nnow=`date +%Y%m%d%H%M%S`\n \nserver=\"gitea-drone-demo\"\n\n# 给实例启个名称，后面配置nginx时会用到\nalias=\"drone_demo\"\n# 设置同一个网络\nnetwork=\"docker_aixnet\"\n\n# 停止当前正在运行的docker实例\necho \"building $server instance...\"\necho \"now date: $now\"\ndocker ps | grep $server | awk '{print $1}' | xargs --no-run-if-empty docker stop\ndocker ps -a | grep $server | awk '{print $1}' | xargs --no-run-if-empty docker rm\ndocker build -t $server .\necho \"built $server instance done...\"\n\n# 启动新docker实例\ndocker run -it --name $alias -p 127.0.0.1:8080:8080 -d --network $network --network-alias $alias $server\n```\n\n`Dockfile`文件:\n\n```sh\nFROM tomcat:9-alpine as dev\n\nWORKDIR /app\n\nCOPY . /app/\n\nEXPOSE 8080\n\nRUN chmod +x ./start.sh\n\nCMD ./start.sh\n```\n\n`start.sh`文件:\n```sh\n#!/bin/sh\n\ncp /app/gitea-drone-demo.war /usr/local/tomcat/webapps/ROOT.war\n\nrm -rf /usr/local/tomcat/webapps/ROOT\n\ncd /usr/local/tomcat/bin\n\n./catalina.sh run\n```\n\n至此，所有的文件都配置好了，距离运行测试只有一步之遥了。我们还需要在树莓派上配置下`nginx`:\n登陆到树莓派, 然后配置`docker-compose.yml`文件:\n```yml\nversion: \"3.7\"\nservices:\n  nginx:\n    image: nginx:alpine\n    container_name: aix_nginx\n    ports:\n      - \"80:80\"\n    restart: \"no\"\n    networks:\n     aixnet:\n       # 设置别名后，这些域名指向的都是nginx的容器内地址，例如: 172.18.0.3，\n       # 这样我们容器内的服务就可以通过该域名进行互相访问了\n       aliases:\n         - \"gitea.drone.demo\"\n         - \"a.com\"\n\n  aix_registry:\n    image: registry:latest\n    container_name: aix_registry\n    ports:\n      - \"5000:5000\"\n    restart: \"no\"\n    networks:\n      - aixnet\n\nnetworks:\n  aixnet:\n```\n\n然后启动`docker-compose up -d`.\n接着进入到`nginx`容器中:\n`docker-compose exec nginx ash`\n\n```nginx\n# 配置反向代理\nvi /etc/nginx/conf.d/gitea.drone.demo.conf\n\nserver {\n    listen 80;\n    server_name gitea.drone.demo;\n    location / {\n        # drone_demo 就是`deploy.sh`文件中配置的实例名称。\n        proxy_pass http://drone_demo:8080;\n        proxy_set_header   Host             $host;\n        proxy_set_header   X-Real-IP        $remote_addr;\n        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;\n    }\n}\n\n重新加载`nginx`配置:\n`nginx -s reload`\n```\n\n经过如上步骤，我们就可以执行测试了,首先配置`ssh`:\n在`192.168.2.86`机器上配置:\nssh-keygen -t rsa -C \"xxxx@163.com\"\n```sh\ncat ~/.ssh/config\n\nHost aixbx\nHostName 192.168.2.86\nPreferredAuthentications publickey\nUser aixbx\nIdentityFile ~/.ssh/id_rsa_aixbx\n\n\n# 将id_rsa_aixbx.pub 配置到gitea中\n# 然后执行:\nOCaml:.ssh limengyu$ ssh -T git@aixbx\nHi there, aixbx! You've successfully authenticated with the key named xxxx@163.com, but Gitea does not provide shell access.\nIf this is unexpected, please log in with password and setup Gitea under another user.\n```\n\n我们通过`git svn`命令操作`svn`仓库，`clone`好代码后，切换到`gitea`分支中，然后配置`upstream`并推送代码到远程`gitea`仓库:\n\n```sh\n# 第一个aixbx是配置的ssh\ngit remote add origin git@aixbx:aixbx/gitea-drone-demo.git\n\n# 将代码push到远程gitea仓库\ngit push -u origin master\n```\n\n之后，我们只需要将`master`分支的内容`merge`到`gitea`分支，在`push`到`gitea`仓库中，就可以自动触发`ci/cd`流程了:\n```sh\ngit checkout gitea\n\ngit merge master\n\ngit push -u origin HEAD:master\n```\n\n![](deploy.png)\n\n## 问题排查\nTODO","tags":["drone"]},{"title":"perl-poem","url":"/blog/2020/05/20/perl-poem/","content":"\n### love letter (a perl poem)\n\n```perl\n#!/usr/bin/perl\n\nlisten me, please;\nmy $dear;\n\nplease:\n`touch my heart`. read the, $message, in;\nsort my @feelings, and pop my @feelings;\n\nplease:\nopen your, heart;\njoin us, together.\n\nlet us tell world,\n    that we are in love until time;\n```","tags":["love letter"]},{"title":"Mysql-面試題","url":"/blog/2020/05/10/Mysql-面試題/","content":"\n## 索引\n\n### 普通索引\n\n最基本的索引，没有任何约束。\n\n### 唯一索引\n\n与普通索引类似，但具有唯一性约束。\n\n### 主键索引\n\n特殊的唯一索引，不允许有空值。\n\n### 复合索引\n\n将多个列组合在一起创建索引，可以覆盖多个列。\n\n#### 最左匹配特性\n\n假如存在复合索引(name, age, sex):\n\n* (张三, 20, F):  优先比较name，如果name相同，再依次比較age和sex。\n\n* (20, F):       将不会走该索引。\n\n* (张三, F):      先查询出name=张三的数据，然后再过滤出所有sex=F的数据。\n\n* 最左前缀匹配原则，MySQL会一直向右匹配直到遇到范围查询(`>、<、between、like`)就停止匹配，比如`a=3 and b=4 and c>5 and d=6`,如果建立`(a,b,c,d)`顺序的索引，`d`是无法使用索引的，如果建立`(a,b,d,c)`的索引则都可以使用到，`a、b、d`的顺序可以任意调整。\n\n* =和in可以乱序，比如`a=1 and b=2 and c=3`建立`(a,b,c)`索引可以任意顺序，MySQL的查询优化器会帮你优化成索引可以识别的形式。\n\n### 外键索引\n\n只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作。\n\n### 全文索引\n\nMySQL自带的全文索引只能用于InnoDB、MyISAM，并且只能对英文进行全文检索，一般使用全文索引引擎(Elasticsearch、Solr)。\n\n### 聚簇索引/密集索引\n\n聚簇索引是将索引和数据都存放在叶子节点中。在InnoDB里，主键索引也被称为聚集索引(clustered index)。\n\n### 非聚簇索引/辅助索引/二级索引/稀疏索引\n\n非聚簇索引就是将数据和索引分开，查找时需要先查找到索引(索引文件仅保存数据记录的地址)，然后通过索引回表找到相应的数据。\n\nInnoDB有且只有一个聚簇索引，其他都是非聚簇索引，而MyISAM中都是非聚簇索引。\n\n* InnoDB: 需查询两次，先通过辅助索引查询到主键，再通过主键从聚簇索引中查询到数据。\n* MyISAM: 叶子节点中保存的是行数据的地址，需要根据地址再寻址一次才能得到数据。\n\n![\"\"](select.png)\n\n### 覆盖索引\n\n* 覆盖索引(covering index)指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。\n当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。\n\n* 指的是基于非聚簇索引查询，但是查询字段只有主键ID ，那么在二级索引中就可以查找到。\n\n如: 表`covering_index_sample`中有一个普通索引`idx_key1_key2(key1,key2)`。当我们通过SQL语句：`select key2 from covering_index_sample where key1 = 'keytest';`的时候，就可以通过覆盖索引查询，无需回表。\n\n### 页/预读\n\n系统从磁盘读取数据到内存时是以磁盘块(`block`)为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。\n\n`InnoDB`存储引擎中有页(`Page`)的概念，页是其磁盘管理的最小单位。`InnoDB`存储引擎中默认每个页的大小为`16KB`(`show variables like 'innodb_page_size';`).\n\n而系统一个磁盘块的存储空间往往没有这么大，因此`InnoDB`每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小`16KB`。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I/O 次数，提高查询效率。\n\n### B-Tree\n\n![\"\"](b-tree.png)\n\n從`B-Tree`结构图中可以看到，每个节点中不仅包含数据的`key`值，还有`data`值。而每一个页的存储空间是有限的，如果`data`数据较大时将会导致每个节点(即一个页)能存储的`key`的数量很小，当存储的数据量很大时同样会导致`B-Tree`的深度较大，增大查询时的磁盘`I/O`次数，进而影响查询效率。\n\n在`B+Tree`中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储`key`值信息，这样可以大大加大每个节点存储的`key`值数量，降低`B+Tree`的高度。\n\n### B+Tree\n\n![\"\"](b+tree.png)\n\n![\"\"](b+tree2.png)\n\n#### 单页，以及前一页和后一页的指针\n\n![\"\"](page1.png)\n\n#### 引入页目录加快查詢(插入时进行排序的原因)\n\n![\"\"](page2.png)\n\n#### 多頁\n\n![\"\"](page3.png)\n\n#### 多页和目录\n\n![\"\"](page4.png)\n\n#### 宏观图\n\n![\"\"](page5.png)\n\n### MyISAM B+Tree\n\n可以看到`MyISAM`叶子节点中保存的是行数据的地址，需要根据地址再寻址一次才能得到数据。\n\n![\"\"](myisam.png)\n\n![\"\"](myisam2.png)\n\n\n## 事务\n\n事务就是对一系列的数据库操作(比如插入多条数据)进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。\n\n### 事务的特性\n\n* `原子性 Atomicity`：一个事务(transaction)中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节.\n\n* `一致性 Consistency`：应用系统从一个正确的状态到另一个正确的状态.而ACID就是说事务能够通过AID来保证这个C的过程.C是目的,AID都是手段.\n\n* `隔离性 Isolation`：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。\n\n* `持久性 Durability`：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失.\n\n### 事务的并发问题\n\n* 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。\n\n* 不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。\n\n* 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为`ABCDE`等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。\n\n>不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。\n\n### 事务隔离级别\n\n* 读未提交(`Read uncommitted`)：事务中的修改，即使没有提交，对其他事务也都是可见的\n\n* 读提交(`read committed`)：事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的\n\n* 可重复读(`repeatable read`)：一个事务按相同的查询条件读取以前检索过的数据，其他事务插入了满足其查询条件的新数据。产生幻行。\n\n* 串行化(`Serializable`)：强制事务串行执行\n\n| 事务隔离级别 | 脏读 | 不可重复读 | 幻读 |\n| :-----| ----: | :----: |  :----: |\n| 读未提交 | 是(允許) | 是 | 是 |\n| 读未提交 | 否(不允許) | 是 | 是|\n| 可重复读 | 否 | 否 | 是 (X)|\n| 串行化 | 否 | 否 | 否 |\n\n* MySQL默认的事务隔离级别为可重复读(repeatable-read)\n\n* MySQL通过`MVCC`+事务第一次调用`SELECT`语句才生成快照，实现其在可重复读(`repeatable-read`)的隔离级别下，不存在幻读问题，即上图`X`处，需要改成\"否\"\n\n>查詢隔离级别：SELECT @@tx_isolation;\n\n## [锁](https://mp.weixin.qq.com/s?__biz=MzI1Mzg4OTMxNQ==&mid=100000550&idx=1&sn=8a5cdff008fc1eed7b5c623c1bdf4ed1&chksm=69ccdd6a5ebb547c7b7baf6be78763fc5065e0a58de202f3e25d8d8ed56e6d1c1146332cfec1#rd)\n\n### 锁的粒度\n\n* 表锁：系统开销最小，会锁定整张表，MyIsam 使用表锁。\n\n* 行锁：最大程度的支持并发处理，但是也带来了最大的锁开销，InnoDB使用行锁。\n\n>Innodb的锁的策略为next-key锁，即record lock + gap lock，是通过在index上加lock实现的。如果index为 unique index，则降级为record lock行锁，如果是普通index，则为next-key lock，如果没有index，则直接锁住全表，即表锁。\n\n### 锁机制\n\n* 共享锁(读锁)：不堵塞，多个用户可以同时读一个资源，互不干扰\n\n* [排他锁(写锁)](https://zhuanlan.zhihu.com/p/83148075)：一个写锁会阻塞其他的读锁和写锁\n\n### 悲观锁/乐观锁\n\n* 悲观锁：依靠数据库提供的锁机制实现(即:共享锁和排他锁)，读取数据时加锁，其它事务无法修改这些数据。修改删除数据时也加锁，其它事务无法读取这些数据。\n\n* 乐观锁：基于数据版本(Version)记录机制实现，通过版本号，从而实现CAS原子性更新(将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则進行更新，否则认为是过期数据)\n\n>InnoDB是基于索引来完成行锁。例如：SELECT * FROM tab_with_index WHERE id = 1 FOR UPDATE。\nFOR UPDATE可以根据条件来完成行锁锁定，并且id是有索引键的列,如果id不是索引键，那么InnoDB将完成表锁，并发将无从谈起。\n\n### [MVCC多版本并发控制](https://juejin.im/post/5c68a4056fb9a049e063e0ab)\n\n并发访问(读或者写)数据库时，对正在事务内处理的数据做多版本的管理，用来避免由于写操作的堵塞，而引发读操作失败的并发问题。\n\nMVCC并发控制下的读事务一般使用`时间戳`或者`事务ID`去标记当前读的数据库的状态(版本)，读取这个版本的数据。读、写事务相互隔离，不需要加锁。读写并存的时候，写操作会根据目前数据库的状态，创建一个新版本，并发的读则依旧访问旧版本的数据。避免了脏读和不可重复读。\n\n## 索引优化\n\n* 联合索引最左前缀原则\n\n* 不要在列上使用函数和进行运算\n\n* 负向条件查询不能使用索引\n  * 负向条件有：!=、<>、not in、not exists、not like 等\n\n* 使用覆盖索引\n  * 所谓覆盖索引，是指被查询的列，数据能从索引中取得，而不用通过行定位符再到数据表上获取，能够极大的提高性能。\n\n* 避免强制类型转换\n\n* 范围列可以用到索引，范围列后面的列无法用到索引\n  * 范围条件有：<、<=、>、>=、between等\n\n* 更新频繁、数据区分度不高的字段上不宜建立索引\n\n* 索引列不允许为null\n\n* 避免使用or来连接条件\n\n* 前导模糊查询不能使用索引\n\n## Explain列\n\n* id：一般来说一个select一个唯一id，如果是子查询，就有两个select，id是不一样的，另外有些子查询的id是一样的(被優化為连接查询)\n\n* select_type：\n  * simple：不包括union和子查询的查询都算simple类型。\n  * primary：包括union，union all，其中最左边的查询即为primary。\n  * union：包括union，union all，除了最左边的查询，其他的查询类型都为union\n\n* type：访问方法\n  * ref：普通二级索引与常量进行等值匹配\n  * ref_or_null：普通二级索引与常量进行等值匹配，该索引可能是null\n  * const：主键或唯一二级索引列与常量进行等值匹配\n  * range：范围区间的查询\n  * all：全表扫描\n\n* possible_keys：对某表进行单表查询时可能用到的索引\n\n* key：经过查询优化器计算不同索引的成本，最终选择成本最低的索引\n\n* rows：\n  * 如果使用全表扫描，那么rows就代表需要扫描的行数\n  * 如果使用索引，那么rows就代表预计扫描的行数\n\n* filtered：\n  * 如果全表扫描，那么filtered就代表满足搜索条件的记录的百分比\n  * 如果是索引，那么filtered就代表除去索引对应的搜索，其他搜索条件的百分比\n\n* Extra：包含的是不适合在其他列显示的额外信息。\n  * Using where：意味着mysql服务器将在存储引擎检索行后再进行过滤\n  * Using index：表示mysql将使用覆盖索引，以避免访问表\n  * Using filesort：意味着mysql会对结果使用一个外部索引排序，而不是按照索引次序从表里读取行\n  * Using index condition：在存储引擎层使用索引过滤数据的一种优化方式\n  * Using temporary：这意味着mysql对查询结果排序时会使用一个临时表\n  * Using join buffer (Block Nested Loop)\n  * Using join buffer (Batched Key Access)\n  * Using MRR\n\n## SQL查询执行顺序\n\n```haskell\n(1)     SELECT\n(2)     DISTINCT <select_list>\n(3)     FROM <left_table>\n(4)     <join_type> JOIN <right_table>\n(5)     ON <join_condition>\n(6)     WHERE <where_condition>\n(7)     GROUP BY <group_by_list>\n(8)     HAVING <having_condition>\n(9)     ORDER BY <order_by_condition>\n(10)    LIMIT <limit_number>\n```\n\n## [Redo/Undo](https://zhuanlan.zhihu.com/p/86553820)\n\n## 主从复制的流程\n\n* Master 上面的 binlog dump 线程，该线程负责将 master 的 binlog event 传到 slave 。\n\n* Slave 上面的 IO 线程，该线程负责接收 Master 传过来的 binlog，并写入 relay log。\n\n* Slave 上面的 SQL 线程，该线程负责读取 relay log 并执行。\n\n* 如果是多线程复制，SQL 线程只做 coordinator，只负责把 relay log 中的 binlog 读出来然后交给 worker 线程， woker 线程负责具体 binlog event 的执行。\n\n## 清理 MySQL binlog\n\n```sql\n# 首先查看主从库正在使用的binlog文件名称\nshow master(slave) status\n\n# 删除之前一定要备份\npurge master logs before'2017-09-01 00:00:00'; # 删除指定时间前的日志\npurge master logs to'mysql-bin.000001'; # 删除指定的日志文件\n\n# 自动删除：通过设置binlog的过期时间让系统自动删除日志\nshow variables like 'expire_logs_days'; # 查看过期时间\nset global expire_logs_days = 30; # 设置过期时间\n```","tags":["锁"]},{"title":"Haskell-Language-Extensions","url":"/blog/2019/11/19/Haskell-Language-Extensions/","content":"\n> [原文](http://dev.stephendiehl.com/hask/#language-extensions)\n\n区分`general`(通用)和`specialized`(专用)语言扩展的不同类别非常重要。\n\n将扩展分类为通用和专用类别的固有问题是它是一个主观分类。进行类型系统研究的`Haskeller`与`Web`编程人员对`Haskell`的解释将有很大不同。\n\n因此，这是一个保守的评估，作为一个任意基准，我们将`everyday`(日常)考虑`FlexibleInstances`和`OverloadedStrings`，而将`GADT`和`TypeFamilies`进行`specialized`.\n\n***Key***\n\n* `Benign`暗示，导入扩展名不会改变模块的语义(如果不使用模块)，并且启用该扩展名也不会轻易使自己陷入困境.\n\n* `Historical`暗示，不应使用此扩展，它纯粹是为了向后兼容而在`GHC`中使用。有时启用这些功能很危险。\n\n* `Steals`语法意味着启用此扩展意味着将不再接受在`vanilla`(香草)`Haskell`中有效的某些代码。例如，`f $(a)`与`Haskell 98`中的`f $ (a)`相同，但是`TemplateHaskell`会将`$(a)`解释为一个`splice`(拼接)。\n\n請看:\n\n* [GHC Extension Reference](http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/flag-reference.html#idp14615552s)\n\n### The Benign\n\n哪些扩展是最常见的还不清楚，但是可以肯定地说以下扩展是良性的并且可以安全地广泛使用:\n\n* OverloadedStrings\n* FlexibleContexts\n* FlexibleInstances\n* GeneralizedNewtypeDeriving\n* TypeSynonymInstances\n* MultiParamTypeClasses\n* FunctionalDependencies\n* NoMonomorphismRestriction\n* GADTs\n* BangPatterns\n* DeriveGeneric\n* ScopedTypeVariables\n\n### The Dangerous\n\n`GHC`的类型检查器有时只是偶然地告诉我们在无法解决某些问题时启用语言扩展。这些包括:\n\n* DatatypeContexts\n* OverlappingInstances\n* IncoherentInstances\n* ImpredicativeTypes\n* AllowAmbigiousTypes\n\n这些几乎总是表明存在设计缺陷，不应打开它来纠正手头的错误，就像`GHC`可能建议的那样！\n\n### NoMonomorphismRestriction\n\n`NoMonomorphismRestriction`允许我们默认禁用`GHC`使用的单态限制类型規则。请参见[单态限制](http://dev.stephendiehl.com/hask/#monomorphism-restriction)。\n\n例如，如果我们将以下模块加载到`GHCi`中:\n\n```haskell\nmodule Bad (foo,bar) where\nfoo x y = x + y\nbar = foo 1\n```\n\n然后我们尝试用`Double`调用函数`bar`，我们得到一个类型错误:\n\n```haskell\nλ: bar 1.1\n<interactive>:2:5: error:\n    • No instance for (Fractional Integer)\n      arising from the literal ‘1.0’\n    • In the first argument of ‘bar’, namely ‘1.0’\n      In the expression: bar 1.0\n      In an equation for ‘it’: it = bar 1.0\n```\n\n问题是，GHC推断出了一种过于`specific`(特殊化)的类型:\n\n```haskell\nλ: :t bar\nbar :: Integer -> Integer\n```\n\n我们可以使用这个扩展来阻止`GHC`特殊化类型，即:\n\n```haskell\n{-# LANGUAGE NoMonomorphismRestriction #-}\n\nmodule Good (foo,bar) where\nfoo x y = x + y\nbar = foo 1\n```\n\n现在一切都会按预期进行:\n\n```haskell\nλ: :t bar\nbar :: Num a => a -> a\n```\n\n### ExtendedDefaultRules\n\n在没有显式类型签名的情况下，`Haskell`通常使用几个默认规则解析不明确的文本。\n\n当一个不明确的文本被类型检查时，如果它的类型类约束中至少有一个是`numeric`(数值)的，并且它的所有类都是标准库类，则会查阅模块的默认列表，并且列表中满足类型变量上下文的第一个类型将被实例化。\n\n例如，给定以下默认规则:\n\n```haskell\ndefault (C1 a,...,Cn a)\n```\n\n下面的一组启发式方法用于确定将不明确类型变量实例化到的对象。\n\n* 类型变量`a`没有其他限制\n* 所有的`Ci`类都是标准的。\n* `Ci`类中至少有一个是数值类。\n\n默认的`default`是`(Integer，Double)`\n\n通常，这很好，但是有时我们希望对默认设置进行更精细的控制。\n\n`-XExtendedDefaultRules`放宽了我们对数值类型类的使用的约束，以及我们只能与标准库类一起使用的约束。\n\n如果我们想让我们的字符串文字(使用`-XOverloadedStrings`)自动默认为更有效的`Text`实现，而不是`String`，我们可以`twiddle`(旋转)标志，`GHC`将执行正确的`substitution`(替换)，而无需在每个字符串文字上进行显式注释.\n\n```haskell\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ExtendedDefaultRules #-}\n\nimport qualified Data.Text as T\n\ndefault (T.Text)\n\nexample = \"foo\"\n```\n\n对于在`GHCi`提示符下`typed`(键入的)代码，`-XExtendedDefaultRules`标志始终处于打开状态，无法关闭。\n\n請看:\n\n* [Monomorphism Restriction](http://dev.stephendiehl.com/hask/#monomorphism-restriction)\n\n### Safe\n\n当每个人最终发现在`GHC`的实现中有几种功能(不是`Haskell`语言)可用于颠覆类型系统时，它们被标记为前缀`unsafe`。仅当可以手动证明表達式的合理性但不能在类型系统或`Haskell`的`externalities`(外在性)中表达此属性时，这些函数才存在。\n\n```haskell\nunsafeCoerce :: a -> b\nunsafePerformIO :: IO a -> a\n```\n\n> 使用这些函數来颠覆`Haskell`类型系统将导致所有无法定义的行为，并带有无法想象的疼痛和痛苦，并且强烈建议不要这样做。当最初使用`Haskell`时，完全没有理由在一段时间内使用这些函數。\n\n`Safe`语言扩展允许我们使用`-XSafe`限制不安全语言功能的使用，`-XSafe`限制了自身标记为安全的模块的导入。\n\n它还禁止使用某些可用于生成不安全代码的语言扩展(`-XTemplateHaskell`)。这些扩展的主要用例是安全审计。\n\n```haskell\n{-# LANGUAGE Safe #-}\n{-# LANGUAGE Trustworthy #-}\n{-# LANGUAGE Safe #-}\n\nimport Unsafe.Coerce\nimport System.IO.Unsafe\n\nbad1 :: String\nbad1 = unsafePerformIO getLine\n\nbad2 :: a\nbad2 = unsafeCoerce 3.14 ()\nUnsafe.Coerce: Can't be safely imported!\nThe module itself isn't safe.\n```\n\n請看:\n\n* [Safe Haskell](https://ghc.haskell.org/trac/ghc/wiki/SafeHaskell)\n\n### PartialTypeSignatures\n\n通常，一个函数要么被赋予完整的显式类型签名，要么根本不被赋予。部分类型签名扩展允许介于两者之间。\n\n可以使用部分类型来避免编写无用的签名，这在开发中很方便:\n\n```haskell\n{-# OPTIONS -XPartialTypeSignatures #-}\n\ntriple :: Int -> _\ntriple i = (i,i,i)\n```\n\n如果设置了`-Wpartial-type-signatures GHC`选项，则部分类型仍将触发警告。\n\n請看:\n\n* [Partial Type Signatures](https://ghc.haskell.org/trac/ghc/wiki/PartialTypeSignatures)\n\n### RecursiveDo\n\n递归`do`表示法允许在`monadic`绑定的两侧使用自引用表达式。\n例如，以下使用惰性评估来生成无限列表。有时，它用于实例化需要保留对其自身的引用的`monadic`上下文中的循环数据类型。\n\n```haskell\n{-# LANGUAGE RecursiveDo #-}\n\njustOnes :: Maybe [Int]\njustOnes = do\n  rec xs <- Just (1:xs)\n  return (map negate xs)\n```\n\n請看:\n\n* [Recursive Do Notation](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#the-recursive-do-notation)\n\n### ApplicativeDo\n\n默认情况下，`GHC`使用隐式调用`bind`和`return`來`desugars`(脫糖)`do`符号:\n\n```haskell\ntest :: Monad m => m (a, b, c)\ntest = do\n  a <- f\n  b <- g\n  c <- h\n  return (a, b, c)\n```\n\n脫糖為:\n\n```haskell\ntest :: Monad m => m (a, b, c)\ntest =\nf >>= \\a ->\n  g >>= \\b ->\n    h >>= \\c ->\n      return (a, b, c)\n```\n\n使用`applicatvedo`，这将减少使用`applicative`组合器和`laxer`(更宽松)的`applicative`约束。\n\n```haskell\ntest :: Applicative m => m (a, b, c)\ntest = (,,) <$> f <*> g <*> h\n```\n\n### PatternGuards\n\n模式守卫是模式匹配语法的扩展。\n\n给定一个`<-`模式限定符，计算右侧并与左侧的模式匹配。如果匹配失败了，那么整个`guard`就失败了，并尝试下一个方程式。如果成功，则在扩展环境中进行适当的绑定，并匹配下一个限定符。\n\n```haskell\n{-# LANGUAGE PatternGuards #-}\n\ncombine env x y\n   | Just a <- lookup x env\n   , Just b <- lookup y env\n   = Just $ a + b\n\n   | otherwise = Nothing\n```\n\n### ViewPatterns\n\n`ViewPatterns`就像可以嵌套在其他模式内部的模式守卫。它们是与代数数据类型的值进行模式匹配的便捷方法:\n\n```haskell\n{-# LANGUAGE ViewPatterns #-}\n{-# LANGUAGE NoMonomorphismRestriction #-}\n\nimport Safe\n\nlookupDefault :: Eq a => a -> b -> [(a,b)] -> b\nlookupDefault k _ (lookup k -> Just s) = s\nlookupDefault _ d _ = d\n\nheadTup :: (a, [t]) -> [t]\nheadTup (headMay . snd -> Just n) = [n]\nheadTup _ = []\n\nheadNil :: [a] -> [a]\nheadNil (headMay -> Just x) = [x]\nheadNil _ = []\n```\n\n### TupleSections\n\n```haskell\n{-# LANGUAGE TupleSections #-}\n\nfirst :: a -> (a, Bool)\nfirst = (,True)\n\nsecond :: a -> (Bool, a)\nsecond = (True,)\nf :: t -> t1 -> t2 -> t3 -> (t, (), t1, (), (), t2, t3)\nf = (,(),,(),(),,)\n```\n\n### MultiWayIf\n\n`Multi-way if`扩展了传统的`if`语句，以允许模式匹配条件，该条件等于一系列`if-then-else`语句。这使我们可以在值上编写\"模式匹配谓词\"。这会更改`Haskell`语言的语法。\n\n```haskell\n{-# LANGUAGE MultiWayIf #-}\n\nbmiTell :: Float -> Text\nbmiTell bmi = if\n  | bmi <= 18.5 -> \"Underweight.\"\n  | bmi <= 25.0 -> \"Average weight.\"\n  | bmi <= 30.0 -> \"Overweight.\"\n  | otherwise   -> \"Clinically overweight.\"\n```\n\n### EmptyCase\n\n在`case`语句中，`GHC`通常至少需要一个模式分支这个限制可以用`-XEmptyCase`放宽。\n如果对`case`语句求值，那么它将立即生成一个`Non-exhaustive patterns in case`.\n\n```haskell\ntest = case of\n```\n\n### LambdaCase\n\n对于`case`语句，`LambdaCase`允许消除纯粹为了模式匹配而引入的冗余自由变量.\n\n沒有`LambdaCase`時:\n\n```haskell\n\\temp -> case temp of\n  p1 -> 32\n  p2 -> 32\n```\n\n有`LambdaCase`時:\n\n```haskell\n\\case\n  p1 -> 32\n  p2 -> 32\n{-# LANGUAGE LambdaCase #-}\n\ndata Exp a\n  = Lam a (Exp a)\n  | Var a\n  | App (Exp a) (Exp a)\n\nexample :: Exp a -> a\nexample = \\case\n  Lam a b -> a\n  Var a   -> a\n  App a b -> example a\n```\n\n### NumDecimals\n\n`NumDecimals`允许对不一定是浮点数的`integral literals`(整数文字)使用指数表示法。没有它，任何使用指数表示法都会引起`Fractional`(分数)类约束:\n\n```haskell\ngoogol :: Fractional a => a\ngoogol = 1e100\n\n{-# LANGUAGE NumDecimals #-}\ngoogol :: Num a => a\ngoogol = 1e100\n```\n\n### PackageImports\n\n`Package imports`允许我们通过它们各自的包`key`来消除分层包名称的歧义。这在必须导入公开同一模块的包的情况下非常有用。实际上，大多数公共库都注意避免名称空间中的冲突，这在大多数现代`Haskell`中通常不是问题。\n\n例如，我们可以明确要求`GHC`解决从`mtl`库提取的`Control.Monad.Error`包:\n\n```haskell\nimport qualified \"mtl\" Control.Monad.Error as Error\nimport qualified \"mtl\" Control.Monad.State as State\nimport qualified \"mtl\" Control.Monad.Reader as Reader\n```\n\n### RecordWildCards\n\n`Record`通配符使我们能够将`Record`的名称扩展为隐式包含在`Record`标签中的变量。\n\n该扩展名可用于将变量名称提取到作用域中或分配给`Record`图中的变量，使`Record`的标签与作用域中的变量对齐以进行分配。\n\n引入的语法是模式选择器`{..}`.\n\n```haskell\n{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Data.Text\n\ndata  Example = Example\n  { e1 :: Int\n  , e2 :: Text\n  , e3 :: Text\n  } deriving (Show)\n\n-- 使用通配符从记录中提取\nscope :: Example -> (Int, Text, Text)\nscope Example {..} = (e1, e2, e3)\n\n-- 使用通配符分配给记录\nassign :: Example\nassign = Example {..}\n  where\n    (e1, e2, e3) = (1, \"Kirk\", \"Picard\")\n```\n\n### NamedFieldPuns\n\n提供用于访问模式匹配中的`Record`字段的替代语法:\n\n```haskell\ndata D = D {a :: Int, b :: Int}\n\nf :: D -> Int\nf D {a, b} = a - b\n\n-- 顺序没关系\ng :: D -> Int\ng D {b, a} = a - b\n```\n\n### PatternSynonyms\n\n假设我们正在编写一个类型检查器，通常会包含一个`distinct`(独特)的`TArr`术语来`ease`(简化)函数签名的`telescoping`(伸缩)，这就是`GHC`在其`Core`语言中所做的。\n\n即使从技术上讲，它也可以用`(->)`构造函数的更基本的应用来编写.\n\n```haskell\ndata Type\n  = TVar TVar\n  | TCon TyCon\n  | TApp Type Type\n  | TArr Type Type\n  deriving (Show, Eq, Ord)\n```\n\n使用`pattern synonyms`，我们可以消除无关的构造函数，而不会失去在`arrow`类型上进行模式匹配的便利性:\n\n```haskell\n{-# LANGUAGE PatternSynonyms #-}\n\npattern TArr t1 t2 = TApp (TApp (TCon \"(->)\") t1) t2\n```\n\n因此，现在我们可以非常自然地为`arrow`类型编写`eliminator`(消除器)和构造函数。\n\n```haskell\n{-# LANGUAGE PatternSynonyms #-}\n\nimport Data.List (foldl1')\n\ntype Name  = String\ntype TVar  = String\ntype TyCon = String\n\ndata Type\n  = TVar TVar\n  | TCon TyCon\n  | TApp Type Type\n  deriving (Show, Eq, Ord)\n\n\npattern TArr t1 t2 = TApp (TApp (TCon \"(->)\") t1) t2\n\ntapp :: TyCon -> [Type] -> Type\ntapp tcon args = foldl TApp (TCon tcon) args\n\narr :: [Type] -> Type\narr ts = foldl1' (\\t1 t2 -> tapp \"(->)\" [t1, t2]) ts\n\nelimTArr :: Type -> [Type]\nelimTArr (TArr (TArr t1 t2) t3) = t1 : t2 : elimTArr t3\nelimTArr (TArr t1 t2) = t1 : elimTArr t2\nelimTArr t = [t]\n\n-- (->) a ((->) b a)\n-- a -> b -> a\nto :: Type\nto = arr [TVar \"a\", TVar \"b\", TVar \"a\"]\n\nfrom :: [Type]\nfrom = elimTArr to\n```\n\n`Pattern synonyms`可以像其他定义一样从模块中导出，方法是为它们加上前缀`pattern`:\n\n```haskell\n\nmodule MyModule (\n  pattern Elt\n) where\n\npattern Elt = [a]\n```\n\n請看:\n\n* [Pattern Synonyms in GHC 8](http://mpickering.github.io/posts/2015-12-12-pattern-synonyms-8.html)\n\n### DeriveFunctor\n\n```haskell\n{-# LANGUAGE DeriveFunctor #-}\n\ndata Tree a = Node a [Tree a]\n  deriving (Show, Functor)\n\ntree :: Tree Int\ntree = fmap (+1) (Node 1 [Node 2 [], Node 3 []])\n```\n\n### DeriveTraversable\n\n```haskell\n{-# LANGUAGE DeriveTraversable #-}\n{-# LANGUAGE PartialTypeSignatures #-}\n\n\ndata Tree a = Node a [Tree a]\n  deriving (Show, Functor, Foldable, Traversable)\n\ntree :: Maybe [Int]\ntree = foldMap go (Node [1] [Node [2] [], Node [3,4] []])\n  where\n    go [] = Nothing\n    go xs = Just xs\n```\n\n### DeriveFoldable\n\n> TODO\n\n### DeriveGeneric\n\n> TODO\n\n### DeriveAnyClass\n\n使用`-XDeriveAnyClass`，我们可以派生任何类。派生逻辑为没有显式定义方法的类型生成实例声明。\n如果`typeclass`为每个方法实现一个默认值，那么这将得到很好的定义并产生一个自动实例。\n\n### StaticPointers\n\n> TODO\n\n### DuplicateRecordFields\n\n`GHC 8.0`引入了`DuplicateRecordFields`扩展，它放宽了`GHC`对具有相同访问器的同一模块中的记录的限制。正被投射到的确切类型现在被推迟到`callsite`.\n\n```haskell\n{-# LANGUAGE DuplicateRecordFields #-}\n\ndata Person = Person { id :: Int }\ndata Animal = Animal { id :: Int }\ndata Vegetable = Vegetable { id :: Int }\n\ntest :: (Person, Animal, Vegetable)\ntest = (Person {id = 1}, Animal {id = 2}, Vegetable {id = 3})\n```\n\n仅使用`DuplicateRecordFields`，仍不支持`projection`(投影)，因此以下操作将不起作用。\n`OverloadedLabels`在某种程度上解决了这个问题.\n\n```haskell\ntest :: (Int, Int, Int)\ntest = (id (Person 1), id (Animal 2), id (Animal 3))\n```\n\n### OverloadedLabels\n\n`GHC 8.0`还引入了`OverloadedLabels`扩展，该扩展允许在共享相同名称的标签上使用有限形式的多态。\n\n要使用重载的标签类型，我们需要启用多种语言扩展，以与作为其实现基础的`promoted`(提升的)字符串和多参数类型类一起使用。\n\n```haskell\nextract :: IsLabel \"id\" t => t\nextract = #id\n{-# LANGUAGE OverloadedLabels #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE DuplicateRecordFields #-}\n{-# LANGUAGE ExistentialQuantification #-}\n\nimport GHC.Records (HasField(..))  -- Since base 4.10.0.0\nimport GHC.OverloadedLabels (IsLabel(..))\n\ndata S = MkS { foo :: Int }\ndata T x y z = forall b . MkT { foo :: y, bar :: b }\n\ninstance HasField x r a => IsLabel x (r -> a) where\n  fromLabel = getField\n\nmain :: IO ()\nmain = do\n  print (#foo (MkS 42))\n  print (#foo (MkT True False))\n```\n\n請看:\n\n* [OverloadedRecordFields revived](http://www.well-typed.com/blog/2015/03/overloadedrecordfields-revived/)\n\n### CPP\n\n每当我们确实需要分离必须跨越多个版本的`GHC`和语言更改而又要保持向后兼容性的逻辑时，`C++`预处理器就是`fallback`。它可以派发用于编译模块的`GHC`版本。\n\n```haskell\n{-# LANGUAGE CPP #-}\n\n#if (__GLASGOW_HASKELL__ > 710)\n-- Imports for GHC 7.10.x\n#else\n-- Imports for other GHC\n#endif\n```\n\n根据编译的操作系统划分代码:\n\n```haskell\n{-# LANGUAGE CPP #-}\n\n#ifdef OS_Linux\n  -- Linux specific logic\n#else\n# ifdef OS_Win32\n  -- Windows specific logic\n# else\n# ifdef OS_Mac\n  -- Macintosh specific logic\n# else\n  -- Other operating systems\n# endif\n# endif\n#endif\n```\n\n或使用的基本库的版本:\n\n```haskell\n#if !MIN_VERSION_base(4,6,0)\n  -- Base specific logic\n#endif\n```\n\n它也可能被滥用来做可怕的事情，例如用字符串进行元编程，但是请不要这样做。\n\n### Historical Extensions\n\n一些语言扩展要么被吸收到核心语言中，要么被弃用以支持其他语言。其他的被认为是不适合的。\n\n`Historical`暗示，不应使用此扩展，它纯粹是为了向后兼容而在`GHC`中使用。有时启用这些功能很危险。\n\n* Rank2Types - `Rank2Types`已包含在`RankNTypes`中.\n\n* XPolymorphicComponents - 是不再存在的`higher-rank`多态性的实现细节.\n\n* NPlusKPatterns - 这些基本上被认为是模式匹配语言的一个丑陋案例，最好将其删除.\n\n* TraditionalRecordSyntax - 传统`Record`语法是`Haskell 98`规范的扩展，现在我们认为是标准`Record`语法.\n\n* OverlappingInstances - 包含在显式的`OVERLAPPING pragmas`中.\n\n* IncoherentInstances - 包含在显式的`INCOHERENT pragmas`中.\n\n* NullaryTypeClasses - 包含在不带参数的显式`Multiparameter Typeclasses`中.\n","tags":["Language-Extensions"]},{"title":"Haskell-Network-Web","url":"/blog/2019/11/19/Haskell-Network-Web/","content":"> [原文](http://dev.stephendiehl.com/hask/#network-web-programming)\n\n`Network & Web Programming`\n\n### HTTP\n\n`Haskell`具有各种`HTTP`请求和处理库。最简单，最灵活的是[HTTP](https://hackage.haskell.org/package/HTTP)库.\n\n```haskell\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Network.HTTP.Types\nimport Network.HTTP.Client\nimport Control.Applicative\nimport Control.Concurrent.Async\n\ntype URL = String\n\nget :: Manager -> URL -> IO Int\nget m url = do\n  req <- parseUrl url\n  statusCode <$> responseStatus <$> httpNoBody req m\n\nsingle :: IO Int\nsingle = do\n  withManager defaultManagerSettings $ \\m -> do\n    get m \"http://haskell.org\"\n\nparallel :: IO [Int]\nparallel = do\n  withManager defaultManagerSettings $ \\m -> do\n    -- Fetch w3.org 10 times concurrently\n    let urls = replicate 10 \"http://www.w3.org\"\n    mapConcurrently (get m) urls\n\nmain :: IO ()\nmain = do\n  print =<< single\n  print =<< parallel\n```\n\n### Blaze\n\n`Blaze`是`HTML`组合器库，它提供了以编程方式构建`HTML`的可组合位的能力。\n\n它没有像[Hastache](http://dev.stephendiehl.com/hask/#hastache)这样的字符串模板库，而是提供了一个`API`，用于从逻辑上构建`HTML`文档，在逻辑上，程序会生成输出的格式。\n\n为了对`HTML`元素进行排序，这些元素可以按`monad`或使用`monoid`操作进行排序.\n\n```haskell\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Html where\n\nimport Text.Blaze.Html5\nimport Text.Blaze.Html.Renderer.Text\n\nimport qualified Data.Text.Lazy.IO as T\n\nexample :: Html\nexample = do\n  h1 \"First header\"\n  p $ ul $ mconcat [li \"First\", li \"Second\"]\n\nmain :: IO ()\nmain = do\n  T.putStrLn $ renderHtml example\n```\n\n对于自定义数据类型，我们可以实现`ToMarkupclass`以在`Haskell`数据结构和`HTML`表示之间进行转换.\n\n```haskell\n{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Html where\n\nimport Text.Blaze.Html5\nimport Text.Blaze.Html.Renderer.Text\n\nimport qualified Data.Text.Lazy as T\nimport qualified Data.Text.Lazy.IO as T\n\ndata Employee = Employee\n  { name :: T.Text\n  , age :: Int\n  }\n\ninstance ToMarkup Employee where\n  toMarkup Employee {..} = ul $ mconcat\n    [ li (toHtml name)\n    , li (toHtml age)\n    ]\n\nfred :: Employee\nfred = Employee { name = \"Fred\", age = 35 }\n\nmain :: IO ()\nmain = do\n  T.putStrLn $ renderHtml (toHtml fred)\n```\n\n### Warp\n\n`Warp`是一种高效的`Web`服务器，它是几种流行的`Haskell Web`框架背后的后端请求引擎。内部已经过微调，可以利用`Haskell`的并发运行时，并且能够处理大量并发请求.\n\n```haskell\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Network.Wai\nimport Network.Wai.Handler.Warp (run)\nimport Network.HTTP.Types\n\napp :: Application\napp req = return $ responseLBS status200 [] \"Engage!\"\n\nmain :: IO ()\nmain = run 8000 app\n```\n\n請看:\n\n* [Warp](http://aosabook.org/en/posa/warp.html)\n\n### Scotty\n\n继续我们在网络库中的跋涉，`Scotty`是一个网络微框架，其原理与`Python`中的`Flask`或`Ruby`中的`Sinatra`相似。\n\n```haskell\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Web.Scotty\n\nimport qualified Text.Blaze.Html5 as H\nimport Text.Blaze.Html5 (toHtml, Html)\nimport Text.Blaze.Html.Renderer.Text (renderHtml)\n\ngreet :: String -> Html\ngreet user = H.html $ do\n  H.head $\n    H.title \"Welcome!\"\n  H.body $ do\n    H.h1 \"Greetings!\"\n    H.p (\"Hello \" >> toHtml user >> \"!\")\n\napp = do\n  get \"/\" $\n    text \"Home Page\"\n\n  get \"/greet/:name\" $ do\n    name <- param \"name\"\n    html $ renderHtml (greet name)\n\nmain :: IO ()\nmain = scotty 8000 app\n```\n\n需要注意的重要一点是，这里使用的`Blaze`库重载了`do-notation`，但它本身并不是`proper`(适当的)`monad`，因此通常适用于`monad`的各种定律和不变量可能会因错误而失效或失败。\n\n可以在`Scotty Wiki`上找到有用的相关资源的集合:\n\n* [Scotty教程和示例](https://github.com/scotty-web/scotty/wiki)\n\n### Servant\n\n> TODO\n\n### Hastache\n\n`Hastache`是基于`Mustache`样式的字符串模板，该样式使用双括号`{{x}}`编码元变量。\n\n`Hastache`支持将许多`Haskell`类型自动转换为字符串，并使用高效的`Text`函数进行格式化。\n\n在将变量名称映射到可打印的`MuType`值的函数中，指定了加载到模板中的变量。例如使用函數。\n\n```haskell\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Text.Hastache\nimport Text.Hastache.Context\n\nimport qualified Data.Text as T\nimport qualified Data.Text.Lazy as TL\nimport qualified Data.Text.Lazy.IO as TL\n\nimport Data.Data\n\ntemplate :: FilePath -> MuContext IO -> IO TL.Text\ntemplate = hastacheFile defaultConfig\n\n-- Function strContext\ncontext :: String -> MuType IO\ncontext \"body\"  = MuVariable (\"Hello World\" :: TL.Text)\ncontext \"title\" = MuVariable (\"Haskell is lovely\" :: TL.Text)\ncontext _       = MuVariable ()\n\nmain :: IO ()\nmain = do\n  output <- template \"templates/home.html\" (mkStrContext context)\n  TL.putStrLn output\n```\n\n或使用`Data-Typeable`记录和`mkGenericContext`，将`Haskell`字段名称转换为变量名称.\n\n```haskell\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE DeriveDataTypeable #-}\n\nimport Text.Hastache\nimport Text.Hastache.Context\n\nimport qualified Data.Text.Lazy as TL\nimport qualified Data.Text.Lazy.IO as TL\n\nimport Data.Data\n\ntemplate :: FilePath -> MuContext IO -> IO TL.Text\ntemplate = hastacheFile defaultConfig\n\n-- Record context\ndata TemplateCtx = TemplateCtx\n  { body :: TL.Text\n  , title :: TL.Text\n  } deriving (Data, Typeable)\n\nmain :: IO ()\nmain = do\n  let ctx = TemplateCtx { body = \"Hello\", title = \"Haskell\" }\n  output <- template \"templates/home.html\" (mkGenericContext ctx)\n  TL.putStrLn output\n```\n\n`MuType`和`MuContext`类型可以由实现`MonadIO`的任何`monad`或转换器(而不仅仅是`IO`)进行参数化.","tags":["Network-Web"]},{"title":"Haskell-Languages","url":"/blog/2019/11/19/Haskell-Languages/","content":"\n> [原文](http://dev.stephendiehl.com/hask/#languages)\n\n\n### Binder Libraries\n\n* [Names for Free](https://nicolaspouillard.fr/publis/names-for-free.pdf)\n* Abstract Binding Trees\n* du Bruijn Indicies\n\n### unbound\n由於它主要是机械的，因此存在几个庫来机械化书写名称`capture`(捕获)和`substitution`(替换)的过程，最强大的可能是`unbound`库。\n例如，我们可以在简单类型的`lambda`演算上实现小型`Hindley-Milner`系统的推断函数，而不必自己编写名称捕获和替换机制。\n```haskell\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Infer where\n\nimport Data.String\nimport Data.Map (Map)\nimport Control.Monad.Error\nimport qualified Data.Map as Map\n\nimport qualified Unbound.LocallyNameless as NL\nimport Unbound.LocallyNameless hiding (Subst, compose)\n\ndata Type\n  = TVar (Name Type)\n  | TArr Type Type\n  deriving (Show)\n\ndata Expr\n  = Var (Name Expr)\n  | Lam (Bind (Name Expr) Expr)\n  | App Expr Expr\n  | Let (Bind (Name Expr) Expr)\n  deriving (Show)\n\n$(derive [''Type, ''Expr])\n\n\ninstance IsString Expr where\n    fromString = Var . fromString\ninstance IsString Type where\n    fromString = TVar . fromString\ninstance IsString (Name Expr) where\n    fromString = string2Name\ninstance IsString (Name Type) where\n    fromString = string2Name\n\ninstance Eq Type where\n    (==) = eqType\n\neqType :: Type -> Type -> Bool\neqType (TVar v1) (TVar v2) = v1 == v2\neqType _ _ = False\n\nuvar :: String -> Expr\nuvar x = Var (s2n x)\n\ntvar :: String -> Type\ntvar x = TVar (s2n x)\n\ninstance Alpha Type\ninstance Alpha Expr\n\ninstance NL.Subst Type Type where\n  isvar (TVar v) = Just (SubstName v)\n  isvar _ = Nothing\n\ninstance NL.Subst Expr Expr where\n  isvar (Var v) = Just (SubstName v)\n  isvar _ = Nothing\n\ninstance NL.Subst Expr Type where\n\n\ndata TypeError\n  = UnboundVariable (Name Expr)\n  | GenericTypeError\n  deriving (Show)\n\ninstance Error TypeError where\n  noMsg = GenericTypeError\n\n\ntype Env = Map (Name Expr) Type\ntype Constraint = (Type, Type)\ntype Infer = ErrorT TypeError FreshM\n\nempty :: Env\nempty = Map.empty\n\nfreshtv :: Infer Type\nfreshtv = do\n  x <- fresh \"_t\"\n  return $ TVar x\n\ninfer :: Env -> Expr -> Infer (Type, [Constraint])\ninfer env expr = case expr  of\n\n  Lam b -> do\n    (n,e) <- unbind b\n    tv <- freshtv\n    let env' = Map.insert n tv env\n    (t, cs) <- infer env' e\n    return (TArr tv t, cs)\n\n  App e1 e2 -> do\n     (t1, cs1) <- infer env e1\n     (t2, cs2) <- infer env e2\n     tv <- freshtv\n     return (tv, (t1, TArr t2 tv) : cs1 ++ cs2)\n\n  Var n -> do\n     case Map.lookup n env of\n        Nothing -> throwError $ UnboundVariable n\n        Just t  -> return (t, [])\n\n  Let b -> do\n     (n, e) <- unbind b\n     (tBody, csBody) <- infer env e\n     let env' = Map.insert n tBody env\n     (t, cs) <- infer env' e\n     return (t, cs ++ csBody)\n```\n\n### unbound-generics\n\n最近未绑定被移植为使用`GHC.Generics`而不是`Template Haskell`。\n该`API`实际上是相同的，因此，例如，一个简单的`lambda`演算可以写为:\n\n```haskell\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE DeriveDataTypeable #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule LC where\n\nimport Unbound.Generics.LocallyNameless\nimport Unbound.Generics.LocallyNameless.Internal.Fold (toListOf)\n\nimport GHC.Generics\n\nimport Data.Typeable (Typeable)\nimport Data.Set as S\n\nimport Control.Monad.Reader (Reader, runReader)\n\ndata Exp\n  = Var (Name Exp)\n  | Lam (Bind (Name Exp) Exp)\n  | App Exp Exp\n  deriving (Show, Generic, Typeable)\n\ninstance Alpha Exp\n\ninstance Subst Exp Exp where\n  isvar (Var x) = Just (SubstName x)\n  isvar _       = Nothing\n\nfvSet :: (Alpha a, Typeable b) => a -> S.Set (Name b)\nfvSet = S.fromList . toListOf fv\n\ntype M a = FreshM a\n\n(=~) :: Exp -> Exp -> M Bool\ne1 =~ e2 | e1 `aeq` e2 = return True\ne1 =~ e2 = do\n    e1' <- red e1\n    e2' <- red e2\n    if e1' `aeq` e1 && e2' `aeq` e2\n      then return False\n      else e1' =~ e2'\n\n-- Reduction\nred :: Exp -> M Exp\nred (App e1 e2) = do\n  e1' <- red e1\n  e2' <- red e2\n  case e1' of\n    Lam bnd -> do\n        (x, e1'') <- unbind bnd\n        return $ subst x e2' e1''\n    otherwise -> return $ App e1' e2'\nred (Lam bnd) = do\n   (x, e) <- unbind bnd\n   e' <- red e\n   case e of\n     App e1 (Var y) | y == x && x `S.notMember` fvSet e1 -> return e1\n     otherwise -> return (Lam (bind x e'))\nred (Var x) = return $ (Var x)\n\n\nx :: Name Exp\nx = string2Name \"x\"\n\ny :: Name Exp\ny = string2Name \"y\"\n\nz :: Name Exp\nz = string2Name \"z\"\n\ns :: Name Exp\ns = string2Name \"s\"\n\nlam :: Name Exp -> Exp -> Exp\nlam x y = Lam (bind x y)\n\nzero  = lam s (lam z (Var z))\none   = lam s (lam z (App (Var s) (Var z)))\ntwo   = lam s (lam z (App (Var s) (App (Var s) (Var z))))\nthree = lam s (lam z (App (Var s) (App (Var s) (App (Var s) (Var z)))))\n\nplus = lam x (lam y (lam s (lam z (App (App (Var x) (Var s)) (App (App (Var y) (Var s)) (Var z))))))\n\ntrue = lam x (lam y (Var x))\nfalse = lam x (lam y (Var y))\nif_ x y z = (App (App x y) z)\n\nmain :: IO ()\nmain = do\n  print $ lam x (Var x) `aeq` lam y (Var y)\n  print $ not (lam x (Var y) `aeq` lam x (Var x))\n  print $ lam x (App (lam y (Var x)) (lam y (Var y))) =~ (lam y (Var y))\n  print $ lam x (App (Var y) (Var x)) =~ Var y\n  print $ if_ true (Var x) (Var y) =~ Var x\n  print $ if_ false (Var x) (Var y) =~ Var y\n  print $ App (App plus one) two =~ three\n```\n\n請看:\n\n* [unbound-generics](https://github.com/lambdageek/unbound-generics)\n\n### pretty\n\n漂亮的`printer`组合器组成逻辑来`print`字符串。\n\n```haskell\n        Combinators\n---------------------\n<>      Concatenation\n<+>     间隔连接\nchar    将字符渲染为文档\ntext    将字符串渲染为文档\n```\n\n```haskell\n{-# LANGUAGE FlexibleInstances #-}\n\nimport Text.PrettyPrint\nimport Text.Show.Pretty (ppShow)\n\nparensIf ::  Bool -> Doc -> Doc\nparensIf True = parens\nparensIf False = id\n\ntype Name = String\n\ndata Expr\n  = Var String\n  | Lit Ground\n  | App Expr Expr\n  | Lam Name Expr\n  deriving (Eq, Show)\n\ndata Ground\n  = LInt Int\n  | LBool Bool\n  deriving (Show, Eq, Ord)\n\n\nclass Pretty p where\n  ppr :: Int -> p -> Doc\n\ninstance Pretty String where\n  ppr _ x = text x\n\ninstance Pretty Expr where\n  ppr _ (Var x)         = text x\n  ppr _ (Lit (LInt a))  = text (show a)\n  ppr _ (Lit (LBool b)) = text (show b)\n\n  ppr p e@(App _ _) =\n    let (f, xs) = viewApp e in\n    let args = sep $ map (ppr (p+1)) xs in\n    parensIf (p>0) $ ppr p f <+> args\n\n  ppr p e@(Lam _ _) =\n    let body = ppr (p+1) (viewBody e) in\n    let vars = map (ppr 0) (viewVars e) in\n    parensIf (p>0) $ char '\\\\' <> hsep vars <+> text \".\" <+> body\n\nviewVars :: Expr -> [Name]\nviewVars (Lam n a) = n : viewVars a\nviewVars _ = []\n\nviewBody :: Expr -> Expr\nviewBody (Lam _ a) = viewBody a\nviewBody x = x\n\nviewApp :: Expr -> (Expr, [Expr])\nviewApp (App e1 e2) = go e1 [e2]\n  where\n    go (App a b) xs = go a (b : xs)\n    go f xs = (f, xs)\n\nppexpr :: Expr -> String\nppexpr = render . ppr 0\n\n\ns, k, example :: Expr\ns = Lam \"f\" (Lam \"g\" (Lam \"x\" (App (Var \"f\") (App (Var \"g\") (Var \"x\")))))\nk = Lam \"x\" (Lam \"y\" (Var \"x\"))\nexample = App s k\n\nmain :: IO ()\nmain = do\n  putStrLn $ ppexpr s\n  putStrLn $ ppShow example\n```\n\n`k`组合器的漂亮打印形式:\n\n```haskell\n\\f g x . (f (g x))\n```\n\n`Text.Show.Pretty`库可用于以更易于理解的形式对实现`Show`的任何类型的嵌套数据结构进行漂亮的輸出。\n\n例如，带有`ppShow`的`SK`组合器`AST`的结构转储。\n\n```haskell\nApp\n  (Lam\n     \"f\" (Lam \"g\" (Lam \"x\" (App (Var \"f\") (App (Var \"g\") (Var \"x\"))))))\n  (Lam \"x\" (Lam \"y\" (Var \"x\")))\n```\n\n将以下内容添加到`ghci.conf`中对于交互式地处理深度嵌套的结构可能会很有用。\n\n```haskell\nimport Text.Show.Pretty (ppShow)\nlet pprint x = putStrLn $ ppShow x\n```\n\n請看:\n\n* [The Design of a Pretty-printing Library](http://belle.sourceforge.net/doc/hughes95design.pdf)\n\n### wl-pprint-text\n\n`wl-pprint-text`是`Wadler`风格的漂亮打印库，它使用`Text`构建器对象在后台高效生成。\n\n它`effectively`(有效)地公开了与基于`String`的漂亮库相同的接口，但性能更高。\n\n```haskell\nCombinators\n\nrenderPretty :: Float -> Int -> Doc -> SimpleDoc\nrenderCompact :: Doc -> SimpleDoc\nrenderOneLine :: Doc -> SimpleDoc\n```\n\n請看:\n\n***Monadic API***\n* [wl-pprint-text](https://hackage.haskell.org/package/wl-pprint-text)\n\n### pretty-show\n\n> TODO\n\n### Haskeline\n\n`Haskeline`是跨平台的`readline`支持，对`GHCi`也很好。\n```haskell\nrunInputT :: Settings IO -> InputT IO a -> IO a\ngetInputLine :: String -> InputT IO (Maybe String)\nimport Control.Monad.Trans\nimport System.Console.Haskeline\n\ntype Repl a = InputT IO a\n\nprocess :: String -> IO ()\nprocess = putStrLn\n\nrepl :: Repl ()\nrepl = do\n  minput <- getInputLine \"Repl> \"\n  case minput of\n    Nothing -> outputStrLn \"Goodbye.\"\n    Just input -> (liftIO $ process input) >> repl\n\nmain :: IO ()\nmain = runInputT defaultSettings repl\n```\n\n### Repline\n\n构建命令行`REPL`接口中的某些任务是如此普遍，以至于将它们抽象到库中变得很有用。\n\n尽管`haskeline`提供了一个明智的用于与`GNU readline`交互的较低级`API`，但是一遍又一遍地实现`tab completion`(命令補全)逻辑和通用命令逻辑有些繁琐。\n\n为此，`Repline`协助构建类似于`GHCi`的默认行为的交互式`shell`.\n\n```haskell\nmodule Main where\n\nimport Control.Monad.Trans\nimport System.Console.Repline\n\nimport Data.List (isPrefixOf)\nimport System.Process (callCommand)\n\ntype Repl a = HaskelineT IO a\n\n-- Evaluation : 处理每行用户输入\ncmd :: String -> Repl ()\ncmd input = liftIO $ print input\n\n-- Tab Completion: 返回输入的部分单词的补全\ncompleter :: Monad m => WordCompleter m\ncompleter n = do\n  let names = [\"kirk\", \"spock\", \"mccoy\"]\n  return $ filter (isPrefixOf n) names\n\n-- Commands\nhelp :: [String] -> Repl ()\nhelp args = liftIO $ print $ \"Help: \" ++ show args\n\nsay :: [String] -> Repl ()\nsay args = do\n  _ <- liftIO $ callCommand $ \"cowsay\" ++ \" \" ++ (unwords args)\n  return ()\n\noptions :: [(String, [String] -> Repl ())]\noptions = [\n    (\"help\", help)  -- :help\n  , (\"say\", say)    -- :say\n  ]\n\nini :: Repl ()\nini = liftIO $ putStrLn \"Welcome!\"\n\nrepl :: IO ()\nrepl = evalRepl \">>> \" cmd options (Word0 completer) ini\n\nmain :: IO ()\nmain = repl\n```\n\n尝试一下.(`<TAB>`表示用户按键)\n\n```haskell\n$ runhaskell Simple.hs\n# Or if in a sandbox: cabal exec runhaskell Simple.hs\nWelcome!\n>>> <TAB>\nkirk spock mccoy\n\n>>> k<TAB>\nkirk\n\n>>> spam\n\"spam\"\n\n>>> :say Hello Haskell\n _______________\n< Hello Haskell >\n ---------------\n        \\   ^__^\n         \\  (oo)\\_______\n            (__)\\       )\\/\\\n                ||----w |\n                ||     ||\n```\n\n請看:\n\n* [repline](https://github.com/sdiehl/repline)","tags":["Languages"]},{"title":"Haskell-Testing","url":"/blog/2019/11/05/Haskell-Testing/","content":"> [原文](http://dev.stephendiehl.com/hask/#testing)\n\n与许多错误信息相反，`Haskell`中的单元测试非常常见和健壮。尽管一般来说，单元测试在`Haskell`中的重要性较低，因为类型系统使得大量的无效程序在构造时完全无法表达。\n单元测试往往是在开发生命周期的后期编写的，通常是关于程序的核心逻辑的，而不是`intermediate plumbing`(中间管道)。\n\n关于`Haskell`库设计的著名思想流派倾向于围绕以强大的方程定律为基础构建的程序，这些定律可保证在组合下程序行为具有强大的不变性。许多测试工具都是围绕这种设计风格构建的。\n\n### QuickCheck\n\n`QuickCheck`可能是最著名的`Haskell`库，它是一个测试框架，用于根据参数的类型自动为任意函数生成大型随机测试:\n\n```haskell\nquickCheck :: Testable prop => prop -> IO ()\n(==>) :: Testable prop => Bool -> prop -> Property\nforAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property\nchoose :: Random a => (a, a) -> Gen a\nimport Test.QuickCheck\n\nqsort :: [Int] -> [Int]\nqsort []     = []\nqsort (x:xs) = qsort lhs ++ [x] ++ qsort rhs\n    where lhs = filter  (< x) xs\n          rhs = filter (>= x) xs\n\nprop_maximum ::  [Int] -> Property\nprop_maximum xs = not (null xs) ==>\n                  last (qsort xs) == maximum xs\n\nmain :: IO ()\nmain = quickCheck prop_maximum\n$ runhaskell qcheck.hs\n*** Failed! Falsifiable (after 3 tests and 4 shrinks):\n[0]\n[1]\n\n$ runhaskell qcheck.hs\n+++ OK, passed 1000 tests.\n```\n可以使用自定义类型扩展测试数据生成器，并使用限制要测试案例范围的谓词来完善测试数据生成器:\n```haskell\nimport Test.QuickCheck\n\ndata Color = Red | Green | Blue deriving Show\n\ninstance Arbitrary Color where\n  arbitrary = do\n    n <- choose (0,2) :: Gen Int\n    return $ case n of\n      0 -> Red\n      1 -> Green\n      2 -> Blue\n\nexample1 :: IO [Color]\nexample1 = sample' arbitrary\n-- [Red,Green,Red,Blue,Red,Red,Red,Blue,Green,Red,Red]\n```\n\n請看:\n\n* [QuickCheck: An Automatic Testing Tool for Haskell](http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html)\n\n### SmallCheck\n\n与`QuickCheck`一样，`SmallCheck`是一个属性测试系统，但它不会生成随机的任意测试数据，而是枚举确定性的一系列测试数据到固定深度。\n\n```haskell\nsmallCheck :: Testable IO a => Depth -> a -> IO ()\nlist :: Depth -> Series Identity a -> [a]\nsample' :: Gen a -> IO [a]\nλ: list 3 series :: [Int]\n[0,1,-1,2,-2,3,-3]\n\nλ: list 3 series :: [Double]\n[0.0,1.0,-1.0,2.0,0.5,-2.0,4.0,0.25,-0.5,-4.0,-0.25]\n\nλ: list 3 series :: [(Int, String)]\n[(0,\"\"),(1,\"\"),(0,\"a\"),(-1,\"\"),(0,\"b\"),(1,\"a\"),(2,\"\"),(1,\"b\"),(-1,\"a\"),(-2,\"\"),(-1,\"b\"),(2,\"a\"),(-2,\"a\"\n```\n\n在一个程序的所有可能的输入上生成测试用例，直到一定深度是很有用的。\n\n```haskell\nimport Test.SmallCheck\n\ndistrib :: Int -> Int -> Int -> Bool\ndistrib a b c = a * (b + c) == a * b + a * c\n\ncauchy :: [Double] -> [Double] -> Bool\ncauchy xs ys = (abs (dot xs ys))^2 <= (dot xs xs) * (dot ys ys)\n\nfailure :: [Double] -> [Double] -> Bool\nfailure xs ys = abs (dot xs ys) <= (dot xs xs) * (dot ys ys)\n\ndot :: Num a => [a] -> [a] -> a\ndot xs ys = sum (zipWith (*) xs ys)\n\nmain :: IO ()\nmain = do\n  putStrLn \"Testing distributivity...\"\n  smallCheck 25 distrib\n\n  putStrLn \"Testing Cauchy-Schwarz...\"\n  smallCheck 4 cauchy\n\n  putStrLn \"Testing invalid Cauchy-Schwarz...\"\n  smallCheck 4 failure\n$ runhaskell smallcheck.hs\nTesting distributivity...\nCompleted 132651 tests without failure.\n\nTesting Cauchy-Schwarz...\nCompleted 27556 tests without failure.\n\nTesting invalid Cauchy-Schwarz...\nFailed test no. 349.\nthere exist [1.0] [0.5] such that\n  condition is false\n```\n\n就像`QuickCheck`一样，我们可以为我們的自定义数据类型实现`series`(系列)实例。 例如，`Vector`没有默认实例，因此让我们实现一个实例:\n\n```haskell\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n\nimport Test.SmallCheck\nimport Test.SmallCheck.Series\nimport Control.Applicative\n\nimport qualified Data.Vector as V\n\ndot :: Num a => V.Vector a -> V.Vector a -> a\ndot xs ys = V.sum (V.zipWith (*) xs ys)\n\ncauchy :: V.Vector Double -> V.Vector Double -> Bool\ncauchy xs ys = (abs (dot xs ys))^2 <= (dot xs xs) * (dot ys ys)\n\ninstance (Serial m a, Monad m) => Serial m (V.Vector a) where\n  series = V.fromList <$> series\n\nmain :: IO ()\nmain = smallCheck 4 cauchy\n```\n\n`SmallCheck`也可以使用泛型来派生`Serial`实例，例如，枚举一定深度的所有树，我们可以使用:\n\n```haskell\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE DeriveGeneric #-}\n\nimport GHC.Generics\nimport Test.SmallCheck.Series\n\ndata Tree a = Null | Fork (Tree a) a (Tree a)\n    deriving (Show, Generic)\n\ninstance Serial m a => Serial m (Tree a)\n\nexample :: [Tree ()]\nexample = list 3 series\n\nmain = print example\n```\n\n### QuickSpec\n\n使用`QuickCheck`任意机制，我们还可以显着地列举大量函數组合，以尝试从`small cases`(小情况)下尝试输入来推导代数定律。\n\n当然，这种方法的基本局限性在于，对于小情况或简单的函数组合，函数可能不会表现出任何令人感兴趣的特性。 因此，在一般情况下，这种方法将行不通，但实际上它仍然非常有用。\n\n```haskell\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nimport Data.List\nimport Data.Typeable\n\nimport Test.QuickSpec hiding (lists, bools, arith)\nimport Test.QuickCheck\n\ntype Var k a = (Typeable a, Arbitrary a, CoArbitrary a, k a)\n\nlistCons :: forall a. Var Ord a => a -> Sig\nlistCons a = background\n  [\n    \"[]\"      `fun0` ([]      :: [a]),\n    \":\"       `fun2` ((:)     :: a -> [a] -> [a])\n  ]\n\nlists :: forall a. Var Ord a => a -> [Sig]\nlists a =\n  [\n    -- 打印任意变量的名称\n    funs',\n    funvars',\n    vars',\n\n    -- 环境定义\n    listCons a,\n\n    -- 推导...的性质的表达式\n    \"sort\"     `fun1` (sort    :: [a] -> [a]),\n    \"map\"      `fun2` (map     :: (a -> a) -> [a] -> [a]),\n    \"id\"       `fun1` (id      :: [a] -> [a]),\n    \"reverse\"  `fun1` (reverse :: [a] -> [a]),\n    \"minimum\"  `fun1` (minimum :: [a] -> a),\n    \"length\"   `fun1` (length  :: [a] -> Int),\n    \"++\"       `fun2` ((++)    :: [a] -> [a] -> [a])\n  ]\n\n  where\n    funs'    = funs (undefined :: a)\n    funvars' = vars [\"f\", \"g\", \"h\"] (undefined :: a -> a)\n    vars'    = [\"xs\", \"ys\", \"zs\"] `vars` (undefined :: [a])\n\n\ntvar :: A\ntvar = undefined\n\nmain :: IO ()\nmain = quickSpec (lists tvar)\n```\n\n运行这个我们更愿意看到它能够推导出列表函数的大多数定律:\n\n```haskell\n$ runhaskell src/quickspec.hs\n== API ==\n-- functions --\nmap :: (A -> A) -> [A] -> [A]\nminimum :: [A] -> A\n(++) :: [A] -> [A] -> [A]\nlength :: [A] -> Int\nsort, id, reverse :: [A] -> [A]\n\n-- background functions --\nid :: A -> A\n(:) :: A -> [A] -> [A]\n(.) :: (A -> A) -> (A -> A) -> A -> A\n[] :: [A]\n\n-- variables --\nf, g, h :: A -> A\nxs, ys, zs :: [A]\n\n-- 以下类型正在使用非标准的相等性 --\nA -> A\n\n-- WARNING: 没有以下类型的变量；考虑添加一些 --\nA\n\n== Testing ==\nDepth 1: 12 terms, 4 tests, 24 evaluations, 12 classes, 0 raw equations.\nDepth 2: 80 terms, 500 tests, 18673 evaluations, 52 classes, 28 raw equations.\nDepth 3: 1553 terms, 500 tests, 255056 evaluations, 1234 classes, 319 raw equations.\n319 raw equations; 1234 terms in universe.\n\n== Equations about map ==\n  1: map f [] == []\n  2: map id xs == xs\n  3: map (f.g) xs == map f (map g xs)\n\n== Equations about minimum ==\n  4: minimum [] == undefined\n\n== Equations about (++) ==\n  5: xs++[] == xs\n  6: []++xs == xs\n  7: (xs++ys)++zs == xs++(ys++zs)\n\n== Equations about sort ==\n  8: sort [] == []\n  9: sort (sort xs) == sort xs\n\n== Equations about id ==\n 10: id xs == xs\n\n== Equations about reverse ==\n 11: reverse [] == []\n 12: reverse (reverse xs) == xs\n\n== Equations about several functions ==\n 13: minimum (xs++ys) == minimum (ys++xs)\n 14: length (map f xs) == length xs\n 15: length (xs++ys) == length (ys++xs)\n 16: sort (xs++ys) == sort (ys++xs)\n 17: map f (reverse xs) == reverse (map f xs)\n 18: minimum (sort xs) == minimum xs\n 19: minimum (reverse xs) == minimum xs\n 20: minimum (xs++xs) == minimum xs\n 21: length (sort xs) == length xs\n 22: length (reverse xs) == length xs\n 23: sort (reverse xs) == sort xs\n 24: map f xs++map f ys == map f (xs++ys)\n 25: reverse xs++reverse ys == reverse (ys++xs)\n ```\n\n请记住一个相当显着的事实，那就是所有这些都是从类型中自动推导出的！\n\n### Criterion(标准)\n\n`Criterion`是一种具有统计意义的基准测试工具。\n\n```haskell\nwhnf :: (a -> b) -> a -> Pure\nnf :: NFData b => (a -> b) -> a -> Pure\nnfIO :: NFData a => IO a -> IO ()\nbench :: Benchmarkable b => String -> b -> Benchmark\nimport Criterion.Main\nimport Criterion.Config\n\n-- 斐波那契数的幼稚递归\nfib1 :: Int -> Int\nfib1 0 = 0\nfib1 1 = 1\nfib1 n = fib1 (n-1) + fib1 (n-2)\n\n-- Use the De Moivre closed form for fibonacci numbers.\nfib2 :: Int -> Int\nfib2 x = truncate $ ( 1 / sqrt 5 ) * ( phi ^ x - psi ^ x )\n  where\n      phi = ( 1 + sqrt 5 ) / 2\n      psi = ( 1 - sqrt 5 ) / 2\n\nsuite :: [Benchmark]\nsuite = [\n    bgroup \"naive\" [\n      bench \"fib 10\" $ whnf fib1 5\n    , bench \"fib 20\" $ whnf fib1 10\n    ],\n    bgroup \"de moivre\" [\n      bench \"fib 10\" $ whnf fib2 5\n    , bench \"fib 20\" $ whnf fib2 10\n    ]\n  ]\n\nmain :: IO ()\nmain = defaultMain suite\n$ runhaskell criterion.hs\nwarming up\nestimating clock resolution...\nmean is 2.349801 us (320001 iterations)\nfound 1788 outliers among 319999 samples (0.6%)\n  1373 (0.4%) high severe\nestimating cost of a clock call...\nmean is 65.52118 ns (23 iterations)\nfound 1 outliers among 23 samples (4.3%)\n  1 (4.3%) high severe\n\nbenchmarking naive/fib 10\nmean: 9.903067 us, lb 9.885143 us, ub 9.924404 us, ci 0.950\nstd dev: 100.4508 ns, lb 85.04638 ns, ub 123.1707 ns, ci 0.950\n\nbenchmarking naive/fib 20\nmean: 120.7269 us, lb 120.5470 us, ub 120.9459 us, ci 0.950\nstd dev: 1.014556 us, lb 858.6037 ns, ub 1.296920 us, ci 0.950\n\nbenchmarking de moivre/fib 10\nmean: 7.699219 us, lb 7.671107 us, ub 7.802116 us, ci 0.950\nstd dev: 247.3021 ns, lb 61.66586 ns, ub 572.1260 ns, ci 0.950\nfound 4 outliers among 100 samples (4.0%)\n  2 (2.0%) high mild\n  2 (2.0%) high severe\nvariance introduced by outliers: 27.726%\nvariance is moderately inflated by outliers\n\nbenchmarking de moivre/fib 20\nmean: 8.082639 us, lb 8.018560 us, ub 8.350159 us, ci 0.950\nstd dev: 595.2161 ns, lb 77.46251 ns, ub 1.408784 us, ci 0.950\nfound 8 outliers among 100 samples (8.0%)\n  4 (4.0%) high mild\n  4 (4.0%) high severe\nvariance introduced by outliers: 67.628%\nvariance is severely inflated by outliers\n```\n\n`Criterion`还可以生成一个`HTML`页面，其中包含绘制的基准测试结果:\n\n```haskell\n$ ghc -O2 --make criterion.hs\n$ ./criterion -o bench.html\n```\n\n![](img/img01.png)\n\n### Tasty\n\n`Tasty`将所有测试框架组合到一个通用`API`中，以形成可运行的批量测试并收集结果。\n\n```haskell\nimport Test.Tasty\nimport Test.Tasty.HUnit\nimport Test.Tasty.QuickCheck\nimport qualified Test.Tasty.SmallCheck as SC\n\narith :: Integer -> Integer -> Property\narith x y = (x > 0) && (y > 0) ==> (x+y)^2 > x^2 + y^2\n\nnegation :: Integer -> Bool\nnegation x = abs (x^2) >= x\n\nsuite :: TestTree\nsuite = testGroup \"Test Suite\" [\n    testGroup \"Units\"\n      [ testCase \"Equality\" $ True @=? True\n      , testCase \"Assertion\" $ assert $ (length [1,2,3]) == 3\n      ],\n\n    testGroup \"QuickCheck tests\"\n      [ testProperty \"Quickcheck test\" arith\n      ],\n\n    testGroup \"SmallCheck tests\"\n      [ SC.testProperty \"Negation\" negation\n      ]\n  ]\n\nmain :: IO ()\nmain = defaultMain suite\n$ runhaskell TestSuite.hs\nUnit tests\n  Units\n    Equality:        OK\n    Assertion:       OK\n  QuickCheck tests\n    Quickcheck test: OK\n      +++ OK, passed 100 tests.\n  SmallCheck tests\n    Negation:        OK\n      11 tests completed\n```\n\n### silently\n\n通常在测试`IO heavy`繁重代码的过程中，我们需要重定向`stdout`来比较一些已知的`quantity`(数量)。\n`silent`包允许我们捕获`IO`块内任何库中对`stdout`所做的任何操作，并将结果返回给测试运行程序.\n\n```haskell\ncapture :: IO a -> IO (String, a)\nimport Test.Tasty\nimport Test.Tasty.HUnit\nimport System.IO.Silently\n\ntest :: Int -> IO ()\ntest n = print (n * n)\n\ntestCapture n = do\n  (stdout, result) <- capture (test n)\n  assert (stdout == show (n*n) ++ \"\\n\")\n\nsuite :: TestTree\nsuite = testGroup \"Test Suite\" [\n    testGroup \"Units\"\n      [ testCase \"Equality\" $ testCapture 10\n      ]\n  ]\n\nmain :: IO ()\nmain = defaultMain suite\n```","tags":["Testing"]},{"title":"Haskell-Strings","url":"/blog/2019/11/05/Haskell-Strings/","content":"> [原文](http://dev.stephendiehl.com/hask/#strings)\n\n### String\n> 默认的字符串类型已损坏，应尽可能避免使用。 不幸的是，由于历史原因，GHC和Base的大部分都依赖于String。\n\n默认的`Haskell`字符串类型被实现为一个天真的字符链接列表，这在大多数情况下都是很糟糕的，但是没有人知道如何修复它，而不重写存在的所有代码的大部分，没有人能确定时间来修复它。所以它仍然破碎，很可能永远破碎。\n\n```haskell\ntype String = [Char]\n```\n对于性能更敏感的情况，有两个用于处理文本数据的库：`text`和`bytestring`。\n* **text** 用于处理`Unicode`数据。\n* **bytestring** 用于处理需要与`C`代码或网络协议互换的`ASCII`数据。\n\n对于这两种格式，`text`和`bytestring`都有两个变体。\n\n* **lazy** 惰性文本对象被编码为严格字节`chunks`(块)的惰性列表。\n* **lazy** 字节向量被编码为字节或代码点的严格`Word8`数组.\n\n产生了四种类型:\n```haskell\nVariant\t            Module\n-----------------------------------------\nstrict text\t        Data.Text\nlazy text\t        Data.Text.Lazy\nstrict bytestring\tData.ByteString\nlazy bytestring\t    Data.ByteString.Lazy\n```\n\n#### Conversions(转换)\n\n字符串类型之间的转换是通过`bytestring`和`text`库中的几个函数完成的。\n`text`和`bytestring`之间的映射本质上是有损的，因此在选择编码时有一定的自由度。为了简单起见，我们只考虑使用`utf-8`。\n\n![](img/img01.png)\n\n#### Overloaded Strings\n使用`-XOverloadedStrings`扩展名，可以在不需要显式打包的情况下重载字符串文字，并且可以在`Haskell`源代码中将其作为字符串文字编写，并通过类型类`IsString`重载。 有时这是可取的。\n\n```haskell\nclass IsString a where\n  fromString :: String -> a\n```\n例如:\n```haskell\nλ: :type \"foo\"\n\"foo\" :: [Char]\n\nλ: :set -XOverloadedStrings\n\nλ: :type \"foo\"\n\"foo\" :: IsString a => a\n```\n我们还可以使用`generalizednewtypedering`为`newtypes`派生`IsString`，尽管如果`newtype`可以与其他字符串互换，那么它的许多安全性就会丢失。\n\n```haskell\nnewtype Cat = Cat Text\n  deriving (IsString)\n\nfluffy :: Cat\nfluffy = \"Fluffy\"\n```\n\n### Import Conventions\n\n```haskell\nimport qualified Data.Text as T\nimport qualified Data.Text.Lazy as TL\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Lazy as BL\nimport qualified Data.ByteString.Char8 as C\nimport qualified Data.ByteString.Lazy.Char8 as CL\nimport qualified Data.Text.IO as TIO\nimport qualified Data.Text.Lazy.IO as TLIO\nimport qualified Data.Text.Encoding as TE\nimport qualified Data.Text.Lazy.Encoding as TLE\n```\n\n### Text\n`文本`类型是一堆`Unicode`字符。\n```haskell\npack :: String -> Text\nunpack :: Text -> String\n{-# LANGUAGE OverloadedStrings #-}\n\nimport qualified Data.Text as T\n\n-- From pack\nmyTStr1 :: T.Text\nmyTStr1 = T.pack (\"foo\" :: String)\n\n-- From overloaded string literal.\nmyTStr2 :: T.Text\nmyTStr2 = \"bar\"\n```\n請看:\n* [Text](http://hackage.haskell.org/package/text-1.1.0.1/docs/Data-Text.html)\n\n### Text.Builder\n```haskell\ntoLazyText :: Builder -> Data.Text.Lazy.Internal.Text\nfromLazyText :: Data.Text.Lazy.Internal.Text -> Builder\n```\n`Text.Builder`允许对惰性文本类型进行高效的`monoidal`(单项的)构造，而不必通过诸如`String`或`List`类型之类的低效率形式作为中介。\n```haskell\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Data.Monoid (mconcat, (<>))\n\nimport Data.Text.Lazy.Builder (Builder, toLazyText)\nimport Data.Text.Lazy.Builder.Int (decimal)\nimport qualified Data.Text.Lazy.IO as L\n\nbeer :: Int -> Builder\nbeer n = decimal n <> \" bottles of beer on the wall.\\n\"\n\nwall :: Builder\nwall = mconcat $ fmap beer [1..1000]\n\nmain :: IO ()\nmain = L.putStrLn $ toLazyText wall\n```\n\n### ByteString\n`ByteStrings`是未装箱的字符数组，具有`strict`(严格)或`lazy`(延迟)的求值.\n```haskell\npack :: String -> ByteString\nunpack :: ByteString -> String\n{-# LANGUAGE OverloadedStrings #-}\n\nimport qualified Data.ByteString as S\nimport qualified Data.ByteString.Char8 as S8\n\n-- From pack\nbstr1 :: S.ByteString\nbstr1 = S.pack (\"foo\" :: String)\n\n-- From overloaded string literal.\nbstr2 :: S.ByteString\nbstr2 = \"bar\"\n```\n請看:\n* [Bytestring: Bits and Pieces](https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/bytestring-bits-and-pieces)\n* [ByteString](http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString.html)\n\n### utf8-string\n> TODO\n\n請看:\n* [utf8-string](https://hackage.haskell.org/package/utf8-string)\n\n### base64-bytestring\n> TODO\n\n請看:\n* [utf8-string](https://hackage.haskell.org/package/base64-bytestring)\n\n### Printf\n`Haskell`还具有`C`风格的可变参数`printf`函数。\n```haskell\nimport Data.Text\nimport Text.Printf\n\na :: Int\na = 3\n\nb :: Double\nb = 3.14159\n\nc :: String\nc = \"haskell\"\n\nexample :: String\nexample = printf \"(%i, %f, %s)\" a b c\n-- \"(3, 3.14159, haskell)\"\n```\n\n### Overloaded Lists\n数据结构库公开`toList`和`fromList`函数以从列表中构造各种结构是普遍存在的。从`GHC 7.8`开始，我们现在可以使用类型类`IsList`重载`surface`(表面)语言中的`list`语法。\n```haskell\nclass IsList l where\n  type Item l\n  fromList  :: [Item l] -> l\n  fromListN :: Int -> [Item l] -> l\n  toList    :: l -> [Item l]\n\ninstance IsList [a] where\n  type Item [a] = a\n  fromList = id\n  toList   = id\nλ: :seti -XOverloadedLists\nλ: :type [1,2,3]\n[1,2,3] :: (Num (GHC.Exts.Item l), GHC.Exts.IsList l) => l\n{-# LANGUAGE OverloadedLists #-}\n{-# LANGUAGE TypeFamilies #-}\n\nimport qualified Data.Map as Map\nimport GHC.Exts (IsList(..))\n\ninstance (Ord k) => IsList (Map.Map k v) where\n  type Item (Map.Map k v) = (k,v)\n  fromList = Map.fromList\n  toList = Map.toList\n\nexample1 :: Map.Map String Int\nexample1 = [(\"a\", 1), (\"b\", 2)]\n```\n\n### String Conversions\n玩`type-tetris`来显式地在字符串之间转换可能会令人沮丧，幸运的是有几个包使用类型类自动转换，从而在任意两个常用字符串表示之间自动转换。然后我们可以编写泛型`comparison`(比较)和`concatenation`(连接)运算符，自动将操作数类型转换为类似的形式。\n```haskell\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Data.String.Conv\n\nimport qualified Data.Text as T\nimport qualified Data.Text.Lazy.IO as TL\n\nimport qualified Data.ByteString as B\nimport qualified Data.ByteString.Lazy as BL\n\nimport Data.Monoid\n\na :: String\na = \"Gödel\"\n\nb :: BL.ByteString\nb = \"Einstein\"\n\nc :: T.Text\nc = \"Feynmann\"\n\nd :: B.ByteString\nd = \"Schrödinger\"\n\n-- Compare unlike strings\n(==~) :: (Eq a, StringConv b a) => a -> b -> Bool\n(==~) a b = a == toS b\n\n-- Concat unlike strings\n(<>~) :: (Monoid a, StringConv b a) => a -> b -> a\n(<>~) a b = a <> toS b\n\nmain :: IO ()\nmain = do\n  putStrLn (toS a)\n  TL.putStrLn (toS b)\n  print (a ==~ b)\n  print (c ==~ d)\n  print (c ==~ c)\n  print (b <>~ c)\n```","tags":["Strings"]},{"title":"Haskell-Prelude","url":"/blog/2019/11/05/Haskell-Prelude/","content":"> [原文](http://dev.stephendiehl.com/hask/#prelude)\n\n### What to Avoid?\n`Haskell`是一门拥有25年历史的语言，它见证了我们构造和编写功能程序的方式的几次革命。 但是结果是，《Prelude》的许多部分仍然反映了旧思想流派，而这些思想流派只有在不破坏生态系统的重要部分的情况下才能被消除。\n\n目前，它实际上仅存在于民间传说中，哪些部分需要使用，哪些部分不使用，尽管几乎所有入门书籍都没有提到这个主题，而是为了简单起见广泛使用了`Prelude`。\n\n关于`Prelude`前奏的建议的简短版本是:\n\n* 避免`String`(字符串).\n* 使用`fmap`代替`map`.\n* 使用`Foldable`和`Traversable`替代`Control.Monad`和`Data.List`版本的`traversals`(遍歷).\n* 避免使用`head`和`read`之类的部分函數，或者使用其全部变体.\n* 避免異常，使用`ExceptT`或`Either`替代.\n* 避免布尔`blind`(盲)函数.\n\n列表类型的`Foldable`实例经常与`Prelude`中的`monomorphic`(单態)版本冲突，这是出于历史原因而保留的。因此，通常需要从隐式导入中显式屏蔽这些函數，并强制使用`Foldable`和`Traversable`。\n\n当然，通常情况下，人们只希望显式地使用`Prelude`，而人们可以显式地导入`Prelude`，并根据需要使用片段，而无需隐式导入整个名称空间。\n```haskell\nimport qualified Prelude as P\n```\n\n### What Should be in Base\n要完成工作，您可能需要.\n* async\n* bytestring\n* containers\n* mtl\n* stm\n* text\n* transformers\n* unordered-containers\n* vector\n* filepath\n* directory\n* process\n* unix\n* deepseq\n* optparse-applicative\n\n### Custom Preludes\n可以通过旋转`-XNoImplicitPrelude`标志来完全禁用默认的`Prelude`。\n```haskell\n{-# LANGUAGE NoImplicitPrelude #-}\n```\n然后，我们可以自由地构建等效的`Prelude`，这更符合我们的喜好。使用模块重新导出，我们可以提取`Prelude`的大部分内容和`safe`之类的库，以建立更加工业化的默认功能集。例如:\n```haskell\nmodule Custom (\n  module Exports,\n) where\n\nimport Data.Int as Exports\nimport Data.Tuple as Exports\nimport Data.Maybe as Exports\nimport Data.String as Exports\nimport Data.Foldable as Exports\nimport Data.Traversable as Exports\n\nimport Control.Monad.Trans.Except\n  as Exports\n  (ExceptT(ExceptT), Except, except, runExcept, runExceptT,\n   mapExcept, mapExceptT, withExcept, withExceptT)\n```\n`Prelude`本身也是完全可复制的，假设整个项目的编译没有隐含的前奏曲。已经出现了几个包，它们以一种更符合现代设计原则的方式提供了许多相同的功能。\n\n### Protolude\n`Protolude`是一个极简的`Prelude`，它为编写现代`Haskell`提供了许多合理的默认值，并且与现有代码兼容。\n\n* [Protolude](http://hackage.haskell.org/package/protolude)\n\n```haskell\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport Protolude\n```\n其他可供选择的`Prelude`示例包括(您的`mileage`(里程)可能因这些而异):\n\n* base-prelude\n* basic-prelude\n* classy-prelude\n* Other Preludes\n\n### Partial Functions(偏函數)\n偏函數是一个函数，它不会`terminate`(终止)并为所有给定的输入产生一个值。相反，`total`(全)函数终止，并始终为所有输入定义。如前所述，`Prelude`的某些历史部分充满了偏函數。\n\n部分函数和全部函数之间的区别在于编译器不能仅仅从语言中指定的信息来推断部分函数的运行时安全性，因此安全性的证明留给用户来保证。当用户可以保证无效输入不会发生时，它们可以安全地使用，但与任何未检查的属性一样，它的安全与否将取决于程序员的勤奋，这非常有悖于`Haskell`的整体哲学，因此，在没有必要的时候，不鼓励使用.\n```haskell\nhead :: [a] -> a\nread :: Read a => String -> a\n(!!) :: [a] -> Int -> a\n```\n\n### Safe\n在某些情况下，`Prelude`具有历史部分函數(例如`Text.Read.readMaybe`)的全部变体，但通常可以在各种实用程序库(如`safe`)中找到这些变体。\n\n提供的`total`版本分为以下三种情况:\n\n* **May** - 未为输入定义函数时，返回`Nothing`\n* **Def** - 未为输入定义函數时，提供默认值\n* **Note** - 当没有为输入定义函数时，使用自定义错误消息调用错误。这是不安全的，但稍微容易调试！\n\n```haskell\n-- Total\nheadMay :: [a] -> Maybe a\nreadMay :: Read a => String -> Maybe a\natMay :: [a] -> Int -> Maybe a\n\n-- Total\nheadDef :: a -> [a] -> a\nreadDef :: Read a => a -> String -> a\natDef   :: a -> [a] -> Int -> a\n\n-- Partial\nheadNote :: String -> [a] -> a\nreadNote :: Read a => String -> String -> a\natNote   :: String -> [a] -> Int -> a\n```\n\n### Boolean Blindness\n```haskell\ndata Bool = True | False\n\nisJust :: Maybe a -> Bool\nisJust (Just x) = True\nisJust Nothing  = False\n```\n布尔类型的问题在于，在类型级别上，`True`和`False`之间实际上没有区别。\n\n将值赋给`Bool`的命题将获取给定的任何信息并将其销毁。\n\n要对行为进行推理，我们必须追溯从中得到布尔答案的命题的出处，这为误解提供了很多可能性。 在最坏的情况下，推理函数安全和不安全使用的唯一方法是相信谓词的词法名称能够反映其出处！\n\n例如，在布尔值上测试一些表示分支是否可以在存在`null`的情况下安全地执行计算的命题会导致意外交换。\n\n考虑到在像`C`或`Python`这样的语言中，测试值是否为`null`与该语言测试值是否不为`null`是没有区别的。这些程序中的哪个程序编码安全使用，哪个段错误编码？\n\n```C\n# This one?\nif p(x):\n    # use x\nelif not p(x):\n    # don't use x\n\n# Or this one?\nif p(x):\n    # don't use x\nelif not p(x):\n    # use x\n```\n从检查中我们无法得知`p`是如何定义的，编译器也不能区分这两个，因此如果我们碰巧把它们弄混了，语言也救不了我们。\n\n与其使无效状态不可表示，不如使无效状态与有效状态不可区分！\n\n更可取的做法是，在`terms`(术语)上进行匹配，这些`terms`(术语)明确地将命题视为一种类型，否则不会进行类型检查。\n```haskell\ncase x of\n  Just a  -> use x\n  Nothing -> don't use x\n\n-- not ideal\ncase p x of\n  True  -> use x\n  False -> don't use x\n\n-- not ideal\nif p x\n  then use x\n  else don't use x\n```\n公平地说，许多流行的语言完全没有`sum`类型的概念（我认为很多麻烦的根源），而只有`product`类型，因此这种推理有时与不熟悉`ML`族语言的人没有直接的对等关系。\n\n在`Haskell`中，`Prelude`提供了诸如`isJust`和`fromJust`之类的函數，这两种函數均可用于颠覆这种推理，并易于引入错误，应经常避免使用。\n\n### Foldable / Traversable\n如果来自命令式的背景，再训练一个人从`maps`(映射)、`folds`(折叠)和`scans`(扫描)的角度来思考列表的迭代可能是具有挑战性的。\n```haskell\nPrelude.foldl :: (a -> b -> a) -> a -> [b] -> a\nPrelude.foldr :: (a -> b -> b) -> b -> [a] -> b\n\n-- pseudocode\nfoldr f z [a...] = f a (f b ( ... (f y z) ... ))\nfoldl f z [a...] = f ... (f (f z a) b) ... y\n```\n具体来说，考虑二进制运算符`(+)`上的简单算术序列:\n```haskell\n-- foldr (+) 1 [2..]\n(1 + (2 + (3 + (4 + ...))))\n-- foldl (+) 1 [2..]\n((((1 + 2) + 3) + 4) + ...)\n```\n`Foldable`和`Traversable`是任何数据结构的所有遍历和折叠的通用接口，这些数据结构通过其元素类型(`List`, `Map`, `Set`, `Maybe`...)进行参数化。这两个类在现代`Haskell`中随处可见，并且非常重要。\n\n一个`foldable`的实例允许我们将函数应用于`monoidal`值的数据类型，这些值使用`mappend`之上的某种逻辑折叠结构。\n\n`traversable`的实例允许我们将函数应用于数据类型，这些数据类型在`applicative`上下文中从左到右遍历结构。\n\n```haskell\nclass (Functor f, Foldable f) => Traversable f where\n  traverse :: Applicative g => (a -> g b) -> f a -> g (f b)\n\nclass Foldable f where\n  foldMap :: Monoid m => (a -> m) -> f a -> m\n```\n\n`foldMap`函数是非常通用的，并且非直观地，许多单态列表折叠本身可以根据此单个多态函数来编写。\n\n`foldMap`将值的函数带到一个`monoidal quantity`(幺半群)，在这些值上使用一个函子，并将该函子折叠成`monoid`。例如，对于琐碎的`Sum monoid`:\n```haskell\nλ: foldMap Sum [1..10]\nSum {getSum = 55}\n```\n例如，如果我们想基于模式匹配将一些抽象元素类型的列表映射到元素的哈希表中，则可以使用它。\n```haskell\nimport Data.Foldable\nimport qualified Data.Map as Map\n\ndata Elt\n  = Elt Int Double\n  | Nil\n\nfoo :: [Elt] -> Map.Map Int Double\nfoo = foldMap go\n  where\n    go (Elt x y) = Map.singleton x y\n    go Nil = Map.empty\n```\n完整的`Foldable`类(具有所有默认实现)包含各种派生函数，它们本身可以用`foldMap`和`Endo`编写.\n```haskell\nnewtype Endo a = Endo {appEndo :: a -> a}\n\ninstance Monoid (Endo a) where\n  mempty = Endo id\n  Endo f `mappend` Endo g = Endo (f . g)\nclass Foldable t where\n    fold    :: Monoid m => t m -> m\n    foldMap :: Monoid m => (a -> m) -> t a -> m\n\n    foldr   :: (a -> b -> b) -> b -> t a -> b\n    foldr'  :: (a -> b -> b) -> b -> t a -> b\n\n    foldl   :: (b -> a -> b) -> b -> t a -> b\n    foldl'  :: (b -> a -> b) -> b -> t a -> b\n\n    foldr1  :: (a -> a -> a) -> t a -> a\n    foldl1  :: (a -> a -> a) -> t a -> a\n```\n例如:\n```haskell\nfoldr :: (a -> b -> b) -> b -> t a -> b\nfoldr f z t = appEndo (foldMap (Endo . f) t) z\n```\n\n列表上的大多数操作可以用`Foldable`和`Traversable`的组合来概括，从而派生出更通用的函数，这些函数可以在实现`Foldable`的所有数据结构上工作.\n```haskell\nData.Foldable.elem    :: (Eq a, Foldable t) => a -> t a -> Bool\nData.Foldable.sum     :: (Num a, Foldable t) => t a -> a\nData.Foldable.minimum :: (Ord a, Foldable t) => t a -> a\nData.Traversable.mapM :: (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)\n```\n不幸的是，由于历史原因，`foldable`导出的名称经常与`Prelude`中定义的名称冲突，要么将其`qualified`导入，要么仅禁用`Prelude`。`Foldable`中的所有操作都专门针对相同的操作，并且行为与`Prelude for List`类型中的操作相同.\n\n```haskell\nimport Data.Monoid\nimport Data.Foldable\nimport Data.Traversable\n\nimport Control.Applicative\nimport Control.Monad.Identity (runIdentity)\nimport Prelude hiding (mapM_, foldr)\n\n-- Rose Tree\ndata Tree a = Node a [Tree a] deriving (Show)\n\ninstance Functor Tree where\n  fmap f (Node x ts) = Node (f x) (fmap (fmap f) ts)\n\ninstance Traversable Tree where\n  traverse f (Node x ts) = Node <$> f x <*> traverse (traverse f) ts\n\ninstance Foldable Tree where\n  foldMap f (Node x ts) = f x `mappend` foldMap (foldMap f) ts\n\n\ntree :: Tree Integer\ntree = Node 1 [Node 1 [], Node 2 [] ,Node 3 []]\n\n\nexample1 :: IO ()\nexample1 = mapM_ print tree\n\nexample2 :: Integer\nexample2 = foldr (+) 0 tree\n\nexample3 :: Maybe (Tree Integer)\nexample3 = traverse (\\x -> if x > 2 then Just x else Nothing) tree\n\nexample4 :: Tree Integer\nexample4 = runIdentity $ traverse (\\x -> pure (x+1)) tree\n```\n我们上面定义的实例也可以由`GHC`使用多种语言扩展自动导出。自动实例与上面的手写版本相同.\n```haskell\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE DeriveFoldable #-}\n{-# LANGUAGE DeriveTraversable #-}\n\ndata Tree a = Node a [Tree a]\n  deriving (Show, Functor, Foldable, Traversable)\n```\n\n請看:\n* [Typeclassopedia](http://wiki.haskell.org/Typeclassopedia)\n\n\n### Corecursion\n```haskell\nunfoldr :: (b -> Maybe (a, b)) -> b -> [a]\n```\n递归函数消耗数据并最终终止，`corecursive`函数生成数据并终止。\n\n如果一个`corecursive`函数总是能够在有限的时间内计算出更多的结果值，那么它就是`productive`(有效率)的。\n\n```haskell\nimport Data.List\n\nf :: Int -> Maybe (Int, Int)\nf 0 = Nothing\nf x = Just (x, x-1)\n\nrev :: [Int]\nrev = unfoldr f 10\n\nfibs :: [Int]\nfibs = unfoldr (\\(a,b) -> Just (a,(b,a+b))) (0,1)\n```\n\n### split包\n[split](http://hackage.haskell.org/package/split-0.1.1/docs/Data-List-Split.html)软件包为拆分列表和字符串类型提供了许多缺少的功能。\n```haskell\nimport Data.List.Split\n\nexample1 :: [String]\nexample1 = splitOn \".\" \"foo.bar.baz\"\n-- [\"foo\",\"bar\",\"baz\"]\n\nexample2 :: [String]\nexample2 = chunksOf 10 \"To be or not to be that is the question.\"\n-- [\"To be or n\",\"ot to be t\",\"hat is the\",\" question.\"]\n```\n\n### monad-loops包\n[monad-loops](http://hackage.haskell.org/package/monad-loops-0.4.2/docs/Control-Monad-Loops.html)程序包为`monadic`上下文中的控制逻辑提供了许多缺少的功能。\n```haskell\nwhileM :: Monad m => m Bool -> m a -> m [a]\nuntilM :: Monad m => m a -> m Bool -> m [a]\niterateUntilM :: Monad m => (a -> Bool) -> (a -> m a) -> a -> m a\nwhileJust :: Monad m => m (Maybe a) -> (a -> m b) -> m [b]\n```\n\n### Foundation包\n> TODO\n\n```haskell\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport Foundation\nimport Foundation.IO\nimport Foundation.String\nimport Foundation.VFS.FilePath\n\nimport Foundation.Collection\n\nexample :: String\nexample = \"Violence is the last refuge of the incompetent.\"\n\nbytes :: UArray Word8\nbytes = toBytes UTF8 example\n\nfile :: IO (UArray Word8)\nfile = readFile \"foundation.hs\"\n\nfileString :: IO (String, Maybe ValidationFailure, UArray Word8)\nfileString = fromBytes UTF8 <$> file\n\n\nxs :: NonEmpty [Int]\nxs = fromList [1,2,3]\n\nx :: Int\nx = head xs\n```\n\n#### Strings and Bytearrays\n\n#### Container Interface\n\n#### Numerical Tower\n\n請看:\n* [Foundation](https://github.com/haskell-foundation/foundation)","tags":["Prelude"]},{"title":"Haskell-Basics","url":"/blog/2019/11/05/Haskell-Basics/","content":"\n> [原文](http://dev.stephendiehl.com/hask/#basics)\n\n### Cabal\n> 历史上，Cabal有一个称为Cabal install的组件，它在很大程度上被Stack所取代。由于历史原因，下面使用的是Cabal沙箱，通常可以用现代工具代替。\n\n[Cabal](https://www.haskell.org/cabal/)是`Haskell`的构建系统。\n\n例如，要从`Hackage`(`Haskell`包的上游源)将`parsec`包安装到系统中，请调用`install`命令:\n```haskell\n$ cabal install parsec           # latest version\n$ cabal install parsec==3.1.5    # exact version\n```\n\n`Haskell`软件包的常规构建调用如下:\n```haskell\n$ cabal get parsec    # fetch source\n$ cd parsec-3.1.5\n\n$ cabal configure\n$ cabal build\n$ cabal install\n```\n要从`Hackage`更新软件包索引，请运行:\n\n```haskell\n$ cabal update\n```\n要启动一个新的`Haskell`项目，请运行:\n```haskell\n$ cabal init\n$ cabal configure\n```\n\n将使用新项目的配置选项创建一个`.cabal`文件。\n\n`cabal`的最新功能是增加了`Sandboxes`(沙箱)(在`cabal`>1.18中)，它们是`Haskell`软件包的独立环境，与存储在我们项目根目录`./.cabal-sandbox`中的全局软件包索引分开。要为我们的`cabal`项目创建一个新的沙箱，请运行:\n```haskell\n$ cabal sandbox init\n```\n此外，可以将沙箱拆除:\n```haskell\n$ cabal sandbox delete\n```\n\n当在具有已设置配置的沙箱的项目的工作目录中时，调用`cabal`命令会更改`cabal`本身的行为。 例如，`cabal install`命令只将安装更改为本地包索引, 而不更改全局配置。\n\n要将`.cabal`文件中的依赖项安装到新创建的沙盒中，请运行:\n```haskell\n$ cabal install --only-dependencies\n```\n也可以通过传递`-j<n>`来并行构建依赖关系，其中`n`是并发构建的数量。\n```haskell\n$ cabal install -j4 --only-dependencies\n```\n\n让我们看一个示例`.cabal`文件。任何软件包都可以提供两个主要入口点：一个`library`(库)和一个`executable`(可执行文件)。\n可以定义多个可执行文件，但只能定义一个`library`(库)。另外，还有一种特殊形式的可执行入口`Test-Suite`，它定义了一个接口，用于从`cabal`调用单元测试。\n\n对于`library`，`.cabal`文件中的`exposed-modules`字段指示在安装软件包时，该软件包结构中的哪些模块将公开可见。这些模块是我们希望向下游使用者公开的面向用户的`API`。\n\n对于`executable`，`main-is`字段表示导出运行应用程序可执行逻辑的`main`函數的模块。包中的每个模块都必须在`ther-modules`，`exposed-modules`或`main-is`字段之一中列出。\n\n```haskell\nname:               mylibrary\nversion:            0.1\ncabal-version:      >= 1.10\nauthor:             Paul Atreides\nlicense:            MIT\nlicense-file:       LICENSE\nsynopsis:           The code must flow.\ncategory:           Math\ntested-with:        GHC\nbuild-type:         Simple\n\nlibrary\n    exposed-modules:\n      Library.ExampleModule1\n      Library.ExampleModule2\n\n    build-depends:\n      base >= 4 && < 5\n\n    default-language: Haskell2010\n\n    ghc-options: -O2 -Wall -fwarn-tabs\n\nexecutable \"example\"\n    build-depends:\n        base >= 4 && < 5,\n        mylibrary == 0.1\n    default-language: Haskell2010\n    main-is: Main.hs\n\nTest-Suite test\n  type: exitcode-stdio-1.0\n  main-is: Test.hs\n  default-language: Haskell2010\n  build-depends:\n      base >= 4 && < 5,\n      mylibrary == 0.1\n```\n为`cabal sandbox`下的项目运行`executable`:\n```haskell\n$ cabal run\n$ cabal run <name> # 当项目中有多个可执行文件时\n```\n\n要将`library`加载到`cabal sandbox`下的[GHCi shell](http://dev.stephendiehl.com/hask/#ghci)中:\n```haskell\n$ cabal repl\n$ cabal repl <name>\n```\n元变量`<name>`是`.cabal`文件中的可执行文件或库声明之一，可以分别由前缀`exe：<name>`或`lib：<name>`消除歧义。\n\n要在本地将包构建到`./dist/build`文件夹中，请执行`build`命令:\n```haskell\n$ cabal build\n```\n要运行测试，我们的软件包本身必须使用`--enable-tests`和`build-depends`选项进行重新配置。如果尚未安装，则必须手动安装`Test-Suite`。\n```haskell\n$ cabal install --only-dependencies --enable-tests\n$ cabal configure --enable-tests\n$ cabal test\n$ cabal test <name>\n```\n\n此外，可以使用为`sandbox`设置的`GHC`环境变量来调用任意的`shell`命令。很常见的是使用此命令调用新的`shell`，以便`ghc`和`ghci`命令使用`sandbox`。(默认情况下，它们不是默认值，这是造成失败的常见原因。)\n```haskell\n$ cabal exec\n$ cabal exec sh # 使用GHC沙箱路径集启动shell\n```\n\n`haddock`文档可以通过执行`haddock`命令为本地项目生成。该文档将建立在`./dist`文件夹中.\n```haskell\n$ cabal haddock\n```\n\n当我们终于准备好上传到`Hackage`时（假设我们已经设置了`Hackage`帐户），那么我们可以构建`tarball`并使用以下命令上传:\n\n```haskell\n$ cabal sdist\n$ cabal upload dist/mylibrary-0.1.tar.gz\n```\n有时，您还想将本地项目中的库添加到沙箱中。在这种情况下，请运行`add-source`命令将库从本地目录引入沙箱:\n```haskell\n$ cabal sandbox add-source /path/to/project\n```\n\n沙箱的当前状态可以在枚举所有当前程序包约束的情况下`frozen`(冻结):\n```haskell\n$ cabal freeze\n```\n这将创建带有约束集的文件`cabal.config`.\n```haskell\nconstraints: mtl ==2.2.1,\n             text ==1.1.1.3,\n             transformers ==0.4.1.0\n```\n最好使用`cabal repl`和`cabal run`命令，但有时我们想在`shell`上手动执行它们的等效操作。\n几个有用的别名依靠`shell`目录扩展来在当前工作目录中找到程序包数据库，并使用适当的标志启动`GHC`:\n```haskell\nalias ghc-sandbox=\"ghc -no-user-package-db -package-db .cabal-sandbox/*-packages.conf.d\"\nalias ghci-sandbox=\"ghci -no-user-package-db -package-db .cabal-sandbox/*-packages.conf.d\"\nalias runhaskell-sandbox=\"runhaskell -no-user-package-db -package-db .cabal-sandbox/*-packages.conf.d\"\n```\n还有一个`zsh`脚本，用于在我们的`Shell`中显示当前工作目录的沙箱状态:\n```shell\nfunction cabal_sandbox_info() {\n    cabal_files=(*.cabal(N))\n    if [ $#cabal_files -gt 0 ]; then\n        if [ -f cabal.sandbox.config ]; then\n            echo \"%{$fg[green]%}sandboxed%{$reset_color%}\"\n        else\n            echo \"%{$fg[red]%}not sandboxed%{$reset_color%}\"\n        fi\n    fi\n}\n\nRPROMPT=\"\\$(cabal_sandbox_info) $RPROMPT\"\n```\n`cabal`配置存储在`$HOME/.cabal/config`中，包含各种选项，包括用于`Hackage`上傳的凭据信息。\n配置的另一个附加功能是完全禁止在沙盒外安装包，以防止意外冲突。\n```haskell\n-- Don't allow global install of packages.\nrequire-sandbox: True\n```\n也可以在启用运行时分析信息的情况下编译`library`(库)。关于[并发](http://dev.stephendiehl.com/hask/#concurrency)和[概要分析](http://dev.stephendiehl.com/hask/#profiling)的部分将对此进行更多讨论.\n```haskell\nlibrary-profiling: True\n```\n\n启用的另一个常见标志是`documentation`，它强制在本地构建`Haddock`文档，这对于`offline reference`(離線引用)很有用。\n\n在`Linux`文件系统上，这些文件构建在`/usr/share/doc/ghc-doc/html/libraries/`目录中.\n```haskell\ndocumentation: True\n```\n如果当前已安装`GHC`，则可以在此本地链接上找到`Prelude`和`Base`库的文档:\n[/usr/share/doc/ghc-doc/html/libraries/index.html](file:///usr/share/doc/ghc-doc/html/libraries/index.html)\n\n請看:\n* [An Introduction to Cabal Sandboxes](http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html)(`Cabal`沙箱简介)\n* [Storage and Identification of Cabalized Packages](http://www.vex.net/~trebla/haskell/sicp.xhtml)(`Cabal`包的存储和标识)\n\n\n### Stack\n\n[Stack](http://docs.haskellstack.org/en/stable/README/)是2015年出现的`Haskell`包结构的一种新方法。`stack`没有使用类似于`cabal install`的滚动构建，而是将一组软件包分解成保证软件包之间内部兼容性的`release`(发布/版本)块。\n与`cabal-install`过去使用的软件包相比，`stack`的软件包`solver`(求解器)使用了一种不同的，更强大的策略来解决依赖关系。\n\n#### Install\n要在`Ubuntu Linux`上安装`stack`，请运行:\n```shell\n# get fp complete key\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 575159689BEFB442\n# add appropriate source repo\necho 'deb http://download.fpcomplete.com/ubuntu trusty main'|sudo tee /etc/apt/sources.list.d/fpco.list\nsudo apt-get update && sudo apt-get install stack -y\n```\n对于其他操作系统，请参阅[官方安装说明](http://docs.haskellstack.org/en/stable/install_and_upgrade/)。\n\n#### Usage\n一旦安装了`Stack`，就可以通过运行以下命令在现有项目的`cabal`文件之上设置构建环境:\n```haskell\nstack init\n```\n`GHC 7.10.3`的示例`stack.yaml`文件如下所示:\n```haskell\nresolver: lts-7.12\nflags: {}\nextra-package-dbs: []\npackages: []\nextra-deps: []\n```\n日常开发中使用的大多数常见库已经在[Stackage](https://www.stackage.org/)存储库中。`extra-deps`字段可用于添加不在`Stackage`存储库中的[Hackage](http://hackage.haskell.org/)依赖项。它们由`package`(软件包)和`version key`(版本密钥)指定。\n例如，可以将`zenc`软件包添加到堆栈构建中:\n```haskell\nextra-deps:\n- zenc-0.1.1\n```\n`stack`命令可用于将`packages`(软件包)和`executables`(可执行文件)安装到当前构建环境或全局环境中。例如，以下命令为`Haskell`流行的`linting`工具[hlint](https://github.com/ndmitchell/hlint)安装`executable`(可执行文件)，并将其放置在`PATH`中:\n```shell\n$ stack install hlint\n```\n要检查依赖项集，请运行:\n```shell\n$ stack list-dependencies\n```\n就像`cabal`一样，可以使用`stack`命令来`orchestrated`(编排)`build`(构建)和`debug`(调试)过程:\n```shell\n$ stack build                 # Build a cabal target\n$ stack repl                  # 啟動ghci\n$ stack ghc                   # 在堆栈环境中调用独立编译器\n$ stack exec bash             # 使用堆栈GHC环境变量执行Shell命令\n$ stack build --file-watch    # 在每次文件系统更改的基础上构建\n```\n要可视化依赖关系图，请先使用`dot`命令将其通过管道传送到`graphviz`，然后再通过管道将其传送到您喜欢的图像查看器中:\n```shell\n$ stack dot --external | dot -Tpng | feh -\n```\n\n### Flags\n启用`GHC`[编译器标志]([https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flag-reference.html)可以使用户在检测常见代码错误时拥有更多控制权。最常用的标志是:\n```shell\nFlag\t                            Description\n--------------------------------------------------\n-fwarn-tabs\t                        在源代码中发出制表符而不是空格的警告\n\n-fwarn-unused-imports\t            警告已导入卻未使用的库\n\n-fwarn-name-shadowing\t            警告嵌套绑定中的重复名称\n\n-fwarn-incomplete-uni-patterns\t    对lambda或模式绑定中的不完整模式发出警告\n\n-fwarn-incomplete-patterns\t        对非穷举(non-exhaustive)模式发出警告\n\n-fwarn-overlapping-patterns\t        对重叠的模式匹配分支发出警告\n\n-fwarn-incomplete-record-updates    当未使用所有字段实例化Record时发出警告\n\n-fdefer-type-errors\t                将类型错误转化为警告\n\n-fwarn-missing-signatures\t        對top-level缺少类型签名发出警告\n\n-fwarn-monomorphism-restriction\t    当隐式应用单态限定时发出警告\n\n-fwarn-orphans\t                    孤立(orphan)类型类实例警告\n\n-fforce-recomp\t                    强制重新编译，而不考虑时间戳\n\n-fno-code\t                        省略代码生成，只解析和类型检查\n\n-fobject-code\t                    生成目标(object)代码\n```\n\n像大多数编译器一样，`GHC`带有`-Wall`标志来启用所有警告。但是，一些启用的警告非常详细。\n例如，`-fwarn-unused-do-bind`和`-fwarn-unused-matches`通常不会对应于错误或失败。\n这些标志中的任何一个都可以添加到项目`.cabal`文件的`ghc-options`部分中。例如:\n```haskell\nlibrary mylib\n\n  ghc-options:\n    -fwarn-tabs\n    -fwarn-unused-imports\n    -fwarn-missing-signatures\n    -fwarn-name-shadowing\n    -fwarn-incomplete-patterns\n```\n上面描述的标志只是最有用的。有关`GHC`支持的标志的完整集合，请参见[官方参考](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flag-reference.html)。\n\n有关调试GHC内部组件的信息，请参见有关`GHC`内部组件的[注释/評論](http://dev.stephendiehl.com/hask/#block-diagram)。\n\n\n### Hackage\n`Hackage`是免费(和/或)开源`Haskell`包的上游源代码。\n\n随着`Haskell`的不断发展，`Hackage`对开发人员来说已经成为很多`things`(事情)，但是对于上传的库来说，似乎有两种主要的哲学。\n\n#### Reusable Code / Building Blocks(可重复使用的代码/构建块)\n在第一种哲学中，`libraries`作为可靠的，由社区支持的`building blocks`(构建模块)存在，用于在通用的稳定建筑物之上构建更高级别的功能。\n\n在以这种方法为主导理念的开发社区中，`libraries`的作者将其编写为一种打包他们对问题领域的理解的方法，以便其他人可以在其理解和专业知识的基础上进行构建。\n\n#### A Staging Area / Request for Comments(暂存区/征求意见)\n与上一個的打包方法相比，`Haskell`社区的一个普遍哲学是`Hackage`是一个上传实验库的地方，以此作为获取社区反馈和使代码公开可用的一种方式。 `Library`作者通常通过简单地指出他们打算拆除代码并在以后重新编写代码，来合理化地将这些类型的图书馆设置为无文档状态，而通常不指明图书馆的实际功能。 不幸的是，这种方法意味着许多`Hackage`命名空间已被`dead-end`(死胡同)，`bit-rotting code`(位腐烂)的代码所污染。有时，软件包也纯粹是上傳的，供组织内部使用，与论文一起使用，或仅与`cabal`构建系统集成。这些软件包通常也没有文档记录。\n\n对于从其他语言生态系统(如`Python`、`JavaScript`、`Ruby`)来到`Haskell`的开发人员来说，看到成千上万的库而没有任何文档或目的描述可能会令人不安。鉴于这些哲学上的差异，目前的黑客文化状态是否可持续，这是一个悬而未决的问题。\n不用说，现在有很多非常低质量的`Haskell`代码和文档，所以在`library`评估中保持保守是一项必要的技能。也就是说，在`Hackage`上也有很多非凡的`library`，它们被很多人精心策划。\n\n通常，如果该库的`Haddock`文档没有一个简单的示例，通常可以安全地假定它是`RFC`样式的库，并且应该在生产级代码中避免使用。\n\n同样，如果该库早于[text](http://hackage.haskell.org/package/text)库（于2007年发布），则应在生产代码中避免使用它。 自早期以来，我们编写`Haskell`的方式已经发生了巨大变化。\n\n### GHCi\n[GHCi](https://wiki.haskell.org/GHC/GHCi)是`GHC`编译器的交互式`shell`。\n`GHCi`是我们将大部分时间用于日常开发的地方。\n```shell\nCommand\tShortcut\tAction\n-----------------------------\n:reload\t:r\t        代码重新加载\n:type\t:t\t        类型检查\n:kind\t:k\t        Kind检查\n:info\t:i\t        信息\n:print\t:p\t        打印表达式\n:edit\t:e\t        在系统编辑器中加载文件\n:load\t:l\t        在REPL中设置活动的Main模块\n:add\t:ad\t        将文件加载到REPL名称空间\n:browse\t:bro\t    浏览REPL名称空间中的所有可用符号\n```\n`introspection`(自省)命令是调试和与`Haskell`代码进行交互的重要部分:\n```haskell\nλ: :type 3\n3 :: Num a => a\nλ: :kind Either\nEither :: * -> * -> *\nλ: :info Functor\nclass Functor f where\n  fmap :: (a -> b) -> f a -> f b\n  (<$) :: a -> f b -> f a\n        -- Defined in `GHC.Base'\n  ...\nλ: :i (:)\ndata [] a = ... | a : [a]       -- Defined in `GHC.Types'\ninfixr 5 :\n```\n在`shell`中查询全局环境的当前状态也是可能的。例如，要查看`GHCi`中的模块级绑定和类型，请运行:\n```haskell\nλ: :browse\nλ: :show bindings\n```\n检查模块级别的导入，执行:\n```haskell\nλ: :show imports\nimport Prelude -- implicit\nimport Data.Eq\nimport Control.Monad\n```\n要查看编译器级别的标志和编译指示，请使用:\n```haskell\nλ: :set\noptions currently set: none.\nbase language is: Haskell2010\nwith the following modifiers:\n  -XNoDatatypeContexts\n  -XNondecreasingIndentation\nGHCi-specific dynamic flag settings:\nother dynamic, non-language, flag settings:\n  -fimplicit-import-qualified\nwarning settings:\n\nλ: :showi language\nbase language is: Haskell2010\nwith the following modifiers:\n  -XNoDatatypeContexts\n  -XNondecreasingIndentation\n  -XExtendedDefaultRules\n```\n可以在提示符下设置语言扩展名和编译器编译指示。有关大量编译器标志选项的信息，请参见[标志参考](http://dev.stephendiehl.com/hask/#flags)。\n\n交互式`shell`的一些命令具有快捷方式:\n```haskell\n    Function\n+t\t显示评估表达式的类型\n+s\t显示计时和内存使用情况\n+m\t启用以:{和:}分隔的多行表达式。\n\n\nλ: :set +t\nλ: []\n[]\nit :: [a]\n\nλ: :set +s\nλ: foldr (+) 0 [1..25]\n325\nit :: Prelude.Integer\n(0.02 secs, 4900952 bytes)\n\nλ: :{\nλ:| let foo = do\nλ:|           putStrLn \"hello ghci\"\nλ:| :}\nλ: foo\n\"hello ghci\"\n```\n通过在`$HOME/.ghc/`中定义`ghci.conf`，或在当前工作目录中为`./.ghci.conf`，可以全局定制`GHCi shell`的配置。\n\n例如，我们可以添加一条命令，以从`GHCi`中使用`Hoogle`类型搜索。首先，安装`hoogle`:\n```haskell\ncabal install hoogle\n```\n然后，我们可以通过向`ghci.conf`中添加命令来启用搜索功能:\n```haskell\n:set prompt \"λ: \"\n\n:def hlint const . return $ \":! hlint \\\"src\\\"\"\n:def hoogle \\s -> return $ \":! hoogle --count=15 \\\"\" ++ s ++ \"\\\"\"\nλ: :hoogle (a -> b) -> f a -> f b\nData.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b\nPrelude fmap :: Functor f => (a -> b) -> f a -> f b\n```\n出于性感的原因，希望将`GHC`提示设置为一个`λ`或一个`λΠ`。不过，前提是你喜欢那种生活方式。\n```haskell\n:set prompt \"λ: \"\n:set prompt \"ΠΣ: \"\n```\n\n#### GHCi Performance(性能)\n对于大型项目，带有默认标志的`GHCi`可以使用相当多的内存，并且需要很长时间来编译。为了通过保留编译模块的工件来加速编译，我们可以启用目标代码编译而不是字节码。\n```haskell\n:set -fobject-code\n```\n启用目标代码编译可能会使类型推断复杂化，因为提供给外壳的类型信息有时可能比源代码加载的代码少。这种特殊性可能会导致某些语言扩展的损坏。在这种情况下，您可以使用`-fbyte-code`标志在每个模块的基础上临时重新启用字节码编译。\n```haskell\n:set -fbyte-code\n:load MyModule.hs\n```\n如果您只需要在交互式外壳中对代码进行类型检查，则完全禁用代码生成将使重新加载代码几乎是瞬间的:\n```haskell\n:set -fno-code\n```\n\n### Editor Integration\n`Haskell`有多种编辑器工具，可用于提供交互式开发反馈和功能，如查询子表达式的类型、`linting`、类型检查和代码完成。\n\n存在几个预先打包的设置，以加快设置`Haskell`开发的许多程序员编辑器的过程。特别是，使用[ghc mod](http://www.mew.org/~kazu/proj/ghc-mod/en/)可以显著提高程序员的效率和生产力，因为该项目试图实现现代`ide`的通用特性。\n\n\n#### Vim\n* [haskell-vim-now](https://github.com/begriffs/haskell-vim-now)\n* [Vim and Haskell in 2016](http://www.stephendiehl.com/posts/vim_2016.html)\n\n#### Emacs\n* [Chris Done's Emacs Config](https://github.com/chrisdone/chrisdone-emacs)\n* [Haskell Development From Emacs](http://tim.dysinger.net/posts/2014-02-18-haskell-with-emacs.html)\n* [Structured Haskell Mode](https://github.com/chrisdone/structured-haskell-mode)\n\n#### Atom\n* [language-haskell plugin](https://atom.io/packages/language-haskell)\n* [ide-haskell plugin](https://atom.io/packages/ide-haskell)\n\n### Bottoms\n`Bottoms`是每个类型都存在的奇特值。评估此值时，`Haskell`的语义不再产生有意义的值。换句话说，无法在`Haskell`中定义对该值的进一步操作。`bottom`值通常写为符号[⊥](https://en.wikipedia.org/wiki/Up_tack)(即`the compiler flipping you off`)。 存在几种表示`Haskell`代码`bottoms`的方法。\n例如，`undefined`是一个`bottom`值的简单例子。该函数具有类型`a`，但其类型签名中没有任何类型约束。因此，`undefined`可以代表函数体中的任何类型，即使函数不完整或完全缺少定义，也可以使类型检查成功。`undefined`功能对于调试或容纳编写不完整的程序非常实用。\n```haskell\nundefined :: a\n\n\nmean :: Num a => Vector a -> a\nmean nums = (total / count) where  -- 部分定义的功能\n              total = undefined\n              count = undefined\n\naddThreeNums :: Num a => a -> a -> a -> a\naddThreeNums n m j = undefined    -- 根本没有声明函数体\n\nf :: a -> Complicated Type\nf = undefined   -- 明天写，今天类型检查！欢迎任意复杂的类型！\n```\n`bottom`值的另一个示例来自对`error`函数的求值，该函数接受`String`并返回可以是任何类型的东西。这个属性非常类似于`undefined`，它也可以代表任何类型。\n\n在函数中调用`error`会导致编译器引发异常，停止程序并打印指定的错误消息。\n在下面的`divByY`函数中，将`0`用作除数会导致此函数导致此类异常。\n```haskell\n-- 接收String类型的错误消息并返回所需的任何类型\nerror :: String -> a\n\n-- 带注释的代码，具有使用`error`函数的函數。\n\ndivByY:: (Num a, Eq a, Fractional a) => a -> a -> a\ndivByY _ 0 = error \"Divide by zero error\"      -- Dividing by 0 causes an error\ndivByY dividend divisor = dividend / divisor   -- Handles defined division\n```\n\n表示`bottom`的第三种方式是使用无限循环项:\n```haskell\nf :: a\nf = let x = x in x\n```\n使用此循环语法的实际`Haskell`代码示例包含在[GHC.Prim](https://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/GHC-Prim.html)模块的源代码中。\n\n存在这些`bottom`是因为无法在[native Haskell](https://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/primitives.html)中定义操作。这些操作以非常低的级别被`baked`(烘焙)到编译器中。\n\n但是，存在此模块是为了使[Haddock](http://dev.stephendiehl.com/hask/#haddock)可以为这些`primitive`(原始)操作生成文档，而循环语法充当`primops`实际实现的占位符。\n\n`bottom`最常见的介绍可能是编写未定义[详尽](http://dev.stephendiehl.com/hask/#exhaustiveness)模式匹配的部分函数。例如，以下代码具有非穷尽的模式匹配，因为`case`表达式缺少对`B`的处理方式的定义：\n```haskell\ndata F = A | B\ncase x of\n  A -> ()\n```\n上面的代码段被转换为以下[GHC Core](http://dev.stephendiehl.com/hask/#code)输出。编译器插入异常以说明`non-exhaustive`(非穷举)模式:\n```haskell\ncase x of _ {\n  A -> ();\n  B -> patError \"<interactive>:3:11-31|case\"\n}\n```\n使用`-fwarn-incomplete-patterns`和`-fwarn-incomplete-uni-patterns`标志可以使`GHC`对不完整的模式更加清晰。\n\n`Record`也会出现类似情况。尽管构建缺少字段的`Record`很少有用，但仍然可以实现。\n```haskell\ndata Foo = Foo { example1 :: Int }\nf = Foo {}  -- 定义缺少字段的Record\n```\n当开发人员忽略字段的定义时，编译器将在`GHC Core`表示中插入一个异常:\n```haskell\nFoo (recConError \"<interactive>:4:9-12|a\")\n```\n幸运的是，`GHC`默认会警告我们有关缺少`Record`字段的信息。\n\n`bottom`在整个[Prelude](http://dev.stephendiehl.com/hask/#prelude)中被广泛使用，尽管这一事实可能不会立即显现出来。包括`bottom`在内的原因是实践性的或历史性的。\n\n典型的例子是`head`函数，它的类型是`[a] -> a`。如果没有`bottom`，这个函数的类型就是不好的。\n```haskell\nimport GHC.Err\nimport Prelude hiding (head, (!!), undefined)\n\n-- degenerate(退化) functions\n\nundefined :: a\nundefined = error \"Prelude.undefined\"\n\nhead :: [a] -> a\nhead (x:_) =  x\nhead []    =  error \"Prelude.head: empty list\"\n\n(!!) :: [a] -> Int -> a\nxs     !! n | n < 0 =  error \"Prelude.!!: negative index\"\n[]     !! _         =  error \"Prelude.!!: index too large\"\n(x:_)  !! 0         =  x\n(_:xs) !! n         =  xs !! (n-1)\n```\n在生产代码中很少看到这些不小心抛出的部分函数，因为它们会导致程序停止。处理异常的首选方法是结合使用`Data.Maybe`中提供的安全变体和常用的折叠函数`maybe`和`any`.\n另一种方法是使用模式匹配，如`listToMaybe`中所示，这是`head`的更安全版本，如下所述:\n```haskell\nlistToMaybe :: [a] -> Maybe a\nlistToMaybe []     =  Nothing\nlistToMaybe (a:_)  =  Just a\n```\n调用根据`error`定义的`bottom`通常不会生成任何位置信息。\n但是，用于提供断言的`assert`可以被短路以生成位置信息，以代替`undefined`或`error`调用。\n```haskell\nimport GHC.Base\n\nfoo :: a\nfoo = undefined\n-- *** Exception: Prelude.undefined\n\nbar :: a\nbar = assert False undefined\n-- *** Exception: src/fail.hs:8:7-12: Assertion failed\n```\n請看:\n* [Avoiding Partial Functions](https://wiki.haskell.org/Avoiding_partial_functions)\n\n\n### Exhaustiveness(穷举)\n`Haskell`中的模式匹配允许使用`non-exhaustive`(非穷尽)模式。\n例如，将`Nothing`传递给`unsafe`将导致程序在运行时崩溃。但是，此函數是其他有效的类型检查程序。\n```haskell\nunsafe :: Num a => Maybe a -> Maybe a\nunsafe (Just x) = Just $ x + 1\n```\n由于`unsafe`以`Maybe a`值作为参数，因此有两个可能的值是有效输入: `Nothing`和`Just a`.\n由于`unsafe`中没有定义`Nothing`的情况，我们认为该函数中的模式匹配是非穷尽的。换句话说，函数没有实现对所有有效输入的适当处理。这样的函数将停止不完全匹配，而不是产生值。\n\n非穷举的部分函数是一个有争议的话题，频繁使用非穷举模式被认为是一种危险的代码气味。\n然而，从语言中完全删除非穷尽模式本身就过于严格，并且禁止太多有效的程序。\n\n存在几个标志，我们可以传递给编译器以向我们警告此类模式，或者在本地或全局范围内完全禁止它们。\n\n```haskell\n$ ghc -c -Wall -Werror A.hs\nA.hs:3:1:\n    Warning: Pattern match(es) are non-exhaustive\n             In an equation for `unsafe': Patterns not matched: Nothing\n```\n`-Wall`或`-fwarn-incomplete-patterns`标志也可以通过使用`OPTIONS_GHC`[编译指示](https://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/pragmas.html)按模块添加。\n\n```haskell\n{-# OPTIONS_GHC -Wall #-}\n{-# OPTIONS_GHC -fwarn-incomplete-patterns #-}\n```\n一个更微妙的`non-exhaustivity`例子是使用隐式模式匹配`lambda`表达式中的单个`uni pattern`。\n与上面的`unsafe`函数类似，`uni pattern`无法处理所有类型的有效输入。例如，即使`lambda`表达式的参数类型是`Maybe a`，但当给定`Nothing`时，`boom`函数将失败。\n```haskell\nboom = \\(Just a) -> something\n```\n`lambda`表达式中的`uni patterns`引起的`non-exhaustivity`(非穷尽)性经常出现在脫糖后的`let`或`do blocks`中，因为这类代码被转换成类似于`boom`的`lambda`表达式。\n```haskell\nboom2 = let\n  Just a = something\n\nboom3 = do\n  Just a <- something\n```\n`GHC`可以使用`-fwarn-incomplete-uni-patterns`标志来警告这些`non-exhaustivity`(非穷举)性情况。\n\n概括地说，任何非平凡的程序都会使用某种程度的部分函数。这只是事实。 因此，对于程序员而言，存在着比在`Haskell`类型系统中无法体现的义务。\n\n\n### Debugger\n从[GHCi](http://dev.stephendiehl.com/hask/#ghci)版本6.8.1开始，内置[调试器](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-debugger.html)已经可用，尽管很少使用。从底部调试未捕获的异常或异步异常的方式类似于使用`gdb`调试`segfault`。\n```haskell\nλ: :set -fbreak-on-exception  -- 设置评估选项以在异常情况下停止\nλ: :break 2 15                -- 在第2行第15列设置一个断点\nλ: :trace main                -- 运行一个函数以生成一系列评估步骤\nλ: :hist                      -- 从断点處后退到先前的评估步骤\nλ: :back                      -- 根據历史记录一步步後退\nλ: :forward                   -- 根據历史记录一步步向前\n```\n\n### Stack Traces(堆栈跟踪)\n启用[运行时分析](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html)后，`GHC`还可以在`hit`(遇到/命中)`diverging`发散`bottom term`(底部项)(`error`，`undefined`)时打印堆栈跟踪,不过，此操作需要启用一个特殊标志和`profiling`(配置)，这两个功能在默认情况下都是禁用的。例如：\n```haskell\nimport Control.Exception\n\nf x = g x\n\ng x = error (show x)\n\nmain = try (evaluate (f ())) :: IO (Either SomeException ())\n$ ghc -O0 -rtsopts=all -prof -auto-all --make stacktrace.hs\n./stacktrace +RTS -xc\n```\n实际上，运行时告诉我们该异常发生在函数`g`中，并枚举了调用堆栈。\n```haskell\n*** Exception (reporting due to +RTS -xc): (THUNK_2_0), stack trace:\n  Main.g,\n  called from Main.f,\n  called from Main.main,\n  called from Main.CAF\n  --> evaluated by: Main.main,\n  called from Main.CAF\n```\n最好在不应用`-O0`优化的情况下运行此代码，以保留源代码中表示的原始调用堆栈。通过应用优化，`GHC`将以非常激烈的方式重新安排程序，从而导致完全不同的调用堆栈。\n請看:\n* [xc flag](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime-control.html#idp13041968)\n\n\n### Trace\n由于`Haskell`是一种[纯语言](http://dev.stephendiehl.com/fun/000_introduction.html#functional-languages)，所以它有一个独特的特性，即大多数代码都可以自己进行内省。\n因此，在整个执行过程中，使用[printf](https://www.codingunit.com/printf-format-specifiers-format-conversions-and-formatted-output)来显示程序在关键时刻的状态通常是不必要的，因为我们可以简单地打开[GHCi](http://dev.stephendiehl.com/hask/#ghci)并测试函数。\n不过，`Haskell`确实附带了一个不安全的跟踪函数，可以用来在`IO monad`之外执行任意打印语句。\n```haskell\nimport Debug.Trace\n\n-- trace :: String -> a -> a\n\n-- traceShow :: Show a => a -> b -> b\n\n\nexample1 :: Int\nexample1 = trace \"impure print\" 1\n\nexample2 :: Int\nexample2 = traceShow \"tracing\" 2\n\nexample3 :: [Int]\nexample3 = [trace \"will not be called\" 3]\n\nmain :: IO ()\nmain = do\n  print example1\n  print example2\n  print $ length example3\n-- impure print\n-- 1\n-- \"tracing\"\n-- 2\n-- 1\n```\n\n>Trace在后台使用unsafePerformIO，因此不应在稳定的代码中使用。\n\n除了`trace`函數外，还有几种单子`trace`变量也很常见:\n```haskell\nimport Text.Printf\nimport Debug.Trace\n\ntraceM :: (Monad m) => String -> m ()\ntraceM string = trace string $ return ()\n\ntraceShowM :: (Show a, Monad m) => a -> m ()\ntraceShowM = traceM . show\n\n-- printf :: PrintfType r => String -> r\n\ntracePrintfM :: (Monad m, PrintfArg a) => String -> a -> m ()\ntracePrintfM s = traceM . printf s\n```\n\n### Type Inference(类型推断)\n虽然通常可以完成`Haskell`的推断，但在某些情况下无法推断主体类型。三种常见情况是:\n\n* 由于相互递归的綁定組，`Reduced`(降低)了多态性\n* 由于多态递归导致的不确定性\n* 由于单态性限制，`Reduced`(降低)了多态性\n\n在每种情况下，`Haskell`都需要程序员的提示，可以通过添加显式类型签名来提供提示。\n\n\n#### Mutually Recursive Binding Groups(相互递归绑定组)\n```haskell\nf x = const x g\ng y = f 'A'\n```\n推断出的类型签名在`usage`(用法)上是正确的，但并不代表最通用的签名。当`GHC`分析模块时，它会分析表达式之间的依赖关系，将它们分组在一起，并在相互定义的组之间应用统一的替换。因此，推断的类型可能不是最`general`(通用)的类型，因此可能需要显式签名。\n```haskell\n-- Inferred types 推断类型\nf :: Char -> Char\ng :: t -> Char\n\n-- 最通用的类型\nf :: a -> a\ng :: a -> Char\n```\n\n#### Polymorphic recursion(多态递归)\n```haskell\ndata Tree a = Leaf | Bin a (Tree (a, a))\n\nsize Leaf = 0\nsize (Bin _ t) = 1 + 2 * size t\n```\n递归是多态的，因为在`size`中推断出的类型变量`a`跨越两种可能的类型(`a`和`(a，a)`).\n这两种类型不会通过类型检查器的`occurs-check`，并且会产生不正确的推断类型。\n```haskell\nOccurs check: cannot construct the infinite type: t0 = (t0, t0)\nExpected type: Tree t0\n  Actual type: Tree (t0, t0)\nIn the first argument of `size', namely `t'\nIn the second argument of `(*)', namely `size t'\nIn the second argument of `(+)', namely `2 * size t'\n```\n简单地添加一个显式类型签名就可以解决这个问题。在一般情况下，使用多态递归的类型推断是不可判定的。\n```haskell\nsize :: Tree a -> Int\nsize Leaf = 0\nsize (Bin _ t) = 1 + 2 * size t\n```\n請看:\n* [Static Semantics of Function and Pattern Bindings](https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-880004.5)(函數和模式绑定的静态语义)\n\n#### Monomorphism Restriction(单态限制)\n单态性限制是一个有争议的类型规则。 默认情况下，它在编译时处于打开状态，而在`GHCi`中处于关闭状态。该规则的实际效果是，为没有显式类型签名的函数推断的类型可能比预期的更`specific`(具体/明確)。\n\n这是因为`GHC`有时会将`general`(一般)类型(例如`Num`)减少为默认类型(例如`Double`)。在`GHCi`中的以下示例中可以看出:\n```haskell\nλ: :set +t\n\nλ: 3\n3\nit :: Num a => a\n\nλ: default (Double)\n\nλ: 3\n3.0\nit :: Num a => a\n```\n可以使用`NoMonomorphicRestriction`扩展来禁用此规则，请参见[下文](http://dev.stephendiehl.com/hask/#nomonomorphicrestriction)。\n\n請看:\n* [Monomorphism Restriction](https://wiki.haskell.org/Monomorphism_restriction)(单态限制)\n\n### Type Holes / Pattern Wildcards\n自`GHC 7.8`发布以来，类型孔或模式通配符，允许使用下划线作为实际值的替代。它们可以在声明或类型签名中使用。\n\n类型孔对于调试不完整的程序很有用。通过在声明右侧的任何值上加一个下划线，`GHC`将在类型检查期间引发错误。错误消息描述了哪些值可以合法填充类型孔。\n```haskell\nhead' = head _\ntypedhole.hs:3:14: error:\n    • Found hole: _ :: [a]\n      Where: ‘a’ is a rigid type variable bound by\n               the inferred type of head' :: a at typedhole.hs:3:1\n    • In the first argument of ‘head’, namely ‘_’\n      In the expression: head _\n      In an equation for ‘head'’: head' = head _\n    • Relevant bindings include head' :: a (bound at typedhole.hs:3:1)\n```\n`GHC`正确地建议完成程序所需的表达式是`xs :: [a]`.\n同样的孔技术可以应用于顶级签名:\n```haskell\nconst' :: _\nconst' x y = x\ntypedhole.hs:5:11: error:\n    • Found type wildcard ‘_’ standing for ‘t -> t1 -> t’\n      Where: ‘t1’ is a rigid type variable bound by\n               the inferred type of const' :: t -> t1 -> t at typedhole.hs:6:1\n             ‘t’ is a rigid type variable bound by\n               the inferred type of const' :: t -> t1 -> t at typedhole.hs:6:1\n      To use the inferred type, enable PartialTypeSignatures\n    • In the type signature:\n        const' :: _\n    • Relevant bindings include\n        const' :: t -> t1 -> t (bound at typedhole.hs:6:1)\n```\n还可以为模式通配符指定显式名称，以便`GHC`在报告结果消息中的推断类型时使用。\n```haskell\nfoo :: _a -> _a\nfoo _ = False\ntypedhole.hs:9:9: error:\n    • Couldn't match expected type ‘_a’ with actual type ‘Bool’\n      ‘_a’ is a rigid type variable bound by\n        the type signature for:\n          foo :: forall _a. _a -> _a\n        at typedhole.hs:8:8\n    • In the expression: False\n      In an equation for ‘foo’: foo _ = False\n    • Relevant bindings include\n        foo :: _a -> _a (bound at typedhole.hs:9:1)\n```\n可以在类型上下文中使用相同的通配符来`dump out`(转出)推断的类型类约束：\n```haskell\nsucc' :: _ => a -> a\nsucc' x = x + 1\ntypedhole.hs:11:10: error:\n    Found constraint wildcard ‘_’ standing for ‘Num a’\n    To use the inferred type, enable PartialTypeSignatures\n    In the type signature:\n      succ' :: _ => a -> a\n```\n当将标志`-XPartialTypeSignatures`传递给`GHC`且推断的类型是明确的时，`GHC`将让我们保留这些空缺，然后进行编译。\n```haskell\ntypedhole.hs:3:10: Warning:\n    Found hole ‘_’ with type: w_\n    Where: ‘w_’ is a rigid type variable bound by\n                the inferred type of succ' :: w_ -> w_1 -> w_ at foo.hs:4:1\n    In the type signature for ‘succ'’: _ -> _ -> _\n```\n\n### Deferred Type Errors(延迟的类型错误)\n\n自7.8版发布以来，`GHC`支持将类型错误视为运行时错误的选项。启用此选项后，程序将运行，但在评估输入错误的表达式时它们将失败。\n\n使用`-fdefer-type-errors`标志以三种方式启用此功能: 在模块级别，从命令行编译时或在`GHCi`交互式会话内部。\n\n例如，下面的程序将编译:\n```haskell\n{-# OPTIONS_GHC -fdefer-type-errors #-} -- 在模块级别启用延迟的类型错误\n\nx :: ()\nx = print 3\n\ny :: Char\ny = 0\n\nz :: Int\nz = 0 + \"foo\"\n\nmain :: IO ()\nmain = do\n  print x\n```\n但是，当在运行时评估病理学术语时，我们将看到类似以下的消息:\n```haskell\ndefer: defer.hs:4:5:\n    Couldn't match expected type ‘()’ with actual type ‘IO ()’\n    In the expression: print 3\n    In an equation for ‘x’: x = print 3\n(deferred type error)\n```\n该错误告诉我们，虽然`x`具有声明的类型`()`，但是函数`print 3`的主体具有`IO ()`类型。但是，如果从未对该术语进行评估，那麼`GHC`將不会抛出异常。\n\n### ghcid\n[ghcid](https://github.com/ndmitchell/ghcid)是一个轻量级的`IDE hook`，无论何时更新代码，它都可以提供持续的反馈。可以通过指定要运行的命令(例如`ghci`，`cabal repl`或`stack repl`)从`cabal`项目目录根目录中的命令行运行。\n```haskell\nghcid --command=\"cabal repl\"  # Run cabal repl under ghcid\nghcid --command=\"stack repl\"  # Run stack repl under ghcid\nghcid --command=\"ghci baz.hs\" # Open baz.hs under ghcid\n```\n当将`Haskell`模块加载到`ghcid`中时，将对代码进行评估，以向用户提供在编译时可能发生的任何错误或警告。当开发人员编辑并保存加载到`ghcid`中的代码时，程序会自动重新加载并评估代码中的错误和警告。\n\n\n### Haddock\n\n[Haddock](https://www.haskell.org/haddock/#Overview)是`Haskell`源代码的自动文档生成工具。它与通常的`cabal`工具链集成在一起。在本节中，我们将探索如何编写代码文档，以便`Haddock`可以成功生成文档。\n\n有几种常见的注释模式用于记录`Haddock`的代码。这些方法中的第一种使用`-|`来描述注释的开头:\n```haskell\n-- | Documentation for f\nf :: a -> a\nf = ...\n```\n多行注释也是可能的:\n```haskell\n-- | Multiline documentation for the function\n-- f with multiple arguments.\nfmap :: Functor f =>\n     => (a -> b)  -- ^ function\n     -> f a       -- ^ input\n     -> f b       -- ^ output\n```\n\n`-- ^`也用于注释构造函数或记录字段:\n```haskell\ndata T a b\n  = A a -- ^ Documentation for A\n  | B b -- ^ Documentation for B\n\ndata R a b = R\n  { f1 :: a -- ^ Documentation for the field f1\n  , f2 :: b -- ^ Documentation for the field f2\n  }\n```\n通过将标识符括在单引号中，可以超链接 模块(即`value`、`types`、`classes`)中的元素:\n```haskell\ndata T a b\n  = A a -- ^ Documentation for 'A'\n  | B b -- ^ Documentation for 'B'\n```\n可以通过将模块括在双引号中来引用模块本身:\n```haskell\n-- | Here we use the \"Data.Text\" library and import\n-- the 'Data.Text.pack' function.\n```\n`haddock`还允许用户在生成的文档中包含代码块。`haddock`中存在两种划分代码块的方法。例如，用`@`符号括起来的代码段将其标记为代码块:\n```haskell\n-- | An example of a code block.\n--\n-- @\n--    f x = f (f x)\n-- @\n```\n同样，可以在注释行中使用鸟形轨迹`(>)`来設置代码块。这种用法与`Bird`风格的[Literate Haskell](https://wiki.haskell.org/Literate_programming#Bird_Style)非常相似。\n```haskell\n-- | A similar code block example that uses bird tracks (i.e. '>')\n-- > f x = f (f x)\n```\n交互式`shell`会话的片段也可以包含在`haddock`文档中。为了表示打算在`REPL`中运行的代码的开头，使用`>>>`符号:\n```haskell\n-- | 嵌入文档中的交互式shell会话示例\n--\n-- >>> factorial 5\n-- 120\n```\n可以通过在模块块中的注释前面加上`*`来添加特定块的标题:\n```haskell\nmodule Foo (\n  -- * My Header\n  example1,\n  example2\n)\n```\n也可以用与模块主体中的引用有关的`$`块来描述各章節:\n```haskell\nmodule Foo (\n  -- $section1\n  example1,\n  example2\n)\n\n-- $section1\n-- Here is the documentation section that describes the symbols\n-- 'example1' and 'example2'.\n```\n可以使用以下语法添加链接:\n```haskell\n<url text>\n```\n只要路径是绝对路径或相对于运行`haddock`的目录的相对路径，也可以包含`image`.\n```haskell\n<<diagram.png title>>\n```\n`haddock`选项也可以在源代码中用`pragmas`指定，无论是在模块级还是项目级.\n```haskell\n{-# OPTIONS_HADDOCK show-extensions, ignore-exports #-}\n```\n```haskell\nOption\t        Description\n-------------------------------\nignore-exports    忽略导出列表，并包括作用域内的所有签名。\nnot-home          根文档中将不考虑模块。\nshow-extensions   使用所使用的语言扩展注释文档。\nhide              强制从Haddock隐藏该模块。\nprune             省略没有注释的定义.\n```","tags":["Basics"]},{"title":"代数数据类型的代数结构(下)","url":"/blog/2019/11/01/代数数据类型的代数结构-下/","content":"> [查看原文](https://web.archive.org/web/20140222124650/http://chris-taylor.github.io/blog/2013/02/13/the-algebra-of-algebraic-data-types-part-iii/)\n\n上次我描述了递归类型，展示了如何将其写为代数方程式，然后您可以求解方程式以推断出有关类型的有趣事实。在本文中，我将解释对类型进行演算的含义。\n\n## Zippers\n常规的`Haskell`列表是一个链接列表。 尽管它们易于定义且易于使用，但它们也有缺点。如果要将元素添加到长度为n的列表，则需要`O(n)`时间。在列表中途访问或修改元素也很慢。链接列表不支持有效的随机访问。\n\n您可以使用数组解决此问题，但不可变数组有其自身的问题。例如，如果您希望数组的元素在内存中是连续的，则数据共享会更加困难。\n\n幸运的是，并非所有应用程序都需要随机访问。有时，您只想跟踪列表中的位置，并能够在列表中四处移动，并可以随时修改元素。\n\n这正是`zipper`所提供的功能，`zipper`是一种数据结构，具有指向可分辨位置的指针，称为`focus`。\n\n## List Zippers\n你可以为任何数据结构写一个`zipper`拉链，但我将重点放在列表上。\n要存储指针，我们可以用一个`Int`将列表包装起来，该`Int`将当前位置存储在`focus`中。\n不过，这充满了各种各样的困难，而且它不符合我们对`focus`中元素的高效访问的要求。\n相反，我们定义了一个新类型，它由`focus`中的元素和一对列表组成，其中一个列表包含`focus`之前的元素，另一个包含`focus`之后的元素, 示意图如下:\n\n![](img/img01.png)\n\n`focus`中的元素在中心，两个列表在两侧。在`Haskell`中，我们将写為:\n```haskell\ndata Zipper a = Z [a] a [a]\n```\n为了使拉链有用，我们需要定义一些函数来左右移动焦点。\n\n出于效率方面的考虑，我们以相反的顺序存储第一个列表-我们需要从列表的末尾（而不是头）有效地添加和删除元素：\n```haskell\nleft  (Z (l:ls) c rs) = Z ls l (c:rs)\nright (Z ls c (r:rs)) = Z (c:ls) r rs\n```\n如果您想了解有关`zippers`的更多信息，那么[Learn You a Haskell](https://web.archive.org/web/20140222183509/http://learnyouahaskell.com/zippers)的最后一章将进行出色的介绍。\n\n## One-Hole Contexts\n\n`zipper`是一种`product`类型-它是两个`as`列表和一个`a`列表的`product`。\n记住, 列表为`L(a)= 1/(1-a)`，列表拉链`LZ(a)`表示为:\n\n![](img/img02.png)\n\n因为`zipper`是一种`product`类型，所以可以将它分开，将其分解为一个单独的数据，并与两个列表配对。这两个列表告诉我们`focus`在哪里，我们通过填写`focus`所在的数据来完成`zipper`。代数上我们有:\n\n![](img/img03.png)\n\n这显然等同于前面的表达式。`product`的第一部分只是一段数据，我们可以把第二部分看作是一个有`hole`(洞)的数据结构当我们用一些数据来配对'填充'这个`hole`(洞)时，我们会得到一个`zipper`。\n\n此'带`hole`(洞)的数据结构'使用`one-hole context`(单洞上下文)的名称。对于列表拉链，如下所示：\n\n![](img/img04.png)\n\n空圆圈是一个`hole`(孔)，代表`无数据`-它是数据的占位符。不包含数据的类型是`unit`(单位)类型`()`，因此我们可以说孔的类型是`()`.\n\n列表拉链没有什么特别的-任何拉链都可以分解为`one-hole`上下文，并且一条数据可以填充`hole`(洞)。\n\n## One-Hole Contexts for Tuples\n我说过，您可以为任何数据类型编写一个拉链，所以让我们为元组编写一些拉链-也就是说，`$a^n$`形式的类型代表某个整数`n`。\n### One-Tuples\n最简单的情况是一元组，它只是一个数据片段。一元组的拉链很简单-只有一个数据位置，所以只有一个`focus`(焦点), 一元组`a`的拉链只是一个`a`。\n\n但是请记住，`zippers`是与`one-hole`上下文配对的一段数据，那么`one-hole`上下文是什么？只有一个地方可以放这个`hole`(洞)，一旦我们在一段数据中放了一个`hole`(洞)，我们就只剩下这个洞了！示意图上，数据与`one-hole`上下文的配对如下所示:\n```haskell\n(a,∘)\n```\n`one-hole`上下文的类型必须为`()`或`1`，这样，当我们将其与数据`a`配对时，我们将再次获得`a`。\n\n### Two-Tuples\n在两元组中，该`hole`(洞)有两个可能的位置。请记住，`sum`表示一个选择，无论是左侧构造函数还是右侧构造函数，数据和`one-hole`上下文的配对如下所示:\n```haskell\n(a,(∘,a)+(a,∘))\n```\n请记住，`hole`的类型为1，`one-hole`上下文的类型为`a + a`或`2a`。\n\n### Three-Tuples\n在三元组中，该`hole`有三个可能的位置。数据和`one-hole`上下文的配对看起来像:\n```haskell\n(a,(∘,a,a)+(a,∘,a)+(a,a,∘))\n```\n`one-hole`上下文的类型为`a²+a²+a²`或`3a²`。\n\n\n## Finding the pattern(寻找模式)\n也许您已经看到了这种模式。 左列是`n = 1、2、3`的`n`元组的类型，右列是其相应的拉链:\n![](img/img05.png)\n\n如果你研究过任何微积分，你会立即发现这个模式——对于一个类型为`a^n`的`n`元组，拉链的类型是`na^n-1`，这正是`a^n`的`derivative`(导数)。\n\n实际上，这种模式始终适用！`Conor McBride`在一篇[论文](https://web.archive.org/web/20140222183509/http://strictlypositive.org/diff.pdf)中指出了这一点，其标题给出了关键的见解:\n\n`The Derivative of a Regular Type is its Type of One-Hole Contexts`(常规类型的导数是其`one-hole`上下文的类型)\n\n如果采用类型表达式并对其进行区分，则结果是该类型的`one-hole`上下文类型。这样就很容易找出如何为任意数据类型编写`zipper`。\n\n## Calculus of Types(类型演算)\n我将使用符号`∂a`来表示'对`a`求导'。您可能已经熟悉了用于区分的符号`d/da`, 这没有什么不同，但它的优点是可以在一行上排版！\n\n我们能把一个类型的导数和它的`one-hole`上下文之间的类比推多远？\n在所有上下文中区分类型是否有效，还是必须小心? 我们当然应该检查微分运算在应用于我们已经知道的类型时是否有意义，例如.\n\n### Constants\n这是微积分的一条简单规则–任何常数的导数为零:\n\n![](img/img06.png)\n\n要对类型解释这一点，请记住派生运算符`d/d a`在包含类型`A`的数据的数据结构中创建了`hole`。此公式表示，如果类型没有任何类型`A`的数据，则其`one-hole`上下文为`Void`，即您不能创建它的任何实例。\n\n### Sums\n导数的求和规则是，对于任何`f(a)`和`g(a)`，`sum`与分别求和然后在求和相同:\n\n![](img/img07.png)\n\n这告诉我们，在`sum`类型中创建一个`hole`相当于在每个`summands`(被加数)中创建一个`hole`，并取它们的和。在更明确的语言中，如果`F a`和`G a`是具有`one-hole`上下文`DF a`和`DG a`的类型，则\n```haskell\ntype Sum a = Add (F a) (G a)\n```\n`one-hole`上下文為:\n```haskell\ntype DSum a = Add (DF a) (DG a)\n```\n\n### Products\n在微积分中，`product`的导数由[莱布尼兹的product规则](https://web.archive.org/web/20140222183509/http://en.wikipedia.org/wiki/Product_rule)给出:\n\n![](img/img08.png)\n\n解释为有关类型的说明，这告诉我们在两种类型的`product`中打`hole`(孔)等同于在第一种类型中打孔(并保留第二种形式)或在第二种类型中打孔(并保留第一个原样)。就是说，\n```haskell\ntype Prod a = (F a, G a)\n```\n的`one-hole`上下文為:\n```haskell\ntype DProd a = Add (DF a, G a) (F a, DG a)\n```\n\n### Composition\n我们还没见过`composition`。如果数据结构`F`包含`G a`类型的元素，则会发生这种情况。\n```haskell\ndata Compose f g a = Compose (f (g a))\n```\n其中`f`和`g`的种类为`* -> *`，而`a`的种类为`*`，尽管保持语法简洁并只写`f(g a)`更简单。\n\n在微积分中，[链式规则](https://web.archive.org/web/20140222183509/http://en.wikipedia.org/wiki/Chain_rule)告诉我们如何区分`compositions`(组成):\n\n![](img/img09.png)\n\n作为一个类型方程，这意味着要在分层数据结构中创建一个`hole`(孔)，我们需要一个`product`,一半的`product`告诉我们孔在外部结构中的位置，另一半则跟踪内部结构中的孔。也就是说，\n```haskell\ntype Comp a = F (G a)\n```\n的`one-hole`上下文為:\n```haskell\ntype DComp a = (DG a, DF (G a))\n```\n\n## Deriving Zippers\n我说过，知道`ADT`的派生与其`one-hole`上下文类型相对应，就可以轻松地为任意数据类型派生拉链。现在，我将证明该主张的合理性。\n### List Zippers\n列表的类型是:\n\n![](img/img10.png)\n\n我们可以使用`quotient`(商)规则和`chain`(链)规则对此进行区分，發現:\n\n![](img/img11.png)\n\n它说列表的`one-hole`上下文是一对列表，正如我们之前所看到的。为了获得列表拉链，我们将`a`与一对列表`L(*a)`進行`product`.\n\n### Tree Zippers\n请记住，二叉树`T(a)`的类型由递归方程定义:\n\n![](img/img12.png)\n\n我们可以像上一篇文章一样求解`T(a)`，然后区分结果。但是，使用[隐式差异](https://web.archive.org/web/20140222183509/http://en.wikipedia.org/wiki/Implicit_differentiation#Implicit_differentiation)来区分上述表达式要容易得多，得到:\n\n![](img/img13.png)\n\n然后我们可以针对`dT/da`解决此问题，找到:\n\n![](img/img14.png)\n\n为了理解这一点，请记住类型`1/(1-x)`与`x`列表中的类型`L(x)`同义。\n所以树拉链是:\n\n![](img/img15.png)\n\n也就是说，树的`one-hole`上下文是两棵树和一个包含类型元素`(bool，a，tree a)`的列表的`product`。看起来是这样的:\n\n![](img/img16.png)\n\n`hole`是我们当前的位置，`focus`(焦点)。洞的下面是两棵树，它们容纳了我们还没有穿过的那部分树。在这张照片中，它们都是单元素树。\n\n回到树顶的红色节点的序列是`past`(过去)-我们经过的树元素最终在`hole`(孔)处结束。\n\n每个节点都与一个`Bool`相关联，该`Bool`告诉我们经过该节点后是左分支还是右分支，以及一个`Tree a`，其中包含所有我们未沿另一条路径错过的元素。\n\n练习：为二进制树编码拉链，记住拉链是与数据配对的`one-hole`上下文。您需要编写`left/right`函数，以在特定节点上使用`left`或`right`路径，并使用`up`返回上一级树。\n\n练习：玫瑰树是每个节点上具有任意多个分支的树。在`Haskell`中，您可以通过以下方式定义它们:\n```haskell\ndata Rose a = Rose a [Rose a]\n```\n玫瑰树拉链长什么样？\n\n## Next Time\n在这篇文章中，我们了解了采用`ADT`的派生(对`ADT`求导)是什么意思，以及如何操作类型代数来自动为任意数据类型派生`zipper`。\n下一次我将讨论给类型的减法和除法赋予一个意义，我可能会继续提到`combinatorial species`(组合种类)。\n","tags":["Chris Taylor"]},{"title":"代数数据类型的代数结构(中)","url":"/blog/2019/11/01/代数数据类型的代数结构-中/","content":"> [查看原文](https://web.archive.org/web/20140222124650/http://chris-taylor.github.io/blog/2013/02/11/the-algebra-of-algebraic-data-types-part-ii/)\n\n上一章節，我介紹了`unit`類型`Unit`或`()`，以及`zero`類型`Void`,同時也介紹了运算符`Add`和`Mul`,還有函數類型`a -> b`.\n\n在这篇文章中，我将同时使用`Haskell`表示法和数学表示法。下表将帮助您在两者之间来回转换.\n\n![](img/img01.png)\n\n在这篇文章中，我将讨论`recursive`(递归)类型，并展示如何利用类型代数来推断它们的有趣之处.\n\n\n## Maybe\n\n让我们来探索`Maybe a`。此类型指示它可能包含类型`a`的值，但也可能为空。它是这样定义的:\n```haskell\ndata Maybe a = Nothing | Just a\n```\n竖线表示这是一个`sum`类型，因此，如果我们首先定义`Nothing`和`Just a`类型，则可以使用之前定义的`Add`类型来编写它。它看起来像这样:\n```haskell\ndata Nothing = Nothing\ndata Just a  = Just a\n\ntype Maybe a = Add Nothing (Just a)\n```\n看看我们如何将`data`声明替换为`type`声明？这意味着`Just a`不再是一种新类型, 只是我们已经知道的一种类型的同义词。\n\n但是我们可以更进一步。请注意，`Nothing`仅具有一个值，因此等效于`()`.\n\n同样，`Just`是一个具有类型`a`的单个值的容器，因此等效于`a`。因此，我们有:\n```haskell\ntype Maybe a = Add () a\n```\n但这就相当于说, `Maybe a`与`1 + a`相同。`Maybe`所做的只是为类型增加一个可能的值.\n\n## Recursive Types\n### Lists\n`Haskell`中的基本列表是一个链表。\n`as`的列表要么是空的，表示为`[]`，要么是单个`a`的`cons`到另一个`as`的列表中，表示为`a:as`。如果我们想定义自己的列表，我们可以写类似:\n```haskell\ndata List a = Nil | Cons a (List a)\n```\n让我们花点时间看一下此声明的结构。就像`Maybe`一样，`List`类型是两个简单类型的`sum`.\n\n第一个`summand`(被加数)是`Nil`，这是一个等效于`()`的`nullary`(空的)构造函数.\n\n第二个`summand`是`Cons a (List a)`，它是由`a`和`as`列表组成的`product`.\n\n如果我们将列表写为`L(a)`，则代数形式为:\n```haskell\nL(a) = 1 + a ⋅ L(a)\n```\n似乎我们应该能够在`Haskell`中将列表类型编写为:\n```haskell\ntype List a = Add () (a, (List a))\n```\n但事实上，这不会编译。\n原因是类型同义词在编译时、类型检查之后、编译之前`expanded`(展开)。这个定义永远不会完成`expanding`(展开)，它只会继续增长:\n```haskell\nAdd () (a, Add () (a, Add () (a, ...)))\n```\n等等。这样做无效的原因与`Haskell`处理递归类型定义的方式有关(就像大多数具有复杂类型系统的语言一样，它使用[isorecursive类型而不是equirecursive类型](https://web.archive.org/web/20140222144454/http://en.wikipedia.org/wiki/Recursive_data_type#Isorecursive_types))。\n\n解决方法是使用`newtype`声明而不是`type`声明，并将类型包装在新的构造函数`L`中:\n```haskell\nnewtype List a = L (Add () (a, List a))\n```\n这只是为了在编译代码时满足类型检查器的要求，额外的构造函数将被优化掉，剩下的将与上面的`type`声明相同。\n\n如果我将`List a`类型写为`L(a)`，那么这个列表声明说明:\n```haskell\nL(a) = 1 + a ⋅ L(a)\n```\n要查看真正的列表，我们可以通过重复`substitution`(替换)开始`expanding`(扩展/展开)定义。在`expansion`(展开)中，每当看到`a · a`的形式时，我都会将其替换为`a²`以节省空间。\n\n练习：表达式`a²`可以表示為一对`(a，a)`或函数`2 → a`。显示这些都是一样的.\n![](img/img02.png)\n\n这告诉我们`A`的列表要么是空的列表，要么是包含单个`A`的列表，要么是包含两个`A`的列表，或者是三个`A`的列表，等等。也许你已经知道了——但是代数告诉我们这很好！\n\n但现在，这里有一些非常酷的东西, 让我们从列表的等式开始，而不是一再替换，我们会暂时忘记对象是类型，并假装它们是任意的数学表达式。这意味着我们有理由使用任何我们喜欢的方法来解出`L(a)`.\n\n首先，从两边减去`a * L(a)`:\n```haskell\nL(a) − a⋅L(a) = 1\n```\n现在将左侧的`L(a)`提出来(`factor out`):\n```haskell\n(1−a) ⋅ L(a) = 1\n```\n最后，将两边都除以`1-a`:\n\n![](img/img03.png)\n\n这看起来很荒谬，因为我们不知道从另一种类型减去一种类型的含义，而且我们当然也不知道将一种类型`divide`(除以)另一种类型的含义。 但这是否告诉我们一些有趣的事情？\n\n如果你学习微积分，你可能记得许多函数都有`Taylor Series`(泰勒级数)`expansion`(展开式)。\n\n我们可以问`Wolfram Alpha`, `1/(1-a)`的泰勒级数是什么，它告诉我们:\n![](img/img04.png)\n\n也就是说，`L(a)`的级数展开正是我们从重复`substitutions`(替换)中推导出来的.\n尽管我们严重地滥用了代数，通过对类型执行完全不合理的操作，我们最终还是得到了一个合理的答案.\n\n### Trees\n\n考虑在节点处具有值的二叉树的类型。在`Haskell`中，您可以将其写为:\n```haskell\ndata Tree a = Empty | Node a (Tree a) (Tree a)\n```\n\n在某种程度上，我们可能已经很熟悉了，我们可以把它看作是两种类型的`sum`, 一种等价于`()`的空类型，一种`product`类型。\n\n这一次它是由三个`terms`组成的`product`,但这不是问题——我们只是使用一个嵌套的`product`,形式是`(a,(b,c))`。\n\n用我们已经知道的运算符定义(同样，使用`newtype`允许我们有递归定义)是:\n```haskell\nnewtype Tree a = T (Add () (a, (Tree a, Tree a)))\n```\n用代数语言，对于树的类型为`T(a)`，我们将写為:\n\n![](img/img05.png)\n\n为了更好地理解树是什么，我们可以像处理列表那样应用重复替换，但这会更混乱相反，我们能用重新排列方程的技巧来求解`T(a)`吗？\n\n首先，重新排列以获得等式一侧的所有内容:\n\n![](img/img06.png)\n\n我们现在可以把它看作`t(a)`的[二次方程](https://web.archive.org/web/20140222144454/http://en.wikipedia.org/wiki/Quadratic_equation)，我们可以用二次方程来求解，得到:\n\n![](img/img07.png)\n\n这比列表方程式更没有意义。 取一个类型的平方根到底意味着什么？但是，保持冷静，我们再次要求`Wolfram Alpha`进行级数展开，它告诉我们:\n\n![](img/img08.png)\n\n我们如何理解这一点？前两个术语告诉我们，一棵树可以是空的(如果是`Empty`)，也可以有一个类型为`a`的值(如果它是`Node a Empty Empty`)。\n\n下一个术语告诉我们一棵树可以用2种不同的方式包含2个`A`类型的值，而下一个术语告诉我们可以用5种不同的方式包含3个`A`类型的值。\n\n但是，如果我们枚举所有的二叉树，并按照它们包含的值的数量对它们进行分组，这正是我们注意到的。一棵树没有值，一棵树只有一个值。然后，有两棵树具有两个值，五棵树具有三个值–如图(从`Flajolet`和`Sedgewick`的出色著作`Analytic Combinatorics`中借用):\n\n![](img/img09.png)\n\n该方程计算可以存在的不同二叉树的数目。这个计数属性与我们在第一篇文章中看到的简单值计数示例有关，也与组合物种有关，如`Brent Yorgey`所广泛描述的。物种和类型有很多共同点，尽管它们不是一回事。\n\n* [combinatorial species](https://web.archive.org/web/20140222144454/http://en.wikipedia.org/wiki/Combinatorial_species)\n* [Brent Yorgey](https://web.archive.org/web/20140222144454/http://byorgey.wordpress.com/)\n\n### Seven Trees In One (七棵树合而为一)\n\n如果我们限制到只包含`unit`(单位)类型的树，即`Tree ()`，则出现在`T(a)`中的`a`等于1，我们可以将树的定义方程写为:\n\n![](img/img10.png)\n\n通过玩代数，反复使用`t2 = t - 1`这个事实，我们可以推断出:\n\n![](img/img11.png)\n\n当用类型语言解释时，它表示六元组树相当于单位类型。\n\n换句话说，只有一棵六元组的树。\n这显然是胡说八道，出什么事了？更神秘的是，如果我们把方程的两边乘以`t`，我们就得到:\n\n![](img/img12.png)\n\n这不是胡说八道-它说七元树等于一個`single`棵树。\n\n乍一看，这不是一个深刻的结果。 具有`countably infinite`([无限数量](https://web.archive.org/web/20140222144454/http://en.wikipedia.org/wiki/Countable_infinity))的可能值的任何两种类型都是等效的-这就是`countable`(可数)的含义。\n\n然而，这比这更微妙。在[七棵树合一](https://web.archive.org/web/20140222144454/http://arxiv.org/pdf/math/9405205v1.pdf)的论文中，`Andreas Blass`不仅展示了如何找到一个从七棵树到一棵树再回到另一棵树的显式映射（本质上他告诉你如何编写上一篇文章中的`from`和`to`函数），而且还展示了函数在任何一棵树中都不需要看超过四层的深度。\n\n最后，他解释了为什么推断`$T^7$ = T|`是有效的，而`$T^6$ = 1`不是事实证明，你可以把我在上面给出的使用减法的推导转化为一个不使用减法的`诚实`证明，因此对类型有效, 但只有当你开始使用的`t`的幂大于6的倍数时。\n\n因此，可以将`t7`進一步`reduce`(化簡為)为`t`(因为`7=6+1`),但不能将`t6`(化簡為)为1.\n\n### An Explanation? (一个解释?)\n\n如果你认为这篇文章提出的问题比它提供的答案还多，这是公平的。例如:\n\n* 减去、除以或取类型的平方根是什么意思？\n* 对于一个仍然有意义的`computational interpretation`(计算解释)的类型方程，你还能做些什么呢？\n* 为什么对类型方程的不合理操作会产生合理的答案呢？\n\n作为最后一个问题的总结，对类型进行建模的数学结构是`semirings`(半环)。\n\n这只是一种说法，可以加和乘`objects`(对象)，你有对应于0和1的对象。`MarceloFiore`和`Tom Leinster`发表的一篇论文表明，如果你能从`equation`(方程)定义的复数`t`开始:\n```haskell\nt = p(t)\n```\n\n对于某些多项式`p`，并推导:\n\n![](img/img13.png)\n\n如果`q1`和`q2`不是常数(它们不能只是1)，那么同样的结果也适用于`semirings`(半环)尤其是对于类型，这是正确的，并且您可以找到不使用`subtraction`(减法)的证明，或者找到对类型非法的任何其他运算符。\n\n下次，我将解释什么是`zippers`(拉链)，并描述如何对类型进行微积分。\n","tags":["Chris Taylor"]},{"title":"代数数据类型的代数结构(上)","url":"/blog/2019/11/01/代数数据类型的代数结构-上/","content":"> [查看原文](https://web.archive.org/web/20140222124650/http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/)\n\n我在2012年11月的`London Haskell`上做了关于这个主题的演讲。演讲的视频在`YouTube`上，幻灯片在`GitHub`上。\n在这一系列文章中，我将解释为什么`Haskell`的数据类型被称为代数-而不提及範疇理论或高级数学。\n\n您在高中学习的代数以数字(例如`1、2、3...`)和运算符(例如加法和乘法)开始。运算符为您提供了一种组合数字并从中生成新数字的方法。例如，将`1`和`2`与加法运算相结合会得出另一个数字`3`, 我们通常表示为:\n```haskell\n1 + 2 = 3\n```\n当你年纪稍大时，你会初次了解一些变量(例如`x，y，z...`)，这些变量可以代表数字。\n更进一步，你会学到代数所遵循的`laws`(法律/定律/法則)。比如:\n```haskell\n0 + x = x\n1 ⋅ x = x\n```\n它适用于`x`的所有值。还有其他`laws`(法律)，它们定义数字或运算的性质。\n\n当数学家谈论代数时，他们指的是比这个更一般的东西。数学代数包括三个部分:\n* **Objects** (对象)是代数的`things`(事物/東西)。对象集合定义了我们所讨论的内容。\n* **Operations** (操作)为我们提供了将旧事物组合成新事物的方法。\n* **Laws** (法律)是对象与操作之间的关系。\n\n在高中代数中，对象是数字，运算是加法、乘法和`friends`(朋友/友元)。\n\n### Haskell类型的代数\n在`Haskell`类型的代数中，`objects`(对象)是类型，例如`Bool`和`Int`。\n\n`Operations`(操作)根据已经存在的类型并从中生成新的类型。一个例子是类型构造函数`Maybe`。它本身不是类型(类型构造子)，但您可以使用它来创建类型，例如类型可能是`Maybe Bool`和`Maybe Int`。另一个示例是`Either`，它从两个旧类型创建了一个新类型, 例如`Either Int Bool`。\n\n#### `counting`(计数)\n通过计算类型可能具有的值，可以看到与更熟悉的数字代数之間的联系。以`Bool`为例:\n```haskell\ndata Bool = False | True\n```\n`Bool`类型的对象可以有两个值，一个是`False`，另一个是`True`(从技术上讲，它也可以是`undefined`)，在后面的文章中我将忽略这一事实。\n粗略地说，`Bool`类型对应于数字代数中的数字`2`.\n如果`Bool`是`2`，那么`1`是什么？它应该是只有一个值的类型。\n在计算机科学文献中，这种类型通常称为`Unit`(单位)，并定义为:\n```haskell\ndata Unit = Unit\n```\n在`Haskell`中，已经有一个只有一个值的类型--称为`()`(读作'单位')。\n\n您不能自己定义它，但是如果可以定义的话:\n```haskell\ndata () = ()\n```\n使用这个计数法类比，`Int`对应于数字`$2^32$`(2的32次方)，因为这是`Int`类型的值的数量(至少它在我的机器上是這樣).\n\n#### 加法\n原则上，我们可以键入与3、4、5等相对应的类型。有时我们可能确实需要这样做, 例如，对应于7的类型对于编码星期几很有用。但是，如果我们能够从旧的基础上构建新的类型，那就更好了。这就是代数`operators`(运算符)的用武之地。\n\n对应于加法的类型是:\n```haskell\ndata Add a b = AddL a | AddR b\n```\n也就是说，类型`a + b`是`tagged union`(标记的并集)，持有`a`或`b`。要了解为什么这与加法相对应，我们可以重新考虑计数法。假设`a`为`Bool`，`b`为`()`，因此`a`有`2`个值，`b`有`1`个值。那麼`Add Bool ()`类型有多少個值？我们可以列出它们:\n```haskell\naddValues = [AddL False, AddL True, AddR ()]\n```\n有三个值，即`3 = 2 + 1`。这通常称为`sum`类型。在`Haskell`中，`sum`类型通常称为`Either`，定义为:\n```haskell\ndata Either a b = Left a | Right b\n```\n但我会坚持使用`Add`.\n\n#### 乘法\n对应于乘法的类型是:\n```haskell\ndata Mul a b = Mul a b\n```\n也就是说，类型`a · b`是既包含`a`又包含`b`的容器.\n计数法证明了其与乘法的对应关系-如果我们将`a`和`b`都設置为`Bool`，则`Mul Bool Bool`类型的可能值为:\n```haskell\nmulValues = [Mul False False, Mul False True, Mul True False, Mul True True]\n```\n有四个值，即`4 = 2 x 2`。这通常称为`product`类型。在`Haskell`中，`product`是`pair`(成對)类型:\n```haskell\ndata (,) a b = (a, b)\n```\n但我会坚持使用`Mul`.\n\n#### 零\n使用加法和乘法，我们可以生成对应于从1到所有数字的类型-但是`0`呢？那将是一个没有值的类型。听起来很奇怪，但是您可以定义这样的类型:\n```haskell\ndata Void\n```\n请注意，数据定义中没有构造函数，因此您永远无法构造`Void`类型的值–它有零個值，正是我们想要的！\n\n### Haskell类型代数中的定律\n我们刚刚定义的类型有哪些定律？就像在数字代数中一样，定律将断言两个`objects`(对象)的相等性-在我们的情况下，`objects`(对象)指类型。\n但是，当谈到`equality`(相等性)时，我并不是指`Haskell`中`(==)`函數意义上的平等。\n相反，我的意思是說两种类型是一一对应的，也就是说，当我说两种类型`a`和`b`相等时，我的意思是您可以编写两个函数:\n```haskell\nfrom :: a -> b\nto   :: b -> a\n```\n将`a`的值与`b`的值配对，因此下面的等式总是成立的(这里的`==`是真正的`haskell`风格的相等):\n```haskell\nto (from a) == a\nfrom (to b) == b\n```\n例如，我认为类型`Bool`和`Add () ()`是等效的。我可以通过以下函数演示相等性:\n```haskell\nto :: Bool -> Add () ()\nto False = AddL ()\nto True  = AddR ()\n\nfrom :: Add () () -> Bool\nfrom (AddL _) = False\nfrom (AddR _) = True\n```\n我将使用三重相等符号`===`来表示类型之间的这种相等性。\n\n#### sum类型定律(和)\n以下是两个补充法则:\n```haskell\nAdd Void a === a\n```\n表示`Add Void a`类型的值与`a`类型的值一样多。\n```haskell\nAdd a b === Add b a\n```\n表示`add`顺序并不重要。在数字代数中，您可能更熟悉这些定律:\n```haskell\n0 + x = x\nx + y = y + x\n```\n如果您喜欢练习，则可以在`Haskell`代数中证明定律的正确性-可以使用计数法，也可以编写函数`from`和`to`.\n\n#### product类型定律(乘积)\n有三个有用的乘法法则:\n```haskell\nMul Void a === Void\n```\n也就是说，如果您将任何东西乘以`Void`，將会得到`Void`，\n```haskell\nMul () a === a\n```\n表示如果您乘以`()`，则不会有任何改变.\n```haskell\nMul a b === Mul b a\n```\n表示乘的顺序無關緊要。这些定律的更常见形式是:\n```haskell\n0 ⋅ x = 0\n1 ⋅ x = x\nx ⋅ y = y ⋅ x\n```\n另外两个练习:\n* 在Haskell代数中证明这些定律的合法性\n* 解释为什么我们不需要以下形式的定律\n```haskell\nMul a Void === Void\nMul a ()   === a\n```\n还有一条定律将加法和乘法运算符联系起来:\n```haskell\nMul a (Add b c) === Add (Mul a b) (Mul a c)\n```\n这一个比较难理解，但是编写相应的`from`和`to`函数并不太难。\n这个法则的算术版本看起来更友好,称为分配律:\n```haskell\na ⋅ ( b + c ) = a ⋅ b + a ⋅ c\n```\n\n#### 函數类型\n在`Haskell`中，除了`Int`和`Bool`这样的具体类型之外，还有`Int - >Bool`或`Double -> String`这样的函数类型，这些是如何融入代数的？\n\n为了弄清楚这一点，我们可以回到计数法。\n有多少`a -> b`类型的函數？\n\n具体来说，将`a`和`b`都設置为`Bool`。\n則值`False`可以映射为`False`或`True`，对于值`True`是同样的，因此有`$2^2$`(2的2次方)个可能的`Bool-> Bool`函数。\n实际上，我们可以列举一下它们:\n```haskell\nf1 :: Bool -> Bool -- equivalent to 'id'\nf1 True  = True\nf1 False = False\n\nf2 :: Bool -> Bool -- equivalent to 'const False'\nf2 _     = False\n\nf3 :: Bool -> Bool -- equivalent to 'const True'\nf3 _     = True\n\nf4 :: Bool -> Bool -- equivalent to 'not'\nf4 True  = False\nf4 False = True\n```\n如果`b`仍然是`Bool`(具有两个值)并且`a`是具有三个值的类型，那会发生什么？\n```haskell\ndata Trio = First | Second | Third\n```\n然后，`First`、`Second`和`Third`中的每一個都可以映射到两个可能的值，总共有`$2^3$`(2的3次方)个类型为`Trio -> Bool`的函数。\n\n同样的论点在一般情况下也成立。如果有`A`类型的值，`B`类型的值，则`A -> B`类型的值的数目为: `$B^A$`(`B的A次方`)\n这证明了函数类型的常用术语为指数类型的.\n\n##### 函數类型定律\n涉及`unit`(单元)类型的函数类型有两条定律, 他们是:\n```haskell\n() -> a === a\n```\n表示函数`() -> a`的数量与类型`a`的值一样多.\n```haskell\na -> () === ()\n```\n表示只有一个`a -> ()`函數, 特别的。它就是: `const ()`. 这些定律的算术形式是:\n![](img/img05.png)\n\n还有一条法律允许从共同参数中提取因式分解:\n```haskell\n(a -> b, a -> c) === a -> (b,c)\n```\n其算术形式为:\n\n![](img/img06.png)\n\n有关返回其他函數的函數的法律:\n```haskell\na -> (b -> c) === (b,a) -> c\n```\n其算术形式为:\n\n![](img/img07.png)\n\n切换右侧部分的变量顺序，同时删除左侧的括号后，最后一个定律可能更熟悉:\n```haskell\na -> b -> c === (a,b) -> c\n```\n也就是说，我们可以使用`curry`和`uncurry`函数。同样，通过编写相应的`to`和`from`函数来证明所有这些定律也是一个有趣的练习。\n\n### 下一篇\n在下一篇文章中，我将研究递归类型，例如列表和二叉树，并展示如何以各种方式滥用类型的代数来推断有关类型的有趣事实。","tags":["Chris Taylor"]},{"title":"Haskell-Categories","url":"/blog/2019/10/16/Haskell-Categories/","content":"> 这是高级部分，编写Haskell通常不需要[范畴](http://dev.stephendiehl.com/hask/#categories)理论知识。\n\n唉，我们来谈谈范畴理论。\n有人可能会说，所有关于`Haskell`的讨论最终都会在某一点上引向这里，然而，范畴理论在`Haskell`语境中的整体重要性被夸大了，不幸的是在某种程度上被迷惑了。\n事实上，直接适用于`Haskell`的范畴理论的数量大致相当于任何本科文本第一章的一个子集。即使这样，使用`Haskell`也不需要真正的范畴理论知识。\n\n\n### Algebraic Relations (代数关系)\n粗略地说，范畴理论对`haskell`编程并不十分重要，尽管一些库从这个主题中获得了一些灵感，但大多数库都没有。\n更重要的是对等式推理有一个全面的了解，并熟悉各种代数关系。\n某些关系出现得如此频繁，以至于我们通常按名称引用它们的属性(通常是从等价的抽象代数概念中提取)。\n考虑一个二元运算(`a 'op' b`)和一元运算`f`.\n```haskell\nAssociativity(结合律)\n\na `op` (b `op` c) = (a `op` b) `op` c\n\nCommutativity(交换律)\n\na `op` b = b `op` a\n\nUnits(单元)\n\na `op` e = a\ne `op` a = a\n\nInversion(反转)\n\n(inv a) `op` a = e\na `op` (inv a) = e\n\nZeros(零点)\n\na `op` e = e\ne `op` a = e\n\nLinearity(线性度)\n\nf (x `op` y) = f x `op` f y\n\nIdempotency(幂等性)\n\nf (f x) = f x\n\nDistributivity(分配律)\n\na `f` (b `g` c) = (a `f` b) `g` (a `f` c)\n(b `g` c) `f` a = (b `f` a) `g` (c `f` a)\n\nAnticommutativity(反交换律)\n\na `op` b = inv (b `op` a)\n```\n当然，这些属性在多个函数上的组合会产生在函数编程中反复出现的高阶关系系统，一旦我们认识到它们，我们就可以对它们进行抽象。\n例如，`monoid`(幺半群)是一个`unit`(单元)和一组值上的单个关联操作的组合。\n```haskell\nStructure(結構)   Notation(符號)\n---------------|-----------------------\nMonoid\t       |  (M, •)\nMonad\t       |  (T, μ, η)\n```\n\n### Categories\n最基本的结构是一个`category`(范畴)，它是`objects`(`Obj`)和`morphisms`(`Hom`)的代数结构，其中`morphisms`(态射)相关联地构成，并且每个对象都具有`identity`(同一性)射态。\n\n启用`kind`(种类)多态性后，我们可以写下由类型变量`c`参数化的类别的一般类别，并写下`Haskell`类型类别的实例`Hask`，并将类型之间的函数作为`morphisms`(态射)。\n\n```haskell\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE TypeSynonymInstances #-}\n\nimport Prelude hiding ((.), id)\n\n-- Morphisms\ntype (a ~> b) c = c a b\n\nclass Category (c :: k -> k -> *) where\n  id :: (a ~> a) c\n  (.) :: (y ~> z) c -> (x ~> y) c -> (x ~> z) c\n\ntype Hask = (->)\n\ninstance Category Hask where\n  id x = x\n  (f . g) x = f (g x)\n```\n\n类别是有趣的，因为它们展示了各种`composition`(组合)属性，以及类别中的各种元素可以组合和重写的方式，同时保留了关于程序的几个不变量。\n\n### Isomorphisms(同构)\n如果我们可以构造具有`2-sided invers`(两面逆)的态射，即将一个對象的结构转换为另一种形式，然后在反转时返回自身，则称该类别的两个对象为同构。\n```haskell\nf  :: a -> b\nf' :: b -> a\n```\n以便:\n```haskell\nf . f' = id\nf'. f  = id\n```\n例如，类型`Either（）a`和`Maybe a`是同构的。\n```haskell\n{-# LANGUAGE ExplicitForAll #-}\n\ndata Iso a b = Iso { to :: a -> b, from :: b -> a }\n\nf :: forall a. Maybe a -> Either () a\nf (Just a) = Right a\nf Nothing  = Left ()\n\nf' :: forall a. Either () a -> Maybe a\nf' (Left _)  = Nothing\nf' (Right a) = Just a\n\niso :: Iso (Maybe a) (Either () a)\niso = Iso f f'\n\ndata V = V deriving Eq\n\nex1 = f  (f' (Right V)) == Right V\nex2 = f' (f  (Just V))  == Just V\ndata Iso a b = Iso { to :: a -> b, from :: b -> a }\n\ninstance Category Iso where\n  id = Iso id id\n  (Iso f f') . (Iso g g') = Iso (f . g) (g' . f')\n```\n\n### Duality(二元性/对偶性)\n中心思想之一是对偶性的概念，即反转某些内部结构会产生带有'镜像'定理的新结构。\n范畴的对偶性反转了`forming`(形成)范畴`C^Op`的态射的方向。\n```haskell\nimport Control.Category\nimport Prelude hiding ((.), id)\n\nnewtype Op a b = Op (b -> a)\n\ninstance Category Op where\n  id = Op id\n  (Op f) . (Op g) = Op (g . f)\n```\n請看:\n* [Duality for Haskellers](http://blog.ezyang.com/2012/10/duality-for-haskellers/)\n\n\n### Functors(函子)\n函子是对象和范畴的`morphisms`(态射)之间的映射，可以保留`identities`(标识)和`composition`(组成)。\n```haskell\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeSynonymInstances #-}\n\nimport Prelude hiding (Functor, fmap, id)\n\nclass (Category c, Category d) => Functor c d t where\n  fmap :: c a b -> d (t a) (t b)\n\ntype Hask = (->)\n\ninstance Category Hask where\n  id x = x\n  (f . g) x = f (g x)\n\ninstance Functor Hask Hask [] where\n  fmap f [] = []\n  fmap f (x:xs) = f x : (fmap f xs)\nfmap id ≡ id\nfmap (a . b) ≡ (fmap a) . (fmap b)\n```\n\n### Natural Transformations(自然变换)\n自然变换是在态射组成顺序`interchange`(交换)下不变的`functor`之间的映射。\n```haskell\ntype Nat f g = forall a. f a -> g a\n```\n这样，对于自然变换`h`，我们有：\n```haskell\nfmap f . h ≡ h . fmap f\n```\n最简单的例子是在`(f = List)`和`(g = Maybe)`类型之间。\n```haskell\nheadMay :: forall a. [a] -> Maybe a\nheadMay []     = Nothing\nheadMay (x:xs) = Just x\n```\n不管我们如何`chase`(追求)`safeHead`，我们最终都会得到相同的结果。\n```haskell\nfmap f (headMay xs) ≡ headMay (fmap f xs)\nfmap f (headMay [])\n= fmap f Nothing\n= Nothing\n\nheadMay (fmap f [])\n= headMay []\n= Nothing\nfmap f (headMay (x:xs))\n= fmap f (Just x)\n= Just (f x)\n\nheadMay (fmap f (x:xs))\n= headMay [f x]\n= Just (f x)\n```\n或考虑函子`(->)`.\n```haskell\nf :: (Functor t)\n  => (->) a b\n  -> (->) (t a) (t b)\nf = fmap\n\ng :: (b -> c)\n  -> (->) a b\n  -> (->) a c\ng = (.)\n\nc :: (Functor t)\n  => (b -> c)\n  -> (->) (t a) (t b)\n  -> (->) (t a) (t c)\nc = f . g\nf . g x = c x . g\n```\n`Haskell`类型的许多表达能力来自有趣的事实，即有一些注意事项，多态`Haskell`函数是自然变换。\n請看:\n* [You Could Have Defined Natural Transformations](http://blog.sigfpe.com/2008/05/you-could-have-defined-natural.html)\n\n### Yoneda Lemma\n`Yoneda`引理是范畴论中的一个基本而深刻的结果。\n`Yoneda`引理指出，对于任何函子`F`，类型`F a`和`∀ b. (a -> b) -> F b`是同构的。\n```haskell\n{-# LANGUAGE RankNTypes #-}\n\nembed :: Functor f => f a -> (forall b . (a -> b) -> f b)\nembed x f = fmap f x\n\nunembed :: Functor f => (forall b . (a -> b) -> f b) -> f a\nunembed f = f id\n```\n这样我们就可以:\n```haskell\nembed . unembed ≡ id\nunembed . embed ≡ id\n```\n\n这个定理最宽泛的表述是，一个范畴中的一个对象可以用它的一组态射来表示，仅这些态射的信息就足以决定对象本身的所有性质。\n\n对于`Haskell`类型，给定一个固定类型`a`和一个函子`f`，如果我们有一个更高阶的多态函数`g`，当给定一个类型`a -> b`的函数产生`f b`时，那么`g`行为完全由`a -> b`决定，`g`的行为完全可以用`f a`来写。\n\n\n#### Continuation Passing(连续传递)\n> TODO\n\n請看:\n* [Reason Isomorphically](https://www.cs.ox.ac.uk/ralf.hinze/publications/WGP10.pdf)\n* [The Continuation Passing Transform and the Yoneda Embedding](https://golem.ph.utexas.edu/category/2008/01/the_continuation_passing_trans.html)\n* [Yoneda is CPS](https://github.com/manzyuk/blog/blob/master/yoneda-embedding-is-cps.org)\n\n#### Double-negated principle of excluded middle(排除中间的双重否定原则)\n> TODO\n\n請看:\n* [Reverse Engineering Machines with the Yoneda Lemma](http://blog.sigfpe.com/2006/11/yoneda-lemma.html)\n\n### Kleisli Category\n`Kleisli`組成(即`Kleisli FIsh`)定义为:\n```haskell\n(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c\nf >=> g ≡ \\x -> f x >>= g\n\n(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c\n(<=<) = flip (>=>)\n```\n用一個`monad m`的`Kleisli`范畴表示的单子律被更`symmetrically`(对称)地表述为一个`associativity`(关联)律和两个`identity`(同一)律。\n```haskell\n(f >=> g) >=> h ≡ f >=> (g >=> h)\nreturn >=> f ≡ f\nf >=> return ≡  f\n```\n简单地说，上述单子法则只是`Kleisli`类别中的类别法则。\n```haskell\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE ExplicitForAll #-}\n\nimport Control.Monad\nimport Control.Category\nimport Prelude hiding ((.))\n\n-- Kleisli category\nnewtype Kleisli m a b = K (a -> m b)\n\n-- Kleisli morphisms ( a -> m b )\ntype (a :~> b) m = Kleisli m a b\n\ninstance Monad m => Category (Kleisli m) where\n  id            = K return\n  (K f) . (K g) = K (f <=< g)\n\n\njust :: (a :~> a) Maybe\njust = K Just\n\nleft :: forall a b. (a :~> b) Maybe -> (a :~> b) Maybe\nleft f = just . f\n\nright :: forall a b. (a :~> b) Maybe -> (a :~> b) Maybe\nright f = f . just\n```\n例如，`Just`只是`Maybe`单子的`Kleisli`类别中的一个`identity`(身份)`morphism`(同态)。\n```haskell\nJust >=> f ≡ f\nf >=> Just ≡ f\n```\n\n### Adjunctions\n> TODO\n\n### Cartesian Closed Categories\n> TODO\n\n### Monoidal Categories\n在一個`symmetric monoidal closed category`(单项封闭类别)中，例如`lambda`演算\n\n### Resources\n\n* [Category Theory, Awodey](http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182)\n* [Category Theory Foundations](https://www.youtube.com/watch?v=ZKmodCApZwk)\n* [Category Theory for Programmers](https://www.youtube.com/watch?v=I8LbkfSSR58&list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_)\n* [The Catsters](http://www.youtube.com/user/TheCatsters)","tags":["Categories"]},{"title":"Haskell-Applicatives","url":"/blog/2019/10/16/Haskell-Applicatives/","content":"> [原文](http://dev.stephendiehl.com/hask/#applicatives)\n\n像`monads`一样，`Applicatives`是泛函上位于`functors`(函子)和`monad`之间的各种计算的抽象结构。\n```haskell\npure :: Applicative f => a -> f a\n(<$>) :: Functor f => (a -> b) -> f a -> f b\n(<*>) :: f (a -> b) -> f a -> f b\n```\n自`GHC 7.6`起，`Applicative`定义为:\n```haskell\nclass Functor f => Applicative f where\n  pure :: a -> f a\n  (<*>) :: f (a -> b) -> f a -> f b\n\n(<$>) :: Functor f => (a -> b) -> f a -> f b\n(<$>) = fmap\n```\n`Applicative`具有以下法律:\n```haskell\npure id <*> v = v\npure f <*> pure x = pure (f x)\nu <*> pure y = pure ($ y) <*> u\nu <*> (v <*> w) = pure (.) <*> u <*> v <*> w\n```\n例如，考虑`Maybe`的实例：\n```haskell\ninstance Applicative Maybe where\n  pure              = Just\n  Nothing <*> _     = Nothing\n  _ <*> Nothing     = Nothing\n  Just f <*> Just x = Just (f x)\n```\n根据经验，只要我们使用`m >>= return . f`我们可能想要的是`applicative functor`(应用函子)，而不是`monad`(单子)函数。\n```haskell\nimport Network.HTTP\nimport Control.Applicative ((<$>),(<*>))\n\nexample1 :: Maybe Integer\nexample1 = (+) <$> m1 <*> m2\n  where\n    m1 = Just 3\n    m2 = Nothing\n-- Nothing\n\nexample2 :: [(Int, Int, Int)]\nexample2 = (,,) <$> m1 <*> m2 <*> m3\n  where\n    m1 = [1,2]\n    m2 = [10,20]\n    m3 = [100,200]\n-- [(1,10,100),(1,10,200),(1,20,100),(1,20,200),(2,10,100),(2,10,200),(2,20,100),(2,20,200)]\n\nexample3 :: IO String\nexample3 = (++) <$> fetch1 <*> fetch2\n  where\n    fetch1 = simpleHTTP (getRequest \"http://www.fpcomplete.com/\") >>= getResponseBody\n    fetch2 = simpleHTTP (getRequest \"http://www.haskell.org/\") >>= getResponseBody\n```\n模式`f <$> a <*> b ...`出現的频率很高，以至于有一系列函数可以提升固定数量参数的`applicative`。这种模式也经常出现在`monads`(`liftM`，`liftM2`，`liftM3`)上。\n```haskell\nliftA :: Applicative f => (a -> b) -> f a -> f b\nliftA f a = pure f <*> a\n\nliftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c\nliftA2 f a b = f <$> a <*> b\n\nliftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\nliftA3 f a b c = f <$> a <*> b <*> c\n```\n`Applicative`还具有`*>`和`<*`函数,它們在放弃其中一个参数的值的同时`sequence applicative actions`。\n运算符`*>`舍弃左侧，而`<*`舍弃右侧。例如，在一元解析器组合器库中，`*>`将使用第一个解析器参数解析，但返回第二个。\n`Applicative`函数`<$>`和`<*>`由`monad`的`liftM`和`ap`概括。\n\n```haskell\nimport Control.Monad\nimport Control.Applicative\n\ndata C a b = C a b\n\nmnd :: Monad m => m a -> m b -> m (C a b)\nmnd a b = C `liftM` a `ap` b\n\napl :: Applicative f => f a -> f b -> f (C a b)\napl a b = C <$> a <*> b\n```\n\n請看: [Applicative Programming with Effects](http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf)\n\n### Alternative\n`Alternative`是`Applicative`类的一个扩展，它有一个零元素和一个与零相关的二进制操作。\n```haskell\nclass Applicative f => Alternative f where\n  -- | The identity of '<|>'\n  empty :: f a\n  -- | An associative binary operation\n  (<|>) :: f a -> f a -> f a\n  -- | One or more.\n  some :: f a -> f [a]\n  -- | Zero or more.\n  many :: f a -> f [a]\n\noptional :: Alternative f => f a -> f (Maybe a)\n\nwhen :: (Alternative f) => Bool -> f () -> f ()\nwhen p s = if p then s else return ()\n\nguard :: (Alternative f) => Bool -> f ()\nguard True  = pure ()\nguard False = mzero\ninstance Alternative Maybe where\n    empty = Nothing\n    Nothing <|> r = r\n    l       <|> _ = l\n\ninstance Alternative [] where\n    empty = []\n    (<|>) = (++)\nλ: foldl1 (<|>) [Nothing, Just 5, Just 3]\nJust 5\n```\n这些实例经常出现在解析器中，在解析器中，`alternative`运算符可以对`alternative`(可選擇的)解析分支建模。\n\n### Arrows\n`category`(范畴)是一种代数结构，它包括一个`identity`的概念和一个`associative`(结合)并`preserves`(保留/保存/维护)`identity`的组合操作。\n```haskell\nclass Category cat where\n  id :: cat a a\n  (.) :: cat b c -> cat a b -> cat a c\ninstance Category (->) where\n  id = Prelude.id\n  (.) = (Prelude..)\n(<<<) :: Category cat => cat b c -> cat a b -> cat a c\n(<<<) = (.)\n\n(>>>) :: Category cat => cat a b -> cat b c -> cat a c\nf >>> g = g . f\n```\n`Arrows`(箭头)是一個具有`products`(产品)概念的`categories`(范畴)的`extension`(延伸)。\n```haskell\nclass Category a => Arrow a where\n  arr :: (b -> c) -> a b c\n  first :: a b c -> a (b,d) (c,d)\n  second :: a b c -> a (d,b) (d,c)\n  (***) :: a b c -> a b' c' -> a (b,b') (c,c')\n  (&&&) :: a b c -> a b c' -> a b (c,c')\n```\n典型的例子是`functions`(函数)。\n```haskell\ninstance Arrow (->) where\n  arr f = f\n  first f = f *** id\n  second f = id *** f\n  (***) f g ~(x,y) = (f x, g y)\n```\n在这种形式中，多个参数的函数可以使用箭头组合符以更`point-free`的形式來實現。\n例如，`histogram`(直方图)函数具有很好的`one-liner`(单线)。\n```haskell\nimport Data.List (group, sort)\n\nhistogram :: Ord a => [a] -> [(a, Int)]\nhistogram = map (head &&& length) . group . sort\nλ: histogram \"Hello world\"\n[(' ',1),('H',1),('d',1),('e',1),('l',3),('o',2),('r',1),('w',1)]\n```\n#### Arrow notation (Arrow表示法)\n`GHC`有内置的语法使用`proc`表示法组合`arrows`(箭头)。在脫糖后，下列各项等效：\n```haskell\n{-# LANGUAGE Arrows #-}\n\naddA :: Arrow a => a b Int -> a b Int -> a b Int\naddA f g = proc x -> do\n                y <- f -< x\n                z <- g -< x\n                returnA -< y + z\naddA f g = arr (\\ x -> (x, x)) >>>\n           first f >>> arr (\\ (y, x) -> (x, y)) >>>\n           first g >>> arr (\\ (z, y) -> y + z)\naddA f g = f &&& g >>> arr (\\ (y, z) -> y + z)\n```\n实际上，这种符号并不经常使用，将来可能会被弃用。\n\n請看: [Arrow Notation](https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/arrow-notation.html)\n\n### Bifunctors\n`Bifunctors`是`functors`(函子)的一个`generalization`(推广/归纳)，它包含由两个参数参数化的类型，并且每个参数包含两个`map`函数。\n```haskell\nclass Bifunctor p where\n  bimap :: (a -> b) -> (c -> d) -> p a c -> p b d\n  first :: (a -> b) -> p a c -> p b c\n  second :: (b -> c) -> p a b -> p a c\n```\n`bifunctor`定律是`usual functor`(一般函子)的自然推广。也就是说，他们以`usual`(通常)的方式`respect`(遵守)`identities`(身份)和`composition`(构成):\n```haskell\nbimap id id ≡ id\nfirst id ≡ id\nsecond id ≡ id\nbimap f g ≡ first f . second g\n```\n典型的例子是`2-tuples`(2元组)。\n```haskell\nλ: first (+1) (1,2)\n(2,2)\nλ: second (+1) (1,2)\n(1,3)\nλ: bimap (+1) (+1) (1,2)\n(2,3)\n\nλ: first (+1) (Left 3)\nLeft 4\nλ: second (+1) (Left 3)\nLeft 3\nλ: second (+1) (Right 3)\nRight 4\n```\n\n### Polyvariadic Functions (多元函數)\n类型类的一个令人惊讶的应用是: 通过在函数类型上定义`instances`(实例)来构造接受任意数量参数的函数的能力。\n参数可以是任意类型，但是结果收集的参数必须转换为`single`(单一)类型或解包为`sum`类型。\n\n```haskell\n{-# LANGUAGE FlexibleInstances #-}\n\nclass Arg a where\n  collect' :: [String] -> a\n\n-- extract to IO\ninstance Arg (IO ()) where\n  collect' acc = mapM_ putStrLn acc\n\n-- extract to [String]\ninstance Arg [String] where\n  collect' acc = acc\n\ninstance (Show a, Arg r) => Arg (a -> r) where\n  collect' acc = \\x -> collect' (acc ++ [show x])\n\ncollect :: Arg t => t\ncollect = collect' []\n\nexample1 :: [String]\nexample1 = collect 'a' 2 3.0\n\nexample2 :: IO ()\nexample2 = collect () \"foo\" [1,2,3]\n```\n\n請看: [Polyvariadic functions](http://okmij.org/ftp/Haskell/polyvariadic.html)","tags":["Haskell"]},{"title":"Haskell-Advanced-Monads","url":"/blog/2019/10/16/Haskell-Advanced-Monads/","content":"> [原文](http://dev.stephendiehl.com/hask/#advanced-monads)\n\n### Function Monad\n如果一个人写了`Haskell`足够长的时间，他可能最终会遇到奇怪的野兽，即(`(->) r`)的`monad`实例。使用它通常不太直观，但是当人们认为它是未包装的`Reader monad`时，它非常简单。\n```haskell\ninstance Functor ((->) r) where\n  fmap = (.)\n\ninstance Monad ((->) r) where\n  return = const\n  f >>= k = \\r -> k (f r) r\n```\n这仅使用`arrow`(箭头)类型运算符的前缀形式。\n```haskell\nimport Control.Monad\n\nid' :: (->) a a\nid' = id\n\nconst' :: (->) a ((->) b a)\nconst' = const\n\n-- Monad m => a -> m a\nfret :: a -> b -> a\nfret = return\n\n-- Monad m => m a -> (a -> m b) -> m b\nfbind :: (r -> a) -> (a -> (r -> b)) -> (r -> b)\nfbind f k = f >>= k\n\n-- Monad m => m (m a) -> m a\nfjoin :: (r -> (r -> a)) -> (r -> a)\nfjoin = join\n\nfid :: a -> a\nfid = const >>= id\n\n-- Functor f => (a -> b) -> f a -> f b\nfcompose :: (a -> b) -> (r -> a) -> (r -> b)\nfcompose = (.)\ntype Reader r = (->) r -- pseudocode\n\ninstance Monad (Reader r) where\n  return a = \\_ -> a\n  f >>= k = \\r -> k (f r) r\n\nask' :: r -> r\nask' = id\n\nasks' :: (r -> a) -> (r -> a)\nasks' f = id . f\n\nrunReader' :: (r -> a) -> r -> a\nrunReader' = id\n```\n\n### RWS Monad\n`RWS monad`结合了以上讨论的三个`monad`的功能，即`Reader`，`Writer`和`State`。还有一个`RWST transformer`。\n```haskell\nrunReader :: Reader r a -> r -> a\nrunWriter :: Writer w a -> (a, w)\nrunState  :: State s a -> s -> (a, s)\n```\n这三个评估函数现在合并为以下函数:\n```haskell\nrunRWS  :: RWS r w s a -> r -> s -> (a, s, w)\nexecRWS :: RWS r w s a -> r -> s -> (s, w)\nevalRWS :: RWS r w s a -> r -> s -> (a, w)\nimport Control.Monad.RWS\n\ntype R = Int\ntype W = [Int]\ntype S = Int\n\ncomputation :: RWS R W S ()\ncomputation = do\n  e <- ask\n  a <- get\n  let b = a + e\n  put b\n  tell [b]\n\nexample = runRWS computation 2 3\n```\n关于`Writer laziness`的常见警告也适用于`RWS`.\n\n### Cont\n```haskell\nrunCont :: Cont r a -> (a -> r) -> r\ncallCC :: MonadCont m => ((a -> m b) -> m a) -> m a\ncont :: ((a -> r) -> r) -> Cont r a\n```\n在`continuation-passing`(连续传递)样式中，复合计算是由嵌套计算序列构成的，嵌套计算序列以`final continuation`(连续)结束，`final continuation`通过将函数传递到`continuation`链中而产生完整计算的结果。\n```haskell\nadd :: Int -> Int -> Int\nadd x y = x + y\n\nadd :: Int -> Int -> (Int -> r) -> r\nadd x y k = k (x + y)\nimport Control.Monad\nimport Control.Monad.Cont\n\nadd :: Int -> Int -> Cont k Int\nadd x y = return $ x + y\n\nmult :: Int -> Int -> Cont k Int\nmult x y = return $ x * y\n\ncontt :: ContT () IO ()\ncontt = do\n    k <- do\n      callCC $ \\exit -> do\n        lift $ putStrLn \"Entry\"\n        exit $ \\_ -> do\n          putStrLn \"Exit\"\n    lift $ putStrLn \"Inside\"\n    lift $ k ()\n\ncallcc :: Cont String Integer\ncallcc = do\n  a <- return 1\n  b <- callCC (\\k -> k 2)\n  return $ a+b\n\nex1 :: IO ()\nex1 = print $ runCont (f >>= g) id\n  where\n    f = add 1 2\n    g = mult 3\n-- 9\n\nex2 :: IO ()\nex2 = print $ runCont callcc show\n-- \"3\"\n\nex3 :: IO ()\nex3 = runContT contt print\n-- Entry\n-- Inside\n-- Exit\n\nmain :: IO ()\nmain = do\n  ex1\n  ex2\n  ex3\nnewtype Cont r a = Cont { runCont :: ((a -> r) -> r) }\n\ninstance Monad (Cont r) where\n  return a       = Cont $ \\k -> k a\n  (Cont c) >>= f = Cont $ \\k -> c (\\a -> runCont (f a) k)\n\nclass (Monad m) => MonadCont m where\n  callCC :: ((a -> m b) -> m a) -> m a\n\ninstance MonadCont (Cont r) where\n  callCC f = Cont $ \\k -> runCont (f (\\a -> Cont $ \\_ -> k a)) k\n```\n請看:\n    [Wikibooks: Continuation Passing Style](http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style)\n    [MonadCont Under the Hood](https://wiki.haskell.org/MonadCont_under_the_hood)\n\n### MonadPlus\n选择与失败.\n```haskell\nclass (Alternative m, Monad m) => MonadPlus m where\n   mzero :: m a\n   mplus :: m a -> m a -> m a\n\ninstance MonadPlus [] where\n   mzero = []\n   mplus = (++)\n\ninstance MonadPlus Maybe where\n   mzero = Nothing\n\n   Nothing `mplus` ys  = ys\n   xs      `mplus` _ys = xs\n```\n`MonadPlus forms a monoid with`\n```haskell\nmzero `mplus` a = a\na `mplus` mzero = a\n(a `mplus` b) `mplus` c = a `mplus` (b `mplus` c)\nasum :: (Foldable t, Alternative f) => t (f a) -> f a\nasum = foldr (<|>) empty\n\nmsum :: (Foldable t, MonadPlus m) => t (m a) -> m a\nmsum = asum\nimport Safe\nimport Control.Monad\n\nlist1 :: [(Int,Int)]\nlist1 = [(a,b) | a <- [1..25], b <- [1..25], a < b]\n\nlist2 :: [(Int,Int)]\nlist2 = do\n  a <- [1..25]\n  b <- [1..25]\n  guard (a < b)\n  return $ (a,b)\n\nmaybe1 :: String -> String -> Maybe Double\nmaybe1 a b = do\n  a' <- readMay a\n  b' <- readMay b\n  guard (b' /= 0.0)\n  return $ a'/b'\n\nmaybe2 :: Maybe Int\nmaybe2 = msum [Nothing, Nothing, Just 3, Just 4]\nimport Control.Monad\n\nrange :: MonadPlus m => [a] -> m a\nrange [] = mzero\nrange (x:xs) = range xs `mplus` return x\n\npyth :: Integer -> [(Integer,Integer,Integer)]\npyth n = do\n  x <- range [1..n]\n  y <- range [1..n]\n  z <- range [1..n]\n  if x*x + y*y == z*z then return (x,y,z) else mzero\n\nmain :: IO ()\nmain = print $ pyth 15\n{-\n[ ( 12 , 9 , 15 )\n, ( 12 , 5 , 13 )\n, ( 9 , 12 , 15 )\n, ( 8 , 6 , 10 )\n, ( 6 , 8 , 10 )\n, ( 5 , 12 , 13 )\n, ( 4 , 3 , 5 )\n, ( 3 , 4 , 5 )\n]\n-}\n```\n\n### MonadFix\n`monadic`计算的`fixed`(固定)点。`mfix f`仅执行一次`f`动作，最终的输出作为输入被反馈。\n```haskell\nfix :: (a -> a) -> a\nfix f = let x = f x in x\n\nmfix :: (a -> m a) -> m a\nclass Monad m => MonadFix m where\n   mfix :: (a -> m a) -> m a\n\ninstance MonadFix Maybe where\n   mfix f = let a = f (unJust a) in a\n            where unJust (Just x) = x\n                  unJust Nothing  = error \"mfix Maybe: Nothing\"\n```\n常规的`do-notation`也可以通过`-XRecursiveDo`扩展，以适应递归`monadic`绑定。\n```haskell\n{-# LANGUAGE RecursiveDo #-}\n\nimport Control.Applicative\nimport Control.Monad.Fix\n\nstream1 :: Maybe [Int]\nstream1 = do\n  rec xs <- Just (1:xs)\n  return (map negate xs)\n\nstream2 :: Maybe [Int]\nstream2 = mfix $ \\xs -> do\n  xs' <- Just (1:xs)\n  return (map negate xs')\n```\ns\n### ST Monad\n`ST monad`为有状态计算的`threads`建模，这些`threads`可以操作可变引用，但在计算时仅限于返回`pure`(纯)值，并且静态地限制在`s`线程的`ST monad`中。\n```haskell\nrunST :: (forall s. ST s a) -> a\nnewSTRef :: a -> ST s (STRef s a)\nreadSTRef :: STRef s a -> ST s a\nwriteSTRef :: STRef s a -> a -> ST s ()\nimport Data.STRef\nimport Control.Monad\nimport Control.Monad.ST\nimport Control.Monad.State.Strict\n\nexample1 :: Int\nexample1 = runST $ do\n  x <- newSTRef 0\n\n  forM_ [1..1000] $ \\j -> do\n    writeSTRef x j\n\n  readSTRef x\n\nexample2 :: Int\nexample2 = runST $ do\n  count <- newSTRef 0\n  replicateM_ (10^6) $ modifySTRef' count (+1)\n  readSTRef count\n\nexample3 :: Int\nexample3 = flip evalState 0 $ do\n  replicateM_ (10^6) $ modify' (+1)\n  get\n\nmodify' :: MonadState a m => (a -> a) -> m ()\nmodify' f = get >>= (\\x -> put $! f x)\n```\n使用`ST monad`，我们可以创建一类有效的纯函數数据结构，该结构以引用透明的方式使用可变引用。\n\n### Free Monads\n```haskell\nPure :: a -> Free f a\nFree :: f (Free f a) -> Free f a\n\nliftF :: (Functor f, MonadFree f m) => f a -> m a\nretract :: Monad f => Free f a -> f a\n```\n`Free monad`是一个`monad`，它不具有`combines`(结合)计算的`join`操作，而是从`functor`(函子)的`application`(应用)中形成`composite`(复合)计算。\n```haskell\njoin :: Monad m => m (m a) -> m a\nwrap :: MonadFree f m => f (m a) -> m a\n```\n最好的例子之一是`Partiality monad`，它对可以分散的计算进行建模。`Haskell`允许无限制的递归，但是例如，我们可以从`Maybe functor`(函子)创建一个`Free monad`，该`monad`可用于固定调用深度，例如[Ackermann函数](https://en.wikipedia.org/wiki/Ackermann_function)。\n```haskell\nimport Control.Monad.Fix\nimport Control.Monad.Free\n\ntype Partiality a = Free Maybe a\n\n-- Non-termination.\nnever :: Partiality a\nnever = fix (Free . Just)\n\nfromMaybe :: Maybe a -> Partiality a\nfromMaybe (Just x) = Pure x\nfromMaybe Nothing = Free Nothing\n\nrunPartiality :: Int -> Partiality a -> Maybe a\nrunPartiality 0 _ = Nothing\nrunPartiality _ (Pure a) = Just a\nrunPartiality _ (Free Nothing) = Nothing\nrunPartiality n (Free (Just a)) = runPartiality (n-1) a\n\nack :: Int -> Int -> Partiality Int\nack 0 n = Pure $ n + 1\nack m 0 = Free $ Just $ ack (m-1) 1\nack m n = Free $ Just $ ack m (n-1) >>= ack (m-1)\n\nmain :: IO ()\nmain = do\n  let diverge = never :: Partiality ()\n  print $ runPartiality 1000 diverge\n  print $ runPartiality 1000 (ack 3 4)\n  print $ runPartiality 5500 (ack 3 4)\n```\n\n`Free monad`的另一个常见用途是构建嵌入式领域特定的语言来描述计算。\n我们可以通过在`IOFree`单子内部建立对计算的纯描述，然后使用`free monad`将转换编码为`effectful`(有效)的`IO`计算，来对`IO monad`的子集建模。\n```haskell\n{-# LANGUAGE DeriveFunctor #-}\n\nimport System.Exit\nimport Control.Monad.Free\n\ndata Interaction x\n  = Puts String x\n  | Gets (Char -> x)\n  | Exit\n  deriving Functor\n\ntype IOFree a = Free Interaction a\n\nputs :: String -> IOFree ()\nputs s = liftF $ Puts s ()\n\nget :: IOFree Char\nget = liftF $ Gets id\n\nexit :: IOFree r\nexit = liftF Exit\n\ngets :: IOFree String\ngets = do\n  c <- get\n  if c == '\\n'\n    then return \"\"\n    else gets >>= \\line -> return (c : line)\n\n-- Collapse our IOFree DSL into IO monad actions.\n-- 将我们的IOFree DSL折叠为IO monad操作。\ninterp :: IOFree a -> IO a\ninterp (Pure r) = return r\ninterp (Free x) = case x of\n  Puts s t -> putStrLn s >> interp t\n  Gets f   -> getChar >>= interp . f\n  Exit     -> exitSuccess\n\necho :: IOFree ()\necho = do\n  puts \"Enter your name:\"\n  str <- gets\n  puts str\n  if length str > 10\n    then puts \"You have a long name.\"\n    else puts \"You have a short name.\"\n  exit\n\nmain :: IO ()\nmain = interp echo\n```\n诸如[free](http://hackage.haskell.org/package/free)中的实现的实现可能如下所示:\n```haskell\n{-# LANGUAGE MultiParamTypeClasses #-}\n\nimport Control.Applicative\n\ndata Free f a\n  = Pure a\n  | Free (f (Free f a))\n\ninstance Functor f => Monad (Free f) where\n  return a     = Pure a\n  Pure a >>= f = f a\n  Free f >>= g = Free (fmap (>>= g) f)\n\nclass Monad m => MonadFree f m  where\n  wrap :: f (m a) -> m a\n\nliftF :: (Functor f, MonadFree f m) => f a -> m a\nliftF = wrap . fmap return\n\niter :: Functor f => (f a -> a) -> Free f a -> a\niter _ (Pure a) = a\niter phi (Free m) = phi (iter phi <$> m)\n\nretract :: Monad f => Free f a -> f a\nretract (Pure a) = return a\nretract (Free as) = as >>= retract\n```\n\n請看:\n    [Monads for Free!](http://www.andres-loeh.de/Free.pdf)\n    [I/O is not a Monad](http://r6.ca/blog/20110520T220201Z.html)\n\n### Indexed Monads\n`Indexed monad`是`monad`的概括，它向类添加了附加的类型参数，该参数携带有关`monadic implementation`的计算或结构的信息。\n```haskell\nclass IxMonad md where\n  return :: a -> md i i a\n  (>>=) :: md i m a -> (a -> md m o b) -> md i o b\n```\n`canonical`(规范)用例是`vanilla`状态的一种变体，它允许在`monad`内部的中间步骤的状态上进行类型更改。\n实际上，这对于处理涉及资源管理的一类问题非常有用，因为额外的索引参数为我们提供了空间，可以通过在编译时允许和限制索引参数上的某些状态转换来静态执行`monadic`动作序列。\n为了使它更有用，我们将使用比较深奥的`-XRebindableSyntax`，通过提供模块本地的替代定义，使我们可以重载`do-notation`和`if-then-else`语法。\n```haskell\n{-# LANGUAGE RebindableSyntax #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE NoMonomorphismRestriction #-}\n\nimport Data.IORef\nimport Data.Char\nimport Prelude hiding (fmap, (>>=), (>>), return)\nimport Control.Applicative\n\nnewtype IState i o a = IState { runIState :: i -> (a, o) }\n\nevalIState :: IState i o a -> i -> a\nevalIState st i = fst $ runIState st i\n\nexecIState :: IState i o a -> i -> o\nexecIState st i = snd $ runIState st i\n\nifThenElse :: Bool -> a -> a -> a\nifThenElse b i j = case b of\n  True -> i\n  False -> j\n\nreturn :: a -> IState s s a\nreturn a = IState $ \\s -> (a, s)\n\nfmap :: (a -> b) -> IState i o a -> IState i o b\nfmap f v = IState $ \\i -> let (a, o) = runIState v i\n                          in (f a, o)\n\njoin :: IState i m (IState m o a) -> IState i o a\njoin v = IState $ \\i -> let (w, m) = runIState v i\n                        in runIState w m\n\n(>>=) :: IState i m a -> (a -> IState m o b) -> IState i o b\nv >>= f = IState $ \\i -> let (a, m) = runIState v i\n                         in runIState (f a) m\n\n(>>) :: IState i m a -> IState m o b -> IState i o b\nv >> w = v >>= \\_ -> w\n\nget :: IState s s s\nget = IState $ \\s -> (s, s)\n\ngets :: (a -> o) -> IState a o a\ngets f = IState $ \\s -> (s, f s)\n\nput :: o -> IState i o ()\nput o = IState $ \\_ -> ((), o)\n\nmodify :: (i -> o) -> IState i o ()\nmodify f = IState $ \\i -> ((), f i)\n\n\n\ndata Locked = Locked\ndata Unlocked = Unlocked\n\ntype Stateful a = IState a Unlocked a\n\nacquire :: IState i Locked ()\nacquire = put Locked\n\n-- Can only release the lock if it's held, try release the lock\n-- that's not held is a now a type error.\nrelease :: IState Locked Unlocked ()\nrelease = put Unlocked\n\n-- Statically forbids improper handling of resources.\nlockExample :: Stateful a\nlockExample = do\n  ptr <- get  :: IState a a a\n  acquire     :: IState a Locked ()\n  -- ...\n  release     :: IState Locked Unlocked ()\n  return ptr\n\n-- Couldn't match type `Locked' with `Unlocked'\n-- In a stmt of a 'do' block: return ptr\nfailure1 :: Stateful a\nfailure1 = do\n  ptr <- get\n  acquire\n  return ptr -- didn't release\n\n-- Couldn't match type `a' with `Locked'\n-- In a stmt of a 'do' block: release\nfailure2 :: Stateful a\nfailure2 = do\n  ptr <- get\n  release -- didn't acquire\n  return ptr\n\n-- Evaluate the resulting state, statically ensuring that the\n-- lock is released when finished.\nevalReleased :: IState i Unlocked a -> i -> a\nevalReleased f st = evalIState f st\n\nexample :: IO (IORef Integer)\nexample = evalReleased <$> pure lockExample <*> newIORef 0\n```\n請看: [Fun with Indexed monads](http://www.cl.cam.ac.uk/~dao29/ixmonad/ixmonad-fita14.pdf)\n\n### lifted-base\n\n默认的`prelude`早于`monad transformers`上的许多工作.\n因此，用于处理错误和与`IO`交互的许多常用功能严格地绑定到`IO monad`，而不是绑定到在`IO`或`ST`之上实现堆栈的函數。\n\n`lifted-base`提供了通用的控制操作，例如可以从`IO`或任何其他基础`monad`提升的`catch`。\n\n#### monad-base\n`Monad base`提供了`liftIO`和其他功能的抽象，以明确提升到转换器堆栈的`privileged`(特权)层。\n它使用`base monad`作为参数`b`实现了多参数类型类。\n```haskell\n-- | Lift a computation from the base monad\nclass (Applicative b, Applicative m, Monad b, Monad m)\n      => MonadBase b m | m -> b where\n  liftBase ∷ b a -> m a\n```\n\n#### monad-control\n\n`Monad control`建立在`monad-base`之上，扩展了`lifting`操作以控制诸如`catch`和`bracket`之类的操作，可以用任何支持这些操作的基础层的变压器来通用地编写.\n然后，`Generic operations`(泛型操作)可以用`MonadBaseControl`表示，并可以用组合器`control`来編寫，该组合器处理`bracket`和自动处理`lifting`.\n```haskell\ncontrol :: MonadBaseControl b m => (RunInBase m b -> b (StM m a)) -> m a\n```\n例如，通常由`Control.Exception`提供的`catch`函数被锁定在`IO`中:\n```haskell\ncatch :: Exception e => IO a -> (e -> IO a) -> IO a\n```\n通过使用`control`来组合它，我们可以构造一个通用版本，它可以自动`lift`(提升)到具有`Monadbasecontrol`实例的常用变压器堆栈的任何组合中.\n```haskell\ncatch\n  :: (MonadBaseControl IO m, Exception e)\n  => m a        -- ^ Computation\n  -> (e -> m a) -- ^ Handler\n  -> m a\ncatch a handler = control $ \\runInIO ->\n                    E.catch (runInIO a)\n                            (\\e -> runInIO $ handler e)\n```","tags":["Advanced-Monads"]},{"title":"Haskell-Monad-Transformers","url":"/blog/2019/10/16/Haskell-Monad-Transformers/","content":"> [原文](http://dev.stephendiehl.com/hask/#monad-transformers)\n\n### mtl / transformers\n所以，前一章对`Monads`的描述有点不可信。现代的`Haskell monad`库通常使用一种更通用的形式，用`monad transformers`来编写，它允许我们将`monad`合在一起形成复合`monad`。前面提到的`monad`被包含在由`Identity`单子组成的`transformer`形式的特例中。\n```haskell\nMonad\t| Transformer  |  Type\t      |  Transformed Type\n--------|--------------|--------------|---------------------\nMaybe\t| MaybeT\t   |  Maybe a\t  |  m (Maybe a)\nReader\t| ReaderT\t   |  r -> a\t  |  r -> m a\nWriter\t| WriterT\t   |  (a,w)\t      |  m (a,w)\nState\t| StateT\t   |  s -> (a,s)  |\t s -> m (a,s)\n```\n```haskell\ntype State  s = StateT  s Identity\ntype Writer w = WriterT w Identity\ntype Reader r = ReaderT r Identity\n\ninstance Monad m => MonadState s (StateT s m)\ninstance Monad m => MonadReader r (ReaderT r m)\ninstance (Monoid w, Monad m) => MonadWriter w (WriterT w m)\n```\n就通用性而言，`mtl`库是这些`monad`最常见的通用接口，它本身依赖于`transformers`库，该库将上述基本`monad`概括为`transformers`.\n\n### Transformers\n`monad transformers`的核心是使我们能够将`monadic`计算嵌套`stack`堆栈中，这个堆栈有一个接口，用於在`levels`(级别)之间交换值，称为`lift`。\n```haskell\nlift :: (Monad m, MonadTrans t) => m a -> t m a\nliftIO :: MonadIO m => IO a -> m a\nclass MonadTrans t where\n    lift :: Monad m => m a -> t m a\n\nclass (Monad m) => MonadIO m where\n    liftIO :: IO a -> m a\n\ninstance MonadIO IO where\n    liftIO = id\n```\n就像基本的`monad`类具有法律一样，`monad transformers`也具有一些法律:\n```haskell\nLaw #1\n\n    lift . return = return\n\nLaw #2\n\n    lift (m >>= f) = lift m >>= (lift . f)\n\n或等效地:\n\nLaw #1\n\n     lift (return x)\n\n    = return x\n\nLaw #2\n\n    do x <- lift m\n     lift (f x)\n\n    = lift $ do x <- m\n                f x\n```\n\n请记住，`transformers`是由`outside-in`(从外向内)组成的，但由`inside out`(内而外)展开，這很有用。\n\n請看: [Monad Transformers: Step-By-Step](http://catamorph.de/publications/2004-10-01-monad-transformers.html)\n\n### Basics\n最基本的使用要求我们为外层的每个`monad transformers`使用`T-variants`(变量)，并在层之间显式地`lift`和`return`值。\n\n`monad`的`kind`為`(* -> *)`,所以把`monad`转换成`monad`的`monad transformers`有`((* -> *) -> * -> *)`:\n```haskell\nMonad (m :: * -> *)\nMonadTrans (t :: (* -> *) -> * -> *)\n```\n因此，例如，如果我们想同时使用`Reader`和`Maybe`单子构成一个复合计算，我们现在可以将`Maybe`放在`ReaderT`内以形成`ReaderT t Maybe a`.\n```haskell\nimport Control.Monad.Reader\n\ntype Env = [(String, Int)]\ntype Eval a = ReaderT Env Maybe a\n\ndata Expr\n  = Val Int\n  | Add Expr Expr\n  | Var String\n  deriving (Show)\n\neval :: Expr -> Eval Int\neval ex = case ex of\n\n  Val n -> return n\n\n  Add x y -> do\n    a <- eval x\n    b <- eval y\n    return (a+b)\n\n  Var x -> do\n    env <- ask\n    val <- lift (lookup x env)\n    return val\n\nenv :: Env\nenv = [(\"x\", 2), (\"y\", 5)]\n\nex1 :: Eval Int\nex1 = eval (Add (Val 2) (Add (Val 1) (Var \"x\")))\n\nexample1, example2 :: Maybe Int\nexample1 = runReaderT ex1 env\nexample2 = runReaderT ex1 []\n```\n这种方法的基本局限性在于，我们发现我們有自己有很多的`lift.lift.lifting`和`return.return.returning`。\n\n\n### ReaderT\n例如，`Reader monad`存在三种可能形式。第一个是`Haskell 98`版本，该版本已不存在，但对于理解基本思想很有用。另外两个是`transformers`和`mtl`变体。\n```haskell\nReader\n\n    newtype Reader r a = Reader { runReader :: r -> a }\n\n    instance MonadReader r (Reader r) where\n    ask       = Reader id\n    local f m = Reader (runReader m . f)\n\nReaderT\n\n    newtype ReaderT r m a = ReaderT { runReaderT :: r -> m a }\n\n    instance (Monad m) => Monad (ReaderT r m) where\n    return a = ReaderT $ \\_ -> return a\n    m >>= k  = ReaderT $ \\r -> do\n        a <- runReaderT m r\n        runReaderT (k a) r\n\n    instance MonadTrans (ReaderT r) where\n        lift m = ReaderT $ \\_ -> m\n\nMonadReader\n\n    class (Monad m) => MonadReader r m | m -> r where\n        ask   :: m r\n        local :: (r -> r) -> m a -> m a\n\n    instance (Monad m) => MonadReader r (ReaderT r m) where\n        ask       = ReaderT return\n        local f m = ReaderT $ \\r -> runReaderT m (f r)\n```\n因此，假设`ask`的三个变体为:\n```haskell\nask :: Reader r r\nask :: Monad m => ReaderT r m r\nask :: MonadReader r m => m r\n```\n实际上，现代`Haskell`仅使用最后一个。\n\n### Newtype Deriving\n通过`Newtypes`，我们可以引用具有单个构造函数的数据类型作为新的`distinct`(独特/不同)类型，而装箱不会增加运行时间，这与具有单个构造函数的代数数据类型不同。\n`around`(圍繞)字符串和数字类型的`Newtype`包装器通常可以大大减少意外错误。\n\n考虑使用`newtype`区分具有不同语义的两个不同文本`Blob`的情况。\n两者都具有与`text`(文本)对象相同的运行时表示形式，但都是`distinguished statically`(静态区分)的，\n这样明文就不会意外地与加密文本互换。\n```haskell\nnewtype Plaintext = Plaintext Text\nnewtype Crytpotext = Cryptotext Text\n\nencrypt :: Key -> Plaintext -> Cryptotext\ndecrypt :: Key -> Cryptotext -> Plaintext\n```\n另一个常见的用例是使用`newtypes`来派生逻辑，以在我们的业务逻辑中派生自定义`monad transformers`。\n使用`-XGeneralizedNewtypeDeriving`，我们可以恢复在我们的`transformer`堆栈中组成的底层类型的实例的函數。\n```haskell\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\nnewtype Velocity = Velocity { unVelocity :: Double }\n  deriving (Eq, Ord)\n\nv :: Velocity\nv = Velocity 2.718\n\nx :: Double\nx = 2.718\n\n-- Type error is caught at compile time even though\n-- they are the same value at runtime!\nerr = v + x\n\nnewtype Quantity v a = Quantity a\n  deriving (Eq, Ord, Num, Show)\n\ndata Haskeller\ntype Haskellers = Quantity Haskeller Int\n\na = Quantity 2 :: Haskellers\nb = Quantity 6 :: Haskellers\n\ntotalHaskellers :: Haskellers\ntotalHaskellers = a + b\nCouldn't match type `Double' with `Velocity'\nExpected type: Velocity\n  Actual type: Double\nIn the second argument of `(+)', namely `x'\nIn the expression: v + x\n```\n将`newtype deriving`与`mtl`库类型类一起使用，我们可以生成不需要在`transform`(转换器)堆栈中显式提升的`flattened transformer`(扁平转换器)类型。例如，这里有一个小的`stack machine`(堆栈机)，它包含了`Reader, Writer, State monad`。\n```haskell\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\nimport Control.Monad.Reader\nimport Control.Monad.Writer\nimport Control.Monad.State\n\ntype Stack   = [Int]\ntype Output  = [Int]\ntype Program = [Instr]\n\ntype VM a = ReaderT Program (WriterT Output (State Stack)) a\n\nnewtype Comp a = Comp { unComp :: VM a }\n  deriving (Monad, MonadReader Program, MonadWriter Output, MonadState Stack)\n\ndata Instr = Push Int | Pop | Puts\n\nevalInstr :: Instr -> Comp ()\nevalInstr instr = case instr of\n  Pop    -> modify tail\n  Push n -> modify (n:)\n  Puts   -> do\n    tos <- gets head\n    tell [tos]\n\neval :: Comp ()\neval = do\n  instr <- ask\n  case instr of\n    []     -> return ()\n    (i:is) -> evalInstr i >> local (const is) eval\n\nexecVM :: Program -> Output\nexecVM = flip evalState [] . execWriterT . runReaderT (unComp eval)\n\nprogram :: Program\nprogram = [\n     Push 42,\n     Push 27,\n     Puts,\n     Pop,\n     Puts,\n     Pop\n  ]\n\nmain :: IO ()\nmain = mapM_ print $ execVM program\n```\n在`newtype`构造函数上的模式匹配不会编译成任何东西.\n例如，`extractB`函数不会像`extractA`那样仔细检查`MkB`构造函数，\n因为`MkB`在运行时不存在，所以它纯粹是一个编译时结构。\n```haskell\ndata A = MkA Int\nnewtype B = MkB Int\n\nextractA :: A -> Int\nextractA (MkA x) = x\n\nextractB :: B -> Int\nextractB (MkB x) = x\n```\n\n### Efficiency (效率)\n第二个`monad transformer`法则保证连续的`lift`(提升)操作的`sequencing`(顺序)在语义上等同于将结果提升到外部`monad`中。\n```haskell\ndo x <- lift m  ==  lift $ do x <- m\n   lift (f x)                 f x\n```\n\n虽然它们可以保证得到相同的结果，但是在使用`monad traversal and looping`(遍历和循环)函数时，在`monad`级别之间`lift`(提升)结果的操作并不是没有代价的，而且经常会出现。\n例如，下面左侧的所有三个函数的效率都低于右侧，后者在基本`monad`中执行绑定，而不是在每次迭代时都进行`lift`(提升)。\n```haskell\n-- Less Efficient      More Efficient\nforever (lift m)    == lift (forever m)\nmapM_ (lift . f) xs == lift (mapM_ f xs)\nforM_ xs (lift . f) == lift (forM_ xs f)\n```\n\n### Monad Morphisms (单子态射)\n基本的`monad transformer`程序包提供了一个`MonadTrans`类，用于提升到另一个`monad`:\n```haskell\nlift :: Monad m => m a -> t m a\n```\n但是通常我们需要与`monad transformer`堆栈一起工作和操作，以产生新的`transformer`，修改现有的`transformers`或用新的`layers`(层)扩展上游库。`mmorph`库提供了直接在`transformer`堆栈上构成`monad morphism transformation`(形态变换)的功能。\n等效的变压器类型等级映射是“提升”功能。\n等效的`type transformer`(类型转换器)`type-level`映射是`hoist`功能.\n```haskell\nhoist :: Monad m => (forall a. m a -> n a) -> t m b -> t n b\n```\n`Hoist`接收`monad`态射(从`m a`到`n a`的映射)并应用于变压器堆栈的内部值`monad`，从而转换外层下的值.\n`monad morphism`(态射)`generalize`将一个`Identity`单子带入任何其他单子`monad m`.\n```haskell\ngeneralize :: Monad m => Identity a -> m a\n```\n例如，它将`State s a`(即`StateT s Identity a`)概括为`StateT s a`.\n因此，我们可以`generalize`(概括)一个现有的`transformer`以在其上`lift`(提升)一個`IO`层。\n```haskell\nimport Control.Monad.State\nimport Control.Monad.Morph\n\ntype Eval a = State [Int] a\n\nrunEval :: [Int] -> Eval a -> a\nrunEval = flip evalState\n\npop :: Eval Int\npop = do\n  top <- gets head\n  modify tail\n  return top\n\npush :: Int -> Eval ()\npush x = modify (x:)\n\nev1 :: Eval Int\nev1 = do\n  push 3\n  push 4\n  pop\n  pop\n\nev2  :: StateT [Int] IO ()\nev2 = do\n  result <- hoist generalize ev1\n  liftIO $ putStrLn $ \"Result: \" ++ show result\n```\n請看: [mmorph](https://hackage.haskell.org/package/mmorph)\n","tags":["Monad-Transformers"]},{"title":"Haskell-Monads","url":"/blog/2019/10/16/Haskell-Monads/","content":"> [原文](http://dev.stephendiehl.com/hask/#monads)\n\n### Eightfold Path to Monad Satori (通往Monad Satori的八重路)\n关于所谓的`monads`的奥秘，抒情诗已经大量涌出。相反，我建议一个启发之路:\n* 不要读`monad`教程。\n* 不，真的，不要读`monad`的教程。\n* 學習[Haskell types](http://book.realworldhaskell.org/read/types-and-functions.html)\n* 学习什么是`typeclass`(类型类)。\n* 阅读[Typeclassopedia](http://wiki.haskell.org/Typeclassopedia)。\n* 阅读`monad`的定义。\n* 在代码中使用`monads`。\n* 不要写`monad`类比教程。\n\n换句话说，了解`monad的`唯一途径是阅读好的源代码，启动`GHC`并编写一些代码。 类比和隐喻不会导致理解。\n\n### Monadic Myths(神話)\n以下均为`false`:\n* `Monads`是不纯的。\n* `Monads`是关于`effects`(效果)的。\n* `Monads`是关于状态的。\n* `Monads`与命令式排序有关。\n* `Monads`与`IO`有关。\n* `Monads`依赖懒惰。\n* `Monads`是该语言的后门，可以产生副作用。\n* `Monads`是`Haskell`内部的嵌入式命令式语言。\n* `Monads`需要了解抽象数学。\n* `Monads`是`Haskell`独有的。\n\n請看: [What a Monad Is Not](http://wiki.haskell.org/What_a_Monad_is_not)\n\n### Monadic Methods\n`Monads`并不复杂。它们被实现为具有兩個方法的`typeclass`: `return`和`(>=)`(发音为`bind`)。\n\n为了实现`monad`实例，这两个函数必须根据`typeclass`定义中描述的一致性进行定义：\n\n```haskell\n-- 'm'指实现 Monad typeClass 的类型构造函数(例如: Maybe,Either等)\nclass Monad m where\n  return :: a -> m a\n  (>>=)  :: m a -> (a -> m b) -> m b\n```\n`Monad`类定义中的第一个类型签名是用于`return`的。\n\n对于`return`一词可能有的任何先入之见都应该丢弃: 它在`Haskell`的上下文中具有完全不同的含义，并且与`C`，`Python`或`Java`等语言的行为截然不同。\n在`Haskell`中，`return`不是函数产生什么值的最终仲裁者，而是将类型为`a`的值注入到`monadic`上下文语境(例如`Maybe`，`Either`等)中，表示为`m a`。\n\n实现`Monad`实例的另一个重要函數是`(>>=)`。\n此中缀操作符有两个参数。\n在其左侧是类型为`m a`的值，而在右侧是类型为`(a -> m b)`的函数。`bind`(绑定)操作得出的最终值类型为`m b`。\n\n第三个辅助函数(`(>>)`)是根据放弃其参数的绑定操作定义的。\n```haskell\n(>>) :: Monad m => m a -> m b -> m b\nm >> k = m >>= \\_ -> k\n```\n这个定义是说`(>>)`有一個`left`和`right`參數，它们分别是类型为`m a`和`m b`的单子数，而中缀操作符返回类型为`m b`的值。\n\n`(>>)`的实际实现表示，当将`m`传递到带有`k`的右侧的`(>>)`时，将始终返回值`k`。\n\n### Laws\n除了`(>>=)`和`return`的特定实现之外，所有`monad`实例还必须满足三个定律。\n\n#### Law 1\n第一定律说，当将`(return a)`通过`(>>=)`传递给函数`f`时，该表达式与`f a`完全等效。\n```haskell\nreturn a >>= f ≡ f a  -- 'a'是指值，而不是类型\n```\n在讨论下两个定律时，我们将提到一个值`m`。\n这个符号是包装在`monadic`上下文中的值的简写。这样的值具有`m a`类型，可以更具体地用`Nothing`、`Just x`或`Right x`等值来表示。\n需要注意的是，这些值`m`的具体实例化中有一些包含多个组件。在讨论第二和第三单子定律时，我们将看到一些例子来说明这一点。\n\n#### Law 2\n第二定律指出，通过`(>>=)`传递给`return`的`monadic`值`m`与其自身完全等效。\n换句话说，使用`bind`将`monadic`值传递给`return`不会改变初始值。\n```haskell\nm >>= return ≡ m  -- 'm'是指类型为'm a'的值\n```\n存在一种更明确的写第二条`Monad`定律的方法。在下面的示例代码中，第一个表达式显示了第二定律如何应用于由[non-nullary](https://wiki.haskell.org/Constructor#Type_constructor)类型构造函数表示的值。第二个片段显示了由`nullary`类型构造函数表示的值在第二定律的上下文中如何工作。\n```haskell\n(SomeMonad val) >>= return ≡ SomeMonad val  -- 'SomeMonad val'具有类型'm a'，就像`Law 2`第一个示例中的`m`一样\n\nNullaryMonadType >>= return ≡ NullaryMonadType\n```\n\n#### Law 3\n虽然前两条法律比较明确，但第三条法律可能更难理解。\n\n这条定律规定，当一个`monadic`值`m`通过`(>>=)`传递给函数`f`，然后將该表达式的结果传递给`>>=g`時，\n整个表达式完全等同于将`m`传递给一个`lambda`表达式，该`lambda`表达式接受一个参数`x`，并产出应用于`x`的函数`f`。\n根据`bind`的定义，`f x`必须返回包装在同一个`monad`中的值。由于此属性，该表达式的结果值可以通过`(>>=)`传递给函数`g`，该函数也返回一个`monadic`值。\n```haskell\n-- 'm'的类型为'm a'\n-- 函数'f'和'g'类型分别為'(a -> m b)'和'(b -> m c)'\n(m >>= f) >>= g ≡ m >>= (\\x -> f x >>= g)\n```\n同样，可以用更明确的代码编写该定律。就像在`Law 2`的明确示例中一样，`m`已由`SomeMonad val`代替，以非常清楚地表明，`monadic`值可以有多个`components`(分量)。\n尽管代码中的变化很小，但是更容易看到值(即`val`)与`lambda`表达式中的`x`对应。在将`(SomeMonad val)`通过`(>>=)`传递给`f`之后，函数`f`在`val`上运行，并返回仍封装在`SomeMonad`类型构造函数中的结果。\n\n我们可以将此新值称为`SomeMonad newVal`。由于它仍然包裹在`monad`上下文中，因此可以将`SomeMonad newVal`通过绑定操作传递到函数`g`中。\n\n```haskell\n((SomeMonad val) >>= f) >>= g ≡ (SomeMonad val) >>= (\\x -> f x >>= g)\n```\n\n請看: [Monad Laws](http://wiki.haskell.org/Monad_laws)\n\n### Do Notation (Do表示法)\nhaskell中的`Monadic`语法是以加糖的形式编写的，称为`do`符号。这种特殊语法的优点是它更容易编写，并且完全等同于`monad`操作的应用程序。根据以下规则递归定义脫糖:\n```haskell\n-- 将'f'绑定到a，然后继续对'm'进行脱糖\ndo { a <- f ; m } ≡ f >>= \\a -> do { m }  \n\n-- 评估`f`，然后继续对'm'进行脱糖\ndo { f ; m } ≡ f >> do { m }\n\ndo { m } ≡ m\n```\n因此，通过应用脱糖规则，以下表达式是等效的:\n```haskell\ndo\n  -- 將f,g和h分別绑定到名称a，b和c。\n  -- 然后将这些名称传递给`return`,\n  -- 以确保所有值都包裹在适当的monad上下文中\n  a <- f\n  b <- g\n  c <- h\n  return (a, b, c)\n\ndo {\n    -- 注意: {}和;字符在do符号中很少使用\n    a <- f;\n    b <- g;\n    c <- h;\n    return (a, b, c)\n}\n\nf >>= \\a ->\n  g >>= \\b ->\n    h >>= \\c ->\n      return (a, b, c)\n```\n如果将`bind`运算符写为`uncurried`(非咖喱)函数（这不是`Haskell`使用它的方式），则相同的`desugaring`操作可能看起来像以下带有`lambda`的嵌套绑定链。\n```haskell\nbindMonad(f, lambda a:\n  bindMonad(g, lambda b:\n    bindMonad(h, lambda c:\n      returnMonad (a,b,c))))\n```\n在`do-notation`中，上面的[monad laws](http://dev.stephendiehl.com/hask/#laws)等效地写成:\n```haskell\n-- Law 1\n\n  do y <- return x\n     f y\n\n= do f x\n\n-- Law 2\n\n  do x <- m\n     return x\n\n= do m\n\n-- Law 3\n\n  do b <- do a <- m\n             f a\n     g b\n\n= do a <- m\n     b <- f a\n     g b\n\n= do a <- m\n     do b <- f a\n        g b\n```\n請看: [Haskell 2010: Do Expressions](http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14)\n\n### Maybe\n`Maybe monad`是`monad`实例的最简单的第一个示例。`Maybe monad`對计算进行建模，该计算可能在计算过程中的任何时候失敗，无法产生值。\n\n`Maybe`类型具有两个值构造函数。第一个`Just`是一个表示成功计算的一元构造函数，第二个`Nothing`是一个表示失败的`nullary`(无效)构造函数。\n```haskell\ndata Maybe a = Nothing | Just a\n```\n`Maybe`的`monad`实例通过:在可能传递给`bind`操作的可能输入上(即`Nothing`或`Just x`)进行模式匹配来描述`Maybe`的`(>>=)`实现。\n\n該实例声明还提供了`return`的实现，在这种情况下，它只是`Just`。\n\n```haskell\ninstance Monad Maybe where\n    -- 'k'是一個具有(a -> Maybe a)類型的函數\n    (Just x) >>= k = k x\n    Nothing  >>= k = Nothing\n    -- Just的类型签名是(a -> Maybe a)\n    -- 换句话说，与上面的typeclass声明中的·return·类型极为相似。\n    return = Just\n```\n以下代码显示了在`Maybe monad`中执行的一些简单操作。\n\n在第一个示例中，值`Just 3`通过`(>>=)`传递给lambda函数`\\x -> return（x + 1)`。\n`x`是指`Just 3`的`Int`部分，我们可以在`lambda`表达式的后半部分使用`x`，其中`return (x + 1)`的值等于`Just 4`，表示一個成功的计算。\n```haskell\n(Just 3) >>= (\\x -> return (x + 1))\n-- Just 4\n```\n在第二个示例中，值`Nothing`通过`(>>=)`传递到与上一个示例相同的`lambda`函数。\n但是，根据`Maybe Monad`实例，每当`Nothing`绑定到一个函数时，表达式的结果将为`Nothing`。\n```haskell\nNothing >>= (\\x -> return (x + 1))\n-- Nothing\n```\n下一個例子中，將`return`應用到`4`,並返回`Just 4`.\n```haskell\nreturn 4 :: Maybe Int\n-- Just 4\n```\n下面的代码示例演示在`Maybe monad`中使用`do`表示法进行可能失败的加法运算。还提供了脫糖的示例。\n```haskell\nexample1 :: Maybe Int\nexample1 = do\n  a <- Just 3    -- Bind 3 to name a\n  b <- Just 4    -- Bind 4 to name b\n  -- 评估(a + b)，\n  -- 然后使用'return'以确保结果在Maybe monad中，\n  -- 以便满足类型签名\n  return $ a + b  -- Just 7\n\n-- 這是脫糖操作，等同於example1\ndesugared1 :: Maybe Int\ndesugared1 = Just 3 >>= \\a ->\n               Just 4 >>= \\b ->\n                 return $ a + b  -- Just 7\n\n\nexample2 :: Maybe Int\nexample2 = do\n  a <- Just 3   -- Bind 3 to name a\n  b <- Nothing  -- Bind Nothing to name b\n  -- 由於Maybe monad中的加法实际上可以返回'Nothing',这个结果可能有些令人惊讶\n  -- 出现此结果是因为其中一个值Nothing指示计算失败。\n  -- 由于计算在过程中的某一步失败，因此整个计算失败，最终结果为'Nothing'。\n  return $ a + b  -- Nothing\n\n-- 這是脫糖操作，等同於example2\ndesugared2 :: Maybe Int\ndesugared2 = Just 3 >>= \\a ->\n               Nothing >>= \\b ->\n                  return $ a + b\n-- Nothing\n```\n\n### List\n`List monad`是`monad`实例的第二个最简单的示例。和往常一样，此`monad`同时实现`(>>=)`和`return`。\n`bind`的定义是，当列表`m`绑定到函数`f`时，结果是`map f`在列表`m`上的`concatenation`(串联)。\n`return`方法仅取一个值`x`并注入一个`singleton`列表`[x]`.\n\n```haskell\ninstance Monad [] where\n  m >>= f   =  concat (map f m)  -- 'm' is a list\n  return x  =  [x]\n```\n为了演示`List monad`的方法，我们将定义两个函数:`m`和`f`。\n`m`是一个简单列表，而`f`是一个函数，它接收单个`Int`參數并返回擁有兩個元素的列表`[1，0]`。\n```haskell\nm :: [Int]\nm = [1,2,3,4]\n\nf :: Int -> [Int]\nf = \\x -> [1,0]\n```\n评估过程如下:\n```haskell\nm >>= f\n==> [1,2,3,4] >>= \\x -> [1,0]\n==> concat (map (\\x -> [1,0]) [1,2,3,4])\n==> concat ([[1,0],[1,0],[1,0],[1,0]])\n==> [1,0,1,0,1,0,1,0]\n```\nHaskell中的列表`comprehension`语法可以根据列表`monad`来实现。\n对于更明显的`monadic`实现，列表`comprehension`可以被视为语法糖。\n示例`a`和`b`说明了这些用例。\n\n第一个示例(`a`)说明了如何编写列表`comprehension`。\n尽管语法一开始看起来很奇怪，但其中的某些元素可能看起来很熟悉。\n例如，`<-`的用法就像在`do`表示法中的`bind`(绑定): 它将列表的元素绑定到名称。\n\n但是，有一个主要区别是显而易见的：例子`a`似乎缺少对`return`的调用。不过，不用担心，`[]`扮演了这个角色。编译器可以轻松地将此语法脫糖为显式调用`return`。此外，它还可以提醒用户该计算是在`List monad`中进行的。\n```haskell\na = [\n      f x y |   -- 对应于示例b中的'f x y'\n      x <- xs,\n      y <- ys,\n      x == y     -- 对应于示例b中的'guard $ x == y'\n    ]\n```\n第二个示例(`b`)显示了用`do`表示符重写的列表`comprehension`:\n```haskell\n-- 与a相同\nb = do\n  x <- xs\n  y <- ys\n  guard $ x == y  -- 对应于示例a中的'x == y'\n  return $ f x y  -- 对应于示例a中的'[]' and 'f x y'\n```\n最后的例子是`List`单子的进一步说明。\n下面的每个函数都返回一个三元组列表，其中包含三个列表的可能组合，这三个列表绑定了名称`a`,`b`和`c`。\n注意: 在元组的`a`位置只能使用绑定到`a`的列表中的值; 对于绑定到`b`和`c`的列表也是如此。\n```haskell\nexample :: [(Int, Int, Int)]\nexample = do\n  a <- [1,2]\n  b <- [10,20]\n  c <- [100,200]\n  return (a,b,c)\n-- [(1,10,100),(1,10,200),(1,20,100),(1,20,200),(2,10,100),(2,10,200),(2,20,100),(2,20,200)]\n\ndesugared :: [(Int, Int, Int)]\ndesugared = [1, 2] >>= \\a ->\n              [10, 20] >>= \\b ->\n                [100, 200] >>= \\c ->\n                  return (a, b, c)\n-- [(1,10,100),(1,10,200),(1,20,100),(1,20,200),(2,10,100),(2,10,200),(2,20,100),(2,20,200)]\n```\n\n### IO\n`IO`可能是`Haskell中`最著名的例子(一种`monad`)。\n\n`IO a`类型的值是一种计算，当执行时，它会在返回`a`类型的值之前执行一些`I/O`。这些计算称为`actions`(动作)。\n在`main`中执行的`IO`动作是程序可以在外部世界上操作或访问信息的方式。`IO`操作使程序可以执行许多操作，包括但不限于:\n* 将字符串打印到终端\n* 从终端读取和分析输入\n* 读取或写入系统上的文件\n* 建立到远程计算机的ssh连接\n* 从无线电天线接收信号进行处理\n\n将`I/O`概念化为`monad`，使开发人员可以访问程序外部的信息，但可以使用纯函數对数据进行操作。以下示例将说明我们如何使用`IO`操作和`IO`值来接收来自`stdin`的输入并将其打印到`stdout`。\n\n在`Haskell`中执行`I/O`的最直接有用的函數可能是`putStrLn`。此函数接收`String`并返回`IO ()`。\n在`main`中调用它將会把`String`打印到`stdout`，后跟换行符。\n\n```haskell\nputStrLn :: String -> IO ()\n```\n这是一些向终端打印內容的代码。执行`putStrLn`的第一次调用，导致将`String`打印到`stdout`。其结果绑定到丢弃其参数的`lambda`表达式，然后执行下一个`putStrLn`。\n```haskell\nmain :: IO ()\nmain = putStrLn \"Vesihiisi sihisi hississäään.\" >>=\n         \\_ -> putStrLn \"Or in English: 'The water devil was hissing in her elevator'.\"\n\n-- Sugared code, written with do notation\nmain :: IO ()\nmain = do putStrLn \"Vesihiisi sihisi hississäään.\"\n          putStrLn \"Or in English: 'The water devil was hissing in her elevator'.\"\n```\n另一个有用的函数是`getLine`，其类型为`IO String`。此函数从`stdin`获取一行输入。然后，开发人员可以将此行绑定到名称，以便对程序中的值进行操作。\n```haskell\ngetLine :: IO String\n```\n下面的代码演示了这两个函數的简单组合以及简化的`IO`代码。首先，`putStrLn`将一个`String`打印到`stdout`，要求用户提供其名称，结果绑定到一个`lambda`上，该`lambda`放弃它的参数。然后，执行`getLine`，向用户提供输入其名称的提示。接下来，将所得的`IO`字符串绑定到`name`，并传递给`putStrLn`。最后，程序将名称打印到终端。\n```haskell\nmain :: IO ()\nmain = do putStrLn \"What is your name: \"\n          name <- getLine\n          putStrLn name\n```\n下面代码块是上一个示例的经过脫糖的等效代码: 但是，`(>>=)`的使用是明确的:\n```haskell\nmain :: IO ()\nmain = putStrLn \"What is your name:\" >>=\n       \\_    -> getLine >>=\n       \\name -> putStrLn name\n```\n最后一个示例的执行方式与前两个示例相同。但是，此示例使用特別的`(>>)`运算符代替将结果绑定到丢弃其参数的`lambda`。\n```haskell\nmain :: IO ()\nmain = putStrLn \"What is your name: \" >> (getLine >>= (\\name -> putStrLn name))\n```\n請看: [Haskell 2010: Basic/Input Output](http://www.haskell.org/onlinereport/haskell2010/haskellch7.html)\n\n### What's the point? (有什么意义?)\n虽然很难（如果不是不可能的话）, 去接触、查看或以其他方式与`monad`进行物理交互，但是这个结构对程序员有一些非常有趣的含义。例如，考虑非直观的事实，我们现在有一个`uniform`(统一)的接口来讨论三种非常不同的，但基本的编程思想: `Failure`,`Collections`和`Effects`.\n\n让我们写下一个名为`sequence`的新函数，它`folds`(折叠)函數`mcons`到单子计算`list`上.\n我们可以认为`mcons`类似于列表构造函数(即`(a:b:[])`)，但它通过`bind`从两个`monadic`值`(p，q)`中提取两个列表元素.\n然後，将绑定值与列表构造器`:`联接在一起，最后再通过`return`在适当的单子上下文中重新包装。\n```haskell\nsequence :: Monad m => [m a] -> m [a]\nsequence = foldr mcons (return [])\n\n-- \nmcons :: Monad m => m t -> m [t] -> m [t]\nmcons p q = do\n  x <- p  -- 'x'表示单個值, [m a]中的每個值將會傳遞給p\n  y <- q  -- 初始值,m []\n  -- y是列表,因此,可以在其前面加上x\n  return (x:y)\n```\n就上述每个单子而言，此函數有什麼意义？\n\n#### Maybe\n在[Maybe context](http://dev.stephendiehl.com/hask/#maybe)中对值列表进行`Sequencing`使我们能够收集可能会失败的一系列计算的结果。但是，`sequence`仅在每次计算成功时才产生`aggregated`(合计)值。换句话说，即使传递给`sequence`的初始列表中的`Maybe`值之一是`Nothing`，`sequence`的结果也将是`Nothing`.\n```haskell\nsequence :: [Maybe a] -> Maybe [a]\nsequence [Just 3, Just 4] -- Just [3,4]\n\n-- 由于结果之一为Nothing，因此整个计算失败\nsequence [Just 3, Just 4, Nothing] -- Nothing\n```\n#### List\n[list monad](http://dev.stephendiehl.com/hask/#list)的`bind`操作形成两个操作数中元素的成对列表。\n因此，将`mcons`中包含的绑定`folding`(折叠)到具有`sequence`的列表列表上，可以实现任意数量列表的通用笛卡尔积。\n```haskell\nsequence :: [[a]] -> [[a]]\nsequence [[1,2,3],[10,20,30]]\n-- [[1,10],[1,20],[1,30],[2,10],[2,20],[2,30],[3,10],[3,20],[3,30]]\n```\n\n#### IO\n在[IO context](http://dev.stephendiehl.com/hask/#io)上下文中应用`sequence`仍然会产生不同的结果。函数获取`IO actions`的列表，按顺序执行这些操作，然后按顺序返回结果值的列表。\n```haskell\nsequence :: [IO a] -> IO [a]\nsequence [getLine, getLine, getLine]\n-- a\n-- b\n-- 9\n-- [\"a\", \"b\", \"9\"] 所有输入作为IO [String]返回到列表中.\n```\n因此，我们有了它，通常彼此独立定义的三个基本计算概念(`Failure`,`Collections`和`Effects`)实际上都共享这种相似的结构。可以对这种统一模式进行抽象，然后将其重复使用以构建适用于所有当前和将来实现的更高抽象。如果您想要了解`monad`的动机，就是这样！这些见解是我所希望知道的关于`monad`回顾的本质。\n\n請看: [Control.Monad](http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#g:4)\n\n### Reader Monad\n`reader monad`允許我们可以在`monadic`上下文中访问共享的不可变状态。\n```haskell\nask :: Reader r r\nasks :: (r -> a) -> Reader r a\nlocal :: (r -> r) -> Reader r a -> Reader r a\nrunReader :: Reader r a -> r -> a\n\nimport Control.Monad.Reader\n\ndata MyContext = MyContext\n  { foo :: String\n  , bar :: Int\n  } deriving (Show)\n\ncomputation :: Reader MyContext (Maybe String)\ncomputation = do\n  n <- asks bar\n  x <- asks foo\n  if n > 0\n    then return (Just x)\n    else return Nothing\n\nex1 :: Maybe String\nex1 = runReader computation $ MyContext \"hello\" 1\n\nex2 :: Maybe String\nex2 = runReader computation $ MyContext \"haskell\" 0\n```\n`Reader monad`的簡單實現:\n```haskell\n-- Reader r a 中的 r 类型就是给定数据的类型，可以从中提取想要的信息\n-- 类型 r 的值称为环境，即从该环境下读出类型为 a 值来\n-- 比如，给定了一个很长的字符串，如果需要读取 它的长度，那么读取器 monad 的类型就应当为 Reader String Int\nnewtype Reader r a = Reader { runReader :: r -> a }\n\ninstance Monad (Reader r) where\n  return a = Reader $ \\_ -> a\n  -- (>>=) :: Reader r a -> (a -> Reader r b) -> Reader r b\n  -- (>>=) 运算符在给定的环境r下执行m后，将结果输入函数k中。\n  m >>= k  = Reader $ \\r -> runReader (k (runReader m r)) r\n\n-- 獲取當前环境s\nask :: Reader r r\nask = Reader id\n\n-- 從指定环境中取值\nasks :: (r -> a) -> Reader r a\nasks f = Reader f\n\n-- 在修改后的环境中执行计算\nlocal :: (r -> r) -> Reader r a -> Reader r a\nlocal f m = Reader $ runReader m . f\n```\n\n### Writer Monad\n`writer monad`使我们能够从`monadic`上下文中`emit`(發出)惰性的值流。\n```haskell\ntell :: w -> Writer w ()\nexecWriter :: Writer w a -> w\nrunWriter :: Writer w a -> (a, w)\n\nimport Control.Monad.Writer\n\ntype MyWriter = Writer [Int] String\n\nexample :: MyWriter\nexample  = do\n  tell [1..3]\n  tell [3..5]\n  return \"foo\"\n\noutput :: (String, [Int])\noutput = runWriter example\n-- (\"foo\", [1, 2, 3, 3, 4, 5])\n```\n`Writer monad`的簡單實現:\n```haskell\nimport Data.Monoid\n\n-- w為記錄器，a為值\nnewtype Writer w a = Writer { runWriter :: (a, w) }\n\ninstance Monoid w => Monad (Writer w) where\n  return a = Writer (a, mempty)\n  -- (>>=) :: Writer w a -> (a -> Writer w b) -> Writer w b\n  m >>= k  = Writer $ let\n      (a, w)  = runWriter m\n      (b, w') = runWriter (k a)\n      in (b, w `mappend` w')\n\nexecWriter :: Writer w a -> w\nexecWriter m = snd (runWriter m)\n\ntell :: w -> Writer w ()\ntell w = Writer ((), w)\n```\n这个实现是懒惰的，因此必须注意，实际上只想生成一个`thunk`流。大多数情况下，`lazy writer`不适合使用，而是通过在`StateT monad`中嵌入一些`monomial`(单值/单项式的)对象或使用严格版本来实现等效结构。\n```haskell\nimport Control.Monad.Writer.Strict\n```\n\n### State Monad\n`State monad`允许有状态`monadic`上下文中的函数访问和修改共享状态。\n```haskell\nrunState  :: State s a -> s -> (a, s)\nevalState :: State s a -> s -> a\nexecState :: State s a -> s -> s\nimport Control.Monad.State\n\ntest :: State Int Int\ntest = do\n  put 3\n  modify (+1)\n  get\n\nmain :: IO ()\nmain = print $ execState test 0\n```\n状态`monad`常常被错误地描述为不纯净，但事实上它是完全纯净的，通过显式传递状态也可以达到同样的效果。`State monad`的简单实现只需要几行代码:\n```haskell\nnewtype State s a = State { runState :: s -> (a,s) }\n\ninstance Monad (State s) where\n  return a = State $ \\s -> (a, s)\n\n  State act >>= k = State $ \\s ->\n    let (a, s') = act s\n    in runState (k a) s'\n\nget :: State s s\nget = State $ \\s -> (s, s)\n\nput :: s -> State s ()\nput s = State $ \\_ -> ((), s)\n\nmodify :: (s -> s) -> State s ()\nmodify f = get >>= \\x -> put (f x)\n\nevalState :: State s a -> s -> a\nevalState act = fst . runState act\n\nexecState :: State s a -> s -> s\nexecState act = snd . runState act\n```\n\n### Monad Tutorials\n已经编写了这么多`monad`教程，以至于产生了一个问题：什么使`monads`在初学`Haskell`时如此困难？我认为这是三个方面的原因:\n\n* 1.关于脱糖的间接作用有几个层次(`There are several levels on indirection with desugaring.`)。\n\n  我们所写的许多`haskell`代碼都经过了彻底的重新编排，并在幕后转化为一种全新的形式。\n  大多数`monad`教程不会手动展开`do-sugar`。\n  这使得初学者认为`monad`是一种在代码中嵌入伪命令式语言的方法，并进一步助长了这样一种误解，即像`IO`这样的特定实例在其`full generality`(全部方面)都是`monad`。\n  ```haskell\n  main = do\n    x <- getLine\n    putStrLn x\n    return ()\n  ```\n  能够手动脱糖对理解至关重要。\n  ```hhaskell\n  main =\n    getLine >>= \\x ->\n      putStrLn x >>= \\_ ->\n        return ()\n  ```\n\n* 2.用于高阶函数的非对称二进制中缀运算符在其他语言中并不常见。\n  ```haskell\n  (>>=) :: Monad m => m a -> (a -> m b) -> m b\n  ```\n  在运算符的左侧，我们有一个`m a`，在右侧，我们有`a -> m b`。尽管某些语言确实具有中缀运算符，而这些运算符本身就是高阶函数，但这种情况仍然很少见。\n\n  因此，对于一个已脫糖的函数,`(>>=)`运算符实际上是通过将函数组合在一起来构建一个更大的函数，这可能会令人困惑。\n  ```haskell\n  main =\n    getLine >>= \\x ->\n      putStrLn >>= \\_ ->\n        return ()\n  ```\n  以前缀形式编写，它变得更易于消化。\n  ```haskell\n  main =\n    (>>=) getLine (\\x ->\n      (>>=) putStrLn (\\_ ->\n            return ()\n      )\n    )\n  ```\n  也许从其他语言中完全删除操作符可能更直观。\n  ```haskell\n  main = bind getLine (\\x -> bind putStrLn (\\_ -> return ()))\n    where\n      bind x y = x >>= y\n  ```\n\n* 3.`Ad-hoc`(特定)多态性在其他语言中并不常见。\n\n  如果不熟悉类型推断，`Haskell`的重载实现可能是不直观的。它是从用户那里抽象出来的，但是`(>>=)`或`bind`函数实际上是三个参数的函数，带有额外的`typeclass dictionary`参数(`$dMonad`)隐式地缠绕在周围。\n  ```haskell\n  main $dMonad = bind $dMonad getLine (\\x -> bind $dMonad putStrLn (\\_ -> return $dMonad ()))\n  ```\n  除非`monad`类的参数与一个具体的类实例`unified`(统一)(通过`inference`推理)，否则`instance dictionary ($dMonadIO)`会被整个拼接在一起。\n  ```haskell\n  main :: IO ()\n  main = bind $dMonadIO getLine (\\x -> bind $dMonadIO putStrLn (\\_ -> return $dMonadIO ()))\n  ```\n\n现在，所有这些转换都是微不足道的，一旦我们理解了它们，它们通常不会被讨论。\n在我看来，`monad`教程的基本谬误并不是说`monad`的直觉很难传达(也不需要隐喻!)但是，新手们经常在对点(1)(2)和(3)的理解不完全的情况下来到`monads`，然后发现一个简单的事实，即`monads`是`haskell`构造的第一个例子，`haskell`构造是这三者的`confluence`(融合)。\n\n\n請看: [Monad Tutorial Fallacy](http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/)","tags":["Monads"]},{"title":"Haskell-Type-Classes","url":"/blog/2019/10/16/Haskell-Type-Classes/","content":"> [原文](http://dev.stephendiehl.com/hask/#type-classes)\n\n类型类扩展\n\n### Minimal Annotations\n當`TypeClasses`的方法存在默认实现的情况下，可能有几种方法來实现`TypeClass`。\n例如，`Eq`完全是通过定义两个值相等或不相等来定义的，即意味着取另一个值的`negation`(否定/反面)。我们可以用不平等来定义平等，反之亦然。\n```haskell\nclass Eq a where\n  (==), (/=) :: a -> a -> Bool\n  x == y = not (x /= y)\n  x /= y = not (x == y)\n```\n在`7.6.1`之前，无法指定实现类型类所需的`minimal`(最小)定义.\n```haskell\nclass Eq a where\n  (==), (/=) :: a -> a -> Bool\n  x == y = not (x /= y)\n  x /= y = not (x == y)\n  {-# MINIMAL (==) #-}\n  {-# MINIMAL (/=) #-}\n```\n`Minimal pragmas`(最小的编译指示)是布尔表达式，以`|`作为逻辑`OR`，必须定义任何一个定义)。`,`(逗号)表示逻辑`AND`，必须同时定义两个定义。\n```haskell\n{-# MINIMAL (==) | (/=) #-} -- Either (==) or (/=)\n{-# MINIMAL (==) , (/=) #-} -- Both (==) and (/=)\n```\n当定义的实例不符合最小标准时，编译`-Wmissing-methods`会发出警告。\n\n### FlexibleInstances\n```haskell\n{-# LANGUAGE FlexibleInstances #-}\n\nclass MyClass a\n\n-- Without flexible instances, all instance heads must be type variable. The\n-- following would be legal.\n-- 如果没有`flexible`实例，所有实例heads都必须是类型變量的。以下是合法的。\ninstance MyClass (Maybe a)\n\n-- With flexible instances, typeclass heads can be arbitrary nested types. The\n-- following would be forbidden without it.\n-- 使用`flexible`实例，类型类heads可以是任意嵌套类型。如果没有`flexible`，以下内容将被禁止。\ninstance MyClass (Maybe Int)\n```\n\n### FlexibleContexts\n```haskell\n{-# LANGUAGE FlexibleContexts #-}\n\nclass MyClass a\n\n-- Without flexible contexts, all contexts must be type variable. The\n-- following would be legal.\n-- 如果没有`flexible`实例, 所有contexts都必须是类型變量的。以下是合法的。\ninstance (MyClass a) => MyClass (Either a b)\n\n-- With flexible contexts, typeclass contexts can be arbitrary nested types. The\n-- following would be forbidden without it.\n-- 使用`flexible`实例，类型类上下文可以是任意嵌套类型。如果没有`flexible`，以下内容将被禁止。\ninstance (MyClass (Maybe a)) => MyClass (Either a b)\n```\n\n### OverlappingInstances\n类型类通常是全局一致的，在程序中的任何调用站点，只有一个`instance`(实例)可以明确地解析为一种类型。\n但是，有一些扩展可以放宽此限制，并执行更多的`instance`搜索手动指导(`manual direction`)。\n`OverlappingInstances`会放宽相关条件(可以有多个实例)，但会引入一种标准，它将解析到最具体的一个。\n```haskell\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE OverlappingInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n\nclass MyClass a b where\n  fn :: (a,b)\n\ninstance MyClass Int b where\n  fn = error \"b\"\n\ninstance MyClass a Int where\n  fn = error \"a\"\n\ninstance MyClass Int Int where\n  fn = error \"c\"\n\nexample :: (Int, Int)\nexample = fn\n```\n从历史上讲，在模块级别启用该方法并不是最好的主意，因为通常来说，我们在模块中定义多个类，而其中的`subset`(子集)可能是`incoherent`(不连贯的)。\n因此，从`7.1`0开始，我们现在可以只注释具用`OVERLAPPING`和`INCOHERENT`编译指示符的实例。\n```haskell\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n\nclass MyClass a b where\n  fn :: (a,b)\n\ninstance {-# OVERLAPPING #-} MyClass Int b where\n  fn = error \"b\"\n\ninstance {-# OVERLAPPING #-} MyClass a Int where\n  fn = error \"a\"\n\ninstance {-# OVERLAPPING #-} MyClass Int Int where\n  fn = error \"c\"\n\nexample :: (Int, Int)\nexample = fn\n```\n\n### IncoherentInstances(不连贯的实例)\n`Incoherent Instances`放宽了只有一个特定实例的限制，可以任意选择一个(基于其内部表示形式的任意排序)，然后生成的程序将进行类型检查。這是相当疯狂的，通常是不良设计的标志。\n```haskell\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE IncoherentInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n\nclass MyClass a b where\n  fn :: (a,b)\n\ninstance MyClass Int b where\n  fn = error \"a\"\n\ninstance MyClass a Int where\n  fn = error \"b\"\n\nexample :: (Int, Int)\nexample = fn\n```\n\n还有一个`Incoherent Instances`:\n\n```haskell\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n\nclass MyClass a b where\n  fn :: (a,b)\n\ninstance {-# INCOHERENT #-} MyClass a Int where\n  fn = error \"general\"\n\ninstance {-# INCOHERENT #-} MyClass Int Int where\n  fn = error \"specific\"\n\nexample :: (Int, Int)\nexample = fn\n```\n\n### TypeSynonymInstances\n```haskell\n{-# LANGUAGE TypeSynonymInstances #-}\n{-# LANGUAGE FlexibleInstances #-}\n\ntype IntList = [Int]\n\nclass MyClass a\n\n-- Without type synonym instances, we're forced to manually expand out type\n-- synonyms in the typeclass head.\ninstance MyClass [Int]\n\n-- With it GHC will do this for us automatically. Type synonyms still need to\n-- be fully applied.\ninstance MyClass IntList\n```","tags":["Type-Classes"]},{"title":"Haskell-Laziness","url":"/blog/2019/10/16/Haskell-Laziness/","content":"> [原文](http://dev.stephendiehl.com/hask/#laziness)\n\n又是一个泼了很多墨水的话题。在`Haskell`领域中有一个正在进行的关于`lazy`(懒惰)和`strict`(严格)评估之间的折衷的讨论，并且有一些细微的论据认为两种范式都應該是默认的。\n`Haskell`采用一种混合方法，允许在需要时进行严格的评估，默认情况下使用惰性。不用说，我们总能找到严格评估比懒惰评估表现出更糟糕行为的例子，反之亦然。\n\n总体上，惰性评估的主要优势在于，可以对无界和有界数据结构进行操作的算法可以使用相同的类型签名，并且无需额外重构其逻辑或强制进行中间计算就可以组成该算法。\n\n试图将懒惰添加到严格的评估模型上的语言通常会将算法类别分为两类: 一类是手动调整以使用`unbounded`(无界)结构的算法，另一类是在`bounded`(有界)结构上操作的算法。\n\n在严格的语言中，惰性和严格处理之间的`mixing`(混合)和匹配常常需要在内存中`manifesting`(显示)大型中间结构，而这样的组合只`just work`(适用于)惰性语言。\n\n由于`Haskell`是唯一一种在设计空间中真正探索这一点的语言，从而达到了工业級的程度；关于惰性评估的知识并没有被广泛地吸收到集体程序员意识中，而且对于新手来说往往是不直观的。这并没有反映在模型本身，仅仅反映在需要更多的`instruction material`(指导材料)和优化惰性编译器的研究上。\n\n`Haskell`的`paradox`(悖论)在于，它探索了许多明确的独特思想(懒惰、`purity`(纯度)、`typeclasses`(类型类))，以至于很难将任何一种思想的讨论从整个实现的`gestalt`(格式塔)中分离出来。\n\n請看:\n* [Oh My Laziness!](http://alpmestan.com/posts/2013-10-02-oh-my-laziness.html)\n* [Reasoning about Laziness](http://www.slideshare.net/tibbe/reasoning-about-laziness)\n* [Lazy Evaluation of Haskell](http://www.vex.net/~trebla/haskell/lazy.xhtml)\n* [More Points For Lazy Evaluation](http://augustss.blogspot.hu/2011/05/more-points-for-lazy-evaluation-in.html)\n* [How Lazy Evaluation Works in Haskell](https://hackhands.com/lazy-evaluation-works-haskell/)\n\n### Strictness\n`lambda`演算有几种评估模型:\n\n* **Strict**     如果在函数主体之前评估所有参数，则评估是严格的。\n* **Non-strict** 如果在输入函数主体之前不一定要对参数进行求值，则评估是非严格的。\n\n这些想法产生了几种模型，`Haskell`本身使用`call-by-need`模型。\n```haskell\nModel\t        Strictness\t    Description\nCall-by-value\tStrict\t        参数在進入函数前評估\nCall-by-name\tNon-strict\t    传递的参数未評估\nCall-by-need\tNon-strict\t    传递的参数未評估，但表达式只求值一次(共享)\n```\n### Seq and WHNF\n如果最外层的构造函数或`lambda`不能进一步`reduced`(减少)，则称该`term`(项)为`weak head normal-form`(弱头范式)。\n\n如果一个`term`(术语)是完全求值的，并且其中包含的所有子表达式和`thunk`都是求值的，则该术语称为`normal form`(标准形式)。\n```haskell\n-- In Normal Form\n42\n(2, \"foo\")\n\\x -> x + 1\n\n-- Not in Normal Form\n1 + 2\n(\\x -> x + 1) 2\n\"foo\" ++ \"bar\"\n(1 + 1, \"foo\")\n\n-- In Weak Head Normal Form\n(1 + 1, \"foo\")\n\\x -> 2 + 2\n'f' : (\"oo\" ++ \"bar\")\n\n-- Not In Weak Head Normal Form\n1 + 1\n(\\x -> x + 1) 2\n\"foo\" ++ \"bar\"\n```\n在`Haskell`中，`normal evaluation`(普通的求值)只发生在`Core`中`case`语句的外部构造函数处。\n如果在`List`上进行模式匹配，则不会隐式强制`List`中的所有值。\n数据结构中的元素只能由最外部的构造函数`evaluated`(计算)。\n例如，要`evaluate`(评估)`List`的长度，我们只需要仔细检查外部`Cons`构造函数，而不用考虑它们的内部值。\n```haskell\nλ: length [undefined, 1]\n2\n\nλ: head [undefined, 1]\nPrelude.undefined\n\nλ: snd (undefined, 1)\n1\n\nλ: fst (undefined, 1)\nPrelude.undefined\n```\n例如，在惰性语言中，下列程序即使包含`diverging terms`(发散项)也会终止。\n```haskell\nignore :: a -> Int\nignore x = 0\n\nloop :: a\nloop = loop\n\nmain :: IO ()\nmain = print $ ignore loop\n```\n在像`OCaml`这样的严格语言中(暂时忽略其`suspensions`(暂停/悬挂))，同一程序有所不同。\n```OCaml\nlet ignore x = 0;; \nlet rec loop a = loop a;;\n\nprint_int (ignore (loop ()));\n```\n在`Haskell`中，创建了一个`thunk`以代表未评估的计算。\n对`thunk`的评估称为`forcing`(强迫)`thunk`。\n结果是一個`update`(更新)，一个引用透明的效果，该效果用计算值替换了`thunk`的内存表示形式。基本思想是，一個`thunk`仅更新一次(尽管它可能在多线程环境中同时被强制执行)，并且其结果值在随后引用时被共享。\n\n命令`:sprint`可用于`introspect`(反省)表达式中未评估的`thunks`的状态，而无需强制执行评估。例如:\n```haskell\nλ: let a = [1..] :: [Integer]\nλ: let b = map (+ 1) a\n\nλ: :sprint a\na = _s\nλ: :sprint b\nb = _\nλ: a !! 4\n5\nλ: :sprint a\na = 1 : 2 : 3 : 4 : 5 : _\nλ: b !! 10\n12\nλ: :sprint a\na = 1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : 10 : 11 : _\nλ: :sprint b\nb = _ : _ : _ : _ : _ : _ : _ : _ : _ : _ : 12 : _\n```\n在计算`thunk`时，它的内存表示被一种称为`blackhole`(黑洞)的特殊形式所代替，它表示计算正在进行，并允许在计算可能依赖于自身完成时出现短路。这是`GHC`运行时一些更微妙的细节的实现。\n\n`seq`函数通过要求在对第二个参数求值之前对第一个参数求值到`WHNF`，引入了对两个`terms`(项)的顺序求值的人为依赖。\n`seq`函数的实现是`GHC`的一个实现细节。\n```haskell\nseq :: a -> b -> b\n\n⊥ `seq` a = ⊥\na `seq` b = b\n```\n众所周知，臭名昭著的`foldl`在不小心使用时会泄漏空间，而且没有应用几个编译器优化。严格的`foldl'`变体使用`seq`来克服这个问题。\n```haskell\nfoldl :: (a -> b -> a) -> a -> [b] -> a\nfoldl f z [] = z\nfoldl f z (x:xs) = foldl f (f z x) xs\nfoldl' :: (a -> b -> a) -> a -> [b] -> a\nfoldl' _ z [] = z\nfoldl' f z (x:xs) = let z' = f z x in z' `seq` foldl' f z' xs\n```\n实际上，`strictness analyzer`(严格性分析器)和`-O2`上的`inliner`(内联)的结合将确保只要函数在调用站点上是`inlinable`(可以內联)的，就會使用`foldl`的严格变体，因此通常不需要手动使用`foldl'`。\n\n需要特别注意的是，`GHCi`的运行没有应用任何优化，因此在`GHCi`中性能较差的同一程序在使用`GHC`编译时可能没有相同的性能特征。\n\n### Strictness Annotations\n`BangPatterns`扩展允许使用另一种语法来强制将函数的参数包装在`seq`中。参数上的`bang`运算符会在执行模式匹配之前强制将其评估结果转换为弱头范式。这可以用于在整个递归中保持对特定参数的评估，而不用创建庞大的`trunks`链。\n```haskell\n{-# LANGUAGE BangPatterns #-}\n\nsum :: Num a => [a] -> a\nsum = go 0\n  where\n    go !acc (x:xs) = go (acc + x) xs\n    go  acc []     = acc\n```\n这将被有效地分解为以下代码:\n```haskell\nsum :: Num a => [a] -> a\nsum = go 0\n  where\n    go acc _ | acc `seq` False = undefined\n    go acc (x:xs)              = go (acc + x) xs\n    go acc []                  = acc\n```\n对`seq'd`参数的函数应用非常常见，以至于它有一个特殊的运算符。\n```haskell\n($!) :: (a -> b) -> a -> b\nf $! x  = let !vx = x in f vx\n```\n\n### Strict Haskell\n从`GHC 8.0`开始，`strictness`(严格性)注释可以自动应用于模块中的所有定义。在以前的版本中，必须通过所有`sites`(站点)上的显式`syntactic`语法注释进行定义。\n\n#### StrictData\n启用`StrictData`会使默认情况下，对其启用的任何模块的构造函数字段都体现為`strict`(严格)。\n```haskell\n{-# LANGUAGE StrictData #-}\n\ndata Employee = Employee\n  { name :: T.Text\n  , age :: Int\n  }\n```\n等效于:\n```haskell\ndata Employee = Employee\n  { name :: !T.Text\n  , age :: !Int\n  }\n```\n#### Strict\n`Strict`意味着`-XStrictData`，并将`strictness annotations`(严格性注释)扩展到函数的所有参数。\n```haskell\nf x y = x + y\n```\n等效于带有显式`bang`模式的以下函数声明：\n```haskell\nf !x !y = x + y\n```\n在模块级别，这有效地使`Haskell`成为一种`call-by-value`语言，但有一些警告。\n现在，对函数的所有参数进行了显式求值，并且该模块中构造函数中的所有数据在构造时都处于`head normal form`。\n但是，在语言指南中有一些细微之处可以更好地解释。\n\n請看: [Strict Extensions](https://downloads.haskell.org/~ghc/master/users-guide//glasgow_exts.html?highlight=typefamilydependencies#strict-by-default-pattern-bindings)\n\n### Deepseq\n很多时候，出于性能的原因，我们需要对数据结构进行深入评估，使其具有`normal form`(正常形式)，而不会对任何`terms`(术语)进行评估。`deepseq`库执行此任务。\n\n`NFData`类型类(普通形式数据)允许我们跨任何本身实现`NFData`的子类型对结构的所有元素进行`seq`。\n```haskell\nclass NFData a where\n  rnf :: a -> ()\n  rnf a = a `seq` ()\n\ndeepseq :: NFData a => a -> b -> b\n($!!) :: (NFData a) => (a -> b) -> a -> b\ninstance NFData Int\ninstance NFData (a -> b)\n\ninstance NFData a => NFData (Maybe a) where\n    rnf Nothing  = ()\n    rnf (Just x) = rnf x\n\ninstance NFData a => NFData [a] where\n    rnf [] = ()\n    rnf (x:xs) = rnf x `seq` rnf xs\n[1, undefined] `seq` ()\n-- ()\n\n[1, undefined] `deepseq` ()\n-- Prelude.undefined\n```\n为了强制对数据结构本身进行充分评估，我们在`deepseq`的两个位置共享相同的参数。\n```haskell\nforce :: NFData a => a -> a\nforce x = x `deepseq` x\n```\n\n### Irrefutable Patterns (无可辩驳的模式)\n惰性模式不`require`(需要)外部构造函数上的匹配，而是根据需要惰性地调用值的访问器。在存在`bottom`的情况下，我们會在使用地点失败，而不是在外部模式匹配。\n```haskell\nf :: (a, b) -> Int\nf (a,b) = const 1 a\n\ng :: (a, b) -> Int\ng ~(a,b) = const 1 a\n\n-- λ: f undefined\n-- *** Exception: Prelude.undefined\n-- λ: g undefined\n-- 1\n\nj :: Maybe t -> t\nj ~(Just x) = x\n\nk :: Maybe t -> t\nk (Just x) = x\n\n-- λ: j Nothing\n-- *** Exception: src/05-laziness/lazy_patterns.hs:15:1-15: Irrefutable pattern failed for pattern (Just x)\n--\n-- λ: k Nothing\n-- *** Exception: src/05-laziness/lazy_patterns.hs:18:1-14: Non-exhaustive patterns in function k\n```","tags":["Laziness"]},{"title":"Haskell-Data-Structures","url":"/blog/2019/10/16/Haskell-Data-Structures/","content":"> [原文](http://dev.stephendiehl.com/hask/#data-structures)\n\n### Map\n\n![](img/map.png)\n\n`map`是将`Ord`键的任何实例映射到任何类型的值的关联数组。\n```haskell\nimport qualified Data.Map as Map\n\nkv :: Map.Map Integer String\nkv = Map.fromList [(1, \"a\"), (2, \"b\")]\n\nlkup :: Integer -> String -> String\nlkup key def =\n  case Map.lookup key kv of\n    Just val -> val\n    Nothing  -> def\n```\n\n### Tree\n![](img/tree.png)\n\n```haskell\nimport Data.Tree\n\n{-\n\n   A\n  / \\\n B   C\n    / \\\n   D   E\n\n-}\n\ntree :: Tree String\ntree = Node \"A\" [Node \"B\" [], Node \"C\" [Node \"D\" [], Node \"E\" []]]\n\npostorder :: Tree a -> [a]\npostorder (Node a ts) = elts ++ [a]\n  where elts = concat (map postorder ts)\n\npreorder :: Tree a -> [a]\npreorder (Node a ts) = a : elts\n  where elts = concat (map preorder ts)\n\nex1 = drawTree tree\nex2 = drawForest (subForest tree)\nex3 = flatten tree\nex4 = levels tree\nex5 = preorder tree\nex6 = postorder tree\n```\n\n### Set\n\n![](img/set.png)\n\n`Sets`是一种无序的数据结构，允许任何类型的`Ord`值，并保证结构中的唯一性。尽管它们具有相同的名称，但它们与`Set`的数学概念并不相同。\n```haskell\nimport qualified Data.Set as Set\n\nset :: Set.Set Integer\nset = Set.fromList [1..1000]\n\nmemtest :: Integer -> Bool\nmemtest elt = Set.member elt set\n```\n\n### Vector\n\n![](img/vector.png)\n\n向量是高性能的一维数组，有六种变体，对于以下类型的可变和不可变变体各有两种。\n* Data.Vector\n* Data.Vector.Storable\n* Data.Vector.Unboxed\n\n向量最显着的特征是通过`(!)`进行恒定时间的内存访问，以及在生成令人惊讶的最佳代码的`fusion`(融合)框架之上的各种高效的`map`,`fold`和`scan`操作。\n```haskell\nfromList :: [a] -> Vector a\ntoList :: Vector a -> [a]\n(!) :: Vector a -> Int -> a\nmap :: (a -> b) -> Vector a -> Vector b\nfoldl :: (a -> b -> a) -> a -> Vector b -> a\nscanl :: (a -> b -> a) -> a -> Vector b -> Vector a\nzipWith :: (a -> b -> c) -> Vector a -> Vector b -> Vector c\niterateN :: Int -> (a -> a) -> a -> Vector a\nimport Data.Vector.Unboxed as V\n\nnorm ::  Vector Double -> Double\nnorm = sqrt . V.sum . V.map (\\x -> x*x)\n\nexample1 :: Double\nexample1 = norm $ V.iterateN 100000000 (+1) 0.0\n```\n請看:\n* [Numerical Haskell: A Vector Tutorial](http://wiki.haskell.org/Numeric_Haskell:_A_Vector_Tutorial)\n\n\n### Mutable Vectors\n\n![](img/mu-vector.png)\n\n```haskell\nfreeze :: MVector (PrimState m) a -> m (Vector a)\nthaw :: Vector a -> MVector (PrimState m) a\n```\n在`IO monad`中，我们可以以恒定的时间读写对可变向量执行任意读写。必要时，可以使用`freeze`/`thaw`函數从`MVector`创建静态`Vector`。\n```haskell\nimport GHC.Prim\nimport Control.Monad\nimport Control.Monad.ST\nimport Control.Monad.Primitive\n\nimport Data.Vector.Unboxed (freeze)\nimport Data.Vector.Unboxed.Mutable\nimport qualified Data.Vector.Unboxed as V\n\nexample :: PrimMonad m => m (V.Vector Int)\nexample = do\n  v <- new 10\n  forM_ [0..9] $ \\i ->\n     write v i (2*i)\n  freeze v\n\n-- vector computation in IO\nvecIO :: IO (V.Vector Int)\nvecIO = example\n\n-- vector computation in ST\nvecST :: ST s (V.Vector Int)\nvecST = example\n\n\nmain :: IO ()\nmain = do\n  vecIO >>= print\n  print $ runST vecST\n```\n向量库本身通常会对索引操作进行边界检查，以防止内存损坏。通过使用`boundschecks cabal`标志进行编译，可以在库级别启用或禁用此功能。\n\n### Unordered-Containers(无序容器)\n\n![](img/unordered-containers.png)\n\n```haskell\nfromList :: (Eq k, Hashable k) => [(k, v)] -> HashMap k v\nlookup :: (Eq k, Hashable k) => k -> HashMap k v -> Maybe v\ninsert :: (Eq k, Hashable k) => k -> v -> HashMap k v -> HashMap k v\n```\n`HashMap`和`HashSet`都是纯函數性数据结构，是`containers`(容器)等价物的替代品，但具有更高效的空间和时间性能。此外，所有存储的元素都必须有一个`Hashable`实例。\n```haskell\nimport qualified Data.HashSet as S\nimport qualified Data.HashMap.Lazy as M\n\nexample1 :: M.HashMap Int Char\nexample1 = M.fromList $ zip [1..10] ['a'..]\n\nexample2 :: S.HashSet Int\nexample2 = S.fromList [1..10]\n```\n請看:\n* [Announcing Unordered Containers](http://blog.johantibell.com/2012/03/announcing-unordered-containers-02.html)\n\n\n### Hashtables\n\n![](img/hashtable.png)\n\n`Hashtables`在`ST`或`IO monad`中提供高效查找的哈希表。\n\n```haskell\nimport Prelude hiding (lookup)\n\nimport Control.Monad.ST\nimport Data.HashTable.ST.Basic\n\n-- Hashtable parameterized by ST \"thread\"\ntype HT s = HashTable s String String\n\nset :: ST s (HT s)\nset = do\n  ht <- new\n  insert ht \"key\" \"value1\"\n  return ht\n\nget :: HT s -> ST s (Maybe String)\nget ht = do\n  val <- lookup ht \"key\"\n  return val\n\nexample :: Maybe String\nexample = runST (set >>= get)\nnew :: ST s (HashTable s k v)\ninsert :: (Eq k, Hashable k) => HashTable s k v -> k -> v -> ST s ()\nlookup :: (Eq k, Hashable k) => HashTable s k v -> k -> ST s (Maybe v)\n```\n\n### Graphs\n\n`containers`库中的`Graph`模块是用于处理有向图的有点过时的`API`。\n一点点的数据包装使它更易于使用。该库不一定非常适合于大型图论操作，但非常适合用于需要解析模块定义图的强连接组件的类型检查器中。\n```haskell\nimport Data.Tree\nimport Data.Graph\n\ndata Grph node key = Grph\n  { _graph :: Graph\n  , _vertices :: Vertex -> (node, key, [key])\n  }\n\nfromList :: Ord key => [(node, key, [key])] -> Grph node key\nfromList = uncurry Grph . graphFromEdges'\n\nvertexLabels :: Functor f => Grph b t -> (f Vertex) -> f b\nvertexLabels g = fmap (vertexLabel g)\n\nvertexLabel :: Grph b t -> Vertex -> b\nvertexLabel g = (\\(vi, _, _) -> vi) . (_vertices g)\n\n-- 拓扑排序图\ntopo' :: Grph node key -> [node]\ntopo' g = vertexLabels g $ topSort (_graph g)\n\n-- 图的强连接组件\nscc' :: Grph node key -> [[node]]\nscc' g = fmap (vertexLabels g . flatten) $ scc (_graph g)\n```\n因此，例如，我们可以构造一个简单的图形:\n![](img/graph001.png)\n\n```haskell\nex1 :: [(String, String, [String])]\nex1 = [\n    (\"a\",\"a\",[\"b\"]),\n    (\"b\",\"b\",[\"c\"]),\n    (\"c\",\"c\",[\"a\"])\n  ]\n\nts1 :: [String]\nts1 = topo' (fromList ex1)\n-- [\"a\",\"b\",\"c\"]\n\nsc1 :: [[String]]\nsc1 = scc' (fromList ex1)\n-- [[\"a\",\"b\",\"c\"]]\n```\n\n或具有两个紧密相连的子图:\n\n![](img/graph002.png)\n\n```haskell\nex2 :: [(String, String, [String])]\nex2 = [\n    (\"a\",\"a\",[\"b\"]),\n    (\"b\",\"b\",[\"c\"]),\n    (\"c\",\"c\",[\"a\"]),\n\n    (\"d\",\"d\",[\"e\"]),\n    (\"e\",\"e\",[\"f\", \"e\"]),\n    (\"f\",\"f\",[\"d\", \"e\"])\n  ]\n\nts2 :: [String]\nts2 = topo' (fromList ex2)\n-- [\"d\",\"e\",\"f\",\"a\",\"b\",\"c\"]\n\nsc2 :: [[String]]\nsc2 = scc' (fromList ex2)\n-- [[\"d\",\"e\",\"f\"],[\"a\",\"b\",\"c\"]]\n```\n請看:\n* [GraphSCC](http://hackage.haskell.org/package/GraphSCC)\n\n### Graph Theory(图论)\n\n`fgl`库提供了更有效的图结构和各种常见的图论操作。例如，在编译器设计的控制流分析中，计算图的优势边界经常出现。\n```haskell\nimport qualified Data.Graph.Inductive as G\n\ncyc3 :: G.Gr Char String\ncyc3 = G.buildGr\n       [([(\"ca\",3)],1,'a',[(\"ab\",2)]),\n                ([],2,'b',[(\"bc\",3)]),\n                ([],3,'c',[])]\n\n-- Loop query\nex1 :: Bool\nex1 = G.hasLoop x\n\n-- Dominators\nex2 :: [(G.Node, [G.Node])]\nex2 = G.dom x 0\nx :: G.Gr Int ()\nx = G.insEdges edges gr\n  where\n  gr = G.insNodes nodes G.empty\n  edges = [(0,1,()), (0,2,()), (2,1,()), (2,3,())]\n  nodes = zip [0,1 ..] [2,3,4,1]\n```\n![](img/graph003.png)\n\n### DList\n\n![](img/dList.png)\n\n`dlist`是一种类似于列表的结构，它针对`O(1)`追加操作进行了优化，在内部使用列表结构的`Church`编码。它特别适合于仅`append`的操作，并且在显示整个结构时只需要访问它。它特别适合在`Writer monad`上使用。\n\n```haskell\nimport Data.DList\nimport Control.Monad\nimport Control.Monad.Writer\n\nlogger :: Writer (DList Int) ()\nlogger = replicateM_ 100000 $ tell (singleton 0)\n```\n\n### Sequence\n\n序列数据结构在结构上与列表类似，但针对`append`/`prepend`操作和`traversal`(遍历)进行了优化。\n```haskell\nimport Data.Sequence\n\na :: Seq Int\na = fromList [1,2,3]\n\na0 :: Seq Int\na0 = a |> 4\n-- [1,2,3,4]\n\na1 :: Seq Int\na1 = 0 <| a\n-- [0,1,2,3]\n```\n\n### Fingertree(指状树)\n> TODO\n\n請看:\n* [fingertree](https://hackage.haskell.org/package/fingertree)\n\n### Vault\n> TODO\n\n請看:\n* [vault](https://hackage.haskell.org/package/vault)","tags":["Structures"]},{"title":"Haskell-Mathematics","url":"/blog/2019/10/16/Haskell-Mathematics/","content":"> [原文](http://dev.stephendiehl.com/hask/#mathematics)\n\n### Numeric Tower(数值塔)\n\n`Haskell`的数值塔是不寻常的，对于新手来说，这是一些困惑的根源。\n \n`Haskell`是少数几种包含静态类型的重载`literals`(文字)而没有其他语言中常见的`coercions`(强制)机制的语言之一。\n\n更令人困惑的是，`Haskell`中的`numerical literals`(数值文字)被从`numeric`类型类分解为一个函数，该函数产生一个多态值，该值可以在`call-site`(调用站点)实例化为`Num`或`Fractional`类型类的任何实例，取决于推断的类型。\n\n用一个直白的比喻，我们实际上是将对象放置在孔中，并且孔的大小和形状限定了放置在孔中的对象。这与其他语言非常不同，在其他语言中，像`2.718`这样的数字文字在编译器中被硬编码为特定类型(`double`或`something`)，并且在运行时根据需要将該值强制转换为更小的值或更大的值。\n```haskell\n42 :: Num a => a\nfromInteger (42 :: Integer)\n\n2.71 :: Fractional a => a\nfromRational (2.71 :: Rational)\n```\n`numeric`(数值)类型类层次结构的定义如下:\n```haskell\nclass Num a\nclass (Num a, Ord a) => Real a\nclass Num a => Fractional a\nclass (Real a, Enum a) => Integral a\nclass (Real a, Fractional a) => RealFrac a\nclass Fractional a => Floating a\nclass (RealFrac a, Floating a) => RealFloat a\n```\n\n![](img/img01.png)\n\n具体的数字类型(`from`: 左列 `to`: 顶行)之间的转换是通过几个通用函数完成的。\n\n![](img/img02.png)\n\n### Integer\n\n`GHC`中的`Integer`类型由`GMP`(`libgmp`)任意精度算术库实现。\n与`Int`类型不同，`Integer`值的大小仅受可用内存的限制。\n\n最值得注意的是，`libgmp`是动态链接已编译`Haskell`二进制文件的少数几个库之一。\n\n`integer-simple`是一個可選的库，它可链接，可以用來代替`libgmp`。\n\n請看:\n* [GHC, primops and exorcising GMP](http://www.well-typed.com/blog/32/)\n\n### Complex\n\n`Haskell`支持通过`Data.Complex`模块中的`Complex`数据类型使用复数进行算术运算。\n\n第一个参数是实部，第二个参数是虚部。\n\n该类型具有单个参数，并从该参数的类型继承其`numerical`(数值)类型类组件(`Num`, `Fractional`, `Floating`)。\n\n```haskell\n-- 1 + 2i\nlet complex = 1 :+ 2\ndata Complex a = a :+ a\nmkPolar :: RealFloat a => a -> a -> Complex a\n```\n仅当`Complex`的参数是`RealFloat`的实例时，才定义`Complex`的`Num`实例。\n```haskell\nλ: 0 :+ 1\n0 :+ 1 :: Complex Integer\n\nλ: (0 :+ 1) + (1 :+ 0)\n1.0 :+ 1.0 :: Complex Integer\n\nλ: exp (0 :+ 2 * pi)\n1.0 :+ (-2.4492935982947064e-16) :: Complex Double\n\nλ: mkPolar 1 (2*pi)\n1.0 :+ (-2.4492935982947064e-16) :: Complex Double\n\nλ: let f x n = (cos x :+ sin x)^n\nλ: let g x n = cos (n*x) :+ sin (n*x)\n```\n\n### Scientific\n\n`Scientific`提供使用科学计数法表示的任意精度数字。构造函数采用任意大小的`Integer`参数表示数字，并使用`Int`表示指数。另外，该值可以从字符串中解析，也可以从`Double`/`Float`中强制转换。\n```haskell\nscientific :: Integer -> Int -> Scientific\nfromFloatDigits :: RealFloat a => a -> Scientific\nimport Data.Scientific\n\nc, h, g, a, k :: Scientific\nc = scientific 299792458 (0)   -- 光速\nh = scientific 662606957 (-42) -- 普朗克常数\ng = scientific 667384    (-16) -- 引力常数\na = scientific 729735257 (-11) -- 优良的结构常数\nk = scientific 268545200 (-9)  -- Khinchin常数\n\ntau :: Scientific\ntau = fromFloatDigits (2*pi)\n\nmaxDouble64 :: Double\nmaxDouble64 = read \"1.7976931348623159e308\"\n-- Infinity 无穷\n\nmaxScientific :: Scientific\nmaxScientific = read \"1.7976931348623159e308\"\n-- 1.7976931348623159e308\n```\n\n### Statistics(统计)\n\n```haskell\nimport Data.Vector\nimport Statistics.Sample\n\nimport Statistics.Distribution.Normal\nimport Statistics.Distribution.Poisson\nimport qualified Statistics.Distribution as S\n\ns1 :: Vector Double\ns1 = fromList [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\ns2 :: PoissonDistribution\ns2 = poisson 2.5\n\ns3 :: NormalDistribution\ns3 = normalDistr mean stdDev\n  where\n    mean   = 1\n    stdDev = 1\n\ndescriptive = do\n  print $ range s1\n  -- 9.0\n  print $ mean s1\n  -- 5.5\n  print $ stdDev s1\n  -- 3.0276503540974917\n  print $ variance s1\n  -- 8.25\n  print $ harmonicMean s1\n  -- 3.414171521474055\n  print $ geometricMean s1\n  -- 4.5287286881167645\n\ndiscrete = do\n  print $ S.cumulative s2 0\n  -- 8.208499862389884e-2\n  print $ S.mean s2\n  -- 2.5\n  print $ S.variance s2\n  -- 2.5\n  print $ S.stdDev s2\n  -- 1.5811388300841898\n\ncontinuous = do\n  print $ S.cumulative s3 0\n  -- 0.15865525393145707\n  print $ S.quantile s3 0.5\n  -- 1.0\n  print $ S.density s3 0\n  -- 0.24197072451914334\n  print $ S.mean s3\n  -- 1.0\n  print $ S.variance s3\n  -- 1.0\n  print $ S.stdDev s3\n  -- 1.0\n```\n\n### Constructive Reals(建设性领域)\n\n除了使用有限精度浮点数对实数建模之外，我们还可以使用`Num`运算，当执行算术或超越函数之类的运算时，该运算符在内部操作表达式的幂级数展开，而在执行中间计算时不会失去精度。\n\n然后，我们简单地切出固定数量的项，并将结果数近似为所需的精度。这种方法并非没有局限和警告, 特别是它可能会出现`diverge`(分歧)。\n```haskell\nexp(x)    = 1 + x + 1/2*x^2 + 1/6*x^3 + 1/24*x^4 + 1/120*x^5 ...\nsqrt(1+x) = 1 + 1/2*x - 1/8*x^2 + 1/16*x^3 - 5/128*x^4 + 7/256*x^5 ...\natan(x)   = x - 1/3*x^3 + 1/5*x^5 - 1/7*x^7 + 1/9*x^9 - 1/11*x^11 ...\npi        = 16 * atan (1/5) - 4 * atan (1/239)\nimport Data.Number.CReal\n\n-- algebraic\nphi :: CReal\nphi = (1 + sqrt 5) / 2\n\n-- transcendental\nramanujan :: CReal\nramanujan = exp (pi * sqrt 163)\n\nmain :: IO ()\nmain = do\n  putStrLn $ showCReal 30 pi\n  -- 3.141592653589793238462643383279\n  putStrLn $ showCReal 30 phi\n  -- 1.618033988749894848204586834366\n  putStrLn $ showCReal 15 ramanujan\n  -- 262537412640768743.99999999999925\n```\n\n### SAT Solvers\n\n一组称为可满足性问题的约束问题出现在从类型检查到包管理的许多不同学科中。简单地说，一个可满足性问题试图从一系列变量中找到`conjunctions`(连词)和`disjunctions`(析词)的解。例如:\n```haskell\n(A v ¬B v C) ∧ (B v D v E) ∧ (D v F)\n```\n要使用`picosat`库解决此问题，可以将其写入`zero-terminated`整数列表，并根据数与变量的关系`fed to`(喂給)求解器:\n```haskell\n1 -2 3  -- (A v ¬B v C)\n2 4 5   -- (B v D v E)\n4 6     -- (D v F)\nimport Picosat\n\nmain :: IO [Int]\nmain = do\n  solve [[1, -2, 3], [2,4,5], [4,6]]\n  -- Solution [1,-2,3,4,5,6]\n```\n`SAT`求解器本身可以用来解决以这种形式存在的数以百万计的变量的可满足性问题，并且经过微调。\n\n請看:\n* [picosat](http://hackage.haskell.org/package/picosat-0.1.1)\n\n### SMT Solvers\n\n将`SAT`问题推广到包含谓词的其他理论中，就产生了非常复杂的`Satisfiability Modulo Theory`(可满足性模理论)问题。\n现有的`SMT`求解器是非常复杂的项目(通常由大型机构提供资金)，通常必须通过外部函數接口或称为`SMT-lib`的通用接口来调用。\n\n`Haskell`中最常用的两个是斯坦福大学的`cvc4`和微软研究院的`z3`。\n\n作为一个例子，下面是如何解决一个简单的[cryptarithm](https://en.wikipedia.org/wiki/Verbal_arithmetic)(密码算法):\n```haskell\nM O N A D\n+ B U R R I T O\n= B A N D A I D\n```\n使用`SBV`庫:\n```haskell\nimport Data.Foldable\nimport Data.SBV\n\n-- | val [4,2] == 42\nval :: [SInteger] -> SInteger\nval = foldr1 (\\d r -> d + 10*r) . reverse\n\npuzzle :: Symbolic SBool\npuzzle = do\n  ds@[b,u,r,i,t,o,m,n,a,d] <- sequenceA [ sInteger [v] | v <- \"buritomnad\" ]\n  constrain $ allDifferent ds\n  for_ ds $ \\d -> constrain $ inRange d (0,9)\n  pure $    val [b,u,r,r,i,t,o]\n          + val     [m,o,n,a,d]\n        .== val [b,a,n,d,a,i,d]\n```\n让我们看一下所有可能的解决方案:\n```haskell\nλ: allSat puzzle\nSolution #1:\n  b = 4 :: Integer\n  u = 1 :: Integer\n  r = 5 :: Integer\n  i = 9 :: Integer\n  t = 7 :: Integer\n  o = 0 :: Integer\n  m = 8 :: Integer\n  n = 3 :: Integer\n  a = 2 :: Integer\n  d = 6 :: Integer\nThis is the only solution.这是唯一的解决方案。\n```\n請看:\n* [sbv](http://leventerkok.github.io/sbv/)\n* [cvc4](http://cvc4.cs.nyu.edu/web/)\n* [z3](http://z3.codeplex.com/)\n\n### Z3\n\n> TODO\n\n請看:\n* [z3](https://hackage.haskell.org/package/z3)","tags":["Mathematics"]},{"title":"Haskell-FFI","url":"/blog/2019/10/16/Haskell-FFI/","content":"> 这是高级部分，编写Haskell通常不需要[FFI](http://dev.stephendiehl.com/hask/#ffi)知识。\n\n### Pure Functions\n用原始类型包装纯`C`函数很简单.\n```haskell\n/* $(CC) -c simple.c -o simple.o */\n\nint example(int a, int b)\n{\n  return a + b;\n}\n-- ghc simple.o simple_ffi.hs -o simple_ffi\n{-# LANGUAGE ForeignFunctionInterface #-}\n\nimport Foreign.C.Types\n\nforeign import ccall safe \"example\" example\n    :: CInt -> CInt -> CInt\n\nmain = print (example 42 27)\n```\n\n### Storable Arrays\n存在一个`Storable`类型类，可用于提供对`Haskell`值的底层的内存的低级访问。\n`Haskell`中的`Ptr`对象的行为很像`C`指针，尽管它们的算术仅以字节為單位，而不是与指针关联的类型的大小(这与`C`有所不同)。\n\n`Prelude`为大多数基本类型以及`Foreign.Storable`模块中的类型定义了`Storable`接口。\n```haskell\nclass Storable a where\n  sizeOf :: a -> Int\n  alignment :: a -> Int\n  peek :: Ptr a -> IO a\n  poke :: Ptr a -> a -> IO ()\n```\n要将数组从`Haskell`传递到`C`，我们可以再次使用`Storable Vector`和一些不安全的操作来获取指向可以传递给`C`的底层数据的外部指针。\n一旦我们进入了`C`土地，没有什么可以保护我们免受邪恶之举的侵害！\n```C\n/* $(CC) -c qsort.c -o qsort.o */\nvoid swap(int *a, int *b)\n{\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nvoid sort(int *xs, int beg, int end)\n{\n    if (end > beg + 1) {\n        int piv = xs[beg], l = beg + 1, r = end;\n\n        while (l < r) {\n            if (xs[l] <= piv) {\n                l++;\n            } else {\n                swap(&xs[l], &xs[--r]);\n            }\n        }\n\n        swap(&xs[--l], &xs[beg]);\n        sort(xs, beg, l);\n        sort(xs, r, end);\n    }\n}\n```\n```haskell\n-- ghc qsort.o ffi.hs -o ffi\n{-# LANGUAGE ForeignFunctionInterface #-}\n\nimport Foreign.Ptr\nimport Foreign.C.Types\n\nimport qualified Data.Vector.Storable as V\nimport qualified Data.Vector.Storable.Mutable as VM\n\nforeign import ccall safe \"sort\" qsort\n    :: Ptr a -> CInt -> CInt -> IO ()\n\nmain :: IO ()\nmain = do\n  let vs = V.fromList ([1,3,5,2,1,2,5,9,6] :: [CInt])\n  v <- V.thaw vs\n  VM.unsafeWith v $ \\ptr -> do\n    qsort ptr 0 9\n  out <- V.freeze v\n  print out\n```\n可以限制来自`C`特定头文件的外部函数的名称。\n```haskell\nforeign import ccall unsafe \"stdlib.h malloc\"\n    malloc :: CSize -> IO (Ptr a)\n```\n在函数名称前加上`＆`，使我们可以创建对函数指针本身的引用。\n```haskell\nforeign import ccall unsafe \"stdlib.h &malloc\"\n    malloc :: FunPtr a\n```\n\n### Function Pointers\n使用上面的`FFI`功能，将`C`函数指针传递到`Haskell`很简单，但是使用`foreign import ccall 'wrapper'`将指向`haskell`函数的函数指针反向传递到`C`又如何呢？\n```C\n#include <stdio.h>\n\nvoid invoke(void (*fn)(int))\n{\n  int n = 42;\n  printf(\"Inside of C, now we'll call Haskell.\\n\");\n  fn(n);\n  printf(\"Back inside of C again.\\n\");\n}\n```\n```haskell\n{-# LANGUAGE ForeignFunctionInterface #-}\n\nimport Foreign\nimport System.IO\nimport Foreign.C.Types(CInt(..))\n\nforeign import ccall \"wrapper\"\n  makeFunPtr :: (CInt -> IO ()) -> IO (FunPtr (CInt -> IO ()))\n\nforeign import ccall \"pointer.c invoke\"\n  invoke :: FunPtr (CInt -> IO ()) -> IO ()\n\nfn :: CInt -> IO ()\nfn n = do\n  putStrLn \"Hello from Haskell, here's a number passed between runtimes:\"\n  print n\n  hFlush stdout\n\nmain :: IO ()\nmain = do\n  fptr <- makeFunPtr fn\n  invoke fptr\n```\n将产生以下输出:\n```haskell\nInside of C, now we'll call Haskell\nHello from Haskell, here's a number passed between runtimes:\n42\nBack inside of C again.\n```","tags":["Advanced-FFI"]},{"title":"Haskell-Concurrency","url":"/blog/2019/10/16/Haskell-Concurrency/","content":"> [原文](http://dev.stephendiehl.com/hask/#concurrency)\n\n`Haskell`中关于并行性和并行性的权威参考是`Simon Marlow`的文章。本节将仅`gloss over`(掩盖)这些主题，因为在本书中对它们进行了更好的解释.\n請看:\n* [Parallel and Concurrent Programming in Haskell](http://chimera.labs.oreilly.com/books/1230000000929)\n\n```haskell\nforkIO :: IO () -> IO ThreadId\n```\n`Haskell`线程的产生极其便宜，仅使用1.5KB的`RAM`(具体取决于平台)，并且比`C`语言中的`pthread`便宜得多。调用`forkIO`106次只需不到1s即可完成。此外，`Haskell`中的函数纯度还确保即使在计算过程中也几乎可以随时终止线程而无需担心。\n\n請看:\n* [The Scheduler](https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Scheduler#TheScheduler)\n\n### Sparks\n`Haskell`中最基本的并行性`atom`是`spark`。这是对`GHC`运行时的提示: 可以并行将计算评估为`weak head normal form`(弱头范式)。\n```haskell\nrpar :: a -> Eval a\nrseq :: Strategy a\nrdeepseq :: NFData a => Strategy a\n\nrunEval :: Eval a -> a\n```\n`rpar a`产生一个独立的`spark`，该`spark`逐渐演变为`weak head normal form`，并将计算结果放入`spark`池中。\n当运行时确定有可用的`CPU`可以评估计算时，它将评估(转换)`spark`。\n如果程序的主线程是`spark`的评估器, 则`spark`被称为`fizzled`(模糊)。`Fizzling`通常是不好的，它表明逻辑或并行性策略不适用于正在评估的工作。\n\n`spark`池也被限制为(但用户可调)默认值8000(从`GHC 7.8.3`开始)。超出此限制创建的`spark`被称为`overflow`(溢出)。\n```haskell\n-- Evaluates the arguments to f in parallel before application.\npar2 f x y = x `rpar` y `rpar` f x y\n```\n`rseq`的参数在评估继续之前强制评估`spark`。\n```haskell\nAction\t    Description\n-----------------------------------------\nFizzled\t    主线程已经评估了结果值，因此无需转换spark。\nDud\tThe     已对表达式求值，将返回计算值，并且不转换spark。\nGC'd\t    spark被添加到spark池中，但是结果没有被引用，因此它被垃圾收集。\nOverflowed\t`spawning`(生成)时spark池中的空间不足。\n```\n并行运行时对于使用`spark`是必需的，并且生成的程序必须使用`-threaded`进行编译。\n另外，程序本身可以通过`-rtsopts`指定运行时选项，例如要使用的内核数量。\n```haskell\nghc -threaded -rtsopts program.hs\n./program +RTS -s N8 -- use 8 cores\n```\n通过传递`-s`标志，可以要求运行时`dump`(转储)有关`spark`评估的信息。\n```haskell\n$ ./spark +RTS -N4 -s\n\n                                    Tot time (elapsed)  Avg pause  Max pause\n  Gen  0         5 colls,     5 par    0.02s    0.01s     0.0017s    0.0048s\n  Gen  1         3 colls,     2 par    0.00s    0.00s     0.0004s    0.0007s\n\n  Parallel GC work balance: 1.83% (serial 0%, perfect 100%)\n\n  TASKS: 6 (1 bound, 5 peak workers (5 total), using -N4)\n\n  SPARKS: 20000 (20000 converted, 0 overflowed, 0 dud, 0 GC'd, 0 fizzled)\n```\n并行计算本身是在`Eval monad`中排序的，用`runEval`进行计算本身就是一个纯计算。\n```haskell\nexample :: (a -> b) -> a -> a -> (b, b)\nexample f x y = runEval $ do\n  a <- rpar $ f x\n  b <- rpar $ f y\n  rseq a\n  rseq b\n  return (a, b)\n```\n\n### Threadscope\n传递标志`-l`会生成事件日志，该事件日志可以用`threadscope`库呈现。\n```haskell\n$ ghc -O2 -threaded -rtsopts -eventlog Example.hs\n$ ./program +RTS -N4 -l\n$ threadscope Example.eventlog\n```\n![](img/img01.png)\n\n有关使用`Threadscope`解释和分析的详细指南，请参见`Simon Marlows`的`Parallel and Concurrent Programming in Haskell`。\n\n請看:\n* [Performance profiling with ghc-events-analyze](http://www.well-typed.com/blog/86/)\n\n### Strategies (策略)\n```haskell\ntype Strategy a = a -> Eval a\nusing :: a -> Strategy a -> a\n```\n`Sparks`本身构成了称为`strategies`(策略)的高级并行结构的基础，这些结构使`Spark`的创建适合所评估的计算或数据结构。\n\n例如，如果我们想同时评估一个元组的两个元素，我们可以创建一个使用`spark`来评估该元组两侧的`strategies`。\n\n```haskell\nimport Control.Parallel.Strategies\n\nparPair' :: Strategy (a, b)\nparPair' (a, b) = do\n  a' <- rpar a\n  b' <- rpar b\n  return (a', b')\n\nfib :: Int -> Int\nfib 0 = 0\nfib 1 = 1\nfib n = fib (n-1) + fib (n-2)\n\nserial :: (Int, Int)\nserial   = (fib 30, fib 31)\n\nparallel :: (Int, Int)\nparallel = runEval . parPair' $ (fib 30, fib 31)\n```\n这种模式如此频繁地出现，组合器`using`可用于等效地以`operator-like`的形式写成，这在某些方面可能更具视觉吸引力。\n```haskell\nusing :: a -> Strategy a -> a\nx `using` s = runEval (s x)\n\nparallel ::: (Int, Int)\nparallel = (fib 30, fib 31) `using` parPair\n```\n对于一个不太复杂的示例，请考虑一个并行的`parmap`，它将一个纯函数映射到一个并行的值列表上。\n```haskell\nimport Control.Parallel.Strategies\n\nparMap' :: (a -> b) -> [a] -> Eval [b]\nparMap' f [] = return []\nparMap' f (a:as) = do\n  b  <- rpar (f a)\n  bs <- parMap' f as\n  return (b:bs)\n\nresult :: [Int]\nresult = runEval $ parMap' (+1) [1..1000]\n```\n上面的函数非常有用，但是如果需要对参数的求值进行并行处理，而不仅仅是简单的弱首范式，则会破坏这些函数。\n例如，如果`rpar`的参数是一个嵌套的构造函数，我们希望将评估表达式的整个部分并行化为`normal form`(普通形式)，而不只是`outer layer`(外层)。\n因此，我们想对我们的策略进行`generalize`(概括)，以便可以将参数的评估策略作为参数传递给该策略。\n\n`Control.Parallel.Strategies`包含`rpar`的通用版本，该版本在`Eval monad`的`rpar`计算中嵌入了附加的评估逻辑。\n```haskell\nrparWith :: Strategy a -> Strategy a\n```\n现在，使用`deepseq`库，我们可以构建`rseq`的`Strategy`变体，其评估结果为`full normal form`(完整范式)。\n```haskell\nrdeepseq :: NFData a => Strategy a\nrdeepseq x = rseq (force x)\n```\n现在，我们可以创建一个采用两个策略的`higher-order`(高阶)策略，它本身会产生一个计算，该计算在被评估时在其调度中使用传递的策略。\n```haskell\nimport Control.DeepSeq\nimport Control.Parallel.Strategies\n\nevalPair :: Strategy a -> Strategy b -> Strategy (a, b)\nevalPair sa sb (a, b) = do\n  a' <- sa a\n  b' <- sb b\n  return (a', b')\n\nparPair :: Strategy a -> Strategy b -> Strategy (a, b)\nparPair sa sb = evalPair (rparWith sa) (rparWith sb)\n\nfib :: Int -> Int\nfib 0 = 0\nfib 1 = 1\nfib n = fib (n-1) + fib (n-2)\n\nserial :: ([Int], [Int])\nserial = (a, b)\n  where\n    a = fmap fib [0..30]\n    b = fmap fib [1..30]\n\nparallel :: ([Int], [Int])\nparallel = (a, b) `using` evalPair rdeepseq rdeepseq\n  where\n    a = fmap fib [0..30]\n    b = fmap fib [1..30]\n```\n这些模式与其他几种通用形式和组合器一起在`Strategies`库中实现，用于组合策略以适合许多不同的并行计算。\n```haskell\nparTraverse :: Traversable t => Strategy a -> Strategy (t a)\ndot :: Strategy a -> Strategy a -> Strategy a\n($||) :: (a -> b) -> Strategy a -> a -> b\n(.||) :: (b -> c) -> Strategy b -> (a -> b) -> a -> c\n```\n請看:\n* [Control.Concurent.Strategies](http://hackage.haskell.org/package/parallel-3.2.0.4/docs/Control-Parallel-Strategies.html)\n\n### STM\n```haskell\natomically :: STM a -> IO a\norElse :: STM a -> STM a -> STM a\nretry :: STM a\n\nnewTVar :: a -> STM (TVar a)\nnewTVarIO :: a -> IO (TVar a)\nwriteTVar :: TVar a -> a -> STM ()\nreadTVar :: TVar a -> STM a\n\nmodifyTVar :: TVar a -> (a -> a) -> STM ()\nmodifyTVar' :: TVar a -> (a -> a) -> STM ()\n```\n软件事务内存是一种保证并行计算中值原子性的技术，这样所有上下文在读写时都能看到相同的数据，保证不会导致不一致的状态。\n`Haskell`的纯度保证了`STM`内的事务是纯净的，并且在提交失败时总是可以回滚。\n```haskell\nimport Control.Monad\nimport Control.Concurrent\nimport Control.Concurrent.STM\n\ntype Account = TVar Double\n\ntransfer :: Account -> Account -> Double -> STM ()\ntransfer from to amount = do\n  available <- readTVar from\n  when (amount > available) retry\n\n  modifyTVar from (+ (-amount))\n  modifyTVar to   (+ amount)\n\n-- Threads are scheduled non-deterministically.\n-- 线程是不确定性调度的.\nactions :: Account -> Account -> [IO ThreadId]\nactions a b = map forkIO [\n     -- transfer to\n       atomically (transfer a b 10)\n     , atomically (transfer a b (-20))\n     , atomically (transfer a b 30)\n\n     -- transfer back\n     , atomically (transfer a b (-30))\n     , atomically (transfer a b 20)\n     , atomically (transfer a b (-10))\n   ]\n\nmain :: IO ()\nmain = do\n  accountA <- atomically $ newTVar 60\n  accountB <- atomically $ newTVar 0\n\n  sequence_ (actions accountA accountB)\n\n  balanceA <- atomically $ readTVar accountA\n  balanceB <- atomically $ readTVar accountB\n\n  print $ balanceA == 60\n  print $ balanceB == 0\n```\n請看:\n* [Beautiful Concurrency](https://www.fpcomplete.com/school/advanced-haskell/beautiful-concurrency)\n\n### Monad Par\n使用`Par monad`，我们将计算表示为数据流图，该数据流按`forked`(分叉)计算之间的`connections`(连接)顺序进行调度，这些分叉计算与`IVar`交换结果计算。\n```haskell\nnew :: Par (IVar a)\nput :: NFData a => IVar a -> a -> Par ()\nget :: IVar a -> Par a\nfork :: Par () -> Par ()\nspawn :: NFData a => Par a -> Par (IVar a)\n```\n![](img/img02.png)\n```haskell\nimport Control.Monad\nimport Control.Monad.Par\n\nf, g :: Int -> Int\nf x = x + 10\ng x = x * 10\n\n--   f x      g x\n--     \\     /\n--      a + b\n--      /   \\\n-- f (a+b)  g (a+b)\n--      \\   /\n--      (d,e)\n\nexample1 :: Int -> (Int, Int)\nexample1 x = runPar $ do\n  [a,b,c,d,e] <- replicateM 5 new\n  fork (put a (f x))\n  fork (put b (g x))\n  a' <- get a\n  b' <- get b\n  fork (put c (a' + b'))\n  c' <- get c\n  fork (put d (f c'))\n  fork (put e (g c'))\n  d' <- get d\n  e' <- get e\n  return (d', e')\n\nexample2 :: [Int]\nexample2 = runPar $ do\n  xs <- parMap (+1) [1..25]\n  return xs\n\n-- foldr (+) 0 (map (^2) [1..xs])\nexample3 :: Int -> Int\nexample3 n = runPar $ do\n  let range = (InclusiveRange 1 n)\n  let mapper x = return (x^2)\n  let reducer x y = return (x+y)\n  parMapReduceRangeThresh 10 range mapper reducer 0\n```\n\n### async\n`async`是一组在`Control.Concurrent`和`STM`之上工作的高级函數.\n```haskell\nasync :: IO a -> IO (Async a)\nwait :: Async a -> IO a\ncancel :: Async a -> IO ()\nconcurrently :: IO a -> IO b -> IO (a, b)\nrace :: IO a -> IO b -> IO (Either a b)\nimport Control.Monad\nimport Control.Applicative\nimport Control.Concurrent\nimport Control.Concurrent.Async\nimport Data.Time\n\ntimeit :: IO a -> IO (a,Double)\ntimeit io = do\n  t0 <- getCurrentTime\n  a <- io\n  t1 <- getCurrentTime\n  return (a, realToFrac (t1 `diffUTCTime` t0))\n\nworker :: Int -> IO Int\nworker n = do\n  -- simulate some work\n  threadDelay (10^2 * n)\n  return (n * n)\n\n-- Spawn 2 threads in parallel, halt on both finished.\n-- 并行生成2个线程，两个线程都完成時停止。\ntest1 :: IO (Int, Int)\ntest1 = do\n  val1 <- async $ worker 1000\n  val2 <- async $ worker 2000\n  (,) <$> wait val1 <*> wait val2\n\n-- Spawn 2 threads in parallel, halt on first finished.\n-- 并行生成2个线程，第一個完成时停止。\ntest2 :: IO (Either Int Int)\ntest2 = do\n  let val1 = worker 1000\n  let val2 = worker 2000\n  race val1 val2\n\n-- Spawn 10000 threads in parallel, halt on all finished.\n-- 并行生成10000个线程，全部完成时停止。\ntest3 :: IO [Int]\ntest3 = mapConcurrently worker [0..10000]\n\nmain :: IO ()\nmain = do\n  print =<< timeit test1\n  print =<< timeit test2\n  print =<< timeit test3\n```","tags":["Concurrency"]},{"title":"Haskell-GHC","url":"/blog/2019/10/16/Haskell-GHC/","content":"> [原文](http://dev.stephendiehl.com/hask/#ghc)\n\n### Block Diagram (程序框图)\n经过`GHC`的代码流是在几种中间语言之间进行翻译以及对其进行优化和转换的过程。\n这些`AST`类型中的许多类型的通用模式是，它们是根据`binder`类型进行参数化设置的，并且在各个阶段，`binder`将被转换。\n当用户输入由包含模块和程序包名称的`qualified`(合格)名称参数化的`HsSyn`参数时，`Renamer pass`(传递)有效地将`AST`参数化的超文本字符串中的`HsSyn`数据类型转换为更高级别的`Name`类型。\n\n#### GHC Compiler\n![](img/img01.png)\n\n#### GHC Compiler Passes\n* **Parser/Frontend** 从人类语法转换而来的巨大`AST`，使得所有可表达的语法(声明，`do-notation`，`where`子句，语法扩展，模板`haskell`等)都可以显式地实现。这是未经过滤的`Haskell`，它非常庞大.\n\n* **Renamer** 从`Frontend`获取语法，并将所有要限定的名称(用`base:Prelude.map`而不是`map`)以及`lambda binders`(绑定器)中的任何`shadowed`(阴影)名称转换为唯一名称。\n\n* **Typechecker** 是一个大`pass`，它有两个用途: 第一个是核心类型双向推理引擎，其中大部分工作都在这里进行，以及前端`Core`语法之间的转换。\n\n* **Desugarer**翻译了几个更高层次的语法构造函数\n    * 将`where`语句转换为(可能是递归的)嵌套的`let`语句。\n    * 嵌套模式匹配扩展为`case`语句的拆分树。\n    * `do-notation`扩展为显式`bind`语句。\n    * 还有很多。\n* **Simplifier** 将许多`Core`结构转换成更适合编译的形式。例如，`let`语句将被`floated`(浮动)或`raised`(提升)，模式匹配将被简化，`inner loops`(内部循环)将被拉出并转换为更优化的形式。直觉上来说，经过简化后，结果实际上可能要复杂得多(对人类而言)!\n\n* **Stg** 将生成的`Core`转换为`STG`(`Spineless Tagless G-Machine`)，它有效地使所有惰性都`explicit`(明確清晰/显式化)，并对將在评估期间处理的`trunk`和`update frames`(更新帧)进行编码。\n\n* **Codegen/Cmm** 会将`STG`转换为`Cmm`(`flavoured C--`)，这是一种简单的命令式语言，可以显示运行时类型的低级实现细节。运行时闭包类型和`stack frames`(堆栈帧)是显式的，关于数据和代码(arity, updatability, free variables, pointer layout)的低级別信息在大多数`constructs`(构造)的`info`(信息)表中显示出来。\n\n* **Native Code**`最後的pass`将通过`GHC`的本地本机代码生成器(`NCG`)或`LLVM`后端将生成的代码转换为`LLVM`或`Assembly`. \n\n每個`pass`的信息可以通过相当大的标志集合來`dumped out`(转储)。虽然有些`passes`比其他`passes`更容易理解，但`GHC`的内部结构非常容易理解。\n大多数时候使用`-ddump siml`和`-ddump stg`就足以理解代码将如何编译，除非您处理的是非常专门的优化或对`GHC`本身的黑客攻击。\n```haskell\nFlag\t         |      Action\n--------------------------------------------------------------\n-ddump-parsed    |\t    Frontend AST(抽象語法樹).\n-ddump-rn\t     |      Output of the rename pass.\n-ddump-tc\t     |      Output of the typechecker.\n-ddump-splices   |\t    Output of TemplateHaskell splices(拼接).\n-ddump-types     |\t    Typed AST representation.(类型的AST表示).\n-ddump-deriv     |\t    Output of deriving instances.\n-ddump-ds\t     |      Output of the desugar pass.\n-ddump-spec\t     |      Output of spescialisation pass.\n-ddump-rules     |\t    Output of applying rewrite rules (应用重写规则).\n-ddump-vect\t     |      Output results of vectorize(矢量化) pass.\n-ddump-simpl     |\t    Ouptut of the SimplCore pass.\n-ddump-inlinings |\t    Output of the inliner.\n-ddump-cse\t     |      Output of the common subexpression elimination pass(公共子表达式消除).\n-ddump-prep\t     |      The CorePrep pass.\n-ddump-stg\t     |      The resulting STG.\n-ddump-cmm\t     |      The resulting Cmm.\n-ddump-opt-cmm\t |      The resulting Cmm optimization pass.\n-ddump-asm\t     |      The final assembly generated.\n-ddump-llvm\t     |      The final LLVM IR generated.\n```\n\n### Core\n`Core`是`explicitly`(显式)类型化的`System-F`系列语法，通过它可以表达所有的`Haskell`构造。\n从`GHCi`來`inspect`(检查)`core`，我们可以使用以下`flags`(标志)和以下`Shell`别名来调用它。\n我们已明确禁用`certain`(某些)元数据和长格式名称的打印，以使`representation`(表示)更易于阅读。\n```haskell\nalias ghci-core=\"ghci -ddump-simpl -dsuppress-idinfo \\\n-dsuppress-coercions -dsuppress-type-applications \\\n-dsuppress-uniques -dsuppress-module-prefixes\"\n```\n然后在交互提示下，我们可以交互地探索`core`(核心)表示形式:\n```haskell\n$ ghci-core\nλ: let f x = x + 2 ; f :: Int -> Int\n\n==================== Simplified expression ====================\nreturnIO\n  (: ((\\ (x :: Int) -> + $fNumInt x (I# 2)) `cast` ...) ([]))\n\nλ: let f x = (x, x)\n\n==================== Simplified expression ====================\nreturnIO (: ((\\ (@ t) (x :: t) -> (x, x)) `cast` ...) ([]))\n```\n[ghc-core](http://hackage.haskell.org/package/ghc-core)对查看`GHC`的`compilation artifacts`(编译工件)也非常有用。\n```haskell\n$ ghc-core --no-cast --no-asm\n```\n另外，可以通过将几个标志传递给编译器来手动输出和检查编译器的主要阶段(`parse tree`,`core`,`stg`,`cmm`,`asm`):\n```haskell\n$ ghc -ddump-to-file -ddump-parsed -ddump-simpl -ddump-stg -ddump-cmm -ddump-asm\n```\n\n#### Reading Core\n`GHC`中的`Core`基本上是人类可读的，但是看看简单的人类书写的例子来了解正在发生的事情是有帮助的。\n```haskell\nid :: a -> a\nid x = x\nid :: forall a. a -> a\nid = \\ (@ a) (x :: a) -> x\n\nidInt :: GHC.Types.Int -> GHC.Types.Int\nidInt = id @ GHC.Types.Int\ncompose :: (b -> c) -> (a -> b) -> a -> c\ncompose f g x = f (g x)\ncompose :: forall b c a. (b -> c) -> (a -> b) -> a -> c\ncompose = \\ (@ b) (@ c) (@ a) (f1 :: b -> c) (g :: a -> b) (x1 :: a) -> f1 (g x1)\nmap :: (a -> b) -> [a] -> [b]\nmap f []     = []\nmap f (x:xs) = f x : map f xs\nmap :: forall a b. (a -> b) -> [a] -> [b]\nmap =\n  \\ (@ a) (@ b) (f :: a -> b) (xs :: [a]) ->\n    case xs of _ {\n      []     -> [] @ b;\n      : y ys -> : @ b (f y) (map @ a @ b f ys)\n    }\n```\n机器生成的名称是为`Core`的许多转换而创建的。\n通常，它们由前缀和唯一标识符组成。\n前缀通常是传递特定的，有时会为特定的自动生成的代码生成特定的名称。\n常见前缀及其含义的列表如下所示:\n```haskell\nPrefix\t    Description\n----------------------------------------------------------------------\n$f...\t    Dict-fun identifiers (from inst decls)\n$dmop\t    Default method for 'op'\n$wf\t        Worker for function 'f'\n$sf\t        Specialised version of f\n$gdm\t    Generated class method\n$d\t        Dictionary names\n$s\t        Specialized function name\n$f\t        Foreign export\n\n--          (C类的第n个超类选择器)\n$pnC\t    n'th superclass selector for class C\n\nT:C\t        Tycon for dictionary for class C\nD:C\t        Data constructor for dictionary for class C\n\n--          (将newtype T强制转换为其底层的运行时表示形式)\nNTCo:T\t    Coercion for newtype T to its underlying runtime representation\n```\n\n需要特别注意的是，用于类型级别和值级别`lambda`抽象的`Λ`和`λ`在`core`中用相同的符号(`\\`)表示，这是`GHC`实现的简化细节，卻是开始时有些混乱的根源。\n```haskell\n-- System-F Notation\nΛ b c a. λ (f1 : b -> c) (g : a -> b) (x1 : a). f1 (g x1)\n\n-- Haskell Core\n\\ (@ b) (@ c) (@ a) (f1 :: b -> c) (g :: a -> b) (x1 :: a) -> f1 (g x1)\n```\n`seq`函数在`Core`语言中有一個直观的实现。\n```haskell\nx `seq` y\ncase x of _ {\n  __DEFAULT -> y\n}\n```\n`Core`脫糖处理時的一个特别值得注意的情况是，对重载数字进行模式匹配会隐式转换为相等性测试(即`Eq`).\n```haskell\nf 0 = 1\nf 1 = 2\nf 2 = 3\nf 3 = 4\nf 4 = 5\nf _ = 0\n\n\nf :: forall a b. (Eq a, Num a, Num b) => a -> b\nf =\n  \\ (@ a)\n    (@ b)\n    ($dEq :: Eq a)\n    ($dNum :: Num a)\n    ($dNum1 :: Num b)\n    (ds :: a) ->\n    case == $dEq ds (fromInteger $dNum (__integer 0)) of _ {\n      False ->\n        case == $dEq ds (fromInteger $dNum (__integer 1)) of _ {\n          False ->\n            case == $dEq ds (fromInteger $dNum (__integer 2)) of _ {\n              False ->\n                case == $dEq ds (fromInteger $dNum (__integer 3)) of _ {\n                  False ->\n                    case == $dEq ds (fromInteger $dNum (__integer 4)) of _ {\n                      False -> fromInteger $dNum1 (__integer 0);\n                      True -> fromInteger $dNum1 (__integer 5)\n                    };\n                  True -> fromInteger $dNum1 (__integer 4)\n                };\n              True -> fromInteger $dNum1 (__integer 3)\n            };\n          True -> fromInteger $dNum1 (__integer 2)\n        };\n      True -> fromInteger $dNum1 (__integer 1)\n    }\n```\n当然，添加一个具体的类型签名会改变`desugar`(脫糖)只匹配`unboxed`(未装箱)的值.\n```haskell\nf :: Int -> Int\nf =\n  \\ (ds :: Int) ->\n    case ds of _ { I# ds1 ->\n        case ds1 of _ {\n            __DEFAULT -> I# 0;\n            0 -> I# 1;\n            1 -> I# 2;\n            2 -> I# 3;\n            3 -> I# 4;\n            4 -> I# 5\n        }\n    }\n```\n請看:\n* [Core Spec](https://github.com/ghc/ghc/blob/master/docs/core-spec/core-spec.pdf)\n* [Core By Example](http://alpmestan.com/2013/06/27/ghc-core-by-example-episode-1/)\n* [CoreSynType](https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType)\n\n### Inliner\n```haskell\ninfixr 0  $\n\n($):: (a -> b) -> a -> b\nf $ x =  f x\n```\n\n每次使用(`$`)时都必须输入辅助闭包将带来巨大的开销。\n幸运的是，`GHC`可以通过在适当的调用位置简单地用其定义的主体替换函数调用来消除此类小函数。\n编译器包含多种启发式方法，用于确定何时适合使用这种替代方法以及所涉及的潜在成本。\n\n除了自动的`inliner`(内联)之外，还提供了手动编译指示，以更精细地控制内联。值得注意的是，`naive`(幼稚/天真)的内联经常导致性能显着下降和更长的编译时间。\n```haskell\n{-# INLINE func #-}\n{-# INLINABLE func #-}\n{-# NOINLINE func #-}\n```\n例如，在我们将二进制函数应用于两个参数的情况下。\n函数主体很小，实际上我们可以只在调用站点内联函数应用，而不必为了应用给定函数而输入另一个闭包。\n```haskell\n{-# INLINE foo #-}\n{-# NOINLINE bar #-}\n\nfoo :: (a -> b -> c) -> a -> b -> c\nfoo f x y = f x y\n\nbar :: (a -> b -> c) -> a -> b -> c\nbar f x y = f x y\n\ntest1 :: Int\ntest1 = foo (+) 10 20\n\ntest2 :: Int\ntest2 = bar (+) 20 30\n```\n看一下`core`，我们可以看到在`test1`中，函数实际上已经在调用位置进行了扩展，只是在那里执行了加法操作，而不是另一个间接操作。\n```haskell\ntest1 :: Int\ntest1 =\n  let {\n    f :: Int -> Int -> Int\n    f = + $fNumInt } in\n  let {\n    x :: Int\n    x = I# 10 } in\n  let {\n    y :: Int\n    y = I# 20 } in\n  f x y\n\ntest2 :: Int\ntest2 = bar (+ $fNumInt) (I# 20) (I# 30)\n```\n标有`NOINLINE`的情况通常表明该函数中的逻辑使用的是诸如`unsafePerformIO`之类的东西或其他一些邪恶的函数。\n在这些情况下，幼稚的内联可能会在整个程序的多个调用位置重复产生效果，这是我們不希望看到的。\n\n請看: [Secrets of the Glasgow Haskell Compiler inliner](https://research.microsoft.com/en-us/um/people/simonpj/Papers/inlining/inline.pdf) (`GHC`编译器内联的秘密)\n\n\n### Rewrite Rules\n> 这是高级部分，编写Haskell通常不需要。\n\n> TODO\n\n請看:\n   * [Using Rules](https://wiki.haskell.org/GHC/Using_rules)\n   * [Rewrite Rules](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/rewrite-rules.html)\n\n### Fusion (聚变/融合)\n> 这是高级部分，编写Haskell通常不需要。\n\n> TODO\n\n請看: [List Fusion](https://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/rewrite-rules.html)\n\n### Dictionaries\n`Haskell`语言定义了`Typeclass`的概念，但与在`Haskell`编译器中如何实现它们无关。\n`GHC`的特殊实现使用了一个名为`dictionary`的传递过程，它传递了`typechecker`的`elaboration phase`(細化阶段)的翻译部分，该翻译部分将带有类型类约束的`Core`函数转换为隐式参数，该隐含参数将传递包含函数实现的类似记录的结构.\n```haskell\nclass Num a where\n  (+) :: a -> a -> a\n  (*) :: a -> a -> a\n  negate :: a -> a\n```\n可以将此类视为等效于以下函数参数化记录的实现:\n```haskell\ndata DNum a = DNum (a -> a -> a) (a -> a -> a) (a -> a)\n\nadd (DNum a m n) = a\nmul (DNum a m n) = m\nneg (DNum a m n) = n\n\nnumDInt :: DNum Int\nnumDInt = DNum plusInt timesInt negateInt\n\nnumDFloat :: DNum Float\nnumDFloat = DNum plusFloat timesFloat negateFloat\n+ :: forall a. Num a => a -> a -> a\n+ = \\ (@ a) (tpl :: Num a) ->\n  case tpl of _ { D:Num tpl _ _ -> tpl }\n\n* :: forall a. Num a => a -> a -> a\n* = \\ (@ a) (tpl :: Num a) ->\n  case tpl of _ { D:Num _ tpl _ -> tpl }\n\nnegate :: forall a. Num a => a -> a\nnegate = \\ (@ a) (tpl :: Num a) ->\n  case tpl of _ { D:Num _ _ tpl -> tpl }\n```\n`Num`和`Ord`的翻译很简单，但对于签名中存在`existential`(存在)类型变量的`monads`，表示等效`dictionary`(字典)的唯一方法是使用`RankNTypes`.\n另外，类型类还可以包括将包含在类型类字典中并在相同参数上进行参数化的超类，并创建一个隐式超类构造函数以从当前`monad`的超类中提取函数。\n```haskell\ndata DMonad m = DMonad\n  { bind   :: forall a b. m a -> (a -> m b) -> m b\n  , return :: forall a. a -> m a\n  }\nclass (Functor t, Foldable t) => Traversable t where\n    traverse :: Applicative f => (a -> f b) -> t a -> f (t b)\n    traverse f = sequenceA . fmap f\ndata DTraversable t = DTraversable\n  { dFunctorTraversable :: DFunctor t  -- superclass dictionary\n  , dFoldableTraversable :: DFoldable t -- superclass dictionary\n  , traverse :: forall a. Applicative f => (a -> f b) -> t a -> f (t b)\n  }\n```\n确实，这与`GHC`实际实现类型类的方式并不遥远。它详细介绍了与此几乎相同的`projection`(投影)函数和数据构造函数，并针对每个多态函数的每个类型类约束将其扩展为字典参数。\n\n### Specialization (特殊化/特化)\n默认情况下，`Haskell`中的重载通常不是完全免费的，尽管可以使用一种称为`specialization`(特殊化)的优化方法，使其在性能至关重要的代码中的特定点上的成本为零。\n由于`GHC`不是整个程序优化的编译器，并且大多数优化(并非全部)都停留在模块边界，因此默认情况下不会启用此功能。\n\n`GHC`实现类型类的方法意味着显式字典在整个调用站点中都是隐式的。\n这通常是实现此功能的最自然的方法，因为它保留单独的编译。\n\n函数可以独立于声明的位置进行编译，而不是在调用它的程序中的每个点重新编译。通过字典传递，调用者可以将类型的实现逻辑线程化到调用站点，然后可以在函数的整个主体中使用它。\n\n当然，这意味着为了获得特定的类型类函数，我们需要(可能多次)`project`(投影)到字典结构中以`pluck out`(提取)函数引用. 运行时使它非常便宜，但并非完全免费。\n\n许多`C++`编译器或整个程序优化的编译器却相反，它们在调用站点上明確地`specialize`(特殊化)了每个函数，并用其特定于类型的实现代替了重载函数。我们可以使用类`specialization`(特殊化)来选择性地启用这种行为。\n```haskell\nmodule Specialize (spec, nonspec, f) where\n\n{-# SPECIALIZE INLINE f :: Double -> Double -> Double #-}\n\nf :: Floating a => a -> a -> a\nf x y = exp (x + y) * exp (x + y)\n\nnonspec :: Float\nnonspec = f (10 :: Float) (20 :: Float)\n\nspec :: Double\nspec = f (10 :: Double) (20 :: Double)\n```\n\n#### Non-specialized\n```haskell\nf :: forall a. Floating a => a -> a -> a\nf =\n  \\ (@ a) ($dFloating :: Floating a) (eta :: a) (eta1 :: a) ->\n    let {\n      a :: Fractional a\n      a = $p1Floating @ a $dFloating } in\n    let {\n      $dNum :: Num a\n      $dNum = $p1Fractional @ a a } in\n    * @ a\n      $dNum\n      (exp @ a $dFloating (+ @ a $dNum eta eta1))\n      (exp @ a $dFloating (+ @ a $dNum eta eta1))\n```\n在`specialize`版本中，类型类操作直接放置在调用站点上，并且只是簡單的拆箱运算。这将映射到一组`tight`(严格/緊湊)的顺序`CPU`指令，并且很有可能是`C`生成的相同代码。\n```haskell\nspec :: Double\nspec = D# (*## (expDouble# 30.0) (expDouble# 30.0))\n```\n`non-specialized`版本必须投影到`typeclass`词典(`$fFloatingFloat`)中6次，并且可能要遍历25个分支才能执行相同的操作。\n```haskell\nnonspec :: Float\nnonspec =\n  f @ Float $fFloatingFloat (F# (__float 10.0)) (F# (__float 20.0))\n```\n\n对于在调用点`specialize`(特殊化)的`numeric`(数字)类型上的`tight loop`(紧密循环)，可以导致性能提高几个数量级。尽管编译时的开销通常是不小的，而且当在许多调用点使用函数时，这可能会使`GHC`的`simplifier pass`速度变慢。\n\n最好的建议是进行概要分析，并在`tight`(紧密)的循环中寻找`dictionary projection`(字典投影)的大量使用，然后在这些地方进行`specialize`(特殊化)和`inline`内联。\n\n如果将`SPECIALISE INLINE`编译指示应用于递归函数，可能会无意间导致`GHC`发生`diverge`(发散)，它将尝试无限`specialize`(特殊化)它自己。\n\n### Static Compilation (静态编译)\n在`Linux`上，`Haskell`程序可以编译为独立的静态链接二进制文件，其中包括静态链接到其中的运行时。\n```haskell\n$ ghc -O2 --make -static -optc-static -optl-static -optl-pthread Example.hs\n\n$ file Example\nExample: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.32, not stripped\n\n$ ldd Example\n        not a dynamic executable\n```\n此外，可以通过剥离不需要的符号来减少生成的二进制文件的文件大小。\n```haskell\n$ strip Example\n```\n还可以使用[upx](http://upx.sourceforge.net/)将可执行文件的大小进一步压缩.\n\n\n### Unboxed Types (未装箱的类型)\n`Haskell`中的常规`numerics`(数字)类型可以被认为是常规代数数据类型，其底層`unboxed`(未装箱)值带有特殊的构造函数参数。\n通常在常规代码中不使用`unboxed`(未装箱)类型和显式`unboxing`(拆箱)，它们是连接到编译器的。\n```haskell\ndata Int = I# Int#\n\ndata Integer\n  = S# Int#              -- Small integers\n  | J# Int# ByteArray#   -- Large GMP integers\n\ndata Float = F# Float#\n```\n```haskell\nSyntax\t        Primitive Type (原始类型)\n--------------------------------------\n3#\t            GHC.Prim.Int#\n3##\t            GHC.Prim.Word#\n3.14#\t        GHC.Prim.Float#\n3.14##\t        GHC.Prim.Double#\n'c'#\t        GHC.Prim.Char#\n\"Haskell\"##\t    GHC.Prim.Addr#\n```\n`kind`为`#`的未装箱类型，永远不会`unify`(统一)`kind`为`*`的类型变量。\n直观地，`kind`为`*`的类型表示具有`uniform`(统一)运行时表示形式的类型，该类型可以多态使用。\n* **Lifted**  - 可以包含一個`bottom term`,由一個指針表示.(`Int`,`Any`, `(,)`)\n* **Unlited** - 不可以包含一個`bottom term`,由`stack`(堆栈)上的值表示.(`Int#`,`(#, #)`)\n```haskell\n{-# LANGUAGE BangPatterns, MagicHash, UnboxedTuples #-}\n\nimport GHC.Exts\nimport GHC.Prim\n\nex1 :: Bool\nex1 = gtChar# a# b#\n  where\n    !(C# a#) = 'a'\n    !(C# b#) = 'b'\n\nex2 :: Int\nex2 = I# (a# +# b#)\n  where\n    !(I# a#) = 1\n    !(I# b#) = 2\n\nex3 :: Int\nex3 = (I# (1# +# 2# *# 3# +# 4#))\n\nex4 :: (Int, Int)\nex4 = (I# (dataToTag# False), I# (dataToTag# True))\n```\n用于`Int`的`Num`类型类中使用的`integer`算术函数只是对该类型的模式匹配，以显示底层未装箱的值，执行内置算术，然后再次执行打包到`Int`的操作。\n```haskell\nplusInt :: Int -> Int -> Int\n(I# x) `plusInt` (I# y) = I# (x +# y)\n```\n其中(`+＃`)是`GHC`内置的低级函数，它映射到`CPU`的内部整数加法指令。\n```haskell\nplusInt :: Int -> Int -> Int\nplusInt a b = case a of {\n    (I# a_) -> case b of {\n      (I# b_) -> I# (+# a_ b_);\n    };\n};\n```\n默认情况下，`Haskell`中的运行时值由一个`boxed`(裝箱)的`StgClosure*`结构体(`struct`)统一表示，该`struct`本身包含多个`payload`(有效负载)值，这些`payload`(有效负载)值本身可以是指向其他`boxed`值的指针，也可以是指向符合系统`word`(字)大小并直接存储在内存闭包中的未裝箱`literal`(文本)值的指针。\n\n`box`的布局由闭包头中的`bitmap`(位图)描述，该位图描述`payload`(有效负载)中的哪些值是指针或非指针。\n\n通过读取闭包上的位图，可以使用`unpackClosure＃ primop`在运行时提取此信息。\n```haskell\n{-# LANGUAGE MagicHash, UnboxedTuples #-}\n{-# OPTIONS_GHC -O1 #-}\n\nmodule Main where\n\nimport GHC.Exts\nimport GHC.Base\nimport Foreign\n\ndata Size = Size\n  { ptrs  :: Int\n  , nptrs :: Int\n  , size  :: Int\n  } deriving (Show)\n\nunsafeSizeof :: a -> Size\nunsafeSizeof a =\n  case unpackClosure# a of\n    (# x, ptrs, nptrs #) ->\n      let header  = sizeOf (undefined :: Int)\n          ptr_c   = I# (sizeofArray# ptrs)\n          nptr_c  = I# (sizeofByteArray# nptrs) `div` sizeOf (undefined :: Word)\n          payload = I# (sizeofArray# ptrs +# sizeofByteArray# nptrs)\n          size    = header + payload\n      in Size ptr_c nptr_c size\n\ndata A = A {-# UNPACK #-} !Int\ndata B = B Int\n\nmain :: IO ()\nmain = do\n  print (unsafeSizeof (A 42))\n  print (unsafeSizeof (B 42))\n```\n例如，带有`UNPACK`编译指示的`datatype`包含1个非指针和0个指针。\n```haskell\ndata A = A {-# UNPACK #-} !Int\nSize {ptrs = 0, nptrs = 1, size = 16}\n```\n而默认的`packed`的`datatype`包含1个指针和0个非指针.\n```haskell\ndata B = B Int\nSize {ptrs = 1, nptrs = 0, size = 9}\n```\n数据构造函数的闭包表示在运行时也带有特定构造函数的标签`tagged`(标记)。\n但是，这不是运行时类型标记，因为没有办法从`tag`(标记)中恢复类型，因为所有构造函数都只使用序列(0，1，2，...).\n\n`tag`(标记)用于区分模式匹配中的大小写。\n内置的`dataToTag＃`可用于抽取任意数据类型的`tag`。\n在某些情况下，当脫糖模式匹配时使用此选项很有用。\n\n```haskell\ndataToTag# :: a -> Int#\n```\n例如:\n```haskell\n-- data Bool = False | True\n-- False ~ 0\n-- True  ~ 1\n\na :: (Int, Int)\na = (I# (dataToTag# False), I# (dataToTag# True))\n-- (0, 1)\n\n-- data Ordering = LT | EQ | GT\n-- LT ~ 0\n-- EQ ~ 1\n-- GT ~ 2\n\nb :: (Int, Int, Int)\nb = (I# (dataToTag# LT), I# (dataToTag# EQ), I# (dataToTag# GT))\n-- (0, 1, 2)\n\n-- data Either a b = Left a | Right b\n-- Left ~ 0\n-- Right ~ 1\n\nc :: (Int, Int)\nc = (I# (dataToTag# (Left 0)), I# (dataToTag# (Right 1)))\n-- (0, 1)\n```\n源代码中包含的`String literals`(字符串文字)也将转换为几个`primop`操作。\n`Haskell`中的`Addr＃`类型代表在`Haskell`堆上预分配的静态`contagious`(可传染)缓冲区，该缓冲区可以容纳`char*`序列。`unpackCString＃`操作可以扫描此缓冲区并将其折叠到`Haskell`内部的`Chars`列表中。\n```haskell\nunpackCString# :: Addr# -> [Char]\n```\n这是在早期的前端`脫糖`阶段完成的，在此阶段，`literals`(文字)被转换为内联的`Addr＃`，而不是由大量的`Cons`字符组成。\n因此，我们的“ Hello World”转化为以下`Core`:\n```haskell\n-- print \"Hello World\"\nprint (unpackCString# \"Hello World\"#)\n```\n請看: \n* [Unboxed Values as First-Class Citizens](http://www.haskell.org/ghc/docs/papers/unboxed-values.ps.gz) (未装箱值作为一等公民)\n\n### IO/ST\n`IO`和`ST monad`在`GHC`运行时中都具有特殊状态，并且共享非常相似的实现。`ST a`和`IO a`都传递以下形式的未装箱元组:\n```haskell\n(# token, a #)\n```\n`RealWorld＃`令牌具有`深奥的魔力`，在编译时实际上不会`expand into`(扩展)为任何代码，而只是在`IO`或`ST monad`的每个绑定中`threaded around through`(四处穿线)，并且具有多个唯一性和不可复制性,确保顺序的IO操作实际上是顺序的。\n\n`unsafePerformIO`可以被认为是一种独特的操作，它丢弃`world`令牌并将`a`取出，顾名思义，它通常并不安全。\n\n`PrimMonad`将这两个`monad`以及与`world`令牌或`ST`线程相关联的数据族抽象出来，并可用于编写在`ST`和`IO`上通用的操作。它在`vector`(向量)包内部广泛使用，以使向量算法可以在`IO`或`ST`内部通用编写。\n```haskell\n{-# LANGUAGE MagicHash #-}\n{-# LANGUAGE UnboxedTuples #-}\n\nimport GHC.IO ( IO(..) )\nimport GHC.Prim ( State#, RealWorld )\nimport GHC.Base ( realWorld# )\n\ninstance  Monad IO  where\n    m >> k    = m >>= \\ _ -> k\n    return    = returnIO\n    (>>=)     = bindIO\n    fail s    = failIO s\n\nreturnIO :: a -> IO a\nreturnIO x = IO $ \\ s -> (# s, x #)\n\nbindIO :: IO a -> (a -> IO b) -> IO b\nbindIO (IO m) k = IO $ \\ s -> case m s of (# new_s, a #) -> unIO (k a) new_s\n\nthenIO :: IO a -> IO b -> IO b\nthenIO (IO m) k = IO $ \\ s -> case m s of (# new_s, _ #) -> unIO k new_s\n\nunIO :: IO a -> (State# RealWorld -> (# State# RealWorld, a #))\nunIO (IO a) = a\n{-# LANGUAGE MagicHash #-}\n{-# LANGUAGE UnboxedTuples #-}\n{-# LANGUAGE TypeFamilies #-}\n\nimport GHC.IO ( IO(..) )\nimport GHC.ST ( ST(..) )\nimport GHC.Prim ( State#, RealWorld )\nimport GHC.Base ( realWorld# )\n\nclass Monad m => PrimMonad m where\n  type PrimState m\n  primitive :: (State# (PrimState m) -> (# State# (PrimState m), a #)) -> m a\n  internal :: m a -> State# (PrimState m) -> (# State# (PrimState m), a #)\n\ninstance PrimMonad IO where\n  type PrimState IO = RealWorld\n  primitive = IO\n  internal (IO p) = p\n\ninstance PrimMonad (ST s) where\n  type PrimState (ST s) = s\n  primitive = ST\n  internal (ST p) = p\n```\n請看:\n* [Evaluation order and state tokens](https://www.fpcomplete.com/user/snoyberg/general-haskell/advanced/evaluation-order-and-state-tokens)（评估顺序和状态令牌）\n\n### ghc-heap-view\n通过一些黑暗的运行时魔法，我们实际上可以使用各种`C`和`Cmm`技巧在运行时检查`StgClosure`结构，以在运行时探究结构表示形式的字段。\n`ghc-heap-view`库可以用于内省此类事情，尽管在日常代码中这种东西实际上没有用，但在研究`GHC`内部结构以检查运行时实现细节并获取所有`Haskell`类型的底层原始位时非常有帮助。\n```haskell\n{-# LANGUAGE MagicHash #-}\n\nimport GHC.Exts\nimport GHC.HeapView\n\nimport System.Mem\n\nmain :: IO ()\nmain = do\n  -- Constr\n  clo <- getClosureData $! ([1,2,3] :: [Int])\n  print clo\n\n  -- Thunk\n  let thunk = id (1+1)\n  clo <- getClosureData thunk\n  print clo\n\n  -- evaluate to WHNF\n  thunk `seq` return ()\n\n  -- Indirection(间接的)\n  clo <- getClosureData thunk\n  print clo\n\n  -- force garbage collection\n  performGC\n\n  -- Value\n  clo <- getClosureData thunk\n  print clo\n```\n构造函数(在此为列表类型的`cons`构造函数)由`CONSTR`闭包表示，该闭包包含指向头部和尾部的两个指针。\n`head`参数中的`integer`(整数)是对预分配`number`(数字)的静态引用，我们在`SRT`(静态引用表)中看到一个静态引用。\n```haskell\nConsClosure {\n  info = StgInfoTable {\n    ptrs = 2,\n    nptrs = 0,\n    tipe = CONSTR_2_0,\n    srtlen = 1\n  },\n  ptrArgs = [0x000000000074aba8/1,0x00007fca10504260/2],\n  dataArgs = [],\n  pkg = \"ghc-prim\",\n  modl = \"GHC.Types\",\n  name = \":\"\n}\n```\n我们还可以观察到进程中的`thunk`的评估和更新(`id（1 + 1`)。\n最初的`thunk`只是一个`thunk`类型，带有指向代码的指针以将其评估为值。\n```haskell\nThunkClosure {\n  info = StgInfoTable {\n    ptrs = 0,\n    nptrs = 0,\n    tipe = THUNK,\n    srtlen = 9\n  },\n  ptrArgs = [],\n  dataArgs = []\n}\n```\n强制时，将对其进行评估并替换为一个指向已计算值的间接闭包。\n```haskell\nBlackholeClosure {\n  info = StgInfoTable {\n    ptrs = 1,\n    nptrs = 0,\n    tipe = BLACKHOLE,\n    srtlen = 0\n  },\n  indirectee = 0x00007fca10511e88/1\n}\n```\n当复制垃圾收集器通过`indirection`(间接)时，它只是用一个由`indirectee`计算的实际计算值的引用替换`indirection`(间接)，这样以后的访问就需要通过`indirection`(间接)指针`chase`(追逐)指针以获得结果。\n```haskell\nConsClosure {\n  info = StgInfoTable {\n    ptrs = 0,\n    nptrs = 1,\n    tipe = CONSTR_0_1,\n    srtlen = 0\n  },\n  ptrArgs = [],\n  dataArgs = [2],\n  pkg = \"integer-gmp\",\n  modl = \"GHC.Integer.Type\",\n  name = \"S#\"\n}\n```\n\n### STG\n在被编译为`Core`之后，程序会被翻译成非常相似的中间形式，称为`STG`(无脊椎无标签G机器)，该抽象机器模型使所有`laziness`(惰性)变得`explicit`(清晰明確)。\n`spineless`表示该语言中的`function applications`(函数应用)没有函数应用的`spine`(脊柱)，而是将其折叠为一系列参数。由于语义信息被存储并且部分应用的函数与`saturated`(饱和)函数的评估方式不同，因此语义中仍然存在`Currying`。\n```haskell\n-- Spine\nf x y z = App (App (App f x) y) z\n\n-- Spineless\nf x y z = App f [x, y, z]\n```\n`STG`中的所有`let`语句都将名称绑定到`lambda form`。不带参数的`lambda form`是`thunk`，而带参数的`lambda form`表示将分配闭包，以捕获显式提及的变量。\n`Thunks`本身要么是可重入的(`\\r`)，要么是可更新的(`\\u`)，这表明`thunk`会向栈中产生一个值，或者在`update frame`(更新帧)被求值后在堆中分配一个值。\n`thunk`的所有后续条目将生成已经计算过的值，而不需要重新执行相同的工作。\n\n`Lambda form`还指示静态引用表，该引用是对函数体所引用的静态堆分配值的引用的集合。\n例如，打开`-ddump-stg`，我们可以看到以下`compose`函数的扩展。\n```haskell\n-- Frontend\ncompose f g = \\x -> f (g x)\n-- Core\ncompose :: forall t t1 t2. (t1 -> t) -> (t2 -> t1) -> t2 -> t\ncompose =\n  \\ (@ t) (@ t1) (@ t2) (f :: t1 -> t) (g :: t2 -> t1) (x :: t2) ->\n    f (g x)\n-- STG\ncompose :: forall t t1 t2. (t1 -> t) -> (t2 -> t1) -> t2 -> t =\n    \\r [f g x] let { sat :: t1 = \\u [] g x; } in  f sat;\nSRT(compose): []\n```\n对于更复杂的示例，让我们跟踪阶乘函数的编译。\n```haskell\n-- Frontend\nfac :: Int -> Int -> Int\nfac a 0 = a\nfac a n = fac (n*a) (n-1)\n-- Core\nRec {\nfac :: Int -> Int -> Int\nfac =\n  \\ (a :: Int) (ds :: Int) ->\n    case ds of wild { I# ds1 ->\n    case ds1 of _ {\n      __DEFAULT ->\n        fac (* @ Int $fNumInt wild a) (- @ Int $fNumInt wild (I# 1));\n      0 -> a\n    }\n    }\nend Rec }\n-- STG\nfac :: Int -> Int -> Int =\n    \\r srt:(0,*bitmap*) [a ds]\n        case ds of wild {\n          I# ds1 ->\n              case ds1 of _ {\n                __DEFAULT ->\n                    let {\n                      sat :: Int =\n                          -- \\u\n                          \\u srt:(1,*bitmap*) []\n                              let { sat :: Int = NO_CCS I#! [1]; } in  - $fNumInt wild sat; } in\n                    -- \\u\n                    let { sat :: Int = \\u srt:(1,*bitmap*) [] * $fNumInt wild a;\n                    } in  fac sat sat;\n                0 -> a;\n              };\n        };\nSRT(fac): [fac, $fNumInt]\n```\n注意，阶乘函数在循环内部分配了两个`thunk`(查找`\\u`)，在计算时会更新它们。它还包括对自身(用于递归)和字典的静态引用，例如对`Int`类型的`Num`类型类的实例。\n\n### Worker/Wrapper\n打开`-O2`后，`GHC`将执行一种特殊的优化，称为`Worker-Wrapper`转换，它将把阶乘函数的逻辑拆分为两个定义，\n`worker`将操作`stack`(堆栈)上`unboxed`(未装箱)的已分配的机器`integers`(整数)，这些整数將编译成一个紧凑的内部循环，而`wrapper`调用`worker`并收集循环的最终结果，并将其打包回到一个`boxed`(装箱)的`heap`(堆)值。这通常比单纯的实现要快一个数量级，后者需要在每次迭代中打包和解包已装箱的整数。\n```haskell\n-- Worker\n$wfac :: Int# -> Int# -> Int# =\n    \\r [ww ww1]\n        case ww1 of ds {\n          __DEFAULT ->\n              case -# [ds 1] of sat {\n                __DEFAULT ->\n                    case *# [ds ww] of sat { __DEFAULT -> $wfac sat sat; };\n              };\n          0 -> ww;\n        };\nSRT($wfac): []\n\n-- Wrapper\nfac :: Int -> Int -> Int =\n    \\r [w w1]\n        case w of _ {\n          I# ww ->\n              case w1 of _ {\n                I# ww1 -> case $wfac ww ww1 of ww2 { __DEFAULT -> I# [ww2]; };\n              };\n        };\nSRT(fac): []\n```\n請看:\n* [Writing Haskell as Fast as C](https://donsbot.wordpress.com/2008/05/06/write-haskell-as-fast-as-c-exploiting-strictness-laziness-and-recursion/)\n\n### Z-Encoding\n`Z-Encoding`是`Haskell`的约定，用于生成在编译器目标语言中安全表示的名称。\n简单地说，`Z-Encoding`将许多符号字符重命名为`z`字符的特殊序列。\n```haskell\nString\t  Z-Encoded String\n----------------------------\nfoo\t          foo\nz\t          zz\nZ\t          ZZ\n()            Z0T\n(,)\t          Z2T\n(,,)\t      Z3T\n_\t          zu\n(\t          ZL\n)\t          ZR\n:\t          ZC\n#\t          zh\n.\t          zi\n(#,#)\t      Z2H\n(->)\t      ZLzmzgZR\n```\n这样，我们不必为`character-rich`(字符丰富)的名称生成唯一的无法识别的名称，而可以简单地通过一种直接的方法将它们转换为唯一但可识别的名称。\n因此，对于`GHC`生成的代码中的一些示例名称:\n```haskell\nZ-Encoded String\t                    Decoded String\n----------------------------------------------------------------------\nZCMain_main_closure\t                    :Main_main_closure\nbase_GHCziBase_map_closure\t            base_GHC.Base_map_closure\nbase_GHCziInt_I32zh_con_info\t        base_GHC.Int_I32#_con_info\nghczmprim_GHCziTuple_Z3T_con_info\t    ghc-prim_GHC.Tuple_(,,)_con_in\nghczmprim_GHCziTypes_ZC_con_info\t    ghc-prim_GHC.Types_:_con_info\n```\n\n### Cmm\n`Cmm`是`GHC`的复杂内部中间表示形式，可直接映射到编译器目标的生成代码上。\n从`Haskell`生成的`Cmm`代码是经过`CPS`转换的，\n所有函数从不返回值，它们仅调用`continuation`(连续)堆栈中的下一`frame`(帧)。\n对函数的所有评估都是通过调用方`indirectly`(间接)跳转到代码对象并将其参数放在`stack`(堆栈)上来进行的。\n这与`C`的评估模型截然不同，后者的评估模型放置在堆栈上，函数返回后会向堆栈产生一个值。\n\n您会在所有闭包和函数名称中看到几个常见的后缀:\n```haskell\nSymbol\tMeaning\n----------------------------------\n0\t      No argument\np\t      Garbage Collected Pointer\nn\t      Word-sized non-pointer\nl\t      64-bit non-pointer (long)\nv\t      Void\nf\t      Float\nd\t      Double\nv16\t    16-byte vector\nv32\t    32-byte vector\nv64\t    64-byte vector\n```\n#### Cmm Registers (寄存器)\n机器模型中描述了10个寄存器。`Sp`是指向堆栈顶部的指针，`SpLim`是指向堆栈中最后一个元素的指针。`Hp`是堆指针，用于通过当前堆限制`HpLim`进行分配和垃圾回收。\n`R1`寄存器始终持有活动闭包，`subsequent`(后续)寄存器是在寄存器中传递的参数。`Functions with more than 10 values spill into memory`(具有10个以上值的函数会溢出到内存中)。\n* **Sp**\n* **SpLim**\n* **Hp**\n* **HpLim**\n* **HpAlloc**\n* **R1**\n* **R2**\n* **R3**\n* **R4**\n* **R5**\n* **R6**\n* **R7**\n* **R8**\n* **R9**\n* **R10**\n\n#### Examples\n为了理解`Cmm`，查看由等价的`Haskell`生成的代码并慢慢理解等价性和机械翻译之间的映射是很有用的。\n每个`Cmm`定义通常都有两部分，即`info table`(信息表)和`entry code`(输入代码)。\n\n`info table`直接映射`StgInfoTable`结构，包含与闭包类型、其`payload`(有效负载)和`references`(引用)相关的各种字段。\n\n`code`(代码)对象是生成代码的基本`blocks`(块)，与`Haskell`函数/构造函数的逻辑相对应。\n\n对于最简单的示例，请考虑一个常量静态构造函数。只是产生`Unit`值的函数。\n在这种情况下，该函数只是没有`payload`(有效负载)的构造函数，并且是静态分配的:\n```haskell\nHaskell:\n\nunit = ()\nCmm:\n\n[section \"data\" {\n     unit_closure:\n         const ()_static_info;\n }]\n```\n考虑带有参数的静态构造函数:\n```haskell\nHaskell:\n\ncon :: Maybe ()\ncon = Just ()\nCmm:\n\n[section \"data\" {\n     con_closure:\n         const Just_static_info;\n         const ()_closure+1;\n         const 1;\n }]\n```\n考虑`literal`(字面)常量。这是一个静态值:\n```haskell\nHaskell:\n\nlit :: Int\nlit = 1\nCmm:\n\n[section \"data\" {\n     lit_closure:\n         const I#_static_info;\n         const 1;\n }]\n```\n考虑`identity`函數:\n```haskell\nHaskell:\n\nid x = x\nCmm:\n\n[section \"data\" {\n     id_closure:\n         const id_info;\n },\n id_info()\n         { label: id_info\n           rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} }\n         }\n     ch1:\n         R1 = R2;\n         jump stg_ap_0_fast; // [R1]\n }]\n```\n考虑常数函数:\n```haskell\nHaskell:\n\nconstant x y = x\nCmm:\n\n[section \"data\" {\n     constant_closure:\n         const constant_info;\n },\n constant_info()\n         { label: constant_info\n           rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} }\n         }\n     cgT:\n         R1 = R2;\n         jump stg_ap_0_fast; // [R1]\n }]\n```\n`Consider a function where application of a function (of unknown arity) occurs.`(考虑发生函数应用的函数)\n```haskell\nHaskell:\n\ncompose f g x = f (g x)\nCmm:\n\n[section \"data\" {\n     compose_closure:\n         const compose_info;\n },\n compose_info()\n         { label: compose_info\n           rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 20} }\n         }\n     ch9:\n         Hp = Hp + 32;\n         if (Hp > HpLim) goto chd;\n         I64[Hp - 24] = stg_ap_2_upd_info;\n         I64[Hp - 8] = R3;\n         I64[Hp + 0] = R4;\n         R1 = R2;\n         R2 = Hp - 24;\n         jump stg_ap_p_fast; // [R1, R2]\n     che:\n         R1 = compose_closure;\n         jump stg_gc_fun; // [R1, R4, R3, R2]\n     chd:\n         HpAlloc = 32;\n         goto che;\n }]\n```\n考虑使用模式匹配进行分支的函数:\n```haskell\nHaskell:\n\nmatch :: Either a a -> a\nmatch x = case x of\n  Left a -> a\n  Right b -> b\nCmm:\n\n[section \"data\" {\n     match_closure:\n         const match_info;\n },\n sio_ret()\n         { label: sio_info\n           rep:StackRep []\n         }\n     ciL:\n         _ciM::I64 = R1 & 7;\n         if (_ciM::I64 >= 2) goto ciN;\n         R1 = I64[R1 + 7];\n         Sp = Sp + 8;\n         jump stg_ap_0_fast; // [R1]\n     ciN:\n         R1 = I64[R1 + 6];\n         Sp = Sp + 8;\n         jump stg_ap_0_fast; // [R1]\n },\n match_info()\n         { label: match_info\n           rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} }\n         }\n     ciP:\n         if (Sp - 8 < SpLim) goto ciR;\n         R1 = R2;\n         I64[Sp - 8] = sio_info;\n         Sp = Sp - 8;\n         if (R1 & 7 != 0) goto ciU;\n         jump I64[R1]; // [R1]\n     ciR:\n         R1 = match_closure;\n         jump stg_gc_fun; // [R1, R2]\n     ciU: jump sio_info; // [R1]\n }]\n```\n#### Macros (宏)\n`Cmm`本身使用许多宏来代表各种构造，其中许多是在外部`C`头文件中定义的。常见类型的简短参考：\n```haskell\nCmm\t  Description\n----------------------\nC_\t  char\nD_\t  double\nF_\t  float\nW_\t  word\nP_\t  garbage collected pointer\nI_\t  int\nL_\t  long\nFN_\t  function pointer (no arguments)\nEF_\t  extern function pointer\nI8\t  8-bit integer\nI16\t  16-bit integer\nI32\t  32-bit integer\nI64\t  64-bit integer\n```\n许多预定义的闭包(`stg_ap_p_fast`等)本身都是机械生成的，或多或少共享相同的`form`(形式)(关于闭包类型，`update frame`更新框架，`stack adjustment`堆栈调整的巨大`switch`语句)。\n\n`GHC`的内部是一个名为`GenApply.hs`的文件，该文件生成大多数这些函數。有关`GHC`生成的当前源文件，请参见阅读部分的`Gist`链接。\n\n例如`stg_ap_p_fast`的输出:\n```C\nstg_ap_p_fast\n{   W_ info;\n    W_ arity;\n    if (GETTAG(R1)==1) {\n        Sp_adj(0);\n        jump %GET_ENTRY(R1-1) [R1,R2];\n    }\n    if (Sp - WDS(2) < SpLim) {\n        Sp_adj(-2);\n        W_[Sp+WDS(1)] = R2;\n        Sp(0) = stg_ap_p_info;\n        jump __stg_gc_enter_1 [R1];\n    }\n    R1 = UNTAG(R1);\n    info = %GET_STD_INFO(R1);\n    switch [INVALID_OBJECT .. N_CLOSURE_TYPES] (TO_W_(%INFO_TYPE(info))) {\n        case FUN,\n             FUN_1_0,\n             FUN_0_1,\n             FUN_2_0,\n             FUN_1_1,\n             FUN_0_2,\n             FUN_STATIC: {\n            arity = TO_W_(StgFunInfoExtra_arity(%GET_FUN_INFO(R1)));\n            ASSERT(arity > 0);\n            if (arity == 1) {\n                Sp_adj(0);\n                R1 = R1 + 1;\n                jump %GET_ENTRY(UNTAG(R1)) [R1,R2];\n            } else {\n                Sp_adj(-2);\n                W_[Sp+WDS(1)] = R2;\n                if (arity < 8) {\n                  R1 = R1 + arity;\n                }\n                BUILD_PAP(1,1,stg_ap_p_info,FUN);\n            }\n        }\n        default: {\n            Sp_adj(-2);\n            W_[Sp+WDS(1)] = R2;\n            jump RET_LBL(stg_ap_p) [];\n        }\n    }\n}\n```\n手写`Cmm`可以通过以下方式手动包含在模块中: 首先通过`GHC`将其编译为对象，然后使用特殊的`FFI`调用。\n```haskell\n#include \"Cmm.h\"\n\nfactorial {\n  entry:\n      W_ n  ;\n      W_ acc;\n      n = R1 ;\n      acc = n ;\n      n = n - 1 ;\n    \n  for:\n      if (n <= 0 ) {\n          RET_N(acc);\n      } else {\n          acc = acc * n  ;\n          n = n - 1 ;\n          goto for ;\n      }\n      RET_N(0);\n}\n-- ghc -c factorial.cmm -o factorial.o\n-- ghc factorial.o Example.hs -o Example\n\n{-# LANGUAGE MagicHash #-}\n{-# LANGUAGE UnliftedFFITypes #-}\n{-# LANGUAGE GHCForeignImportPrim #-}\n{-# LANGUAGE ForeignFunctionInterface #-}\n\nmodule Main where\n\nimport GHC.Prim\nimport GHC.Word\n\nforeign import prim \"factorial\" factorial_cmm  :: Word# -> Word#\n\nfactorial :: Word64 -> Word64\nfactorial (W64# n) =  W64# (factorial_cmm n)\n\nmain :: IO ()\nmain = print (factorial 5)\n```\n請看:\n* [CmmType](http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/CmmType)\n* [MiscClosures](https://github.com/ghc/ghc/blob/master/includes/stg/MiscClosures.h)\n* [StgCmmArgRep](https://github.com/ghc/ghc/blob/master/compiler/codeGen/StgCmmArgRep.hs)\n\n`Cmm`运行时:\n* [Apply.cmm](https://github.com/ghc/ghc/blob/master/rts/Apply.cmm)\n* [StgStdThunks.cmm](https://github.com/ghc/ghc/blob/master/rts/StgStdThunks.cmm)\n* [StgMiscClosures.cmm](https://github.com/ghc/ghc/blob/master/rts/StgMiscClosures.cmm)\n* [PrimOps.cmm](https://github.com/ghc/ghc/blob/master/rts/PrimOps.cmm)\n* [Updates.cmm](https://github.com/ghc/ghc/blob/master/rts/Updates.cmm)\n* [Precompiled Closures(Autogenerated Output)](https://gist.github.com/sdiehl/e5c9daab7a6d1da0ede7)(预编译的闭包(自动生成的输出))\n\n### Optimization Hacks (优化技巧)\n\n#### Tables Next to Code\n`GHC`会将顶级闭包的`info table`直接放在内存中对象的`entry code`旁边，这样`info table`中的字段就可以通过指向代码本身的函数指针上的指针算术来访问。\n如果不执行此优化，则需要再跟踪一个指针以获取`info table`。\n考虑到使用`tables-next-to-code`访问`info table`的频率，优化结果会有一个可处理的加速。\n\n#### Pointer Tagging\n根据所涉及的闭包的类型，`GHC`将利用指向闭包的指针的最后几`bits`(位)来存储信息，这些信息可以在`jumping into`(跳入)或`access`(访问)`info tables`之前从指针本身的`bits`(位)中读取。\n\n对于`trunk`，这可能是诸如是否将其评估为`WHNF`的信息，对于构造函数，它包含构造函数`tag`(标记)以避免`info tables`信息表查找。\n\n根据`architecture`(体系结构)，`tag bits`(标记位)是指针的最后2位或3位。\n\n```C\n// 32 bit arch\nTAG_BITS = 2\n\n// 64-bit arch\nTAG_BITS = 3\n```\n在`CMM`中，通过以下宏定义, 最常出现这些情况:\n```C\n#define TAG_MASK ((1 << TAG_BITS) - 1)\n#define UNTAG(p) (p & ~TAG_MASK)\n#define GETTAG(p) (p & TAG_MASK)\n```\n因此，例如，在许多预编译函数中，将测试`active closure`(活动闭包)`r1`是否已经求值。\n```C\nif (GETTAG(R1)==1) {\n    Sp_adj(0);\n    jump %GET_ENTRY(R1-1) [R1,R2];\n}\n```\n\n### Interface Files\n在编译过程中，`GHC`将为每个模块生成接口文件，这些文件是该模块导出的特定符号(函数，类型类等)的二进制编码，以及它本身依赖的任何程序包依赖项。这实际上是编译器内部使用的`ModGuts`结构的序列化形式。可以使用`--show-iface`标志来转储该文件的内部结构。`GHC`版本之间的精确结构有所不同。\n\n### Resources\n請看:\n* [GHC Illustrated](https://takenobu-hs.github.io/downloads/haskell_ghc_illustrated.pdf)\n* [Dive into GHC: Pipeline](http://www.stephendiehl.com/posts/ghc_01.html)\n* [Dive into GHC: Intermediate Forms](http://www.stephendiehl.com/posts/ghc_02.html)\n* [Dive into GHC: Targeting Core](http://www.stephendiehl.com/posts/ghc_03.html)\n\n","tags":["GHC"]},{"title":"Haskell-Template-Haskell","url":"/blog/2019/10/16/Haskell-Template-Haskell/","content":"> 这是高级部分，编写Haskell通常无需了解[TemplateHaskell](http://dev.stephendiehl.com/hask/#template-haskell)。\n\n### Perils of Metaprogramming (元编程的危险)\n`Template Haskell`是一组非常强大的抽象，有些人可能会说它太强大了。它有效地允许我们在编译时运行任意代码来生成其他`haskell`代码。你可以做一些非常疯狂的事情，比如从文件系统中读取，或者做一些网络调用来通知你的代码如何编译，从而导致不确定的构建。\n\n虽然在某些极端情况下这是有用的，但在生产环境中使用时需要谨慎。`TemplateHaskell`可以导致构建时间的增长而不受绑定，迫使您手动对模块的所有定义进行排序，并且通常会生成无法维护的代码。如果你发现自己又回到元编程上来了，问问自己，在我的抽象中，什么让我失败了，以至于我唯一的选择是编写可编写代码的代码。\n> 在启用TemplateHaskell之前，应使用注意事项。 首先考虑惯用的解决方案。\n\n### Quasiquotation\n`Quasiquotation`允许我们表达`quoted`的语法块，这些语法块不一定是宿主语言的语法，但与只编写一个巨大的字符串不同，它被解析为宿主语言中的一些`AST`数据类型。\n值得注意的是，来自宿主语言的值可以通过用户可定义的逻辑注入到自定义语言中，从而允许信息在两种语言之间流动。\n\n实际上，`Quasiquotation`可用于实现定制的特定于領域的语言或完全通过代码生成与其他通用语言集成。\n\n我们已经了解了如何编写`Parsec`解析器，现在让我们为其编写一个`Quasiquotation`程序。\n```haskell\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Quasiquote where\n\nimport Language.Haskell.TH\nimport Language.Haskell.TH.Syntax\nimport Language.Haskell.TH.Quote\n\nimport Text.Parsec\nimport Text.Parsec.String (Parser)\nimport Text.Parsec.Language (emptyDef)\n\nimport qualified Text.Parsec.Expr as Ex\nimport qualified Text.Parsec.Token as Tok\n\nimport Control.Monad.Identity\n\ndata Expr\n  = Tr\n  | Fl\n  | Zero\n  | Succ Expr\n  | Pred Expr\n  deriving (Eq, Show)\n\ninstance Lift Expr where\n  lift Tr         = [| Tr |]\n  lift Fl         = [| Tr |]\n  lift Zero       = [| Zero |]\n  lift (Succ a)   = [| Succ a |]\n  lift (Pred a)   = [| Pred a |]\n\ntype Op = Ex.Operator String () Identity\n\nlexer :: Tok.TokenParser ()\nlexer = Tok.makeTokenParser emptyDef\n\nparens :: Parser a -> Parser a\nparens = Tok.parens lexer\n\nreserved :: String -> Parser ()\nreserved = Tok.reserved lexer\n\nsemiSep :: Parser a -> Parser [a]\nsemiSep = Tok.semiSep lexer\n\nreservedOp :: String -> Parser ()\nreservedOp = Tok.reservedOp lexer\n\nprefixOp :: String -> (a -> a) -> Op a\nprefixOp x f = Ex.Prefix (reservedOp x >> return f)\n\ntable :: [[Op Expr]]\ntable = [\n    [ prefixOp \"succ\" Succ\n    , prefixOp \"pred\" Pred\n    ]\n  ]\n\nexpr :: Parser Expr\nexpr = Ex.buildExpressionParser table factor\n\ntrue, false, zero :: Parser Expr\ntrue  = reserved \"true\" >> return Tr\nfalse = reserved \"false\" >> return Fl\nzero  = reservedOp \"0\" >> return Zero\n\nfactor :: Parser Expr\nfactor =\n      true\n  <|> false\n  <|> zero\n  <|> parens expr\n\ncontents :: Parser a -> Parser a\ncontents p = do\n  Tok.whiteSpace lexer\n  r <- p\n  eof\n  return r\n\ntoplevel :: Parser [Expr]\ntoplevel = semiSep expr\n\nparseExpr :: String -> Either ParseError Expr\nparseExpr s = parse (contents expr) \"<stdin>\" s\n\nparseToplevel :: String -> Either ParseError [Expr]\nparseToplevel s = parse (contents toplevel) \"<stdin>\" s\n\ncalcExpr :: String -> Q Exp\ncalcExpr str = do\n  filename <- loc_filename `fmap` location\n  case parse (contents expr) filename str of\n    Left err -> error (show err)\n    Right tag -> [| tag |]\n\ncalc :: QuasiQuoter\ncalc = QuasiQuoter calcExpr err err err\n  where err = error \"Only defined for values\"\n```\n测试一下:\n```haskell\n{-# LANGUAGE QuasiQuotes #-}\n\nimport Quasiquote\n\na :: Expr\na = [calc|true|]\n-- Tr\n\nb :: Expr\nb = [calc|succ (succ 0)|]\n-- Succ (Succ Zero)\n\nc :: Expr\nc = [calc|pred (succ 0)|]\n-- Pred (Succ Zero)\n```\n一项非常重要的特性是保留位置信息的能力，以便可以将嵌入语言中的错误追溯到宿主语法的这一行。\n\n### language-c-quote\n当然，由于我们可以为引用的表达式提供一个任意的解析器，因此可以考虑完全嵌入另一种语言的`AST`。例如`C`或`CUDA C`。\n```haskell\nhello :: String -> C.Func\nhello msg = [cfun|\n\nint main(int argc, const char *argv[])\n{\n    printf($msg);\n    return 0;\n}\n\n|]\n```\n对此进行评估，我们获得了引用的`C`程序的`AST`表示，可以使用`ppr`函数对其进行操作或打印回文本`C`代码:\n```haskell\nFunc\n  (DeclSpec [] [] (Tint Nothing))\n  (Id \"main\")\n  DeclRoot\n  (Params\n     [ Param (Just (Id \"argc\")) (DeclSpec [] [] (Tint Nothing)) DeclRoot\n     , Param\n         (Just (Id \"argv\"))\n         (DeclSpec [] [ Tconst ] (Tchar Nothing))\n         (Array [] NoArraySize (Ptr [] DeclRoot))\n     ]\n     False)\n  [ BlockStm\n      (Exp\n         (Just\n            (FnCall\n               (Var (Id \"printf\"))\n               [ Const (StringConst [ \"\\\"Hello Haskell!\\\"\" ] \"Hello Haskell!\")\n               ])))\n  , BlockStm (Return (Just (Const (IntConst \"0\" Signed 0))))\n  ]\n```\n在这个例子中，我们只是在`printf`语句中拼接了反引号的`Haskell`字符串，但是我们可以在引号表达式之间传递许多其他值，包括标识符，数字和其他实现`Lift`类型类的引号表达式。\n\n例如，现在，如果我们想以编程方式生成`CUDA`内核的源代码以在`GPU`上运行，我们可以切换`CUDA C`语言以发出`C`代码。\n```haskell\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nimport Text.PrettyPrint.Mainland\nimport qualified Language.C.Syntax as C\nimport qualified Language.C.Quote.CUDA as Cuda\n\ncuda_fun :: String -> Int -> Float -> C.Func\ncuda_fun fn n a = [Cuda.cfun|\n\n__global__ void $id:fn (float *x, float *y) {\n  int i = blockIdx.x*blockDim.x + threadIdx.x;\n  if ( i<$n ) { y[i] = $a*x[i] + y[i]; }\n}\n\n|]\n\ncuda_driver :: String -> Int -> C.Func\ncuda_driver fn n = [Cuda.cfun|\n\nvoid driver (float *x, float *y) {\n  float *d_x, *d_y;\n\n  cudaMalloc(&d_x, $n*sizeof(float));\n  cudaMalloc(&d_y, $n*sizeof(float));\n\n  cudaMemcpy(d_x, x, $n, cudaMemcpyHostToDevice);\n  cudaMemcpy(d_y, y, $n, cudaMemcpyHostToDevice);\n\n  $id:fn<<<($n+255)/256, 256>>>(d_x, d_y);\n\n  cudaFree(d_x);\n  cudaFree(d_y);\n  return 0;\n}\n\n|]\n\nmakeKernel :: String -> Float -> Int -> [C.Func]\nmakeKernel fn a n = [\n    cuda_fun fn n a\n  , cuda_driver fn n\n  ]\n\nmain :: IO ()\nmain = do\n  let ker = makeKernel \"saxpy\" 2 65536\n  mapM_ (print . ppr) ker\n```\n运行此代碼生成:\n```C\n__global__ void saxpy(float* x, float* y)\n{\n    int i = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (i < 65536) {\n        y[i] = 2.0 * x[i] + y[i];\n    }\n}\nint driver(float* x, float* y)\n{\n    float* d_x, * d_y;\n\n    cudaMalloc(&d_x, 65536 * sizeof(float));\n    cudaMalloc(&d_y, 65536 * sizeof(float));\n    cudaMemcpy(d_x, x, 65536, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_y, y, 65536, cudaMemcpyHostToDevice);\n    saxpy<<<(65536 + 255) / 256, 256>>>(d_x, d_y);\n    return 0;\n}\n```\n通过`nvcc -ptx -c`运行结果输出，以获得与输出代码相关联的`PTX`.\n\n### Template Haskell\n当然，最有用的`quasiquotation`是从`Haskell`内部程序生成`Haskell`代码本身的能力。\n`template-haskell`框架为`quotation`(引句)提供了四个入口点，以生成各种类型的`Haskell`声明和表达式。\n```haskell\nType      Quasiquoted     Class\n----------------------------------------\nQ Exp     [e| ... |]      expression\nQ Pat     [p| ... |]      pattern\nQ Type    [t| ... |]      type\nQ [Dec]   [d| ... |]      declaration\n```\n\n```haskell\ndata QuasiQuoter = QuasiQuoter\n  { quoteExp  :: String -> Q Exp\n  , quotePat  :: String -> Q Pat\n  , quoteType :: String -> Q Type\n  , quoteDec  :: String -> Q [Dec]\n  }\n```\n`logic evaluating`(评估)，`splicing`(拼接)和`introspecting`(内省)编译时值的逻辑嵌入在`Q monad`中，后者具有一个`runQ`，可用于评估其上下文。此`monad`的这些功能已深深嵌入到`GHC`的实现中。\n```haskell\nrunQ :: Quasi m => Q a -> m a\nrunIO :: IO a -> Q a\n```\n与以前一样，`TemplateHaskell`提供了使用`Lift`类型类将`Haskell`值提升为引用表达式内的`AST quantities`(数量)的功能。\n```haskell\nclass Lift t where\n  lift :: t -> Q Exp\n\ninstance Lift Integer where\n  lift x = return (LitE (IntegerL x))\n\ninstance Lift Int where\n  lift x= return (LitE (IntegerL (fromIntegral x)))\n\ninstance Lift Char where\n  lift x = return (LitE (CharL x))\n\ninstance Lift Bool where\n  lift True  = return (ConE trueName)\n  lift False = return (ConE falseName)\n\ninstance Lift a => Lift (Maybe a) where\n  lift Nothing  = return (ConE nothingName)\n  lift (Just x) = liftM (ConE justName `AppE`) (lift x)\n\ninstance Lift a => Lift [a] where\n  lift xs = do { xs' <- mapM lift xs; return (ListE xs') }\n```\n在许多情况下，`Template Haskell`可用于交互式探索各种`Haskell`语法的`AST`形式。\n```haskell\nλ: runQ [e| \\x -> x |]\nLamE [VarP x_2] (VarE x_2)\n\nλ: runQ [d| data Nat = Z | S Nat |]\n[DataD [] Nat_0 [] [NormalC Z_2 [],NormalC S_1 [(NotStrict,ConT Nat_0)]] []]\n\nλ: runQ [p| S (S Z)|]\nConP Singleton.S [ConP Singleton.S [ConP Singleton.Z []]]\n\nλ: runQ [t| Int -> [Int] |]\nAppT (AppT ArrowT (ConT GHC.Types.Int)) (AppT ListT (ConT GHC.Types.Int))\n\nλ: let g = $(runQ [| \\x -> x |])\n\nλ: g 3\n3\n```\n使用[Language.Haskell.TH](http://hackage.haskell.org/package/template-haskell-2.4.0.0/docs/Language-Haskell-TH-Syntax.html#t:Dec)，我们可以将`Haskell AST`一个元素一个元素地拼凑在一起，但是需要遵循我们自己的自定义逻辑来生成代码。尽管`Haskell`的源语言(称为`HsSyn`)非常庞大，在其`AST`中大约有100个节点，其中许多节点都依赖于语言`pragmas`(编译指令)的状态，但这可能会有些痛苦。\n```haskell\n-- builds the function (f = \\(a,b) -> a)\nf :: Q [Dec]\nf = do\n  let f = mkName \"f\"\n  a <- newName \"a\"\n  b <- newName \"b\"\n  return [ FunD f [ Clause [TupP [VarP a, VarP b]] (NormalB (VarE a)) [] ] ]\nmy_id :: a -> a\nmy_id x = $( [| x |] )\n\nmain = print (my_id \"Hello Haskell!\")\n```\n作为一种调试工具，能够交互式地将特定符号的`reified`(具体化)信息`dump`(转储)出来是很有用的，为此有一个简单的小技巧。\n```haskell\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nimport Text.Show.Pretty (ppShow)\nimport Language.Haskell.TH\n\nintrospect :: Name -> Q Exp\nintrospect n = do\n  t <- reify n\n  runIO $ putStrLn $ ppShow t\n  [| return () |]\nλ: $(introspect 'id)\nVarI\n  GHC.Base.id\n  (ForallT\n     [ PlainTV a_1627405383 ]\n     []\n     (AppT (AppT ArrowT (VarT a_1627405383)) (VarT a_1627405383)))\n  Nothing\n  (Fixity 9 InfixL)\n\n\nλ: $(introspect ''Maybe)\nTyConI\n  (DataD\n     []\n     Data.Maybe.Maybe\n     [ PlainTV a_1627399528 ]\n     [ NormalC Data.Maybe.Nothing []\n     , NormalC Data.Maybe.Just [ ( NotStrict , VarT a_1627399528 ) ]\n     ]\n     [])\nimport Language.Haskell.TH\n\nfoo :: Int -> Int\nfoo x = x + 1\n\ndata Bar\n\nfooInfo :: InfoQ\nfooInfo = reify 'foo\n\nbarInfo :: InfoQ\nbarInfo = reify ''Bar\n$( [d| data T = T1 | T2 |] )\n\nmain = print [T1, T2]\n```\n`Splices`(拼接)由表达式级别的`$(f)`语法表示，而在顶层仅通过调用`template Haskell`函数来表示。运行带有`-ddump-splices`的`GHC`可以显示我们的代码在编译时被`spliced`(拼接)到`AST`中的特定位置。\n```haskell\n$(f)\n\ntemplate_haskell_show.hs:1:1: Splicing declarations\n    f\n  ======>\n    template_haskell_show.hs:8:3-10\n    f (a_a5bd, b_a5be) = a_a5bd\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Splice where\n\nimport Language.Haskell.TH\nimport Language.Haskell.TH.Syntax\n\nspliceF :: Q [Dec]\nspliceF = do\n  let f = mkName \"f\"\n  a <- newName \"a\"\n  b <- newName \"b\"\n  return [ FunD f [ Clause [VarP a, VarP b] (NormalB (VarE a)) [] ] ]\n\nspliceG :: Lift a => a -> Q [Dec]\nspliceG n = runQ [d| g a = n |]\n{-# LANGUAGE TemplateHaskell #-}\n\nimport Splice\n\nspliceF\nspliceG \"argument\"\n\nmain = do\n  print $ f 1 2\n  print $ g ()\n```\n在`splice`(拼接)点，使用的所有变量和类型都必须在作用域中，因此它必须出现在模块中它们的声明之后。因此，在使用`TemplateHaskell`时，我们通常必须在心理上对代码进行拓扑排序，以便按顺序定义声明。\n\n請看:\n* [Template Haskell AST](http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH.html#t:Exp)\n\n### Antiquotation\n既然我们有了`TemplateHaskell`机制，就可以从上面扩展我们的`quasiquotation`，我们可以实现用于传递`Haskell`值和通过在模板表达式上进行模式匹配将`Haskell`值拉出的同一类逻辑。\n```haskell\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE DeriveDataTypeable #-}\n\nmodule Antiquote where\n\nimport Data.Generics\nimport Language.Haskell.TH\nimport Language.Haskell.TH.Quote\n\nimport Text.Parsec\nimport Text.Parsec.String (Parser)\nimport Text.Parsec.Language (emptyDef)\n\nimport qualified Text.Parsec.Expr as Ex\nimport qualified Text.Parsec.Token as Tok\n\ndata Expr\n  = Tr\n  | Fl\n  | Zero\n  | Succ Expr\n  | Pred Expr\n  | Antiquote String\n  deriving (Eq, Show, Data, Typeable)\n\nlexer :: Tok.TokenParser ()\nlexer = Tok.makeTokenParser emptyDef\n\nparens :: Parser a -> Parser a\nparens = Tok.parens lexer\n\nreserved :: String -> Parser ()\nreserved = Tok.reserved lexer\n\nidentifier :: Parser String\nidentifier = Tok.identifier lexer\n\nsemiSep :: Parser a -> Parser [a]\nsemiSep = Tok.semiSep lexer\n\nreservedOp :: String -> Parser ()\nreservedOp = Tok.reservedOp lexer\n\noper s f assoc = Ex.Prefix (reservedOp s >> return f)\n\ntable = [ oper \"succ\" Succ Ex.AssocLeft\n        , oper \"pred\" Pred Ex.AssocLeft\n        ]\n\nexpr :: Parser Expr\nexpr = Ex.buildExpressionParser [table] factor\n\ntrue, false, zero :: Parser Expr\ntrue  = reserved \"true\" >> return Tr\nfalse = reserved \"false\" >> return Fl\nzero  = reservedOp \"0\" >> return Zero\n\nantiquote :: Parser Expr\nantiquote = do\n  char '$'\n  var <- identifier\n  return $ Antiquote var\n\nfactor :: Parser Expr\nfactor = true\n      <|> false\n      <|> zero\n      <|> antiquote\n      <|> parens expr\n\ncontents :: Parser a -> Parser a\ncontents p = do\n  Tok.whiteSpace lexer\n  r <- p\n  eof\n  return r\n\nparseExpr :: String -> Either ParseError Expr\nparseExpr s = parse (contents expr) \"<stdin>\" s\n\n\nclass Expressible a where\n  express :: a -> Expr\n\ninstance Expressible Expr where\n  express = id\n\ninstance Expressible Bool where\n  express True = Tr\n  express False = Fl\n\ninstance Expressible Integer where\n  express 0 = Zero\n  express n = Succ (express (n - 1))\n\n\nexprE :: String -> Q Exp\nexprE s = do\n  filename <- loc_filename `fmap` location\n  case parse (contents expr) filename s of\n    Left err -> error (show err)\n    Right exp -> dataToExpQ (const Nothing `extQ` antiExpr) exp\n\nexprP :: String -> Q Pat\nexprP s = do\n  filename <- loc_filename `fmap` location\n  case parse (contents expr) filename s of\n    Left err -> error (show err)\n    Right exp -> dataToPatQ (const Nothing `extQ` antiExprPat) exp\n\n-- antiquote RHS\nantiExpr :: Expr -> Maybe (Q Exp)\nantiExpr (Antiquote v) = Just embed\n  where embed = [| express $(varE (mkName v)) |]\nantiExpr _ = Nothing\n\n-- antiquote LHS\nantiExprPat :: Expr -> Maybe (Q Pat)\nantiExprPat (Antiquote v) = Just $ varP (mkName v)\nantiExprPat _ = Nothing\n\nmini :: QuasiQuoter\nmini = QuasiQuoter exprE exprP undefined undefined\n{-# LANGUAGE QuasiQuotes #-}\n\nimport Antiquote\n\n-- extract\na :: Expr -> Expr\na [mini|succ $x|] = x\n\nb :: Expr -> Expr\nb [mini|succ $x|] = [mini|pred $x|]\n\nc :: Expressible a => a -> Expr\nc x = [mini|succ $x|]\n\nd :: Expr\nd = c (8 :: Integer)\n-- Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ Zero)))))))\n\ne :: Expr\ne = c True\n-- Succ Tr\n```\n\n### Templated Type Families\n> 这是高级部分，编写Haskell通常无需了解TemplateHaskell.\n\n就像在`value-level`级别上一样，我们可以通过将它们的`AST`拼凑在一起来构造`type-level`(类型级别)的构造。\n```haskell\nType          AST\n----------    ----------\nt1 -> t2      ArrowT `AppT` t2 `AppT` t2\n[t]           ListT `AppT` t\n(t1,t2)       TupleT 2 `AppT` t1 `AppT` t2\n```\n例如，考虑到类型级算术在`GHC 7.6`中仍然有点不完整，但通常情况下，类型级`numbers`(数字)的范围不是完整的整数集，而是一些有界的数字集。相反，我们可以用类型族来定义操作，而不是使用归纳定义(通常需要手动证明)，只需将参数的整个域枚举到类型族，并将它们映射到编译时计算的某个结果。\n\n例如，`modulus`(模)运算符在类型级别实现是非常`non-trivial`(重要)的，但是我们可以使用`enumFamily`函数在`type-family`中进行`splice`(拼接)，该函数只需枚举所有可能的数字对，直到所需的深度。\n```haskell\nmodule EnumFamily where\nimport Language.Haskell.TH\n\nenumFamily :: (Integer -> Integer -> Integer)\n           -> Name\n           -> Integer\n           -> Q [Dec]\nenumFamily f bop upper = return decls\n  where\n    decls = do\n      i <- [1..upper]\n      j <- [2..upper]\n      return $ TySynInstD bop (rhs i j)\n\n    rhs i j = TySynEqn\n      [LitT (NumTyLit i), LitT (NumTyLit j)]\n      (LitT (NumTyLit (i `f` j)))\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nimport EnumFamily\n\nimport Data.Proxy\nimport GHC.TypeLits\n\ntype family Mod (m :: Nat) (n :: Nat) :: Nat\ntype family Add (m :: Nat) (n :: Nat) :: Nat\ntype family Pow (m :: Nat) (n :: Nat) :: Nat\n\nenumFamily mod ''Mod 10\nenumFamily (+) ''Add 10\nenumFamily (^) ''Pow 10\n\na :: Integer\na = natVal (Proxy :: Proxy (Mod 6 4))\n-- 2\n\nb :: Integer\nb = natVal (Proxy :: Proxy (Pow 3 (Mod 6 4)))\n-- 9\n\n--    enumFamily mod ''Mod 3\n--  ======>\n--    template_typelevel_splice.hs:7:1-14\n--    type instance Mod 2 1 = 0\n--    type instance Mod 2 2 = 0\n--    type instance Mod 2 3 = 2\n--    type instance Mod 3 1 = 0\n--    type instance Mod 3 2 = 1\n--    type instance Mod 3 3 = 0\n--    ...\n```\n在实践中，尽管编译时间可能会因此增加一些，但`GHC`对于大量的`type-family`(类型族)声明似乎很好。\n`singletons`库还提供了一种自动化此过程的方法，它允许我们在`quasiqoter`中编写看似值级别的声明，然后将逻辑`promoting`(提升)到类型级别。\n例如，如果我们想为`HList`编写一个值级别和类型级别的映射函数，这通常需要相当多的样板文件，现在可以非常简洁地说明。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE TypeSynonymInstances #-}\n\nimport Data.Singletons\nimport Data.Singletons.TH\n\n$(promote [d|\n  map :: (a -> b) -> [a] -> [b]\n  map _ [] = []\n  map f (x:xs) = f x : map f xs\n  |])\n\ninfixr 5 :::\n\ndata HList (ts :: [ * ]) where\n  Nil :: HList '[]\n  (:::) :: t -> HList ts -> HList (t ': ts)\n\n-- TypeLevel\n-- MapJust :: [*] -> [Maybe *]\ntype MapJust xs = Map Maybe xs\n\n-- Value Level\n-- mapJust :: [a] -> [Maybe a]\nmapJust :: HList xs -> HList (MapJust xs)\nmapJust Nil = Nil\nmapJust (x ::: xs) = (Just x) ::: mapJust xs\n\ntype A = [Bool, String , Double , ()]\n\na :: HList A\na = True ::: \"foo\" ::: 3.14 ::: () ::: Nil\n\nexample1 :: HList (MapJust A)\nexample1 = mapJust a\n\n-- example1 reduces to example2 when expanded\n-- 展开后，example1`化简`为example2\nexample2 :: HList ([Maybe Bool, Maybe String , Maybe Double , Maybe ()])\nexample2 = Just True ::: Just \"foo\" ::: Just 3.14 ::: Just () ::: Nil\n```\n\n### Templated Type Classes\n> 这是高级部分，编写Haskell通常无需了解TemplateHaskell.\n\n`Template Haskell`的最常见用法是自动生成类型类实例。考虑一下，如果我们想为`flat`(平面)数据结构编写一个简单的`Pretty`打印类，该类根据`AST`中构造函数的名称`derived`(派生)出`ppr`方法，我们可以编写一个简单的实例。\n```haskell\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FlexibleContexts #-}\n\nmodule Class where\n\nimport Language.Haskell.TH\n\nclass Pretty a where\n  ppr :: a -> String\n\nnormalCons :: Con -> Name\nnormalCons (NormalC n _) = n\n\ngetCons :: Info -> [Name]\ngetCons cons = case cons of\n    TyConI (DataD    _ _ _ tcons _) -> map normalCons tcons\n    con -> error $ \"Can't derive for:\" ++ (show con)\n\npretty :: Name -> Q [Dec]\npretty dt = do\n  info <- reify dt\n  Just cls <- lookupTypeName \"Pretty\"\n  let datatypeStr = nameBase dt\n  let cons = getCons info\n  let dtype = mkName (datatypeStr)\n  let mkInstance xs =\n        InstanceD\n        []                              -- Context\n        (AppT\n          (ConT cls)                    -- Instance\n          (ConT dtype))                 -- Head\n        [(FunD (mkName \"ppr\") xs)]      -- Methods\n  let methods = map cases cons\n  return $ [mkInstance methods]\n\n-- Pattern matches on the ``ppr`` method\ncases :: Name -> Clause\ncases a = Clause [ConP a []] (NormalB (LitE (StringL (nameBase a)))) []\n```\n在一个单独的文件中，在`top-level`(顶层)调用`pretty`实例，如果要查看已`spliced`(拼接)的类实例，则使用`--ddump-splice`。\n```haskell\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nimport Class\n\ndata PlatonicSolid\n  = Tetrahedron\n  | Cube\n  | Octahedron\n  | Dodecahedron\n  | Icosahedron\n\npretty ''PlatonicSolid\n\nmain :: IO ()\nmain = do\n  putStrLn (ppr Octahedron)\n  putStrLn (ppr Dodecahedron)\n```\n\n### Multiline Strings\n`Haskell`不支持多行字符串文本，尽管我们可以使用`quasiqueoter`来模拟它。然后使用`tostring`将得到的`String`文本转换为`desired`(所需)的任何结果类型。\n```haskell\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Multiline (s) where\n\nimport Data.String\nimport Language.Haskell.TH.Quote\n\ns :: QuasiQuoter\ns = QuasiQuoter\n  { quoteExp  = (\\a -> [|fromString a|]) . trim\n  , quotePat  = \\_ -> fail \"illegal raw string QuasiQuote\"\n  , quoteType = \\_ -> fail \"illegal raw string QuasiQuote\"\n  , quoteDec  = \\_ -> fail \"illegal raw string QuasiQuote\"\n  }\n\ntrim :: String -> String\ntrim ('\\n':xs) = xs\ntrim xs = xs\n```\n然后，在一个单独的模块中，我们可以启用`Quasiquotes`并嵌入字符串。\n```haskell\n{-# LANGUAGE QuasiQuotes #-}\n\nimport Multiline (s)\nimport qualified Data.Text as T\n\nfoo :: T.Text\nfoo = [s|\nThis\nis\nmy\nmultiline\nstring\n|]\n```\n\n### git-embed (嵌入)\n通常需要在可执行文件中嵌入生成的特定`Git`版本哈希。\n使用`git-embed`，编译器将有效地向命令行发出`shell`，以检索`CWD Git`存储库的版本信息，并在编译时使用`Template Haskell`定义然後嵌入此信息。\n这对于在程序或服务的命令行接口中嵌入版本信息通常很有用。\n```haskell\n{-# LANGUAGE TemplateHaskell #-}\n\nimport Git.Embed\nimport Data.Version\nimport Paths_myprog\n\ngitRev :: String\ngitRev = $(embedGitShortRevision)\n\ngitBranch :: String\ngitBranch = $(embedGitBranch)\n\nver :: String\nver = showVersion Paths_myprog.version\n```\n請看: \n* [git-embed](https://hackage.haskell.org/package/git-embed)\n\n","tags":["Template-Haskell"]},{"title":"Haskell-Streaming","url":"/blog/2019/10/16/Haskell-Streaming/","content":"> [原文](http://dev.stephendiehl.com/hask/#streaming)\n\n### Lazy IO\n使用常规的`monadic`方法处理通过`IO`积累的数据的问题在于，`Prelude`工具要求我们在开始计算之前就一次在内存中显示大量数据。\n```haskell\nmapM :: (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)\nsequence :: (Monad m, Traversable t) => t (m a) -> m (t a)\n```\n从文件中读取将为强制读取的字符串创建一个`thunk`，然后读取文件。问题在于，这种方法将`IO effects`(效果)的顺序与评估顺序联系在一起，而这很难在很大程度上进行推理。\n\n考虑到通常情況下,`monad`法律(在没有`Seq`的情况下)保证这些计算应该是`identical`(相同/恒等)的。但是，使用惰性`IO`可以构造一个`degenerate`(简并)的案例。\n```haskell\nimport System.IO\n\nmain :: IO ()\nmain = do\n  withFile \"foo.txt\" ReadMode $ \\fd -> do\n    contents <- hGetContents fd\n    print contents\n  -- \"foo\\n\"\n\n  contents <- withFile \"foo.txt\" ReadMode hGetContents\n  print contents\n  -- \"\"\n```\n因此，我们需要一个系统，以确保在使用恒定内存的情况下进行确定性资源处理。为此，`Conduits`和`Pipes`库都使用不同的(虽然在很大程度上是等效的)方法解决了此问题。\n\n### Pipes\n```haskell\nawait :: Monad m => Pipe a y m a\nyield :: Monad m => a -> Pipe x a m ()\n\n(>->) :: Monad m\n      => Pipe a b m r\n      -> Pipe b c m r\n      -> Pipe a c m r\n\nrunEffect :: Monad m => Effect m r -> m r\ntoListM :: Monad m => Producer a m () -> m [a]\n```\n`Pipes`是一个流处理库，非常强调组合的静态语义。最简单的用法是将`pipe`函数与`(>->)`組合运算符相连接，其中每个组件都可以通过`await`和`yield`函數順著`stream`來`push`(推)和`pull`(拉)值。\n```haskell\nimport Pipes\nimport Pipes.Prelude as P\nimport Control.Monad\nimport Control.Monad.Identity\n\na :: Producer Int Identity ()\na = forM_ [1..10] yield\n\nb :: Pipe Int Int Identity ()\nb =  forever $ do\n  x <- await\n  yield (x*2)\n  yield (x*3)\n  yield (x*4)\n\nc :: Pipe Int Int Identity ()\nc = forever $ do\n  x <- await\n  if (x `mod` 2) == 0\n    then yield x\n    else return ()\n\nresult :: [Int]\nresult = P.toList $ a >-> b >-> c\n```\n例如，我们可以构造一个`FizzBuzz`管道:\n```haskell\n{-# LANGUAGE MultiWayIf #-}\n\nimport Pipes\nimport qualified Pipes.Prelude as P\n\ncount :: Producer Integer IO ()\ncount = each [1..100]\n\nfizzbuzz :: Pipe Integer String IO ()\nfizzbuzz = do\n  n <- await\n  if | n `mod` 15 == 0 -> yield \"FizzBuzz\"\n     | n `mod` 5  == 0 -> yield \"Fizz\"\n     | n `mod` 3  == 0 -> yield \"Buzz\"\n     | otherwise       -> return ()\n  fizzbuzz\n\nmain :: IO ()\nmain = runEffect $ count >-> fizzbuzz >-> P.stdoutLn\n```\n为了继续使用我们的`Lazy IO`构建的`degenerate`(简并)案例，现在考虑一下，我们现在可以在文件上`compose`(组合)和`sequence deterministic actions`(顺序确定的操作)，而不必担心`effect`(影响)顺序。\n```haskell\nimport Pipes\nimport Pipes.Prelude as P\nimport System.IO\n\nreadF :: FilePath -> Producer String IO ()\nreadF file = do\n    lift $ putStrLn $ \"Opened\" ++ file\n    h <- lift $ openFile file ReadMode\n    fromHandle h\n    lift $ putStrLn $ \"Closed\" ++ file\n    lift $ hClose h\n\nmain :: IO ()\nmain = runEffect $ readF \"foo.txt\" >-> P.take 3 >-> stdoutLn\n```\n这只是`pipes`功能的简单示例。\n关于管道的文档非常详尽,并且做了大量的工作，使得这个库非常`thorough`(全面/透彻/周密)。\n`pipes`是一个`accessible`(可访问的)、范畴理论驱动的设计的光辉范例。\n\n請看: [Pipes Tutorial](http://hackage.haskell.org/package/pipes-4.1.0/docs/Pipes-Tutorial.html)\n\n### Safe Pipes\n```haskell\nbracket :: MonadSafe m => Base m a -> (a -> Base m b) -> (a -> m c) -> m c\n```\n作为一个激励性的例子，`ZeroMQ`是一个网络消息库，它通过传统的`Unix套`接字抽象为各种网络拓扑。\n最值得注意的是，它并非旨在保证在发生错误时能为`delivery`(交付)或`recovery`(恢复)提供任何形式的事務性保证，因此有必要在其之上设计一个层,以在应用程序层提供所需的行为。\n\n在`Haskell`中，我们希望保证，如果在`socket`上进行轮询，我们会及时收到消息，或者将资源视为处于错误状态并从中恢复。\n使用`pipes-safe`，我们可以管理惰性`io`资源的生命周期，并可以安全地处理`failures`(故障)、`resource termination`(资源终止)和`finalization gracefully`(优雅地完成)。\n在其他语言中，这种逻辑可能会被分散在几个地方，或者放在一些全局上下文中，容易引入错误和微妙的`race`(种族/競爭)条件。使用管道，我们得到了一个很好的紧凑的抽象设计，正好适合这种用例。\n\n例如，现在我们可以将`ZeroMQ`套接字创建和终结放在`SafeT monad transformer`中，它保证在成功传递消息之后，我们能按预期执行管道功能，或者在失败时，`halt`(停止)执行并`finalize`(终结)套接字。\n```haskell\nimport Pipes\nimport Pipes.Safe\nimport qualified Pipes.Prelude as P\n\nimport System.Timeout (timeout)\nimport Data.ByteString.Char8\nimport qualified System.ZMQ as ZMQ\n\ndata Opts = Opts\n  { _addr    :: String  -- ^ ZMQ socket address\n  , _timeout :: Int     -- ^ Time in milliseconds for socket timeout\n  }\n\nrecvTimeout :: Opts -> ZMQ.Socket a -> Producer ByteString (SafeT IO) ()\nrecvTimeout opts sock = do\n  body <- liftIO $ timeout (_timeout opts) (ZMQ.receive sock [])\n  case body of\n    Just msg -> do\n      liftIO $ ZMQ.send sock msg []\n      yield msg\n      recvTimeout opts sock\n    Nothing  -> liftIO $ print \"socket timed out\"\n\ncollect :: ZMQ.Context\n        -> Opts\n        -> Producer ByteString (SafeT IO) ()\ncollect ctx opts = bracket zinit zclose (recvTimeout opts)\n  where\n    -- Initialize the socket\n    zinit = do\n      liftIO $ print \"waiting for messages\"\n      sock <- ZMQ.socket ctx ZMQ.Rep\n      ZMQ.bind sock (_addr opts)\n      return sock\n\n    -- On timeout or completion guarantee the socket get closed.\n    zclose sock = do\n      liftIO $ print \"finalizing\"\n      ZMQ.close sock\n\nrunZmq :: ZMQ.Context -> Opts -> IO ()\nrunZmq ctx opts = runSafeT $ runEffect $\n  collect ctx opts >-> P.take 10 >-> P.print\n\nmain :: IO ()\nmain = do\n  ctx <- ZMQ.init 1\n  let opts = Opts {_addr = \"tcp://127.0.0.1:8000\", _timeout = 1000000 }\n  runZmq ctx opts\n  ZMQ.term ctx\n```\n\n### Conduits\n```haskell\nawait :: Monad m => ConduitM i o m (Maybe i)\nyield :: Monad m => o -> ConduitM i o m ()\n($$) :: Monad m => Source m a -> Sink a m b -> m b\n(=$) :: Monad m => Conduit a m b -> Sink b m c -> Sink a m c\n\ntype Sink i = ConduitM i Void\ntype Source m o = ConduitM () o m ()\ntype Conduit i m o = ConduitM i o m ()\n```\n尽管在解决`IO`资源的恒定空间确定性资源处理(`constant space deterministic resource handling for IO resources`)的同一问题的哲学方法上不同，但`Conduits`在概念上是相似的。\n\n第一个初始区别是，`await`函数现在返回一个`Maybe`，它允许对`termination`(终止)进行不同的处理。`composition`(合成)运算符还分为`connecting`(连接)运算符`($$)`和`fusing`(融合)运算符`(=$)`，分别用于组合`Sources`和`Sink`以及`Conduit`和`Sink`。\n```haskell\n{-# LANGUAGE MultiWayIf #-}\n\nimport Data.Conduit\nimport Control.Monad.Trans\nimport qualified Data.Conduit.List as CL\n\nsource :: Source IO Int\nsource = CL.sourceList [1..100]\n\nconduit :: Conduit Int IO String\nconduit = do\n  val <- await\n  liftIO $ print val\n  case val of\n    Nothing -> return ()\n    Just n -> do\n      if | n `mod` 15 == 0 -> yield \"FizzBuzz\"\n         | n `mod` 5  == 0 -> yield \"Fizz\"\n         | n `mod` 3  == 0 -> yield \"Buzz\"\n         | otherwise       -> return ()\n      conduit\n\nsink :: Sink String IO ()\nsink = CL.mapM_ putStrLn\n\nmain :: IO ()\nmain = source $$ conduit =$ sink\n```\n\n請看: [Conduit Overview](https://www.fpcomplete.com/user/snoyberg/library-documentation/conduit-overview)\n\n\n","tags":["Streaming"]},{"title":"Haskell-Parsing","url":"/blog/2019/10/16/Haskell-Parsing/","content":"> [原文](http://dev.stephendiehl.com/hask/#parsing)\n\n### Parsec\n对于在`Haskell`进行解析，使用称为`Parser Combinators`的库家族是很常见的，该库使我们可以编写代码来生成解析器，它们本身看起来与解析器语法本身非常相似！\n```haskell\n\t     Combinators\n---------------------------\n<|>\t     选择运算符在继续处理第二个参数之前尝试分析第一个参数。它可以按顺序链接以生成一系列选项。\nmany\t 消耗与给定模式匹配的任意数量的模式，并将它们作为列表返回。\nmany1\t 与many一样，但至少需要一个匹配。\noptional 可选地解析给定的模式，返回其值作为Maybe。\ntry\t     回溯运算符将允许我们解析不明确的匹配表达式，并使用不同的模式重新启动。\n```\n`Parsec`有两种编写风格，一种可以选择使用`monad`编写，另一种可以选择使用`applicatives`编写。\n```haskell\nparseM :: Parser Expr\nparseM = do\n  a <- identifier\n  char '+'\n  b <- identifier\n  return $ Add a b\n```\n使用`applicatives`编写的相同代码，使用`applicative combinator`:\n```haskell\n-- | Sequential application.\n(<*>) :: f (a -> b) -> f a -> f b\n\n-- | Sequence actions, discarding the value of the first argument.\n(*>) :: f a -> f b -> f b\n(*>) = liftA2 (const id)\n\n-- | Sequence actions, discarding the value of the second argument.\n(<*) :: f a -> f b -> f a\n(<*) = liftA2 const\nparseA :: Parser Expr\nparseA = Add <$> identifier <* char '+' <*> identifier\n```\n现在，例如，如果我们想解析简单的`lambda`表达式，我们可以将解析器逻辑编码为这些组合器的组合，当使用`parse`进行评估时，这些组合器将产生`string parser`(字符串解析器)。\n```haskell\nimport Text.Parsec\nimport Text.Parsec.String\n\ndata Expr\n  = Var Char\n  | Lam Char Expr\n  | App Expr Expr\n  deriving Show\n\nlam :: Parser Expr\nlam = do\n  char '\\\\'\n  n <- letter\n  string \"->\"\n  e <- expr\n  return $ Lam n e\n\napp :: Parser Expr\napp = do\n  apps <- many1 term\n  return $ foldl1 App apps\n\nvar :: Parser Expr\nvar = do\n  n <- letter\n  return $ Var n\n\nparens :: Parser Expr -> Parser Expr\nparens p = do\n  char '('\n  e <- p\n  char ')'\n  return e\n\nterm :: Parser Expr\nterm = var <|> parens expr\n\nexpr :: Parser Expr\nexpr = lam <|> app\n\ndecl :: Parser Expr\ndecl = do\n  e <- expr\n  eof\n  return e\n\ntest :: IO ()\ntest = parseTest decl \"\\\\y->y(\\\\x->x)y\"\n\nmain :: IO ()\nmain = test >>= print\n```\n\n### Custom Lexer (自定义词法分析器)\n在我们之前的示例中，无需进行`lexing pass`(词法遍历)，因为每个`lexeme`(词素)都映射到流类型中字符的顺序集合。如果我们想用一组`non-trivial`(不重要)的`tokens`(令牌/标记)集合来扩展此解析器，则`Parsec`为我们提供了一组函数，用于定义词法分析器并将其与`parser combinators`(解析器组合器)集成在一起。\n最简单的示例建立在内置的`Parsec`语言定义之上，该定义定义了一组最常见的词汇方案。\n\n例如，我们将在使用`Text token`(标记)而不是字符串的`haskellDef`语法之上构建`empty`(空)语言语法。\n```haskell\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Text.Parsec\nimport Text.Parsec.Text\nimport qualified Text.Parsec.Token as Tok\nimport qualified Text.Parsec.Language as Lang\n\nimport Data.Functor.Identity (Identity)\nimport qualified Data.Text as T\nimport qualified Data.Text.IO as TIO\n\ndata Expr\n  = Var T.Text\n  | App Expr Expr\n  | Lam T.Text Expr\n  deriving (Show)\n\nlexer :: Tok.GenTokenParser T.Text () Identity\nlexer = Tok.makeTokenParser style\n\nstyle :: Tok.GenLanguageDef T.Text () Identity\nstyle = Lang.emptyDef\n  { Tok.commentStart    = \"{-\"\n  , Tok.commentEnd      = \"-}\"\n  , Tok.commentLine     = \"--\"\n  , Tok.nestedComments  = True\n  , Tok.identStart      = letter\n  , Tok.identLetter     = alphaNum <|> oneOf \"_'\"\n  , Tok.opStart         = Tok.opLetter style\n  , Tok.opLetter        = oneOf \":!#$%&*+./<=>?@\\\\^|-~\"\n  , Tok.reservedOpNames = []\n  , Tok.reservedNames   = []\n  , Tok.caseSensitive   = True\n  }\n\nparens :: Parser a -> Parser a\nparens = Tok.parens lexer\n\nreservedOp :: T.Text -> Parser ()\nreservedOp op = Tok.reservedOp lexer (T.unpack op)\n\nident :: Parser T.Text\nident = T.pack <$> Tok.identifier lexer\n\ncontents :: Parser a -> Parser a\ncontents p = do\n  Tok.whiteSpace lexer\n  r <- p\n  eof\n  return r\n\nvar :: Parser Expr\nvar = do\n  var <- ident\n  return (Var var )\n\napp :: Parser Expr\napp = do\n  e1 <- expr\n  e2 <- expr\n  return (App e1 e2)\n\nfun :: Parser Expr\nfun = do\n  reservedOp \"\\\\\"\n  binder <- ident\n  reservedOp \".\"\n  rhs <- expr\n  return (Lam binder rhs)\n\nexpr :: Parser Expr\nexpr = do\n  es <- many1 aexp\n  return (foldl1 App es)\n\naexp :: Parser Expr\naexp = fun <|> var <|> (parens expr)\n\ntest :: T.Text -> Either ParseError Expr\ntest = parse (contents expr) \"<stdin>\"\n\nrepl :: IO ()\nrepl = do\n  str <- TIO.getLine\n  print (test str)\n  repl\n\nmain :: IO ()\nmain = repl\n```\n請看:\n* [Text.Parsec.Language](https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Language.html)\n\n### Simple Parsing\n将我们的词法分析器和解析器放在一起，我们可以为我们的小`λ`演算语法编写一个更强大的解析器。\n```haskell\nmodule Parser (parseExpr) where\n\nimport Text.Parsec\nimport Text.Parsec.String (Parser)\nimport Text.Parsec.Language (haskellStyle)\n\nimport qualified Text.Parsec.Expr as Ex\nimport qualified Text.Parsec.Token as Tok\n\ntype Id = String\n\ndata Expr\n  = Lam Id Expr\n  | App Expr Expr\n  | Var Id\n  | Num Int\n  | Op  Binop Expr Expr\n  deriving (Show)\n\ndata Binop = Add | Sub | Mul deriving Show\n\nlexer :: Tok.TokenParser ()\nlexer = Tok.makeTokenParser style\n  where ops = [\"->\",\"\\\\\",\"+\",\"*\",\"-\",\"=\"]\n        style = haskellStyle {Tok.reservedOpNames = ops }\n\nreservedOp :: String -> Parser ()\nreservedOp = Tok.reservedOp lexer\n\nidentifier :: Parser String\nidentifier = Tok.identifier lexer\n\nparens :: Parser a -> Parser a\nparens = Tok.parens lexer\n\ncontents :: Parser a -> Parser a\ncontents p = do\n  Tok.whiteSpace lexer\n  r <- p\n  eof\n  return r\n\nnatural :: Parser Integer\nnatural = Tok.natural lexer\n\nvariable :: Parser Expr\nvariable = do\n  x <- identifier\n  return (Var x)\n\nnumber :: Parser Expr\nnumber = do\n  n <- natural\n  return (Num (fromIntegral n))\n\nlambda :: Parser Expr\nlambda = do\n  reservedOp \"\\\\\"\n  x <- identifier\n  reservedOp \"->\"\n  e <- expr\n  return (Lam x e)\n\naexp :: Parser Expr\naexp =  parens expr\n    <|> variable\n    <|> number\n    <|> lambda\n\nterm :: Parser Expr\nterm = Ex.buildExpressionParser table aexp\n  where infixOp x f = Ex.Infix (reservedOp x >> return f)\n        table = [[infixOp \"*\" (Op Mul) Ex.AssocLeft],\n                 [infixOp \"+\" (Op Add) Ex.AssocLeft]]\n\nexpr :: Parser Expr\nexpr = do\n  es <- many1 term\n  return (foldl1 App es)\n\nparseExpr :: String -> Expr\nparseExpr input =\n  case parse (contents expr) \"<stdin>\" input of\n    Left err -> error (show err)\n    Right ast -> ast\n\nmain :: IO ()\nmain = getLine >>= print . parseExpr >> main\n```\n尝试一下:\n```haskell\nλ: runhaskell simpleparser.hs\n1+2\nOp Add (Num 1) (Num 2)\n\n\\i -> \\x -> x\nLam \"i\" (Lam \"x\" (Var \"x\"))\n\n\\s -> \\f -> \\g -> \\x -> f x (g x)\nLam \"s\" (Lam \"f\" (Lam \"g\" (Lam \"x\" (App (App (Var \"f\") (Var \"x\")) (App (Var \"g\") (Var \"x\"))))))\n```\n\n### Generic Parsing\n以前，我们为漂亮的打印定义了`generic`(通用/泛型)运算，这引出了我们是否可以在`Generics`(通用/泛型)之上编写解析器的问题。\n答案是肯定的，只要特定`lexemes`(词素)与`sum`和`products`类型之间存在直接映射即可。\n考虑最简单的情况，我们只是使用`regular`(常规)泛型机制读取构造函数的名称，然后为其构建一个`Parsec`解析器`terms`(术语)。\n```haskell\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nimport Text.Parsec\nimport Text.Parsec.Text.Lazy\nimport Control.Applicative ((<*), (<*>), (<$>))\nimport GHC.Generics\n\nclass GParse f where\n  gParse :: Parser (f a)\n\n-- Type synonym metadata for constructors\ninstance (GParse f, Constructor c) => GParse (C1 c f) where\n  gParse =\n    let con = conName (undefined :: t c f a) in\n    (fmap M1 gParse) <* string con\n\n-- Constructor names\ninstance GParse f => GParse (D1 c f) where\n  gParse = fmap M1 gParse\n\n-- Sum types\ninstance (GParse a, GParse b) => GParse (a :+: b) where\n  gParse = try (fmap L1 gParse <|> fmap R1 gParse)\n\n-- Product types\ninstance (GParse f, GParse g) => GParse (f :*: g) where\n  gParse = (:*:) <$> gParse <*> gParse\n\n-- Nullary constructors\ninstance GParse U1 where\n  gParse = return U1\n\ndata Scientist\n  = Newton\n  | Einstein\n  | Schrodinger\n  | Feynman\n  deriving (Show, Generic)\n\ndata Musician\n  = Vivaldi\n  | Bach\n  | Mozart\n  | Beethoven\n  deriving (Show, Generic)\n\ngparse :: (Generic g, GParse (Rep g)) => Parser g\ngparse = fmap to gParse\n\nscientist :: Parser Scientist\nscientist = gparse\n\nmusician :: Parser Musician\nmusician = gparse\nλ: parseTest parseMusician \"Bach\"\nBach\n\nλ: parseTest parseScientist \"Feynman\"\nFeynman\n```\n通过更多的工作和外部包装，可以轻松扩展此示例以自动解析简单的递归类型。\n```haskell\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE DefaultSignatures #-}\n\nimport Control.Applicative    ((<*), (*>), (<*>), (<$>), pure)\nimport GHC.Generics\nimport Text.Parsec            ((<|>), string, try, many1, digit, char, letter, spaces)\nimport Text.Parsec.Text.Lazy  (Parser)\n\nclass GParse f where\n  gParse :: Parser (f a)\n\n-- Types\ninstance (Parse a) => GParse (K1 R a) where\n  gParse = fmap K1 parse\n\n-- Selector names\ninstance (GParse f, Selector s) => GParse (M1 S s f) where\n  gParse = fmap M1 gParse\n\n-- Type synonym metadata for constructors\ninstance (GParse f, Constructor c) => GParse (C1 c f) where\n  gParse =\n    let con = conName (undefined :: t c f a) in\n      (spaces >> string con >> spaces) *> fmap M1 gParse\n\n-- Constructor names\ninstance (Datatype d, GParse f) => GParse (D1 d f) where\n  gParse = fmap M1 gParse\n\n-- Sum types\ninstance (GParse a, GParse b) => GParse (a :+: b) where\n  gParse = try (fmap L1 gParse) <|> try (fmap R1 gParse)\n\n-- Product types\ninstance (GParse f, GParse g) => GParse (f :*: g) where\n  gParse = (:*:) <$> try gParse <*> try gParse\n\n-- Nullary constructors\ninstance GParse U1 where\n  gParse = return U1\n\ngparse :: (Generic g, GParse (Rep g)) => Parser g\ngparse = fmap to gParse\n\nclass Parse a where\n  parse :: Parser a\n  default parse :: (Generic a, GParse (Rep a)) => Parser a\n  parse = spaces >> char '(' >> gparse >>= \\e -> char ')' >> return e\n\ninstance Parse Integer where\n  parse = rd <$> (plus <|> minus <|> number)\n    where rd     = read :: String -> Integer\n          plus   = char '+' *> number\n          minus  = (:) <$> char '-' <*> number\n          number = many1 digit\n\ninstance Parse String where\n   parse = many1 letter\n\ntype Name = String\n\ndata Exp \n  = Lit Integer\n  | Var Name\n  | Plus Exp Exp \n  | App Exp Exp \n  | Abs Name Exp deriving (Show, Generic, Parse)\n\nexpr :: Parser Exp\nexpr = parse\nλ: parseTest expr \"(App (Plus (Lit 1) (Var n)) (App (Plus (Lit 5) (Lit 5)) (Plus (Lit 6) (Lit 6))))\"\nApp (Plus (Lit 1) (Var \"n\")) (App (Plus (Lit 5) (Lit 5)) (Plus (Lit 6) (Lit 6)))\n```\n\n### Attoparsec\n`Attoparsec`是类似于`Parsec`的解析器组合器，但更适合于大文本和二进制文件的批量解析，而不是将语言语法解析为`AST`。正确编写后，`Attoparsec`解析器可能会[efficient](http://www.serpentine.com/blog/2014/05/31/attoparsec/)。\n\n`Parsec`和`Attoparsec`之间的显着区别是不存在回溯运算符`(try)`，而是反映在`attoparsec`的不同底层解析器模型上。\n\n对于简单的小`λ`演算语言，我们可以像使用`parsec`一样使用`attoparsec`:\n```haskell\n{-# LANGUAGE OverloadedStrings #-}\n{-# OPTIONS_GHC -fno-warn-unused-do-bind #-}\n\nimport Control.Applicative\nimport Data.Attoparsec.Text\nimport qualified Data.Text as T\nimport qualified Data.Text.IO as T\nimport Data.List (foldl1')\n\ndata Name\n  = Gen Int\n  | Name T.Text\n  deriving (Eq, Show, Ord)\n\ndata Expr\n  = Var Name\n  | App Expr Expr\n  | Lam [Name] Expr\n  | Lit Int\n  | Prim PrimOp\n  deriving (Eq, Show)\n\ndata PrimOp\n  = Add\n  | Sub\n  | Mul\n  | Div\n  deriving (Eq, Show)\n\ndata Defn = Defn Name Expr\n  deriving (Eq, Show)\n\nname :: Parser Name\nname = Name . T.pack <$> many1 letter\n\nnum :: Parser Expr\nnum = Lit <$> signed decimal\n\nvar :: Parser Expr\nvar = Var <$> name\n\nlam :: Parser Expr\nlam = do\n  string \"\\\\\"\n  vars <- many1 (skipSpace *> name)\n  skipSpace *> string \"->\"\n  body <- expr\n  return (Lam vars body)\n\neparen :: Parser Expr\neparen = char '(' *> expr <* skipSpace <* char ')'\n\nprim :: Parser Expr\nprim = Prim <$> (\n      char '+' *> return Add\n  <|> char '-' *> return Sub\n  <|> char '*' *> return Mul\n  <|> char '/' *> return Div)\n\nexpr :: Parser Expr\nexpr = foldl1' App <$> many1 (skipSpace *> atom)\n\natom :: Parser Expr\natom = try lam\n    <|> eparen\n    <|> prim\n    <|> var\n    <|> num\n\ndef :: Parser Defn\ndef = do\n  skipSpace\n  nm <- name\n  skipSpace *> char '=' *> skipSpace\n  ex <- expr\n  skipSpace <* char ';'\n  return $ Defn nm ex\n\nfile :: T.Text -> Either String [Defn]\nfile = parseOnly (many def <* skipSpace)\n\nparseFile :: FilePath -> IO (Either T.Text [Defn])\nparseFile path = do\n  contents <- T.readFile path\n  case file contents of\n    Left a -> return $ Left (T.pack a)\n    Right b -> return $ Right b\n\nmain :: IO (Either T.Text [Defn])\nmain = parseFile \"simple.ml\"\n```\n例如，使用下面的简单`lambda`表达式尝试上面的解析器:\n```haskell\nf = g (x - 1);\ng = f (x + 1);\nh = \\x y -> (f x) + (g y);\n```\n`Attoparsec`也非常适合二进制和网络协议样式解析，这是从分布式共识网络协议的一个小实现中提取的:\n```haskell\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Control.Monad\n\nimport Data.Attoparsec\nimport Data.Attoparsec.Char8 as A\nimport Data.ByteString.Char8\n\ndata Action\n  = Success\n  | KeepAlive\n  | NoResource\n  | Hangup\n  | NewLeader\n  | Election\n  deriving Show\n\ntype Sender = ByteString\ntype Payload = ByteString\n\ndata Message = Message\n  { action :: Action\n  , sender :: Sender\n  , payload :: Payload\n  } deriving Show\n\nproto :: Parser Message\nproto = do\n  act  <- paction\n  send <- A.takeTill (== '.')\n  body <- A.takeTill (A.isSpace)\n  endOfLine\n  return $ Message act send body\n\npaction :: Parser Action\npaction = do\n  c <- anyWord8\n  case c of\n    1  -> return Success\n    2  -> return KeepAlive\n    3  -> return NoResource\n    4  -> return Hangup\n    5  -> return NewLeader\n    6  -> return Election\n    _  -> mzero\n\nmain :: IO ()\nmain = do\n  let msgtext = \"\\x01\\x6c\\x61\\x70\\x74\\x6f\\x70\\x2e\\x33\\x2e\\x31\\x34\\x31\\x35\\x39\\x32\\x36\\x35\\x33\\x35\\x0A\"\n  let msg = parseOnly proto msgtext\n  print msg\n```\n請看:\n* [Text Parsing Tutorial](https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec)\n\n### Optparse Applicative\n`Optparse-applicative`是一个组合器库，用于构建命令行界面，这些命令行界面可以接收各种用户`flags`(标志)，`commands`(命令)和`switches`(开关)，并将它们映射到可以处理输入的`Haskell`数据结构中。\n`main`界面是通过`applicative functor`(应用函子)`Parser`和各种组合器(例如`strArgument`和`flag`)组成的，这些组合器通过一些`monadic`(单子)动作填充选项解析表，这些动作返回一個`Haskell`值。\n所得的值序列可以适当地组合到一个较大的`Config`数据结构中，该数据结构包含所有给定的选项。`--help header`标头也会自动从组合器生成.\n```haskell\n./optparse\nUsage: optparse.hs [filename...] [--quiet] [--cheetah]\n\nAvailable options:\n  -h,--help                Show this help text\n  filename...              Input files\n  --quiet                  Whether to shut up.\n  --cheetah                Perform task quickly.\nimport Data.List\nimport Data.Monoid\nimport Options.Applicative\n\ndata Opts = Opts\n  { _files :: [String]\n  , _quiet :: Bool\n  , _fast :: Speed\n  }\n\ndata Speed = Slow | Fast\n\noptions :: Parser Opts\noptions = Opts <$> filename <*> quiet <*> fast\n  where\n    filename :: Parser [String]\n    filename = many $ argument str $\n         metavar \"filename...\"\n      <> help \"Input files\"\n\n    fast :: Parser Speed\n    fast = flag Slow Fast $\n         long \"cheetah\"\n      <> help \"Perform task quickly.\"\n\n    quiet :: Parser Bool\n    quiet = switch $\n         long \"quiet\"\n      <> help \"Whether to shut up.\"\n\ngreet :: Opts -> IO ()\ngreet (Opts files quiet fast) = do\n  putStrLn \"reading these files:\"\n  mapM_ print files\n\n  case fast of\n    Fast -> putStrLn \"quickly\"\n    Slow -> putStrLn \"slowly\"\n\n  case quiet of\n    True  -> putStrLn \"quietly\"\n    False -> putStrLn \"loudly\"\n\nopts :: ParserInfo Opts\nopts = info (helper <*> options) fullDesc\n\nmain :: IO ()\nmain = execParser opts >>= greet\n```\n請看:\n* [Optparse Applicative Tutorial](https://github.com/pcapriotti/optparse-applicative)\n\n### Happy & Alex\n`Happy`是`Haskell`的解析器生成器系统，类似于`c`的工具`yacc`。\n它作为一个预处理器，使用自己的语法从两个规范(`lexer`文件和`parser`文件)生成一个解析表。\n`happy`没有与解析器组合器相同的底层解析器实现，并且可以有效地使用左递归文法，而无需显式`factorization`(分解)。\n它还可以很容易地被修改以跟踪`tokens`(标记)的位置信息，并处理缩进敏感语法的`offside`(越位)解析规则。`Happy`在`GHC`中用于`Haskell`的语法。\n\n* Lexer.x\n* Parser.y\n\n运行`standalone`(独立)命令将为模块生成`haskell`源代码。\n```haskell\n$ alex Lexer.x -o Lexer.hs\n$ happy Parser.y -o Parser.hs\n```\n生成的模块通常不可读，不幸的是，错误消息是在`Haskell`源代码中给出的，而不是`Happy`源代码.\n\n#### Lexer\n例如，我们可以定义一个带有自定义`tokens`(标记)集的小玩具`lexer`。\n```haskell\n{\nmodule Lexer (\n  Token(..),\n  scanTokens\n) where\n\nimport Syntax\n}\n\n%wrapper \"basic\"\n\n$digit = 0-9\n$alpha = [a-zA-Z]\n$eol   = [\\n]\n\ntokens :-\n\n  -- Whitespace insensitive (空格不敏感)\n  $eol                          ;\n  $white+                       ;\n  print                         { \\s -> TokenPrint }\n  $digit+                       { \\s -> TokenNum (read s) }\n  \\=                            { \\s -> TokenEq }\n  $alpha [$alpha $digit \\_ \\']* { \\s -> TokenSym s }\n\n{\n\ndata Token \n  = TokenNum Int\n  | TokenSym String\n  | TokenPrint\n  | TokenEq\n  | TokenEOF\n  deriving (Eq,Show)\n\nscanTokens = alexScanTokens\n\n}\n```\n\n#### Parser\n关联的解析器是`production`(生产)规则和运行解析器的`monad`(单子)的列表。`Production`(生产)规则由左侧的一组选项和右侧的带有索引元变量(`$1`，`$2`，...)的`Haskell`表达式生成，这些变量映射到左侧的有序`terms`(术语)(即第二个术语`term`〜`$1`，`term`〜`$2`).\n```haskell\nterms\n    : term                   { [$1] }\n    | term terms             { $1 : $2 }\n{\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\nmodule Parser (\n  parseExpr,\n) where\n\nimport Lexer\nimport Syntax\n\nimport Control.Monad.Except\n}\n\n%name expr\n%tokentype { Token }\n%monad { Except String } { (>>=) } { return }\n%error { parseError }\n\n%token\n    int   { TokenNum $$ }\n    var   { TokenSym $$ }\n    print { TokenPrint }\n    '='   { TokenEq }\n\n%%\n\nterms \n    : term                   { [$1] }\n    | term terms             { $1 : $2 }\n\nterm \n   : var                     { Var $1 }\n   | var '=' int             { Assign $1 $3 }\n   | print term              { Print $2 }\n\n{\n\nparseError :: [Token] -> Except String a\nparseError (l:ls) = throwError (show l)\nparseError [] = throwError \"Unexpected end of Input\"\n\nparseExpr :: String -> Either String [Expr]\nparseExpr input = \n  let tokenStream = scanTokens input in\n  runExcept (expr tokenStream)\n}\n```\n作为简单的输入，请考虑以下简单的程序:\n```haskell\nx = 4\nprint x\ny = 5\nprint y\ny = 6\nprint y\n```\n\n### Configurator (配置器)\n`Configurator`是用于配置`Haskell daemons`(守护进程)和程序的库。它使用一种简单但灵活的配置语言，支持几种最常用的数据类型，以及来自配置或系统环境的字符串插值。\n```haskell\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Data.Text\nimport qualified Data.Configurator as C\n\ndata Config = Config\n  { verbose      :: Bool\n  , loggingLevel :: Int\n  , logfile      :: FilePath\n  , dbHost       :: Text\n  , dbUser       :: Text\n  , dbDatabase   :: Text\n  , dbpassword   :: Maybe Text\n  } deriving (Eq, Show)\n\nreadConfig :: FilePath -> IO Config\nreadConfig cfgFile = do\n  cfg          <- C.load [C.Required cfgFile]\n  verbose      <- C.require cfg \"logging.verbose\"\n  loggingLevel <- C.require cfg \"logging.loggingLevel\"\n  logFile      <- C.require cfg \"logging.logfile\"\n  hostname     <- C.require cfg \"database.hostname\"\n  username     <- C.require cfg \"database.username\"\n  database     <- C.require cfg \"database.database\"\n  password     <- C.lookup cfg \"database.password\"\n  return $ Config verbose loggingLevel logFile hostname username database password\n\nmain :: IO ()\nmain = do\n  cfg <-readConfig \"example.config\"\n  print cfg\n```\n一個簡單的配置文件:\n```haskell\nlogging \n{\n  verbose      = true\n  logfile      = \"/tmp/app.log\"\n  loggingLevel = 3\n}\n\ndatabase\n{\n  hostname = \"us-east-1.rds.amazonaws.com\"\n  username = \"app\"\n  database = \"booktown\"\n  password = \"hunter2\"\n}\n```\n`Configurator`还包含一个`import`指令，它允许将复杂应用程序的配置拆分为几个较小的文件，或者将配置数据共享给多个应用程序。","tags":["Parsing"]},{"title":"Haskell-Error-Handling","url":"/blog/2019/10/16/Haskell-Error-Handling/","content":"> [原文](http://dev.stephendiehl.com/hask/#error-handling)\n\n### Control.Exception\n处理`errors`的最底层(也是最危险的)方法是使用`throw`和`catch`函数，这些函数使我们可以在纯代码中抛出可扩展的异常，但可以在`IO`中捕获生成的异常。\n特别要注意的是，`throw`的返回值`inhabits`(驻留在)所有类型中。对于不使用`low-level`系统操作的自定义代码，没有理由使用此选项。\n```haskell\nthrow :: Exception e => e -> a\ncatch :: Exception e => IO a -> (e -> IO a) -> IO a\ntry :: Exception e => IO a -> IO (Either e a)\nevaluate :: a -> IO a\n{-# LANGUAGE DeriveDataTypeable #-}\n\nimport Data.Typeable\nimport Control.Exception\n\ndata MyException = MyException\n    deriving (Show, Typeable)\n\ninstance Exception MyException\n\nevil :: [Int]\nevil = [throw MyException]\n\nexample1 :: Int\nexample1 = head evil\n\nexample2 :: Int\nexample2 = length evil\n\nmain :: IO ()\nmain = do\n  a <- try (evaluate example1) :: IO (Either MyException Int)\n  print a\n\n  b <- try (return example2) :: IO (Either MyException Int)\n  print b\n```\n因为除非需要該值，否则将不会评估該值，因此，如果希望确定是否捕获到异常，可以在调用`catch`之前将其深深地强制转换为`head normal form`(普通形式)。标准库没有提供`strictCatch`，但是在`deepseq`方面有一个简单的实现。\n```haskell\nstrictCatch :: (NFData a, Exception e) => IO a -> (e -> IO a) -> IO a\nstrictCatch = catch . (toNF =<<)\n```\n\n### Exceptions\n前一种方法的问题是必须依赖于`IO`内部`GHC`的异步异常处理来处理基本操作。\n`Exceptions`提供了与`Control.exception`相同的`api`，但却放松了对`IO`的依赖。\n```haskell\n{-# LANGUAGE DeriveDataTypeable #-}\n\nimport Data.Typeable\nimport Control.Monad.Catch\nimport Control.Monad.Identity\n\ndata MyException = MyException\n    deriving (Show, Typeable)\n\ninstance Exception MyException\n\nexample :: MonadCatch m => Int -> Int -> m Int\nexample x y | y == 0 = throwM MyException\n            | otherwise = return $ x `div` y\n\npure :: MonadCatch m => m (Either MyException Int)\npure = do\n  a <- try (example 1 2)\n  b <- try (example 1 0)\n  return (a >> b)\n```\n請看: [exceptions](http://hackage.haskell.org/package/exceptions)\n\n### ExceptT\n从`mtl 2.2`或更高版本开始，`ErrorT`类已由`ExceptT`取代。在`transformers`(变压器)级别。\n```haskell\nnewtype ExceptT e m a = ExceptT (m (Either e a))\n\nrunExceptT :: ExceptT e m a -> m (Either e a)\nrunExceptT (ExceptT m) = m\n\ninstance (Monad m) => Monad (ExceptT e m) where\n    return a = ExceptT $ return (Right a)\n    m >>= k = ExceptT $ do\n        a <- runExceptT m\n        case a of\n            Left e -> return (Left e)\n            Right x -> runExceptT (k x)\n    fail = ExceptT . fail\n\nthrowE :: (Monad m) => e -> ExceptT e m a\nthrowE = ExceptT . return . Left\n\ncatchE :: (Monad m) =>\n    ExceptT e m a               -- ^ the inner computation\n    -> (e -> ExceptT e' m a)    -- ^ a handler for exceptions in the inner\n                                -- computation\n    -> ExceptT e' m a\nm `catchE` h = ExceptT $ do\n    a <- runExceptT m\n    case a of\n        Left  l -> runExceptT (h l)\n        Right r -> return (Right r)\n```\n使用`mtl`:\n```haskell\ninstance MonadTrans (ExceptT e) where\n    lift = ExceptT . liftM Right\n\nclass (Monad m) => MonadError e m | m -> e where\n    throwError :: e -> m a\n    catchError :: m a -> (e -> m a) -> m a\n\ninstance MonadError IOException IO where\n    throwError = ioError\n    catchError = catch\n\ninstance MonadError e (Either e) where\n    throwError             = Left\n    Left  l `catchError` h = h l\n    Right r `catchError` _ = Right r\n```\n請看: [Control.Monad.Except](https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html)\n\n### spoon\n有时，您将不得不处理那些在任何时候都可能抛出的看似纯粹的函数。像这样的函數在标准库中有很多，在`Hackage`中有更多。\n\n您只想`purely`(純粹)处理此逻辑，就好像它返回一个正确的`Maybe a`一样，但是要捕获该逻辑，您需要在`IO`内安装一个`IO`处理程序来捕获它。\n`Spoon`允许我们安全地(`purely`的，尽管它使用对`unsafePerformIO`的引用透明调用)来捕获这些异常并将它们放在它們所属的`Maybe`中。\n\n`spoon`函数将其参数评估为`head normal form`，而`teaspoon`则将其参数评估为[weak head normal form](http://dev.stephendiehl.com/hask/#seq-and-whnf)。\n```haskell\nimport Control.Spoon\n\ngoBoom :: Int -> Int -> Int\ngoBoom x y = x `div` y\n\n-- evaluate to normal form\ntest1 :: Maybe [Int]\ntest1 = spoon [1, 2, undefined]\n\n-- evaluate to weak head normal form\ntest2 :: Maybe [Int]\ntest2 = teaspoon [1, 2, undefined]\n\nmain :: IO ()\nmain = do\n  maybe (putStrLn \"Nothing\") (print . length) test1\n  maybe (putStrLn \"Nothing\") (print . length) test2\n```\n\n請看: [Spoon](https://hackage.haskell.org/package/spoon)\n\n### safe-exceptions\n> TODO","tags":["Error-Handling"]},{"title":"Haskell-Quantification","url":"/blog/2019/10/09/Haskell-Quantification/","content":"> 这是高级部分，编写Haskell通常不需要-[原文](http://dev.stephendiehl.com/hask/#quantification)。\n\n### Universal Quantification\n\n`Universal Quantification`(通用量化)是`Haskell`中编码多态性的主要机制。\n`Universal Quantification`的本质是，我们可以表达对一组类型以相同方式操作的函数，并且其函数行为完全取决于此范围内所有类型的行为。\n\n```haskell\n{-# LANGUAGE ExplicitForAll #-}\n\n-- ∀a. [a]\nexample1 :: forall a. [a]\nexample1 = []\n\n-- ∀a. [a]\nexample2 :: forall a. [a]\nexample2 = [undefined]\n\n-- ∀a. ∀b. (a → b) → [a] → [b]\nmap' :: forall a. forall b. (a -> b) -> [a] -> [b]\nmap' f = foldr ((:) . f) []\n\n-- ∀a. [a] → [a]\nreverse' :: forall a. [a] -> [a]\nreverse' = foldl (flip (:)) []\n```\n通常，在类型签名中省略量词，因为在`Haskell`的`vanilla`表面语言中，毫无疑问地假定自由类型变量已被普遍量化。\n\n### Free theorems(定理)\n\n通用量化的类型变量实际上暗含着有关函数实现的相当多的深层属性，这些属性可以从其类型签名中得出。\n例如，确保`Haskell`中的`identity`函數只有一种实现，因为该信息只可以出現在主體內。\n```haskell\nid :: forall a. a -> a\nid x = x\n\nfmap :: Functor f => (a -> b) -> f a -> f b\n```\n`fmap`的`Free theorems`:\n```haskell\nforall f g. fmap f . fmap g = fmap (f . g)\n```\n請看: [Theorems for Free](http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi?)\n\n### Type Systems\n`Hindley-Milner`类型系统在历史上很重要, 它是第一个接受多态性和可以始终确定主要类型的推理技术的`typed  lambda`计算之一。\n```haskell\ne : x\n  | λx:t.e            -- value abstraction\n  | e1 e2             -- application\n  | let x = e1 in e2  -- let\n\nt : t -> t     -- function types\n  | a          -- type variables\n\nσ : ∀ a . t    -- type scheme\n```\n在一个实现中，该函数泛化将类型内的所有`type variables`转换为产生`type scheme`的多态类型变量。\n該函数实例化将`scheme`映射到一個`type`，但是任何多态变量都转换为非绑定类型变量。\n\n### Rank-N Types\n`System-F`是`Haskell`底层的类型系统。从某种意义上说，`System-F`包含`HM`类型系统，因为`HM`中可表达的每种类型都可以在`System-F`中表达。\n`System-F`在文案中有时被称为`Girald-Reynolds polymorphic lambda calculus(Girald-Reynolds多态Lambda演算)`或者`second-order lambda calculus（二阶Lambda演算）`。\n```haskell\nt : t -> t     -- function types\n  | a          -- type variables\n  | ∀ a . t    -- forall\n\ne : x          -- variables\n  | λ(x:t).e   -- value abstraction\n  | e1 e2      -- value application\n  | Λa.e       -- type abstraction\n  | e_t        -- type application\n```\n一个与`GHC Core`等效的示例:\n```haskell\nid : ∀ t. t -> t\nid = Λt. λx:t. x\n-- id :: forall t. t -> t\n-- id = \\ (@ t) (x :: t) -> x\n\ntr : ∀ a. ∀ b. a -> b -> a\ntr = Λa. Λb. λx:a. λy:b. x\n-- tr :: forall a b. a -> b -> a\n-- tr = \\ (@ a) (@ b) (x :: a) (y :: b) -> x\n\nfl : ∀ a. ∀ b. a -> b -> b\nfl = Λa. Λb. λx:a. λy:b. y\n-- fl :: forall a b. a -> b -> b\n-- fl = \\ (@ a) (@ b) (x :: a) (y :: b) -> y\n\nnil : ∀ a. [a]\nnil = Λa. Λb. λz:b. λf:(a -> b -> b). z\n-- nil :: forall a. [a]\n-- nil = \\ (@ a) (@ b) (z :: b) (f :: a -> b -> b) -> z\n\ncons : ∀ a. a -> [a] -> [a]\ncons = Λa. λx:a. λxs:(∀ b. b -> (a -> b -> b) -> b).\n    Λb. λz:b. λf : (a -> b -> b). f x (xs_b z f)\n-- cons :: forall a. a -> [a] -> [a]\n-- cons = \\ (@ a) (x :: a) (xs :: forall b. b -> (a -> b -> b) -> b)\n--     (@ b) (z :: b) (f :: a -> b -> b) -> f x (xs @ b z f)\n```\n通常，当`Haskell`的类型检查器推断类型签名时，它将所有类型变量的量词放在最外面的位置，这样在类型表达式的主体内就不会出现量词，这被称为`prenex`限制。\n这限制了整个类的类型签名，這些簽名本來可以在`System-F`中表达，但是这样做的好处是使推断更加容易。\n```haskell\n{-# LANGUAGE RankNTypes #-}\n\n-- Can't unify ( Bool ~ Char )\nrank1 :: forall a. (a -> a) -> (Bool, Char)\nrank1 f = (f True, f 'a')\n\nrank2 :: (forall a. a -> a) -> (Bool, Char)\nrank2 f = (f True, f 'a')\n\nauto :: (forall a. a -> a) -> (forall b. b -> b)\nauto x = x\n\nxauto :: forall a. (forall b. b -> b) -> a -> a\nxauto f = f\nMonomorphic Rank 0: t\nPolymorphic Rank 1: forall a. a -> t\nPolymorphic Rank 2: (forall a. a -> t) -> t\nPolymorphic Rank 3: ((forall a. a -> t) -> t) -> t\n```\n需要特别注意的是，由`higher ranked`类型的显式量词绑定的类型变量可能无法逃脱其封闭范围。\n类型检查器将通过强制绑定在`rank-n`类型内部的变量(称为`skolem`常量)将不会与推理引擎所推断的自由元类型变量统一，从而显式实施此操作。\n类型检查器将显式地强制执行此操作，方法是强制在`rank-n`类型内部绑定的变量(称为`skolem`常量)不能与由推理引擎推断的自由元类型变量相统一。\n```haskell\n{-# LANGUAGE RankNTypes #-}\n\nescape :: (forall a. a -> a) -> Int\nescape f = f 0\n\ng x = escape (\\a -> x)\n```\n在此示例中，为了使表达式具有良好的类型,`f`必须具有`(Int -> Int)`,这意味着在整个类型上具有`a 〜 Int`，\n但是由于`a`绑定在量词下，因此它一定不能与`Int`统一，因此类型检查器必须失败，并出现`skolem`捕获错误。\n```haskell\nCouldn't match expected type `a' with actual type `t'\n`a' is a rigid type variable bound by a type expected by the context: a -> a\n`t' is a rigid type variable bound by the inferred type of g :: t -> Int\nIn the expression: x In the first argument of `escape', namely `(\\a -> x)'\nIn the expression: escape (\\a -> x)\n```\n实际上，这可以用于我们的优势，以便对特定类型变量的范围和使用实施几种类型的不变量。\n例如，`ST monad`使用一個`second rank`类型来防止捕获具有单独状态线程的`ST monad`之间的引用，在这些状态线程中，`s`类型变量绑定在`rank-2`类型内并且不能转义，从而静态地保证了`ST`内部不会泄漏，因此可确保其引用透明性。\n\n### Existential Quantification(存在量化)\n`existential`(存在)类型是具有一组特殊的包装和拆包语义的类型和`term`对。\n生产者知道`existential`中编码的值的类型,但是`existential`值的消費者不知道。\n```haskell\n{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE RankNTypes #-}\n\n-- ∃ t. (t, t → t, t → String)\ndata Box = forall a. Box a (a -> a) (a -> String)\n\nboxa :: Box\nboxa = Box 1 negate show\n\nboxb :: Box\nboxb = Box \"foo\" reverse show\n\napply :: Box -> String\napply (Box x f p) = p (f x)\n\n-- ∃ t. Show t => t\ndata SBox = forall a. Show a => SBox a\n\nboxes :: [SBox]\nboxes = [SBox (), SBox 2, SBox \"foo\"]\n\nshowBox :: SBox -> String\nshowBox (SBox a) = show a\n\nmain :: IO ()\nmain = mapM_ (putStrLn . showBox) boxes\n-- ()\n-- 2\n-- \"foo\"\n```\n`SBox`上的`existential`收集了一个纯粹根据其`Show`接口和一个不透明指针定义的值的集合，\n没有其他有关值的信息，并且无法以任何其他方式访问或解包它们。\n\n传递`existential`类型可以使我们向数据类型的使用者隐藏信息，并限制函数可以使用的行为。\n传递带有`existential`变量的记录，可以使类型与固定的一组函数\"捆绑\"在一起，这些函数在其隐藏的内部操作。\n```haskell\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ExistentialQuantification #-}\n\n-- a b are existentially bound type variables, m is a free type variable\n-- a b是existentially绑定类型变量，m是自由类型变量\ndata MonadI m = MonadI\n  { _return :: forall a . a -> m a\n  , _bind   :: forall a b . m a -> (a -> m b) -> m b\n  }\n\nmonadMaybe:: MonadI Maybe\nmonadMaybe = MonadI\n  { _return = Just\n  , _bind   = \\m f -> case m of\n      Nothing -> Nothing\n      Just x  -> f x\n  }\n```\n\n### Impredicative Types(強制性類型)\n>这是高级部分，编写Haskell通常不需要。\n\n尽管非常脆弱，但是`GHC`对强制性多态性的支持也很有限，它允许使用多态类型实例化类型变量。\n\n这暗示着这放宽了量词必须在`arrow`(箭头)类型之前的限制，现在它们可以放置在类型构造函数内部。\n```haskell\n-- Can't unify ( Int ~ Char )\nrevUni :: forall a. Maybe ([a] -> [a]) -> Maybe ([Int], [Char])\nrevUni (Just g) = Just (g [3], g \"hello\")\nrevUni Nothing  = Nothing\n{-# LANGUAGE ImpredicativeTypes #-}\n\n-- Uses higher-ranked polymorphism.\nf :: (forall a. [a] -> a) -> (Int, Char)\nf get = (get [1,2], get ['a', 'b', 'c'])\n\n-- Uses impredicative polymorphism.\ng :: Maybe (forall a. [a] -> a) -> (Int, Char)\ng Nothing = (0, '0')\ng (Just get) = (get [1,2], get ['a','b','c'])\n```\n很少使用此扩展，并且考虑到`-XImpredicativeTypes`从根本上被破坏了。 尽管`GHC`非常谨慎地告诉我们在类型签名中意外打错时启用它！\n\n一些值得注意的细节，($)操作符以一种非常特殊的方式连接到`GHC`中，以便仅在`ST monad`中使用($)操作符时，通过($)将`runST`的`impredicative instantiation`(強制性实例化)应用到($)中。如果这听起来像是丑陋的骇客，那是因为它确实是，但是相当方便。\n\n例如，如果我们定义一个行为应该与($)相同的函数`apply`，我们将得到一个关于多态实例化的错误，即使它们的定义是相同的!\n```haskell\n{-# LANGUAGE RankNTypes #-}\n\nimport Control.Monad.ST\n\nf `apply` x =  f x\n\nfoo :: (forall s. ST s a) -> a\nfoo st = runST $ st\n\nbar :: (forall s. ST s a) -> a\nbar st = runST `apply` st\n    Couldn't match expected type `forall s. ST s a'\n                with actual type `ST s0 a'\n    In the second argument of `apply', namely `st'\n    In the expression: runST `apply` st\n    In an equation for `bar': bar st = runST `apply` st\n```\n請看: [SPJ Notes on $](https://www.haskell.org/pipermail/glasgow-haskell-users/2010-November/019431.html)\n\n### Scoped Type Variables\n通常，在函数的顶级签名中使用的类型变量仅作用于类型签名，而不是作用在`terms`和`let/where`子句中的函数主体及其严格签名。\n```haskell\n{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\npoly :: forall a b c. a -> b -> c -> (a, a)\npoly x y z = (f x y, f x z)\n  where\n    -- second argument is universally quantified from inference\n    -- 第二个參數是根据推论普遍量化的\n    -- f :: forall t0 t1. t0 -> t1 -> t0\n    f x' _ = x'\n\nmono :: forall a b c. a -> b -> c -> (a, a)\nmono x y z = (f x y, f x z)\n  where\n    -- b is not implictly universally quantified because it is in scope\n    -- b没有被隐含地普遍量化，因为它在范围内\n    f :: a -> b -> a\n    f x' _ = x'\n\nexample :: IO ()\nexample = do\n  x :: [Int] <- readLn\n  print x\n\n```\n\n","tags":["Quantification"]},{"title":"Haskell-Generics","url":"/blog/2019/10/09/Haskell-Generics/","content":"> [原文](http://dev.stephendiehl.com/hask/#generics)\n\n`Haskell`有几种技术可以自动生成用于各种任务的类型类，这些任务主要由样板代码生成组成，例如:\n* **Pretty Printing** (漂亮打印)\n* **Equality** (平等/相等)\n* **Serialization** (序列化)\n* **Ordering** (比較)\n* **Traversal** (遍历)\n\n这些是通过以下几节中概述的几种工具和技术来实现的:\n* **Typeable / Dynamic**\n* **Scrap Your Boilerplate** (报废/扔掉你的样板)\n* **GHC.Generics**\n* **generics-sop**\n\n### Typeable\n`Typeable`类用于为任意类型创建运行时类型信息。\n```haskell\ntypeOf :: Typeable a => a -> TypeRep\n{-# LANGUAGE DeriveDataTypeable #-}\n\nimport Data.Typeable\n\ndata Animal = Cat | Dog deriving Typeable\ndata Zoo a = Zoo [a] deriving Typeable\n\nequal :: (Typeable a, Typeable b) => a -> b -> Bool\nequal a b = typeOf a == typeOf b\n\nexample1 :: TypeRep\nexample1 = typeOf Cat\n-- Animal\n\nexample2 :: TypeRep\nexample2 = typeOf (Zoo [Cat, Dog])\n-- Zoo Animal\n\nexample3 :: TypeRep\nexample3 = typeOf ((1, 6.636e-34, \"foo\") :: (Int, Double, String))\n-- (Int,Double,[Char])\n\nexample4 :: Bool\nexample4 = equal False ()\n-- False\n```\n使用`typeable`实例允许我们编写一个类型安全的`cast`函数，该函数可以安全地使用`unsafecast`，并提供结果类型与输入匹配的证明。\n```haskell\ncast :: (Typeable a, Typeable b) => a -> Maybe b\ncast x\n  | typeOf x == typeOf ret = Just ret\n  | otherwise = Nothing\n  where\n    ret = unsafeCast x\n```\n历史上值得注意的是，目前在`GHC 7.6`中可以编写我们自己的`Typeable`类，但是它允许我们引入可能导致崩溃的危险行为，除非`GHC`本身否則不应该这样做。从`GHC 7.8`开始，已經禁止我們手写`Typeable`实例。 从`GHC 7.10`开始，默认情况下已启用`-XAutoDeriveTypeable`擴展。\n\n請看: [Typeable and Data in Haskell](http://chrisdone.com/posts/data-typeable)\n\n### Dynamic\n由于我们有一种查询运行时类型信息的方法，因此可以使用此机器实现`Dynamic`(动态)类型。\n这允许我们将任何`monotype`(单型)打包成一个`uniform`(统一)的类型，该类型可以传递给任何采用动态类型的函数，然后可以用类型安全的方式解包基础值。\n```haskell\ntoDyn :: Typeable a => a -> Dynamic\nfromDyn :: Typeable a => Dynamic -> a -> a\nfromDynamic :: Typeable a => Dynamic -> Maybe a\ncast :: (Typeable a, Typeable b) => a -> Maybe b\nimport Data.Dynamic\nimport Data.Maybe\n\ndynamicBox :: Dynamic\ndynamicBox = toDyn (6.62 :: Double)\n\nexample1 :: Maybe Int\nexample1 = fromDynamic dynamicBox\n-- Nothing\n\nexample2 :: Maybe Double\nexample2 = fromDynamic dynamicBox\n-- Just 6.62\n\nexample3 :: Int\nexample3 = fromDyn dynamicBox 0\n-- 0\n\nexample4 :: Double\nexample4 = fromDyn dynamicBox 0.0\n-- 6.62\n```\n在`GHC 7.8`中，`Typeable`类是`poly-kinded`(多类型)的，因此`polymorphic`(多态)函数可以应用于函数和`higher kinded`(更高种类)的类型。\n>使用`dynamic`有点罕见，除了在处理外部内存和`ffi`接口的奇怪情况下。将它用于业务逻辑被认为是一种代码异味。考虑一个更惯用的解决方案。\n\n### Data\n正如`Typeable`允许我们创建运行时类型信息一样，`Data`类也允许我们根据需要向运行时`reflect`(反映)有关`datatypes`结构的信息。\n```haskell\nclass Typeable a => Data a where\n  gfoldl  :: (forall d b. Data d => c (d -> b) -> d -> c b)\n          -> (forall g. g -> c g)\n          -> a\n          -> c a\n\n  gunfold :: (forall b r. Data b => c (b -> r) -> c r)\n          -> (forall r. r -> c r)\n          -> Constr\n          -> c a\n\n  toConstr :: a -> Constr\n  dataTypeOf :: a -> DataType\n  gmapQl :: (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r\n```\n`gfoldl`和`gunfold`的类型有些令人生畏(其取决于`RankNTypes`),最好的理解方法是看一些示例。首先，最简单的情况是`sum`类型`Animal`将产生以下代码:\n```haskell\ndata Animal = Cat | Dog deriving Typeable\ninstance Data Animal where\n  gfoldl k z Cat = z Cat\n  gfoldl k z Dog = z Dog\n\n  gunfold k z c\n    = case constrIndex c of\n        1 -> z Cat\n        2 -> z Dog\n\n  toConstr Cat = cCat\n  toConstr Dog = cDog\n\n  dataTypeOf _ = tAnimal\n\ntAnimal :: DataType\ntAnimal = mkDataType \"Main.Animal\" [cCat, cDog]\n\ncCat :: Constr\ncCat = mkConstr tAnimal \"Cat\" [] Prefix\n\ncDog :: Constr\ncDog = mkConstr tAnimal \"Dog\" [] Prefix\n```\n\n对于带有非空容器的类型，我们会得到一些更有趣的东西。考虑列表类型:\n```haskell\ninstance Data a => Data [a] where\n  gfoldl _ z []     = z []\n  gfoldl k z (x:xs) = z (:) `k` x `k` xs\n\n  toConstr []    = nilConstr\n  toConstr (_:_) = consConstr\n\n  gunfold k z c\n    = case constrIndex c of\n        1 -> z []\n        2 -> k (k (z (:)))\n\n  dataTypeOf _ = listDataType\n\nnilConstr :: Constr\nnilConstr = mkConstr listDataType \"[]\" [] Prefix\n\nconsConstr :: Constr\nconsConstr = mkConstr listDataType \"(:)\" [] Infix\n\nlistDataType :: DataType\nlistDataType = mkDataType \"Prelude.[]\" [nilConstr,consConstr]\n```\n看一下`gfoldl`，我们看到`Data`有一个函数的实现，通过在每个元素上应用函数`k`并在`spine`(书脊)上应用`z`，我们可以遍历构造函数的元素。例如，看一个2元组的实例:\n```haskell\ninstance (Data a, Data b) => Data (a,b) where\n  gfoldl k z (a,b) = z (,) `k` a `k` b\n\n  toConstr (_,_) = tuple2Constr\n\n  gunfold k z c\n    = case constrIndex c of\n      1 -> k (k (z (,)))\n\n  dataTypeOf _  = tuple2DataType\n\ntuple2Constr :: Constr\ntuple2Constr = mkConstr tuple2DataType \"(,)\" [] Infix\n\ntuple2DataType :: DataType\ntuple2DataType = mkDataType \"Prelude.(,)\" [tuple2Constr]\n```\n这非常整洁，现在在同一类型类中，我们有一种`generic`(通用)的方法可以对任何`Data`实例进行内省并编写依赖于其子项的结构和类型的逻辑。\n现在，我们可以编写一个函数，该函数允许我们根据运行时类型上的模式匹配`traverse`(遍历)`Data`的任意实例和`twiddle`(旋转)值。 \n因此，让我们写下一个为`n`元组和列表增加`Value`类型的函数。\n```haskell\n{-# LANGUAGE DeriveDataTypeable #-}\n\nimport Data.Data\nimport Control.Monad.Identity\nimport Control.Applicative\n\ndata Animal = Cat | Dog deriving (Data, Typeable)\n\nnewtype Val = Val Int deriving (Show, Data, Typeable)\n\nincr :: Typeable a => a -> a\nincr = maybe id id (cast f)\n  where f (Val x) = Val (x * 100)\n\nover :: Data a => a -> a\nover x = runIdentity $ gfoldl cont base (incr x)\n  where\n    cont k d = k <*> (pure $ over d)\n    base = pure\n\nexample1 :: Constr\nexample1 = toConstr Dog\n-- Dog\n\nexample2 :: DataType\nexample2 = dataTypeOf Cat\n-- DataType {tycon = \"Main.Animal\", datarep = AlgRep [Cat,Dog]}\n\nexample3 :: [Val]\nexample3 = over [Val 1, Val 2, Val 3]\n-- [Val 100,Val 200,Val 300]\n\nexample4 :: (Val, Val, Val)\nexample4 = over (Val 1, Val 2, Val 3)\n-- (Val 100,Val 200,Val 300)\n```\n我们还可以编写`generic`(通用)操作，例如计算数据类型中参数的数量。\n```haskell\nnumHoles :: Data a => a -> Int\nnumHoles = gmapQl (+) 0 (const 1)\n\nexample1 :: Int\nexample1 = numHoles (1,2,3,4,5,6,7)\n-- 7\n\nexample2 :: Int\nexample2 = numHoles (Just 3)\n-- 1\n```\n\n### Syb\n使用`Data`提供的接口，我们可以在运行时检索所需的信息，检查表达式的类型并重写它们，收集`terms`(项)，并找到与特定谓词匹配的`subterms`(子项)。\n```haskell\neverywhere :: (forall a. Data a => a -> a) -> forall a. Data a => a -> a\neverywhereM :: Monad m => GenericM m -> GenericM m\nsomewhere :: MonadPlus m => GenericM m -> GenericM m\nlistify :: Typeable r => (r -> Bool) -> GenericQ [r]\neverything :: (r -> r -> r) -> GenericQ r -> GenericQ r\n```\n例如，假设我们有一些自定义的`datatypes`(数据类型)集合，我们要为其编写`generic`(通用)转换，以根据重写规则集转换数值子表达式。 我们可以使用`syb`简洁地编写转换规则。\n```haskell\n{-# LANGUAGE DeriveDataTypeable #-}\n\nimport Data.Data\nimport Data.Typeable\nimport Data.Generics.Schemes\nimport Data.Generics.Aliases (mkT)\n\ndata MyTuple a = MyTuple a Float\n  deriving (Data, Typeable, Show)\n\nexampleT :: Data a => MyTuple a -> MyTuple a\nexampleT = everywhere (mkT go1) . everywhere (mkT go2)\n  where\n    go1 :: Int -> Int\n    go1 x = succ x\n\n    go2 :: Float -> Float\n    go2 x = succ x\n\nfindFloat :: Data x => x -> Maybe Float\nfindFloat = gfindtype\n\nmain :: IO ()\nmain = do\n  let term = MyTuple (MyTuple (1 :: Int) 2.0) 3.0\n  print (exampleT term)\n  print (gsize term)\n  print (findFloat term)\n  print (listify ((>0) :: (Int -> Bool)) term)\n```\n* [Data.Generics.Schemes](https://hackage.haskell.org/package/syb-0.6/docs/Data-Generics-Schemes.html)\n\n### Generic\n最现代的`generic programming`(泛型编程)方法是使用`type families`来实现更好的派生任意类型类的结构属性的方法。\n`Generic`(泛型)实现了一个类型类，该类具有一个关联的类型`Rep`(`Representation`表示)和一对函数，这些函数形成一个`2-sided inverse`(双面逆)(`isomorphism`同构)，用于在`associated`(相关联)类型和相关`derived`(派生)类型之间进行转换。\n```haskell\nclass Generic a where\n  type Rep a\n  from :: a -> Rep a\n  to :: Rep a -> a\n\nclass Datatype d where\n  datatypeName :: t d f a -> String\n  moduleName :: t d f a -> String\n\nclass Constructor c where\n  conName :: t c f a -> String\n```\n[GHC.Generics](https://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc-prim-0.2.0.0/GHC-Generics.html)\n`GHC.Generics`定义了一组`named types`(命名类型)，用于对`Haskell`中可用的类型的各种`structural properties`(结构特性)进行建模。\n```haskell\n-- | Sums: encode choice between constructors\ninfixr 5 :+:\ndata (:+:) f g p = L1 (f p) | R1 (g p)\n\n-- | Products: encode multiple arguments to constructors\ninfixr 6 :*:\ndata (:*:) f g p = f p :*: g p\n\n-- | Tag for M1: datatype\ndata D\n-- | Tag for M1: constructor\ndata C\n\n-- | Constants, additional parameters and recursion of kind *\nnewtype K1 i c p = K1 { unK1 :: c }\n\n-- | Meta-information (constructor names, etc.)\nnewtype M1 i c f p = M1 { unM1 :: f p }\n\n-- | Type synonym for encoding meta-information for datatypes\ntype D1 = M1 D\n\n-- | Type synonym for encoding meta-information for constructors\ntype C1 = M1 C\n```\n如果我们要手工为一个简单的类型编写`Generic`(通用)实例，那么使用派生机制`GHC`可以为我们机械地生成该`Generic`(通用)实例:\n```haskell\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE TypeFamilies #-}\n\nimport GHC.Generics\n\ndata Animal\n  = Dog\n  | Cat\n\ninstance Generic Animal where\n  type Rep Animal = D1 T_Animal ((C1 C_Dog U1) :+: (C1 C_Cat U1))\n\n  from Dog = M1 (L1 (M1 U1))\n  from Cat = M1 (R1 (M1 U1))\n\n  to (M1 (L1 (M1 U1))) = Dog\n  to (M1 (R1 (M1 U1))) = Cat\n\ndata T_Animal\ndata C_Dog\ndata C_Cat\n\ninstance Datatype T_Animal where\n  datatypeName _ = \"Animal\"\n  moduleName _ = \"Main\"\n\ninstance Constructor C_Dog where\n  conName _ = \"Dog\"\n\ninstance Constructor C_Cat where\n  conName _ = \"Cat\"\n```\n在`GHCi`中使用`kind!`我们可以查看与`Generic`(泛型)实例相关联的`type family`表示(`Rep/Representative`)\n```haskell\nλ: :kind! Rep Animal\nRep Animal :: * -> *\n= M1 D T_Animal (M1 C C_Dog U1 :+: M1 C C_Cat U1)\n\nλ: :kind! Rep ()\nRep () :: * -> *\n= M1 D GHC.Generics.D1() (M1 C GHC.Generics.C1_0() U1)\n\nλ: :kind! Rep [()]\nRep [()] :: * -> *\n= M1\n    D\n    GHC.Generics.D1[]\n    (M1 C GHC.Generics.C1_0[] U1\n     :+: M1\n           C\n           GHC.Generics.C1_1[]\n           (M1 S NoSelector (K1 R ()) :*: M1 S NoSelector (K1 R [()])))\n```\n现在聪明的一点是，我们没有在`datatype`(数据类型)上编写`generic`(泛型)函数，而是在`Rep`上编写了它，然后使用`from`来`reify`(具体化)结果.\n因此，对于`Haskell`默认`Eq`的等效版本，它改用`generic deriving`(泛型派生)，我们可以这样写:\n```haskell\nclass GEq' f where\n  geq' :: f a -> f a -> Bool\n\ninstance GEq' U1 where\n  geq' _ _ = True\n\ninstance (GEq c) => GEq' (K1 i c) where\n  geq' (K1 a) (K1 b) = geq a b\n\ninstance (GEq' a) => GEq' (M1 i c a) where\n  geq' (M1 a) (M1 b) = geq' a b\n\n-- Equality for sums.\ninstance (GEq' a, GEq' b) => GEq' (a :+: b) where\n  geq' (L1 a) (L1 b) = geq' a b\n  geq' (R1 a) (R1 b) = geq' a b\n  geq' _      _      = False\n\n-- Equality for products.\ninstance (GEq' a, GEq' b) => GEq' (a :*: b) where\n  geq' (a1 :*: b1) (a2 :*: b2) = geq' a1 a2 && geq' b1 b2\n```\n为了适应编写类的两种方法(`generic-deriving`或自定义实现),我们可以使用`DefaultSignatures`扩展来允许用户将`typeclass`函数留空，并遵从`Generic`(泛型)或定义它们自己的函数。\n```haskell\n{-# LANGUAGE DefaultSignatures #-}\n\nclass GEq a where\n  geq :: a -> a -> Bool\n\n  default geq :: (Generic a, GEq' (Rep a)) => a -> a -> Bool\n  geq x y = geq' (from x) (from y)\n```\n现在，使用我们库的任何人都只需要(派生)`derive Generic`并创建我们的`typeclass`实例的空实例，而无需为`GEq`编写任何样板。\n\n以下是`deriving equality generics`(派生相等泛型)的完整示例:\n```haskell\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE DefaultSignatures #-}\n\nimport GHC.Generics\n\n-- Auxiliary class\nclass GEq' f where\n  geq' :: f a -> f a -> Bool\n\ninstance GEq' U1 where\n  geq' _ _ = True\n\ninstance (GEq c) => GEq' (K1 i c) where\n  geq' (K1 a) (K1 b) = geq a b\n\ninstance (GEq' a) => GEq' (M1 i c a) where\n  geq' (M1 a) (M1 b) = geq' a b\n\ninstance (GEq' a, GEq' b) => GEq' (a :+: b) where\n  geq' (L1 a) (L1 b) = geq' a b\n  geq' (R1 a) (R1 b) = geq' a b\n  geq' _      _      = False\n\ninstance (GEq' a, GEq' b) => GEq' (a :*: b) where\n  geq' (a1 :*: b1) (a2 :*: b2) = geq' a1 a2 && geq' b1 b2\n\n--\nclass GEq a where\n  geq :: a -> a -> Bool\n  default geq :: (Generic a, GEq' (Rep a)) => a -> a -> Bool\n  geq x y = geq' (from x) (from y)\n\n-- Base equalities\ninstance GEq Char where geq = (==)\ninstance GEq Int where geq = (==)\ninstance GEq Float where geq = (==)\n\n-- Equalities derived from structure of (:+:) and (:*:)\ninstance GEq a => GEq (Maybe a)\ninstance (GEq a, GEq b) => GEq (a,b)\n\nmain :: IO ()\nmain = do\n  print $ geq 2 (3 :: Int)\n  print $ geq 'a' 'b'\n  print $ geq (Just 'a') (Just 'a')\n  print $ geq ('a','b') ('a', 'b')\n```\n請看:\n* [Cooking Classes with Datatype Generic Programming](http://www.stephendiehl.com/posts/generics.html)\n* [Datatype-generic Programming in Haskell](http://www.andres-loeh.de/DGP-Intro.pdf)\n* [generic-deriving](http://hackage.haskell.org/package/generic-deriving-1.6.3)\n\n### Generic Deriving\n使用`Generics`(泛型)，许多通用库提供了一种派生`common`(通用)类型类实例的机制。一些真实的例子：\n[hashable](http://hackage.haskell.org/package/hashable)库允许我们派生`hash`函数。\n```haskell\n{-# LANGUAGE DeriveGeneric #-}\n\nimport GHC.Generics (Generic)\nimport Data.Hashable\n\ndata Color = Red | Green | Blue deriving (Generic, Show)\n\ninstance Hashable Color where\n\nexample1 :: Int\nexample1 = hash Red\n-- 839657738087498284\n\nexample2 :: Int\nexample2 = hashWithSalt 0xDEADBEEF Red\n-- 62679985974121021\n```\n[cereal](http://hackage.haskell.org/package/cereal-0.4.0.1)库允许我们派生二进制表示。\n```haskell\n{-# LANGUAGE DeriveGeneric #-}\n\nimport Data.Word\nimport Data.ByteString\nimport Data.Serialize\n\nimport GHC.Generics\n\ndata Val = A [Val] | B [(Val, Val)] | C\n  deriving (Generic, Show)\n\ninstance Serialize Val where\n\nencoded :: ByteString\nencoded = encode (A [B [(C, C)]])\n-- \"\\NUL\\NUL\\NUL\\NUL\\NUL\\NUL\\NUL\\NUL\\SOH\\SOH\\NUL\\NUL\\NUL\\NUL\\NUL\\NUL\\NUL\\SOH\\STX\\STX\"\n\nbytes :: [Word8]\nbytes = unpack encoded\n-- [0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,2,2]\n\ndecoded :: Either String Val\ndecoded = decode encoded\n```\n[aeson](http://hackage.haskell.org/package/aeson)库允许我们為`JSON instances`派生JSON表示形式。\n```haskell\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Data.Aeson\nimport GHC.Generics\n\ndata Point = Point { _x :: Double, _y :: Double }\n   deriving (Show, Generic)\n\ninstance FromJSON Point\ninstance ToJSON Point\n\nexample1 :: Maybe Point\nexample1 = decode \"{\\\"x\\\":3.0,\\\"y\\\":-1.0}\"\n\nexample2 = encode $ Point 123.4 20\n```\n請看: [A Generic Deriving Mechanism for Haskell](http://dreixel.net/research/pdf/gdmh.pdf) (Haskell的通用派生机制)\n\n#### Higher Kinded Generics\n使用相同的接口`GHC.Generics`为`higher-kinded`(更高种类)的`generics`(泛型)提供了单独的类型类。\n```haskell\nclass Generic1 f where\n  type Rep1 f :: * -> *\n  from1  :: f a -> (Rep1 f) a\n  to1    :: (Rep1 f) a -> f a\n```\n例如`Maybe`的`Rep1`实例格式为：\n```haskell\ntype instance Rep1 Maybe\n  = D1\n      GHC.Generics.D1Maybe\n      (C1 C1_0Maybe U1\n       :+: C1 C1_1Maybe (S1 NoSelector Par1))\n```\n\n### generics-sop\n> TODO\n\n\n### Uniplate\n`Uniplate`是用于编写遍历和转换任意数据结构的泛型库。这对于编写`AST`转换和`rewriting systems`(重写系统)非常有用。\n```haskell\nplate :: from -> Type from to\n(|*)  :: Type (to -> from) to -> to -> Type from to\n(|-)  :: Type (item -> from) to -> item -> Type from to\n\ndescend   :: Uniplate on => (on -> on) -> on -> on\ntransform :: Uniplate on => (on -> on) -> on -> on\nrewrite   :: Uniplate on => (on -> Maybe on) -> on -> on\n```\n`descend`函数将对表达式的每个直接后代应用一个函数，然后将它们`combines`(组合)到父表达式。\n\n`transform`函數将对表达式中的所有项执行一次自下而上的转换。\n\n`rewrite`函数将把表达式中的所有项彻底转换为`fixed point`(不动点)，使用`Maybe`表示终止。\n```haskell\nimport Data.Generics.Uniplate.Direct\n\ndata Expr a\n  = Fls\n  | Tru\n  | Var a\n  | Not (Expr a)\n  | And (Expr a) (Expr a)\n  | Or  (Expr a) (Expr a)\n  deriving (Show, Eq)\n\ninstance Uniplate (Expr a) where\n  uniplate (Not f)     = plate Not |* f\n  uniplate (And f1 f2) = plate And |* f1 |* f2\n  uniplate (Or f1 f2)  = plate Or |* f1 |* f2\n  uniplate x           = plate x\n\nsimplify :: Expr a -> Expr a\nsimplify = transform simp\n where\n   simp (Not (Not f)) = f\n   simp (Not Fls) = Tru\n   simp (Not Tru) = Fls\n   simp x = x\n\nreduce :: Show a => Expr a -> Expr a\nreduce = rewrite cnf\n  where\n    -- double negation\n    cnf (Not (Not p)) = Just p\n\n    -- de Morgan\n    cnf (Not (p `Or` q))  = Just $ (Not p) `And` (Not q)\n    cnf (Not (p `And` q)) = Just $ (Not p) `Or` (Not q)\n\n    -- distribute conjunctions\n    cnf (p `Or` (q `And` r)) = Just $ (p `Or` q) `And` (p `Or` r)\n    cnf ((p `And` q) `Or` r) = Just $ (p `Or` q) `And` (p `Or` r)\n    cnf _ = Nothing\n\n\nexample1 :: Expr String\nexample1 = simplify (Not (Not (Not (Not (Var \"a\")))))\n-- Var \"a\"\n\nexample2 :: [String]\nexample2 = [a | Var a <- universe ex]\n  where\n    ex = Or (And (Var \"a\") (Var \"b\")) (Not (And (Var \"c\") (Var \"d\")))\n-- [\"a\",\"b\",\"c\",\"d\"]\n\nexample3 :: Expr String\nexample3 = reduce $ ((a `And` b) `Or` (c `And` d)) `Or` e\n  where\n    a = Var \"a\"\n    b = Var \"b\"\n    c = Var \"c\"\n    d = Var \"d\"\n    e = Var \"e\"\n```\n另外，`Uniplate`实例可以从`Data`实例自动派生而无需显式编写`Uniplate`实例。这种方法在显式的手写实例上会产生少量开销。\n```haskell\nimport Data.Data\nimport Data.Typeable\nimport Data.Generics.Uniplate.Data\n\ndata Expr a\n  = Fls\n  | Tru\n  | Lit a\n  | Not (Expr a)\n  | And (Expr a) (Expr a)\n  | Or (Expr a) (Expr a)\n  deriving (Data, Typeable, Show, Eq)\n```\n\n#### Biplate\n`Biplates`泛化目标类型不一定与源类型相同的`plates`(板)，它使用多参数类型类来指示`sub-target`(子目标)的`type sub`(类型子)。\n`Uniplate`函数都具有等价的广义`biplate`形式。\n```haskell\ndescendBi   :: Biplate from to => (to -> to) -> from -> from\ntransformBi :: Biplate from to => (to -> to) -> from -> from\nrewriteBi   :: Biplate from to => (to -> Maybe to) -> from -> from\n\ndescendBiM   :: (Monad m, Biplate from to) => (to -> m to) -> from -> m from\ntransformBiM :: (Monad m, Biplate from to) => (to -> m to) -> from -> m from\nrewriteBiM   :: (Monad m, Biplate from to) => (to -> m (Maybe to)) -> from -> m from\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE FlexibleContexts #-}\n\nimport Data.Generics.Uniplate.Direct\n\ntype Name = String\n\ndata Expr\n  = Var Name\n  | Lam Name Expr\n  | App Expr Expr\n  deriving Show\n\ndata Stmt\n  = Decl [Stmt]\n  | Let Name Expr\n  deriving Show\n\ninstance Uniplate Expr where\n  uniplate (Var x  ) = plate Var |- x\n  uniplate (App x y) = plate App |* x |* y\n  uniplate (Lam x y) = plate Lam |- x |* y\n\ninstance Biplate Expr Expr where\n  biplate = plateSelf\n\ninstance Uniplate Stmt where\n  uniplate (Decl x  ) = plate Decl ||* x\n  uniplate (Let x y) = plate Let |-  x |- y\n\ninstance Biplate Stmt Stmt where\n  biplate = plateSelf\n\ninstance Biplate Stmt Expr where\n  biplate (Decl x) = plate Decl ||+ x\n  biplate (Let x y) = plate Let |- x |* y\n\nrename :: Name -> Name -> Expr -> Expr\nrename from to = rewrite f\n  where\n    f (Var a) | a == from = Just (Var to)\n    f (Lam a b) | a == from = Just (Lam to b)\n    f _ = Nothing\n\ns, k, sk :: Expr\ns = Lam \"x\" (Lam \"y\" (Lam \"z\" (App (App (Var \"x\") (Var \"z\")) (App (Var \"y\") (Var \"z\")))))\nk = Lam \"x\" (Lam \"y\" (Var \"x\"))\nsk = App s k\n\nm :: Stmt\nm = descendBi f $ Decl [ (Let \"s\" s) , Let \"k\" k , Let \"sk\" sk ]\n  where\n    f = rename \"x\" \"a\"\n      . rename \"y\" \"b\"\n      . rename \"z\" \"c\"\n```","tags":["Generics"]},{"title":"Haskell-Promotion","url":"/blog/2019/10/09/Haskell-Promotion/","content":"> [原文](http://dev.stephendiehl.com/hask/#promotion)\n\n### Higher Kinded Types\n`higher kinded types`是什麼?\n与大多数其他语言相比，`Haskell`中的`kind`系统是独特的，因为它允许构造将`types`(类型)和`type constructors`(类型构造函数)带到其他类型的`datatypes`(数据类型)。\n据说这样的系统支持`higher kinded types`。\n\n`haskell`中的所有`Kind`註解都必然会产生一個`kind *`，尽管左边的任何`terms`(术语)都可能是`higher-kinded`(`* -> *`)。\n常见的例子是`Monad`，它的种类为`* -> *`。\n但是我们也已经在`free monads`中看到了这种`higher-kindedness`。\n```haskell\ndata Free f a where\n  Pure :: a -> Free f a\n  Free :: f (Free f a) -> Free f a\n\ndata Cofree f a where\n  Cofree :: a -> f (Cofree f a) -> Cofree f a\nFree :: (* -> *) -> * -> *\nCofree :: (* -> *) -> * -> *\n```\n例如，对于某些`monokinded`(单种)类型`a`的`Cofree Maybe a`可以通过`Maybe :: * -> *`来建模非空列表。\n```haskell\n-- Cofree Maybe a is a non-empty list\ntestCofree :: Cofree Maybe Int\ntestCofree = (Cofree 1 (Just (Cofree 2 Nothing)))\n```\n\n### Kind Polymorphism\n> 这是高级部分，编写Haskell通常不需要了解`kind polymorphism`(种类多态性)。\n\n`regular`(正则/常規)值级函数接受一个函数并将其应用于一个参数，它被普遍地推广到通常的`hindley-milner`方法中。\n```haskell\napp :: forall a b. (a -> b) -> a -> b\napp f a = f a\n```\n但是，当我们在`type-level`(类型级别)执行相同的操作时，我们会发现丢失了有关所应用构造函数的`polymorphism`(多态性)的信息。\n```haskell\n-- TApp :: (* -> *) -> * -> *\ndata TApp f a = MkTApp (f a)\n```\n启用`-XPolyKinds`擴展也会允许`kind`级别的`polymorphic`(多态)变量。\n```haskell\n-- Default:   (* -> *) -> * -> *\n-- PolyKinds: (k -> *) -> k -> *\ndata TApp f a = MkTApp (f a)\n\n-- Default:   ((* -> *) -> (* -> *)) -> (* -> *)\n-- PolyKinds: ((k -> *) -> (k -> *)) -> (k -> *)\ndata Mu f a = Roll (f (Mu f) a)\n\n-- Default:   * -> *\n-- PolyKinds: k -> *\ndata Proxy a = Proxy\n```\n使用`polykinded`(多种类)的`Proxy`类型允许我们在任意`kind`(种类)的构造函数上写下类型类函数。\n```haskell\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n\ndata Proxy a = Proxy\ndata Rep = Rep\n\nclass PolyClass a where\n  foo :: Proxy a -> Rep\n  foo = const Rep\n\n-- () :: *\n-- [] :: * -> *\n-- Either :: * -> * -> *\n\ninstance PolyClass ()\ninstance PolyClass []\ninstance PolyClass Either\n```\n例如，我们现在可以在类型级别上写下`polymorphic`(多态)`S K combinators`(组合器)。\n```haskell\n{-# LANGUAGE PolyKinds #-}\n\nnewtype I (a :: *) = I a\nnewtype K (a :: *) (b :: k) = K a\nnewtype Flip (f :: k1 -> k2 -> *) (x :: k2) (y :: k1) = Flip (f y x)\n\nunI :: I a -> a\nunI (I x) = x\n\nunK :: K a b -> a\nunK (K x) = x\n\nunFlip :: Flip f x y -> f y x\nunFlip (Flip x) = x\n```\n\n### Data Kinds\n> 这是高级部分，编写Haskell通常不需要了解`Data Kinds`。\n\n`-XDataKinds`扩展允许我们在值级别和类型级别使用`refer to`(引用)构造函数。考虑一个简单的`sum`类型:\n```haskell\ndata S a b = L a | R b\n\n-- S :: * -> * -> *\n-- L :: a -> S a b\n-- R :: b -> S a b\n```\n启用扩展后，我们可以看到我们的类型构造函数现在已自动升级，因此可以将`L`或`R`视为类型为`S`的数据构造函数或`kind`(種類)为`S`的`L`类型的数据构造器。\n\n```haskell\n{-# LANGUAGE DataKinds #-}\n\ndata S a b = L a | R b\n\n-- S :: * -> * -> *\n-- L :: * -> S * *\n-- R :: * -> S * *\n```\n可以在类型签名中以单引号作为前缀来引用升级的数据构造函数。\n同样重要的是，默认情况下，这些提升的构造函数不随模块一起导出，但是可以为勾选的`promoted`(提升)类型创建`type synonym`(类型同义词)实例，并直接将其导出。\n```haskell\ndata Foo = Bar | Baz\ntype Bar = 'Bar\ntype Baz = 'Baz\n```\n将此与`type families`相结合，我们看到可以通过将`types`(类型)提升到`kind`(种类)级别来编写有意义的类型级别的函数。\n```haskell\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE DataKinds #-}\n\nimport Prelude hiding (Bool(..))\n\ndata Bool = False | True\n\ntype family Not (a :: Bool) :: Bool\n\ntype instance Not True = False\ntype instance Not False = True\n\nfalse :: Not True ~ False => a\nfalse = undefined\n\ntrue :: Not False ~ True => a\ntrue = undefined\n\n-- Fails at compile time.\n-- Couldn't match type 'False with 'True\ninvalid :: Not True ~ True => a\ninvalid = undefined\n```\n\n\n### Size-Indexed Vectors\n\n使用这种新结构，我们现在可以创建一个`Vec`类型，该类型通过其长度和元素类型进行参数化，因为我们有一种`kind`(种类)丰富的语言，足以在广义代数数据类型的`kind`(种类)签名中对后继类型进行编码。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FlexibleContexts #-}\n\ndata Nat = Z | S Nat deriving (Eq, Show)\n\ntype Zero  = Z\ntype One   = S Zero\ntype Two   = S One\ntype Three = S Two\ntype Four  = S Three\ntype Five  = S Four\n\ndata Vec :: Nat -> * -> * where\n  Nil :: Vec Z a\n  Cons :: a -> Vec n a -> Vec (S n) a\n\ninstance Show a => Show (Vec n a) where\n  show Nil         = \"Nil\"\n  show (Cons x xs) = \"Cons \" ++ show x ++ \" (\" ++ show xs ++ \")\"\n\nclass FromList n where\n  fromList :: [a] -> Vec n a\n\ninstance FromList Z where\n  fromList [] = Nil\n\ninstance FromList n => FromList (S n) where\n  fromList (x:xs) = Cons x $ fromList xs\n\n\nlengthVec :: Vec n a -> Nat\nlengthVec Nil = Z\nlengthVec (Cons x xs) = S (lengthVec xs)\n\nzipVec :: Vec n a -> Vec n b -> Vec n (a,b)\nzipVec Nil Nil = Nil\nzipVec (Cons x xs) (Cons y ys) = Cons (x,y) (zipVec xs ys)\n\nvec4 :: Vec Four Int\nvec4 = fromList [0, 1, 2, 3]\n\nvec5 :: Vec Five Int\nvec5 = fromList [0, 1, 2, 3, 4]\n\n\nexample1 :: Nat\nexample1 = lengthVec vec4\n-- S (S (S (S Z)))\n\nexample2 :: Vec Four (Int, Int)\nexample2 = zipVec vec4 vec4\n-- Cons (0,0) (Cons (1,1) (Cons (2,2) (Cons (3,3) (Nil))))\n```\n所以现在如果我们尝试`zip`两个形状错误的`vec`类型，那么在编译时会得到一个关于`off by one`错误的错误。\n```haskell\nexample2 = zipVec vec4 vec5\n-- Couldn't match type 'S 'Z with 'Z\n-- Expected type: Vec Four Int\n--   Actual type: Vec Five Int\n```\n我们可以使用相同的技术来创建一个由空或非空标志静态索引的容器,这样,如果我们尝试获取空列表的头部,则会得到编译时错误,或者等效地声明为我們有义务向编译器证明我们传递给`head`函数的参数是非空的。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FlexibleContexts #-}\n\ndata Size = Empty | NonEmpty\n\ndata List a b where\n  Nil  :: List Empty a\n  Cons :: a -> List b a -> List NonEmpty a\n\nhead' :: List NonEmpty a -> a\nhead' (Cons x _) = x\n\nexample1 :: Int\nexample1 = head' (1 `Cons` (2 `Cons` Nil))\n\n-- Cannot match type Empty with NonEmpty\nexample2 :: Int\nexample2 = head' Nil\nCouldn't match type None with Many\nExpected type: List NonEmpty Int\n  Actual type: List Empty Int\n```\n\n請看: [Giving Haskell a Promotion](https://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf)\n\n\n### Typelevel Numbers\n`GHC`的`type literals`(类型文字)也可以用来代替显式`Peano`算术。\n\n`GHC 7.6`在执行`reduction`(约简)方面非常保守，而`GHC 7.8`则要少得多，它可以解决许多涉及自然数的类型级约束，但有时仍需要一点儿`coaxing`(哄骗)。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE TypeOperators #-}\n\nimport GHC.TypeLits\n\ndata Vec :: Nat -> * -> * where\n  Nil :: Vec 0 a\n  Cons :: a -> Vec n a -> Vec (1 + n) a\n\n-- GHC 7.6 will not reduce\n-- vec3 :: Vec (1 + (1 + (1 + 0))) Int\n\nvec3 :: Vec 3 Int\nvec3 = 0 `Cons` (1 `Cons` (2 `Cons` Nil))\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE FlexibleContexts #-}\n\nimport GHC.TypeLits\nimport Data.Type.Equality\n\ndata Foo :: Nat -> * where\n  Small    :: (n <= 2)  => Foo n\n  Big      :: (3 <= n) => Foo n\n\n  Empty    :: ((n == 0) ~ True) => Foo n\n  NonEmpty :: ((n == 0) ~ False) => Foo n\n\nbig :: Foo 10\nbig = Big\n\nsmall :: Foo 2\nsmall = Small\n\nempty :: Foo 0\nempty = Empty\n\nnonempty :: Foo 3\nnonempty = NonEmpty\n```\n請看: [Type-Level Literals](http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/type-level-literals.html)  \n\n### Typelevel Strings\n> TODO\n\n### Custom Errors\n从`GHC 8.0`开始，我们可以使用`type families`提供自定义类型错误。\n消息本身`hook into`(挂接)到`GHC`中，并使用在`GHC.TypeLits`中找到的小`datatype`(数据类型)表示。\n```haskell\ndata ErrorMessage where\n  Text :: Symbol -> ErrorMessage\n  ShowType :: t -> ErrorMessage\n\n  -- Put two messages next to each other\n  (:<>:) :: ErrorMessage -> ErrorMessage -> ErrorMessage\n\n  -- Put two messages on top of each other\n  (:$$:) :: ErrorMessage -> ErrorMessage -> ErrorMessage\n```\n如果在表达式的签名中找到這些表达式中的任意一個，`GHC`将报告以下形式的错误消息：\n```haskell\nexample.hs:1:1: error:\n    • My custom error message line 1.\n    • My custom error message line 2.\n    • In the expression: example\n      In an equation for ‘foo’: foo = ECoerce (EFloat 3) (EInt 4)\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nimport GHC.TypeLits\n\ninstance\n  -- Error Message\n  TypeError (Text \"Equality is not defined for functions\"\n  :$$:\n  (ShowType a :<>: Text \" -> \" :<>: ShowType b))\n\n  -- Instance head\n  => Eq (a -> b) where (==) = undefined\n\n-- Fail when we try to equate two functions\nexample = id == id\n```\n一个不太人为的示例是创建一个类型安全的嵌入式`DSL`，该类型的`DSL`在类型级别上强制实现`semantics`(语义上)的`invariants`(不变性)。 一段时间以来，我们已经能够使用`GADT`和`type-families`来做这种事情，但是错误报告却非常可怕。使用`GHC 8.0`，我们可以拥有`type-families`，它可以发出有用的类型错误，以反映实际出了什么问题，并将其集成到`GHC`中。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nimport GHC.TypeLits\n\ntype family Coerce a b where\n  Coerce Int Int     = Int\n  Coerce Float Float = Float\n  Coerce Int Float   = Float\n  Coerce Float Int   = TypeError (Text \"Cannot cast to smaller type\")\n\ndata Expr a where\n  EInt    :: Int -> Expr Int\n  EFloat  :: Float -> Expr Float\n  ECoerce :: Expr b -> Expr c -> Expr (Coerce b c)\n\nfoo :: Expr Int\nfoo = ECoerce (EFloat 3) (EInt 4)\n```\n\n### Type Equality\n继续以在`Haskell`中构建更详尽的证明为主题，`ghc 7.8`最近附带了`data.type.equality`模块，该模块为我们提供了一组扩展的类型级操作集，用于将`the equality of types`(类型相等)表示为`values`(值)、`constraints`(约束)和`promoted booleans`(提升的布尔值)。\n```haskell\n(~)   :: k -> k -> Constraint\n(==)  :: k -> k -> Bool\n(<=)  :: Nat -> Nat -> Constraint\n(<=?) :: Nat -> Nat -> Bool\n(+)   :: Nat -> Nat -> Nat\n(-)   :: Nat -> Nat -> Nat\n(*)   :: Nat -> Nat -> Nat\n(^)   :: Nat -> Nat -> Nat\n(:~:)     :: k -> k -> *\nRefl      :: a1 :~: a1\nsym       :: (a :~: b) -> b :~: a\ntrans     :: (a :~: b) -> (b :~: c) -> a :~: c\ncastWith  :: (a :~: b) -> a -> b\ngcastWith :: (a :~: b) -> (a ~ b => r) -> r\n```\n这样，我们就有了一种更强大的语言来编写可以在编译时检查的`restrictions`(限制/限定/框框)，以及一种将允许我们(稍后)编写更高级的证明的机制。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE ConstraintKinds #-}\n\nimport GHC.TypeLits\nimport Data.Type.Equality\n\ntype Not a b = ((b == a) ~ False)\n\nrestrictUnit :: Not () a => a -> a\nrestrictUnit = id\n\nrestrictChar :: Not Char a => a -> a\nrestrictChar = id\n```\n\n### Proxies (代理人)\n对`phantom`(幻影)类型使用`kind polymorphism`(種類多态性)使我们可以表达`Proxy`类型，\n该代理类型由一个没有参数的构造函数`inhabited`(所驻留)，但带有一個(可以携带任意一個類型的)`polykinded`(多種類)幻像类型变量。\n```haskell\n{-# LANGUAGE PolyKinds #-}\n\n-- | A concrete, poly-kinded proxy type\ndata Proxy t = Proxy\nimport Data.Proxy\n\na :: Proxy ()\na = Proxy\n\nb :: Proxy 3\nb = Proxy\n\nc :: Proxy \"symbol\"\nc = Proxy\n\nd :: Proxy Maybe\nd = Proxy\n\ne :: Proxy (Maybe ())\ne = Proxy\n```\n如果我们通常将`undefined`作为类型类字典的`witness`(见证)来传递，我们可以改为传递一个带有幻像类型的`Proxy`对象，而无需`bottom`(底部)。\n(`Using scoped type variables we can then operate with the phantom parameter and manipulate wherever is needed.`)\n使用作用域类型变量，我们可以与`phantom`参数`operate with`(合作)，并在需要的地方进行`manipulate`(操作)。\n\n```haskell\nt1 :: a\nt1 = (undefined :: a)\n\nt2 :: Proxy a\nt2 Proxy :: Proxy a\n```\n\n### Promoted Syntax\n我们已经看到使用`DataKinds`提升(`promoted`)了构造函数，但就像在`value-level`上，`GHC`还允许我们为列表和元组使用一些语法糖，而不是显式的`cons`和`pair`。这是通过`-XTypeOperators`扩展启用的，该扩展在`type-level`引入了列表语法和任意`arity`(數)元组。\n```haskell\ndata HList :: [*] -> * where\n  HNil  :: HList '[]\n  HCons :: a -> HList t -> HList (a ': t)\n\ndata Tuple :: (*,*) -> * where\n  Tuple :: a -> b -> Tuple '(a,b)\n```\n使用此方法，我们可以构造所有各种`composite`(复合)类型级别的对象。\n```haskell\nλ: :kind 1\n1 :: Nat\n\nλ: :kind \"foo\"\n\"foo\" :: Symbol\n\nλ: :kind [1,2,3]\n[1,2,3] :: [Nat]\n\nλ: :kind [Int, Bool, Char]\n[Int, Bool, Char] :: [*]\n\nλ: :kind Just [Int, Bool, Char]\nJust [Int, Bool, Char] :: Maybe [*]\n\nλ: :kind '(\"a\", Int)\n(,) Symbol *\n\nλ: :kind [ '(\"a\", Int), '(\"b\", Bool) ]\n[ '(\"a\", Int), '(\"b\", Bool) ] :: [(,) Symbol *]\n```\n\n### Singleton Types\n> 这是高级部分，编写Haskell通常不需要`Singleton Types`知识。\n\n单例类型是具有单个值`inhabitant`(居民/實例)的类型。可以使用`GADTs`或`data families`以多种方式构造`Singleton`(单例)类型。\n```haskell\ndata instance Sing (a :: Nat) where\n  SZ :: Sing 'Z\n  SS :: Sing n -> Sing ('S n)\n\ndata instance Sing (a :: Maybe k) where\n  SNothing :: Sing 'Nothing\n  SJust :: Sing x -> Sing ('Just x)\n\ndata instance Sing (a :: Bool) where\n  STrue :: Sing True\n  SFalse :: Sing False\n```\n#### Promoted Naturals\n![](img/01.png)\n`singleton`类型是`haskell`中伪造`dependent types`(依赖类型)的小型家庭工业的一个组成部分，即使用基于值的`terms`(术语)构造类型。\n单例类型是通过将类型和值之间的映射建模为类型的结构属性来`cheating`(作弊)的一种方式。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeSynonymInstances #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nimport Data.Proxy\nimport GHC.Exts (Any)\nimport Prelude hiding (succ)\n\ndata Nat = Z | S Nat\n\n-- kind-indexed data family\ndata family Sing (a :: k)\n\ndata instance Sing (a :: Nat) where\n  SZ :: Sing 'Z\n  SS :: Sing n -> Sing ('S n)\n\ndata instance Sing (a :: Maybe k) where\n  SNothing :: Sing 'Nothing\n  SJust :: Sing x -> Sing ('Just x)\n\ndata instance Sing (a :: Bool) where\n  STrue :: Sing True\n  SFalse :: Sing False\n\ndata Fin (n :: Nat) where\n  FZ :: Fin (S n)\n  FS :: Fin n -> Fin (S n)\n\ndata Vec a n where\n  Nil  :: Vec a Z\n  Cons :: a -> Vec a n -> Vec a (S n)\n\nclass SingI (a :: k) where\n  sing :: Sing a\n\ninstance SingI Z where\n  sing = SZ\n\ninstance SingI n => SingI (S n) where\n  sing = SS sing\n\nderiving instance Show Nat\nderiving instance Show (SNat a)\nderiving instance Show (SBool a)\nderiving instance Show (Fin a)\nderiving instance Show a => Show (Vec a n)\n\ntype family (m :: Nat) :+ (n :: Nat) :: Nat where\n  Z :+ n = n\n  S m :+ n = S (m :+ n)\n\ntype SNat (k :: Nat) = Sing k\ntype SBool (k :: Bool) = Sing k\ntype SMaybe (b :: a) (k :: Maybe a) = Sing k\n\nsize :: Vec a n -> SNat n\nsize Nil         = SZ\nsize (Cons x xs) = SS (size xs)\n\nforget :: SNat n -> Nat\nforget SZ = Z\nforget (SS n) = S (forget n)\n\nnatToInt :: Integral n => Nat -> n\nnatToInt Z     = 0\nnatToInt (S n) = natToInt n + 1\n\nintToNat :: (Integral a, Ord a) => a -> Nat\nintToNat 0 = Z\nintToNat n = S $ intToNat (n - 1)\n\nsNatToInt :: Num n => SNat x -> n\nsNatToInt SZ     = 0\nsNatToInt (SS n) = sNatToInt n + 1\n\nindex :: Fin n -> Vec a n -> a\nindex FZ (Cons x _)      = x\nindex (FS n) (Cons _ xs) = index n xs\n\n\ntest1 :: Fin (S (S (S Z)))\ntest1 = FS (FS FZ)\n\ntest2 :: Int\ntest2 = index FZ (1 `Cons` (2 `Cons` Nil))\n\ntest3 :: Sing ('Just ('S ('S Z)))\ntest3 = SJust (SS (SS SZ))\n\ntest4 :: Sing ('S ('S Z))\ntest4 = SS (SS SZ)\n\n-- polymorphic constructor SingI\ntest5 :: Sing ('S ('S Z))\ntest5 = sing\n```\n`GHC.TypeLits`中提供的内置单例类型具有有用的实现，即:即使存在下，类型级别的值也可以反映到值级别并`back up`(备份)到类型级别。\n```haskell\nsomeNatVal :: Integer -> Maybe SomeNat\nsomeSymbolVal :: String -> SomeSymbol\n\nnatVal :: KnownNat n => proxy n -> Integer\nsymbolVal :: KnownSymbol n => proxy n -> String\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE TypeOperators #-}\n\nimport Data.Proxy\nimport GHC.TypeLits\n\na :: Integer\na = natVal (Proxy :: Proxy 1)\n-- 1\n\nb :: String\nb = symbolVal (Proxy :: Proxy \"foo\")\n-- \"foo\"\n\nc :: Integer\nc = natVal (Proxy :: Proxy (2 + 3))\n-- 5\n```\n\n### Closed Type Families\n到目前为止，在我们使用的类型族(称为`open type families`)中，没有概念涉及类型级函数中的`equations`(方程)的顺序。\n`type-family`可以在代码解析中的任何位置进行扩展，只需按顺序通过可用的定义即可进行扩展。`Closed type-families`(封闭类型家族)允许另一种声明，该声明为`resolution`(解决方案)提供`a base cas`(基本情况)，从而使我们能够实际地对类型(在类型上)编写递归函数。\n例如，考虑我们是否要编写一个函数，该函数对函数类型中的参数进行计数，并在值级别进行`reifies`(具体化)。\n```haskell\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nimport Data.Proxy\nimport GHC.TypeLits\n\ntype family Count (f :: *) :: Nat where\n  Count (a -> b) = 1 + (Count b)\n  Count x = 1\n\ntype Fn1 = Int -> Int\ntype Fn2 = Int -> Int -> Int -> Int\n\nfn1 :: Integer\nfn1 = natVal (Proxy :: Proxy (Count Fn1))\n-- 2\n\nfn2 :: Integer\nfn2 = natVal (Proxy :: Proxy (Count Fn2))\n-- 4\n```\n我们现在可以写下的各种函数都相当出色，允许我们在类型级别编写有意义的逻辑。\n```haskell\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nimport GHC.TypeLits\nimport Data.Proxy\nimport Data.Type.Equality\n\n-- Type-level functions over type-level lists.\n\ntype family Reverse (xs :: [k]) :: [k] where\n  Reverse '[] = '[]\n  Reverse xs = Rev xs '[]\n\ntype family Rev (xs :: [k]) (ys :: [k]) :: [k] where\n  Rev '[] i = i\n  Rev (x ': xs) i = Rev xs (x ': i)\n\ntype family Length (as :: [k]) :: Nat where\n  Length '[] = 0\n  Length (x ': xs) = 1 + Length xs\n\ntype family If (p :: Bool) (a :: k) (b :: k) :: k where\n  If True a b = a\n  If False a b = b\n\ntype family Concat (as :: [k]) (bs :: [k]) :: [k] where\n  Concat a '[] = a\n  Concat '[] b = b\n  Concat (a ': as) bs = a ': Concat as bs\n\ntype family Map (f :: a -> b) (as :: [a]) :: [b] where\n  Map f '[] = '[]\n  Map f (x ': xs) = f x ': Map f xs\n\ntype family Sum (xs :: [Nat]) :: Nat where\n  Sum '[] = 0\n  Sum (x ': xs) = x + Sum xs\n\nex1 :: Reverse [1,2,3] ~ [3,2,1] => Proxy a\nex1 = Proxy\n\nex2 :: Length [1,2,3] ~ 3 => Proxy a\nex2 = Proxy\n\nex3 :: (Length [1,2,3]) ~ (Length (Reverse [1,2,3])) => Proxy a\nex3 = Proxy\n\n-- Reflecting type level computations back to the value level.\nex4 :: Integer\nex4 = natVal (Proxy :: Proxy (Length (Concat [1,2,3] [4,5,6])))\n-- 6\n\nex5 :: Integer\nex5 = natVal (Proxy :: Proxy (Sum [1,2,3]))\n-- 6\n\n-- Couldn't match type ‘2’ with ‘1’\nex6 :: Reverse [1,2,3] ~ [3,1,2] => Proxy a\nex6 = Proxy\n```\n`type family`函数的结果也不一定要`kinded`(归)为`(*)`。例如，允许使用`Nat`或`Constraint`(约束)。\n```haskell\ntype family Elem (a :: k) (bs :: [k]) :: Constraint where\n  Elem a (a ': bs) = (() :: Constraint)\n  Elem a (b ': bs) = a `Elem` bs\n\ntype family Sum (ns :: [Nat]) :: Nat where\n  Sum '[] = 0\n  Sum (n ': ns) = n + Sum ns\n```\n\n### Kind Indexed Type Families\n> 这是高级部分，编写Haskell通常不需要。\n\n正如通常在`types`(类型)上对`typeclasses`建立索引一样，\n`type families`也可以在`kinds`(种类)上建立索引，这些`kinds`(种类)作为类型变量的显式`kind`(种类)签名给出。\n```haskell\ntype family (a :: k) == (b :: k) :: Bool\ntype instance a == b = EqStar a b\ntype instance a == b = EqArrow a b\ntype instance a == b = EqBool a b\n\ntype family EqStar (a :: *) (b :: *) where\n  EqStar a a = True\n  EqStar a b = False\n\ntype family EqArrow (a :: k1 -> k2) (b :: k1 -> k2) where\n  EqArrow a a = True\n  EqArrow a b = False\n\ntype family EqBool a b where\n  EqBool True  True  = True\n  EqBool False False = True\n  EqBool a     b     = False\n\ntype family EqList a b where\n  EqList '[]        '[]        = True\n  EqList (h1 ': t1) (h2 ': t2) = (h1 == h2) && (t1 == t2)\n  EqList a          b          = False\n\ntype family a && b where\n  True && True = True\n  a    && a    = False\n```\n\n### Promoted Symbols\n```haskell\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE ConstraintKinds #-}\n\n\nimport GHC.TypeLits\nimport Data.Type.Equality\n\ndata Label (l :: Symbol) = Get\n\nclass Has a l b | a l -> b where\n  from :: a -> Label l -> b\n\ndata Point2D = Point2 Double Double deriving Show\ndata Point3D = Point3 Double Double Double deriving Show\n\ninstance Has Point2D \"x\" Double where\n  from (Point2 x _) _ = x\n\ninstance Has Point2D \"y\" Double where\n  from (Point2 _ y) _ = y\n\n\ninstance Has Point3D \"x\" Double where\n  from (Point3 x _ _) _ = x\n\ninstance Has Point3D \"y\" Double where\n  from (Point3 _ y _) _ = y\n\ninstance Has Point3D \"z\" Double where\n  from (Point3 _ _ z) _ = z\n\n\ninfixl 6 #\n\n(#) :: a -> (a -> b) -> b\n(#) = flip ($)\n\n_x :: Has a \"x\" b => a -> b\n_x pnt = from pnt (Get :: Label \"x\")\n\n_y :: Has a \"y\" b => a -> b\n_y pnt = from pnt (Get :: Label \"y\")\n\n_z :: Has a \"z\" b => a -> b\n_z pnt = from pnt (Get :: Label \"z\")\n\ntype Point a r = (Has a \"x\" r, Has a \"y\" r)\n\ndistance :: (Point a r, Point b r, Floating r) => a -> b -> r\ndistance p1 p2 = sqrt (d1^2 + d2^2)\n  where\n    d1 = (p1 # _x) + (p1 # _y)\n    d2 = (p2 # _x) + (p2 # _y)\n\nmain :: IO ()\nmain = do\n  print $ (Point2 10 20) # _x\n\n  -- Fails with: No instance for (Has Point2D \"z\" a0)\n  -- print $ (Point2 10 20) # _z\n\n  print $ (Point3 10 20 30) # _x\n  print $ (Point3 10 20 30) # _z\n\n  print $ distance (Point2 1 3) (Point2 2 7)\n  print $ distance (Point2 1 3) (Point3 2 7 4)\n  print $ distance (Point3 1 3 5) (Point3 2 7 3)\n```\n由于`record`与`tuple`基本上没有区别，因此我们也可以对记录字段名执行相同的`kind`构造。\n```haskell\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE ConstraintKinds #-}\n\n\nimport GHC.TypeLits\n\nnewtype Field (n :: Symbol) v = Field { unField :: v }\n  deriving Show\n\ndata Person1 = Person1\n  { _age      :: Field \"age\" Int\n  , _name     :: Field \"name\" String\n  }\n\ndata Person2 = Person2\n  { _age'  :: Field \"age\" Int\n  , _name' :: Field \"name\" String\n  , _lib'  :: Field \"lib\" String\n  }\n\nderiving instance Show Person1\nderiving instance Show Person2\n\ndata Label (l :: Symbol) = Get\n\nclass Has a l b | a l -> b where\n  from :: a -> Label l -> b\n\ninstance Has Person1 \"age\" Int where\n  from (Person1 a _) _ = unField a\n\ninstance Has Person1 \"name\" String where\n  from (Person1 _ a) _ = unField a\n\ninstance Has Person2 \"age\" Int where\n  from (Person2 a _ _) _ = unField a\n\ninstance Has Person2 \"name\" String where\n  from (Person2 _ a _) _ = unField a\n\nage :: Has a \"age\" b => a -> b\nage pnt = from pnt (Get :: Label \"age\")\n\nname :: Has a \"name\" b => a -> b\nname pnt = from pnt (Get :: Label \"name\")\n\n-- Parameterized constraint kind for \"Simon-ness\" of a record.\ntype Simon a = (Has a \"name\" String, Has a \"age\" Int)\n\nspj :: Person1\nspj = Person1 (Field 56) (Field \"Simon Peyton Jones\")\n\nsmarlow :: Person2\nsmarlow = Person2 (Field 38) (Field \"Simon Marlow\") (Field \"rts\")\n\n\ncatNames :: (Simon a, Simon b) => a -> b -> String\ncatNames a b = name a ++ name b\n\naddAges :: (Simon a, Simon b) => a -> b -> Int\naddAges a b = age a + age b\n\n\nnames :: String\nnames = name smarlow ++ \",\" ++ name spj\n-- \"Simon Marlow,Simon Peyton Jones\"\n\nages :: Int\nages = age spj + age smarlow\n-- 94\n```\n值得注意的是，这种方法大部分只是所有样板类实例化，可以使用`TemplateHaskell`或`Generic deriving`(泛型派生)将其抽象化。\n\n### HLists\n> 这是高级部分，编写Haskell通常不需要。\n`heterogeneous`(异类)列表是`cons`列表，其类型静态地编码其值的`ordered types`(有序类型)。\n```haskell\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE KindSignatures #-}\n\ninfixr 5 :::\n\ndata HList (ts :: [ * ]) where\n  Nil :: HList '[]\n  (:::) :: t -> HList ts -> HList (t ': ts)\n\n-- Take the head of a non-empty list with the first value as Bool type.\nheadBool :: HList (Bool ': xs) -> Bool\nheadBool hlist = case hlist of\n  (a ::: _) -> a\n\nhlength :: HList x -> Int\nhlength Nil = 0\nhlength (_ ::: b) = 1 + (hlength b)\n\n\ntuple :: (Bool, (String, (Double, ())))\ntuple = (True, (\"foo\", (3.14, ())))\n\nhlist :: HList '[Bool, String , Double , ()]\nhlist = True ::: \"foo\" ::: 3.14 ::: () ::: Nil\n```\n当然，这立即引发了一个问题，即在存在`type-heterogeneity`(类型异质性)的情况下如何将这样的列表打印成字符串。\n\n在这种情况下，我们可以将`type-families`与`constraint kinds`(约束类型)结合使用，以对`HLists`参数应用`Show`来生成`HList`中所有类型都是`Showable`的`aggregate constraint`(聚合约束)，然后派生`Show`实例。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nimport GHC.Exts (Constraint)\n\ninfixr 5 :::\n\ndata HList (ts :: [ * ]) where\n  Nil :: HList '[]\n  (:::) :: t -> HList ts -> HList (t ': ts)\n\ntype family Map (f :: a -> b) (xs :: [a]) :: [b]\ntype instance Map f '[] = '[]\ntype instance Map f (x ': xs) = f x ': Map f xs\n\ntype family Constraints (cs :: [Constraint]) :: Constraint\ntype instance Constraints '[] = ()\ntype instance Constraints (c ': cs) = (c, Constraints cs)\n\ntype AllHave (c :: k -> Constraint) (xs :: [k]) = Constraints (Map c xs)\n\nshowHList :: AllHave Show xs => HList xs -> [String]\nshowHList Nil = []\nshowHList (x ::: xs) = (show x) : showHList xs\n\ninstance AllHave Show xs => Show (HList xs) where\n  show = show . showHList\n\nexample1 :: HList '[Bool, String , Double , ()]\nexample1 = True ::: \"foo\" ::: 3.14 ::: () ::: Nil\n-- [\"True\",\"\\\"foo\\\"\",\"3.14\",\"()\"]\n```\n\n### Typelevel Dictionaries\n\n关于`promotion`(晋升)的讨论大部分是关于我们是否可以在类型级别创建数据结构以在编译时存储信息的问题。例如，类型级别`association list`(关联列表)可用于对类型级别`symbols`(符号)和任何其他`promotable`(可推广)类型之间的映射进行建模。与`type-families`一起，我们可以写下类型级别的`traversal`(遍历)和`lookup`(查找)函数。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nimport GHC.TypeLits\nimport Data.Proxy\nimport Data.Type.Equality\n\ntype family If (p :: Bool) (a :: k) (b :: k) :: k where\n  If True a b = a\n  If False a b = b\n\ntype family Lookup (k :: a) (ls :: [(a, b)]) :: Maybe b where\n  Lookup k '[] = 'Nothing\n  Lookup k ('(a, b) ': xs) = If (a == k) ('Just b) (Lookup k xs)\n\ntype M = [\n    '(\"a\", 1)\n  , '(\"b\", 2)\n  , '(\"c\", 3)\n  , '(\"d\", 4)\n  ]\n\ntype K = \"a\"\ntype (!!) m (k :: Symbol) a = (Lookup k m) ~ Just a\n\nvalue :: Integer\nvalue = natVal ( Proxy :: (M !! \"a\") a => Proxy a )\n```\n如果我们要求`GHC`展开类型签名，则可以查看类型级映射查找函数的显式实现。\n```haskell\n(!!)\n  :: If\n       (GHC.TypeLits.EqSymbol \"a\" k)\n       ('Just 1)\n       (If\n          (GHC.TypeLits.EqSymbol \"b\" k)\n          ('Just 2)\n          (If\n             (GHC.TypeLits.EqSymbol \"c\" k)\n             ('Just 3)\n             (If (GHC.TypeLits.EqSymbol \"d\" k) ('Just 4) 'Nothing)))\n     ~ 'Just v =>\n     Proxy k -> Proxy v\n```\n\n### Advanced Proofs\n> 这是高级部分，编写Haskell通常不需要。\n\n现在我们有了`length-indexed`(长度索引)的向量，让我们编写反向函数，它有多难？\n所以我们去写下这样的东西:\n```haskell\nreverseNaive :: forall n a. Vec a n -> Vec a n\nreverseNaive xs = go Nil xs -- Error: n + 0 != n\n  where\n    go :: Vec a m -> Vec a n -> Vec a (n :+ m)\n    go acc Nil = acc\n    go acc (Cons x xs) = go (Cons x acc) xs -- Error: n + succ m != succ (n + m)\n```\n运行此命令，我们发现`GHC`对代码中的两行感到不满意:\n```haskell\nCouldn't match type ‘n’ with ‘n :+ 'Z’\n    Expected type: Vec a n\n      Actual type: Vec a (n :+ 'Z)\n\nCould not deduce ((n1 :+ 'S m) ~ 'S (n1 :+ m))\n    Expected type: Vec a1 (k :+ m)\n      Actual type: Vec a1 (n1 :+ 'S m)\n```\n当我们从向量中展开元素时，由于向后合并向量的子部分，最终将对索引进行大量类型级别的算术运算，但结果是，我们发现`GHC`会遇到一些`unification`(统一)错误，因为它不知道自然数的基本算术属性。即`forall n. n + 0 = 0 `和`forall n m. n + (1 + m) = 1 + (n + m)`。当然，我们应该在类型级别上构建一个可以直观地对算术进行建模的系统，但是`GHC`只是一个笨拙的编译器，它不能自动推论自然数和`Peano`数之间的`isomorphism`(同构)，这当然不应该是真正的假设。\n\n因此，在这些`call sites`(调用站点)中，我们现在都有一个证明义务来构造证明条款。回想一下我们对`GADTs`的`propositional equality`(命题平等)的讨论，我们实际上已经有了这样的机制来构造它。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE ExplicitForAll #-}\n\nimport Data.Type.Equality\n\ndata Nat = Z | S Nat\n\ndata SNat n where\n  Zero :: SNat Z\n  Succ :: SNat n -> SNat (S n)\n\ndata Vec :: * -> Nat -> * where\n  Nil :: Vec a Z\n  Cons :: a -> Vec a n -> Vec a (S n)\n\ninstance Show a => Show (Vec a n) where\n  show Nil         = \"Nil\"\n  show (Cons x xs) = \"Cons \" ++ show x ++ \" (\" ++ show xs ++ \")\"\n\ntype family (m :: Nat) :+ (n :: Nat) :: Nat where\n  Z :+ n = n\n  S m :+ n = S (m :+ n)\n\n-- (a ~ b) implies (f a ~ f b)\ncong :: a :~: b -> f a :~: f b\ncong Refl = Refl\n\n-- (a ~ b) implies (f a) implies (f b)\nsubst :: a :~: b -> f a -> f b\nsubst Refl = id\n\nplus_zero :: forall n. SNat n -> (n :+ Z) :~: n\nplus_zero Zero = Refl\nplus_zero (Succ n) = cong (plus_zero n)\n\nplus_suc :: forall n m. SNat n -> SNat m -> (n :+ (S m)) :~: (S (n :+ m))\nplus_suc Zero m = Refl\nplus_suc (Succ n) m = cong (plus_suc n m)\n\nsize :: Vec a n -> SNat n\nsize Nil         = Zero\nsize (Cons _ xs) = Succ $ size xs\n\nreverse :: forall n a. Vec a n -> Vec a n\nreverse xs = subst (plus_zero (size xs)) $ go Nil xs\n  where\n    go :: Vec a m -> Vec a k -> Vec a (k :+ m)\n    go acc Nil = acc\n    go acc (Cons x xs) = subst (plus_suc (size xs) (size acc)) $ go (Cons x acc) xs\n\nappend :: Vec a n -> Vec a m -> Vec a (n :+ m)\nappend (Cons x xs) ys = Cons x (append xs ys)\nappend Nil         ys = ys\n\nvec :: Vec Int (S (S (S Z)))\nvec = 1 `Cons` (2 `Cons` (3 `Cons` Nil))\n\ntest :: Vec Int (S (S (S Z)))\ntest = Main.reverse vec\n```\n我们可以考虑是否可以避免使用`singleton`(单例)技巧，而只使用类型级自然数，从技术上讲，这种方法应该是可行的，尽管似乎`GHC 7.8`中的自然数求解器可以确定某些属性，但不能确定某些属性完成`reverse`函数的自然数证明。\n```haskell\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nimport Prelude hiding (Eq)\nimport GHC.TypeLits\nimport Data.Type.Equality\n\ntype Z = 0\n\ntype family S (n :: Nat) :: Nat where\n  S n = n + 1\n\n-- Yes!\neq_zero :: Z :~: Z\neq_zero = Refl\n\n-- Yes!\nzero_plus_one :: (Z + 1) :~: (1 + Z)\nzero_plus_one = Refl\n\n-- Yes!\nplus_zero :: forall n. (n + Z) :~: n\nplus_zero = Refl\n\n-- Yes!\nplus_one :: forall n. (n + S Z) :~: S n\nplus_one = Refl\n\n-- No.\nplus_suc :: forall n m. (n + (S m)) :~: (S (n + m))\nplus_suc = Refl\n```\n请注意，在`GHC 7.6`中可能有一种我不知道的方法。\n在`GHC 7.10`中，有一些计划中的变更，以解决这些问题。特别是，有计划允许`pluggable`(可插拔)类型的系统扩展，这些扩展可以将这类问题外包给第三方`SMT`求解器，后者可以解决此类`numeric relations`(数字关系)并将此信息返回给`GHC`的`typechecker`(类型检查器)。\n\n顺便说一句，这是对`Agda`中等效证明的直接音译，它是通过相同的方法完成的，但没有`song and dance`(歌舞)来`get around`(解决)缺少依赖类型的问题。\n```haskell\nmodule Vector where\n\ninfixr 10 _∷_\n\ndata ℕ : Set where\n  zero : ℕ\n  suc  : ℕ → ℕ\n\n{-# BUILTIN NATURAL ℕ    #-}\n{-# BUILTIN ZERO    zero #-}\n{-# BUILTIN SUC     suc  #-}\n\ninfixl 6 _+_\n\n_+_ : ℕ → ℕ → ℕ\n0 + n = n\nsuc m + n = suc (m + n)\n\ndata Vec (A : Set) : ℕ → Set where\n  []  : Vec A 0\n  _∷_ : ∀ {n} → A → Vec A n → Vec A (suc n)\n\n_++_ : ∀ {A n m} → Vec A n → Vec A m → Vec A (n + m)\n[] ++ ys = ys\n(x ∷ xs) ++ ys = x ∷ (xs ++ ys)\n\ninfix 4 _≡_\n\ndata _≡_ {A : Set} (x : A) : A → Set where\n  refl : x ≡ x\n\nsubst : {A : Set} → (P : A → Set) → ∀{x y} → x ≡ y → P x → P y\nsubst P refl p = p\n\ncong : {A B : Set} (f : A → B) → {x y : A} → x ≡ y → f x ≡ f y\ncong f refl = refl\n\nvec : ∀ {A} (k : ℕ) → Set\nvec {A} k = Vec A k\n\nplus_zero : {n : ℕ} → n + 0 ≡ n \nplus_zero {zero}  = refl\nplus_zero {suc n} = cong suc plus_zero\n\nplus_suc : {n : ℕ} → n + (suc 0) ≡ suc n \nplus_suc {zero}  = refl\nplus_suc {suc n} = cong suc (plus_suc {n})\n\nreverse : ∀ {A n} → Vec A n → Vec A n\nreverse []       = []\nreverse {A} {suc n} (x ∷ xs) = subst vec (plus_suc {n}) (reverse xs ++ (x  ∷ []))\n```\n\n### Liquid Haskell\n> 这是高级部分，编写Haskell通常不需要`LiquidLiskell`的知识。\n\n`LiquidHaskell`是`GHC`类型系统的一个扩展，它使用`annotation`(注释)语法增加了`refinement`(细化)类型的能力。外部可以检查函数的类型签名，以获得比默认ghc提供的更丰富的类型语义，包括需要外部smt解算器验证的`non-exhaustive`(非穷尽)模式和复杂的算术属性。例如, `LiquidHaskell`可以静态地验证在`Maybe a`上操作的函数总是被赋予`Just`，或者算术函数总是产生一个甚至是正数的`Int`。\n\n要在`Ubuntu`中安装`LiquidHaskell`，请在`/etc/sources.list中`添加以下行:\n```haskell\ndeb http://ppa.launchpad.net/hvr/z3/ubuntu trusty main\n```\n然后安装外部`SMT`求解器:\n```haskell\n$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys F6F88286\n$ sudo apt-get install z3\n```\n然后`clone repo`(存储库)并使用`stack`进行构建:\n```haskell\n$ git clone --recursive git@github.com:ucsd-progsys/liquidhaskell.git\n$ cd liquidhaskell\n$ stack install\n```\n確保`$HOME/.local/bin`在你的`$PATH`中.\n```haskell\nimport Prelude hiding (mod, gcd)\n\n{-@ mod :: a:Nat -> b:{v:Nat| 0 < v} -> {v:Nat | v < b} @-}\nmod :: Int -> Int -> Int\nmod a b\n  | a < b = a\n  | otherwise = mod (a - b) b\n\n{-@ gcd :: a:Nat -> b:{v:Nat | v < a} -> Int @-}\ngcd :: Int -> Int -> Int\ngcd a 0 = a\ngcd a b = gcd b (a `mod` b)\n```\n可以使用`liquid`命令行工具通过`solver`(求解器)运行该模块。\n```haskell\n$ liquid example.hs\nDone solving.\n\n**** DONE:  solve **************************************************************\n\n\n**** DONE:  annotate ***********************************************************\n\n\n**** RESULT: SAFE **************************************************************\n```\n有关更多详细文档和更多用例，请参见官方文档:\n[Liquid Haskell Documentation](https://ucsd-progsys.github.io/liquidhaskell-tutorial/01-intro.html)\n\n\n\n\n","tags":["Promotion"]},{"title":"Haskell-Type-Families","url":"/blog/2019/10/09/Haskell-Type-Families/","content":"> [原文](http://dev.stephendiehl.com/hask/#type-families)\n\n### MultiParam Typeclasses\n原始`Haskell 98`类型类的解析是通过非常简单的上下文约简来进行的，该上下文约简可以最大程度地减少谓词之间的相互依赖性，解析超类，并将类型简化为普通形式。例如：\n```haskell\n(Eq [a], Ord [a]) => [a]\n==> Ord a => [a]\n```\n如果单个参数`typeclass`表示类型的属性(即,它在类中还是不在`class`中),则多参数`typeclass`表示类型之间的关系。例如，如果我们要表达这种关系，则可以将一个类型转换为另一种类型，则可以使用类似以下的类:\n```haskell\n{-# LANGUAGE MultiParamTypeClasses #-}\n\nimport Data.Char\n\nclass Convertible a b where\n  convert :: a -> b\n\ninstance Convertible Int Integer where\n  convert = toInteger\n\ninstance Convertible Int Char where\n  convert = chr\n\ninstance Convertible Char Int where\n  convert = ord\n```\n当然，现在我们的`Convertible Int`实例不再是唯一的，\n因此，不再存在一个很好的过程来仅根据`a`来确定`b`的推断类型。\n为了解决这个问题，让我们添加一个函數依赖项`a -> b`,它告诉`GHC`实例`a`唯一地确定了`b`可以成为的实例。因此，我们将看到将`Int`与`Integer`和`Char`都衝突关联的两个实例。\n```haskell\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE FunctionalDependencies #-}\n\nimport Data.Char\n\nclass Convertible a b | a -> b where\n  convert :: a -> b\n\ninstance Convertible Int Char where\n  convert = chr\n\ninstance Convertible Char Int where\n  convert = ord\n\nFunctional dependencies conflict between instance declarations:\n  instance Convertible Int Integer\n  instance Convertible Int Char\n```\n现在，有一个更简单的过程来唯一地确定实例，并且多参数`typeclass`变得更加可用和可推断。\n有效的函數依赖`| a-> b`表示我们不能使用相同的`a`但不同的`b`定义多个多参数`typeclass`实例。\n```haskell\nλ: convert (42 :: Int)\n'*'\nλ: convert '*'\n42\n```\n现在，让事情变得不那么简单。\n启用`UndecidableInstances`会放宽对上下文`reduction`(缩减)的约束，这种约束只能使该类的约束在结构上小于其头部。\n结果，隐式计算现在可以在类型类实例搜索中进行。\n结合`Peano`数字的类型级别表示，我们发现我们可以在类型级别对基本算术进行编码。\n```haskell\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE UndecidableInstances #-}\n\ndata Z\ndata S n\n\ntype Zero  = Z\ntype One   = S Zero\ntype Two   = S One\ntype Three = S Two\ntype Four  = S Three\n\nzero :: Zero\nzero = undefined\n\none :: One\none = undefined\n\ntwo :: Two\ntwo = undefined\n\nthree :: Three\nthree = undefined\n\nfour :: Four\nfour = undefined\n\nclass Eval a where\n  eval :: a -> Int\n\ninstance Eval Zero where\n  eval _ = 0\n\ninstance Eval n => Eval (S n) where\n  eval m = 1 + eval (prev m)\n\nclass Pred a b | a -> b where\n  prev :: a -> b\n\ninstance Pred Zero Zero where\n  prev = undefined\n\ninstance Pred (S n) n where\n  prev = undefined\n\nclass Add a b c | a b -> c where\n  add :: a -> b -> c\n\ninstance Add Zero a a where\n  add = undefined\n\ninstance Add a b c => Add (S a) b (S c) where\n  add = undefined\n\nf :: Three\nf = add one two\n\ng :: S (S (S (S Z)))\ng = add two two\n\nh :: Int\nh = eval (add three four)\n```\n如果类型类的上下文看上去与`Prolog`相似，那么您没看错，如果人们将上下文限定符(`=>`)作为旋转門`:-`逆向读取，那么它就是完全相同的方程式。\n```haskell\nadd(0, A, A).\nadd(s(A), B, s(C)) :- add(A, B, C).\n\npred(0, 0).\npred(S(A), A).\n```\n这是在滥用类型类，如果使用不当，可能会在编译时终止或溢出。在未仔细考虑其含义的情况下，不应打开`UndecidableInstances`。\n```haskell\n<interactive>:1:1:\n    Context reduction stack overflow; size = 201\n```\n\n### Type Families\n`Type Families`允许我们在类型域中编写函数，这些函数将类型作为参数，这些参数可以生成类型或索引在其参数上的值，这些值在编译时进行类型检查时执行。`Type Families`有两种变体:`data families`和`type synonym families`。\n* **`type families`** are named function on types\n* **`data families`** are type-indexed data types\n\n首先，让我们看一下`type synonym families`，有两种等效的语法构造方法。在类型类中声明为关联的`type families`，或者在`toplevel`声明为独立的声明。下列形式在语义上是等效的，尽管非关联的形式严格来说更为笼统：\n```haskell\n-- (1) Unassociated form\ntype family Rep a\ntype instance Rep Int = Char\ntype instance Rep Char = Int\n\nclass Convertible a where\n  convert :: a -> Rep a\n\ninstance Convertible Int where\n  convert = chr\n\ninstance Convertible Char where\n  convert = ord\n\n-- (2) Associated form\nclass Convertible a where\n  type Rep a\n  convert :: a -> Rep a\n\ninstance Convertible Int where\n  type Rep Int = Char\n  convert = chr\n\ninstance Convertible Char where\n  type Rep Char = Int\n  convert = ord\n```\n使用我们用于`multiparameter`+`functional dependencies`的示例，我们看到`type family`方法和`functional dependencies`之间有直接的转换。这两种方法具有相同的表达能力。\n\n可以在`GHCi`中使用`:kind!`命令查询关联的`type family`。\n```haskell\nλ: :kind! Rep Int\nRep Int :: *\n= Char\nλ: :kind! Rep Char\nRep Char :: *\n= Int\n```\n另一方面，`Data families`使我们可以创建新型的参数化数据构造函数。\n通常，我们只能定义`typeclasses`函数，它们的行为会导致统一的结果，这纯粹是`typeclasses`参数的结果。\n`With data families we can allow specialized behavior indexed on the type.`(使用`data families`，我们可以允许在类型上建立专门的行为索引)。\n\n例如，如果我们想创建更复杂的向量结构(位掩码向量，元组向量，...),这些结构暴露出统一的API,但在内部处理其数据布局中的差异,则可以使用`data families`来实现这一点:\n```haskell\n{-# LANGUAGE TypeFamilies #-}\n\nimport qualified Data.Vector.Unboxed as V\n\ndata family Array a\ndata instance Array Int       = IArray (V.Vector Int)\ndata instance Array Bool      = BArray (V.Vector Bool)\ndata instance Array (a,b)     = PArray (Array a) (Array b)\ndata instance Array (Maybe a) = MArray (V.Vector Bool) (Array a)\n\nclass IArray a where\n  index :: Array a -> Int -> a\n\ninstance IArray Int where\n  index (IArray xs) i = xs V.! i\n\ninstance IArray Bool where\n  index (BArray xs) i = xs V.! i\n\n-- Vector of pairs\ninstance (IArray a, IArray b) => IArray (a, b) where\n  index (PArray xs ys) i = (index xs i, index ys i)\n\n-- Vector of missing values\ninstance (IArray a) => IArray (Maybe a) where\n  index (MArray bm xs) i =\n    case bm V.! i of\n      True  -> Nothing\n      False -> Just $ index xs i\n```\n\n### Injectivity(內射性)\n`type-families`定义的类型级别函数不一定是`injectivity`的，函数可以将两个不同的输入类型映射到相同的输出类型。\n这不同于`injectivity`类型构造器(也是类型级别的函数)的行为。\n\n例如: 對於`Maybe`构造函數，`Maybe t1 = Maybe t2`意味著`t1 = t2`.\n```haskell\ndata Maybe a = Nothing | Just a\n-- Maybe a ~ Maybe b  implies  a ~ b\n\ntype instance F Int = Bool\ntype instance F Char = Bool\n\n-- F a ~ F b does not imply  a ~ b, in general\n```\n\n### Roles\n> 这是高级部分，编写Haskell通常不需要。\n\n`Roles`是`datatypes`的类型变量参数的进一步规范。\n* `nominal`(名义上的)\n* `representational`(代表性的/表示形式)\n* `phantom`(幻影)\n\n他们被添加到语言中,以解决围绕`newtype`及其运行时表示之间的`correspondence`(对应关系)的一个令人讨厌且长期存在的`bug`。\n`roles`引入的基本区别是类型相等有两个概念。当两种类型的名称相同时，它们在名义上是相等的。这是`Haskell`或`Core`中通常的等式。当两种类型具有相同的表示形式时，它们在表示上是相等的。(如果类型具有`higher-kinded`(较高的种类)，则所有名义上相等的实例化将导致表示形式相同的类型。)\n\n* nominal - 兩個類型是相同的\n* representational - 兩個類型具有相同的運行時表示形式\n```haskell\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\nnewtype Age = MkAge { unAge :: Int }\n\ntype family Inspect x\ntype instance Inspect Age = Int\ntype instance Inspect Int = Bool\n\nclass Boom a where\n  boom :: a -> Inspect a\n\ninstance Boom Int where\n  boom = (== 0)\n\nderiving instance Boom Age\n\n-- GHC 7.6.3 exhibits undefined behavior\nfailure = boom (MkAge 3)\n-- -6341068275333450897\n```\n`Roles`通常是自动推断的，但是通过`RoleAnnotations`扩展，可以手动对其进行注释。除极少数情况外，这不是必需的，尽管有助于了解幕后情况。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE RoleAnnotations #-}\n\ndata Nat = Zero | Suc Nat\n\ntype role Vec nominal representational\ndata Vec :: Nat -> * -> * where\n  Nil  :: Vec Zero a\n  (:*) :: a -> Vec n a -> Vec (Suc n) a\n\ntype role App representational nominal\ndata App (f :: k -> *) (a :: k) = App (f a)\n\ntype role Mu nominal nominal\ndata Mu (f :: (k -> *) -> k -> *) (a :: k) = Roll (f (Mu f) a)\n\ntype role Proxy phantom\ndata Proxy (a :: k) = Proxy\ncoerce :: Coercible * a b => a -> b\nclass (~R#) k k a b => Coercible k a b\n```\n\n[Safe Zero-cost Coercions for Haskell](http://cs.brynmawr.edu/~rae/papers/2014/coercible/coercible.pdf) (Haskell的安全零成本强制转换)\n\n[Data.Coerce](https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Coerce.html#t:Coercible)\n\n請看:   \n* [Roles](https://ghc.haskell.org/trac/ghc/wiki/Roles)\n* [Roles: A New Feature of GHC](http://typesandkinds.wordpress.com/2013/08/15/roles-a-new-feature-of-ghc/)\n\n\n### Mono-traversable(单行遍历)\n使用`type families`，`mono-traversable`可以将`Functor`，`Foldable`和`Traversable`的概念进行概括(归纳)，以包括`monomorphic`(单态)和`polymorphic`(多态)类型。\n```haskell\nomap :: MonoFunctor mono => (Element mono -> Element mono) -> mono -> mono\n\notraverse :: (Applicative f, MonoTraversable mono)\n          => (Element mono -> f (Element mono)) -> mono -> f mono\n\nofoldMap :: (Monoid m, MonoFoldable mono)\n         => (Element mono -> m) -> mono -> m\nofoldl' :: MonoFoldable mono\n        => (a -> Element mono -> a) -> a -> mono -> a\nofoldr :: MonoFoldable mono\n        => (Element mono -> b -> b) -> b -> mono -> b\n```\n例如，自此以来，文本类型通常不接受任何这些类型类，但是现在我们可以写出对`Foldable`和`Traversable`接口进行建模的实例。\n```haskell\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Data.Text\nimport Data.Char\nimport Data.Monoid\nimport Data.MonoTraversable\nimport Control.Applicative\n\nbs :: Text\nbs = \"Hello Haskell.\"\n\nshift :: Text\nshift = omap (chr . (+1) . ord) bs\n-- \"Ifmmp!Ibtlfmm/\"\n\nbackwards :: [Char]\nbackwards = ofoldl' (flip (:)) \"\" bs\n-- \".lleksaH olleH\"\n\n\ndata MyMonoType = MNil | MCons Int MyMonoType deriving Show\n\ntype instance Element MyMonoType = Int\n\ninstance MonoFunctor MyMonoType where\n  omap f MNil = MNil\n  omap f (MCons x xs) = f x `MCons` omap f xs\n\ninstance MonoFoldable MyMonoType where\n  ofoldMap f   = ofoldr (mappend . f) mempty\n  ofoldr       = mfoldr\n  ofoldl'      = mfoldl'\n  ofoldr1Ex f  = ofoldr1Ex f . mtoList\n  ofoldl1Ex' f = ofoldl1Ex' f . mtoList\n\ninstance MonoTraversable MyMonoType where\n  omapM f xs = mapM f (mtoList xs) >>= return . mfromList\n  otraverse f = ofoldr acons (pure MNil)\n    where acons x ys = MCons <$> f x <*> ys\n\nmtoList :: MyMonoType -> [Int]\nmtoList (MNil) = []\nmtoList (MCons x xs) = x : (mtoList xs)\n\nmfromList :: [Int] -> MyMonoType\nmfromList [] = MNil\nmfromList (x:xs) = MCons x (mfromList xs)\n\nmfoldr :: (Int -> a -> a) -> a -> MyMonoType -> a\nmfoldr f z MNil =  z\nmfoldr f z (MCons x xs) =  f x (mfoldr f z xs)\n\nmfoldl' :: (a -> Int -> a) -> a -> MyMonoType -> a\nmfoldl' f z MNil = z\nmfoldl' f z (MCons x xs) = let z' = z `f` x\n                           in seq z' $ mfoldl' f z' xs\n\nex1 :: Int\nex1 = mfoldl' (+) 0 (mfromList [1..25])\n\nex2 :: MyMonoType\nex2 = omap (+1) (mfromList [1..25])\n```\n請看: [From Semigroups to Monads](http://fundeps.com/tables/FromSemigroupToMonads.pdf)\n\n### NonEmpty\n与其让许多`Prelude`函数的`degenerate`(退化/简并)情况适应列表的空值情况，不如将静态列表强制构造为某种类型的`inhabitant`(實例)，有时是更可取的。\n```haskell\ninfixr 5 :|, <|\ndata NonEmpty a = a :| [a]\n\nhead :: NonEmpty a -> a\ntoList :: NonEmpty a -> [a]\nfromList :: [a] -> NonEmpty a\nhead :: NonEmpty a -> a\nhead ~(a :| _) = a\nimport Data.List.NonEmpty\nimport Prelude hiding (head, tail, foldl1)\nimport Data.Foldable (foldl1)\n\na :: NonEmpty Integer\na = fromList [1,2,3]\n-- 1 :| [2,3]\n\nb :: NonEmpty Integer\nb = 1 :| [2,3]\n-- 1 :| [2,3]\n\nc :: NonEmpty Integer\nc = fromList []\n-- *** Exception: NonEmpty.fromList: empty list\n\nd :: Integer\nd = foldl1 (+) $ fromList [1..100]\n-- 5050\n```\n\n### Manual Proofs (手工證明)\n> 这是高级部分，编写Haskell通常不需要。\n\n计算机科学中最深刻的成果之一是`curry-howard`对应关系，即逻辑命题可以用类型来建模，而将这些类型实例化就构成了这些命题的证明。程序就是证明，证明就是程序。\n```haskell\nTypes\t          Logic\nA\t              proposition\na : A\t          proof\nB(x)\t          predicate\nVoid        \t  ⊥\nUnit\t          ⊤\nA + B\t          A ∨ B\nA × B\t          A ∧ B\nA -> B            A ⇒ B\n```\n在依赖类型的语言中，我们可以充分利用这个结果；在`haskell`中，我们没有依赖类型提供的优势，但仍然可以证明微不足道的结果。例如，现在我们可以为加法建立类型级別的函数的模型，并提供零是加法恒等式的一个小证明。\n```haskell\nP 0                   [ base step ]\n∀n. P n  → P (1+n)    [ inductive step ]\n-------------------\n∀n. P(n)\nAxiom 1: a + 0 = a\nAxiom 2: a + suc b = suc (a + b)\n\n  0 + suc a\n= suc (0 + a)  [by Axiom 2]\n= suc a        [Induction hypothesis]\n∎\n```\n翻译成`Haskell`的公理只是简单的类型化定义，而归纳数据类型的递归构成了我们证明的归纳步骤。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE TypeOperators #-}\n\ndata Z\ndata S n\n\ndata SNat n where\n  Zero :: SNat Z\n  Succ :: SNat n -> SNat (S n)\n\ndata Eql a b where\n  Refl :: Eql a a\n\ntype family Add m n\ntype instance Add Z n = n\ntype instance Add (S m) n = S (Add m n)\n\nadd :: SNat n -> SNat m -> SNat (Add n m)\nadd Zero     m = m\nadd (Succ n) m = Succ (add n m)\n\ncong :: Eql a b -> Eql (f a) (f b)\ncong Refl = Refl\n\n-- ∀n. 0 + suc n = suc n\nplus_suc :: forall n.  SNat n\n         -> Eql (Add Z (S n)) (S n)\nplus_suc Zero = Refl\nplus_suc (Succ n) = cong (plus_suc n)\n\n-- ∀n. 0 + n = n\nplus_zero :: forall n. SNat n\n         -> Eql (Add Z n) n\nplus_zero Zero = Refl\nplus_zero (Succ n) = cong (plus_zero n)\n```\n使用`TypeOperators`扩展，我们还可以在`type-level`使用中缀符号。\n```haskell\ndata a :=: b where\n  Refl :: a :=: a\n\ncong :: a :=: b -> (f a) :=: (f b)\ncong Refl = Refl\n\ntype family (n :: Nat) :+ (m :: Nat) :: Nat\ntype instance Zero     :+ m = m\ntype instance (Succ n) :+ m = Succ (n :+ m)\n\nplus_suc :: forall n m. SNat n -> SNat m -> (n :+ (S m)) :=: (S (n :+ m))\nplus_suc Zero m = Refl\nplus_suc (Succ n) m = cong (plus_suc n m)\n```\n\n### Constraint Kinds (约束种类)\n> 这是高级部分，编写Haskell通常不需要。\n\n`GHC`的实现还通过启用`-XConstraintKinds`扩展，公開了将`Haskell`中的限定词绑定为类型本身的謂詞。\n使用此扩展，我们将`constraints`(约束)作为第一类类型处理。\n```haskell\nNum :: * -> Constraint\nOdd :: * -> Constraint\ntype T1 a = (Num a, Ord a)\n```\n空约束集由`() :: Constraint`表示。\n对于一个虚构的示例，如果我们想创建一个通用的`Sized`类，该类带有对所涉及容器的元素的约束，则可以使用`type families`非常简单地实现此目的。\n```haskell\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE ConstraintKinds #-}\n\nimport GHC.Exts (Constraint)\nimport Data.Hashable\nimport Data.HashSet\n\ntype family Con a :: Constraint\ntype instance Con [a] = (Ord a, Eq a)\ntype instance Con (HashSet a) = (Hashable a)\n\nclass Sized a where\n  gsize :: Con a => a -> Int\n\ninstance Sized [a] where\n  gsize = length\n\ninstance Sized (HashSet a) where\n  gsize = size\n```\n其中一个用例是捕获受函数约束的`typeclass`字典并将其具体化为一个值。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE KindSignatures #-}\n\nimport GHC.Exts (Constraint)\n\ndata Dict :: Constraint -> * where\n  Dict :: (c) => Dict c\n\ndShow :: Dict (Show a) -> a -> String\ndShow Dict x = show x\n\ndEqNum :: Dict (Eq a, Num a) -> a -> Bool\ndEqNum Dict x = x == 0\n\n\nfShow :: String\nfShow = dShow Dict 10\n\nfEqual :: Bool\nfEqual = dEqNum Dict 0\n```\n\n### TypeFamilyDependencies\n`Type families`在历史上不是内射的，也就是说，它们不能保证将其参数的不同元素映射到其结果的相同元素。语法类似于`multiparmater typeclass functional dependencies`(多参数类型类函数依赖项)，因为生成的类型由一组`type families`参数唯一确定。\n```haskell\n{-# LANGUAGE XTypeFamilyDependencies #-}\n\ntype family F a b c = (result :: k) | result -> a b c\ntype instance F Int  Char Bool = Bool\ntype instance F Char Bool Int  = Int\ntype instance F Bool Int  Char = Char\n```\n請看: [Injective type families for Haskell](http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf) (Haskell的内射性`type families`)\n","tags":["Type-Families"]},{"title":"Haskell-interpreters","url":"/blog/2019/10/09/Haskell-interpreters/","content":"> [原文](http://dev.stephendiehl.com/hask/#interpreters)\n\n`λ`演算为许多语言奠定了理论和实践基础。每个微积分的核心是三个组成部分:\n* **Var** - 表識一個變量\n* **Lam** - 表識一個lambda抽象\n* **App** - 表識一個應用\n![](img/img01.png)\n对这些构造和数据结构表示进行建模的方法有很多，但是它们或多或少都包含这三个要素。\n例如，在`lambda`的`binders`和`variables`上使用字符串名称的`lambda`演算可能如下所示：\n```haskell\ntype Name = String\n\ndata Exp\n  = Var Name\n  | Lam Name Exp\n  | App Exp Exp\n```\n在`lambda`表达式中，出现在表达式主体中的所有变量都被外部`lambda`绑定器引用，則该表达式被称为是`closed`，而具有未绑定的自由变量的表达式则是`open`的。\n\n### HOAS\n高阶抽象语法(`HOAS`)是在一种语言中实现`lambda`演算的一种技术，其中`lambda`表达式的绑定直接映射到宿主语言(即`Haskell`)的`lambda`绑定，从而通过利用`Haskell`的实现为我们的自定义语言提供`substitution`(替换)机制。\n```haskell\n{-# LANGUAGE GADTs #-}\n\ndata Expr a where\n  Con :: a -> Expr a\n  Lam :: (Expr a -> Expr b) -> Expr (a -> b)\n  App :: Expr (a -> b) -> Expr a -> Expr b\n\ni :: Expr (a -> a)\ni = Lam (\\x -> x)\n\nk :: Expr (a -> b -> a)\nk = Lam (\\x -> Lam (\\y -> x))\n\ns :: Expr ((a -> b -> c) -> (a -> b) -> (a -> c))\ns = Lam (\\x -> Lam (\\y -> Lam (\\z -> App (App x z) (App y z))))\n\neval :: Expr a -> a\neval (Con v) = v\neval (Lam f) = \\x -> eval (f (Con x))\neval (App e1 e2) = (eval e1) (eval e2)\n\n\nskk :: Expr (a -> a)\nskk = App (App s k) k\n\nexample :: Integer\nexample = eval skk 1\n-- 1\n```\n漂亮的打印`HOAS`术语也可能非常复杂，因为该函数的主体位于`Haskell lambda`绑定器下。\n\n### PHOAS\n称为`PHOAS`的`HOAS`形式略有不同，它使用在`binder`类型上参数化的`lambda`数据类型。\n在这种形式下，评估需要将其拆包为单独的`Value`类型以包装`lambda`表达式。\n```haskell\n{-# LANGUAGE RankNTypes #-}\n\ndata ExprP a\n  = VarP a\n  | AppP (ExprP a) (ExprP a)\n  | LamP (a -> ExprP a)\n  | LitP Integer\n\ndata Value\n  = VLit Integer\n  | VFun (Value -> Value)\n\nfromVFun :: Value -> (Value -> Value)\nfromVFun val = case val of\n  VFun f -> f\n  _      -> error \"not a function\"\n\nfromVLit :: Value -> Integer\nfromVLit val = case val of\n  VLit n -> n\n  _      -> error \"not a integer\"\n\nnewtype Expr = Expr { unExpr :: forall a . ExprP a }\n\neval :: Expr -> Value\neval e = ev (unExpr e) where\n  ev (LamP f)      = VFun(ev . f)\n  ev (VarP v)      = v\n  ev (AppP e1 e2)  = fromVFun (ev e1) (ev e2)\n  ev (LitP n)      = VLit n\n\ni :: ExprP a\ni = LamP (\\a -> VarP a)\n\nk :: ExprP a\nk = LamP (\\x -> LamP (\\y -> VarP x))\n\ns :: ExprP a\ns = LamP (\\x -> LamP (\\y -> LamP (\\z -> AppP (AppP (VarP x) (VarP z)) (AppP (VarP y) (VarP z)))))\n\nskk :: ExprP a\nskk = AppP (AppP s k) k\n\nexample :: Integer\nexample = fromVLit $ eval $ Expr (AppP skk (LitP 3))\n```\n請看:\n* [PHOAS](http://adam.chlipala.net/papers/PhoasICFP08/PhoasICFP08Talk.pdf)\n* [Encoding Higher-Order Abstract Syntax with Parametric Polymorphism](http://www.seas.upenn.edu/~sweirich/papers/itabox/icfp-published-version.pdf)\n\n### Final Interpreters\n使用类型类，我们可以实现`Final Interpreters`，该解释器使用绑定到类型类的函數而不是数据构造函数对一组可扩展`terms`(术语)进行建模。\n类型类的实例在这些术语上形成解释器。\n\n例如，我们可以编写一种包含基本算术的小语言，然后在不更改基数的情况下使用乘法运算符追溯性地扩展我们的表达式语言。同时，我们的解释器逻辑在扩展新表达式后仍保持不变。\n```haskell\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE TypeSynonymInstances #-}\n{-# LANGUAGE NoMonomorphismRestriction #-}\n\nclass Expr repr where\n  lit :: Int -> repr\n  neg :: repr -> repr\n  add :: repr -> repr -> repr\n  mul :: repr -> repr -> repr\n\ninstance Expr Int where\n  lit n = n\n  neg a = -a\n  add a b = a + b\n  mul a b = a * b\n\ninstance Expr String where\n  lit n = show n\n  neg a = \"(-\" ++ a ++ \")\"\n  add a b = \"(\" ++ a ++ \" + \" ++ b ++ \")\"\n  mul a b = \"(\" ++ a ++ \" * \" ++ b ++ \")\"\n\nclass BoolExpr repr where\n  eq :: repr -> repr -> repr\n  tr :: repr\n  fl :: repr\n\ninstance BoolExpr Int where\n  eq a b = if a == b then tr else fl\n  tr = 1\n  fl = 0\n\ninstance BoolExpr String where\n  eq a b = \"(\" ++ a ++ \" == \" ++ b ++ \")\"\n  tr = \"true\"\n  fl = \"false\"\n\neval :: Int -> Int\neval = id\n\nrender :: String -> String\nrender = id\n\nexpr :: (BoolExpr repr, Expr repr) => repr\nexpr = eq (add (lit 1) (lit 2)) (lit 3)\n\nresult :: Int\nresult = eval expr\n-- 1\n\nstring :: String\nstring = render expr\n-- \"((1 + 2) == 3)\"\n```\n\n### Finally Tagless\n同样，也可以使用`final interpreter`和`Identity`函子来为`lambda`演算编写评估器。\n```haskell\nimport Prelude hiding (id)\n\nclass Expr rep where\n  lam :: (rep a -> rep b) -> rep (a -> b)\n  app :: rep (a -> b) -> (rep a -> rep b)\n  lit :: a -> rep a\n\nnewtype Interpret a = R { reify :: a }\n\ninstance Expr Interpret where\n  lam f   = R $ reify . f . R\n  app f a = R $ reify f $ reify a\n  lit     = R\n\neval :: Interpret a -> a\neval e = reify e\n\ne1 :: Expr rep => rep Int\ne1 = app (lam (\\x -> x)) (lit 3)\n\ne2 :: Expr rep => rep Int\ne2 = app (lam (\\x -> lit 4)) (lam $ \\x -> lam $ \\y -> y)\n\nexample1 :: Int\nexample1 = eval e1\n-- 3\n\nexample2 :: Int\nexample2 = eval e2\n-- 4\n```\n請看: [Typed Tagless Interpretations and Typed Compilation](http://okmij.org/ftp/tagless-final/)\n\n### Datatypes\n描述代数数据类型的常用方法是指出求和类型、乘积类型和多项式表达式之间的自然对应关系是如何产生的。\n```haskell\ndata Void                       -- 0\ndata Unit     = Unit            -- 1\ndata Sum a b  = Inl a | Inr b   -- a + b\ndata Prod a b = Prod a b        -- a * b\ntype (->) a b = a -> b          -- b ^ a\n```\n直觉上遵循这样的观念，即总是可以根据类型的`inhabitants`(類型的實例的統稱)数量来给出其类型的基数。\n`product`类型允许许多`inhabitants`，如`product`函數(即笛卡尔积的基数).\n`sum`类型則是它的`holes`(孔)數总和.\n`function`类型則是`domain`(域)和`codomain`(共域)的`span`(范围)的指数.\n```haskell\n-- domain/codomain/range概念\n\\x -> 2x + 1\ndomain:   A{1,2,3,4}\ncodomain: B{1,2,3,4,5,6,7,8,9,10}\nrange:    C{3,5,7,9}\n```\n```haskell\n-- 1 + A\ndata Maybe a = Nothing | Just a\n```\n递归类型对应于这些`terms`(項/術語)的无穷`series`(系列)。\n```haskell\n-- pseudocode\n\n-- μX. 1 + X\ndata Nat a = Z | S Nat\nNat a = μ a. 1 + a\n      = 1 + (1 + (1 + ...))\n\n-- μX. 1 + A * X\ndata List a = Nil | Cons a (List a)\nList a = μ a. 1 + a * (List a)\n       = 1 + a + a^2 + a^3 + a^4 ...\n\n-- μX. A + A*X*X\ndata Tree a f = Leaf a | Tree a f f\nTree a = μ a. 1 + a * (List a)\n       = 1 + a^2 + a^4 + a^6 + a^8 ...\n```\n請看: [Species and Functors and Types, Oh My!](http://dept.cs.williams.edu/~byorgey/pub/species-pearl.pdf)\n\n### F-Algebras\n`initial algebra`(初始代数)方法与`final interpreter`方法的不同之处在于，我们现在将`terms`表示为代数数据类型，并且解释器通过模式匹配实现递归和评估。\n```haskell\ntype Algebra f a = f a -> a\ntype Coalgebra f a = a -> f a\nnewtype Fix f = Fix { unFix :: f (Fix f) }\n\ncata :: Functor f => Algebra f a -> Fix f -> a\nana  :: Functor f => Coalgebra f a -> a -> Fix f\nhylo :: Functor f => Algebra f b -> Coalgebra f a -> a -> b\n```\n在`Haskell`中，`F-algebra`是一個與函数`f a-> a`在一起的函子`f a`。`Coalgebra`反轉這個函數，对于函子`f`，我们可以使用递归`Fix newtype`包装器来形成其递归展开。\n```haskell\nnewtype Fix f = Fix { unFix :: f (Fix f) }\n\nFix :: f (Fix f) -> Fix f\nunFix :: Fix f -> f (Fix f)\nFix f = f (f (f (f (f (f ( ... ))))))\n\nnewtype T b a = T (a -> b)\n\nFix (T a)\nFix T -> a\n(Fix T -> a) -> a\n(Fix T -> a) -> a -> a\n...\n```\n通过这种形式，我们可以写下通用的`fold/unfold`(折叠/展开)函数，该函数是通用的数据类型，并且纯粹是根据函子下的递归编写的。\n```haskell\ncata :: Functor f => Algebra f a -> Fix f -> a\ncata alg = alg . fmap (cata alg) . unFix\n\nana :: Functor f => Coalgebra f a -> a -> Fix f\nana coalg = Fix . fmap (ana coalg) . coalg\n```\n我们称这些函數为`catamorphisms`和`anamorphisms`。\n特别要注意的是，这两个函数的类型只是使箭头方向相反。\n用另一种方式解释，他们将定义`Fix f f`之间的保留平面结构映射的`algebra/coalgebra`转换为`rolls`(滚动)或`unrolls`(展开)固定点的函数。\n\n这种方法的特別之處在於，将递归抽象到函子定义中，并且我们可以自由地实现平面转换逻辑！\n\n例如，以下形式的自然数的构造:\n```haskell\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\ntype Algebra f a = f a -> a\ntype Coalgebra f a = a -> f a\n\nnewtype Fix f = Fix { unFix :: f (Fix f) }\n\n-- catamorphism\ncata :: Functor f => Algebra f a -> Fix f -> a\ncata alg = alg . fmap (cata alg) . unFix\n\n-- anamorphism\nana :: Functor f => Coalgebra f a -> a -> Fix f\nana coalg = Fix . fmap (ana coalg) . coalg\n\n-- hylomorphism\nhylo :: Functor f => Algebra f b -> Coalgebra f a -> a -> b\nhylo f g = cata f . ana g\n\ntype Nat = Fix NatF\ndata NatF a = S a | Z deriving (Eq,Show)\n\ninstance Functor NatF where\n  fmap f Z     = Z\n  fmap f (S x) = S (f x)\n\nplus :: Nat -> Nat -> Nat\nplus n = cata phi where\n  phi Z     = n\n  phi (S m) = s m\n\ntimes :: Nat -> Nat -> Nat\ntimes n = cata phi where\n  phi Z     = z\n  phi (S m) = plus n m\n\nint :: Nat -> Int\nint = cata phi where\n  phi  Z    = 0\n  phi (S f) = 1 + f\n\nnat :: Integer -> Nat\nnat = ana (psi Z S) where\n  psi f _ 0 = f\n  psi _ f n = f (n-1)\n\nz :: Nat\nz = Fix Z\n\ns :: Nat -> Nat\ns = Fix . S\n\n\ntype Str = Fix StrF\ndata StrF x = Cons Char x | Nil\n\ninstance Functor StrF where\n  fmap f (Cons a as) = Cons a (f as)\n  fmap f Nil = Nil\n\nnil :: Str\nnil = Fix Nil\n\ncons :: Char -> Str -> Str\ncons x xs = Fix (Cons x xs)\n\nstr :: Str -> String\nstr = cata phi where\n  phi Nil         = []\n  phi (Cons x xs) = x : xs\n\nstr' :: String -> Str\nstr' = ana (psi Nil Cons) where\n  psi f _ []     = f\n  psi _ f (a:as) = f a as\n\nmap' :: (Char -> Char) -> Str -> Str\nmap' f = hylo g unFix\n  where\n    g Nil        = Fix Nil\n    g (Cons a x) = Fix $ Cons (f a) x\n\n\ntype Tree a = Fix (TreeF a)\ndata TreeF a f = Leaf a | Tree a f f deriving (Show)\n\ninstance Functor (TreeF a) where\n  fmap f (Leaf a) = Leaf a\n  fmap f (Tree a b c) = Tree a (f b) (f c)\n\ndepth :: Tree a -> Int\ndepth = cata phi where\n  phi (Leaf _)     = 0\n  phi (Tree _ l r) = 1 + max l r\n\n\nexample1 :: Int\nexample1 = int (plus (nat 125) (nat 25))\n-- 150\n```\n或者，例如，一种依赖于范围词典的小的表达式语言的解释器：\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nimport Control.Applicative\nimport qualified Data.Map as M\n\ntype Algebra f a = f a -> a\ntype Coalgebra f a = a -> f a\n\nnewtype Fix f = Fix { unFix :: f (Fix f) }\n\ncata :: Functor f => Algebra f a -> Fix f -> a\ncata alg = alg . fmap (cata alg) . unFix\n\nana :: Functor f => Coalgebra f a -> a -> Fix f\nana coalg = Fix . fmap (ana coalg) . coalg\n\nhylo :: Functor f => Algebra f b -> Coalgebra f a -> a -> b\nhylo f g = cata f . ana g\n\ntype Id = String\ntype Env = M.Map Id Int\n\ntype Expr = Fix ExprF\ndata ExprF a\n  = Lit Int\n  | Var Id\n  | Add a a\n  | Mul a a\n  deriving (Show, Eq, Ord, Functor)\n\nderiving instance Eq (f (Fix f)) => Eq (Fix f)\nderiving instance Ord (f (Fix f)) => Ord (Fix f)\nderiving instance Show (f (Fix f)) => Show (Fix f)\n\neval :: M.Map Id Int -> Fix ExprF -> Maybe Int\neval env = cata phi where\n  phi ex = case ex of\n    Lit c   -> pure c\n    Var i   -> M.lookup i env\n    Add x y -> liftA2 (+) x y\n    Mul x y -> liftA2 (*) x y\n\nexpr :: Expr\nexpr = Fix (Mul n (Fix (Add x y)))\n  where\n    n = Fix (Lit 10)\n    x = Fix (Var \"x\")\n    y = Fix (Var \"y\")\n\nenv :: M.Map Id Int\nenv = M.fromList [(\"x\", 1), (\"y\", 2)]\n\ncompose :: (f (Fix f) -> c) -> (a -> Fix f) -> a -> c\ncompose x y = x . unFix . y\n\nexample :: Maybe Int\nexample = eval env expr\n-- Just 30\n```\n这种方法特別之處在於`catamorphisms`自然地构成了有效的复合转换。\n```haskell\ncompose :: Functor f => (f (Fix f) -> c) -> (a -> Fix f) -> a -> c\ncompose f g = f . unFix . g\n```\n請看: [Understanding F-Algebras](https://www.fpcomplete.com/user/bartosz/understanding-algebras)\n\n### recursion-schemes(递归方案)\n>这是高级部分，编写Haskell通常不需要。\n\n```haskell\nName\t\t\nCatamorphism\tfoldr :: (a -> b -> b) -> b -> [a] -> b\t    解构数据结构\nAnamorphism\t  unfoldr :: (b -> Maybe (a, b)) -> b -> [a]\t逐级构造结构\n```\n\n```haskell\n-- | A fix-point type.\nnewtype Fix f = Fix { unFix :: f (Fix f) }\n\n-- | Catamorphism or generic function fold.\ncata :: Functor f => (f a -> a) -> (Fix f -> a)\ncata f = f . fmap (cata f) . unFix\n\n-- | Anamorphism or generic function unfold.\nana :: Functor f => (a -> f a) -> (a -> Fix f)\nana f = Fix . fmap (ana f) . f\n```\n上面`F-algebra`示例的代码是在称为`recursion-schemes`的现成库中实现的。\n```haskell\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE DeriveFunctor #-}\n\nimport Data.Functor.Foldable\n\ntype Var = String\n\ndata Exp\n  = Var Var\n  | App Exp Exp\n  | Lam [Var] Exp\n  deriving Show\n\ndata ExpF a\n  = VarF Var\n  | AppF a a\n  | LamF [Var] a\n  deriving Functor\n\ntype instance Base Exp = ExpF\n\ninstance Foldable Exp where\n  project (Var a)     = VarF a\n  project (App a b)   = AppF a b\n  project (Lam a b)   = LamF a b\n\ninstance Unfoldable Exp where\n  embed (VarF a)      = Var a\n  embed (AppF a b)    = App a b\n  embed (LamF a b)    = Lam a b\n\nfvs :: Exp -> [Var]\nfvs = cata phi\n  where phi (VarF a)    = [a]\n        phi (AppF a b)  = a ++ b\n        phi (LamF a b) = foldr (filter . (/=)) a b\n```\n一個使用例子:\n```haskell\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE TypeSynonymInstances #-}\n\nimport Data.Traversable\nimport Control.Monad hiding (forM_, mapM, sequence)\nimport Prelude hiding (mapM)\nimport qualified Data.Map as M\n\nnewtype Fix (f :: * -> *) = Fix { outF :: f (Fix f) }\n\n-- Catamorphism\ncata :: Functor f => (f a -> a) -> Fix f -> a\ncata f = f . fmap (cata f) . outF\n\n-- Monadic catamorphism\ncataM :: (Traversable f, Monad m) => (f a -> m a) -> Fix f -> m a\ncataM f = f <=< mapM (cataM f) . outF\n\ndata ExprF r\n  = EVar String\n  | EApp r r\n  | ELam r r\n  deriving (Show, Eq, Ord, Functor)\n\ntype Expr = Fix ExprF\n\ninstance Show (Fix ExprF) where\n  show (Fix f) = show f\n\ninstance Eq (Fix ExprF) where\n  Fix x == Fix y = x == y\n\ninstance Ord (Fix ExprF) where\n  compare (Fix x) (Fix y) = compare x y\n\n\nmkApp :: Fix ExprF -> Fix ExprF -> Fix ExprF\nmkApp x y = Fix (EApp x y)\n\nmkVar :: String -> Fix ExprF\nmkVar x = Fix (EVar x)\n\nmkLam :: Fix ExprF -> Fix ExprF -> Fix ExprF\nmkLam x y = Fix (ELam x y)\n\ni :: Fix ExprF\ni = mkLam (mkVar \"x\") (mkVar \"x\")\n\nk :: Fix ExprF\nk = mkLam (mkVar \"x\") $ mkLam (mkVar \"y\") $ (mkVar \"x\")\n\nsubst :: M.Map String (ExprF Expr) -> Expr -> Expr\nsubst env = cata alg where\n  alg (EVar x) | Just e <- M.lookup x env = Fix e\n  alg e = Fix e\n```\n請看: [recursion-schemes](http://hackage.haskell.org/package/recursion-schemes)\n\n### Data types à la carte\n>TODO\n\n### Hint and Mueval\n>这是高级部分，编写Haskell通常不需要。\n`GHC`本身实际上可以通过连接到`GHC`的字节码解释器(与`GHCi`相同)来即时解释任意`Haskell`源代碼。\n`hint`包允许我们将任意字符串解析，类型检查和评估，并将其评估为任意的`Haskell`程序。\n```haskell\nimport Language.Haskell.Interpreter\n\nfoo :: Interpreter String\nfoo = eval \"(\\\\x -> x) 1\"\n\nexample :: IO (Either InterpreterError String)\nexample = runInterpreter foo\n```\n除非程序本身的目的是评估任意的`Haskell`代码(例如在线`Haskell shell`等)，否则围绕它构建库通常不是明智的选择。\n`hint`和`mueval`都有效地完成了相同的任务，只是围绕`GHC API`的内部稍有不同而设计。\n\n請看:\n * [hint](http://hackage.haskell.org/package/mueval)\n * [mueval](http://hackage.haskell.org/package/mueval)","tags":["interpreters"]},{"title":"Haskell-GADTs","url":"/blog/2019/10/09/Haskell-GADTs/","content":"> [原文](http://dev.stephendiehl.com/hask/#gadts)\n\n### GADTs\n\n通用代数数据类型(`GADT`)是对代数数据类型的扩展，它使我们可以将构造函数限定为具有类型相等约束的数据类型，\n从而允许使用普通`Vanilla ADT`无法表达的一类类型。\n\n`-XGADTs`隐式地为数据类型声明(`-XGADTSyntax`)启用替代语法，使得以下声明等效:\n```haskell\n-- Vanilla\ndata List a\n  = Empty\n  | Cons a (List a)\n\n-- GADTSyntax\ndata List a where\n  Empty :: List a\n  Cons :: a -> List a -> List a\n```\n\n例如，考慮如下數據類型`Term`，我们有一个`Succ term`，它接收一个由所有类型参数化的`Term`。\n当尝试编写求值程序时，冲突`(a ~ Bool)`或`(a ~ Int)`之间会出现问题。\n```haskell\ndata Term a\n  = Lit a\n  | Succ (Term a)\n  | IsZero (Term a)\n\n-- 不是一個好的類型 :(\neval (Lit i)      = i\neval (Succ t)     = 1 + eval t\neval (IsZero i)   = eval i == 0\n```\n而且我们接收无意义`terms`的构造会导致更多的错误处理案例。\n```haskell\n-- 這是一個有效的類型\nfailure = Succ (Lit True)\n```\n使用`GADT`，我们可以为我们的语言表示类型不变式(即,只有类型安全的表达式才可以表示)。\n然后，此`GADT`上的模式匹配会携带类型相等约束，而无需显式标签。\n```haskell\n{-# Language GADTs #-}\n\ndata Term a where\n  Lit    :: a -> Term a\n  Succ   :: Term Int -> Term Int\n  IsZero :: Term Int -> Term Bool\n  If     :: Term Bool -> Term a -> Term a -> Term a\n\neval :: Term a -> a\neval (Lit i)      = i                                   -- Term a\neval (Succ t)     = 1 + eval t                          -- Term (a ~ Int)\neval (IsZero i)   = eval i == 0                         -- Term (a ~ Int)\neval (If b e1 e2) = if eval b then eval e1 else eval e2 -- Term (a ~ Bool)\n\nexample :: Int\nexample = eval (Succ (Succ (Lit 3)))\n```\n這一次:\n```haskell\n-- 在编译时將被拒绝\nfailure = Succ (Lit True)\n```\n可以将显式相等约束`(a 〜 b)`添加到函数的上下文中。\n例如，以下内容扩展为相同的类型。\n```haskell\nf :: a -> a -> (a, a)\nf :: (a ~ b) => a -> b -> (a,b)\n(Int ~ Int)  => ...\n(a ~ Int)    => ...\n(Int ~ a)    => ...\n(a ~ b)      => ...\n(Int ~ Bool) => ... -- 將不会进行类型检查\n```\n这实际上是`GHC`在幕后为实现`GADT`(隐式传递和穿插相等`terms`)所做的工作的实现细节。\n如果我们愿意，我们可以使用`GHC`进行相同的设置，只是使用`equality constraints`(相等约束)和`existential quantification`(存在量化)。确实，`GADT`的内部表示形式是常规的代数数据类型，以`coercion evidence`(强制性证据)作为参数。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE ExistentialQuantification #-}\n\n-- Using Constraints(約束)\ndata Exp a\n  = (a ~ Int) => LitInt a\n  | (a ~ Bool) => LitBool a\n  | forall b. (b ~ Bool) => If (Exp b) (Exp a) (Exp a)\n\n-- Using GADTs\n-- data Exp a where\n--   LitInt  :: Int  -> Exp Int\n--   LitBool :: Bool -> Exp Bool\n--   If      :: Exp Bool -> Exp a -> Exp a -> Exp a\n\neval :: Exp a -> a\neval e = case e of\n  LitInt i   -> i\n  LitBool b  -> b\n  If b tr fl -> if eval b then eval tr else eval fl\n```\n在存在`GADT`的情况下,推论在许多情况下变得很棘手,通常需要明确的注释.\n例如,`f`可以具有`T a -> [a]`或`T a -> [Int]`,并且都不是主要的。\n```haskell\ndata T :: * -> * where\n  T1 :: Int -> T Int\n  T2 :: T a\n\nf (T1 n) = [n]\nf T2     = []\n```\n\n### Kind Signatures\n`Haskell`的`kind`系统(即:类型的类型)是由`single kind *`和一個`arrow kind ->`组成的系统。\n```Haskell\nκ : *\n  | κ -> κ\n\nInt :: *\nMaybe :: * -> *\nEither :: * -> * -> *\n```\n实际上，此系统有一些扩展将在以后介绍(请参阅后面的部分中的`PolyKinds`和`Unboxed`类型)，但是日常代码中的大多数类型只是星号`*`或箭头`->`。\n\n启用`KindSignatures`扩展后，我们现在可以使用其显式`kinds`(种类)对顶级类型签名进行注释，而无需执行普通的`kind`(种类)推断过程。\n\n```haskell\n{-# LANGUAGE KindSignatures #-}\n\nid :: forall (a :: *). a -> a\nid x = x\n```\n除了默认的`GADT`声明，我们还可以将`GADT`的参数限制为特定`kinds`(种类)。\n对于基本用法，`Haskell`的`kind`(种类)推断可以很好地推断出这一点，但是与其他一些扩展`kind`系统的类型扩展结合起来，这就变得至关重要了。\n```haskell\n{-# Language GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n\ndata Term a :: * where\n  Lit    :: a -> Term a\n  Succ   :: Term Int -> Term Int\n  IsZero :: Term Int -> Term Bool\n  If     :: Term Bool -> Term a -> Term a -> Term a\n\ndata Vec :: * -> * -> * where\n  Nil :: Vec n a\n  Cons :: a -> Vec n a -> Vec n a\n\ndata Fix :: (* -> *) -> * where\n  In :: f (Fix f) -> Fix f\n```\n\n### Void\n`Void`类型是没有居民的类型。它仅与自身`unifies`(結合)。\n使用`newtype`包装器，我们可以创建一种类型，在其中递归使其无法构造`inhabitant`(類型的實例的統稱)。\n```haskell\n-- Void :: Void -> Void\nnewtype Void = Void Void\n```\n或者使用`-XEmptyDataDecls`扩展，我们也可以等效地将`uninhabited`(无人居住)类型构造为没有构造函数的`data`声明。\n```haskell\ndata Void\n```\n这两种类型的唯一`inhabitant`(類型的實例的統稱)是一个类似(`undefined`)的`diverging term`(发散项)。\n\n### Phantom Types(幻影類型)\n`Phantom`类型是出现在类型声明左侧的参数，但不受`inhabitants`(類型的實例的統稱)类型值的限制。\n它们实际上是我们用来在类型级别上编码其他信息的插槽。\n```haskell\nimport Data.Void\n\ndata Foo tag a = Foo a\n\ncombine :: Num a => Foo tag a -> Foo tag a -> Foo tag a\ncombine (Foo a) (Foo b) = Foo (a+b)\n\n-- All identical at the value level, but differ at the type level.\n-- 在值级别上全部相同，但在类型级别上不同。\na :: Foo () Int\na = Foo 1\n\nb :: Foo t Int\nb = Foo 1\n\nc :: Foo Void Int\nc = Foo 1\n\n-- () ~ ()\nexample1 :: Foo () Int\nexample1 = combine a a\n\n-- t ~ ()\nexample2 :: Foo () Int\nexample2 = combine a b\n\n-- t0 ~ t1\nexample3 :: Foo t Int\nexample3 = combine b b\n\n-- 无法将类型't'与'Void'匹配\n-- t不可以保持多態,應該是: example4 :: Foo Void Int\nexample4 :: Foo t Int\nexample4 = combine b c\n```\n请注意，类型变量标记未出现在声明的右侧。使用此方法，我们可以在类型级别表达不需在值级别体现的不变量。\n我们正在通过在类型级别添加额外的信息来有效地进行编程。\n\n考虑使用`newtypes`静态区分纯文本和加密文本的情况:\n```Haskell\nnewtype Plaintext = Plaintext Text\nnewtype Crytpotext = Cryptotext Text\n\nencrypt :: Key -> Plaintext -> Cryptotext\ndecrypt :: Key -> Cryptotext -> Plaintext\n```\n使用幻像类型，我们使用一个额外的参数:\n```haskell\nimport Data.Text\n\ndata Cryptotext\ndata Plaintext\n\ndata Msg a = Msg Text\n\nencrypt :: Msg Plaintext -> Msg Cryptotext\nencrypt = undefined\n\ndecrypt :: Msg Cryptotext -> Msg Plaintext\ndecrypt = undefined\n```\n使用`-XEmptyDataDecls`可以与不包含任何值`inhabitants`(類型的實例的統稱)且为\"匿名类型\"的幻像类型进行有效组合。\n```haskell\n{-# LANGUAGE EmptyDataDecls #-}\n\ndata Token a\n```\n`tagged`库定义了类似的`Tagged`的`newtype`包装器。\n\n請看: [幻影类型的乐趣](http://www.researchgate.net/publication/228707929_Fun_with_phantom_types/file/9c960525654760c169.pdf)\n\n### Typelevel Operations\n>这是高级部分，编写Haskell通常不需要。\n\n使用更丰富的数据类型语言,我们可以表达`witness`(见证)构造函数中`terms`之间关系的`terms`，\n例如,我们现在可以表达一个表示两种类型的`propositional equality`(命题相等)的`term`。\n\n`Eql a b`类型是`a`和`b`类型相等的证明，通过在单个`Refl`构造函数上进行模式匹配，我们将相等约束引入到模式匹配的主体中。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE ExplicitForAll #-}\n\n-- a ≡ b\ndata Eql a b where\n  Refl :: Eql a a\n\n-- Congruence(一致性)\n-- (f : A → B) {x y} → x ≡ y → f x ≡ f y\ncong :: Eql a b -> Eql (f a) (f b)\ncong Refl = Refl\n\n-- Symmetry(對稱性)\n-- {a b : A} → a ≡ b → a ≡ b\nsym :: Eql a b -> Eql b a\nsym Refl = Refl\n\n-- Transitivity(傳遞性)\n-- {a b c : A} → a ≡ b → b ≡ c → a ≡ c\ntrans :: Eql a b -> Eql b c -> Eql a c\ntrans Refl Refl = Refl\n\n-- Coerce one type to another given a proof of their equality.\n-- 强迫一种类型到另一种，以证明他们的平等。\n-- {a b : A} → a ≡ b → a → b\ncastWith :: Eql a b -> a -> b\ncastWith Refl = id\n\n-- Trivial cases 簡單的情況\na :: forall n. Eql n n\na = Refl\n\nb :: forall. Eql () ()\nb = Refl\n```\n从`GHC 7.8`开始，这些构造函数和函数包含在`Data.Type.Equality`模块的`Prelude`中。\n\n","tags":["GADTs"]},{"title":"評估模型","url":"/blog/2019/10/08/評估模型/","content":">類型正確的程序不可以\"出錯\".    — Robin Milner\n>http://dev.stephendiehl.com/fun/005_evaluation.html\n\n### Evaluation(評估)\n尽管`lambda`演算极其简单，但评估和实现lambda表达式的约简的方式却多种多样。\n评估的不同模型是评估策略。\n\n设计空间中存在兩點分歧:严格和非严格评估。\n\n如果在约简`lambda`之前必须先评估`lambda`表达式的参数，则稱评估策略是严格的。\n在`lambda`约简之前不必对参数进行求值的语言是非严格的。\n\n换句话说，`diverging terms`(分歧项)由`bottom`值(表示为`⊥f`)表示相等。\n```haskell\nf ⊥ ≠ ⊥\n```\n\n### 評估模型\n有许多不同的模型及其各种混合形式。我们将考虑三种主要模型：\n\n* `Call-by-value`(按值调用): 在進入函数之前先评估参数\n* `Call-by-name`(按名称调用): 参数传递时未评估\n* `Call-by-need`(按需调用): 参数传递时未评估，但表达式只評估一次，并在后续引用时共享\n\n給定一個表達式: `fx`\n```haskell\n    Call-by-value:\n        1. 評估 xv\n        2. 評估 fλy.e\n        3. 評估 [y/v]e\n\n    Call-by-name:\n        1. 評估 fλy.e\n        2. 評估 [y/x]e\n\n    Call-by-need:\n        1. 分配一個thunk vx\n        2. 評估 fλy.e\n        3. 評估 [y/v]e\n```\n在一个模型中具有正常形式的`terms`(項)在另一个模型中可能具有或不具有正常形式。\n在`call-by-need`和`call-by-name`的评估中，不一定要在進入之前就评估不同的`terms`(項)，因此在这些模型中具有正常形式的某些`term`(項)可能会在`call-by-value`的情况下发生偏离。\n\n#### Call-by-value\n`Call-by-value`是一种非常普遍的评估模型。许多命令式和函数式编程语言都使用此评估策略。\n\n`Call-by-value`的本质是有两类表达式: `terms`(术语/項)和`values`(值)。\n\n`values`是`lambda`表达式和其他形式的普通项，不能进一步简化。函数的所有参数在被绑定到`lambda`内部之前都将被简化为正常形式，并且只有在参数被简化之后才会进行归纳。\n\n对于简单的算术表达式，归纳如下进行。请注意，子表达式`(2 + 2)`在绑定之前是如何评估为正常形式的。\n```haskell\n(\\x. \\y. y x) (2 + 2) (\\x. x + 1)\n=> (\\x. \\y. y x) 4 (\\x. x + 1)\n=> (\\y. y 4) (\\x. x + 1)\n=> (\\x. x + 1) 4\n=> 4 + 1\n=> 5\n```\n当然，对于应用程序有两个评估规则。\n\n![](img/img01.png)\n\n对于简单的小的`λ`演算，按值调用解释器非常简单。`lambda`演算的运行时评估的一部分涉及创建闭包，即将局部变量保存在作用域内的环境。\n用我们的小语言来说，`reduction`(規約)可能会收敛的两个可能的值是`VInt`和`VClosure`。\n```haskell\ndata Expr\n  = Var Int\n  | Lam Expr\n  | App Expr Expr\n  | Lit Int\n  | Prim PrimOp Expr Expr\n  deriving Show\n\ndata PrimOp = Add | Mul\n  deriving Show\n\ndata Value\n  = VInt Int\n  | VClosure Expr Env\n  deriving Show\n\ntype Env = [Value]\n\nemptyEnv :: Env\nemptyEnv = []\n```\n评估函数仅将本地作用域和一個`term`(术语)映射到最终值。每当引用变量时，都会在环境中查找该变量。\n每当输入`lambda`时，它将使用闭包的本地作用域扩展环境。\n```haskell\neval :: Env -> Expr -> Value\neval env term = case term of\n  Var n -> env !! n\n  Lam a -> VClosure a env\n  App a b ->\n    let VClosure c env' = eval env a in\n    let v = eval env b in\n    eval (v : env') c\n\n  Lit n -> VInt n\n  Prim p a b -> (evalPrim p) (eval env a) (eval env b)\n\nevalPrim :: PrimOp -> Value -> Value -> Value\nevalPrim Add (VInt a) (VInt b) = VInt (a + b)\nevalPrim Mul (VInt a) (VInt b) = VInt (a * b)\n```\n\n#### Call-by-name\n在`Call-by-name`评估中，將按原样替换`lambda`表达式的参数，评估仅从左向右进行替换最外面的`lambda`或归约值。如果不使用替换表达式，则永远不会求值。\n![](img/img02.png)\n\n例如，我们看过的`Call-by-value`的相同表达式具有相同的正常形式，但通过不同的归约顺序得出：\n```haskell\n(\\x. \\y. y x) (2 + 2) (\\x. x + 1)\n=> (\\y. y (2 + 2)) (\\x. x + 1)\n=> (\\x. x + 1) (2 + 2)\n=> (2 + 2) + 1\n=> 4 + 1\n=> 5\n```\n尽管很少有语言使用此模型，但`Call-by-name`不是严格的。\n\n#### Call-by-need\n`Call-by-need`是一种特殊类型的非严格评估，其中未评估的表达式由`suspensions`或`thunks`表示，将其传递到未评估的函数中，仅在需要或强制时才对其进行评估。\n\n当强制使用`thunk`时，`thunk`的表示将使用计算值进行更新，并且在进一步引用时不会重新计算。\n\n未评估的`lambda`表达式的`thunk`会在评估时分配，并将所得的计算值放在相同的引用中，以便后续计算共享结果。如果不再需要该参数，则永远不会对其进行计算，这将导致在空间和时间之间进行权衡。\n\n由于子表达式的评估不遵循任何预先定义的顺序，因此带有副作用的任何不纯函数的评估都将以不确定的顺序进行。因此，仅在纯函數设置中才能有效实现`Call-by-need`。\n\n```haskell\ntype Thunk = () -> IO Value\n\ndata Value\n  = VBool Bool\n  | VInt Integer\n  | VClosure (Thunk -> IO Value)\n\nupdate :: IORef Thunk -> Value -> IO ()\nupdate ref v = do\n  writeIORef ref (\\() -> return v)\n  return ()\n\nforce :: IORef Thunk -> IO Value\nforce ref = do\n  th <- readIORef ref\n  v <- th ()\n  update ref v\n  return v\n\nmkThunk :: Env -> String -> Expr -> (Thunk -> IO Value)\nmkThunk env x body = \\a -> do\n  a' <- newIORef a\n  eval ((x, a') : env) body\n\neval :: Env -> Expr -> IO Value\neval env ex = case ex of\n  EVar n -> do\n    th <- lookupEnv env n\n    v <- force th\n    return v\n\n  ELam x e -> return $ VClosure (mkThunk env x e)\n\n  EApp a b -> do\n    VClosure c <- eval env a\n    c (\\() -> eval env b)\n\n  EBool b -> return $ VBool b\n\n  EInt n  -> return $ VInt n\n\n  EFix e  -> eval env (EApp e (EFix e))\n```\n例如，在这个模型中，下面的程序不会`diverge`(发散)，因为传递给常量函数的`omega`组合子没有被使用，因此参数没有被求值。\n```haskell\nomega = (\\x -> x x) (\\x -> x x)\ntest1 = (\\y -> 42) omega\n\nomega :: Expr\nomega = EApp (ELam \"x\" (EApp (EVar \"x\") (EVar \"x\")))\n             (ELam \"x\" (EApp (EVar \"x\") (EVar \"x\")))\n\ntest1 :: IO Value\ntest1 = eval [] $ EApp (ELam \"y\" (EInt 42)) omega\n```\n### Higher Order Abstract Syntax (HOAS)\n`GHC Haskell`是一种丰富的语言，具有多种扩展功能，除其他外，这些功能使我们能够将定义语言中的`lambda`表达式直接映射到`Haskell`中的`lambda`表达式。\n在这种情况下，我们将使用`GADT`在我们的表达式类型中嵌入`Haskell`表达式。\n\n```haskell\n{-# LANGUAGE GADTs #-}\n\ndata Expr a where\n  Lift :: a                       -> Expr a\n  Tup  :: Expr a -> Expr b        -> Expr (a, b)\n  Lam  :: (Expr a -> Expr b)      -> Expr (a -> b)\n  App  :: Expr (a -> b) -> Expr a -> Expr b\n  Fix  :: Expr (a -> a)           -> Expr a\n```\n这种编码最显著的特点是，变量没有獨特的构造函数。相反，它们只是宿主语言中的值。一些示例表达式:\n```haskell\nid :: Expr (a -> a)\nid = Lam (\\x -> x)\n\ntr :: Expr (a -> b -> a)\ntr = Lam (\\x -> (Lam (\\y -> x)))\n\nfl :: Expr (a -> b -> b)\nfl = Lam (\\x -> (Lam (\\y -> y)))\n```\n然后，我们的`evaluator`只需使用`Haskell`进行评估。\n```haskell\neval :: Expr a -> a\neval (Lift v)    = v\neval (Tup e1 e2) = (eval e1, eval e2)\neval (Lam f)     = \\x -> eval (f (Lift x))\neval (App e1 e2) = (eval e1) (eval e2)\neval (Fix f)     = (eval f) (eval (Fix f))\n```\n一些使用的例子:\n```haskell\nfact :: Expr (Integer -> Integer)\nfact =\n  Fix (\n    Lam (\\f ->\n      Lam (\\y ->\n        Lift (\n          if eval y == 0\n          then 1\n          else eval y * (eval f) (eval y - 1)))))\n\ntest :: Integer\ntest = eval fact 10\n\nmain :: IO ()\nmain = print test\n```\n在使用`HOAS`时必须注意几点。首先，转换这种形式的表达式需要做更多的工作，因为为了处理表达式，我们需要到达`Haskell`函数本身的`lambda`绑定下。因为所有的机制都被封装在`Haskell`的实现中，即使是像漂亮的打印和编写转换传递这样的简单操作也会变得更加困难。这种形式是评估的好形式，但不是转换的好形式。\n\n### Parametric Higher Order Abstract Syntax (PHOAS)\n另一种稍微不同的`HOAS`形式称为`PHOAS`，它在存在类型下的绑定类型上使用参数化的`lambda`表示。\n```haskell\n{-# LANGUAGE RankNTypes #-}\n\ndata ExprP a\n  = VarP a\n  | AppP (ExprP a) (ExprP a)\n  | LamP (a -> ExprP a)\n  | LitP Integer\n\nnewtype Expr = Expr { unExpr :: forall a . ExprP a }\n```\n我们语言中的`lambda`只是`Haskell`中的`lambda`。例如，通常的`SK`组合器将编写如下:\n```haskell\n-- i x = x\ni :: ExprP a\ni = LamP (\\a -> VarP a)\n\n-- k x y = x\nk :: ExprP a\nk = LamP (\\x -> LamP (\\y -> VarP x))\n\n-- s f g x = f x (g x)\ns :: ExprP a\ns = \n  LamP (\\f -> \n    LamP (\\g -> \n      LamP (\\x -> \n        AppP \n          (AppP (VarP f) (VarP x))\n          (AppP (VarP g) (VarP x))\n        )))\n```\n评估将产生运行时`Value`类型，就像我们的外部解释器一样。\n我们将使用几个`extractor`函数，这些函数在後台使用不完整的模式。\n该模型本身并不能防止格式错误的程序在这里爆炸，因此有必要在评估之前确保程序是正确的。 通常，在达到这一点之前，`typechecker`(类型检查器)会在更高级别上保证这一点。\n```haskell\ndata Value\n  = VLit Integer\n  | VFun (Value -> Value)\n\nfromVFun :: Value -> (Value -> Value)\nfromVFun val = case val of\n  VFun f -> f\n  _      -> error \"not a function\"\n\nfromVLit :: Value -> Integer\nfromVLit val = case val of\n  VLit n -> n\n  _      -> error \"not an integer\"\n```\n评估只是利用了一个事实，即利用了我們存在类型下的`Haskell`函数，因此我们免费获得所有名称捕获，闭包和绑定机制。`PHOAS`模型的评估逻辑非常短。\n```haskell\neval :: Expr -> Value\neval e = ev (unExpr e) where\n  ev (LamP f)      = VFun(ev . f)\n  ev (VarP v)      = v\n  ev (AppP e1 e2)  = fromVFun (ev e1) (ev e2)\n  ev (LitP n)      = VLit n\n```\n再次考虑`S K K = I`示例，并检查结果:\n```haskell\nskk :: ExprP a\nskk = AppP (AppP s k) k\n\nexample :: Integer\nexample = fromVLit $ eval $ Expr (AppP skk (LitP 3))\n```\n我们将广泛地使用这种评估技术来为我们更大的语言编写翻译。这是在`Haskell`中编写解释器非常方便和有用的方法。\n\n### Embedding IO\n如前所述，`effects`是`Haskell`中的一流值。\n\n在`Haskell`中，我们不直接读取文件，而是创建一个表示读取文件的值。通过在我们的语言的基本操作与`Haskell`中标准操作的现有函数实现之间建立映射，并使用`monadic`操作建立纯有效的计算结果，我们可以在`Haskell`中为我们的语言的解释程序建立非常清晰的模型的解释。经过评估，我们最终将得到的`IO`值提升到`Haskell`中并执行结果。这与`PHOAS`模型非常吻合，并且使我们能够简单地利用`Haskell`的实现，以非常少的代码有效地为我们的语言实现完整的解释器。\n\n要将`IO`操作嵌入我们的解释器中，我们创建了一个独特的`VEffect`值，该值将在评估过程中建立顺序`IO`计算。该值将传递给`Haskell`，并具体化为现实世界的`effects`。\n```haskell\ndata ExprP a\n  = VarP a\n  | GlobalP Name\n  | AppP (ExprP a) (ExprP a)\n  | LamP (a -> ExprP a)\n  | LitP Char\n  | EffectP a\n\ndata Value\n  = VChar Char\n  | VFun (Value -> Value)\n  | VEffect (IO Value)\n  | VUnit\n\nfromVEff :: Value -> (IO Value)\nfromVEff val = case val of\n  VEffect f -> f\n  _         -> error \"not an effect\"\neval :: Expr -> Value\neval e = ev (unExpr e) where\n  ev (LamP f)      = VFun(ev . f)\n  ev (AppP e1 e2)  = fromVFun (ev e1) (ev e2)\n  ev (LitP n)      = VChar n\n  ev (EffectP v)   = v\n  ev (VarP v)      = v\n  ev (GlobalP op)  = prim op\n\n-- Lift an effect from our language into Haskell IO.\nrun :: Expr -> IO ()\nrun f = void (fromVEff (eval f))\n```\n`prim`函数将仅对一组内置操作执行查找，我们将使用一些语法糖来定义这些操作，以包装`Haskell`函数。\n```haskell\nunary :: (Value -> Value) -> Value\nunary f = lam $ \\a -> f a\n\nbinary :: (Value -> Value -> Value) -> Value\nbinary f = lam $ \\a ->\n           lam $ \\b -> f a b\n\nprim :: Name -> Value\nprim op = case op of\n \"putChar#\" -> unary $ \\x ->\n    VEffect $ do\n      putChar (fromVChar x)\n      return VUnit\n\n \"getChar#\" -> VEffect $ do\n      val <- getChar\n      return (VChar val)\n\n \"bindIO#\"   -> binary $ \\x y -> bindIO x y\n \"returnIO#\" -> unary  $ \\x   -> returnIO x\n \"thenIO#\"   -> binary $ \\x y -> thenIO x y\n```\n例如，我们语言中的`thenIO＃`序列`effects`(效果)将简单地将两个`VEffect`对象压缩为一个复合`effects`，从而建立一个新的`VEffect`值，该值在內部`IO`值上使用`Haskell`的`monadic`序列.\n```haskell\nbindIO :: Value -> Value -> Value\nbindIO (VEffect f) (VFun g) = VEffect (f >>= fromVEff . g)\n\nthenIO :: Value -> Value -> Value\nthenIO (VEffect f) (VEffect g) = VEffect (f >> g)\n\nreturnIO :: Value -> Value\nreturnIO a = VEffect $ return a\n```\n实际上，我们只是重新创建了与`Haskell IO`及其运行时相同的概念关系，但是，我们的宿主语言使用`Haskell`作为运行时.","tags":["Evaluation"]},{"title":"类型系統","url":"/blog/2019/09/29/类型系統/","content":"> [A type system is a] tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute.  — Benjamin Pierce\n> http://dev.stephendiehl.com/fun/004_type_systems.html\n\n类型系统是一种形式语言，我们可以在其中描述和限制编程语言的语义。该主题的研究是一个丰富而开放的研究领域，在设计空间中具有许多自由度。\n如引言中所述，这是一个非常大的主题，我们将仅涵盖足够多的主题以完成针对我们语言的类型检查器的编写，而不是针对该主题的全面性。\n每个人都阅读的经典文章是`Types and Programming Languages`或`TAPL`，并更深入地讨论了该主题。实际上，我们将以`Haskell`的风格非常紧密地遵循`TAPL`。\n\n\n### Rules\n在编程语言语义的研究中，逻辑语句是用特定的逻辑符号编写的。对于我们的目的，`property`(属性)是关于术语类型的事实。它的写法如下:\n```\n1:𝙽𝚊𝚝\n```\n这些事实存在于被称为类型系统的预设话语范围之内，类型系统具有定义，属性，约定以及关于类型和术语的逻辑推论规则。 在给定的系统中，我们将具有关于这些术语的几个属性。 例如:\n* **(A1)** `0`是一個自然數\n* **(A2)** 對於一個自然數`n`, `𝚜𝚞𝚌𝚌(n)`也是一個自然數.\n\n给定自然数的几个属性，我们将使用一种表示法，将其链接在一起以形成有关系统中任意项的证明。\n![](img/img01.png)\n\n在这种表示法中，该行上方的表达式称为先例，而该行下方的表达式称为结论。没有先例的规则是一个公理。\n\n变量`n`是代表任何自然数的元变量，规则实例是这些元变量的值替换。\n`derivation`(推导)是有限深度规则的树。我们写`⊢ C`表示存在一个推论，其结论为`C`，证明`C`是可证明的。\n\n例如`⊢ 2: 𝙽𝚊𝚝`的推导:\n\n![](img/img02.png)\n\n这些推导中还可能存在类型上下文或被寫作`Γ`的类型環境。\n上下文是一系列命名变量映射到关于命名变量的属性。\n上下文的逗号运算符通过在现有集合的右侧添加新`property`(属性)来扩展`Γ`。\n空上下文用`∅`表示，是该属性链中不包含任何信息的终端元素。\n因此，上下文定义为：\n![](img/img03.png)\n\n这是使用上下文进行加法的类型规则的示例:\n![](img/img04.png)\n\n在这种情况下，无论上下文如何，`property`(属性)总是隐含的，我们将缩短表达式。这只是一个词汇约定。\n![](img/img05.png)\n\n### Type Safety(类型安全)\n在使用这种逻辑符号对编程语言的语义进行建模的上下文中，我们经常提到语义规则的两个基本規則。\n* **Statics(静态)**: 从语言语法中派生出来的语义描述。\n* **Dynamics(动态)**: 描述由程序产生的值演化的语义描述。\n\n类型安全性定义为语言的静态和动态之间的等效性。这种等效性由两个与类型和评估语义相关的属性来建模:\n\n* **Progress**: 如果表达式的类型正确，则要么是一个值，要么可以通过可用的评估规则对其进行进一步评估。\n* **Preservation**: 如果表达式`e`的类型为`τ`，并且被评估为`e'`，则`e'`的类型为`τ`。\n\n### Types\n`type`(类型)一词在常见的编程词典中经常被重载。其他语言通常将在动态语言中出现的运行时标签称为类型。一些例子：\n```Haskell\n# Python\n>>> type(1)\n<type 'int'>\n\n# Javascript\n> typeof(1)\n'number'\n\n# Ruby\nirb(main):001:0> 1.class\n=> Fixnum\n\n# Julia\njulia> typeof(1)\nInt64\n\n# Clojure\nuser=> (type 1)\njava.lang.Long\n```\n虽然这是一个完全可以接受的替代定义，但我们不会走这条路线，而只会将自己纯粹局限于静态类型的讨论，换句话说，就是在运行时之前已知的类型。根据这组定义，许多所谓的动态类型语言通常仅具有单个静态类型。\n例如，在`Python`中，所有静态类型都包含在`PyObject`中，并且只有在运行时才区分出标签`PyTypeObject * ob_type`，以产生`type`的`Python`概念。\n同样，这不是我们将要讨论的类型。这些语言之间的权衡是，它们通常具有琐碎的静态语义，而语言的动态性却往往极其复杂。`Haskell`和`OCaml`之类的语言是此设计领域的对立面。\n类型通常会写成`τ`，并且可以包含许多不同的构造，以至于类型语言可能变得与`value`(值)级别语言一样丰富。\n\n现在，我们仅考虑三种简单类型，两种`ground`类型(`𝙽𝚊𝚝`和`𝙱𝚘𝚘𝚕`)和一种`arrow`(箭头)类型:\n\n![](img/img06.png)\n\n`arrow`(箭头0类型将是函数表达式的类型，左参数是输入类型，右参数是输出类型。按照惯例，`arrow`类型将关联到右侧:\n\n![](img/img07.png)\n\n在我们将实现的所有语言中，编译期间出现的类型都将被擦除。虽然类型可能出现在计算语义中，但是`runtime`运行时不能在运行时对值的类型进行分派。\n根据定义，类型仅在编译时存在于该语言的静态语义中。\n\n### Small-Step Semantics\n我们真正感兴趣的正式描述是编程语言中的表达式。编程语言语义由该语言的操作语义描述。操作语义可以看作是对抽象机器的描述，抽象机器按照编程语言的抽象术语进行操作，就像虚拟机按照指令进行操作一样。\n我们使用了一个名为\"小步骤语义\"的框架，在这个框架中，派生过程展示了如何重写组合以生成一个`term`(术语)，我们可以通过一系列状态更改将该术语计算为一个值。\n这是一个框架，通过描述可能的`transitions`(过渡)类型和`terms`可能占用的空间，在运行程序之前对程序运行时行为的各个方面进行建模。\n我们希望`term`能够过渡并终止为我们语言中的一個值，而不是像我们之前遇到的那样被\"卡住\"。\n在构造第一个解析器之前，请回顾一下我们的小计算器语言:\n```Haskell\ndata Expr\n  = Tr\n  | Fl\n  | IsZero Expr\n  | Succ Expr\n  | Pred Expr\n  | If Expr Expr Expr\n  | Zero\n```\n表达式语法如下:\n\n![](img/img08.png)\n\n这种小语言的小步评估语义由以下9条规则唯一定义。\n`They describe each step that an expression may take during evaluation which may or may not terminate and converge on a value.`(它们描述了表达式在评估过程中可能采取的可能终止或收敛于某个值的每个步骤。)\n\n![](img/img09.png)\n\n我们的解释器的评估逻辑只是通过预定义的评估规则来简化表达式，直到表达式达到标准形式(一個值)或陷入困境为止。\n```Haskell\nnf :: Expr -> Expr\nnf t = fromMaybe t (nf <$> eval1 t)\n\neval :: Expr -> Maybe Expr\neval t = case isVal (nf t) of\n  True  -> Just (nf t)\n  False -> Nothing -- term is \"stuck\"\n```\n我们语言中的值定义: 文字数或布尔值.\n```Haskell\nisVal :: Expr -> Bool\nisVal Tr = True\nisVal Fl = True\nisVal t | isNum t = True\nisVal _ = False\n```\n以`applicative`形式编写的评估规则与我们的评估逻辑之间存在明显的对应关系。\n```Haskell\n-- Evaluate a single step.\neval1 :: Expr -> Maybe Expr\neval1 expr = case expr of\n  Succ t                    -> Succ <$> (eval1 t)\n  Pred Zero                 -> Just Zero\n  Pred (Succ t) | isNum t   -> Just t\n  Pred t                    -> Pred <$> (eval1 t)\n  IsZero Zero               -> Just Tr\n  IsZero (Succ t) | isNum t -> Just Fl\n  IsZero t                  -> IsZero <$> (eval1 t)\n  If Tr  c _                -> Just c\n  If Fl _ a                 -> Just a\n  If t c a                  -> (\\t' -> If t' c a) <$> eval1 t\n  _                         -> Nothing\n```\n正如我们之前所注意到的，我们可以构造出各种病态的表达方式，这些表达方式会被卡住。\n查看计算规则，每一个受保护的模式匹配都提示我们，当布尔值用于数字的位置时，哪里可能\"出错\"，反之亦然。\n我们希望在编译时静态地强制执行这个不变量，因此我们将引入一个小型类型系统来处理现有术语的两种语法类别。除了箭头类型，我们还添加了自然数的抽象类型和布尔值的类型:\n![](img/img10.png)\n\n在Haskell中实现为以下数据类型:\n```Haskell\ndata Type\n  = TBool\n  | TNat\n  | TArr Type Type\n```\n現在的类型規則:\n![](img/img11.png)\n\n这些规则限制了所有可能程序的空间。\n\n这是一个更复杂的展示，但这一制度也有`progress`(进步)和`preservation`(保存)。如果一个`term`(术语)现在是类型良好的，那么它将始终计算为一个值，并且在计算时不会\"出错\"。\n为了检查表达式的格式是否良好，我们实现了一段称为类型检查器的逻辑，它确定`term`是否具有定义良好的类型(根据类型规则)，如果有，则返回该类型，如果没有，则返回失败(除非没有)。\n```Haskell\ntype Check a = Except TypeError a\n\ndata TypeError\n  = TypeMismatch Type Type\n\ncheck :: Expr -> Either TypeError Type\ncheck = runExcept . typeof\ntypeof :: Expr -> Check Type\ntypeof expr = case expr of\n  Succ a -> do\n    ta <- typeof a\n    case ta of\n      TNat -> return TNat\n      _    -> throwError $ TypeMismatch ta TNat\n\n  Pred a -> do\n    ta <- typeof a\n    case ta of\n      TNat -> return TNat\n      _    -> throwError $ TypeMismatch ta TNat\n\n  IsZero a -> do\n    ta <- typeof a\n    case ta of\n      TNat -> return TBool\n      _    -> throwError $ TypeMismatch ta TNat\n\n  If a b c -> do\n    ta <- typeof a\n    tb <- typeof b\n    tc <- typeof c\n    if ta /= TBool\n    then throwError $ TypeMismatch ta TBool\n    else\n      if tb /= tc\n      then throwError $ TypeMismatch ta tb\n      else return tc\n\n  Tr   -> return TBool\n  Fl   -> return TBool\n  Zero -> return TNat\n```\n\n\n### Observations\n我们以前在無類型语言中遇到的病态术语现在完全没有表达能力，并且在编译时被拒绝。\n```Haskell\nArith> succ 0\nsucc 0 : Nat\n\nArith> succ (succ 0)\nsucc (succ 0) : Nat\n\nArith> if false then true else false\nfalse : Bool\n\nArith> iszero (pred (succ (succ 0)))\nfalse : Bool\n\nArith> pred (succ 0)\n0 : Nat\n\nArith> iszero false\nType Mismatch: Bool is not Nat\n\nArith> if 0 then true else false\nType Mismatch: Nat is not Bool\n```\n很好，我们已经使整个非法程序类都无法表示。让我们做更多的事情！\n\n### Simply Typed Lambda Calculus\n\n`Church`和`Curry`的`simply typed lambda calculus(STLC)`是`lambda`演算的扩展，该演算用类型项注释每个`lambda`绑定器。`STLC`是明确类型化的，所有类型都直接出现在绑定器上，要确定范围内任何变量的类型，我们只需要遍历其`enclosing`包围范围即可。\n\n![](img/img12.png)\n\n最简单的`STLC`语言是这三个`terms`(术语)，但是，我们将添加数字和布尔文字项，以便我们编写有意义的示例。\n\n![](img/img13.png)\n\n我们可以為我們的語言考虑一种非常简单的类型系统，它由`Int`和`Bool`类型以及`function`类型组成。\n\n![](img/img14.png)\n\n\n### Type Checker\n类型规则非常简单，并且我们再次获得了不错的属性，即每个语法术语与类型规则之间存在一对一的映射。\n\n* **T-Var**: 变量只是从上下文中提取。\n* **T-Lam**: 在推断主体时`lambdas`将类型化变量引入到环境中。\n* **T-App**: 将类型为`t1 -> t2`的`lambda`应用于类型为`t1`的值将产生类型为`t2`的值。\n\n![](img/img15.png)\n\n评估规则描述了值在其他值之间转换的本质，并确定了程序的运行时行为。\n\n![](img/img16.png)\n\n由于我们现在有了`lambda`范围变量的概念，因此我们将在类型规则中实现一个以`Γ`形式表示的类型环境`Env`。\n```Haskell\ntype Env = [(Name, Type)]\n\nextend :: (Name, Type) -> Env -> Env\nextend xt env = xt : env\n\ninEnv :: (Name, Type) -> Check a -> Check a\ninEnv (x,t) = local (extend (x,t))\n\nlookupVar :: Name -> Check Type\nlookupVar x = do\n  env <- ask\n  case lookup x env of\n    Just e  -> return e\n    Nothing -> throwError $ NotInScope x\n```\n\n类型检查器将是`ExceptT + Reader monad`的转换器，其中读取器将保持类型环境。\n简单类型的`lambda`演算类型检查器有三种可能的故障模式:\n* 我们尝试`unify`(统一)两种不同类型。\n* 我们尝试对参数应用非函数。\n* 引用变量不在范围内。\n```Haskell\ndata TypeError\n  = Mismatch Type Type\n  | NotFunction Type\n  | NotInScope Name\n\ntype Check = ExceptT TypeError (Reader Env)\n```\n这里的语法模式与其等效的类型判断之间存在直接等价关系。通常，情况并非总是如此。类型检查器的实现如下：\n```Haskell\ncheck :: Expr -> Check Type\ncheck expr = case expr of\n\n  Lit (LInt{}) -> return TInt\n\n  Lit (LBool{}) -> return TBool\n\n  Lam x t e -> do\n    rhs <- inEnv (x,t) (check e)\n    return (TArr t rhs)\n\n  App e1 e2 -> do\n    t1 <- check e1\n    t2 <- check e2\n    case t1 of\n       (TArr a b) | a == t2 -> return b\n                  | otherwise -> throwError $ Mismatch t2 a\n       ty -> throwError $ NotFunction ty\n\n  Var x -> lookupVar x\n```\n\n### Evaluation(評估)\n从根本上说，类型化`lambda`演算的计算与非类型化`lambda`演算没有什么不同，也不可能有什么不同，因为类型的语法添加纯粹是一个静态构造，根据定义，在运行时不能有任何表现。\n唯一的區別是: 简单类型的`lambda`演算所接受的程序比非类型的`lambda`演算所允许的程序少得多(即类型化的更严格)。\n静态类型化语言的编译的基本思想是，可以通过擦除类型信息但保留类型化程序的评估语义，将类型化程序转换为未类型化程序。如果我们的程序具有类型安全性，则它永远不会在运行时\"出错\"。\n当然反过来是不正确的，没有\"出错\"的程序不一定是类型正确的，尽管我们是否可以证明一个不良类型的程序是否不会出错是一个正交的问题。我们作为静态类型语言实现者的游戏基本上是一种限制：我们會占据所有程序的空间，并在我们愿意考虑的程序讨论范围内划出一条大界限，因为這些是我们唯一可以证明其属性的程序。\n> 类型正确的程序不会出错，但是，并非每个不会出错的程序都类型正确。 展示不会出错但在任何可判定类型系统中类型错误的程序很容易。许多这样的程序很有用，这就是为什么像Erlang和Lisp这样的动态类型语言很受欢迎的原因。 -- Simon Peyton Jones\n\n权利总是有代价的。使用一个系统，您可以做更多的事情。在另一种方法中，您可以更多地谈论程序可以做的事情。语言设计学科的基础艺术是平衡两者，以找到正确的功率重量比。\n\n### Observations\n嘗試一些簡單的例子:\n```Haskell\nStlc> (\\x : Int . \\y : Int . y) 1 2\n2\n\nStlc> (\\x : (Int -> Int). x) (\\x : Int . 1) 2\n1\n\nStlc> (\\x : Int . x) False\nCouldn't match expected type 'Int' with actual type: 'Bool'\nStlc> 1 2\nTried to apply to non-function type: Int\n\nStlc> (\\x : Int . (\\y : Int . x))\n<<closure>>\n```\n\n### Notation Reference(符号參考)\n此处介绍的符号将在`Haskell`编译器的整个构建过程中使用。作为参考，这里列出了我们将使用的每种符号约定。其中一些术语尚未引入。\n![](img/img17.png)","tags":["类型系統"]},{"title":"Lambda演算","url":"/blog/2019/09/28/Lambda演算/","content":"> 語言是人類理性的工具，而不僅僅是表達思想的媒介，這是公認的真理。 — George Boole\n> http://dev.stephendiehl.com/fun/003_lambda_calculus.html\n\n## Lambda演算\n所有函數式語言的基礎都是原子的組合概念，即單個變量的函數抽象。`Lambda`演算非常簡單的由三個項及其所有有效的遞歸組合組成。\n![](img/img01.png)\n\n這個緊湊的符號看起來與您在`Haskell`中使用的符號略有不同，但實際上沒有: `λx.xa`等同於`\\x -> x a`。這意味著您在上圖中看到的內容將轉換為`(\\x -> x) (\\y -> y)`，這等同於`id id`（當然，其結果為`id`）。\n\n這三個術語通常在代碼中通過它們名稱的幾個縮寫來表示:\n* **Var** - 標識一個變量\n* **Lam** - 標識一個lambda抽象\n* **App** - 標識一個應用\n\n一個lambda項被稱為綁定它的變量。例如這裏的`lambda`綁定`x`，在數學中我們通常會這麼寫:\n```haskell\nf(x) = e\n```\n\n使用lambda演算符號，我們寫為:\n```haskell\nf = λx.e\n```\n換句話説，`λx.e`是一個接收變量`x`，返回`e`的函數.\n```haskell\ne := x      (Var)\n     λx.e   (Lam)\n     e e    (App)\n```\n`lambda`演算通常被稱為函數式編程的\"匯編語言\"，它的變體和擴展構成了許多函數編譯器中間形式的基礎，這些中間形式適用於`Haskell/Ocaml/StandardML`等語言。\n\n我們首先討論的變體稱為`無類型的Lambda演算`，相比之下，稍後我們將討論`類型化的Lambda演算`，它是其擴展。\n\n編寫`Lambda`表達式時，我們將採用機種語法約定。多個表達式的`App`執行左關聯:\n```haskell\nx1 x2 x3 ...Xn = (...((x1x2)x3)...Xn)\n```\n按照慣例，`App`在語法上盡可能向右擴展，括號用於消除歧異。\n\n在`Lambda`演算中，每個`Lambda`抽象綁定一個變量，而`lambda`抽象的主體可能是另一個`lambda`抽象，為了方便，我們經常在一個符號上寫多個`lambda`抽象及其變量。這只是一種語法約定，並不會改變其基本含義。\n```haskell\nλxy.z = λx.λy.z\n```\n`lambda`演算的實際實現允許在表示`lambda`抽象方面有幾個自由度。\n最值得注意的是為綁定變量選擇標識符。\n\n如果一個變量包含在同一個變量綁定的`lambda`表達式中，則稱該變量`bound`(範圍內的)。相反，如果變量沒有`bound`(不在範圍內)，則稱它是`free`(自由)的。\n有`free`變量的項稱為`open term`(開項)，而沒有`free`變量的項稱為`closed`(閉項)或`combinator`(組合子)。\n\n![](img/img02.png)\n\n`e0`是一個`combinator`，而`e1`不是。\n在`e1`中出現的兩次`x`，都是`bound`的，第一個`y`也是`bound`的，而第二個`y`是`free`的。`a`也是`free`的。\n\n多個`lambda`抽象可以綁定相同的變量名稱，然後，每次出現的變量都由最近的`enclosing binder`(封閉綁定器)來`bound`(限定它的範圍)。\n例如: 以下表達式中的`x`變量`bound`(限定)在內部的`lambda`上，而`y`變量`bound`(限定)在外部`lambda`上。這種現象稱為`name shadowing`(名稱陰影)。\n```haskell\nλxy.(λxz.x + y)\n```\n\n### SKI Combinators\n有三個基本的`closed`表達式，稱為`SKI`組合器。\n![](img/img03.png)\n\n在`Haskell`中，它們被寫做:\n```haskell\ns f g x = f x (g x)\nk x y = x\ni x = x\n```\n相當引人注目的`Moses Schonfinkel`表明: 所有的`closed lambda`表達式都可以僅用`S`和`K`組合子表示(甚至是`I`組合子)。\n例如，我們可以很容易的證明`SKK`可以簡化為`I`.\n![](img/img04.png)\n\n在测试`lambda`演算的实现时，这是一个有用的完整性检查。\n\n### Implementation(實現)\n具有命名綁定的`lambda`演算語法 最簡單的實現是使用以下定義:\n```haskell\ntype Name = String\n\ndata Expr\n  = Var Name\n  | App Expr Expr\n  | Lam Name Expr\n```\n\n`lambda`表達式有機種詞法語法選擇，我們將簡單的選擇`Haskell`約定, 它以反斜槓(`\\`)到具有(`->`)的主體表示`lambda`，并以空格表示`App`。命名變量只是字母數字字符序列。\n\n* ***Logical notation***: `𝚌𝚘𝚗𝚜𝚝 = λxy.x`\n* ***Haskell notation***: `const = \\x y -> x`\n\n此外，可以添加其他術語，如文字數字或布爾值，這使編寫說明性示例更加容易，對於這些，我們將添加一個`Lit`構造函數。\n\n```haskell\ndata Expr\n  = ...\n  | Lit Lit\n\ndata Lit\n  = LInt Int\n  | LBool Bool\n```\n\n### Substitution(替換)\n`lambda`項`(((xx.e)a))`的評估通過用參數`a`替換`e`中所有自由出現的變量`x`來進行。\n一個單個的替換步驟被稱為`reduction`(減少/約簡)。\n\n我們將替換`application`放在要應用的表達式之前的方括號中，\n`[x/a]e`将变量`x`映射到表达式`e`上的新替换`a`。\n```haskell\n(λx.e)a → [x/a]e\n```\n一個替換元變量被寫作`[s]`.\n詳細的替換定義如下:\n![](img/img05.png)\n\n`fv(e)`是`e`中的自由變量集.\n\n使用本地命名的綁定器的根本問題是名稱捕獲的問題，或者如何處理替換與自由變量的名稱衝突的情況。我們需要在最後一種情況下使用該條件，以避免將`y`重寫為`x`時會從根本上改變以下表達式含義的幼稚替換。\n```haskell\n[y/x](λx.xy) → λx.xx\n```\n按照慣例，我們總是使用`capture-avoiding`(避免捕獲)替換，只有當變量不在表達式的自由變量集合中時，替換才會繼續進行，如果變量不在表達式的自由變量集合中，則會在其位置上創建一個新的變量。\n```haskell\n(λx.e)a → [x/a]e   if x ∉ 𝚏𝚟(a)\n```\n有幾個綁定庫和`lambda`演算語法的替代實現可以避免這些問題，這是一個非常常見的問題，即使是專家也很容易執行錯誤。\n```haskell\n### free occurance demo\n(λx. x) y  =  y\n(λx. f x x) y  =  f y y\n(λx. f x x) (g y)  =  f (g y) (g y)\n\n(λx. λz. f x z) (g y)  =  λz. f (g y) z\n\n(λx. λz. f (λx. g x) z) (g y)  =  λz. f (λx. g x) z\n\n### 这是一个更棘手的示例\n### 在执行(避免捕获)替换之前，需要alpha转换(绑定变量的重命名)\n### 答案λz. f (λy. f (g y) y) (g y)是錯誤的\n### 因為λy. f ..y..中的y和g y中的y不是一個相同的的y)\n(λx. λz. f (λy. f x y) x) (g y)  =  (λx. λz. f (λt. f x t) x) (g y)  =  λz. f (λt. f (g y) t) (g y)\n```\n\n### Conversion and Equivalences(轉換和相等關係)\n\n#### Alpha(α)等價\n\n![](img/img06.png)\n\nAlpha等价是一种属性（当使用命名的活页夹时），更改活页夹上以及整个表达式主体中的变量不应更改整个表达式的基本含义。 因此，例如，以下是等效的字母。\n`Alpha`等價是一種屬性(當使用`named binders`命名綁定器時),更改綁定器上以及整個表達式主體中的變量不應該更個整個表達式的基本含義，因此，如下是`Alpha`等價:\n\n![](img/img07.png)\n\n##### Beta-reduction歸約(β)\n\n`Beta`歸約僅是一個簡單的替換步驟，即在整個表達式主體中用`lambda`的參數替換由`lambda`表達式綁定的變量。\n\n![](img/img08.png)\n\n\n#### Eta-reduction歸約(η)\n\n![](img/img09.png)\n\n這可以通過如下事實證明，如果我們把兩邊都應用到一個`term`(項)上,一個`Beta`歸約的步驟會把左邊變成右邊。\n\n![](img/img10.png)\n\n\n#### Eta-expansion(展開)\n\n與`Eta-reduction`相反的是`eta-expansion`,它採用一個不飽和的函數並使所有變量顯式綁定在`lambda`中，當我們討論翻譯成`STG`時，`Eta-expansion`將會很重要。\n\n### Reduction\n`λ`演算表達式的評估通過`Beta-reduction`進行。`lambda`中綁定的變量將在`lambda`的主體中替換。\n\n在設計空間中，關於如何做到這一點，以及表達式的計算順序，有幾個自由度。\n例如，我們可以在`lambda`下求值，然後將變量代入其中，或者取而代之的是對參數求值，然後替換並減少`lambda`表達式。\n有關更多信息，我們將在評估模型部分中進行討論。\n```haskell\nUntyped> (\\x.x) 1\n1\n\nUntyped> (\\x y . y) 1 2\n2\n\nUntyped> (\\x y z. x z (y z)) (\\x y . x) (\\x y . x)\n  => \\x y z . (x z (y z))\n  => \\y z . ((\\x y . x) z (y z))\n    => \\x y . x\n    => \\y . z\n   => z\n => \\z . z\n\\z . z\n```\n請注意，最後一次評估是我們先前遇到的`SKK`。\n\n在無類型的`lambda`演算中，我們可以自由的表示無限發散的表達式:\n```haskell\nUntyped> \\f . (f (\\x . (f x x)) (\\x . (f x x)))\n\\f . (f (\\x . (f x x)) (\\x . (f x x)))\n\nUntyped> (\\f . (\\x. (f x x)) (\\x. (f x x))) (\\f x . f f)\n...\n\nUntyped> (\\x. x x) (\\x. x x)\n...\n```\n### Let\n除了`App`以外，通常將稱為`Let`綁定的構造器添加到`lambda`演算語法中。在無類型的`lambda`演算中，`let`綁定在語義上等同於應用的`lambda`表達式。\n```haskell\n𝚕𝚎𝚝 a = e 𝚒𝚗 b   :=   (λa.b)e\n```\n在我們的語言中，我們將像在`Haskell`中一樣編寫`let`語句。\n`Toplevel`表達式將被編寫為`let`語句，沒有一個主體來表示它們被添加到全局範圍。\n`Haskell`語言不使用這個約定，但是`Ocaml`和`StandardML`使用這個約定。在`Haskell`中，对于`toplevel`声明，前面的`let`被简单地省略。\n```haskell\nlet S f g x = f x (g x);\nlet K x y = x;\nlet I x = x;\n\nlet skk = S K K;\n```\n目前，`let`的評估規則與所應用的`lambda`相同.\n![](img/img11.png)\n在後來的`lambda`演算變體中，表達式將具有不同的語義，並且將於應用的`lambda`表達式不同。關於這一點的更多信息將在`Hindley-Milner`推理部分中進行討論。\n\n### Everything Can Be a λ term(一切都可以成为λ项)\n**0**\n\n**1**\n\n**2**\n\n**succ**\n\n**pred**\n\n**not**\n\n**and**\n\n**or**\n\n**add**\n\n**mul**\n\n### Recursion(遞歸)\n可能最著名的組合器是`Curry`的`Y`組合器，在無類型的`λ`演算中，`Y`可用於允許表達式包含對自身的引用，以及`reduce`(歸約/減少)對自身的引用，從而允許遞歸和循環邏輯。\n`Y`組合器是許多所謂的定點組合器之一。\n![](img/img12.png)\n\n`Y`在給定`R`的情況下非常特殊，它返回`R`的固定點。\n\n![](img/img13.png)\n\n例如，階乘函數可以根據自身對定點的重複應用來遞歸定義，直到基本情況為0!。\n\n![](img/img14.png)\n\n處於樂趣，可以證明`Y`組合器可以用`S`和`K`組合器來表示。\n![](img/img15.png)\n\n在沒有顯式定點或遞歸`let`綁定的無類型`lambda`演算語言中，`Y`組合器可以僅使用`lambda`表達式創建這兩個結構。\n但是，更常見的是在術語語法中僅添加原子定點運算符或遞歸`let`作為基本構造。\n![](img/img16.png)\n\n`fix`具有評估規則:\n\n![](img/img17.png)\n\n與`fixpoint`(定點)(或`Y`組合器)一起，我們可以創建`let`綁定，這些綁定在綁定表達式的主體內包含對自身的引用。我們將這些遞歸`let`綁定稱為`ML`方言中的`let rec`.\n目前，我們將實現遞歸`let`作為簡單的語法糖，並通過以下等效性將定點包裹在`lambda`綁定周圍。\n```haskell\nlet rec x = e1 in e2    =    let x = fix (\\x. e1) in e2\n```\n因此，現在我們可以寫下每個函數式程序員最喜歡的兩個函數:`factorial`(階乘)和`fibonacci`(斐波那契)。\n\n為了顯示兩種風格樣式，一種使用`let rec`編寫，另一種使用顯式`fix`編寫。\n```haskell\nlet fact = fix (\\fact -> \\n ->\n  if (n == 0)\n    then 1\n    else (n * (fact (n-1))));\n\n\nlet rec fib n =\n  if (n == 0)\n  then 0\n  else if (n==1)\n  then 1\n  else ((fib (n-1)) + (fib (n-2)));\n```\n\n#### Omega Combinator\n我們將測試的一個重要的退化案例是`omega`組合器，該組合器對其自身應用了一個參數。\n```haskell\nω = λx.xx\n```\n當我們將`ω`組合器應用與自身時，我們發現這會導致無限長的重複`reductions`鏈.\n\n沒有正常形式的`reductions`序列被稱為`diverge`(發散)\n\n![](img/img18.png)\n\n我們將此表達式稱為`Ω`組合器。它是`λ`演算中的規範循環`term`(項)。\n相當多的靜態類型系統會拒絕使用這個術語，因此它是一個非常有用的測試工具。\n\n![](img/img19.png)\n\n### Pretty Printing\n`Hackage`提供了許多漂亮的打印庫，這些庫簡化了為我們的數據類型轉儲文本形式的過程。儘管庫之間存在一些差異，但大多數庫都使用同一組組合器。我們將使用`Hackage`上的`pretty`包中的`Text.PrettyPrint`模塊。我們大多數漂亮的打印都是不可避免的樣板，但是會使內部狀態的調適更加容易。\n\n```haskell\n\t    Combinators\n<>\t    Concatenation\n<+>\t    Spaced concatenation\nchar\tRenders a character as a Doc\ntext\tRenders a string as a Doc\nhsep\tHorizontally concatenates a list of Doc\nvcat\tVertically joins a list of Doc with newlines\n```\n漂亮打印的核心類型是`Doc`類型，即文檔的抽象類型。這種類型的組合器將操縱此文檔的內部結構，然後最終使用`render`函數將其內部化為物理字符串。由於我們打算在多種類型之間進行漂亮打印，因此我們將創建一個漂亮類型類。\n```haskell\nmodule Pretty where\n\nimport Text.PrettyPrint\n\nclass Pretty p where\n  ppr :: Int -> p -> Doc\n\n  pp :: p -> Doc\n  pp = ppr 0\n```\n首先，我們創建兩個輔助函數來折疊我們的`lambda`綁定，以便我們可以將它們打印為單個的`lambda`表達式。\n```haskell\nviewVars :: Expr -> [Name]\nviewVars (Lam n a) = n : viewVars a\nviewVars _ = []\n\nviewBody :: Expr -> Expr\nviewBody (Lam _ a) = viewBody a\nviewBody x = x\n```\n然後，我們創建一個用於對子表達式加括號的輔助函數。\n```haskell\nparensIf ::  Bool -> Doc -> Doc\nparensIf True = parens\nparensIf False = id\n```\n最後，我們定義`ppr`，變量`p`將指示我們在當前正在打印的結構中的深度。並允許我們進行不同的打印，以在必要時將其與周圍環境進行區分。\n```haskell\ninstance Pretty Expr where\n  ppr p e = case e of\n    Lit (LInt a)  -> text (show a)\n    Lit (LBool b) -> text (show b)\n    Var x   -> text x\n    App a b -> parensIf (p>0) $ (ppr (p+1) a) <+> (ppr p b)\n    Lam x a -> parensIf (p>0) $\n         char '\\\\'\n      <> hsep (fmap pp (viewVars e))\n      <+> \"->\"\n      <+> ppr (p+1) (viewBody e)\n\nppexpr :: Expr -> String\nppexpr = render . ppr 0\n```","tags":["Write-Haskell"]},{"title":"Hindley-Milner推论","url":"/blog/2019/09/18/Hindley-Milner推论/","content":"\n> [原文](http://dev.stephendiehl.com/fun/006_hindley_milner.html)\n\n### HM类型系统\n辛德雷-米尔纳类型系统(也称为`Damas-Hindley-Milner`或`HM`)是一组类型系统,它们承认有一个可处理的算法可以从非类型化语法确定类型,这是一个偶然的特性。\n这是通过一个称为`unification`(统一)的过程来实现的,在这个过程中,一个结构良好的程序的类型会产生一组约束,当解决这些约束时,总是有一个惟一的主体类型。\n\n最简单的`Hindley Milner`类型系统由一组非常短的规则定义。\n前四个规则描述了我们可以如何判断将每个句法结构(`Lam`，`App`，`Var`，`Let`)映射到它们的预期类型,我们很快就会详细阐述这些规则。\n![](img/HM0.png)\n米尔纳的观察是,因为类型规则映射到唯一的语法,我们实际上可以向后运行类型规则,每当我们没有子表达式的已知类型时,我们通过在其位置放置一个新变量,\n收集关于其后续类型判断引起的使用限制来进行\"猜测\".\n这是ML族语言中类型推断的本质,通过生成和解决一种统一(`unification`)问题,我们可以从语法中唯一地重构类型,算法本身很大程度上只是统一求解器的结构化使用.\n然而,完整的类型推断使我们有点束缚,因为虽然推理问题在这种简单的语言和简单的扩展中是易处理的,但几乎所有对语言的重要补充都会破坏在没有注释的情况下推断类型的能力,\n或者使推理算法严重复杂化.然而,`Hindley-Milner`家族在设计领域代表了一个非常有用,富有成效的\"甜蜜点\".\n\n### 语法\n我们的第一种类型推断语言的语法实际上将是我们的无类型`lambda`演算的扩展,包括`fixpoint`运算符,`booleans`,`integers`,`let`和一些基本的算术运算.\n```haskell\ntype Name = String\n\ndata Expr\n  = Var Name\n  | App Expr Expr\n  | Lam Name Expr\n  | Let Name Expr Expr\n  | Lit Lit\n  | If Expr Expr Expr\n  | Fix Expr\n  | Op Binop Expr Expr\n  deriving (Show, Eq, Ord)\n\ndata Lit\n  = LInt Integer\n  | LBool Bool\n  deriving (Show, Eq, Ord)\n\ndata Binop = Add | Sub | Mul | Eql\n  deriving (Eq, Ord, Show)\n\ndata Program = Program [Decl] Expr deriving Eq\n\ntype Decl = (String, Expr)\n```\n`parser`是微不足道的,唯一的补充是`toplevel` `let`声明(`Decl`),它们被加入到全局程序中,\n所有顶级声明都必须以分号结束,尽管它们可以跨越多行并且忽略空格.例如:\n```haskell\n-- SKI combinators\nlet I x = x;\nlet K x y = x;\nlet S f g x = f x (g x);\n```\n和之前一样,`let rec`表达式将根据`fixpoint`运算符展开,只是语法糖.\n\n### 多态性\n我们将向我们的语言添加一个额外的构造,它将允许我们的语言具有一种新的多态性形式.\n多态性是一个术语的属性,它允许同一函数实现同时使用几种不同的类型.\n例如,`identity`函数的多态签名实例映射一个`α`类型的输入:\n\n![](img/HM01.png)\n现在不必为每种可能的类型重复函数(即实现`idInt`,`idBool`...)\n我们的类型系统允许包含在多态类型签名中的任何实例.\n![](img/HM02.png)\n普遍量化的一个相当显著的事实是,关于一类的`inhabitants`(類型的實例的統稱)的许多属性是由构造保证的,这些就是所谓的`free`定理.\n例如,任何`(a, b) -> a`类型的(`nonpathological`)实现必须等同于`fst`.\n一个稍微不那么简单的例子是`fmap`函数的类型`Functor f =>（a -> b）-> f a -> f b`\n第二个`functor`法律要求:\n```haskell\nforall f g. fmap f . fmap g = fmap (f . g)\n```\n但是,我们不可能为`fmap`编写一个(`nonpathological`)函数,该函数具有所需的类型,但没有此属性.我们得到`free`定理!\n\n### 类型\n我们将使用的类型语言从用于类型化`lambda`演算的简单类型系统开始.\n```haskell\nnewtype TVar = TV String\n  deriving (Show, Eq, Ord)\n\ndata Type\n  = TVar TVar\n  | TCon String\n  | TArr Type Type\n  deriving (Show, Eq, Ord)\n\ntypeInt, typeBool :: Type\ntypeInt  = TCon \"Int\"\ntypeBool = TCon \"Bool\"\n```\n`Type schemes``model polymorphic types`(样板多态类型)，它们表示量词中绑定的类型变量在封闭的类型中是多态的，可以用与签名一致的任何类型实例化。直观地说明了该函数的实现:\n```haskell\ndata Scheme = Forall [TVar] Type\n```\n`Type schemes`(类型模式)将在我们的输入规则中写为`σ`.\n![](img/HM03.png)\n例如:`id`和`const`函数将会有以下类型:\n![](img/HM04.png)\n我们现在将我们的类型划分为两个句法类别,单型和多型.\n在我们简单的初始语言中,`type schemes`(类型模式)将始终是`top level`(顶级)签名的表示,即使没有多态类型变量.\n在实现术语中,这意味着在推断后从我们的`Infer monad`中产生单型时,\n`we will immediately generalize it at the toplevel \"closing over\" all free type variables in a type scheme.`\n(我们将立即在类型模式的顶层\"关闭所有\"自由类型变量中归纳它)\n\n### 上下文\n```haskell\nnewtype TypeEnv = TypeEnv (Map.Map Var Scheme)\n```\n两个主要操作是扩展和限定,它从上下文中引入或删除命名数量.\n![](img/HM05.png)\n对上下文的操作只是对底层`map`上的常用`Set`操作.\n```haskell\nextend :: TypeEnv -> (Var, Scheme) -> TypeEnv\nextend (TypeEnv env) (x, s) = TypeEnv $ Map.insert x s env\n```\n### Inference Monad(推理)\n我们所有的类型推断逻辑都将存在于`Infer monad`中,它是`ExcpetT`+`State`的`monad`变换器堆栈.允许各种错误报告并有状态地保存新名称.\n```haskell\ntype Infer a = ExceptT TypeError (State Unique) a\n```\n在`monad`中运行逻辑会导致类型错误或结果类型模式.\n```haskell\nrunInfer :: Infer (Subst, Type) -> Either TypeError Scheme\nrunInfer m = case evalState (runExceptT m) initUnique of\n  Left err  -> Left err\n  Right res -> Right $ closeOver res\n```\n### Substitution(替换)\n查询表达式的自由变量和对表达式应用替换,这两个操作将执行相当多的操作.\n![](img/HM06.png)\n相同的模式适用于类型级别的类型变量.\n![](img/HM07.png)\n表达式上的替换将替换应用于局部变量，如果匹配，则替换指定的子表达式。在名称捕获的情况下，将引入一个新的变量。\n![](img/HM08.png)\n同样，替换也可以应用于类型环境之上的元素。\n![](img/HM09.png)\n我们在`Haskell`中的替换实现只是从类型变量到类型的`Map`.\n```haskell\ntype Subst = Map.Map TVar Type\n```\n替换的组合(`s1 ∘ s2`, `s1 compose s2`)可以简单地编码为基础`Map`上的操作,重要的是要注意,在我们的实现中,我们选择了替换为`left-biased`,取决于推理算法的实现,以确保在替换之间不发生冲突.\n```haskell\nnullSubst :: Subst\nnullSubst = Map.empty\n\ncompose :: Subst -> Subst -> Subst\ns1 `compose` s2 = Map.map (apply s1) s2 `Map.union` s1\n```\n\n`Haskell`中的实现是通过`Substitutable`类型类的一系列实现来公开一个`apply`函数,该函数应用在 指定类型变量的 类型结构上 给出的替换.\n```haskell\nclass Substitutable a where\n  apply :: Subst -> a -> a\n  ftv   :: a -> Set.Set TVar\n\ninstance Substitutable Type where\n  apply _ (TCon a)       = TCon a\n  apply s t@(TVar a)     = Map.findWithDefault t a s\n  apply s (t1 `TArr` t2) = apply s t1 `TArr` apply s t2\n\n  ftv TCon{}         = Set.empty\n  ftv (TVar a)       = Set.singleton a\n  ftv (t1 `TArr` t2) = ftv t1 `Set.union` ftv t2\n\ninstance Substitutable Scheme where\n  apply s (Forall as t)   = Forall as $ apply s' t\n                            where s' = foldr Map.delete s as\n  ftv (Forall as t) = ftv t `Set.difference` Set.fromList as\n\ninstance Substitutable a => Substitutable [a] where\n  apply = fmap . apply\n  ftv   = foldr (Set.union . ftv) Set.empty\n\ninstance Substitutable TypeEnv where\n  apply s (TypeEnv env) =  TypeEnv $ Map.map (apply s) env\n  ftv (TypeEnv env) = ftv $ Map.elems env\n```\n在整个类型规则和替换中,我们需要新的名称.在这个天真的版本中,我们将简单地使用无限的字符串列表,并按照我们在`状态monad`中保存的索引切入列表的第`n`个元素,这是最简单的实现,稍后我们将使这种名称生成技术更加健壮.\n```haskell\nletters :: [String]\nletters = [1..] >>= flip replicateM ['a'..'z']\n\nfresh :: Infer Type\nfresh = do\n  s <- get\n  put s{count = count s + 1}\n  return $ TVar $ TV (letters !! count s)\n```\n创建新变量对于实施推理规则至关重要。 每当我们在某个表达式中遇到第一次使用变量时，我们将创建一个新的类型变量。\n\n### Unification(统一)\n推理思想的核心是统一的概念,两个表达式`e1`和`e2`的统一符是替换`s`,使得:\n![](img/HM10.png)\n如果在它们之间存在统一的替换集合，则认为两个术语是统一的。 如果替换的应用与所应用的顺序无关，即如果我们总是以相同的正常形式到达而不管所选择的替换顺序如何，则称替换集是汇合的。\n我们将采用这种表示法:\n```haskell\nτ ∼ τ′:s\n```\n事实上`τ,τ'`这两种类型是可以通过一个替换`s`进行统一的,这样:\n```haskell\n[s]τ = [s]τ′\n```\n两个相同的项可以用空的统一器轻松地统一:\n```haskell\nc ∼ c : [ ]\n```\n我们的小HM语言的统一规则如下:\n![](img/HM11.png)\n如果我们想要将类型变量`α`与类型`τ`统一起来,我们通常可以用类型替换变量: `[α/τ]`.但是,我们的规则规定了一个前提条件,称为该统一的发生检查: 类型变量`α`不得在`τ`中自由出现.如果确实如此.则替换将不是统一.\n例如,统一`α`和`α → β`的问题.\n替换`s` = `[α/α → β]`不统一: 我们得到\n```haskell\n[s]α = α → β\n-- 和\n[s]α → β = (α → β) → β\n```\n实际上,无论我们尝试什么替代,`[s]α → β`总是比`[s]α`长,所以不存在统一者,唯一的机会是用无限类型替换: `[α/(...((α → β) → β)→ ⋯ → β) → β]`将是一个统一者，但我们的语言没有这样的类型。\n如果由于发生检查(`occurs check`)而统一失败,我们说统一将给出无限类型。\n请注意,如果我们尝试类型检查`omega`组合器`λx.xx`，那么统一`α → β`和`α`正是我们必须要做的,所以它被发生检查(`occurs check`)排除了，\n正如我们在覆盖无类型`lambda`演算时所讨论的其他`pathological`术语一样.\n```haskell\noccursCheck ::  Substitutable a => TVar -> a -> Bool\noccursCheck a t = a `Set.member` ftv t\n```\n`unify`函数存在于`Infer monad`中并产生替换:\n```haskell\nunify ::  Type -> Type -> Infer Subst\nunify (l `TArr` r) (l' `TArr` r')  = do\n    s1 <- unify l l'\n    s2 <- unify (apply s1 r) (apply s1 r')\n    return (s2 `compose` s1)\n\nunify (TVar a) t = bind a t\nunify t (TVar a) = bind a t\nunify (TCon a) (TCon b) | a == b = return nullSubst\nunify t1 t2 = throwError $ UnificationFail t1 t2\n\nbind ::  TVar -> Type -> Infer Subst\nbind a t | t == TVar a     = return nullSubst\n         | occursCheck a t = throwError $ InfiniteType a t\n         | otherwise       = return $ Map.singleton a t\n```\n\n### Generalization and Instantiation (泛化和实例化)\n`Hindley-Milner`的核心是两个基本操作:\n`Generalization`泛化: 通过关闭类型方案中的所有自由类型变量,将`τ`类型转换为`σ`类型。\n`Instantiation`实例化: 通过为当前类型环境中未出现的每个类型变量创建新名称,将`σ`类型转换为`τ`类型。\n![](img/HM12.png)\n(`T-Inst`)规则中的`⊑`运算符表示类型是类型模式(`type scheme`)的实例.\n![](img/HM13.png)\n`⊑`符号右边的类型`τ1`是左边类型模式(`σ = 左边`)的实例化,如果对于所有的`β ∈ 𝚏𝚝𝚟(σ)`存在一个替换`[s]β = β`,则` τ1 = [s]τ2`,看例子:\n\n```haskell\n∀a.a → a ⊑ 𝙸𝚗𝚝 → 𝙸𝚗𝚝\n∀a.a → a ⊑ b → b\n∀ab.a → b → a ⊑ 𝙸𝚗𝚝 → 𝙱𝚘𝚘𝚕 → 𝙸𝚗𝚝\n```\n这些映射非常直观地映射到简单地操作`Haskell Set`变量对象和新名称供应的代码:\n```haskell\ninstantiate ::  Scheme -> Infer Type\ninstantiate (Forall as t) = do\n  as' <- mapM (const fresh) as\n  let s = Map.fromList $ zip as as'\n  return $ apply s t\n\ngeneralize :: TypeEnv -> Type -> Scheme\ngeneralize env t  = Forall as t\n    where as = Set.toList $ ftv t `Set.difference` ftv env\n```\n按照约定,`let`绑定被尽可能地一般化(`generalized`).\n因此,在下面的定义中,`f`在绑定的主体上进行了一般化,以便在每次调用`f`时,都用新的类型变量实例化它.\n```haskell\nPoly> let f = (\\x -> x) in let g = (f True) in f 3\n3 : Int\n```\n在这个表达式中,`f`的类型在`let`定义中生成,并将使用两个不同的签名实例化.\n在f的调用位置,它将与`Int`相统一,另一个与`Bool`相统一。\n相反,在`lambda`中绑定`f`将导致类型错误.\n```haskell\nPoly> (\\f -> let g = (f True) in (f 3)) (\\x -> x)\nCannot unify types: \n    Bool\nwith \n    Int\n```\n这是`let generalization(一般化)`的本质.\n\n### Typing Rules (类型规则)\n最后,在所有类型机制到位后,我们可以写下我们简单的小多态`lambda`演算的类型规则.\n```haskell\ninfer :: TypeEnv -> Expr -> Infer (Subst, Type)\n```\n`infer`将局部类型环境和活动表达式映射到部分统一解决方案和中间类型的2元组.通过在每个部分推断的子表达式和局部环境中应用来自统一的部分替换,自下而上遍历`AST`并且在每个递归级别处求解约束,如果遇到错误,则会在`Infer monad`中调用`throwError`,并报告错误:\n```haskell\ninfer :: TypeEnv -> Expr -> Infer (Subst, Type)\ninfer env ex = case ex of\n\n  Var x -> lookupEnv env x\n\n  Lam x e -> do\n    tv <- fresh\n    let env' = env `extend` (x, Forall [] tv)\n    (s1, t1) <- infer env' e\n    return (s1, apply s1 tv `TArr` t1)\n\n  App e1 e2 -> do\n    tv <- fresh\n    (s1, t1) <- infer env e1\n    (s2, t2) <- infer (apply s1 env) e2\n    s3       <- unify (apply s2 t1) (TArr t2 tv)\n    return (s3 `compose` s2 `compose` s1, apply s3 tv)\n\n  Let x e1 e2 -> do\n    (s1, t1) <- infer env e1\n    let env' = apply s1 env\n        t'   = generalize env' t1\n    (s2, t2) <- infer (env' `extend` (x, t')) e2\n    return (s1 `compose` s2, t2)\n\n  If cond tr fl -> do\n    (s1, t1) <- infer env cond\n    (s2, t2) <- infer env tr\n    (s3, t3) <- infer env fl\n    s4 <- unify t1 typeBool\n    s5 <- unify t2 t3\n    return (s5 `compose` s4 `compose` s3 `compose` s2 `compose` s1, apply s5 t2)\n\n  Fix e1 -> do\n    (s1, t) <- infer env e1\n    tv <- fresh\n    s2 <- unify (TArr tv tv) t\n    return (s2, apply s1 tv)\n\n  Op op e1 e2 -> do\n    (s1, t1) <- infer env e1\n    (s2, t2) <- infer env e2\n    tv <- fresh\n    s3 <- unify (TArr t1 (TArr t2 tv)) (ops Map.! op)\n    return (s1 `compose` s2 `compose` s3, apply s3 tv)\n\n  Lit (LInt _)  -> return (nullSubst, typeInt)\n  Lit (LBool _) -> return (nullSubst, typeBool)\n```\n让我们浏览每个规则派生，看看它如何转换为代码:\n#### T-Var\nT-Var规则，只需从`typing`变换上下文中提取变量的类型即可.\n```haskell\nVar x -> lookupEnv env x\n```\n函数`lookupVar`在`typing`环境中查找局部变量引用,如果找到它,则实例化一个新副本.\n```haskell\nlookupEnv :: TypeEnv -> Var -> Infer (Subst, Type)\nlookupEnv (TypeEnv env) x = do\n  case Map.lookup x env of\n    Nothing -> throwError $ UnboundVariable (show x)\n    Just s  -> do t <- instantiate s\n                  return (nullSubst, t)\n```\n![](img/HM14.png)\n\t\n#### T-Lam\n对于`lambdas`,由`lambda`绑定的变量本地作用于`typing`环境,然后使用此作用域推断表达式的主体.\n输出类型是一个新类型变量,并与生成的推断类型统一.\n```haskell\nLam x e -> do\n    tv <- fresh\n    let env' = env `extend` (x, Forall [] tv)\n    (s1, t1) <- infer env' e\n    return (s1, apply s1 tv `TArr` t1)\n```\n![](img/HM15.png)\n\n\n#### T-App\n对于应用程序,第一个参数必须是`lambda`表达式或返回`lambda`表达式,因此要知道它必须是`t1 -> t2`的形式,但除了两个值的汇合外,不确定输出类型。\n我们推断两种类型,\n将第一个参数中的约束应用于第二推断类型的结果,然后使用整个应用程序表达式的例外形式(`excepted form`)统一这两个类型。\n```\nApp e1 e2 -> do\n    tv <- fresh\n    (s1, t1) <- infer env e1\n    (s2, t2) <- infer (apply s1 env) e2\n    s3       <- unify (apply s2 t1) (TArr t2 tv)\n    return (s3 `compose` s2 `compose` s1, apply s3 tv)\n```\n![](img/HM16.png)\n\n#### T-Let\n如前所述,`let`将会`generalized`(一般化),因此我们将为`let`表达式的主体创建一个本地`typing`类型化环境,并添加一般化推断类型的`let`绑定值到主体的`typing`环境中.\n```haskell\n Let x e1 e2 -> do\n    (s1, t1) <- infer env e1\n    let env' = apply s1 env\n        t'   = generalize env' t1\n    (s2, t2) <- infer (env' `extend` (x, t')) e2\n    return (s1 `compose` s2, t2)\n```\n![](img/HM17.png)\n\n#### T-BinOp\n有几个内建操作,我们到目前为止还没有提到,因为类型规则很简单,我们只需统一这个操作的预设置类型签名.\n```haskell\nOp op e1 e2 -> do\n    (s1, t1) <- infer env e1\n    (s2, t2) <- infer env e2\n    tv <- fresh\n    s3 <- unify (TArr t1 (TArr t2 tv)) (ops Map.! op)\n    return (s1 `compose` s2 `compose` s3, apply s3 tv)\n\nops :: Map.Map Binop Type\nops = Map.fromList [\n      (Add, (typeInt `TArr` (typeInt `TArr` typeInt)))\n    , (Mul, (typeInt `TArr` (typeInt `TArr` typeInt)))\n    , (Sub, (typeInt `TArr` (typeInt `TArr` typeInt)))\n    , (Eql, (typeInt `TArr` (typeInt `TArr` typeBool)))\n  ]\n```\n\n#### Literals\n`literal`整数和`boolean`类型的类型通常是它们各自的类型.\n```haskell\n(+) :: 𝙸𝚗𝚝 → 𝙸𝚗𝚝 → 𝙸𝚗𝚝\n(×) :: 𝙸𝚗𝚝 → 𝙸𝚗𝚝 → 𝙸𝚗𝚝\n(−) :: 𝙸𝚗𝚝 → 𝙸𝚗𝚝 → 𝙸𝚗𝚝\n(=) :: 𝙸𝚗𝚝 → 𝙸𝚗𝚝 → 𝙱𝚘𝚘𝚕\n```\n![](img/HM18.png)\n\n### Constraint Generation (约束生成)\n`Hindley Milner`的先前实现很简单,但具有混合两个独立过程的奇怪特性: `constraint solving`(约束求解器)和`traversal`(遍历).让我们讨论不执行此操作的推理算法的另一种实现.\n在约束生成方法中,约束是通过自下而上遍历生成的,添加到有序容器中,规范化,求解,然后可能在类型化AST上进行后置替换.这将是我们将从这里使用的方法,\n虽然与`on-line solver`之间存在等价,但使用单独的约束求解器变得更容易管理,因为我们的类型系统变得更复杂,我们开始构建语言.\n现在我们的推理`monad`变成了`RWST`(`Reader-Writer-State`转换器)+`Either`(处理类型错误).推理状态保持不变,只是提供新鲜的名称.\n```haskell\n-- | Inference monad\ntype Infer a = (RWST\n                  Env             -- Typing environment\n                  [Constraint]    -- Generated constraints\n                  InferState      -- Inference state\n                  (Except         -- Inference errors\n                    TypeError)\n                  a)              -- Result\n\n-- | Inference state\ndata InferState = InferState { count :: Int }\n```\n我们将只收集`Writer`中的`unifier`并使用`uni`函数发出它们,而不是在每个遍历级别统一类型变量.\n```haskell\n-- | Unify two types\nuni :: Type -> Type -> Infer ()\nuni t1 t2 = tell [(t1, t2)]\n```\n由于`typing`输入环境存储在`Reader monad`中,我们可以使用`local`来为`typing`环境创建一个本地范围的附加组件.这对于`typing`绑定器很方便.\n```haskell\n-- | Extend type environment\ninEnv :: (Name, Scheme) -> Infer a -> Infer a\ninEnv (x, sc) m = do\n  let scope e = (remove e x) `extend` (x, sc)\n  local scope m\n```\n\n### Typing\n这些类型规则是相同的,只是现在我们可以用一种不需要线程处理太多状态的更少噪音的方式来编写它们.\n所有的细节都被隐藏起来,并被编码在特定的组合器中,以一种让我们专注于领域逻辑的方式操纵我们的`Infer monad`的状态。\n```haskell\ninfer :: Expr -> Infer Type\ninfer expr = case expr of\n  Lit (LInt _)  -> return $ typeInt\n  Lit (LBool _) -> return $ typeBool\n\n  Var x -> lookupEnv x\n\n  Lam x e -> do\n    tv <- fresh\n    t <- inEnv (x, Forall [] tv) (infer e)\n    return (tv `TArr` t)\n\n  App e1 e2 -> do\n    t1 <- infer e1\n    t2 <- infer e2\n    tv <- fresh\n    uni t1 (t2 `TArr` tv)\n    return tv\n\n  Let x e1 e2 -> do\n    env <- ask\n    t1 <- infer e1\n    let sc = generalize env t1\n    t2 <- inEnv (x, sc) (infer e2)\n    return t2\n\n  Fix e1 -> do\n    t1 <- infer e1\n    tv <- fresh\n    uni (tv `TArr` tv) t1\n    return tv\n\n  Op op e1 e2 -> do\n    t1 <- infer e1\n    t2 <- infer e2\n    tv <- fresh\n    let u1 = t1 `TArr` (t2 `TArr` tv)\n        u2 = ops Map.! op\n    uni u1 u2\n    return tv\n\n  If cond tr fl -> do\n    t1 <- infer cond\n    t2 <- infer tr\n    t3 <- infer fl\n    uni t1 typeBool\n    uni t2 t3\n    return t2\n```\n\n### Constraint Solver (约束解决器)\n`Infer monad`的`Writer`层包含从推理传递发出的生成的约束集.\n一旦推断完成,我们就会得到一个结果类型签名,其中包含无意义的唯一新变量和一组约束,我们必须解决这些约束以将类型细化为其主要类型.\n约束由一个单独的`Solve monad`解决,该`monad`包含`Unifier`(最常见的统一)解决方案,当应用于生成的签名时,它将产生解决方案.\n```haskell\ntype Constraint = (Type, Type)\n\ntype Unifier = (Subst, [Constraint])\n\n-- | Constraint solver monad\ntype Solve a = StateT Unifier (ExceptT TypeError Identity) a\n```\n\n统一逻辑也与以前相同,除了它现在脱离推理独立编写,并将其部分状态存储在`Solve monad`的状态层内.\n```haskell\nunifies :: Type -> Type -> Solve Unifier\nunifies t1 t2 | t1 == t2 = return emptyUnifer\nunifies (TVar v) t = v `bind` t\nunifies t (TVar v) = v `bind` t\nunifies (TArr t1 t2) (TArr t3 t4) = unifyMany [t1, t2] [t3, t4]\nunifies t1 t2 = throwError $ UnificationFail t1 t2\n\nunifyMany :: [Type] -> [Type] -> Solve Unifier\nunifyMany [] [] = return emptyUnifer\nunifyMany (t1 : ts1) (t2 : ts2) =\n  do (su1,cs1) <- unifies t1 t2\n     (su2,cs2) <- unifyMany (apply su1 ts1) (apply su1 ts2)\n     return (su2 `compose` su1, cs1 ++ cs2)\nunifyMany t1 t2 = throwError $ UnificationMismatch t1 t2\n```\n```\nThe solver function simply iterates over the set of constraints, composing them and applying the resulting constraint solution over the intermediate solution eventually converting on the most general unifier which yields the final substitution which when applied over the inferred type signature, yields the principal type solution for the expression.\n```\n求解器函数简单地迭代约束集,组合它们并将结果约束解决方案应用于中间解决方案,最终转换为最通用的统一,产生最终替换,当应用于推断类型签名时,为表达式产生主要类型解决方案.\n\n```haskell\n-- Unification solver\nsolver :: Solve Subst\nsolver = do\n  (su, cs) <- get\n  case cs of\n    [] -> return su\n    ((t1, t2): cs0) -> do\n      (su1, cs1)  <- unifies t1 t2\n      put (su1 `compose` su, cs1 ++ (apply su1 cs0))\n      solver\n```\n这是一个更加优雅的解决方案，而不是在同一个传递中混合推理和求解，并且很好地适应了我们将在后面的章节中讨论的类型化核心形式的生成。\n\n\n\n### Worked Examples\n让我们来看两个推理如何适用于简单函数的例子.\n#### 例子1\n考虑:\n```haskell\n\\x y z -> x + y + z\n```\n`infer`函数生成的类型只包含每个参数和返回类型的新变量.\n```haskell\na -> b -> c -> e\n```\n当我们遍历两个加法运算时，发出由T-BinOp引起的约束.\n```haskell\n1. a -> b -> d ~ Int -> Int -> Int\n2. d -> c -> e ~ Int -> Int -> Int\n```\n这里`d`是中间项`x + y`的类型.通过应用`Uni-Arrow`,我们可以推导出以下一组替换.\n```haskell\n1. a ~ Int\n2. b ~ Int\n3. c ~ Int\n4. d ~ Int\n5. e ~ Int\n```\n将此解决方案替换回类型会产生推断类型:\n```haskell\nInt -> Int -> Int -> Int\n```\n\n#### 例子2\n```haskell\ncompose f g x = f (g x)\n```\n推断函数生成的类型仅包含唯一的新变量.\n```haskell\na -> b -> c -> e\n```\n由两个T-App规则引起的我们得到以下约束:\n```haskell\n1. b ~ c -> d\n2. a ~ d -> e\n```\n这里`d`是`(g x)`的类型,约束已经是规范形式,通过应用`Uni-VarLeft`两次,我们得到以下一组替换:\n```haskell\n1. b ~ c -> d\n2. a ~ d -> e\n```\n所以我们得到这种类型:\n```haskell\ncompose :: forall c d e. (d -> e) -> (c -> d) -> c -> e\n```\n如果需要，我们可以按字母顺序重命名变量以获得:\n```haskell\ncompose :: forall a b c. (a -> b) -> (c -> a) -> c -> b\n```\n\n### Interpreter\n我们的求值程序将直接在语法上运行，并将结果计算为`Value`类型.\n```haskell\ndata Value\n  = VInt Integer\n  | VBool Bool\n  | VClosure String Expr TermEnv\n```\n解释器设置为`Identity monad`,后面它将成为一个更复杂的`monad`,但现在它很简单.值(`value`)环境将显式地线程化,并且每当创建闭包时,我们只需在闭包中存储本地环境的副本.\n```haskell\ntype TermEnv = Map.Map String Value\ntype Interpreter t = Identity t\n```\n我们的计算逻辑是上一章实现的lambda演算求值器的扩展.\n然而，您可能会注意到在整个评估过程中使用了许多不完整的模式.\n不过不要害怕,我们的程序评估不会\"出错\".\n这些模式中的每一个都代表了我们的类型系统保证永远不会发生的一种状态.\n例如，如果我们的程序没有在作用域中引用每个变量,那么它将永远不会达到开始时的求值,并且将在类型检查器中被拒绝,我们在这里使用不完整的模式在道义上是正确的!\t\n```haskell\neval :: TermEnv -> Expr -> Interpreter Value\neval env expr = case expr of\n  Lit (LInt k)  -> return $ VInt k\n  Lit (LBool k) -> return $ VBool k\n\n  Var x -> do\n    let Just v = Map.lookup x env\n    return v\n\n  Op op a b -> do\n    VInt a' <- eval env a\n    VInt b' <- eval env b\n    return $ (binop op) a' b'\n\n  Lam x body -> \n    return (VClosure x body env)\n\n  App fun arg -> do\n    VClosure x body clo <- eval env fun\n    argv <- eval env arg\n    let nenv = Map.insert x argv clo\n    eval nenv body\n\n  Let x e body -> do\n    e' <- eval env e\n    let nenv = Map.insert x e' env\n    eval nenv body\n\n  If cond tr fl -> do\n    VBool br <- eval env cond\n    if br == True\n    then eval env tr\n    else eval env fl\n\n  Fix e -> do\n    eval env (App e (Fix e))\n\nbinop :: Binop -> Integer -> Integer -> Value\nbinop Add a b = VInt $ a + b\nbinop Mul a b = VInt $ a * b\nbinop Sub a b = VInt $ a - b\nbinop Eql a b = VBool $ a == b\n```\n\n\n### Interactive Shell\n我们的语言现在已经成长为我们之前使用过的小型`shell`,现在我们需要更强大的东西来保持我们的交互式解释器的逻辑.\n```haskell\ndata IState = IState\n  { tyctx :: TypeEnv  -- Type environment\n  , tmctx :: TermEnv  -- Value environment\n  }\n\ninitState :: IState\ninitState = IState emptyTyenv emptyTmenv\n\ntype Repl a = HaskelineT (StateT IState IO) a\n\nhoistErr :: Show e => Either e a -> Repl a\nhoistErr (Right val) = return val\nhoistErr (Left err) = do\n  liftIO $ print err\n  abort\n```\n我们的语言可以由`GHC`编译成独立的二进制文件:\n```haskell\n$ ghc --make Main.hs -o poly\n$ ./poly\nPoly>\n```\n在我们程序的顶部，我们将查看命令选项并允许三种命令变体:\n```haskell\n$ poly                # launch shell\n$ poly input.ml       # launch shell with 'input.ml' loaded\n$ poly test input.ml  # dump test for 'input.ml' to stdout\n```\n```haskell\nmain :: IO ()\nmain = do\n  args <- getArgs\n  case args of\n    []      -> shell (return ())\n    [fname] -> shell (load [fname])\n    [\"test\", fname] -> shell (load [fname] >> browse [] >> quit ())\n    _ -> putStrLn \"invalid arguments\"\n```\n`shell`命令需要一个`pre`动作,该动作在`shell`启动之前运行,逻辑简单地将我们的`Repl monad`评估为`IO`并从`main`函数运行它.\n```haskell\nshell :: Repl a -> IO ()\nshell pre\n  = flip evalStateT initState\n  $ evalRepl \"Poly> \" cmd options completer pre\n```\n`cmd`驱动程序是我们程序的主要入口点,每次用户输入一行输入时都会执行它,第一个参数是用户输入行.\n```haskell\ncmd :: String -> Repl ()\ncmd source = exec True (L.pack source)\n```\n然后，我们的语言的核心是`exec`函数，它导入所有编译器传递的信息，然后按顺序线程化输入和输出，最终生成一个结果类型环境和程序的评估结果。它们被`monoidally`连接到解释器的状态中，然后循环产生下一组输入.\n```haskell\nexec :: Bool -> L.Text -> Repl ()\nexec update source = do\n  -- Get the current interpreter state\n  st <- get\n\n  -- Parser ( returns AST )\n  mod <- hoistErr $ parseModule \"<stdin>\" source\n\n  -- Type Inference ( returns Typing Environment )\n  tyctx' <- hoistErr $ inferTop (tyctx st) mod\n\n  -- Create the new environment\n  let st' = st { tmctx = foldl' evalDef (tmctx st) mod\n               , tyctx = tyctx' <> (tyctx st)\n               }\n\n  -- Update the interpreter state\n  when update (put st')\n```\n`Repline`还支持添加特定的套接字输入集，以便将它们映射到编译器中的内置命令。我们将实现其中三个。\n```haskell\nCommand\tAction\n:browse\t\tBrowse the type signatures for a program\n:load <file>\tLoad a program from file\n:type\t\tShow the type of an expression\n:quit\t\tExit interpreter\n```\n它们的实现大多很简单。\n```haskell\noptions :: [(String, [String] -> Repl ())]\noptions = [\n    (\"load\"   , load)\n  , (\"browse\" , browse)\n  , (\"quit\"   , quit)\n  , (\"type\"   , Main.typeof)\n  ]\n\n-- :browse command\nbrowse :: [String] -> Repl ()\nbrowse _ = do\n  st <- get\n  liftIO $ mapM_ putStrLn $ ppenv (tyctx st)\n\n-- :load command\nload :: [String] -> Repl ()\nload args = do\n  contents <- liftIO $ L.readFile (unwords args)\n  exec True contents\n\n-- :type command\ntypeof :: [String] -> Repl ()\ntypeof args = do\n  st <- get\n  let arg = unwords args\n  case Infer.typeof (tyctx st) arg of\n    Just val -> liftIO $ putStrLn $ ppsignature (arg, val)\n    Nothing -> exec False (L.pack arg)\n\n-- :quit command\nquit :: a -> Repl ()\nquit _ = liftIO $ exitSuccess\n```\n最后，`shell`的`tab`补全将使用解释器的类型环境`key`在一组本地定义的变量上完成。`Repline`支持基于前缀的`tab`完成，其中将使用当前命令的前缀来确定要执行哪些`tab`完成。\n在我们以`command:load`开头的情况下，我们将直接在当前工作的文件名上`tab`完成。\n```haskell\ncompleter :: CompleterStyle (StateT IState IO)\ncompleter = Prefix (wordCompleter comp) defaultMatcher\n\n-- Prefix tab completer\ndefaultMatcher :: MonadIO m => [(String, CompletionFunc m)]\ndefaultMatcher = [\n    (\":load\"  , fileCompleter)\n  ]\n\n-- Default tab completer\ncomp :: (Monad m, MonadState IState m) => WordCompleter m\ncomp n = do\n  let cmds = [\":load\", \":browse\", \":quit\", \":type\"]\n  TypeEnv ctx <- gets tyctx\n  let defs = Map.keys ctx\n  return $ filter (isPrefixOf n) (cmds ++ defs)\n```\n\n### Observations (意见)\n我们有它，我们的第一个小型推断语言！\n通过运行`ghci Main.hs`加载`poly`解释器并调用`main`函数。\n```haskell\n$ ghci Main.hs\nλ: main\nPoly> :load test.ml\nPoly> :browse\n```\n通过在程序的`toplevel`声明一些函数来尝试一些简单的例子。我们可以使用`:type`命令以交互方式查询表达式的类型，该命令实际上只是在管道中途运行表达式并在类型检查后停止。\n```haskell\nPoly> let id x = x\nPoly> let const x y = x\nPoly> let twice x = x + x\n\nPoly> :type id\nid : forall a. a -> a\n\nPoly> :type const\nconst : forall a b. a -> b -> a\n\nPoly> :type twice\ntwice : Int -> Int\n```\n注意几个重要的事实。\n我们的类型检查器现在将在解释之前将我们的拒绝程序与范围错误相关联。\n```haskell\nPoly> \\x -> y\nNot in scope: \"y\"\n```\n此外，那些类型不太好的程序现在也会被直接拒绝.\n```haskell\nPoly> 1 + True\nCannot unify types: \n    Bool\nwith \n    Int\n```\n`omega`组合子将无法通过`occurs`检查:\n```haskell\nPoly> \\x -> x x\nCannot construct the the infinite type: a = a -> b\n```\n`test.ml`文件提供了对小解释器的各种测试. 例如,`fact`和`fib`函数都使用`fixpoint`来计算`Fibonacci`数或阶乘。\n```haskell\nlet fact = fix (\\fact -> \\n -> \n  if (n == 0) \n    then 1 \n    else (n * (fact (n-1))));\n\nlet rec fib n = \n  if (n == 0) \n    then 0\n    else if (n==1) \n      then 1\n      else ((fib (n-1)) + (fib (n-2)));\nPoly> :type fact\nfact : Int -> Int\n\nPoly> fact 5\n120\n\nPoly> fib 16\n610\n```\n\n\n\n","tags":["类型系統"]},{"title":"Haskell的自动化测试工具-QuickCheck","url":"/blog/2019/08/07/Haskell的自动化测试工具-QuickCheck/","content":"> [原文地址](http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html)\n### QuickCheck是什么\n`QuickCheck`是一种自动测试`Haskell`程序的工具。程序员以`函数应满足哪些属性`的形式提供程序的规范，然后，`QuickCheck`测试这些属性是否存在于大量随机生成的案例中。\n规范在`Haskell`中使用`QuickCheck`库中定义的组合器来表示。`QuickCheck`提供组合器来定义属性，观察测试数据的分布，并定义测试数据生成器。\n\n### 一个简单的例子\n一个简单的属性定义示例是：\n```haskell\nprop_RevRev xs = reverse (reverse xs) == xs\n  where types = xs::[Int]\n```\n要检查该属性，我们需要将此定义加载到`hugs`中，然后调用:\n```haskell\nMain> quickCheck prop_RevRev\nOK, passed 100 tests.\n```\n当属性失败时，`QuickCheck`会显示出一个反例。例如，如果我们定义:\n```haskell\nprop_RevId xs = reverse xs == xs\n  where types = xs::[Int]\n```\n然后检查它的结果:\n```haskell\nMain> quickCheck prop_RevId\nFalsifiable, after 1 tests:\n[-3,15]\n```\n\n### 使用QuickCheck\n要使用`QuickCheck`，您必须下载模块`QuickCheck.hs`，最好还是脚本`quickCheck`。将模块`QuickCheck`导入到包含规范或测试数据生成器的每个模块中。然后，您可以通过将定义的模块加载到`hugs`中并调用它来测试属性:\n```haskell\nquickCheck <property-name>\n```\n或者通过运行脚本:\n```haskell\n> quickCheck <options> <file names>\n```\n它检查给定模块中定义的每个属性。您可以使用与`hugs`相同的命令行选项。\n你不需要使用`hugs`来检查属性: 任何`Haskell 98`实现都应该足够了。但是, `quickCheck`脚本假定您的系统上安装了`hugs`。您可能需要编辑脚本以插入`runhugs`的位置。\n\n#### 如何判断正在测试哪个属性？\n某些版本的`hugs`在评估之前会显示要评估的表达式; 因此，您可以随时查看正在检查的属性，以及哪个属性失败。如果您的拥抱版本没有这样做，请给`quickCheck`提供`+names`标识:\n```haskell\n  > quickCheck + names <options> <file names>\n```\n这样它在检查之前将打印每个属性名称。\n\n#### 如果测试循环或遇到错误，我该怎么办？\n在这种情况下，我们知道该属性不成立，但是`quickCheck`没有显示反例。我们为这种情况提供了另一种测试功能。使用以下命令进行重复测试:\n```haskell\n  verboseCheck <property-name>\n```\n在运行测试之前显示每个测试用例：显示的最后一个测试用例是出现循环或错误的测试用例。\n\n### 属性\n属性表示为`Haskell`函数定义，名称以`prop_`开头。属性通过其参数进行普遍量化，因此:\n```haskell\nprop_RevRev xs = reverse (reverse xs) == xs\n  where types = xs :: [Int]\n```\n表示所有列表xs的等式成立(也就是说,所有有限的,总的列表)。\n属性必须具有单态类型。`多态`属性（例如上面的属性）必须限制为用于测试的特定类型。通过在陈述子句中声明一个或多个参数的类型是很方便的:\n```haskell\n  where types = (x1 :: t1, x2 :: t2, ...)\n```\n请注意，`types`不是关键字; 这只是一个本地声明，它提供了一个方便的地方来限制`x1,x2`等的类型。\n除非使用下面的其他组合器定义属性，否则属性的结果应为`Bool`类型。\n\n#### 条件属性\n属性可以采取如下形式:\n```haskell\n  <condition> ==> <property>\n```\n例如:\n```haskell\nordered xs = and (zipWith (<=) xs (drop 1 xs))\ninsert x xs = takeWhile (<x) xs++[x]++dropWhile (<x) xs\n\nprop_Insert x xs = ordered xs ==> ordered (insert x xs)\n  where types = x::Int\n```\n如果条件确实存在`==>`之后的属性，则此属性成立。\n测试丢弃不满足条件的测试用例。\n测试用例生成继续，直到找到满足条件的100个案例，或者直到达到测试用例数量的总体限制（如果条件永远不成立则避免循环）。\n在这种情况下，以下消息\n```haskell\nArguments exhausted after 97 tests.\n```\n表明满足该条件的97个测试用例被发现，并且该属性保留在这97个案例中。\n\n#### 量化属性\n属性可以采取如下形式:\n```haskell\nforAll <generator> $ \\<pattern> -> <property>\n```\n例如:\n```haskell\nprop_Insert2 x = forAll orderedList $ \\xs -> ordered (insert x xs)\n  where types = x::Int \n```\n`forAll`的第一个参数是测试数据生成器; 通过提供自定义生成器，而不是使用该类型的默认生成器，可以控制测试数据的分布。\n在示例中，通过为有序列表提供自定义生成器，而不是过滤掉未排序的测试用例，\n我们保证在不达到测试用例总体限制的情况下可以生成100个测试用例。\n下面的描述用于定义生成器的组合器。\n\n### 观察测试用例分布\n观察测试用例的分布是非常重要的：如果测试数据分布不均匀，那么从测试结果中得出的结论可能是无效的。特别是，`==>`运算符会严重扭曲测试数据的分布，因为只使用满足给定条件的测试数据。\n`QuickCheck`提供了几种观察测试数据分布的方法。制作观察的守则已纳入到属性声明中，\n每次实际测试该属性时，进行观察，然后在测试完成时汇总所收集的观察结果。\n\n#### 计算琐碎的案例\n属性可以采取如下形式:\n```haskell\n   <condition> `trivial` <property>\n```\n例如:\n```haskell\nprop_Insert x xs = ordered xs ==> null xs `trivial` ordered (insert x xs)\n  where types = x::Int\n```\n条件为True的测试用例被归类为琐碎的，并且报告了总数中的琐碎测试用例的比例。在这个例子中，测试产生\n```v\nMain> quickCheck prop_Insert\nOK, passed 100 tests (58% trivial).\n```\n#### 测试用例分类\n属性可以采取如下形式:\n```haskell\n  classify <condition> <string>$ <property>\n```\n例如:\n```haskell\nprop_Insert x xs = \n\tordered xs ==> \n\t\tclassify (ordered (x:xs)) \"at-head\"$\n \t\tclassify (ordered (xs++[x])) \"at-tail\"$\n\t\tordered (insert x xs)\n  where types = x::Int\n```\n满足条件的测试用例被赋予给定的分类，并且在测试之后报告分类的分布。 在这种情况下，结果是\n```haskell\nMain> quickCheck prop_Insert\nOK, passed 100 tests.\n58% at-head, at-tail.\n22% at-tail.\n4% at-head.\n```\n请注意，测试用例可能属于多个分类。\n\n#### 收集数据值\n属性可以采取如下形式:\n```haskell\ncollect <expression>$ <property>\n```\n例如:\n```haskell\nprop_Insert x xs = \n\tordered xs ==> collect (length xs)$\n\t\t       ordered (insert x xs)\n  where types = x::Int\n```\n在每个测试用例中评估`collect`的参数，并报告值的分布。此参数的类型必须位于`Show`类中。在上面的例子中，输出是:\n```haskell\nMain> quickCheck prop_Insert\nOK, passed 100 tests.\n58% 0.\n26% 1.\n13% 2.\n3% 3.\n```\n\n#### 合并观察\n这里描述的观察结果可以以任何方式组合。将每个测试用例的所有观察结合起来，并报告这些组合的分布。例如，测试属性:\n```haskell\nrop_Insert x xs = \n\tordered xs ==> \n\t\tcollect (length xs)$\n\t\tclassify (ordered (x:xs)) \"at-head\"$\n \t\tclassify (ordered (xs++[x])) \"at-tail\"$\n\t\tordered (insert x xs)\n  where types = x::Int\n```\n将会产生:\n```haskell\nMain> quickCheck prop_Insert\nOK, passed 100 tests.\n58% 0, at-head, at-tail.\n22% 1, at-tail.\n13% 2.\n4% 1, at-head.\n3% 3.\n```\n从中可以看出，列表头部或结尾的插入尚未针对长度多于一个元素的列表进行测试。\n\n### 测试数据生成器: 类型Gen\n测试数据由测试数据生成器生成。`QuickCheck`为大多数类型定义了默认生成器，但是你可以通过`forAll`使用自己的生成器，并且需要为你引入的任何新类型定义自己的生成器。\n生成器具有`Gen a`形式的类型; 这是`a`类型值的生成器。`Gen`类型是`monad`，因此`Haskell`的`do`语法和标准`monadic`函数可用于定义生成器。\n生成器建立在以下函数之上:\n```haskell\n   choose :: Random a => (a, a) -> Gen a\n```\n它可以从一个区间随机选择一个具有均匀分布的值。例如，要在列表的元素之间进行随机选择，请使用\n```haskell\ndo i<-choose (0,length xs-1)\n   return (xs!!i)\n```\n\n#### 在替代品之间选择\n生成器可以有如下形式:\n```haskell\n   oneof <list of generators>\n```\n在列表中的生成器之间以相同的概率选择。例如，\n```haskell\n   oneof [return True, return False]\n```\n生成一个随机布尔值，其值为`true`的概率为一半。\n我们可以使用以下控制结果分布的函数代替:\n```haskell\n   frequency :: [(Int, Gen a)] -> Gen a\n```\n`frequency`从列表中随机选择一个生成器，但是按给定因子加权选择每个备选方案的概率。例如，\n```haskell\n   frequency [(2,return True), (1,return False)]\n```\n将会有三分之二几率产生`True`.\n\n### 测试数据的大小\n测试数据生成器具有隐式大小参数; `quickCheck`从生成小测试用例开始，随着测试的进行逐渐增加大小。\n不同的测试数据生成器以不同的方式解释大小参数: 有些忽略它，而列表生成器，例如，将其解释为生成列表长度的上限。\n您可以随意使用它，因为您希望控制自己的测试数据生成器。\n您可以使用`size`参数获取它的值:\n```haskell\n  sized :: (Int -> Gen a) -> Gen a\n```\n`size g`调用`g`，将当前大小作为参数传递给它。例如，要生成`0`到`size`范围内的自然数，请使用\n```haskell\n  sized $ \\n -> choose (0, n)\n```\n大小控制的目的是确保测试用例足够大以显示错误，同时保持足够小以便快速测试。有时默认大小控件无法实现此目的。例如，在测试运行结束时，任意列表最多可包含50个元素，因此任意列表的列表最多可能有2500个，这对于高效测试来说太大了。在这种情况下，显式修改`size`参数会很有用。你可以用\n```haskell\n  resize :: Int -> Gen a -> Gen a\n```\n`resize n g`调用`size`参数为`n`的生成器`g`。`size`参数永远不应该是负数。例如，要生成随机矩阵，可能需要采用原始大小的平方根:\n```haskell\n  matrix = sized $ \\n -> resize (round (sqrt n)) arbitrary\n```\n#### 生成递归数据类型\n递归数据类型的生成器很容易使用`oneof`或`frequency`来表示构造函数和`Haskell`的标准`monadic`组合器，以便为每种情况形成生成器。\n例如，如果树的类型由以下类型定义:\n```haskell\ndata Tree = Leaf Int | Branch Tree Tre\n```\n那么一个树的生成器可能为如下这样:\n```haskell\ntree = oneof [liftM Leaf arbitrary,\n\t      liftM2 Branch tree tree]\n```\n但是，像这样的递归生成器可能无法终止或产生非常大的结果。为避免这种情况，递归生成器应始终使用大小控制机制。例如，\n```haskell\ntree = sized tree'\ntree' 0 = liftM Leaf arbitrary\ntree' n | n>0 = \n\toneof [liftM Leaf arbitrary,\n\t       liftM2 Branch subtree subtree]\n  where subtree = tree' (n `div` 2)\n```\n注意:\n* 我们通过在大小为零时强制结果为叶子来保证终止。\n* 我们在每次递归时将大小减半，以便大小给出树中节点数的上限。 我们可以自由地解释尺寸。\n* 我们在分支的两个分支之间共享子树生成器的事实当然不意味着我们在每种情况下生成相同的树。\n\n#### 有用的生成器组合器\n如果`g`是一个类型`t`的生成器,那么:\n* 两个`g`产生一对`tS`，\n* 3个`g`产生三倍的`tS`，\n* 4个`g`产生四倍的`tS`，\n* `vector n g`生成一个`n tS`列表。\n如果`xs`是列表，则元素`xs`生成`xs`的任意元素。\n\n### Arbitrary类\n`QuickCheck`使用`Haskell`的重载机制为每种类型定义默认测试数据生成器。这是使用该类完成的:\n```haskell\nclass Arbitrary a where\n  arbitrary   :: Gen a\n  coarbitrary :: a -> Gen b -> Gen b\n```\n`QuickCheck`为类型 `()`，`Bool`，`Int`，`Integer`，`Float`，`Double`，`pair`，`triples`，`quadruples`，`lists`和`functions`定义了实例。\n类方法`arbitrary`是类型`a`的默认生成器。\n你可以为任意其他类型声明一个默认生成器，通过声明一个`Arbitrary`类的实例，并实现`arbitrary`方法。\n\n类方法`coarbitrary`用于生成随机函数值：类型`a-> b`的`arbitrary`的实现对类型`a`使用`coarbitrary`。如果你只想生成`a`类型的随机值，你只需要为该类型定义方法`arbitrary`，而如果你想在类型上生成随机函数，那么你应该定义两个类方法。\n\n`coarbitrary`方法将类型`a`的值解释为生成器变换器。应对其进行定义，以便将不同的值解释为独立的生成器变压器。这些可以通过使用以下函数实现:\n```haskell\n  variant :: Int -> Gen a -> Gen a\n```\n对于不同的自然数`i`和`j`，`variant i g`和`variant j g`是独立的生成器变压器。\n`variant`的参数必须是非负的，为了提高效率，应该很小。\n`coarbitrary`的实例可以通过将由`variant`构造的生成器变换器组合在一起来定义。\n例如，如果`tree`的类型定义如下:\n```haskell\n  data Tree = Leaf Int | Branch Tree Tree\n```\n然后可以通过如下代码定义一个合适的`Arbitrary`实例:\n```haskell\ninstance Arbitrary Tree where\n  arbitrary = sized tree'\n    where tree' 0 = liftM Leaf arbitrary\n\t  tree' n | n>0 = \n\t\toneof [liftM Leaf arbitrary,\n\t          liftM2 Branch subtree subtree]\n  \t    where subtree = tree' (n `div` 2)\n  coarbitrary (Leaf n) = \n\tvariant 0 . coarbitrary n\n  coarbitrary (Branch t1 t2) = \n\tvariant 1 . coarbitrary t1 . coarbitrary t2\n```\n#### 函数的属性\n`QuickCheck`可以生成随机函数值，从而检查函数的属性。例如，我们可以检查函数组合的相关性如下:\n```haskell\nprop_ComposeAssoc f g h x =\n  ((f . g) . h) x == (f . (g . h)) x\n  where types = [f, g, h] :: [Int->Int]\n```\n但是，在我们测试这样的属性之前，我们必须确保可以打印函数值(如果找到了反例).也就是说，函数类型必须是`Show`类的实例。要实现这个，你必须将模块`ShowFunctions`导入到包含这种高阶属性的每个模块中。如果找到反例，则功能值将显示为`<function>`.\n\n### 提示: 使用newtype\n`QuickCheck`可以轻松地将测试数据生成器与每种类型相关联，但有时您需要不同的分发。例如，假设您正在测试一个操作语法树的程序，并使用变量的构造函数:\n```haskell\n data Expr = Var String | ...\n```\n尽管变量名称表示为字符串，但字符串的默认测试数据生成器不太可能为变量名称生成良好的分布。 例如，如果您正在生成随机表达式，您可能希望有时在测试数据中出现名称冲突，但是两个随机生成的字符串(例如`p}v(\\231\\156A`.)不太可能发生冲突。\n当然，您可以为变量名称编写自定义测试数据生成器，也可以从一个小集合中随机选择，并尝试记住在字符串扮演名称角色的任何地方使用它。但这很容易出错。更好的方法是定义一个名称的新类型，与`String`同构，并使您的自定义生成器成为它的默认值。例如:\n```haskell\nnewtype Name = Name String\n\ninstance Arbitrary Name where\n  arbitrary = oneof [\"a\", \"b\", \"c\", \"d\", \"e\"]\n```\n如果您小心使用`Name`类型，无论您的名字是什么，那么您的属性将更容易编写并且经常都是正确的！\n\n","tags":["QuickCheck"]},{"title":"英语语法学习笔记-名词短语与冠词","url":"/blog/2019/06/21/英语语法学习笔记-名词短语与冠词/","content":"\n### 名词短语结构\n\n### 什么时候不需要用限定词\n\n### 专有名词与补语位置\n\n\n\n","tags":["冠词"]},{"title":"英语语法学习笔记-补语","url":"/blog/2019/06/21/英语语法学习笔记-补语/","content":"### 5种单句基本句型\n```\n#主语 Subject\n#动词 Verb\n#宾语 Object\n#补语 Complemnt\n1. S + V\t\t(主语 + 动词)\n2. S + V + O\t\t(主语 + 动词 + 宾语)\n3. S + V + C\t\t(主语 + 动词 + 补语)\n4. S + V + O + O\t(主语 + 动词 + 宾语 + 宾语)\n5. S + V + O + C\t(主语 + 动词 + 宾语 + 补语)\n```\n\n### 及物动词/不及物动词\n一个完整的句子，必须能够表达完整的意思。这需要两部分来完成: 主语和动词。主语，是这个句子所描述的对象。动词，构成描述的主要内容。例如:\n```\n1. John Smith died in World War Two. (S + V)\n   (约翰史密斯死于第二次世界大战.)\n\n2. John Smith killed three enemy soldiers. (S + V + O)\n   (约翰史密斯杀死了三名敌军士兵.)\n```\n第1个例子中，主语为`John Smith`，表明这句话是要告诉你有关`John Smith`的事情，是什么事情呢？他死了(动词`died`表明叙述的主要内容)！至于他是死于第一次世界大战，还是第二次世界大战是可有可无的细节(以介词短语`in World War Two`来修饰)，因此，第1个例子写成`John Smith died`，也可以构造成完整，正确的句子。\n像`die`种动作，可以独立发生，不牵涉到别的人和物的动词，就称为`不及物`动词。而第2个例子中的`kill`动作，则必须发生在另一个对象身上，因为要做出`杀`的动作，就必须有一个`被杀`的东西，因此`kill`这种动词就是`及物`动词，它后面通常会有一个宾语来`接受`这个动作，在这个例子中，`three enemy soldiers`就是做为宾语。\n \n### be动词\n上一节例2中，如果省略掉宾语`three enemy soldiers`，主语+动词`John Smith killed`依旧可以表示为一个句子(虽然没有表达出完整的意思): 约翰史密斯杀了人，只不过没有具体表明杀了谁。\n而如果句子中省略了补语，就不能表达出完整的意思。\n在所有的英语动词中，不论是`及物`动词还是`不及物`动词，都要担任起`叙述全句最主要内容`的工作，只有解释为`是`的动词没有叙述能力(没有任何意义)，只能扮演`引导叙述/串联`的角色。例如: \n```\n3. John Smith was a soldier. (S + V + C)\n   (约翰史密斯是军人.)\n```\n在例3中，主语仍然是`John Smith`，但是动词`was`就和前面例子中的动词`die/kill`不一样了，因为`was`并没有告诉我们有关`John Smith`的任何事情，叙述主要内容的工作落在了后面的补语`a soldier`上，动词`was`在这里只是起到了`串联`的作用。\n\n### 不必翻译的动词: be动词\n```\n4. John Smith was courageous. (S + V + C)\n   (约翰史密斯很勇敢.)\n\n5. The soup is too hot. (S + V + C)\n   (汤太烫了.)\n```\n例4中的`was`和例5中的`is`更能说明: 解释为`是`的动词没有叙述能力，完全没有任何意义。\n因为在中文翻译中，`是`被完全去掉了，如果翻译成`汤是太汤了`就不像中文的说话口吻了。\n在英文中，`is`是动词不可以丢掉，但是它不像其他动词能叙述出主要内容，如果只说`John Smith was`，`The soup is`，那么这些句子通常都是错的，而且没有意义。因为动词`是`缺乏叙述能力。\n\n### 补语定义\n解释为`是`的动词，因为没有叙述能力，只能把主语和主语后面构成叙述的部分连接起来，所以它又称作`连缀动词(Linking Verb)`。跟在这种动词后面的部分，因为替代了动词所扮演的叙述角色，补足句子使之获得完整的意思，因此称作`补语(Complement)`。\n\n### 需要补语的动词有哪些?(S+V+C)\n`be动词`直接翻译为`是`，是最有代表性的`连缀动词`，在所有的英语动词中，凡是接补语的动词(`连缀动词`)都可以解释为各种各样的`是`:\n```\nlook\t看起来是\nseem\t似乎是\nappear\t显得是\nsound\t听起来是\nfeel\t摸起来是\ntaste\t尝起来是\nturn\t转变为\nprove\t证实为\nbecome\t成为\nmake\t做为\n```\n一个主语使用如上的任意动词，都不能构成一个有意义的完整句子，需要使用补语补足。例如:\n```\n1. That dress looks pretty. (S + V + C) \n   (那件裙子很好看)\n\n2. The dog seems friendly. \n   (那只狗看起来很友善)\n\n3. His demands appear reasonable. \n   (他的要求显得很合理)\n\n4. He became a teacher.\n   (他当了教师)\n\n5. A nurse makes a good wife. \n   (娶护士做太太真不错)\n```\n如果将以上例子中各式各样的`是`替换成纯粹的`是`(`be动词`)，句子的句型和语义都没有太大变化。这就是`S + V + C`的句型`(主语补语)`.\n\n### 宾语补语的句型(S+V+O+O)\n`主语+动词+补语(主语补语)`的句型是用补语告诉读者主语是什么，中间用表示为`是`的动词串联起来。\n`主语+动词+宾语+补语(宾语补语)`的句型则是用补语告诉读者宾语是什么，中间暗示有一个`是`的关系存在。例如:\n```\n1. I find the dress pretty. (S + V + O + C)\n   (我发现这衣服很漂亮)\n\n2. The meat made the dog friendly. \n   (肉让狗变得友善)\n\n3. They consider his demands reasonable. \n   (他们认为他的要求是合理的)\n   \n4. His college training made him a teacher. \n   (他的大学教育使他成为一名教师)\n\n5. Most people consider a nurse a good wife. \n   (大多数的人认为护士会是称职的太太)\n```\n例如第1个例子: 宾语`the dress`和补语`pretty`之间虽然没有`是`字，但是带有这种暗示存在。如果加个`be动词`进去就变成了上一节介绍的主语补语句子: `That dress is pretty`。\n其实这也是检验`S + V + O + C`句型最简便的方法: 把句子中的宾语和补语拿出来，中间加入`be动词`，看看能否变成`S + V + C`句型。\n\n### 补语的词类\n```\n1. John Smith was a soldier. (S + V + C)\n   (约翰史密斯是军人)\n2. The military academy made John Smith a soldier. (S + V + O + C) \n   (军校训练使约翰史密斯成为军人)\n\n3. John Smith was courageous. (S + V + C)\n   (约翰史密斯很勇敢)\n4. I consider John Smith courageous. (S + V + O + C)\n   (我认为约翰史密斯很勇敢)\n```\n补语的词类，应该是名称和形容词比较合理。\n因为主语或宾语都是名词，所以补语也可以为名词，然后经由动词`是`的连接来表达同等的关系。另外修饰名词的修饰语就是形容词，因此补语也可以为形容词。\n例1中`John Smith`为主语，`a soldier`为主语补语，词类都是名词。\n例2中`John Smith`为宾语，`a soldier`为宾语补语，但词类仍然为名词。\n例3中主语补语`courageus`为形容词，因而可以经由动词`是`的引导来修饰主语`John Smith`是怎样的人。\n例4中`courageus`为宾语补语，词类没有变化，仍然为形容词。\n\n### 没有补语的be动词(S+V)\n`be动词`是最纯粹的`连缀动词`，解释为`是`，后面应该要有补语句子才算完整。如果看到`be动词`后面没有补语，表示这个`be动词`并不是作为`连缀动词`来使用，此时，`be动词`并不解释为`是`，而是要解释为`存在`。用在最单纯的`主语+宾语`句型中。\n```\n1. I think;therefore I am. \n   (我思故我在)\n\n2. To be or not to be,that is the question. \n   (生存还是毁灭,这是个问题)\n```\n例1中，`I am`不可以翻译为`我是`，如果`am`作为`连缀动词`使用，后面必须有补语来说明`是什么`，在没有补语的情况下，`I am`就得翻译成`我存在`了。\n同理，例2中，`To be or not to be`应该翻译成`要存在还是不要存在`。\n\n### 有两个宾语的句型(S+V+O+O)\n有两个宾语的句型，即: `主语 + 动词 + 宾语 + 宾语`，需要和`主语 + 动词 + 宾语 + 补语`的句型区分开。后者的宾语和补语也可以都是名词，但宾语和补语之间存在`等于是`的关系。\n```\n1. John's father gave him a dog. (约翰的父亲给他一只狗)\n2. John's father called him a dog. (约翰的父亲骂他是狗)\n```\n例1中，`him`和`a dog`都是宾语，其中`him`是`gave`的对象，`a dog`是`gave`的东西，两个都是名词，且并不相等。\n例2中，`him`是宾语，`a dog`是补语，因为有`他是狗`的意思在，所以`a dog`是`him`的补语。\n\n### 练习\n请判断以下句子属于五种基本句型中的哪一种?\n```\n1. The magician moved his fingers quickly. (S + V + O)\n   (魔术师迅速移动他的手指.)\n\n2. The police found the letter missing. (S + V + O + C)\n   (警察发现那封信丢失了.)\n   \n3. The police found the missing letter. (S + V + O)\n   (警察找到了丢失的信.)\n\n4. He ordered himself a steak and a bottle of red wine. (S + V + O + O)\n   (他点了一份牛排和一瓶红酒.)\n\n5. Don't you like dancing? (S + V + O)\n   (你不喜欢跳舞么?)\n\n6. The President has gone abroad on a visit. (S + V)\n   (总统出国访问了.)(President/has gone)\n\n7. That sounds like a good idea. (S + V + C)\n   (听起来像是个好主意.)\n\n8. The box feels heavy. (S + V + C)\n   (盒子摸起来很重.)\n\n9. He told his guests a dirty joke at the party. (S + V + O + O)\n   (他在聚会上给客人讲了个下流的笑话.)\n\n10. The people elected Bill Clinton President. (S + V + O + C)\n    (人民选举比尔克林顿为总统.)\n\n11. The child asks her mother a million questions a day. (S + V + O + O)\n    (这个孩子每天问他妈妈一百万个问题.)\n\n12. Monkeys love bananas. (S + V + O)\n    (猴子喜欢香蕉.)\n\n13. You can leave the door open. (S + V + O + C)\n    (你可以把门开着.)\n\n14. The company has gone bankrupt. (S + V + C)\n    (这家公司已经破产了.)(company/has gone/bankrupt)\n\n15. Why don't you answer me? (S + V + O) \n    (为什么不回答我?)\n\n16. I consider you a member of the family. (S + V + O + C)\n    (我认为你是家庭的一员.)(I/consider/you/member)\n\n17. It never rains in California. (S + V)\n    (加利福尼亚从不下雨.)\n\n18. You'll look better with these designer glasses on. (S + V + C)\n    (你戴上这幅名牌眼睛会好看些.)\n\n19. I can see better without these reading glasses. (S + V)\n    (我不戴老花镜能看的更清楚些.)\n\n20. Do you call me liar? (S + V + O + C)\n    (你说我撒谎么?)\n```\n\n\n\n","tags":["补语"]},{"title":"深入理解Haskell-IO","url":"/blog/2019/05/29/深入理解Haskell-IO/","content":"> 本文翻译自[维基百科](https://wiki.haskell.org/IO_inside),想要看原文的可以去那里查看.\n\n### IO内部\nHaskell I/O一直是新Haskellers混乱和惊喜的根源。虽然Haskell中的简单I/O代码看起来非常类似于命令式语言中的等价物，但尝试编写更复杂的代码通常会导致完全混乱。这是因为Haskell I/O内部真的非常不同。Haskell是一种纯语言，甚至I/O系统也无法打破这种纯度。\n以下正文试图解释Haskell I/O实现的细节，这个解释应该可以帮助你最终掌握所有的智能I/O技巧。此外，我已经添加了您可能遇到的各种陷阱的详细说明。阅读本文后，您将获得\"Haskell I/O大师\"学位，该学位同等于计算机科学和数学学士学位。\n如果您是Haskell I/O新手，您可能更愿意从阅读[IO简介](https://wiki.haskell.org/Introduction_to_IO)开始\n\n#### Haskell是一门纯语言\nHaskell是一门纯语言，这意味着任何函数调用的结果完全由其参数决定，像C中的`rand()`或`getchar()`这样的伪函数在每次调用时都会返回不同的结果，这些函数根本不可能在Haskell中编写。而且，Haskell函数不能有副作用，这意味着这些函数不能对\"真实世界\"做任何更改，例如：更改文件/写入文件/打印/通过网络发送数据等。这两个限制一起意味着任何函数调用都可以被具有相同参数的先前调用的结果替换，并且语言保证所有这些重新排列不会改变程序结果!\n\n让我们将其与C语言进行比较: 优化C编译器尝试猜测哪些函数没有副作用，并且不依赖于可变全局变量。如果这个猜测错了，优化可以改变程序的语义！为了避免这种灾难，C优化器在猜测中是保守的，或者需要程序员提供有关函数纯度的提示。\n\n与优化的C编译器相比，Haskell编译器是一组纯数学转换。这导致更好的高级优化设施。此外，纯数学计算可以更容易地分成几个可以并行执行的线程，这在多核CPU的这些日子里越来越重要。最后，纯计算不易出错且更容易验证，这增加了Haskell的稳健性和使用Haskell的程序开发速度。Haskell纯度允许编译器只调用其结果确实需要计算高级函数的最终值的函数(例如: main) - 这称为惰性求值。纯粹的数学计算是件好事，但是I/O动作怎么样？函数如下:\n```haskell\nputStrLn \"Press any key to begin formatting\"\n```\n不能返回任何有意义的结果值，那么我们如何确保编译器不会省略或重新排序其执行？总的来说，我们如何使用完全惰性的语言处理有状态的算法和副作用？这个问题在18年的Haskell开发中提出了许多不同的解决方案(参见Haskell的历史)，尽管现在基于monads的解决方案已成为标准。\n\n#### monad是什么?\n什么是monad? 这是来自数学范畴理论的东西，我不知道了。为了理解monad如何用于解决I/O和副作用的问题，您不需要知道它。就像我一样，只知道小学数学就足够了。\n让我们想象一下，我们想在Haskell中实现众所周知的`getchar`函数。它应该有什么样的类型？我们试试吧：\n```haskell\ngetchar :: Char\n\nget2chars = [getchar,getchar]\n```\n只有`Char`类型的`getchar`函数会得到什么？您可以在`get2chars`的定义中看到所有可能出现的问题：\n* 因为Haskell编译器将所有函数视为纯函数(没有副作用)，所以它可以避免对`getchar`的\"过度\"调用, 并使用两次返回值.\n* 即使它确实进行了两次调用，也无法确定应首先执行哪个调用。你想按照阅读顺序或相反的顺序返回两个字符吗？`get2chars`定义中没有任何内容可以回答这个问题。\n\n从程序员的角度来看，如何解决这些问题呢？\n让我们为`getchar`函数增加一个\"伪装\"的参数，使每个调用与编译器的观点\"不同\":\n```haskell\ngetchar :: Int -> Char\n\nget2chars = [getchar 1, getchar 2]\n```\n马上，这解决了上面提到的第一个问题 - 现在编译器将进行两次调用，因为编译器将它们视为具有不同的参数。整个`get2chars`函数也应该有一个\"伪装\"参数，否则我们会遇到同样的问题：\n```haskell\ngetchar   :: Int -> Char\nget2chars :: Int -> String\n\nget2chars _ = [getchar 1, getchar 2]\n```\n现在我们需要给编译器一些线索来确定它应该首先调用哪个函数。Haskell语言没有提供任何表达评估顺序的方法......除了数据依赖性！如何添加一个人工数据依赖项，以防止在第一个`getchar`之前评估第二个`getchar`？为了实现这一目标，我们将从`getchar`函数返回一个额外的\"伪装\"结果，该\"伪装\"结果将用作下一个`getchar`函数调用的参数：\n```haskell\ngetchar :: Int -> (Char, Int)\n\nget2chars _ = [a,b]  where (a,i) = getchar 1\n                           (b,_) = getchar i\n```\n到目前为止还不错 - 现在我们可以保证在读`b`之前读取`a`，因为读`b`需要通过读`a`返回的值(`i`)!\n我们在`get2chars`中添加了一个\"伪装\"参数，但问题是Haskell编译器太聪明了! 它可以相信外部`getchar`函数真的依赖于它的参数，但是对于`get2chars`函数，它会看到我们是在作弊，因为我们扔掉了它(参数使用了_占位符)! 因此，编译器不会觉得有必要按照我们想要的顺序执行调用。我们该如何解决这个问题? 将这个\"虚假\"的参数传递给`getchar`函数怎么样?! 这样的话，编译器就无法猜测它是否真的未使用过。\n\n```haskell\nget2chars i0 = [a,b]  where (a,i1) = getchar i0\n                            (b,i2) = getchar i1\n```\n还有更多 - `get2chars`具有与`getchar`功能相同的纯度问题。\n如果需要调用`get2chars`两次，则需要一种方法来描述这些调用的顺序。看着：\n```Haskell\n-- order of 'get2chars' calls isn't defined 未定义'get2chars'调用的顺序\nget4chars = [get2chars 1, get2chars 2]  \n```\n我们已经知道如何处理这些问题 - `get2chars`函数也应该返回一些可以用来顺序调用的\"伪装\"值：\n```Haskell\nget2chars :: Int -> (String, Int)\n\nget4chars i0 = (a++b)  where (a,i1) = get2chars i0\n                             (b,i2) = get2chars i1\n```\n但是`get2chars`函数应该返回什么\"伪装\"值？如果我们使用一些整数常量，那么过于聪明的Haskell编译器会猜测我们想再次作弊。如何返回`getchar`函数返回的值？看：\n```Haskell\nget2chars :: Int -> (String, Int)\nget2chars i0 = ([a,b], i2)  where (a,i1) = getchar i0\n                                  (b,i2) = getchar i1\n```\n信不信由你，但我们刚刚已经构建了整个`monadic` Haskell I/O系统。\n\n#### 欢迎来到真实世界，宝贝\n警告：关于IO的以下故事是不正确的，因为它无法实际解释IO的一些重要方面（包括交互和并发）。但是，有些人发现开始理解是有用的。\nHaskell `main`函数具有以下类型:\n```Haskell\nmain :: RealWorld -> ((), RealWorld)\n```\n其中`RealWorld`是一种\"伪装\"的类型，用来替换我们的Int。\n这就像在接力赛中接过的接力棒。当`main`函数调用某些IO函数时，它将作为参数收到的\"RealWorld\"传递给了IO函数。所有IO函数都有类似的类型，涉及`RealWorld`作为参数和结果。确切地说，`IO`是以下列方式定义的类型同义词：\n```Haskell\ntype IO a  =  RealWorld -> (a, RealWorld)\n```\n因此，`main`函数只有类型`IO()`，`getChar`函数有类型`IO Char`,等等。您可以将`IO Char`类型视为\"获取当前的`RealWorld`，对其执行某些操作，并返回`Char`和（可能已更改的）`RealWorld`。让我们看`main`调用`getChar`两次：\n```Haskell\ngetChar :: RealWorld -> (Char, RealWorld)\n\nmain :: RealWorld -> ((), RealWorld)\nmain world0 = let (a, world1) = getChar world0\n                  (b, world2) = getChar world1\n              in ((), world2)\n```\n仔细看看：`main`函数将收到的`world0`传递给第一个`getChar`函数。 这个`getChar`函数返回一些`RealWorld`类型的新值，它将在下一次调用中使用。最后，`main`返回它从第二个`getChar`获得的`world2`。\n* 如果没有使用它读取的字符，这里是否可以省略任何`getChar`调用？不，因为我们需要返回第二个`getChar`结果的`world2`，这又需要从第一个`getChar`返回的`world1`。\n* 是否可以重新排序`getChar`调用？ 否：第二个`getChar`在第一个之前无法调用，因为它使用了第一次调用返回的`world1`.\n* 是否可以重复调用？ 在Haskell语义中 - 是的，但真正的编译器永远不会在这种简单的情况下重复工作（否则，生成的程序将没有任何速度保证）。\n\n正如我们已经说过的那样，RealWorld值被用作一个接力棒，它在严格的顺序中被`main`调用的所有例程之间传递。在每个例程中，RealWorld值以相同的方式使用。 总的来说，为了\"计算\"从`main`返回的`world`，我们应该直接或间接地执行从`main`调用的每个IO过程。这意味着插入链中的每个程序都将在我们打算调用它时执行(相对于其他IO操作)。让我们考虑以下程序：\n```Haskell\nmain = do a <- ask \"What is your name?\"\n          b <- ask \"How old are you?\"\n          return ()\n\nask s = do putStr s\n           readLn\n```\n现在你有足够的知识以低级别方式重写它，并检查每个应该执行的操作是否真的将使用它应该具有的参数并按照我们期望的顺序执行(练习)。\n但是条件执行呢？没问题。让我们定义众所周知的`when`操作：\n```Haskell\nwhen :: Bool -> IO () -> IO ()\nwhen condition action world =\n    if condition\n      then action world\n      else ((), world)\n```\n如您所见，我们可以根据数据值轻松地在执行链中包含或排除IO过程(操作)，如果在`when`的调用中`condition`为False，那么`action`将永远不会被调用，因为真实的Haskell编译器，从不调用其结果不用于最终结果的函数(例如: 这里main函数的`world`最终值)。循环和更复杂的控制结构可以以相同的方式实现。试试看吧！\n最后，你可能想要知道，在程序中传递这些RealWorld值需要花费的成本，它是免费的，这些\"伪装\"值仅在编译器分析和优化代码时存在，但是当它进入汇编代码生成时，它\"突然\"意识到这种类型就像`()`，因此所有的这些参数和结果值都可以从最终生成的代码中省略。这不漂亮吗？\n\n#### `>>=` 和 `do` 表示法\n所有初学者(包括我)都认为`do`是执行IO动作的魔术语句。那是错的,`do`只是语法糖，它简化了使用IO(以及其他monad的程序)的编写，但这超出了本教程的范围。`do`符号最终被转换为传递`world`值的语句，就像我们上面手动编写的那样，用于简化几个IO操作的粘合。您不需要只为一条语句使用`do`语句,例如:\n```Haskell\nmain = do putStr \"Hello!\"\n```\n脱糖后:\n```Haskell\nmain = putStr \"Hello!\"\n```\n让我们来看看如何在下面的例子中使用多个语句来解释`do`\n```Haskell\nmain = do putStr \"What is your name?\"\n          putStr \"How old are you?\"\n          putStr \"Nice day!\"\n```\n这里的`do`语句只是加入了应该按顺序执行的几个IO动作。它被翻译成一个所谓的\"绑定运算符\"的顺序应用程序，即`>>`：\n```Haskell\nmain = (putStr \"What is your name?\") >> ((putStr \"How old are you?\") >> (putStr \"Nice day!\"))\n```\n这个绑定操作符只是结合了两个IO动作，通过在它们之间传递`world`来顺序执行它们：\n```Haskell\n(>>) :: IO a -> IO b -> IO b\n(action1 >> action2) world0 =\n   let (a, world1) = action1 world0\n       (b, world2) = action2 world1\n   in (b, world2)\n```\n如果以这种方式定义运算符对您来说很奇怪，请按以下方式阅读此定义：\n```Haskell\naction1 >> action2 = action\n  where\n    action world0 = let (a, world1) = action1 world0\n                        (b, world2) = action2 world1\n                    in (b, world2)\n```\n现在，您可以在使用`>>`的位置替换其定义，并检查由`do`语法糖构造的程序实际上与我们通过手动操作`world`值编写的程序相同。\n\n更复杂的示例涉及使用`<-`绑定的变量：\n```Haskell\nmain = do \n   a <- readLn\n   print a\n```\n这段代码可以脱糖为:\n```Haskell\nmain = readLn >>= (\\a -> print a)\n```\n正如您应该记住的那样,`>>`绑定操作符默默地忽略其第一个`action`的值，仅将其第二个`action`的结果做为整体结果返回。\n另一方面,`>>=`绑定操作符(注意末尾的额外'=')允许我们使用其第一个`action`的结果, 并将其作为附加参数传递给第二个`action`,看看定义：\n```Haskell\n(>>=) :: IO a -> (a -> IO b) -> IO b\n(action1 >>= action2) world0 =\n   let (a, world1) = action1 world0\n       (b, world2) = action2 a world1\n   in (b, world2)\n```\n首先,第二个`action`的类型(更准确地说,是一个返回IO action的函数),即`a -> IO b`是什么意思? \n通过替换IO定义,我们得到`a -> RealWorld -> (b, RealWorld)`,这意味着第二个action实际上有两个参数: 实际在其中使用的类型`a`,以及用于IO action排序的`RealWorld`类型的值. \n情况总是如此,与您在其类型签名中看到的相比较,任何IO过程都另有一个参数,此参数隐藏在别名\"IO\"的定义中。\n其次,您可以使用`>>`和`>>=`这些操作来简化您的程序。例如,在上面的代码中我们不需要引入变量a,因为`readLn`的结果可以直接发送到`print`:\n```Haskell\nmain = readLn >>= print\n```\n第三,如你所见,符号：\n```Haskell\ndo x <- action1\n    action2\n```\n其中`action1`的类型为`IO a`,而`action2`的类型为`IO b`,转换为：\n```Haskell\naction1 >>= (\\x -> action2)\n```\n其中`>>=`的第二个参数的类型为`a -> IO b`,这就是处理`<-`绑定的方式: `<-`左侧的名称只是后续操作的一个参数,表示为一个大的IO action.\n另请注意,如果`action1`的类型为`IO a`,那么`x`将只有类型`a`; 您可以将`<-`的效果视为将`action1`的IO值\"解包\"为`x`.\n还要注意`<-`不是真正的运算符,它是纯语法,就像`do`本身一样,它的含义只取决于它被脱糖的方式.\n\n看下一个例子:\n```Haskell\nmain = do putStr \"What is your name?\"\n          a <- readLn\n          putStr \"How old are you?\"\n          b <- readLn\n          print (a,b)\n```\n这段代码可以脱糖为:\n```Haskell\nmain = putStr \"What is your name?\"\n       >> readLn\n       >>= \\a -> putStr \"How old are you?\"\n       >> readLn\n       >>= \\b -> print (a,b)\n```\n我在这里省略了括号,`>>`和`>>=`运算符都是左关联的,但是lambda绑定总是尽可能向右延伸,这意味着这里引入的`a`和`b`绑定对所有剩余的动作都有效.\n作为练习,自己添加括号并将此过程转换为显式传递`world`值的低级代码(练习),我认为这应该足以帮助您最终了解`do`转换和绑定操作符`>>=`的工作原理.\n\n不好,我忘记了第三个monadic运算符: `return`,它只是结合了它的两个参数: 传递的值和`world`:\n```Haskell\nreturn :: a -> IO a\nreturn a world0 = (a, world0)\n```\n转换一个简单的`return`用法示例怎么样？说，\n```Haskell\nmain = do a <- readLn\n          return (a*2)\n```\n具有命令式语言背景的程序员通常认为Haskell中的`return`与其他语言一样,会立即从IO过程返回.正如你在其定义中看到的那样(甚至只是从它的类型),这样的假设是完全错误的,\n使用`return`的唯一目的是将一些值(类型为'a')`lift`到整个动作的结果中(类型为`IO a`),因此它通常应该仅用作某个IO序列的最后执行语句,例如,尝试将以下过程转换为相应的低级代码(练习)：\n```Haskell\nmain = do a <- readLn\n          when (a>=0) $ do\n              return ()\n          print \"a is negative\"\n```\n并且您将意识到即使对于`a`的非负值,也会执行`print`语句. 如果需要从IO过程中间退出,可以使用`if`语句:\n```Haskell\nmain = do a <- readLn\n          if (a>=0)\n            then return ()\n            else print \"a is negative\"\n```\n而且，Haskell设计规则允许我们使用以下设计:\n```v\nmain = do a <- readLn\n          if (a>=0) then return ()\n            else do\n          print \"a is negative\"\n          ...\n```\n这可能有助于从冗长的`do`语句中逃脱。\n\n最后一个练习: 实现一个函数`liftM`.它将普通值的操作提升到monadic的操作,它的类型签名:\n```Haskell\nliftM :: (a -> b) -> (IO a -> IO b)\n```\n如果这对您来说太难了,请从以下高级定义开始并以低级方式重写它(练习):\n```Haskell\nliftM f action = do \n\t    x <- action\n            return (f x)\n```\n\n#### 可变数据(引用/数组/哈希表)\n正如您应该知道的,Haskell中的每个名称都绑定到一个固定(不可变)值,这大大简化了理解算法和代码优化,但在某些情况下这是不合适的,众所周知,有许多算法在可更新变量,数组等方面更容易实现.\n这意味着与变量关联的值(例如,在不同的执行点)可能不同,因此读取其值不能视为纯函数.想象一下,例如,以下代码:\n```Haskell\nmain = do let a0 = readVariable varA\n              _  = writeVariable varA 1\n              a1 = readVariable varA\n          print (a0, a1)\n```\n这看起来很奇怪吗? 首先,对`readVariable`的两次调用看起来是一样的,因此编译器可以只重用第一次调用返回的值. 其次,不使用`writeVariable`调用的结果,因此编译器可以(并且将会)完全省略此调用,为了完成描述,这三个调用可以按任何顺序重新排列,因为它们看起来彼此独立,这显然不是预期的. 解决方案是什么？你已经知道了, 使用IO actions, 使用IO actions可确保完成:\n* 按照书面形式的顺序执行\n* 每个action都必须执行\n* 相同action的结果将不会被重用(例如: `readVariable varA`)\n所以,上面的代码应该写成:\n```Haskell\nimport Data.IORef\nmain = do varA <- newIORef 0  -- Create and initialize a new variable\n          a0 <- readIORef varA\n          writeIORef varA 1\n          a1 <- readIORef varA\n          print (a0, a1)\n```\n这里,`varA`的类型为`IORef Int`,意思是\"IO monad中的一个变量(引用),持有一个类型为Int的值\",`newIORef`创建一个新变量(引用)并返回它,然后使用此引用进行读/写操作,`readIORef varA`操作返回的值不仅取决于所涉及的变量,还取决于执行此操作的时刻,因此它可以在每次调用时返回不同的值. 数组,散列表和任何其他_mutable_数据结构以相同的方式定义,对于每个数据结构,都有一个操作可以创建新的\"可变值\"并返回对它的引用,然后使用`IO monad`中的特殊读写操作,以下代码显示了使用可变数组的示例:\n```Haskell\nimport Data.Array.IO\nmain = do arr <- newArray (1,10) 37 :: IO (IOArray Int Int)\n          a <- readArray arr 1\n          writeArray arr 1 64\n          b <- readArray arr 1\n          print (a, b)\n```\n这里,创建了一个由10个元素组成的数组,其中37作为每个位置的初始值,接着将第一个元素(索引为1)的值读入变量`a`,然后将索引为1的元素的值设置为64,然后再次读入`b`,正如您通过执行此代码所看到的，`a`将设置为37,`b`将设置为64.\n\n其他依赖于状态的操作通常也实现为IO操作,例如,随机数生成器应在每次调用时返回不同的值。给它一个涉及IO的类型看起来很自然：\n```Haskell\nrand :: IO Int\n```\n另外,当你导入C例程时你应该小心,如果这个例程不纯,即它的结果取决于\"真实世界\"(文件系统，内存内容......),内部状态等等,你应该给它是一种IO类型,否则,编译器可以\"优化\"此程序(使用相同参数的程序)的重复调用.\n例如，我们可以为以下内容编写非IO类型：\n```\noreign import ccall\n   sin :: Double -> Double\n```\n因为`sin`的结果只取决于它的论点，但是:\n```Haskell\nforeign import ccall\n   tell :: Int -> IO Int\n```\n如果您将`tell`声明为纯函数(没有IO),那么您可以在每次调用时获得相同的位置.\n\n#### IO actions作为值\n到目前为止,您应该理解为什么在非IO(纯)程序中使用IO操作是不可能的,这样的程序只是没有得到\"接力棒\";他们不知道传递给IO action的任何`world`值,`RealWorld`类型是一种抽象数据类型,因此纯函数也不能自己构造`RealWorld`值,并且它是严格类型,因此也不能使用`undefined`,因此,禁止在纯过程中使用IO操作只是一种类型系统技巧(通常在Haskell中)。\n但是虽然纯代码不能_execute_ IO动作，\n它可以与任何其他功能值一起使用 - 它们可以存储在数据结构中,作为参数传递,作为结果返回,收集在列表中,并部分应用,但IO action仍然是一个功能值,因为我们不能将它应用于最后一个参数 - 类型为RealWorld。\n为了_execute_ IO动作,我们需要将它应用于一些RealWorld值,这只能在一些IO过程中,在其\"action链\"中完成。\n只有当这个过程被调用(作为\"为`main`函数计算world最终值\"过程的一部分时),才会真正执行此操作。\n看看这个例子:\n```Haskell\nmain world0 = let get2chars = getChar >> getChar\n                  ((), world1) = putStr \"Press two keys\" world0\n                  (answer, world2) = get2chars world1\n              in ((), world2)\n```\n这里我们首先将一个值绑定到`get2chars`,然后编写一个涉及`putStr`的绑定,但是执行顺序是什么？它不是由`let`绑定的顺序定义的,它是由处理`world`值的顺序定义的! \n您可以随意重新排序绑定语句,执行顺序将由关于传递的`world`值的数据依赖性定义,让我们看看`do`语法中的`main`是什么样的：\n```Haskell\nmain = do let get2chars = getChar >> getChar\n          putStr \"Press two keys\"\n          get2chars\n          return ()\n```\n正如您所看到的,我们已经消除了两个`let`绑定,只留下了一个定义`get2chars`的绑定,非`let`语句按照它们写入的确切顺序执行,因为如上所述它们将声明中的`world`值传递给声明(语句),因此,这个版本的函数更容易理解,因为我们不必在心理上弄清楚`world`值的数据依赖性.\n\n此外,像`get2chars`这样的IO action不能直接执行,因为它们是具有`RealWorld`参数的函数,要执行它们,我们需要提供`RealWorld`参数,即将它们插入到`main`链中,将它们放在从`main`执行的某些`do`序列中(直接在`main`函数中,或间接在从`main`调用的IO函数中).在完成之前,它们将保留(就像任何部分评估形式的函数),我们可以像使用任何其他函数一样使用IO操作 - 将它们绑定到名称(如上所述),将它们保存在数据结构中,将它们作为函数参数传递并将它们作为结果返回 - 直到你给他们魔法的`RealWorld`参数,他们才会被执行!\n\n##### 示例: IO actions列表\n让我们尝试定义IO actions列表:\n```Haskell\nioActions :: [IO ()]\nioActions = [\n              (print \"Hello!\"),\n              (putStr \"just kidding\"),\n              (getChar >> return ())\n            ]\n```\n我在每个action周围使用了额外的括号，尽管它们并不是真正需要的。如果您仍然无法相信这些操作不会立即执行，请回忆一下此列表的实际类型：\n```Haskell\nioActions :: [RealWorld -> ((), RealWorld)]\n```\n好吧，现在我们要执行其中一些操作。没问题，只需将它们插入`main`链：\n```Haskell\nmain = do head ioActions\n          ioActions !! 1\n          last ioActions\n```\n看起来很奇怪吧？实际上，您在`do`语句中编写的任何IO操作(或用作`>>` / `>>=`运算符的参数)都是一个表达式，为某些类型`a`返回类型`IO a`的结果。\n通常，您使用某些类型为`x -> y -> ... -> IO a`的函数,并提供所有`x,y`等参数。\n但是你并不局限于这个标准场景 - 不要忘记Haskell是一种函数式语言,你可以以任何可能的方式自由计算所需的函数值(回想一下`IO a`实际上是一种函数类型).\n\n这里我们刚从列表中提取了几个函数 - 没问题,正如我们在前面的例子中所做的那样,这个函数值也可以即时构建 - 这也没问题。\n想看到这个函数值作为参数传递？只要看看`when`的定义. 嘿,我们可以像任何其他函数值一样购买,出售和出租这些IO操作! 例如,让我们定义一个执行列表中所有IO actions的函数：\n```Haskell\nsequence_ :: [IO a] -> IO ()\nsequence_ [] = return ()\nsequence_ (x:xs) = do x\n               sequence_ xs\n```\n没有黑魔法 - 我们只是从列表中提取IO actions并将它们插入到一系列IO操作中，这些操作应该一个接一个地执行(按照它们在列表中的顺序)以\"计算整个`sequence_`调用的最终world值\"。\n在`sequence_`的帮助下，我们可以将最后一个`main`函数重写为：\n```Haskell\nmain = sequence_ ioActions\n```\n与任何其他（功能和非功能）值一样，Haskell使用IO操作的能力允许我们定义任意复杂度的控制结构。例如，尝试定义一个重复动作的控制结构，直到它返回`False`结果(练习)：\n```Haskell\nwhile :: IO Bool -> IO ()\nwhile action = ???\n```\n大多数编程语言根本不允许您定义控制结构，而那些允许的通常是需要您使用宏扩展系统的编程语言。在Haskell中，控制结构只是任何人都可以编写的简单函数。\n\n##### 例子: 返回一个IO actions作为结果\n如何通过函数返回IO操作? 好吧,我们每次定义IO过程时都会这样做 - 它们都返回需要执行RealWorld值的IO actions。虽然我们通常只是将它们作为更高级别IO过程的一部分来执行,但也可以在没有实际执行的情况下收集它们：\n```Haskell\nmain = do let a = sequence ioActions\n              b = when True getChar\n              c = getChar >> getChar\n          putStr \"These 'let' statements are not executed!\"\n```\n这些分配的IO过程可以用作其他过程的参数，或者写入全局变量，或者以其他方式处理，或者稍后执行，就像我们在`get2chars`示例中所做的那样。\n但是如何从IO过程返回参数化IO action呢？让我们定义一个过程，该过程从表示为句柄的文件返回第i个字节：\n```Haskell\nreadi h i = do hSeek h AbsoluteSeek i\n               hGetChar h\n```\n到现在为止还挺好。但是，如果一个程序返回具有给定名称的文件的第i个字节，而不是每次都重新打开它？\n```Haskell\nreadfilei :: String -> IO (Integer -> IO Char)\nreadfilei name = do h <- openFile name ReadMode\n                    return (readi h)\n```\n如您所见，这是一个IO过程，它打开一个文件并返回另一个将读取指定字节的IO过程。但我们可以更进一步，在`readfilei`中包含`readi`内容：\n```Haskell\nreadfilei name = do h <- openFile name ReadMode\n                    let readi h i = do hSeek h AbsoluteSeek i\n                                       hGetChar h\n                    return (readi h)\n```\n现在看起来更好了。但是，如果可以从当前定义`readi`的环境中获取作为`readi`参数的`h`，我们为什么要添加`h`? 更短的版本是这样的：\n```Haskell\nreadfilei name = do h <- openFile name ReadMode\n                    let readi i = do hSeek h AbsoluteSeek i\n                                     hGetChar h\n                    return readi\n```\n我们在这做了什么? 我们在`readfilei`中构建了一个涉及本地名称的参数化IO action，并将其作为结果返回。现在可以通过以下方式使用它：\n```Haskell\nmain = do myfile <- readfilei \"test\"\n          a <- myfile 0\n          b <- myfile 1\n          print (a,b)\n```\n这种使用IO操作的方式对于Haskell程序来说非常典型 - 您只需构造一个或多个所需的IO操作(带或不带参数),可能涉及\"构造函数\"接收的参数,并将它们返回给调用者。然后,这些IO操作可以在程序的其余部分中使用,而无需了解您的内部实现策略。可以使用的一件事是部分模拟OOP(或更确切地说ADT)编程范例。\n\n##### 示例：内存分配器生成器\n例如,我的一个程序有一个模块,它是一个内存子分配器。它接收大内存块的地址和大小,并返回两个过程 - 一个用于分配给定大小的子块,另一个用于释放分配的子块：\n```Haskell\nmemoryAllocator :: Ptr a -> Int -> IO (Int -> IO (Ptr b),\n                                       Ptr c -> IO ())\n\nmemoryAllocator buf size = do ......\n               let alloc size = do ...\n                                   ...\n                   free ptr = do ...\n                                 ...\n               return (alloc, free)\n```\n这是如何实现的？`alloc`和`free`函数使用在memoryAllocator过程中创建的引用。由于这些引用的创建是`memoryAllocator IO`操作链的一部分，因此将为每个调用memoryAllocator的内存块创建一组新的独立引用：\n```Haskell\nmemoryAllocator buf size = do start <- newIORef buf\n                 end <- newIORef (buf `plusPtr` size)\n                 ...\n```\n这两个引用是在`alloc`和`free`定义中读取和写入的(我们将为这个例子实现一个非常简单的内存分配器):\n```Haskell\n    let alloc size = do addr <- readIORef start\n                        writeIORef start (addr `plusPtr` size)\n                        return addr\n                        \n    let free ptr = do writeIORef start ptr\n```\n我们在这里定义的只是一对闭包,它们在定义时使用可用的状态。正如您所看到的,尽管Haskell缺乏对不纯函数的直接支持,但它与任何其他函数语言一样简单。\n以下示例使用memoryAllocator返回的过程在两个独立的内存缓冲区中同时分配/释放块：\n```Haskell\nmain = do buf1 <- mallocBytes (2^16)\n          buf2 <- mallocBytes (2^20)\n          (alloc1, free1) <- memoryAllocator buf1 (2^16)\n          (alloc2, free2) <- memoryAllocator buf2 (2^20)\n          ptr11 <- alloc1 100\n          ptr21 <- alloc2 1000\n          free1 ptr11\n          free2 ptr21\n          ptr12 <- alloc1 100\n          ptr22 <- alloc2 1000\n```\n##### 示例: 使用记录类型模拟OOP\n让我们实现经典的OOP示例：绘制图形。有不同类型的数字：圆形，矩形等。任务是创建一个异构的图列表。此列表中的所有图应支持相同的操作集：绘制`draw`，移动`move`等。我们将这些操作表示为IO过程。让我们定义一个包含所有所需过程的实现的结构，而不是`class`：\n```Haskell\ndata Figure = Figure { \n\tdraw :: IO (),\n        move :: Displacement -> IO ()\n}\n\ntype Displacement = (Int, Int)  -- horizontal and vertical displacement in points\n```\n每个图形类型的构造函数应该只返回一个Figure记录：\n```Haskell\ncircle    :: Point -> Radius -> IO Figure -- 圆 \nrectangle :: Point -> Point -> IO Figure  -- 矩形\n\ntype Point = (Int, Int)  -- 点坐标\ntype Radius = Int        -- 以圆为单位的圆半径\n```\n我们将通过打印当前参数来绘制`draw`图。让我们从`circle`和`rectangle`构造函数的简化实现开始，而不需要实际的`move`支持:\n```Haskell\ncircle center radius = do\n    let description = \"  Circle at \"++show center++\" with radius \"++show radius\n    return $ Figure { draw = putStrLn description }\n\nrectangle from to = do\n    let description = \"  Rectangle \"++show from++\"-\"++show to)\n    return $ Figure { draw = putStrLn description }\n```\n如您所见，每个构造函数只返回一个固定的绘图`draw`过程，该过程打印用于创建具体图形的参数。我们来测试一下：\n```Haskell\ndrawAll :: [Figure] -> IO ()\ndrawAll figures = do putStrLn \"Drawing figures:\"\n                     mapM_ draw figures\n\nmain = do figures <- sequence [circle (10,10) 5,\n                               circle (20,20) 3,\n                               rectangle (10,10) (20,20),\n                               rectangle (15,15) (40,40)]\n          drawAll figures\n```\n现在让我们定义可以实际移动的\"全功能full-featured\"图。为了实现这一点，我们应该为每个图形提供一个可变变量，用于保存每个图形的当前屏幕位置。该变量的类型为`IORef Point`。该变量应该在图构造函数中创建，并在图记录中包含的IO过程(闭包)中进行操作：\n```Haskell\ncircle center radius = do\n    centerVar <- newIORef center\n\n    let drawF = do center <- readIORef centerVar\n                   putStrLn (\"  Circle at \"++show center\n                             ++\" with radius \"++show radius)\n\n    let moveF (addX,addY) = do (x,y) <- readIORef centerVar\n                   writeIORef centerVar (x+addX, y+addY)\n\n    return $ Figure { draw=drawF, move=moveF }\n\nrectangle from to = do\n    fromVar <- newIORef from\n    toVar   <- newIORef to\n\n    let drawF = do from <- readIORef fromVar\n                   to   <- readIORef toVar\n                   putStrLn (\"  Rectangle \"++show from++\"-\"++show to)\n\n    let moveF (addX,addY) = do (fromX,fromY) <- readIORef fromVar\n                               (toX,toY)     <- readIORef toVar\n                               writeIORef fromVar (fromX+addX, fromY+addY)\n                               writeIORef toVar   (toX+addX, toY+addY)\n\n    return $ Figure { draw=drawF, move=moveF }\n```\n现在我们可以测试移动图的代码：\n```Haskell\nmain = do figures <- sequence [circle (10,10) 5,\n                               rectangle (10,10) (20,20)]\n          drawAll figures\n          mapM_ (\\fig -> move fig (10,10)) figures\n          drawAll figures\n```\n重要的是要意识到我们不仅限于在一个旨在模拟C++/Java风格接口的记录中仅包含IO action。记录还可以包括值，IORefs，纯函数 - 简而言之，任何类型的数据。例如，我们可以轻松地将area和origin字段添加到图形接口中：\n```Haskell\ndata Figure = Figure { draw :: IO (),\n                       move :: Displacement -> IO (),\n                       area :: Double,\n                       origin :: IORef Point\n                     }\n```\n\n#### 异常处理\n\n\n#### 与C/C++和外部库的接口\n\n#### IO monad的黑暗面\n\n##### unsafePerformIO\n来自命令式语言背景的程序员经常寻找在纯过程中执行IO操作的方法。但是，这是什么意思? 想象一下，您正在尝试编写一个读取具有给定名称的文件内容的过程，并尝试将其写为纯（非IO）函数：\n```Haskell\nreadContents :: Filename -> String\n```\n将readContents定义为纯函数肯定会简化使用它的代码。但它也会给编译器带来问题：\n* 此调用未插入\"world转换\"序列中,因此编译器不知道您希望何时执行此操作。例如,如果文件在程序开头有一种内容而另一种在结尾 - 你想看哪些内容？您不知道何时(或者甚至是)将要调用此函数,因为Haskell将此函数视为纯函数,并且可以根据需要重新排序任何或所有纯函数的执行。\n* 尽管可以在调用之间改变文件(或当前目录),但是可以考虑尝试读取具有相同名称的文件的内容(即,减少到单个调用)。同样,Haskell认为所有非IO函数都是纯粹的,并且可以随意省略具有相同参数的多个调用。\n因此,实现与真实世界交互的纯函数被认为是不良的行为,好男孩和女孩从来没有这样做;\n然而,有(半官方)方法在纯函数内部使用IO动作。你应该记住,通过要求一个RealWorld接力棒去调用一个IO action是禁止的。\n纯函数没有接力棒,但是有一个特殊的`magic`程序可以从不知名的地方产生这个\"接力棒\",使用它来调用IO action,然后抛出所产生的`world`!这是一个有点低级魔法。这个非常特殊(危险)的程序是：\n```Haskell\nunsafePerformIO :: IO a -> a\n```\n让我们来看看它的(可能的)定义:\n```Haskell\nunsafePerformIO :: (RealWorld -> (a, RealWorld)) -> a\nunsafePerformIO action = \n\tlet (a, world1) = action createNewWorld \n\tin a\n```\n其中`createNewWorld`是一个内部函数，产生RealWorld类型的新值。\n使用`unsafePerformIO`,您可以轻松编写内部执行I/O的纯函数。但是不要在没有真正需要的情况下这样做,并记住遵循这条规则: 编译器不知道你在作弊;它仍然认为每个非IO功能都是纯粹的。因此,所有通常的优化规则都可以(并且将会)应用于其执行。所以你必须确保:\n* 每次调用的结果仅取决于其参数\n* 您不依赖于此函数的副作用,如果不需要其结果,则该函数可能不会执行\n让我们更深入地研究这个问题。Haskell中的函数评估由值的必要性决定 - 语言仅计算计算最终结果所需的值。但这对于`main`函数意味着什么呢?为了计算\"最终world值\"，您需要执行`main`链中包含的所有中间IO操作,通过使用`unsafePerformIO`,我们在此链之外调用IO操作,我们有什么保证可以运行它们？没有。只有在需要运行它们来计算整个函数结果时才会运行它们(这反过来也应该被要求在`main`链中执行一些操作)，这是Haskell按需评估策略的一个例子。现在你应该清楚地看到差异:\n* IO过程中的IO操作保证只要(直接或间接)在`main`链内执行 - 即使未使用其结果(因为它返回的隐式`world`值将被使用)。您可以直接在IO过程中指定操作的执行顺序。通过从每个IO操作传递到下一个IO操作的隐式`world`值来模拟数据依赖性。\n* 只有在真正使用此操作的结果时,才会执行`unsafePerformIO`内的IO操作,评估顺序无法保证,您不应该依赖它(除非您确定可能存在任何数据依赖性)。\n我还应该说，在`unsafePerformIO`调用中你可以在相同的绑定操作符`and/or`我们上面看到的`do`语法糖的帮助下组织一个小的内部IO actions链。\n例如，这里有一个特别复杂的方法来计算0之后的整数:\n```Haskell\none :: Int\none = unsafePerformIO $ do var <- newIORef 0\n                           modifyIORef var (+1)\n                           readIORef var\n```\n在这种情况下,只要需要`unsafePerformIO`调用的结果,就会执行该链中的所有操作。为了确保这一点,实际的`unsafePerformIO`实现会评估`action`返回的`world`：\n```Haskell\nunsafePerformIO action = let (a,world1) = action createNewWorld\n                         in (world1 `seq` a)\n```\n(`seq`操作在返回第二个参数的值之前严格评估其第一个参数)\n\n##### inlinePerformIO\n`inlinePerformIO`与`unsafePerformIO`具有相同的定义,但添加了`INLINE`编译指示：\n```Haskell\n-- 就像unsafePerformIO一样,但我们内联它,大量的性能提升,因为它暴露了很多东西进一步内联\n{-# INLINE inlinePerformIO #-}\ninlinePerformIO action = let (a, world1) = action createNewWorld\n                         in (world1 `seq` a)\n#endif\n```\n语义上`inlinePerformIO = unsafePerformIO`，其中任何一个都有任何语义。\n当然,不同之处在于`inlinePerformIO`比`unsafePerformIO`更不安全。虽然`ghc`将尽量不重复或共同使用`unsafePerformIO`的不同用途,但我们积极地内联`inlinePerformIO`。因此,实际上您只能在IO内容非常纯正的地方使用它,例如从不可变的内存缓冲区读取(如`ByteStrings`的情况),然而,分配新缓冲区之类的事情不应该在`inlinePerformIO`内部完成,因为它可以很容易地在整个程序中浮动并只执行一次，所以最终会有许多东西共享同一个缓冲区，这很糟糕。\n```Haskell\nwrite :: Int -> (Ptr Word8 -> IO ()) -> Put ()\nwrite !n body = Put $ \\c buf@(Buffer fp o u l) ->\n  if n <= l\n    then write' c fp o u l\n    else write' (flushOld c n fp o u) (newBuffer c n) 0 0 0\n\n  where {-# NOINLINE write' #-}\n        write' c !fp !o !u !l =\n          -- warning: this is a tad hardcore\n          inlinePerformIO\n            (withForeignPtr fp\n              (\\p -> body $! (p `plusPtr` (o+u))))\n          `seq` c () (Buffer fp o (u+n) (l-n))\n```\n它的使用方式如下：\n```Haskell\nword8 w = write 1 (\\p -> poke p w)\n```\n这不符合我的经验法则,不要问我们为什么声称它是安全的(如果有人真的想知道,请问`Ross Paterson`谁先在`Builder monoid`中做过)\n\n##### unsafeInterleaveIO\n但是还有一个更奇怪的操作叫做`unsafeInterleaveIO`,它得到了\"官方接力棒\",制作了自己的翻印副本,然后与main接力棒同时进行一场\"非法\"的接力比赛!我无法在不引起悲痛和愤慨的情况下进一步讨论它的行为,因此,在俄罗斯和中国等软件盗版的温床国家,这种操作被广泛使用也就不足为奇了!)别问我 —— 我不会再提我经常用的这种卑鄙的伎俩了。\n可以使用`unsafePerformIO`(不是`unsafeInterleaveIO`)来执行I/O操作,而不是按预定义顺序执行I/O操作。例如,以下代码：\n```Haskell\ndo let c = unsafePerformIO getChar\n   do_proc c\n```\n只有当代码确实需要`c`的值时才会执行`getChar I/O`调用,即它将像任何通常的Haskell计算一样懒惰地执行.\n现在想象下面的代码：\n```Haskell\ndo let s = [unsafePerformIO getChar, unsafePerformIO getChar, unsafePerformIO getChar]\n   do_proc s\n```\n此列表中的三个字符也将按需计算,这意味着它们的值将取决于它们的消耗顺序。这通常不是我们需要的。\n`unsafeInterleaveIO`解决了这个问题 - 它只在需要时执行I/O,但允许为数据结构的各个部分定义精确的*内部*执行顺序。这就是为什么我写道`unsafeInterleaveIO`制作非法复制的接力棒。\n\n首先,`unsafeInterleaveIO`将`(IO a)`action 作为参数并返回类型为`a`的值：\n```Haskell\ndo str <- unsafeInterleaveIO myGetContents\n```\n其次,`unsafeInterleaveIO`不会立即执行任何操作,它只创建一个类型为`a`的盒子,在请求此值时将执行指定为参数的操作。\n第三,这个action本身可以立即计算整个值或者......再次使用`unsafeInterleaveIO`推迟计算一些子组件：\n```Haskell\nmyGetContents = do\n   c <- getChar\n   s <- unsafeInterleaveIO myGetContents\n   return (c:s)\n```\n此代码仅在确实需要`str`的值时执行,在这一刻,将执行`getChar`(结果分配给`c`),并且将创建一个更懒的IO盒子`s`。 此盒子再次包含指向`myGetContents`调用的链接\n然后,返回一个包含`char read`的list单元格,并链接到`myGetContents`调用(作为计算列表其余部分的方法)。\n仅当需要list中的下一个值时,才会再次执行此操作。\n作为最终结果,我们无法在读取第一个之前读取到列表中的第二个字符,而是读取整个列表的懒惰字符。答对了！\n\nPS:当然，实际代码应该包括EOF检查。请注意，你可以在每次通话中读取多个字符/记录:\n```Haskell\nmyGetContents = do\n   c <- replicateM 512 getChar\n   s <- unsafeInterleaveIO myGetContents\n   return (c++s)\n```\n\n#### 更安全的方法: ST monad\n我们之前说过，我们可以使用`unsafePerformIO`来执行完全纯粹但仍以某种方式与真实世界交互的计算。但是，还有更好的方法! 它保持了完全纯粹性，并且允许使用引用/数组等等 - 并且它已经完成了使用，你猜对了，类型魔法。这是`ST monad`。\n`ST monad`的`unsafePerformIO`版本称为`runST`,它有一种非常不寻常的类型。\n```Haskell\nrunST :: (forall s . ST s a) -> a\n```\n`ST monad中`的`s`变量是状态类型。此外,`ST monad`中可用的所有有趣的可变内容都是通过`s`来量化的：\n```Haskell\nnewSTRef :: a -> ST s (STRef s a)\nnewArray_ :: Ix i => (i, i) -> ST s (STArray s i e)\n```\n那么为什么`runST`有这么时髦的类型呢？让我们看看如果我们写下会发生什么\n```Haskell\nmakeSTRef :: a -> STRef s a\nmakeSTRef a = runST (newSTRef a)\n```\n这将失败,因为`newSTRef a`并不适用于所有状态类型`s` —— 它只适用于返回类型`STRef s a`的`s`。\n这有点古怪,但结果是,您只能运行一个`ST`计算,其中输出类型在功能上是纯的,并且不引用计算的内部可变状态,`ST monad`也不能访问I/O操作,比如写入控制台 —— 只有引用、数组之类的操作才能方便地进行纯计算。\n重要提示 - `state`类型实际上并不意味着什么。例如，我们从未拥有类型`s`的值。这只是让类型系统通过烟雾和镜子来确保我们的纯度工作的一种方式。\n它实际上只是一种类型系统魔法:在内部,`runST`像`unsafePerformIO`一样，用真实世界的接力棒运行计算。它们的内部实现几乎是相同的, 事实上,有一个函数:\n```Haskell\nstToIO :: ST RealWorld a -> IO a\n```\n不同之处在于`ST`使用类型系统魔法禁止不安全行为,例如从安全`ST`包装中提取可变对象,但是允许使用对可变引用和数组的所有方便访问来执行纯函数输出。\n下面是我们如何用上面的`unsafePerformIO`重写我们的函数:\n```Haskell\noneST :: ST s Int -- note that this works correctly for any s\noneST = do var <- newSTRef 0\n           modifySTRef var (+1)\n           readSTRef var\n\none :: Int\none = runST oneST\n```\n\n#### 欢迎来到机器: 实际的GHC实现\n一个小小的免责声明: 我应该说我并没有在这里详细描述monad是什么(我自己甚至都不完全理解它)而且我的解释只显示了在Haskell中实现`IO monad`的一种可能方式。例如,`hbc Haskell`编译器和`Hugs`解释器通过`continuation`实现`IO monad`。我还没有谈到异常处理,这是`monad`概念的一个自然部分。您可以阅读\"All About Monads\"指南,了解有关这些主题的更多信息。\n但有一些好消息:首先,你刚刚获得的`IO monad`理解将适用于任何许多其他`monad`的实现。您只是无法直接使用`RealWorld`值。\n其次,这里描述的`IO monad`实现实际上是在`GHC、yhc/nhc (jhc?)`编译器中使用的。下面是GHC来源的IO定义:\n```Haskell\nnewtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))\n```\n它使用`State# RealWorld`类型而不是我们的`RealWorld`,它使用`(# #)`严格的元组进行优化,并围绕该类型添加一个IO数据构造函数。然而,从我们的解释来看,并没有什么重大的变化。了解了通过`伪装world状态`值\"链接\"IO操作的原则,您现在可以轻松理解和编写`GHC I/O`操作的底层实现。\n\n##### Yhc/nhc98 实现\n```Haskell\ndata World = World\nnewtype IO a = IO (World -> Either IOError a)\n```\n这个实现使`World`在某种程度上消失,并返回类型为`a`的结果,或者如果出现错误,则返回`IOError`。只有当编译器知道IO类型的一些特殊信息,并且不会对其进行过度优化时,函数右边才会缺少`World`。\n\n#### 进一步阅读\n\n#### to-do列表\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["IO"]},{"title":"Dubbo源码阅读之服务器创建","url":"/blog/2019/02/20/Dubbo源码阅读之服务器创建/","content":">在《Dubbo源码阅读之服务暴露》一文中，我们知道在服务暴露时会创建服务器，这篇文章我们就详细看下服务器相关的源码。\n\n![](images/dubbo.jpeg)\n\n###\n\n\n\n","tags":["dubbo"]},{"title":"Haskell常用扩展","url":"/blog/2018/11/20/Haskell常用扩展/","content":"\n### BinaryLiterals\n\n### ExistentialQuantification\n\n### FlexibleInstances\n\n### LambdaCase\n一个句法扩展，允许你用\\case代替\\arg - > case arg of.\n请考虑以下函数定义：\n```haskell\ndayOfTheWeek :: Int -> String\ndayOfTheWeek 0 = \"Sunday\"\ndayOfTheWeek 1 = \"Monday\"\ndayOfTheWeek 2 = \"Tuesday\"\ndayOfTheWeek 3 = \"Wednesday\"\ndayOfTheWeek 4 = \"Thursday\"\ndayOfTheWeek 5 = \"Friday\"\ndayOfTheWeek 6 = \"Saturday\"\n```\n如果您想避免重复函数名称，可以这样编写：\n```haskell\ndayOfTheWeek :: Int -> String\ndayOfTheWeek i = case i of\n    0 -> \"Sunday\"\n    1 -> \"Monday\"\n    2 -> \"Tuesday\"\n    3 -> \"Wednesday\"\n    4 -> \"Thursday\"\n    5 -> \"Friday\"\n    6 -> \"Saturday\"\n```\n而使用LambdaCase扩展后，您可以将其编写为函数表达式，而无需为参数命名：\n```haskell\n{-# LANGUAGE LambdaCase #-}\n\ndayOfTheWeek :: Int -> String\ndayOfTheWeek = \\case\n    0 -> \"Sunday\"\n    1 -> \"Monday\"\n    2 -> \"Tuesday\"\n    3 -> \"Wednesday\"\n    4 -> \"Thursday\"\n    5 -> \"Friday\"\n    6 -> \"Saturday\"\n```\n\n### ScopedTypeVariables\nScopedTypeVariables允许您引用声明中的通用量化类型, 更明确一点：\n```haskell\nimport Data.Monoid\n\nfoo :: forall a b c. (Monoid b, Monoid c) => (a, b, c) -> (b, c) -> (a, b, c)\nfoo (a, b, c) (b', c') = (a :: a, b'', c'')\n    where (b'', c'') = (b <> b', c <> c') :: (b, c)\n```\n重要的是我们可以使用a,b和c来指示编译器在声明的子表达式中(where子句中的元组和最终结果中的第一个a),实际上,ScopedTypeVariables有助于将复杂函数编写为部分之和，允许程序员将类型签名添加到没有具体类型的中间值。\n\n\n### OverloadedStrings\n通常，Haskell中的字符串文字具有String类型（它是[Char]的类型别名）。虽然这对于较小的教育程序来说不是问题，但实际应用程序通常需要更高效的存储，例如Text或ByteString.\nOverloadedStrings只是将文字类型更改为:\n```haskell\n\"test\" :: Data.String.IsString a => a\n```\n允许它们直接传递给期望这种类型的函数。许多库为类似字符串的类型实现了这个接口，包括Data.Text和Data.ByteString ，它们都比[Char]提供了一定的时间和空间优势。\n\n还有一些像Postgresql简单库那样的OverloadedStrings独特用途，它允许用双引号编写SQL查询，就像普通字符串一样，但提供了对不正确连接的保护，这是一种臭名昭着的SQL注入攻击源。\n要创建IsString类的实例，您需要实现fromString函数。示例：\n```haskell\ndata Foo = A | B | Other String deriving Show\n\ninstance IsString Foo where\n  fromString \"A\" = A\n  fromString \"B\" = B\n  fromString xs  = Other xs\n\ntests :: [ Foo ]\ntests = [ \"A\", \"B\", \"Testing\" ]\n```\n\n\n\n### TupleSections\n一种语法扩展，允许以节的方式应用元组构造函数(它是一个运算符):\n```haskell\n(a,b) == (,) a b\n\n-- With TupleSections\n(a,b) == (,) a b == (a,) b == (,b) a\n```\n#### N-tuples\n它也适用于元素大于2的元组\n```haskell\n(,2,) 1 3 == (1,2,3)\n```\n#### Mapping\n这在使用部分的其他地方也很有用:\n```haskell\nmap (,\"tag\") [1,2,3] == [(1,\"tag\"), (2, \"tag\"), (3, \"tag\")]\n```\n没有此扩展的上述示例如下所示：\n```haskell\nmap (\\a -> (a, \"tag\")) [1,2,3]\n```\n\n\n\n","tags":["haskell"]},{"title":"Redis源码阅读-字符串","url":"/blog/2018/11/17/Redis源码阅读-字符串/","content":">Redis动态字符串数据结构的定义及实现在sds.h和sds.c文件中。\n\n* 字符串定义\n* 字符串实现\n* 方法实现\n\n### 字符串定义\n我们平时在使用Redis时，经常使用的数据结构就是字符串，例如：\n```shell\n127.0.0.1:6379> set name Redis\nOK\n127.0.0.1:6379> get name\n\"Redis\"\n127.0.0.1:6379> del name\n(integer) 1\n```\n那么字符串在Redis是如何定义的呢？我们可以在sds.h文件中找到答案。\n在该文件中，我们可以看到Redis字符串数据结构SDS由两部分组成，sds指针和sdshdr头部类型，\n其中sdshdr类型定义了5种(sdshdr5/sdshdr8/sdshdr16/sdshdr32/sdshdr64)，主要是为了针对不同长度的字符串，节省内存：\n```c\ntypedef char *sds;\n\nstruct __attribute__ ((__packed__)) sdshdr5 {\n    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr8 {\n    uint8_t len;\n    uint8_t alloc;\n    unsigned char flags;\n    char buf[];\n};\n\n/*flags值定义*/\n#define SDS_TYPE_5  0\n#define SDS_TYPE_8  1\n#define SDS_TYPE_16 2\n#define SDS_TYPE_32 3\n#define SDS_TYPE_64 4\n\n//掩码\n#define SDS_TYPE_MASK 7\n#define SDS_TYPE_BITS 3\n\n/*通过buf指针获取sds头指针，T为sds头类型值，s为buf指针\n *这里##会将两个字符串连接起来，如:T为8，则sdshdr##T为sdshrd8\n *sizeof(struct sdshdr##T)为结构体sdshdr8占用的字节数，这里为3字节\n */\n#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));\n\n#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))\n\n#define SDS_TYPE_5_LEN(f) ((f)>>SDS_TYPE_BITS)\n```\n![](img/sds.png)\nlen   标识当前字节数组的长度，不包含字符串结束标识。\nalloc 标识当前字节数组分配的内存大小，不包含字符串结束标识。\nflags 低3位标识当前使用的是哪个sdshdr类型。\nbuf   保存字符串值和结束标识。\n*sds  指向buf数组的起始地址\n为SDS增加一个头部类型可以提高一些操作的效率，例如用O(1)的复杂度就可以从头部中取到字符串长度。\nsdshdr头部类型是通过结构体定义的，默认情况下会进行内存对齐优化，即结构体分配的内存是内部最大元素的整数倍，例如sdshdr32将会分配12字节。\n这里使用__attribute__ ((__packed__))关闭内存对齐优化，从而按照实际占用字节数来对齐，即sdshdr32将会分配9字节，节省了3字节。内存紧凑，使用sds-1就可以得到flags字段，进而得到其头部类型。没有内存对齐，cpu寻址效率就会降低，Redis是在内存分配前做了一些操作，解决内存对齐的，后面会看到。\nbuf数组初始化时不占用内存空间，使得头部内存和存储字符串的内存地址连续，另外结尾隐含一个'\\0',而SDS是以len字段来判断是否是否到达字符串末尾的，因此在字符串中间可以出现'\\0'，即SDS字符串是二进制安全的。\n\n### 字符串实现\n创建新字符串使用的是sds.c中的sdsnewlen函数：\n```c\n// 使用init指针指向的内容和initlen创建一个新的字符串\nsds sdsnewlen(const void *init, size_t initlen) {\n    void *sh;\n    \n    // buf数组起始地址\n    sds s;\n    \n    // 根据长度选择合适的sds头部类型\n    char type = sdsReqType(initlen);\n\n    // 用type 8创建空字符串方便追加\n    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;\n    \n    // 根据sds头部类型获取头部大小\n    int hdrlen = sdsHdrSize(type);\n    \n    // flag指针\n    unsigned char *fp;\n\n    // 为sds分配内存（后面会分析s_malloc）\n    // 内存大小为：sds头部大小 + 存储字符串的长度initlen + 末尾空字符大小1字节\n    sh = s_malloc(hdrlen+initlen+1); \n\n    if (!init)\n        // 内存初始化为0（后面会分析memset）\n        memset(sh, 0, hdrlen+initlen+1);\n    // 内存分配失败\n    if (sh == NULL) return NULL;\n\n    // buf数组的起始地址\n    s = (char*)sh+hdrlen;\n    \n    // buf数组起始地址-1，即为flags字段\n    fp = ((unsigned char*)s)-1;\n\n    // 初始化sds头部的len,alloc,flags字段\n    switch(type) {\n        case SDS_TYPE_5: {\n            *fp = type | (initlen << SDS_TYPE_BITS);\n            break;\n        }\n        case SDS_TYPE_8: {\n            //根据buf起始地址获取指向sds头部的起始地址的指针\n            SDS_HDR_VAR(8,s);\n\t    // 设置len字段值为initlen\n            sh->len = initlen;\n\t    // 设置alloc字段值为initlen\n            sh->alloc = initlen;\n\t    // 设置flags字段类型为type\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n    }\n    // 初始化buf数组\n    if (initlen && init)\n        // 拷贝init到buf数组（后面会分析memcpy）\n        memcpy(s, init, initlen);\n\n    // 添加末尾空字符标识\n    s[initlen] = '\\0';\n    return s;\n}\n\n/**\n * 根据字符串长度获取合适的头部类型\n * @param string_size 字符串初始长度\n * @return\n */\nstatic inline char sdsReqType(size_t string_size) {\n    if (string_size < 1<<5) //32\n        return SDS_TYPE_5;\n    if (string_size < 1<<8) //256\n        return SDS_TYPE_8;\n    if (string_size < 1<<16) //65536\n        return SDS_TYPE_16;\n#if (LONG_MAX == LLONG_MAX) //等于有符号long最大值\n    if (string_size < 1ll<<32) //4gb\n        return SDS_TYPE_32;\n    return SDS_TYPE_64;\n#else\n    return SDS_TYPE_32;\n#endif\n}\n\n/**\n * 通过字符串头部类型获取其头大小\n * @param type 字符串类型 0-4\n * @return\n */\nstatic inline int sdsHdrSize(char type) {\n    // type & SDS_TYPE_MASK = type\n    // 例如：sdshdr8， 1 & 7 = 1\n    switch(type&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            return sizeof(struct sdshdr5);\n        case SDS_TYPE_8:\n            //sizeof计算结构体大小，取消了内存对齐\n            return sizeof(struct sdshdr8); // 3字节\n        case SDS_TYPE_16:\n            return sizeof(struct sdshdr16); // 5字节\n        case SDS_TYPE_32:\n            return sizeof(struct sdshdr32); // 9字节\n        case SDS_TYPE_64:\n            return sizeof(struct sdshdr64); // 17字节\n    }\n    return 0;\n}\n```\n关于内存操作的函数，将在内存操作小节介绍，这里就不在进行介绍了。\n### 方法实现\n","tags":["redis"]},{"title":"数据结构与算法-复杂度分析(下)","url":"/blog/2018/10/13/数据结构与算法-复杂度分析(下)/","content":">本小節浅析最好、最坏、平均、均摊时间复杂度\n\n### 最好、最坏情况时间复杂度\n```c\n// 從數組array中查找x,找到了則返回x出現的位置，沒有找到則返回-1\n// n表示数组array的长度\nint find(int[] array, int n, int x) {\n  int i = 0;\n  int pos = -1;\n  for (; i < n; ++i) {\n    if (array[i] == x) pos = i;\n  }\n  return pos;\n}\n```\n根據前文介紹的時間複雜度分析方法，我們可以知道如上代碼複雜度為`O(n)`.\n\n但是上面的代碼不夠高效，我們不一定每次都需要遍歷一次數組，因為有時候中途找到了就可以提前結束遍歷了。修改下代碼:\n```c\n// n表示数组array的长度\nint find(int[] array, int n, int x) {\n  int i = 0;\n  int pos = -1;\n  for (; i < n; ++i) {\n    if (array[i] == x) {\n       pos = i;\n       // 找到了，結束循環\n       break;\n    }\n  }\n  return pos;\n}\n```\n此時，時間複雜度就不一定是`O(n)`了，如果數組第一個元素就是我們要找的`x`,那麼我們就不需要遍歷後面的`n-1`個元素了，因此時間複雜度為`O(1)`，如果數組中不包含`x`，那麼我們就得遍歷整個數組，因此時間複雜度就是`O(n)`.\n\n* 最好情况时间复杂度: 在最理想的情况下，执行这段代码的时间复杂度, 例如上面的`O(1)`\n* 最坏情况时间复杂度: 在最糟糕的情况下，执行这段代码的时间复杂度, 例如上面的`O(n)`\n\n### 平均情况时间复杂度\n`最好`、`最坏`情况时间复杂度都是極端情況下的例子，發生的機率很小，因此需要引入`平均`情况时间复杂度.\n\n要查找变量`x`在数组中的位置，有`n+1`种情况: [在数组的`0～n-1`位置中] 和 [不在数组中]。\n我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以`n+1`，就可以得到需要遍历的元素个数的平均值，即:\n\n![](数据结构与算法-复杂度分析(下)/img01.png)\n\n```c\n推導:\n等差數列的求和公式為: n(1+n)/2\n\n1、1+2+3+...+n+n = n(1+n)/2 + n\n                = (n(1+n)/2) + (2n/2)\n                = (n(1+n)+2n) / 2\n                = (n+n²+2n) / 2\n                = (n² + 3n) / 2\n                = n(n+3) / 2\n2、将n(n+3)/2代入式子中，就成了n(n+3)/2 / n+1 = n(n+3)/2(n+1)\n```\n\n省略掉系数、低阶、常量後，時間複雜度為`O(n)`.\n\n以上結論是正確的，但是計算過程有些問題: `n+1`种情况出現的概率是不一樣的。\n\n分析:\n假设元素`x`在数组中与不在数组中的概率都为`1/2`, 要查找的数据出现在`0～n-1`这`n`个位置的概率也是一样的，为`1/n`。所以，根据概率乘法法则，要查找的数据出现在`0～n-1`中任意位置的概率就是`1/(2n)`.\n\n如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样:\n\n![](数据结构与算法-复杂度分析(下)/img02.png)\n\n这个值就是概率论中的`加权平均值`，也叫作`期望值`，所以`平均时间复杂度`的全称应该叫`加权平均时间复杂度`或者`期望时间复杂度`。\n\n引入概率之后，前面那段代码的`加权平均值`为`(3n+1)/4`。用`大O`表示法来表示，去掉系数和常量，这段代码的`加权平均时间复杂度`仍然是`O(n)`.\n\n### 均摊时间复杂度\n```c\n // array表示一个长度为n的数组\n // 代码中的array.length就等于n\n int[] array = new int[n];\n int count = 0;\n \n void insert(int val) {\n    if (count == array.length) {\n       int sum = 0;\n       for (int i = 0; i < array.length; ++i) {\n          sum = sum + array[i];\n       }\n       array[0] = sum;\n       // 更新下標位置，下次插入時會覆蓋之前的數據\n       count = 1;\n    }\n\n    array[count] = val;\n    ++count;\n }\n ```\n* 数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为`O(1)`.\n* 最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 `O(n)`.\n* 那平均时间复杂度是多少呢？答案是`O(1)`。我们还是可以通过前面讲的概率论的方法来分析.\n\n分析`平均`时间复杂度:\n假设数组的长度是 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是`O(1)`。\n除此之外，还有一种\"额外\"的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是`O(n)`。而且，这`n+1`种情况发生的概率一样，都是`1/(n+1)`。所以，根据`加权平均`的计算方法，我们求得的平均时间复杂度就是:\n\n![](数据结构与算法-复杂度分析(下)/img03.png)\n\n\n`find()` 和 `insert()`區別:\n* `find()`極端情況下复杂度才为`O(1)`,`insert()`大部分情況都為`O(1)`,個別情況為`O(n)`.\n* `insert()`出現`O(1)`和`O(n)`的頻率是有規律、時序關係的，即一個`O(n)`插入後，緊跟著`n-1`個`O(1)`的插入.\n\n针对这种特殊的场景，我们并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。我们引入了一种更加简单的分析方法: `摊还分析法`，通过摊还分析得到的时间复杂度我们起了一个名字，叫`均摊时间复杂度`.\n\n每一次`O(n)`的插入操作，都会跟着`n-1`次`O(1)`的插入操作，所以把耗时多的那次操作均摊到接下来的`n-1`次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是`O(1)`.\n\n在能够应用`均摊时间复杂度`分析的场合，一般`均摊时间`复杂度就等于`最好情况`时间复杂度。`均摊时间`复杂度就是一种特殊的`平均时间`复杂度.\n\n\n### 课后思考\n```c\n// 全局变量，大小为10的数组array，长度len，下标i。\nint array[] = new int[10];\nint len = 10;\nint i = 0;\n\n// 往数组中添加一个元素\nvoid add(int element) {\n   if (i >= len) { // 数组空间不够了\n     // 重新申请一个2倍大小的数组空间\n     int new_array[] = new int[len*2];\n     // 把原来array数组中的数据依次copy到new_array\n     for (int j = 0; j < len; ++j) {\n       new_array[j] = array[j];\n     }\n     // new_array复制给array，array现在大小就是2倍len了\n     array = new_array;\n     len = 2 * len;\n   }\n   // 将element放到下标为i的位置，下标i加一\n   array[i] = element;\n   ++i;\n}\n```\n1. 最好情况时间复杂度为 O(1)\n\n2. 最坏情况分析：\n最坏情况代码执行的次数跟每次数组的长度有关\n第1次调用insert的执行的次数为 n ,\n第2次调用insert的执行的次数为 2n ,\n第3次调用insert的执行的次数为 2^2 * n\n第k次调用insert的执行的次数为 2^(k-1) * n\n最坏时间复杂度为 O(n)。\n\n3. 平均情况分析\n当每次遇到最坏情况时数组会进行2倍扩容，原数组被导入新数组，虽然数组的长度变大了，但是插入操作落在的区间的长度是一样的，分别是0~len-1, len~(2len-1),....；\n插入的情况仍是len+1种：0~len-1和插满之后的O(len)；所以每次插入的概率是：p= 1/len+1，\n最后求出加权平均时间复杂度为 1*p + 2*p+ ▪▪▪ + len*p + len * p = O(1);\n\n4. 均摊时间复杂度 O(1)\n而均摊复杂度由于每次O(len)的出现都跟着len次O(1)，是前后连贯的，因而将O(len)平摊到前len次上，得出平摊复杂度是O(1)","tags":["复杂度分析"]},{"title":"数据结构与算法-复杂度分析(上)","url":"/blog/2018/10/13/数据结构与算法-复杂度分析(上)/","content":">本小节总结: 时间、空间复杂度分析\n* 什么是复杂度分析？\n* 为什么要进行复杂度分析？\n* 如何进行时间、空间复杂度分析？(大O表示法)\n\n### 什么是复杂度分析\n1. 数据結构与算法是为了解决\"如何让计算机运行的更快同时更省存储空间\"的问题，因此，执行效率是评估一个算法好坏的重要指标。\n2. 我们需要从算法执行时间、占用空间两个纬度来评估数据结构和算法的性能。通常使用时间复杂度和空间复杂度来描述性能问题。\n3. 复杂度分析描述的是算法执行时间(占用空间)与数据规模的增长关系。\n\n### 为什么要进行复杂度分析\n平时我们会把代码运行一遍，然后通过统计、监控就可以得到算法执行的时间和占用的内存，此方法称为事后统计法，存在很大的局限性。\n1. 测试结果非常依赖测试环境\n2. 测试结果受数据规模的影响很大，我们需要一个不用具体的测试数据进行测试就可以粗略的评估算法执行效率的方法。\n3. 掌握复杂度分析，将会编写出性能更优的代码，有利于降低系统开发和维护的成本。\n\n### 如何进行复杂度分析\n#### 大O表示法的由来\n所有代码的执行时间T(n)与每行代码的执行次数n成正比。用大O表示法就是:\n```haskell\n\tT(n) = O(f(n))\n其中:\n\tT(n) 表示代码执行时间。\n\tf(n) 表示每行代码执行的次数总和。\n\t大0 表示代码执行时间 T(n) 与 f(n) 表达式成正比。\n```\n大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示`代码执行时间`随`数据规模增长`的变化趋势。因此也叫做渐进时间复杂度，简称时间复杂度。\n\n#### 大O表示法的特点\n以时间复杂度为例，由于时间复杂度描述的是算法`执行时间`与`数据规模增长`的变化趋势，所以常量阶、低阶、以及系数实际上对这种增长趋势不产生决定性影响，因此在进行时间复杂度分析时可以省略这些项。\n\n#### 时间复杂度分析法则\n1. 只关注循环次数最多的一段代码：比如`循环`操作\n2. 加法法则取量级最大代码复杂度：比如一段代码中有单循环和多重循环，则取`多重循环`的复杂度。\n3. 乘法法则嵌套代码复杂度取乘积: 比如递归、多重循环等，取嵌套内外代码复杂度的乘积。\n4. 多个规模求加法：比如方法有两个参数分别控制两个循环的次数，则将两者的复杂度进行相加，即: `O(m+n)`\n\n#### 常见的时间复杂度级别\n1. 多项式阶\n    随着数据规模的不断增长，算法的执行时间和空间占用，按照多项式的比例增长。从低阶到高阶常见的有(越高阶效率越低)：\n```perl    \n\tO(1): 常数阶\n\n\tO(logn): 对数阶\n\n\tO(n): 线性阶\n\n\tO(nlogn): 线性对数阶\n\n\tO(n^2): 平方阶\n\n\tO(n^3): 立方阶\n```\n2. 非多项式阶\n    我们把时间复杂度为非多项式量级的算法问题叫做NP(Non-Deterministic Ploynomial非确定多项式)问题，随着数据规模的不断增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括：\n```perl\n\tO(2^n): 指数阶\n\n\tO(n!): 阶乘阶\n```\n#### 空间复杂度\n空间复杂度和时间复杂度类似，全称为：渐进空间复杂度，表示算法的`存储空间`和`数据规模`之间的增长关系。\n常见的空间复杂度级别有：O(1)、O(n)、O(n^2)，而O(logn)、O(nlogn)这样的对数阶复杂度平时都用不到。\n\n### 例子\n#### 时间复杂度分析\n##### O(1)\n```c\nint i = 8;\nint j = 6;\nint sum = i + j;\n```\n只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。\n\n##### O(logn)、O(nlogn)\n對數階時間複雜度是很常見的，也是很難分析的。看如下例子:\n```c\ni=1;\nwhile (i <= n) {\n\ti = i * 2;\n}\n```\n根據上文分析方法可知第3行是循環執行次數最多的，因此只要知道這行代碼執行的次數，就可以知道整段代碼的時間複雜度。\n根據代碼可以知道`i`是從`1`開始取值的，每次循環都乘以`2`，當`i <= n`時，循環結束。\n`i`的取值就是等比數列，如果列出來就是:\n```c\n2^0 2^1 2^2 .. 2^n .. 2^k .. 2^x = n\n```\n因此只要我們算出來x的的值，就可以知道這行代碼的執行次數了:\n```c\n2^x = n, 求解x\n\nx = log2n\n```\n因此，該段代碼的時間複雜度就是`O(log2n)`.\n\n代碼稍微修改下:\n```c\ni=1; \nwhile (i <= n) { \n\ti = i * 3;\n}\n```\n根据上文的思路可以知道这段代码的时间复杂度为`O(log3n)`.\n\n实际上，不管是以2为底、以3为底，还是以10为底，我们可以把所有对数阶的时间复杂度都记为`O(logn)`.\n因為对数之间是可以互相转换的，`log3n` 就等于 `log32 * log2n`，所以 `O(log3n) = O(C * log2n)`，其中 `C = log32` 是一个常量。\n由於采用大`O`标记复杂度的时候可以忽略系数，即`O(Cf(n)) = O(f(n))`。所以,`O(log2n)`就等于`O(log3n)`。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的\"底\"，统一表示为`O(logn)`.\n\n根據`乘法法则`,如果一段代码的时间复杂度是`O(logn)`，我们循环执行`n`遍，时间复杂度就是`O(nlogn)`了。\n\n`O(nlogn)`也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是`O(nlogn)`.\n\n##### O(m+n)、O(m*n)\n下面的例子中,代码的复杂度由两个数据的规模来决定。\n```c\nint cal(int m, int n) {\n  int sum_1 = 0;\n  int i = 1;\n  for (; i < m; ++i) {\n    sum_1 = sum_1 + i;\n  }\n\n  int sum_2 = 0;\n  int j = 1;\n  for (; j < n; ++j) {\n    sum_2 = sum_2 + j;\n  }\n\n  return sum_1 + sum_2;\n}\n```\n從代碼中可以看出，`m`和`n`表示兩個數據規模，由於我們不知道`m`和`n`哪個量級大，因此我們就不可以簡單的使用`加法法則`,省略掉其中一個，所以時間複雜度為: `O(m+n)`.\n\n乘法法则继续有效: `T1(m) * T2(n) = O(f(m) * f(n))`\n\n#### 空间复杂度分析\n空间复杂度全称就是`渐进空间复杂度`，表示算法的`存储空间`与`数据规模`之间的增长关系。\n```c\nvoid print(int n) {\n  int i = 0;\n  int[] a = new int[n];\n  for (i; i <n; ++i) {\n    a[i] = i * i;\n  }\n\n  for (i = n-1; i >= 0; --i) {\n    print out a[i]\n  }\n}\n```\n和分析時間複雜度一樣，第2行代码中，我们申请了一个空间存储变量`i`，但是它是`常量阶`的，跟数据规模`n`没有关系，所以我们可以忽略.\n\n第`3`行申请了一个大小为`n`的`int`类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是`O(n)`.\n\n常见的空间复杂度有`O(1)`、`O(n)`、`O(n2)`，像`O(logn)`、`O(nlogn)`这样的`对数阶`复杂度平时都用不到.\n","tags":["复杂度分析"]},{"title":"Dubbo源码阅读之Configurator动态配置","url":"/blog/2018/09/05/Dubbo源码阅读之Configurator动态配置/","content":">我们可以编写动态配置来配置服务提供者。这个操作通常在监控中心完成。\n\n### 官网文档\n我们先看下官网给的文档说明\n```java\nRegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();\n//获取注册中心\nRegistry registry = registryFactory.getRegistry(URL.valueOf(\"zookeeper://10.20.153.10:2181\"));\n//注册配置\nregistry.register(URL.valueOf(\"override://0.0.0.0/com.foo.BarService?category=configurators&dynamic=false&application=foo&timeout=1000\"));\n```\n在这个配置override url中：\n* override:// 表示数据将会被覆盖，当前dubbo支持override和absent，可以自行扩展，必填参数.\n* 0.0.0.0 表示该配置对所有IP地址都有效，如果只想覆盖指定的ip数据，则可以替换指定的ip地址，必填参数.\n* com.foo.BarService 表示对指定的服务有效，必填参数.\n* category=configurators 表示数据是动态配置的，必填参数.\n* dynamic=false 表示数据是持久化的，当注册方撤销时，数据仍存储在注册表中。\n* enabled=true 启用覆盖策略，可以不传，不传的话，默认值为启用\n* application=foo 表示对指定的application有效，可以不传，不传的话则对所有应用程序有效。\n* timeout=1000 表示满足上述条件的timeout参数的值将会被1000覆盖，如果想要覆盖其他参数，则直接添加到override URL参数上。\n\n#### 例子\n* 禁用服务提供者(通常用于临时踢掉提供者机器，类似于禁止消费者访问，请使用路由规则)\n```java\noverride://10.20.153.10/com.foo.BarService?category=configurators&dynamic=false&disbaled=true\n```\n\n* 调整权重:(通常用于容量评估，默认为100)\n```java\noverride://10.20.153.10/com.foo.BarService?category=configurators&dynamic=false&weight=200\n```\n\n* 调整负载均衡策略(默认策略为随机)\n```java\noverride://10.20.153.10/com.foo.BarService?category=configurators&dynamic=false&loadbalance=leastactive\n```\n\n* 服务降级:(通常用于暂时屏蔽非关键服务的错误）\n```java\noverride://0.0.0.0/com.foo.BarService?category=configurators&dynamic=false&application=foo&mock=force:return+null\n```\n\n现在我们开始看源码实现\n### Configurator接口\n```java\npublic interface Configurator extends Comparable<Configurator> {\n\n    /**\n     * 获取配置url\n     */\n    URL getUrl();\n\n    /**\n     * 配置服务提供者url\n     * 向url中添加新属性(absent) 或者 覆盖url中的属性(override).(新属性来源于配置url)\n     * @param url 旧的提供者url\n     * @return  新的提供者url\n     */\n    URL configure(URL url);\n}\n```\n\n#### AbstractConfigurator抽象类\n该抽象类实现了Configurator接口。并实现了configure方法，在该方法中，会判断当前url是否满足覆盖url的条件。如果满足的话，会调用抽象方法doConfigure执行相应的配置。doConfigure抽象方法由两个子类AbsentConfigurator(absent)和OverrideConfigurator(override)进行实现。\n```java\npublic abstract class AbstractConfigurator implements Configurator {\n\n    /**\n     * 配置url\n     */\n    private final URL configuratorUrl;\n\n    public AbstractConfigurator(URL url) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"configurator url == null\");\n        }\n        this.configuratorUrl = url;\n    }\n\n    @Override\n    public URL getUrl() {\n        return configuratorUrl;\n    }\n\n    /**\n     * @param url 旧的url\n     * @return\n     */\n    @Override\n    public URL configure(URL url) {\n        if (configuratorUrl == null || configuratorUrl.getHost() == null\n                || url == null || url.getHost() == null) {\n            return url;\n        }\n        //如果override url存在端口，则意味着它是服务提供者地址\n        //我们想要这个override url控制一个指定的服务提供者\n        //该覆盖url规则可能对特定的服务提供者实例生效，或者对持有这个服务提供者实例的消费者生效\n        if (configuratorUrl.getPort() != 0) {\n            if (url.getPort() == configuratorUrl.getPort()) {\n                //服务提供者\n                return configureIfMatch(url.getHost(), url);\n            }\n        } else {\n            //configuratorUrl没有端口，意味着这个url的ip指定的是一个消费者地址或者0.0.0.0\n            //如果它是一个消费者ip地址，目的是控制一个特定的消费者实例，\n            //它必须在消费者端生效，任何提供者都将会忽略该url\n            //如果ip是0.0.0.0，则该配置url对消费者、生产者都生效\n            if (url.getParameter(Constants.SIDE_KEY, Constants.PROVIDER).equals(Constants.CONSUMER)) {\n                //消费者\n                //NetUtils.getLocalHost is the ip address consumer registered to registry.\n                //NetUtils.getLocalHost是一个注册到注册中心的消费者ip地址\n                return configureIfMatch(NetUtils.getLocalHost(), url);\n            } else if (url.getParameter(Constants.SIDE_KEY, Constants.CONSUMER).equals(Constants.PROVIDER)) {\n                //生产者\n                // take effect on all providers, so address must be 0.0.0.0,\n                // otherwise it won't flow to this if branch\n                //对所有生产者生效，因此地址必须是0.0.0.0，否则，它将不会进入这个分支\n                return configureIfMatch(Constants.ANYHOST_VALUE, url);\n            }\n        }\n        return url;\n    }\n\n    /**\n     * @param host 受影响的主机地址\n     * @param url\n     * @return\n     */\n    private URL configureIfMatch(String host, URL url) {\n        if (Constants.ANYHOST_VALUE.equals(configuratorUrl.getHost())\n                || host.equals(configuratorUrl.getHost())) {\n            //配置url的host等于0.0.0.0，或者等于host\n            \n            //获取配置url的application参数值，如果为空，则获取username属性\n            String configApplication = configuratorUrl.getParameter(Constants.APPLICATION_KEY,configuratorUrl.getUsername());\n            //获取当前url的application参数值，如果为空，则获取username属性\n            String currentApplication = url.getParameter(Constants.APPLICATION_KEY, url.getUsername());\n\n            if (configApplication == null || Constants.ANY_VALUE.equals(configApplication)\n                    || configApplication.equals(currentApplication)) {\n                //配置url的configApplication = (null || * || currentApplication)\n                Set<String> condtionKeys = new HashSet<String>();\n                \n\t\t//添加category、check、dynamic、enabled参数\n                condtionKeys.add(Constants.CATEGORY_KEY);\n                condtionKeys.add(Constants.CHECK_KEY);\n                condtionKeys.add(Constants.DYNAMIC_KEY);\n                condtionKeys.add(Constants.ENABLED_KEY);\n                \n\t\t//遍历配置url的参数列表\n                for (Map.Entry<String, String> entry : configuratorUrl.getParameters().entrySet()) {\n                    //参数key\n                    String key = entry.getKey();\n                    //参数value\n                    String value = entry.getValue();\n                    \n\t\t    if (key.startsWith(\"~\") || Constants.APPLICATION_KEY.equals(key) || Constants.SIDE_KEY.equals(key)) {\n\t\t\t//参数key = (application || side || ^~ )\n                        \n\t\t\t//添加该key参数\n                        condtionKeys.add(key);\n                        \n\t\t\tif (value != null && !Constants.ANY_VALUE.equals(value)\n                                && !value.equals(url.getParameter(key.startsWith(\"~\") ? key.substring(1) : key))) {\n                            //如果 当前url的key参数的值 != * 并且 不等于 配置url的key参数的值，则直接返回当前url\n                            return url;\n                        }\n                    }\n                }\n                //从配置url中移除condtionKeys参数，然后执行配置\n                return doConfigure(url, configuratorUrl.removeParameters(condtionKeys));\n            }\n        }\n        return url;\n    }\n\n    /**\n     * 1、具有特定主机IP的URL比0.0.0.0的优先级高\n     * 2、如果两个url有相同的host，比较priority字段的值\n     */\n    @Override\n    public int compareTo(Configurator o) {\n        if (o == null) {\n            return -1;\n        }\n\n        int ipCompare = getUrl().getHost().compareTo(o.getUrl().getHost());\n        if (ipCompare == 0) {\n            int i = getUrl().getParameter(Constants.PRIORITY_KEY, 0),\n                    j = o.getUrl().getParameter(Constants.PRIORITY_KEY, 0);\n            if (i < j) {\n                return -1;\n            } else if (i > j) {\n                return 1;\n            } else {\n                return 0;\n            }\n        } else {\n            return ipCompare;\n        }\n    }\n    \n    //抽象方法，执行相应配置策略\n    protected abstract URL doConfigure(URL currentUrl, URL configUrl);\n\n}\n```\n#### AbsentConfigurator实现类\n```java\npublic class AbsentConfigurator extends AbstractConfigurator {\n\n    public AbsentConfigurator(URL url) {\n        super(url);\n    }\n    \n    /**\n     * @currentUrl 服务提供者url\n     * @configUrl  配置url\n     */\n    @Override\n    public URL doConfigure(URL currentUrl, URL configUrl) {\n        //将配置url中的参数添加到服务提供者url参数中(只会添加不存在的，不会覆盖已存在的参数)\n        return currentUrl.addParametersIfAbsent(configUrl.getParameters());\n    }\n}\n\n/**\n * 只有原服务提供者url中不包含该参数时，才会添加，不会覆盖\n */\npublic URL addParametersIfAbsent(Map<String, String> parameters) {\n        if (parameters == null || parameters.size() == 0) {\n            return this;\n        }\n        //A-1,B-2,C-2 覆盖url\n        //A-2,B-2     原服务提供者url参数\n        //A-2,B-2,C-2 新的服务提供者url参数\n        Map<String, String> map = new HashMap<String, String>(parameters);\n        map.putAll(getParameters());\n        return new URL(protocol, username, password, host, port, path, map);\n}\n```\n\n#### OverrideConfigurator实现类\n```java\npublic class OverrideConfigurator extends AbstractConfigurator {\n\n    public OverrideConfigurator(URL url) {\n        super(url);\n    }\n \n    /**\n     * @currentUrl 服务提供者url\n     * @configUrl  配置url\n     */\n    @Override\n    public URL doConfigure(URL currentUrl, URL configUrl) {\n        //将配置url中的参数添加到服务提供者url参数中\n        return currentUrl.addParameters(configUrl.getParameters());\n    }\n}\n\n/**\n * 将配置url中的参数添加到服务提供者url参数中(会覆盖)\n */\npublic URL addParameters(Map<String, String> parameters) {\n\tif (parameters == null || parameters.size() == 0) {\n\t    return this;\n\t}\n\t//参数值没有发生变化\n\tboolean hasAndEqual = true;\n\tfor (Map.Entry<String, String> entry : parameters.entrySet()) {\n\t    //获取当前服务提供者url的参数值\n\t    String value = getParameters().get(entry.getKey());\n\t    if (value == null) {\n\t\t//当前服务提供者url中的参数值为空，并且覆盖url中的参数值不为空\n\t\tif (entry.getValue() != null) {\n\t\t    hasAndEqual = false;\n\t\t    break;\n\t\t}\n\t    } else {\n\t\t//当前服务提供者url中的参数值不为空，并且和覆盖url中的参数值不相等\n\t\tif (!value.equals(entry.getValue())) {\n\t\t    hasAndEqual = false;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tif (hasAndEqual) {\n\t    //没有发生变化。立即返回\n\t    return this;\n\t}\n\tMap<String, String> map = new HashMap<String, String>(getParameters());\n\t//使用配置url中的参数值覆盖当前服务提供者url中的参数值\n\tmap.putAll(parameters);\n\treturn new URL(protocol, username, password, host, port, path, map);\n}\n```\n\n#### 配置工厂类\n工厂类用来创建相应的配置策略实现类\n```java\npublic class AbsentConfiguratorFactory implements ConfiguratorFactory {\n    @Override\n    public Configurator getConfigurator(URL url) {\n        return new AbsentConfigurator(url);\n    }\n}\n\npublic class OverrideConfiguratorFactory implements ConfiguratorFactory {\n    @Override\n    public Configurator getConfigurator(URL url) {\n        return new OverrideConfigurator(url);\n    }\n}\n```\n配置扩展\n```java\noverride=com.alibaba.dubbo.rpc.cluster.configurator.override.OverrideConfiguratorFactory\nabsent=com.alibaba.dubbo.rpc.cluster.configurator.absent.AbsentConfiguratorFactory\n```\n\n自定义的配置策略实现，可以自行参照AbsentConfigurator类进行实现，本小节就先介绍到这里了。","tags":["dubbo"]},{"title":"Dubbo源码阅读之Router","url":"/blog/2018/08/30/Dubbo源码阅读之Router/","content":">Router负责从多个Invoker中按路由规则选出子集,比如读写分离,应用隔离,白名单等\n路由规则确定一个服务调用的目标服务器.它有两种路由规则：条件路由规则和脚本路由规则。同时也支持扩展。\n![](img/read-write.png)\n![](img/rule.png)\n\nRouter相关类图如下：\n![](img/router.jpg)\n\n在AbstractDirectory抽象类的list方法，以及RegistryDirectory类的route方法中将会调用Router类的route方法筛选invoker列表。\n```java\n//AbstractDirectory抽象类的list方法\n@Override\npublic List<Invoker<T>> list(Invocation invocation) throws RpcException {\n\tif (destroyed) {\n\t    throw new RpcException(\"Directory already destroyed .url: \" + getUrl());\n\t}\n\t//根据invocation获取invokers列表(根据方法名查询缓存methodInvokerMap)\n\tList<Invoker<T>> invokers = doList(invocation);\n\tList<Router> localRouters = this.routers;\n\tif (localRouters != null && !localRouters.isEmpty()) {\n\t    //遍历路由\n\t    for (Router router : localRouters) {\n\t\ttry {\n\t\t    if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) {\n\t\t\t//如果url的runtime配置为true,则每次都会进行route\n\t\t\t//执行路由，进行过滤\n\t\t\tinvokers = router.route(invokers, getConsumerUrl(), invocation);\n\t\t    }\n\t\t} catch (Throwable t) {\n\t\t    logger.error(\"Failed to execute router: \" + getUrl() + \", cause: \" + t.getMessage(), t);\n\t\t}\n\t    }\n\t}\n\treturn invokers;\n}\n\n//RegistryDirectory类的route方法中\nprivate List<Invoker<T>> route(List<Invoker<T>> invokers, String method) {\n\t//创建Invocation对象\n\tInvocation invocation = new RpcInvocation(method, new Class<?>[0], new Object[0]);\n\t//获取路由列表\n\tList<Router> routers = getRouters();\n\tif (routers != null) {\n\t    for (Router router : routers) {\n\t\tif (router.getUrl() != null) {\n\t\t    //执行路由\n\t\t    invokers = router.route(invokers, getConsumerUrl(), invocation);\n\t\t}\n\t    }\n\t}\n\treturn invokers;\n}\n```\n\n### Router接口\n```java\npublic interface Router extends Comparable<Router> {\n\n    /**\n     * 获取路由url\n     * @return url\n     */\n    URL getUrl();\n\n    /**\n     * 执行路由\n     * @param invokers\n     * @param url  refer url\n     * @param invocation\n     * @return routed invokers\n     */\n    <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException;\n}\n```\n#### ConditionRouter实现类\nConditionRouter：基于条件表达式的路由规则，它的条件规则如下：\n* => 之前的为消费者匹配条件，所有参数和消费者的 URL 进行对比，当消费者满足匹配条件时，对该消费者执行后面的过滤规则。\n* => 之后为提供者地址列表的过滤条件，所有参数和提供者的 URL 进行对比，消费者最终只拿到过滤后的地址列表。\n* 如果匹配条件为空，表示对所有消费方应用，如：=> host != 10.20.153.11\n* 如果过滤条件为空，表示禁止访问，如：host = 10.20.153.10 =>\n```java\npublic class ConditionRouter implements Router, Comparable<Router> {\n\n    private static final Logger logger = LoggerFactory.getLogger(ConditionRouter.class);\n\n    /**\n     * 路由正则\n     */\n    private static Pattern ROUTE_PATTERN = Pattern.compile(\"([&!=,]*)\\\\s*([^&!=,\\\\s]+)\");\n    /**\n     * 路由url\n     */\n    private final URL url;\n    /**\n     * 优先级 优先级越大排得越靠前，默认为0\n     */\n    private final int priority;\n    /**\n     * 是否强制执行路由\n     */\n    private final boolean force;\n    /**\n     * <method,[list*,get*]>\n     */\n    private final Map<String, MatchPair> whenCondition;\n    /**\n     * <host,[192.168.99.60]>\n     */\n    private final Map<String, MatchPair> thenCondition;\n\n    public ConditionRouter(URL url) {\n        this.url = url;\n        //从url中获取priority参数\n        this.priority = url.getParameter(Constants.PRIORITY_KEY, 0);\n        //从url中获取force参数\n        this.force = url.getParameter(Constants.FORCE_KEY, false);\n        try {\n            //从url中获取rule参数，并解码\n            String rule = url.getParameterAndDecoded(Constants.RULE_KEY);\n            if (rule == null || rule.trim().length() == 0) {\n                //无效的路由规则\n                throw new IllegalArgumentException(\"Illegal route rule!\");\n            }\n            //从路由规则中移除consumer.和provider.\n            rule = rule.replace(\"consumer.\", \"\").replace(\"provider.\", \"\");\n            //查看路由规则中是否存在\"=>\"符号，并获取出现的位置i\n            int i = rule.indexOf(\"=>\");\n            //如果路由规则中不存在=>符号，则when为null,否则=>符号的左侧部分为when\n            String whenRule = i < 0 ? null : rule.substring(0, i).trim();\n            //如果路由规则中不存在=>符号，则整个路由规则都是then，否则=>符号右侧部分为then\n            String thenRule = i < 0 ? rule.trim() : rule.substring(i + 2).trim();\n            //解析规则\n            Map<String, MatchPair> when = StringUtils.isBlank(whenRule) || \"true\".equals(whenRule) ? new HashMap<String, MatchPair>() : parseRule(whenRule);\n            Map<String, MatchPair> then = StringUtils.isBlank(thenRule) || \"false\".equals(thenRule) ? null : parseRule(thenRule);\n            // NOTE: It should be determined on the business level whether the `When condition` can be empty or not.\n            //提示：应该在业务层面搞定`When condition` 是否可以为empty 或者not empty\n            this.whenCondition = when;\n            this.thenCondition = then;\n        } catch (ParseException e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    /**\n     * 解析规则\n     * @param rule\n     * @return\n     * @throws ParseException\n     */\n    private static Map<String, MatchPair> parseRule(String rule) throws ParseException {\n        Map<String, MatchPair> condition = new HashMap<String, MatchPair>();\n        if (StringUtils.isBlank(rule)) {\n            //路由规则为空，则直接返回\n            return condition;\n        }\n        //kv对，存储匹配和不匹配的条件\n        MatchPair pair = null;\n        // 多个值 \n        Set<String> values = null;\n        //使用正则进行匹配 method = find*,list*,get*,is*\n        final Matcher matcher = ROUTE_PATTERN.matcher(rule);\n        //尝试逐一匹配\n        while (matcher.find()) {\n            String separator = matcher.group(1);\n            String content = matcher.group(2);\n            //条件表达式的开始部分\n            if (separator == null || separator.length() == 0) {\n                pair = new MatchPair();\n                condition.put(content, pair);\n            }\n            //条件表达式的KV部分\n            else if (\"&\".equals(separator)) {\n                if (condition.get(content) == null) {\n                    pair = new MatchPair();\n                    condition.put(content, pair);\n                } else {\n                    pair = condition.get(content);\n                }\n            }\n            //KV部分的值\n            else if (\"=\".equals(separator)) {\n                if (pair == null) {\n                    throw new ParseException(\"Illegal route rule \\\"\"\n                            + rule + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\", matcher.start());\n                }\n                values = pair.matches;\n                values.add(content);\n            }\n            else if (\"!=\".equals(separator)) {\n                if (pair == null) {\n                    throw new ParseException(\"Illegal route rule \\\"\"\n                            + rule + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\", matcher.start());\n                }\n                values = pair.mismatches;\n                values.add(content);\n            }\n            // kv的value部分，其中value有多个值，使用逗号分隔\n            else if (\",\".equals(separator)) { // Should be seperateed by ','\n                if (values == null || values.isEmpty()) {\n                    throw new ParseException(\"Illegal route rule \\\"\"\n                            + rule + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\", matcher.start());\n                }\n                values.add(content);\n            } else {\n                throw new ParseException(\"Illegal route rule \\\"\" + rule\n                        + \"\\\", The error char '\" + separator + \"' at index \"\n                        + matcher.start() + \" before \\\"\" + content + \"\\\".\", matcher.start());\n            }\n        }\n        return condition;\n    }\n\n    @Override\n    public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation)\n            throws RpcException {\n        if (invokers == null || invokers.isEmpty()) {\n            return invokers;\n        }\n        try {\n            if (!matchWhen(url, invocation)) {\n\t        //不匹配when规则，直接返回\n                return invokers;\n            }\n            List<Invoker<T>> result = new ArrayList<Invoker<T>>();\n            if (thenCondition == null) {\n\t        //当前消费者在服务黑名单里\n                logger.warn(\"The current consumer in the service blacklist. consumer: \" + NetUtils.getLocalHost() + \", service: \" + url.getServiceKey());\n                return result;\n            }\n            for (Invoker<T> invoker : invokers) {\n                if (matchThen(invoker.getUrl(), url)) {\n\t\t    //成功匹配then规则，添加到结果集\n                    result.add(invoker);\n                }\n            }\n            if (!result.isEmpty()) {\n                return result;\n            } else if (force) { \n\t        //强制执行 \n                logger.warn(\"The route result is empty and force execute. consumer: \" + NetUtils.getLocalHost() + \", service: \" + url.getServiceKey() + \", router: \" + url.getParameterAndDecoded(Constants.RULE_KEY));\n                return result;\n            }\n        } catch (Throwable t) {\n            logger.error(\"Failed to execute condition router rule: \" + getUrl() + \", invokers: \" + invokers + \", cause: \" + t.getMessage(), t);\n        }\n\t//没有一个符合规则的Provider,则直接返回。5\n        return invokers;\n    }\n\n    @Override\n    public URL getUrl() {\n        return url;\n    }\n\t\n    //是否匹配when规则\n    boolean matchWhen(URL url, Invocation invocation) {\n        return whenCondition == null || whenCondition.isEmpty() || matchCondition(whenCondition, url, null, invocation);\n    }\n    \n    //url参数为invoker的url属性\n    private boolean matchThen(URL url, URL param) {\n        //then规则不为空，且匹配then规则，则返回true\n        return !(thenCondition == null || thenCondition.isEmpty()) && matchCondition(thenCondition, url, param, null);\n    }\n\n    /**\n     * 匹配条件\n     * @param condition\n     * @param url\n     * @param param\n     * @param invocation\n     * @return\n     */\n    private boolean matchCondition(Map<String, MatchPair> condition, URL url, URL param, Invocation invocation) {\n        //获取url参数，即消费者的parameters的Map集合\n\tMap<String, String> sample = url.toMap();\n        boolean result = false;\n        for (Map.Entry<String, MatchPair> matchPair : condition.entrySet()) {\n            //例如：method，或者url中的某个参数\n\t    String key = matchPair.getKey();\n            String sampleValue;\n            if (invocation != null && (Constants.METHOD_KEY.equals(key) || Constants.METHODS_KEY.equals(key))) {\n                //key=method，则从invocation中获取真实方法名\n\t\tsampleValue = invocation.getMethodName();\n            } else {\n\t        //从url参数中获取key对应的值\n                sampleValue = sample.get(key);\n                if (sampleValue == null) {\n\t\t    //添加前缀default.进行获取\n                    sampleValue = sample.get(Constants.DEFAULT_KEY_PREFIX + key);\n                }\n            }\n            if (sampleValue != null) {\n\t        //调用MatchPair的isMatch方法进行匹配\n                if (!matchPair.getValue().isMatch(sampleValue, param)) {\n                    return false;\n                } else {\n                    result = true;\n                }\n            } else {\n                if (!matchPair.getValue().matches.isEmpty()) {\n                    return false;\n                } else {\n                    result = true;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * 内部类\n     */\n    private static final class MatchPair {\n        final Set<String> matches = new HashSet<String>();\n        final Set<String> mismatches = new HashSet<String>();\n    \n        //value为调用的方法名，或者为url自定义参数的值\n\t//param参数为route方法的url参数，即ref url\n        private boolean isMatch(String value, URL param) {\n            if (!matches.isEmpty() && mismatches.isEmpty()) {\n                //存在=，不存在!=\n                for (String match : matches) {\n                    //进行匹配\n                    if (UrlUtils.isMatchGlobPattern(match, value, param)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            if (!mismatches.isEmpty() && matches.isEmpty()) {\n                //存在!=,不存在=\n                for (String mismatch : mismatches) {\n                    if (UrlUtils.isMatchGlobPattern(mismatch, value, param)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            if (!matches.isEmpty() && !mismatches.isEmpty()) {\n                //存在=，也存在!=,优先使用!=\n                for (String mismatch : mismatches) {\n                    if (UrlUtils.isMatchGlobPattern(mismatch, value, param)) {\n                        return false;\n                    }\n                }\n                for (String match : matches) {\n                    if (UrlUtils.isMatchGlobPattern(match, value, param)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            return false;\n        }\n    }\n}\n\n//param参数为route方法的url参数\npublic static boolean isMatchGlobPattern(String pattern, String value, URL param) {\n\tif (param != null && pattern.startsWith(\"$\")) {\n\t    pattern = param.getRawParameter(pattern.substring(1));\n\t}\n\treturn isMatchGlobPattern(pattern, value);\n}\n\npublic static boolean isMatchGlobPattern(String pattern, String value) {\n\tif (\"*\".equals(pattern)) {\n\t    return true;\n\t}\n\tif ((pattern == null || pattern.length() == 0) && (value == null || value.length() == 0)) {\n\t    return true;\n\t}\n\tif ((pattern == null || pattern.length() == 0) || (value == null || value.length() == 0)) {\n\t    return false;\n\t}\n        //获取*号最后出现的位置\n\tint i = pattern.lastIndexOf('*');\n\t// 没有 \"*\"\n\tif (i == -1) {\n\t    return value.equals(pattern);\n\t}\n\t// \"*\" 为最后\n\telse if (i == pattern.length() - 1) {\n\t    return value.startsWith(pattern.substring(0, i));\n\t}\n\t// \"*\" 在开始处\n\telse if (i == 0) {\n\t    return value.endsWith(pattern.substring(i + 1));\n\t}\n\t// \"*\" 在中间\n\telse {\n\t    String prefix = pattern.substring(0, i);\n\t    String suffix = pattern.substring(i + 1);\n\t    return value.startsWith(prefix) && value.endsWith(suffix);\n\t}\n}\n```\n\n##### 调试parseRule方法\n我们使用一个例子来debug下parseRule方法\n```java\npublic static void main(String[] args) throws ParseException {\n        //我们定义一个规则：method = find*,list*,get*,is* => host = 192.168.99.60,192.168.99.61\n\tString rule = \"method = find*,list*,get*,is* => host = 192.168.99.60,192.168.99.61\";\n\t\n\trule = rule.replace(\"consumer.\", \"\").replace(\"provider.\", \"\");\n\t\n\t//查看路由规则中是否存在\"=>\"符号，并获取出现的位置i\n\tint i = rule.indexOf(\"=>\");\n\tString whenRule = i < 0 ? null : rule.substring(0, i).trim();\n\t\n\t//如果路由规则中不存在=>符号，则整个路由规则都是then，否则=>符号右侧部分为then\n\tString thenRule = i < 0 ? rule.trim() : rule.substring(i + 2).trim();\n\t\n\t//解析规则\n\tMap<String, MatchPair> when = StringUtils.isBlank(whenRule) || \"true\".equals(whenRule) ? new HashMap<String, MatchPair>() : parseRule(whenRule);\n\tMap<String, MatchPair> then = StringUtils.isBlank(thenRule) || \"false\".equals(thenRule) ? null : parseRule(thenRule);\n}\n\n//parseRule方法部分源码\nMap<String, MatchPair> condition = new HashMap<String, MatchPair>();\nfinal Matcher matcher = ROUTE_PATTERN.matcher(rule);\n//尝试逐一匹配\nwhile (matcher.find()) {\n    String separator = matcher.group(1);\n    String content = matcher.group(2);\n}\n```\n当解析when规则的时候，在while循环中将会依次解析出如下值(第二个分割线以下的内容是解析then时的结果)：\n```java\nseparator   content\n------------------------------------\n    \"\"      method(第一次遍历)\n    =\t    find*\n    ,       list*\n    ,       get*\n    ,       is*\n------------------------------------\n    \"\"\t    host\n    =       192.168.99.60\n    ,       192.168.99.61\n```\n其中第一次遍历时，separator为空，content为method，此时将会新建一个MatchPair对象，然后放入到condition哈希中，后面的遍历将会按照separator值的不同进入到不同的分支，然后把content值加入到MatchPair对象的matches集合中(separator为=号则放入matches集合,为!=则放入mismatches集合中)。\n```java\nif (separator == null || separator.length() == 0) {\n\tpair = new MatchPair();\n\tcondition.put(content, pair);\n}\n```\n解析then规则的过程类似，这里就不介绍了。\n\n\n#### ScriptRouter实现类\n![](img/ScriptRouter.png)\n```java\npublic class ScriptRouter implements Router {\n\n    /**\n     * <脚本类型，脚本引擎>\n     */\n    private static final Map<String, ScriptEngine> engines = new ConcurrentHashMap<String, ScriptEngine>();\n\n    /**\n     * 当前使用的脚本引擎\n     */\n    private final ScriptEngine engine;\n\n    /**\n     * 优先级\n     */\n    private final int priority;\n    /**\n     * 路由规则\n     */\n    private final String rule;\n\n    /**\n     * 路由url\n     */\n    private final URL url;\n\n    public ScriptRouter(URL url) {\n        this.url = url;\n        //获取url的type参数，标识脚本类型，如：js、groovy\n        String type = url.getParameter(Constants.TYPE_KEY);\n        //获取url的priority参数，标识优先级\n        this.priority = url.getParameter(Constants.PRIORITY_KEY, 0);\n        //获取url的rule参数，标识脚本规则\n        String rule = url.getParameterAndDecoded(Constants.RULE_KEY);\n        if (type == null || type.length() == 0) {\n            //默认脚本类型，javascript\n            type = Constants.DEFAULT_SCRIPT_TYPE_KEY;\n        }\n        if (rule == null || rule.length() == 0) {\n            //路由规则不可以为空\n            throw new IllegalStateException(new IllegalStateException(\"route rule can not be empty. rule:\" + rule));\n        }\n        //根据脚本类型,从缓存中获取脚本引擎\n        ScriptEngine engine = engines.get(type);\n        if (engine == null) {\n            //根据脚本类型type创建一个脚本引擎\n            engine = new ScriptEngineManager().getEngineByName(type);\n            if (engine == null) {\n                throw new IllegalStateException(new IllegalStateException(\"Unsupported route rule type: \" + type + \", rule: \" + rule));\n            }\n            //放入缓存\n            engines.put(type, engine);\n        }\n        this.engine = engine;\n        this.rule = rule;\n    }\n\n    @Override\n    public URL getUrl() {\n        return url;\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {\n        try {\n            List<Invoker<T>> invokersCopy = new ArrayList<Invoker<T>>(invokers);\n            Compilable compilable = (Compilable) engine;\n            //将参数传递到脚本引擎\n            Bindings bindings = engine.createBindings();\n            bindings.put(\"invokers\", invokersCopy);\n            bindings.put(\"invocation\", invocation);\n            bindings.put(\"context\", RpcContext.getContext());\n            //编译规则脚本\n            CompiledScript function = compilable.compile(rule);\n            //执行脚本，返回筛选后的invokers列表\n            Object obj = function.eval(bindings);\n            if (obj instanceof Invoker[]) {\n                invokersCopy = Arrays.asList((Invoker<T>[]) obj);\n            } else if (obj instanceof Object[]) {\n                invokersCopy = new ArrayList<Invoker<T>>();\n                for (Object inv : (Object[]) obj) {\n                    invokersCopy.add((Invoker<T>) inv);\n                }\n            } else {\n                invokersCopy = (List<Invoker<T>>) obj;\n            }\n            return invokersCopy;\n        } catch (ScriptException e) {\n            //fail then ignore rule .invokers.\n            logger.error(\"route error , rule has been ignored. rule: \" + rule + \", method:\" + invocation.getMethodName() + \", url: \" + RpcContext.getContext().getUrl(), e);\n            return invokers;\n        }\n    }\n}\n```\n\n#### MockInvokersSelector实现类\nMockInvokersSelector：其实就是用于路由 Mock 服务与非Mock服务。\nDubbo默认会在AbstractDirectory#setRouters方法中自动添加MockInvokersSelector路由规则。\n```java\npublic class MockInvokersSelector implements Router{\n\n    @Override\n    public <T> List<Invoker<T>> route(final List<Invoker<T>> invokers,URL url, final Invocation invocation) throws RpcException {\n        if (invocation.getAttachments() == null) {\n            //附加参数为空\n            //返回不支持mock协议的invoker\n            return getNormalInvokers(invokers);\n        } else {\n            //从附加参数中获取invocation.need.mock属性的值\n            String value = invocation.getAttachments().get(Constants.INVOCATION_NEED_MOCK);\n            if (value == null) {\n                //返回不支持mock协议的invoker\n                return getNormalInvokers(invokers);\n            } else if (Boolean.TRUE.toString().equalsIgnoreCase(value)) {\n                //如果invocation.need.mock = true,则返回mock-Invokers\n                return getMockedInvokers(invokers);\n            }\n        }\n        return invokers;\n    }\n    ....省略其他方法....\n}\n\npublic abstract class AbstractDirectory<T> implements Directory<T> {\n    \n    /**\n     * 设置路由\n     * 1、添加：收到notify通知的routers、当前url的router参数、new MockInvokersSelector()\n     * 2、将routers排序\n     * 3、缓存routers\n     * @param routers 收到notify通知的routers\n     */\n    protected void setRouters(List<Router> routers) {\n        routers = routers == null ? new ArrayList<Router>() : new ArrayList<Router>(routers);\n        //获取路由器工厂扩展名称，router参数\n        String routerkey = url.getParameter(Constants.ROUTER_KEY);\n        if (routerkey != null && routerkey.length() > 0) {\n            //根据路由器工厂扩展名获取扩展实例\n            RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getExtension(routerkey);\n            //根据url获取路由器实例，并放入routers\n            routers.add(routerFactory.getRouter(url));\n        }\n        //添加支持mock协议的invoker选择器\n        routers.add(new MockInvokersSelector());\n        //排序\n        Collections.sort(routers);\n        this.routers = routers;\n    }\n    ....省略其他方法....\n}\n \n```\n\n#### 自定义Router\n假如我们的服务提供者分为多个不同的组，我们想要根据某个调用参数调用不同的组。\n我们可以自定义一个CustomRouter类，然后实现route方法。\n\n```java\npublic class CustomRouter extends ConditionRouter{\n\n    @Override\n    public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation)throws RpcException {\n        if (invokers == null || invokers.isEmpty()) {\n            return invokers;\n        }\n\t//获取调用参数\n\tObject[] arguments = invocation.getArguments();\n        if(arguments == null || arguments.length == 0){\n            logger.error(\"方法: {} 缺少路由参数routeKey\",invocation.getMethodName());\n            return null;\n        }\n\t//获取路由key\n        Object routeKey = arguments[0];\n\tString consumerGroup = getGroup(routeKey);\n\t//String consumerGroup = url.getParameter(Constants.GROUP_KEY);\n\n        List<Invoker<T>> result = new ArrayList<Invoker<T>>();\n\tfor (Invoker<T> invoker : invokers) {\n\t    //获取服务提供者的group参数\n            String group = invoker.getUrl().getParameter(Constants.GROUP_KEY);\n            \n\t    //判断当前服务提供者的group是否和当前调用参数中的group是否匹配\n\t    if (consumerGroup.equals(group)) {\n\t        //匹配的话，则保存当前服务提供者\n                result.add(invoker);\n            }\n        }\n\tif(result.size() > 0){\n\t   //返回匹配的服务提供者组\n\t   return result;\n\t}\n        return invokers;\n    }\n    \n    /**\n     * 获取group\n     */\n    private String getGroup(String routeKey){\n\tif(routeKey.endsWith(\"1\")){\n\t   return \"v1\";\n\t}else{\n\t   return \"v2\";\n\t}\n    }\n}\n\n/**\n * 工厂\n */\npublic class CustomRouterFactory implements RouterFactory {\n\n    public static final String NAME = \"custom\";\n\n    @Override\n    public Router getRouter(URL url) {\n        return new CustomRouter(url);\n    }\n\n}\n```\n\n然后我们配置扩展，让dubbo可以自动发现。\n```java\ncustom=com.alibaba.dubbo.rpc.cluster.router.custom.CustomRouterFactory\n```\n\n然后配置路由规则，例如可以在RegistryProtocol类的register方法中加入添加路由规则进行断点测试。\n```java\npublic void register(URL registryUrl, URL registedProviderUrl) {\n        //获取注册中心\n\tRegistry registry = registryFactory.getRegistry(registryUrl);\n\t//注册服务提供者\n\tregistry.register(registedProviderUrl);\n\t\n\t//测试代码(添加路由规则),group=foo标识对指定的foo组生效\n\t#URL routerUrl = URL.valueOf(\"routers://0.0.0.0/com.alibaba.dubbo.demo.DemoService?name=test&category=routers&router=custom&dynamic=false&version=1.0&group=foo\");\n\tURL routerUrl = URL.valueOf(\"routers://0.0.0.0/com.alibaba.dubbo.demo.DemoService?name=test&category=routers&router=custom&dynamic=false\");\n\tregistry.register(routerUrl);\n}\n```\n\n最后模拟消费者调用进行测试即可。\n\n\n\n\n\n\n\n\n\n\n\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之服务引用","url":"/blog/2018/08/23/Dubbo源码阅读之服务引用/","content":">本小节讲解上小节遗留的ref = createProxy(map)方法，不了解的可以先看下上篇文章《Dubbo源码阅读之集成Spring-0202注解解析》\n\n该方法定义在ReferenceConfig类中，在调用init方法进行初始化时，会调用createProxy方法来生成代理对象。\n\n### createProxy创建代理\n```java\n/**\n * 创建代理\n */\nprivate T createProxy(Map<String, String> map) {\n\tURL tmpUrl = new URL(\"temp\", \"localhost\", 0, map);\n\tfinal boolean isJvmRefer;\n\t//是否引用本地服务，新版使用： scope=local来判断\n\tif (isInjvm() == null) {\n\t    if (url != null && url.length() > 0) {\n\t\t//如果配置中指定了url属性，则不使用本地引用\n\t\tisJvmRefer = false;\n\t    } else if (InjvmProtocol.getInjvmProtocol().isInjvmRefer(tmpUrl)) {\n\t\t//默认情况下，如果有本地服务，则引用本地服务\n\t\tisJvmRefer = true;\n\t    } else {\n\t\tisJvmRefer = false;\n\t    }\n\t} else {\n\t    isJvmRefer = isInjvm().booleanValue();\n\t}\n\tif (isJvmRefer) {\n\t    //构建本地协议\n\t    URL url = new URL(Constants.LOCAL_PROTOCOL, NetUtils.LOCALHOST, 0, interfaceClass.getName()).addParameters(map);\n\t    //引用本地服务(后面会分析该方法)\n\t    invoker = refprotocol.refer(interfaceClass, url);\n\t    if (logger.isInfoEnabled()) {\n\t\tlogger.info(\"Using injvm service \" + interfaceClass.getName());\n\t    }\n\t} else {\n\t    if (url != null && url.length() > 0) {\n\t\t//用户指定了URL属性，可以是p2p地址或者注册中心的地址，多个地址使用\";\"分隔\n\t\tString[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);\n\t\tif (us != null && us.length > 0) {\n\t\t    for (String u : us) {\n\t\t\tURL url = URL.valueOf(u);\n\t\t\tif (url.getPath() == null || url.getPath().length() == 0) {\n\t\t\t    //path为空时，使用服务接口名称作为path\n\t\t\t    url = url.setPath(interfaceName);\n\t\t\t}\n\t\t\tif (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n\t\t\t    //注册中心协议，添加引用标识refer参数\n\t\t\t    urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));\n\t\t\t} else {\n\t\t\t    //p2p地址(后面会分析该方法)\n\t\t\t    urls.add(ClusterUtils.mergeUrl(url, map));\n\t\t\t}\n\t\t    }\n\t\t}\n\t    } else {\n\t\t//从注册中心配置中组装URL(后面会分析该方法)\n\t\tList<URL> us = loadRegistries(false);\n\t\tif (us != null && !us.isEmpty()) {\n\t\t    //遍历注册中心us(后面会分析该方法)\n\t\t    for (URL u : us) {\n\t\t\t//加载监控url(后面会分析该方法)\n\t\t\tURL monitorUrl = loadMonitor(u);\n\t\t\tif (monitorUrl != null) {\n\t\t\t    //添加monitor参数\n\t\t\t    map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));\n\t\t\t}\n\t\t\t//添加refer参数\n\t\t\turls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));\n\t\t    }\n\t\t}\n\t\tif (urls == null || urls.isEmpty()) {\n\t\t    //在消费者端，没有配置注册中心，因此无法引用相应服务接口\n\t\t    throw new IllegalStateException(\"No such any registry to reference \" + interfaceName + \" on the consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion() + \", please config <dubbo:registry address=\\\"...\\\" /> to your spring config.\");\n\t\t}\n\t    }\n\t    if (urls.size() == 1) {\n\t\t//引用一个远程服务(后面会分析该方法)\n\t\t//registry://172.172.172.47:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&dubbo=2.0.0&pid=1172&qos.port=33333&refer=application%3Ddemo-consumer%26check%3Dfalse%26dubbo%3D2.0.0%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D1172%26qos.port%3D33333%26register.ip%3D192.168.99.60%26side%3Dconsumer%26timestamp%3D1535094943004&registry=zookeeper&timestamp=1535095022853\n\t\tinvoker = refprotocol.refer(interfaceClass, urls.get(0));\n\t    } else {\n\t\t//如果有多个url\n\t\tList<Invoker<?>> invokers = new ArrayList<Invoker<?>>();\n\t\tURL registryURL = null;\n\t\tfor (URL url : urls) {\n\t\t    //记录\"远程引用\"\n\t\t    invokers.add(refprotocol.refer(interfaceClass, url));\n\t\t    if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n\t\t\t//使用最后一个注册中心url\n\t\t\tregistryURL = url;\n\t\t    }\n\t\t}\n\t\tif (registryURL != null) {\n\t\t    //有注册中心协议的URL，使用AvailableCluster\n\t\t    URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);\n\t\t    invoker = cluster.join(new StaticDirectory(u, invokers));\n\t\t} else { \n\t\t    //不是注册中心的url\n\t\t    invoker = cluster.join(new StaticDirectory(invokers));\n\t\t}\n\t    }\n\t}\n\t//检测服务提供者是否存在\n\tBoolean c = check;\n\tif (c == null && consumer != null) {\n\t    c = consumer.isCheck();\n\t}\n\tif (c == null) {\n\t    //默认需要检测服务提供者是否存在\n\t    c = true;\n\t}\n\t//检测服务提供者是否存在\n\tif (c && !invoker.isAvailable()) {\n\t    throw new IllegalStateException(\"Failed to check the status of the service \" + interfaceName + \". No provider available for the service \" + (group == null ? \"\" : group + \"/\") + interfaceName + (version == null ? \"\" : \":\" + version) + \" from the url \" + invoker.getUrl() + \" to the consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion());\n\t}\n\tif (logger.isInfoEnabled()) {\n\t    logger.info(\"Refer dubbo service \" + interfaceClass.getName() + \" from url \" + invoker.getUrl());\n\t}\n\t//创建服务代理\n\treturn (T) proxyFactory.getProxy(invoker);\n}\n\n/**\n * 构造注册中心URL\n * @param provider\n * @return\n */\nprotected List<URL> loadRegistries(boolean provider) {\n\t//检测是否配置了RegistryConfig，并配置\n\tcheckRegistry();\n\tList<URL> registryList = new ArrayList<URL>();\n\tif (registries != null && !registries.isEmpty()) {\n\t    //遍历注册中心配置\n\t    for (RegistryConfig config : registries) {\n\t\t//获取当前注册中心地址，例如： zookeeper://172.172.172.47:2181\n\t\tString address = config.getAddress();\n\t\tif (address == null || address.length() == 0) {\n\t\t    //设置address = 0.0.0.0\n\t\t    address = Constants.ANYHOST_VALUE;\n\t\t}\n\t\t//从系统配置中获取注册中心地址\n\t\tString sysaddress = System.getProperty(\"dubbo.registry.address\");\n\t\tif (sysaddress != null && sysaddress.length() > 0) {\n\t\t    //如果系统配置的注册中心地址不为空，则优先使用系统配置\n\t\t    address = sysaddress;\n\t\t}\n\t\tif (address != null && address.length() > 0\n\t\t\t&& !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) {\n\t\t    //注册中心地址可用\n\t\t    Map<String, String> map = new HashMap<String, String>();\n\t\t    //附加参数，即找到application、config类中的属性，并添加进来\n\t\t    appendParameters(map, application);\n\t\t    appendParameters(map, config);\n\t\t    map.put(\"path\", RegistryService.class.getName());\n\t\t    map.put(\"dubbo\", Version.getVersion());\n\t\t    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n\t\t    if (ConfigUtils.getPid() > 0) {\n\t\t\tmap.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n\t\t    }\n\t\t    if (!map.containsKey(\"protocol\")) {\n\t\t\t//添加protocol参数\n\t\t\tif (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension(\"remote\")) {\n\t\t\t    map.put(\"protocol\", \"remote\");\n\t\t\t} else {\n\t\t\t    map.put(\"protocol\", \"dubbo\");\n\t\t\t}\n\t\t    }\n\t\t    //根据address和map生成注册中心url\n\t\t    List<URL> urls = UrlUtils.parseURLs(address, map);\n\t\t    \n\t\t    //遍历注册中心url，添加registry参数,并设置protocol属性，然后保存起来\n\t\t    for (URL url : urls) {\n\t\t\t//url = zookeeper://172.172.172.47:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&dubbo=2.0.0&pid=1172&qos.port=33333&timestamp=1535095022853\n\t\t\t//添加registry参数 = zookeeper\n\t\t\turl = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());\n\t\t\t\n\t\t\t//重新设置协议为registry\n\t\t\turl = url.setProtocol(Constants.REGISTRY_PROTOCOL);\n\t\t\tif ((provider && url.getParameter(Constants.REGISTER_KEY, true))\n\t\t\t\t|| (!provider && url.getParameter(Constants.SUBSCRIBE_KEY, true))) {\n\t\t\t    //registry://172.172.172.47:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&dubbo=2.0.0&pid=1172&qos.port=33333&registry=zookeeper&timestamp=1535095022853\n\t\t\t    registryList.add(url);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\treturn registryList;\n}\n\n/**\n * 检测RegistryConfig配置\n */\nprotected void checkRegistry() {\n\t//向后兼容\n\tif (registries == null || registries.isEmpty()) {\n\t    //获取到注册中心属性配置值\n\t    String address = ConfigUtils.getProperty(\"dubbo.registry.address\");\n\t    if (address != null && address.length() > 0) {\n\t\tregistries = new ArrayList<RegistryConfig>();\n\t\t//使用\"|\"分隔注册中心，然后构造RegistryConfig对象\n\t\tString[] as = address.split(\"\\\\s*[|]+\\\\s*\");\n\t\tfor (String a : as) {\n\t\t    RegistryConfig registryConfig = new RegistryConfig();\n\t\t    registryConfig.setAddress(a);\n\t\t    registries.add(registryConfig);\n\t\t}\n\t    }\n\t}\n\tif ((registries == null || registries.isEmpty())) {\n\t    throw new IllegalStateException((getClass().getSimpleName().startsWith(\"Reference\")\n\t\t    ? \"No such any registry to refer service in consumer \"\n\t\t    : \"No such any registry to export service in provider \")\n\t\t    + NetUtils.getLocalHost()\n\t\t    + \" use dubbo version \"\n\t\t    + Version.getVersion()\n\t\t    + \", Please add <dubbo:registry address=\\\"...\\\" /> to your spring config. If you want unregister, please set <dubbo:service registry=\\\"N/A\\\" />\");\n\t}\n\tfor (RegistryConfig registryConfig : registries) {\n\t    //添加属性\n\t    appendProperties(registryConfig);\n\t}\n}\n```\n\n接下来我们看下Protocol的refer方法，在《Dubbo源码阅读之服务暴露》小节我们介绍过，将会生成Protocol$Adaptive类：\n```java\npublic class Protocol$Adaptive implements com.alibaba.dubbo.rpc.Protocol {\n\t/**\n\t * @param arg0 服务接口类\n\t * @param arg1 注册中心url\n\t */\n\tpublic com.alibaba.dubbo.rpc.Invoker refer(java.lang.Class arg0, com.alibaba.dubbo.common.URL arg1) throws com.alibaba.dubbo.rpc.RpcException {\n\t\tif (arg1 == null){\n\t\t\t//url参数不可以为空\n\t\t\tthrow new IllegalArgumentException(\"url == null\");\n\t\t}\n\t\t\n\t\tcom.alibaba.dubbo.common.URL url = arg1;\n\t\t\n\t\t//使用url的protocol属性值(这里为registry)，作为扩展名称，如果为空，则默认使用\"dubbo\"\n\t\tString extName = url.getProtocol() == null ? \"dubbo\" : url.getProtocol();\n\t\t\n\t\tif(extName == null) {\n\t\t\tthrow new IllegalStateException(\"Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(\" + url.toString() + \") use keys([protocol])\");\n\t\t}\n\t\t\n\t\t//获取扩展名称为extName的Protocol扩展实例(这里可能是被包装过的类)\n\t\tcom.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);\n\t\t\n\t\t//调用该extension实例的refer方法\n\t\treturn extension.refer(arg0, arg1);\n\t}\n}\n```\n这里和服务暴露时的流程一样，将会调用两个包装类ProtocolFilterWrapper和ProtocolListenerWrapper的refer方法。\n```java\npublic class ProtocolFilterWrapper implements Protocol {\n\t@Override\n\tpublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n\t\tif (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n\t\t    //这里将会调用ProtocolListenerWrapper类的refer方法\n\t\t    return protocol.refer(type, url);\n\t\t}\n\t\treturn buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);\n\t}\n}\n\npublic class ProtocolListenerWrapper implements Protocol {\n\t/**\n\t * @param type interface com.alibaba.dubbo.demo.DemoService\n\t * @param url  registry://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&dubbo=2.0.0&pid=1512&qos.port=33333&refer=application%3Ddemo-consumer%26check%3Dfalse%26dubbo%3D2.0.0%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D1512%26qos.port%3D33333%26register.ip%3D192.168.99.60%26side%3Dconsumer%26timestamp%3D1528340394760&registry=multicast&timestamp=1528340417091\n\t * @param <T>\n\t * @return\n\t * @throws RpcException\n\t */\n\t@Override\n\tpublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n\t\tif (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n\t\t    //这里将会调用RegistryProtocol类的refer方法\n\t\t    return protocol.refer(type, url);\n\t\t}\n\t\treturn new ListenerInvokerWrapper<T>(protocol.refer(type, url),\n\t\t\tCollections.unmodifiableList(\n\t\t\t\tExtensionLoader.getExtensionLoader(InvokerListener.class)\n\t\t\t\t\t.getActivateExtension(url, Constants.INVOKER_LISTENER_KEY)));\n\t}\n}\n```\nRegistryProtocol的refer方法：\n```java\n/**\n * @param type远程服务接口类型\n * @param url 远程服务的URL地址\n * registry://172.172.172.47:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&dubbo=2.0.0&pid=1172&qos.port=33333&refer=application%3Ddemo-consumer%26check%3Dfalse%26dubbo%3D2.0.0%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D1172%26qos.port%3D33333%26register.ip%3D192.168.99.60%26side%3Dconsumer%26timestamp%3D1535094943004&registry=zookeeper&timestamp=1535095022853\n * @return\n * @throws RpcException\n */\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n\t//生成注册中心url\n\turl = url.setProtocol(\n\t\t//设置协议，从url中的registry参数中获取注册时的协议(zookeeper)，没有获取到的话，则默认为dubbo协议\n\t\turl.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_REGISTRY)\n\t\t//然后移除registry参数\n\t).removeParameter(Constants.REGISTRY_KEY);\n\n\t//根据url获取注册中心\n\t//zookeeper://172.172.172.47:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&dubbo=2.0.0&pid=1172&qos.port=33333&refer=application%3Ddemo-consumer%26check%3Dfalse%26dubbo%3D2.0.0%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D1172%26qos.port%3D33333%26register.ip%3D192.168.99.60%26side%3Dconsumer%26timestamp%3D1535094943004&timestamp=1535095022853\n\tRegistry registry = registryFactory.getRegistry(url);\n\tif (RegistryService.class.equals(type)) {\n\t    return proxyFactory.getInvoker((T) registry, type, url);\n\t}\n\n\t//获取url中的refer参数，并转换成map\n\tMap<String, String> qs = StringUtils.parseQueryString(\n\t\turl.getParameterAndDecoded(Constants.REFER_KEY)\n\t);\n\t//获取map中的group参数\n\tString group = qs.get(Constants.GROUP_KEY);\n\tif (group != null && group.length() > 0) {\n\t    if ((Constants.COMMA_SPLIT_PATTERN.split(group)).length > 1\n\t\t    || \"*\".equals(group)) {\n\t\t//group=\"a,b\" or group=\"*\"\n\t\treturn doRefer(getMergeableCluster(), registry, type, url);\n\t    }\n\t}\n\treturn doRefer(cluster, registry, type, url);\n}\n\n/**\n *\n * @param cluster\n * @param registry 注册中心\n * @param type 远程服务接口类型\n * @param url 注册中心url\n * @return\n */\nprivate <T> Invoker<T> doRefer(Cluster cluster, Registry registry, Class<T> type, URL url) {\n\t//根据服务接口type和注册中心url创建RegistryDirectory对象(后面会分析该方法)\n\t//Directory代表多个Invoker,可以把它看成List<Invoker>，\n        //但与List不同的是,它的值可能是动态变化的,比如注册中心推送变更\n\tRegistryDirectory<T> directory = new RegistryDirectory<T>(type, url);\n\t//设置注册中心实例\n\tdirectory.setRegistry(registry);\n\t//设置协议\n\tdirectory.setProtocol(protocol);\n\t\n\t//refer参数指定的url的所有属性\n\tMap<String, String> parameters = new HashMap<String, String>(directory.getUrl().getParameters());\n\t\n\t//生成消费者url\n\t//consumer://192.168.99.60/com.alibaba.dubbo.demo.DemoService?application=demo-consumer&check=false&dubbo=2.0.0&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=1172&qos.port=33333&side=consumer&timestamp=1535094943004\n\tURL subscribeUrl = new URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), 0, type.getName(), parameters);\n\t\n\tif (!Constants.ANY_VALUE.equals(url.getServiceInterface())\n\t\t&& url.getParameter(Constants.REGISTER_KEY, true)) {\n\t    //注册消费者，添加category=consumers,check=false参数\n\t    registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,\n\t\t    Constants.CHECK_KEY, String.valueOf(false)));\n\t}\n\t\n\t//订阅此url\n\tdirectory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,\n\t\t//提供者 /dubbo/interfaceClass/providers\n\t\t//配置  /dubbo/interfaceClass/configurators\n\t\t//路由  /dubbo/interfaceClass/routers\n\t\tConstants.PROVIDERS_CATEGORY\n\t\t\t+ \",\" + Constants.CONFIGURATORS_CATEGORY\n\t\t\t+ \",\" + Constants.ROUTERS_CATEGORY));\n\t\n\t//Cluster将Directory中的多个Invoker伪装成一个Invoker,对上层透明,伪装过程包含了容错逻辑,调用失败后,重试另一个(后面会分析该方法)\n\tInvoker invoker = cluster.join(directory);\n\t\n\t//注册消费者\n\tProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);\n\treturn invoker;\n}\n```\n这里首先注册了消费者，然后订阅了相关目录(providers、configurations、routers)，当有相应服务提供者提供服务时，注册中心会通过notify通知到消费者，接着消费者会通过RegistryDirectory类异步更新本地缓存。\n注册消费者时，首先会调用AbstractRegistry类的register方法，将注册url保存起来，然后会调用FailbackRegistry类的register方法，在该方法中会调用doRegister方法(该方法调用失败的话，会稍后进行重试),最后会调用ZookeeperRegistry的doRegister方法，进行最终的注册。\n```java\n//ZookeeperRegistry类的doRegister方法\n@Override\nprotected void doRegister(URL url) {\n\ttry {\n\t    //执行注册 dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=5312&side=provider&timestamp=1534994264738\n\t    //根据url确定节点路径；根据url的dynamic参数确定是否是临时节点 /dubbo/com.alibaba.dubbo.demo.DemoService/providers/dubbo%3A%2F%2F192.168.99.60%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26dubbo%3D2.0.0%26generic%3Dfalse%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D5312%26side%3Dprovider%26timestamp%3D1534994264738\n\t    zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true));\n\t} catch (Throwable e) {\n\t    throw new RpcException(\"Failed to register \" + url + \" to zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e);\n\t}\n}\n```\n订阅时，会调用RegistryDirectory类的subscribe方法\n```java\npublic class RegistryDirectory<T> extends AbstractDirectory<T> implements NotifyListener {\n\n       /**\n\t* 订阅url\n\t* @param url 消费者url \n\t* consumer://192.168.99.60/com.alibaba.dubbo.demo.DemoService?application=demo-consumer&category=providers,configurators,routers&check=false&dubbo=2.0.0&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=1880&qos.port=33333&side=consumer&timestamp=1535449640995\n\t*/\n\tpublic void subscribe(URL url) {\n\t\t//设置消费者url(将url保存到AbstractDirectory父类中)\n\t\tsetConsumerUrl(url);\n\t\t\n\t\t//订阅该消费者url(this即为当前RegistryDirectory对象,它实现了NotifyListener接口)\n\t\t//首先调用AbstractRegistry的subscribe方法(保存订阅信息)\n\t\t//接着调用FailbackRegistry的subscribe方法(调用ZookeeperRegistry的doSubscribe方法，如果发生异常了会捕获到，然后保存下来稍后重试)\n\t\t//然后调用ZookeeperRegistry的doSubscribe方法(获取待通知urls，最后调用notify方法进行通知)\n\t\tregistry.subscribe(url, this);\n\t}\n}\n```\n我们简单看下ZookeeperRegistry类的doSubscribe方法，其中省略掉了一些代码\n```java\n//此listener参数就是上文创建的RegistryDirectory类\nprotected void doSubscribe(final URL url, final NotifyListener listener) {\n\tList<URL> urls = new ArrayList<URL>();\n\t//根据toCategoriesPath(url)方法获取到类别列表，然后遍历该列表\n\t//如：/dubbo/com.alibaba.dubbo.demo.DemoService/providers\n\tfor (String path : toCategoriesPath(url)) {\n\t    ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);\n\t    if (listeners == null) {\n\t\tzkListeners.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, ChildListener>());\n\t\tlisteners = zkListeners.get(url);\n\t    }\n\t    //根据dubbo的监听获取zk的监听\n\t    ChildListener zkListener = listeners.get(listener);\n\t    if (zkListener == null) {\n\t        //创建节点监听\n\t\tlisteners.putIfAbsent(listener, new ChildListener() {\n\t\t    @Override\n\t\t    public void childChanged(String parentPath, List<String> currentChilds) {\n\t\t\t//执行通知\n\t\t\tZookeeperRegistry.this.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds));\n\t\t    }\n\t\t});\n\t\tzkListener = listeners.get(listener);\n\t    }\n\t    //创建path节点,\n\t    //即：/dubbo/com.xxx.demoService/providers\n\t    //即：/dubbo/consumers  /dubbo/com.alibaba.dubbo.demo.DemoService/configurators\n\t    zkClient.create(path, false);\n\t    //为path节点添加zkListener监听(children变量即为该path节点的子节点数据)\n\t    List<String> children = zkClient.addChildListener(path, zkListener);\n\t    if (children != null) {\n\t        //节点数据(待通知列表)\n\t\t//empty://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&category=configurators&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=6504&side=provider&timestamp=1534927826842\n\t\turls.addAll(toUrlsWithEmpty(url, path, children));\n\t    }\n\t}\n\t//执行通知(urls即为待通知的消息列表)\n\tnotify(url, listener, urls);\n}\n```\n调用notify方法进行通知时,会先调用FailbackRegistry类的notify方法,内部会调用doNotify方法(调用失败的话,会保存失败信息,稍后重试)\n```java\n//FailbackRegistry类的notify\n//省略了一些不重要的代码\n@Override\nprotected void notify(URL url, NotifyListener listener, List<URL> urls) {\n\ttry {\n\t    //执行通知(将会调用父类AbstractRegistry中的notify方法)\n\t    doNotify(url, listener, urls);\n\t} catch (Exception t) {\n\t    //通知失败，添加到失败列表，定期重试\n\t    Map<NotifyListener, List<URL>> listeners = failedNotified.get(url);\n\t    if (listeners == null) {\n\t\tfailedNotified.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, List<URL>>());\n\t\tlisteners = failedNotified.get(url);\n\t    }\n\t    listeners.put(listener, urls);\n\t    logger.error(\"Failed to notify for subscribe \" + url + \", waiting for retry, cause: \" + t.getMessage(), t);\n\t}\n}\n```\n而doNotify方法最终会调用AbstractRegistry类的notify方法,在AbstractRegistry类的notify方法中,会根据category将待通知urls进行分组,然后挨个处理每一个category,并按照<订阅url服务唯一标识,空格分隔的多个待通知url>的形式，保存到本地properties文件中，最后调用RegistryDirectory类的notify方法将待通知列表categoryList下发给消费者。\n```java\n//AbstractRegistry类的notify方法\n//省略了一些不重要的代码\nprotected void notify(URL url, NotifyListener listener, List<URL> urls) {\n\t//<category,List<URL>>\n\tMap<String, List<URL>> result = new HashMap<String, List<URL>>();\n\t//遍历待通知urls，根据url中的category参数进行分组，保存到result中\n\tfor (URL u : urls) {\n\t    //url和u是否匹配(url的范围是否比u大)\n\t    if (UrlUtils.isMatch(url, u)) {\n\t\t//获取待通知url的category，默认值是providers\n\t\tString category = u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);\n\t\tList<URL> categoryList = result.get(category);\n\t\tif (categoryList == null) {\n\t\t    categoryList = new ArrayList<URL>();\n\t\t    result.put(category, categoryList);\n\t\t}\n\t\tcategoryList.add(u);\n\t    }\n\t}\n\tif (result.size() == 0) {\n\t    //类别待通知url列表为空，直接返回\n\t    return;\n\t}\n\t//下面会将notified中的url及其values.values中的URL保存到缓存文件中\n\tMap<String, List<URL>> categoryNotified = notified.get(url);\n\tif (categoryNotified == null) {\n\t    notified.putIfAbsent(url, new ConcurrentHashMap<String, List<URL>>());\n\t    categoryNotified = notified.get(url);\n\t}\n\tfor (Map.Entry<String, List<URL>> entry : result.entrySet()) {\n\t    //类别\n\t    String category = entry.getKey();\n\t    //类别待通知url列表\n\t    List<URL> categoryList = entry.getValue();\n\t    //保存<类别,类别待通知url列表>\n\t    categoryNotified.put(category, categoryList);\n\t    //保存注册中心缓存文件(将订阅url、待通知url列表保存到缓存文件)\n\t    saveProperties(url);\n\t    //触发通知给消费者(类别待通知url列表)，此listener就是RegistryDirectory类\n\t    listener.notify(categoryList);\n\t}\n}\n```\n然后我们来看RegistryDirectory类的notify方法\n```java\npublic synchronized void notify(List<URL> urls) {\n\tList<URL> invokerUrls = new ArrayList<URL>();\n\tList<URL> routerUrls = new ArrayList<URL>();\n\tList<URL> configuratorUrls = new ArrayList<URL>();\n\t//遍历待通知列表，根据category进行分组，并分别保存到上面定义的list列表中\n\tfor (URL url : urls) {\n\t    //获取url协议\n\t    String protocol = url.getProtocol();\n\t    //获取url分类\n\t    String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);\n\t    if (Constants.ROUTERS_CATEGORY.equals(category)\n\t\t    || Constants.ROUTE_PROTOCOL.equals(protocol)) {\n\t\t//添加路由url\n\t\trouterUrls.add(url);\n\t    } else if (Constants.CONFIGURATORS_CATEGORY.equals(category)\n\t\t    || Constants.OVERRIDE_PROTOCOL.equals(protocol)) {\n\t\t//添加配置url\n\t\tconfiguratorUrls.add(url);\n\t    } else if (Constants.PROVIDERS_CATEGORY.equals(category)) {\n\t\t//添加服务提供者url\n\t\tinvokerUrls.add(url);\n\t    } else {\n\t\t//不支持的分类\n\t\tlogger.warn(\"Unsupported category \" + category + \" in notified url: \" + url + \" from registry \" + getUrl().getAddress() + \" to consumer \" + NetUtils.getLocalHost());\n\t    }\n\t}\n\tif (configuratorUrls != null && !configuratorUrls.isEmpty()) {\n\t    //将url转换成Configurator类并保存(后面会分析该方法)\n\t    this.configurators = toConfigurators(configuratorUrls);\n\t}\n\tif (routerUrls != null && !routerUrls.isEmpty()) {\n\t    //将路由url转换成路由对象(后面会分析该方法)\n\t    List<Router> routers = toRouters(routerUrls);\n\t    if (routers != null) {\n\t\t//保存路由(后面会分析该方法)\n\t\tsetRouters(routers);\n\t    }\n\t}\n\tList<Configurator> localConfigurators = this.configurators;\n\t//合并override参数\n\tthis.overrideDirectoryUrl = directoryUrl;\n\tif (localConfigurators != null && !localConfigurators.isEmpty()) {\n\t    for (Configurator configurator : localConfigurators) {\n\t\t//根据configurator覆盖overrideDirectoryUrl中的属性，\n\t\t//或者将configurator中的属性添加到overrideDirectoryUrl中\n\t\tthis.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl);\n\t    }\n\t}\n\t//刷新Invoker(后面会分析该方法)\n\trefreshInvoker(invokerUrls);\n}\n\n```\n接下来，我们来挨个看下上面用到的方法\n\n#### 更新Configurator\n```java\n//将待通知url转换成Configurator\npublic static List<Configurator> toConfigurators(List<URL> urls) {\n\tif (urls == null || urls.isEmpty()) {\n\t    return Collections.emptyList();\n\t}\n\tList<Configurator> configurators = new ArrayList<Configurator>(urls.size());\n\t//遍历待通知url列表\n\tfor (URL url : urls) {\n\t    if (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) {\n\t\t//协议为empty，则清空configurators，并跳出循环\n\t\tconfigurators.clear();\n\t\tbreak;\n\t    }\n\t    //获取url所有参数\n\t    Map<String, String> override = new HashMap<String, String>(url.getParameters());\n\t    \n\t    //override的anyhost参数可以被自动添加\n\t    //它不可以改变对变化中的url的判断，因此需要移除掉anyhost参数\n\t    override.remove(Constants.ANYHOST_KEY);\n\t    if (override.size() == 0) {\n\t\tconfigurators.clear();\n\t\tcontinue;\n\t    }\n\t    //添加配置\n\t    configurators.add(configuratorFactory.getConfigurator(url));\n\t}\n\t//排序\n\tCollections.sort(configurators);\n\treturn configurators;\n}\n```\n\n#### 更新Router\n```java\n//将待通知url转换成Router对象\nprivate List<Router> toRouters(List<URL> urls) {\n\tList<Router> routers = new ArrayList<Router>();\n\tif (urls == null || urls.isEmpty()) {\n\t    return routers;\n\t}\n\tif (urls != null && !urls.isEmpty()) {\n\t    //遍历待通知url列表\n\t    for (URL url : urls) {\n\t\tif (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) {\n\t\t    //协议为empty的话，直接返回\n\t\t    continue;\n\t\t}\n\t\t//获取url的router参数，该参数标识了路由协议\n\t\tString routerType = url.getParameter(Constants.ROUTER_KEY);\n\t\tif (routerType != null && routerType.length() > 0) {\n\t\t    //设置路由协议\n\t\t    url = url.setProtocol(routerType);\n\t\t}\n\t\ttry {\n\t\t    //根据url获取路由实例\n\t\t    Router router = routerFactory.getRouter(url);\n\t\t    if (!routers.contains(router)) {\n\t\t\t//添加路由\n\t\t\trouters.add(router);\n\t\t    }\n\t\t} catch (Throwable t) {\n\t\t    logger.error(\"convert router url to router error, url: \" + url, t);\n\t\t}\n\t    }\n\t}\n\treturn routers;\n}\n\nprotected void setRouters(List<Router> routers) {\n\t//复制routers列表\n\trouters = routers == null ? new ArrayList<Router>() : new ArrayList<Router>(routers);\n\t\n\t//获取路由工厂的扩展名称\n\tString routerkey = url.getParameter(Constants.ROUTER_KEY);\n\tif (routerkey != null && routerkey.length() > 0) {\n\t    //根据 路由工厂扩展名 获取 路由工厂扩展实例\n\t    RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getExtension(routerkey);\n\t    //根据url获取路由实例，并放入routers\n\t    routers.add(routerFactory.getRouter(url));\n\t}\n\t//添加支持mock协议的invoker选择器\n\trouters.add(new MockInvokersSelector());\n\t//排序\n\tCollections.sort(routers);\n\t//保存最新的路由信息\n\tthis.routers = routers;\n}\n```\n#### 更新Invoker\n然后我们来看refreshInvoker方法\n```java\n/**\n * 将待通知invoker url转换成invoker Map，转换规则如下：\n * 1、如果url已经转换成invoker，则不再重新引用并直接从缓存中获取，并注意url中的任何参数更改都将被重新引用。\n * 2、如果传入的invoker列表不为空，则意味着这是最新的调用者列表\n * 3、如果传入的invoker列表为空，则意味着该规则只是一个override规则或者route规则，需要重新对比以决定是否需要重新引用\n */\nprivate void refreshInvoker(List<URL> invokerUrls) {\n\tif (invokerUrls != null && invokerUrls.size() == 1 && invokerUrls.get(0) != null\n\t\t&& Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) {\n\t    //empty协议\n\t    //禁止访问\n\t    this.forbidden = true;\n\t    this.methodInvokerMap = null;\n\t    //销毁所有的invokers\n\t    destroyAllInvokers();\n\t} else {\n\t    //允许访问\n\t    this.forbidden = false;\n\t    //记录当前的 urlInvokerMap\n\t    Map<String, Invoker<T>> oldUrlInvokerMap = this.urlInvokerMap;\n\t    if (invokerUrls.isEmpty() && this.cachedInvokerUrls != null) {\n\t\t//收到的invokerUrls为空，但是缓存中的不为空，则使用当前缓存中的invoker\n\t\tinvokerUrls.addAll(this.cachedInvokerUrls);\n\t    } else {\n\t\tthis.cachedInvokerUrls = new HashSet<URL>();\n\t\t//缓存invokerUrls列表，方便比较\n\t\tthis.cachedInvokerUrls.addAll(invokerUrls);\n\t    }\n\t    if (invokerUrls.isEmpty()) {\n\t\t//invoker url列表为空，直接返回\n\t\treturn;\n\t    }\n\t    //将invoker-url转换成invoker-map(后面会分析该方法)\n\t    Map<String, Invoker<T>> newUrlInvokerMap = toInvokers(invokerUrls);\n\t    \n\t    //建立 方法名与invoker的映射(后面会分析该方法)\n\t    Map<String, List<Invoker<T>>> newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap);\n\t   \n\t    //状态改变\n\t    if (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) {\n\t\t//转换发生错误\n\t\tlogger.error(new IllegalStateException(\"urls to invokers error .invokerUrls.size :\" + invokerUrls.size() + \", invoker.size :0. urls :\" + invokerUrls.toString()));\n\t\treturn;\n\t    }\n\t    //保存最新的 methodInvokerMap(后面会分析该方法)\n\t    this.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;\n\t    //保存最新的 urlInvokerMap\n\t    this.urlInvokerMap = newUrlInvokerMap;\n\t    try {\n\t\t//关闭未使用的invoker(后面会分析该方法)\n\t\tdestroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap);\n\t    } catch (Exception e) {\n\t\tlogger.warn(\"destroyUnusedInvokers error. \", e);\n\t    }\n\t}\n}\n```\n\n##### toInvokers方法\n```java\n/**\n * 将invoker-url转换成invoker，如果url已经被引用，将不会重新引用\n * @param urls 服务提供者url\n * dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=6640&side=provider&timestamp=1535449604077\n * @return invokers\n */\nprivate Map<String, Invoker<T>> toInvokers(List<URL> urls) {\n\tMap<String, Invoker<T>> newUrlInvokerMap = new HashMap<String, Invoker<T>>();\n\tif (urls == null || urls.isEmpty()) {\n\t    return newUrlInvokerMap;\n\t}\n\tSet<String> keys = new HashSet<String>();\n\t//获取当前url支持的协议\n\tString queryProtocols = this.queryMap.get(Constants.PROTOCOL_KEY);\n\t//遍历urls，检测每一个providerUrl是否满足当前调用者url的协议要求(queryProtocols)\n\tfor (URL providerUrl : urls) {\n\t    //如果在reference端配置了协议protocol，则只选择匹配的协议\n\t    if (queryProtocols != null && queryProtocols.length() > 0) {\n\t\tboolean accept = false;\n\t\t//可接受的协议数组\n\t\tString[] acceptProtocols = queryProtocols.split(\",\");\n\t\tfor (String acceptProtocol : acceptProtocols) {\n\t\t    if (providerUrl.getProtocol().equals(acceptProtocol)) {\n\t\t\t//如果该提供者url的协议在可接受的协议范围内，则跳出循环\n\t\t\taccept = true;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (!accept) {\n\t\t    //没找到，则判断下一个服务提供者\n\t\t    continue;\n\t\t}\n\t    }\n\t    if (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) {\n\t        //服务提供者协议为empty，则进行下次循环\n\t\tcontinue;\n\t    }\n\t    if (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) {\n\t\t//不支持的协议\n\t\tlogger.error(new IllegalStateException(\"Unsupported protocol \" + providerUrl.getProtocol() + \" in notified url: \" + providerUrl + \" from registry \" + getUrl().getAddress() + \" to consumer \" + NetUtils.getLocalHost()\n\t\t\t+ \", supported protocol: \" + ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));\n\t\tcontinue;\n\t    }\n\t    //合并url参数(后面会分析该方法)\n\t    URL url = mergeUrl(providerUrl);\n\t    \n\t    //url的参数已经排过序\n\t    //dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-consumer&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=1880&qos.port=33333&register.ip=192.168.99.60&remote.timestamp=1535449604077&side=consumer&timestamp=1535449640995\n\t    String key = url.toFullString();\n\t    if (keys.contains(key)) {\n\t\t//重复的url\n\t\tcontinue;\n\t    }\n\t    keys.add(key);\n\t    //缓存key是url，不与消费者端的参数合并，无论消费者如何组合参数，\n            //如果服务器url发生改变，则重新进行引用\n\t    Map<String, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap;\n\t    //根据缓存key获取invoker\n\t    Invoker<T> invoker = localUrlInvokerMap == null ? null : localUrlInvokerMap.get(key);\n\t    if (invoker == null) {\n\t\t//不在缓存中，重新引用\n\t\ttry {\n\t\t    boolean enabled = true;\n\t\t    //获取disabled参数、enabled参数，来判断是否可用\n\t\t    if (url.hasParameter(Constants.DISABLED_KEY)) {\n\t\t\tenabled = !url.getParameter(Constants.DISABLED_KEY, false);\n\t\t    } else {\n\t\t\tenabled = url.getParameter(Constants.ENABLED_KEY, true);\n\t\t    }\n\t\t    if (enabled) {\n\t\t\t//可以引用，重新引用(后面会介绍)\n\t\t\tinvoker = new InvokerDelegate<T>(\n\t\t\t        //根据服务接口、远程服务url重新引用\n\t\t\t\tprotocol.refer(serviceType, url),\n\t\t\t\turl,\n\t\t\t\tproviderUrl\n\t\t\t);\n\t\t    }\n\t\t} catch (Throwable t) {\n\t\t    logger.error(\"Failed to refer invoker for interface:\" + serviceType + \",url:(\" + url + \")\" + t.getMessage(), t);\n\t\t}\n\t\tif (invoker != null) {\n\t\t    //保存新的invoker到缓存\n\t\t    newUrlInvokerMap.put(key, invoker);\n\t\t}\n\t    } else {\n\t\tnewUrlInvokerMap.put(key, invoker);\n\t    }\n\t}\n\tkeys.clear();\n\treturn newUrlInvokerMap;\n}\n\n```\n##### toMethodInvokers方法\n\n```java\n/**\n * 获取Invoker和method之间的映射关系\n * @param invokersMap Invoker Map\n * @return Mapping relation between Invoker and method\n */\nprivate Map<String, List<Invoker<T>>> toMethodInvokers(Map<String, Invoker<T>> invokersMap) {\n\t//method与invoker列表的映射\n\tMap<String, List<Invoker<T>>> newMethodInvokerMap = new HashMap<String, List<Invoker<T>>>();\n\t\n\t// According to the methods classification declared by the provider URL,\n\t// the methods is compatible with the registry to execute the filtered methods\n\tList<Invoker<T>> invokersList = new ArrayList<Invoker<T>>();\n\t\n\tif (invokersMap != null && invokersMap.size() > 0) {\n\t    //遍历invokers\n\t    for (Invoker<T> invoker : invokersMap.values()) {\n\t\t//获取服务提供者方法列表\n\t\tString parameter = invoker.getUrl().getParameter(Constants.METHODS_KEY);\n\t\tif (parameter != null && parameter.length() > 0) {\n\t\t    //逗号分隔方法\n\t\t    String[] methods = Constants.COMMA_SPLIT_PATTERN.split(parameter);\n\t\t    if (methods != null && methods.length > 0) {\n\t\t\tfor (String method : methods) {\n\t\t\t    if (method != null && method.length() > 0 && !Constants.ANY_VALUE.equals(method)) {\n\t\t\t\t//通过method获取invoker列表\n\t\t\t\tList<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);\n\t\t\t\tif (methodInvokers == null) {\n\t\t\t\t    methodInvokers = new ArrayList<Invoker<T>>();\n\t\t\t\t    //添加方法、invoker映射\n\t\t\t\t    newMethodInvokerMap.put(method, methodInvokers);\n\t\t\t\t}\n\t\t\t\tmethodInvokers.add(invoker);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\t//添加invoker\n\t\tinvokersList.add(invoker);\n\t    }\n\t}\n\t//根据路由筛选InvokersList(后面会分析该方法)\n\tList<Invoker<T>> newInvokersList = route(invokersList, null);\n\t\n\t//保存<*,newInvokersList>\n\tnewMethodInvokerMap.put(Constants.ANY_VALUE, newInvokersList);\n\t\n\tif (serviceMethods != null && serviceMethods.length > 0) {\n\t    //遍历服务method列表,并从newMethodInvokerMap中获取该method对应的Invoker列表\n\t    //如果没有获取到，则将该method映射到newInvokersList列表上\n\t    for (String method : serviceMethods) {\n\t\tList<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);\n\t\tif (methodInvokers == null || methodInvokers.isEmpty()) {\n\t\t    methodInvokers = newInvokersList;\n\t\t}\n\t\t//根据路由筛选invoker列表，然后保存method、invokerList映射\n\t\tnewMethodInvokerMap.put(method, route(methodInvokers, method));\n\t    }\n\t}\n\tfor (String method : new HashSet<String>(newMethodInvokerMap.keySet())) {\n\t    List<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);\n\t    //排序invoker\n\t    Collections.sort(methodInvokers, InvokerComparator.getComparator());\n\t    //不可变集合\n\t    newMethodInvokerMap.put(method, Collections.unmodifiableList(methodInvokers));\n\t}\n\treturn Collections.unmodifiableMap(newMethodInvokerMap);\n}\n```\n###### route方法\n```java\n/**\n * 根据路由筛选InvokersList\n * Router 负责从多个 Invoker 中按路由规则选出子集，比如读写分离，应用隔离等\n * @param invokers\n * @param method\n * @return\n */\nprivate List<Invoker<T>> route(List<Invoker<T>> invokers, String method) {\n\t//创建Invocation对象\n\tInvocation invocation = new RpcInvocation(method, new Class<?>[0], new Object[0]);\n\t//获取路由列表\n\tList<Router> routers = getRouters();\n\tif (routers != null) {\n\t    for (Router router : routers) {\n\t\tif (router.getUrl() != null) {\n\t\t    //执行路由\n\t\t    invokers = router.route(invokers, getConsumerUrl(), invocation);\n\t\t}\n\t    }\n\t}\n\treturn invokers;\n}\n```\n\n##### toMergeMethodInvokerMap方法\n```java\nprivate Map<String, List<Invoker<T>>> toMergeMethodInvokerMap(Map<String, List<Invoker<T>>> methodMap) {\n\tMap<String, List<Invoker<T>>> result = new HashMap<String, List<Invoker<T>>>();\n\tfor (Map.Entry<String, List<Invoker<T>>> entry : methodMap.entrySet()) {\n\t    //当前方法名\n\t    String method = entry.getKey();\n\t    //当前invokers\n\t    List<Invoker<T>> invokers = entry.getValue();\n\t    //将invokers按照group进行分组，放入到groupMap中(<group,List<invokers>>)\n\t    Map<String, List<Invoker<T>>> groupMap = new HashMap<String, List<Invoker<T>>>();\n\t    for (Invoker<T> invoker : invokers) {\n\t\t//当前url的group\n\t\tString group = invoker.getUrl().getParameter(Constants.GROUP_KEY, \"\");\n\t\tList<Invoker<T>> groupInvokers = groupMap.get(group);\n\t\tif (groupInvokers == null) {\n\t\t    groupInvokers = new ArrayList<Invoker<T>>();\n\t\t    groupMap.put(group, groupInvokers);\n\t\t}\n\t\tgroupInvokers.add(invoker);\n\t    }\n\t    if (groupMap.size() == 1) {\n\t\t//只有一个group\n\t\tresult.put(method, groupMap.values().iterator().next());\n\t    } else if (groupMap.size() > 1) {\n\t\t//多个group的情况\n\t\tList<Invoker<T>> groupInvokers = new ArrayList<Invoker<T>>();\n\t\tfor (List<Invoker<T>> groupList : groupMap.values()) {\n\t\t    //针对每一个groupList创建一个StaticDirectory，然后生成一个invoker并放入groupInvokers中\n\t\t    groupInvokers.add(cluster.join(new StaticDirectory<T>(groupList)));\n\t\t}\n\t\tresult.put(method, groupInvokers);\n\t    } else {\n\t\t//没有group\n\t\tresult.put(method, invokers);\n\t    }\n\t}\n\treturn result;\n}\n```\n![](img/toMergeMethodInvokerMap.png)\n\n##### 销毁无用的invoker\n```java\n/**\n * 检测缓存中的invoker是否需要被销毁\n * 如果设置url属性：refer.autodestroy=false\n * invokers将会在不减少的情况下增加，可能会有一个引用泄露\n * @param oldUrlInvokerMap\n * @param newUrlInvokerMap\n */\nprivate void destroyUnusedInvokers(Map<String, Invoker<T>> oldUrlInvokerMap,Map<String, Invoker<T>> newUrlInvokerMap) {\n\tif (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) {\n\t    //关闭所有的invoker\n\t    destroyAllInvokers();\n\t    return;\n\t}\n\tList<String> deleted = null;\n\tif (oldUrlInvokerMap != null) {\n\t    Collection<Invoker<T>> newInvokers = newUrlInvokerMap.values();\n\t    for (Map.Entry<String, Invoker<T>> entry : oldUrlInvokerMap.entrySet()) {\n\t\tif (!newInvokers.contains(entry.getValue())) {\n\t\t    //老的invoker在新的invoker列表中不存在\n\t\t    if (deleted == null) {\n\t\t\tdeleted = new ArrayList<String>();\n\t\t    }\n\t\t    //标记该老的url，后面会进行删除\n\t\t    deleted.add(entry.getKey());\n\t\t}\n\t    }\n\t}\n\tif (deleted != null) {\n\t    for (String url : deleted) {\n\t\tif (url != null) {\n\t\t    //从老的invoker-map中移除该url，并关闭该老的invoker\n\t\t    Invoker<T> invoker = oldUrlInvokerMap.remove(url);\n\t\t    if (invoker != null) {\n\t\t\ttry {\n\t\t\t    //销毁该invoker\n\t\t\t    invoker.destroy();\n\t\t\t} catch (Exception e) {\n\t\t\t    logger.warn(\"destory invoker[\" + invoker.getUrl() + \"] faild. \" + e.getMessage(), e);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n}\n```\n#### 重新引用invoker\n\n接下来，我们来看看上面的toInvokers方法中，重新引用invoker的逻辑，即\n```java\nif (enabled) {\n\t//可以引用，重新引用\n\tinvoker = new InvokerDelegate<T>(\n\t\tprotocol.refer(serviceType, url),\n\t\turl,\n\t\tproviderUrl\n\t);\n}\n```\n这里会先调用ProtocolListenerWrapper类的refer方法,然后在该方法内会在调用ProtocolFilterWrapper类的refer方法\n```java\npublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n\tif (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n\t    return protocol.refer(type, url);\n\t}\n\treturn new ListenerInvokerWrapper<T>(\n\t        //调用ProtocolFilterWrapper类的refer方法获取到invoker\n\t\tprotocol.refer(type, url),\n\t\tCollections.unmodifiableList(\n\t\t      ExtensionLoader.getExtensionLoader(InvokerListener.class)\n\t\t\t\t     .getActivateExtension(url, Constants.INVOKER_LISTENER_KEY)\n\t));\n}\n```\n我们看下ProtocolFilterWrapper类的refer方法，在该方法内部会去调用DubboProtocol类的refer方法\n```java\n@Override\npublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n\tif (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n\t\treturn protocol.refer(type, url);\n\t}\n\t//构建invoker链\n\treturn buildInvokerChain(\n\t\t//调用DubboProtocol类的refer方法\n\t\tprotocol.refer(type, url), \n\t\t//reference.filter\n\t\tConstants.REFERENCE_FILTER_KEY, \n\t\t//consumer\n\t\tConstants.CONSUMER\n\t);\n}\n\n/**\n * 构建Invoker链\n * @param invoker\n * @param key  \n * @param group \n */\nprivate static <T> Invoker<T> buildInvokerChain(final Invoker<T> invoker,String key, String group) {\n\tInvoker<T> last = invoker;\n\t//获取过滤器：ConsumerContextFilter、FutureFilter、MonitorFilter\n\tList<Filter> filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);\n\tif (!filters.isEmpty()) {\n\t    for (int i = filters.size() - 1; i >= 0; i--) {\n\t\t//MonitorFilter、FutureFilter、ConsumerContextFilter\n\t\tfinal Filter filter = filters.get(i);\n\t\tfinal Invoker<T> next = last;\n\t\tlast = new Invoker<T>() {\n\t\t    @Override\n\t\t    public Class<T> getInterface() {\n\t\t\treturn invoker.getInterface();\n\t\t    }\n\t\t    @Override\n\t\t    public URL getUrl() {\n\t\t\treturn invoker.getUrl();\n\t\t    }\n\t\t    @Override\n\t\t    public boolean isAvailable() {\n\t\t\treturn invoker.isAvailable();\n\t\t    }\n\t\t    @Override\n\t\t    public Result invoke(Invocation invocation) throws RpcException {\n\t\t        //调用filter的invoke方法\n\t\t\treturn filter.invoke(next, invocation);\n\t\t    }\n\t\t    @Override\n\t\t    public void destroy() {\n\t\t\tinvoker.destroy();\n\t\t    }\n\t\t    @Override\n\t\t    public String toString() {\n\t\t\treturn invoker.toString();\n\t\t    }\n\t\t};\n\t    }\n\t}\n\treturn last;\n}\n```\nDubboProtocol类的refer方法\n```java\n/**\n * @param serviceType com.alibaba.dubbo.demo.DemoService\n * @param url \n * dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-consumer&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=5624&qos.port=33333&register.ip=192.168.99.60&remote.timestamp=1535531661191&side=consumer&timestamp=1535531690333\n */\n@Override\npublic <T> Invoker<T> refer(Class<T> serviceType, URL url) throws RpcException {\n\t//加载优化序列化类\n\toptimizeSerialization(url);\n\t\n\t//创建DubboInvoker\n\tDubboInvoker<T> invoker = new DubboInvoker<T>(\n\t\tserviceType,\n\t\turl,\n\t\t//创建客户端(后面小节会分析该方法)\n\t\tgetClients(url),\n\t\t//当前对象已创建的invoker集合\n\t\tinvokers\n\t);\n\t//将invoker保存到invokers集合中\n\tinvokers.add(invoker);\n\treturn invoker;\n}\n```\n该invoker中持有一个client对象，默认是NettyClient，后面小节会介绍该过程，最终生成的Invoker如下图，：\n![](img/InvokerChain.png)\n\n#### registerConsumer注册消费者\n\n最后调用ProviderConsumerRegTable类的registerConsumer方法注册消费者\n```java\npublic static ConcurrentHashMap<String, Set<ConsumerInvokerWrapper>> consumerInvokers = new ConcurrentHashMap<String, Set<ConsumerInvokerWrapper>>();\n\n/**\n * 注册消费者\n * @param invoker\n * @param registryUrl 注册中心url\n * @param consumerUrl 消费者url\n * @param registryDirectory\n */\npublic static void registerConsumer(Invoker invoker, URL registryUrl, URL consumerUrl, RegistryDirectory registryDirectory) {\n\t//创建ConsumerInvokerWrapper\n\tConsumerInvokerWrapper wrapperInvoker = new ConsumerInvokerWrapper(invoker, registryUrl, consumerUrl, registryDirectory);\n\t//服务唯一标识\n\tString serviceUniqueName = consumerUrl.getServiceKey();\n\t//根据服务唯一标识获取invokers\n\tSet<ConsumerInvokerWrapper> invokers = consumerInvokers.get(serviceUniqueName);\n\tif (invokers == null) {\n\t    consumerInvokers.putIfAbsent(serviceUniqueName, new ConcurrentHashSet<ConsumerInvokerWrapper>());\n\t    invokers = consumerInvokers.get(serviceUniqueName);\n\t}\n\t//添加wrapperInvoker到缓存\n\tinvokers.add(wrapperInvoker);\n}\n```\n\n到此为止，整个流程就介绍完毕了。下面小节将会介绍一下注册中心Registry。\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之注册中心-Zookeeper注册中心","url":"/blog/2018/08/23/Dubbo源码阅读之注册中心-Zookeeper注册中心/","content":">本小节讲解Zookeeper注册中心的实现\n\n\n### ZookeeperRegistry注册中心\n先来看下后面会用到的接口：\n```java\n/**\n * 节点监听\n */\npublic interface ChildListener {\n    /**\n     * 节点发生改变\n     * @param path\n     * @param children\n     */\n    void childChanged(String path, List<String> children);\n}\n/**\n * 连接状态监听器\n */\npublic interface StateListener {\n    //断开连接\n    int DISCONNECTED = 0;\n    //已连接\n    int CONNECTED = 1;\n    //重新连接\n    int RECONNECTED = 2;\n\n    /**\n     * 连接状态改变\n     * @param connected 状态值\n     */\n    void stateChanged(int connected);\n}\n```\n然后我们来看ZookeeperRegistry的实现,该类继承自FailbackRegistry,因此具备了发生异常时自动重试的能力\n```java\npublic class ZookeeperRegistry extends FailbackRegistry {\n\n    private final static Logger logger = LoggerFactory.getLogger(ZookeeperRegistry.class);\n\n    /**\n     * 默认的zk端口\n     */\n    private final static int DEFAULT_ZOOKEEPER_PORT = 2181;\n\n    /**\n     * 默认的zk根节点\n     */\n    private final static String DEFAULT_ROOT = \"dubbo\";\n\n    /**\n     * zk根节点，如：/dubbo\n     */\n    private final String root;\n\n    private final Set<String> anyServices = new ConcurrentHashSet<String>();\n\n    /**\n     * URL：订阅url,<节点监听事件>\n     */\n    private final ConcurrentMap<URL, ConcurrentMap<NotifyListener, ChildListener>>\n            zkListeners = new ConcurrentHashMap<URL, ConcurrentMap<NotifyListener, ChildListener>>();\n\n    /**\n     * zk客户端接口(支持多种客户端实现)\n     */\n    private final ZookeeperClient zkClient;\n\n    public ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) {\n        //设置注册中心url\n        super(url);\n        if (url.isAnyHost()) {\n            //host = 0.0.0.0 || anyhost = true\n            throw new IllegalStateException(\"registry address == null\");\n        }\n        //获取url参数group,标识zk根节点名称,默认为dubbo\n        String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);\n        if (!group.startsWith(Constants.PATH_SEPARATOR)) {\n            //添加前缀，如：/dubbo\n            group = Constants.PATH_SEPARATOR + group;\n        }\n        this.root = group;\n\n        //调用zookeeperTransporter接口的connect方法连接到zk客户端(后面会分析该方法)\n        zkClient = zookeeperTransporter.connect(url);\n\n        //添加节点变更事件到AbstractZookeeperClient父类中的缓存集合变量中\n        zkClient.addStateListener(new StateListener() {\n            @Override\n            public void stateChanged(int state) {\n                if (state == RECONNECTED) {\n                    try {\n                        //重连事件，进行恢复\n                        recover();\n                    } catch (Exception e) {\n                        logger.error(e.getMessage(), e);\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * 给zk地址附加默认端口号\n     * @param address\n     * @return\n     */\n    static String appendDefaultPort(String address) {\n        if (address != null && address.length() > 0) {\n            int i = address.indexOf(':');\n            if (i < 0) {\n                //添加zk默认端口2181，即：address:2181\n                return address + \":\" + DEFAULT_ZOOKEEPER_PORT;\n            } else if (Integer.parseInt(address.substring(i + 1)) == 0) {\n                //端口为0的话，则使用默认端口\n                return address.substring(0, i + 1) + DEFAULT_ZOOKEEPER_PORT;\n            }\n        }\n        return address;\n    }\n\n    @Override\n    public boolean isAvailable() {\n        //连接是否可用\n        return zkClient.isConnected();\n    }\n\n    @Override\n    public void destroy() {\n        super.destroy();\n        try {\n            //销毁客户端\n            zkClient.close();\n        } catch (Exception e) {\n            logger.warn(\"Failed to close zookeeper client \" + getUrl() + \", cause: \" + e.getMessage(), e);\n        }\n    }\n\n    @Override\n    protected void doRegister(URL url) {\n        try {\n            //执行注册 dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=5312&side=provider&timestamp=1534994264738\n            //根据url确定节点路径；根据url的dynamic参数确定是否是临时节点\n\t    //如：/dubbo/com.alibaba.dubbo.demo.DemoService/providers/dubbo%3A%2F%2F192.168.99.60%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26dubbo%3D2.0.0%26generic%3Dfalse%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D5312%26side%3Dprovider%26timestamp%3D1534994264738\n            //在zk上创建节点\n\t    zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true));\n        } catch (Throwable e) {\n            throw new RpcException(\"Failed to register \" + url + \" to zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e);\n        }\n    }\n\n    @Override\n    protected void doUnregister(URL url) {\n        try {\n            //执行取消注册\n            //删除url节点路径\n            zkClient.delete(toUrlPath(url));\n        } catch (Throwable e) {\n            throw new RpcException(\"Failed to unregister \" + url + \" to zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e);\n        }\n    }\n\n    @Override\n    protected void doUnsubscribe(URL url, NotifyListener listener) {\n        //执行取消订阅\n        //根据订阅url获取监听\n        ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);\n        if (listeners != null) {\n            //根据NotifyListener获取zk监听\n            ChildListener zkListener = listeners.get(listener);\n            if (zkListener != null) {\n                //从zk上移除节点监听\n                zkClient.removeChildListener(toUrlPath(url), zkListener);\n            }\n        }\n    }\n\n    /**\n     * 执行订阅\n     * @param url\n     * 例如： provider://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&category=configurators&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=6504&side=provider&timestamp=1534927826842\n     *       consumer://192.168.99.60/com.alibaba.dubbo.demo.DemoService?application=demo-consumer&category=providers,configurators,routers&check=false&dubbo=2.0.0&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=1880&qos.port=33333&side=consumer&timestamp=1535449640995\n     * @param listener 例如：OverrideListener\n     */\n    @Override\n    protected void doSubscribe(final URL url, final NotifyListener listener) {\n        try {\n            //执行订阅\n            //查看订阅url的interface属性是否=*\n            if (Constants.ANY_VALUE.equals(url.getServiceInterface())) {\n                String root = toRootPath();\n                //获取订阅url的监听列表\n                ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);\n                if (listeners == null) {\n                    zkListeners.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, ChildListener>());\n                    listeners = zkListeners.get(url);\n                }\n                //获取listener对应的zk监听器\n                ChildListener zkListener = listeners.get(listener);\n                if (zkListener == null) {\n                    //如果zk监听器为空，则新建一个，并放入zkListeners集合中\n                    listeners.putIfAbsent(listener, new ChildListener() {\n                        @Override\n                        public void childChanged(String parentPath, List<String> currentChilds) {\n                            for (String child : currentChilds) {\n                                child = URL.decode(child);\n                                if (!anyServices.contains(child)) {\n                                    //记录节点child\n                                    anyServices.add(child);\n                                    //订阅child\n                                    //添加interface = child\n                                    //添加check = false\n                                    subscribe(url.setPath(child).addParameters(Constants.INTERFACE_KEY,child,\n                                            Constants.CHECK_KEY, String.valueOf(false)), listener);\n                                }\n                            }\n                        }\n                    });\n                    zkListener = listeners.get(listener);\n                }\n                //创建root持久化节点\n                zkClient.create(root, false);\n                //添加root节点监听，services为root节点的子节点列表\n                List<String> services = zkClient.addChildListener(root, zkListener);\n                if (services != null && !services.isEmpty()) {\n                    for (String service : services) {\n                        //子节点\n                        service = URL.decode(service);\n                        anyServices.add(service);\n                        //订阅子节点\n                        subscribe(url.setPath(service).addParameters(Constants.INTERFACE_KEY, service,\n                                Constants.CHECK_KEY, String.valueOf(false)), listener);\n                    }\n                }\n            } else {\n                List<URL> urls = new ArrayList<URL>();\n                //遍历url的类别列表 /dubbo/com.alibaba.dubbo.demo.DemoService/configurators\n                for (String path : toCategoriesPath(url)) {\n\t\t    //根据订阅url获取监听\n                    ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);\n                    if (listeners == null) {\n                        zkListeners.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, ChildListener>());\n                        listeners = zkListeners.get(url);\n                    }\n                    ChildListener zkListener = listeners.get(listener);\n                    if (zkListener == null) {\n\t\t        //添加为空，则新建一个节点监听\n                        listeners.putIfAbsent(listener, new ChildListener() {\n                            @Override\n                            public void childChanged(String parentPath, List<String> currentChilds) {\n                                //执行通知\n                                ZookeeperRegistry.this.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds));\n                            }\n                        });\n                        zkListener = listeners.get(listener);\n                    }\n                    //创建path节点,\n                    //即：/dubbo/com.xxx.demoService/providers\n                    //即：/dubbo/consumers  /dubbo/com.alibaba.dubbo.demo.DemoService/configurators\n                    zkClient.create(path, false);\n                    //添加path节点监听zkListener\n                    List<String> children = zkClient.addChildListener(path, zkListener);\n                    if (children != null) {\n\t\t\t//empty://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&category=configurators&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=6504&side=provider&timestamp=1534927826842\n                        urls.addAll(toUrlsWithEmpty(url, path, children));\n                    }\n                }\n                //通知消费者(urls即为待通知的消息)\n                notify(url, listener, urls);\n            }\n        } catch (Throwable e) {\n            throw new RpcException(\"Failed to subscribe \" + url + \" to zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public List<URL> lookup(URL url) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"lookup url == null\");\n        }\n        try {\n            //找到的所有的子节点\n            List<String> providers = new ArrayList<String>();\n            //遍历url类别数组 /dubbo/com.alibaba.dubbo.demo.DemoService/providers\n            for (String path : toCategoriesPath(url)) {\n                //获取path节点的子节点\n                List<String> children = zkClient.getChildren(path);\n                if (children != null) {\n                    providers.addAll(children);\n                }\n            }\n            return toUrlsWithoutEmpty(url, providers);\n        } catch (Throwable e) {\n            throw new RpcException(\"Failed to lookup \" + url + \" from zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * 如果root = /,则返回 / ,否则返回 /dubbo/\n     * @return\n     */\n    private String toRootDir() {\n        if (root.equals(Constants.PATH_SEPARATOR)) {\n            return root;\n        }\n        return root + Constants.PATH_SEPARATOR;\n    }\n\n    private String toRootPath() {\n        return root;\n    }\n\n    /**\n     * 获取服务地址\n     * @param url\n     * @return  /dubbo/  或者 /dubbo/编码后的interface\n     */\n    private String toServicePath(URL url) {\n        String name = url.getServiceInterface();\n        if (Constants.ANY_VALUE.equals(name)) {\n            //interface = *，则返回: /dubbo/\n            return toRootPath();\n        }\n        //返回： /dubbo/编码后的interface\n        return toRootDir() + URL.encode(name);\n    }\n\n    /**\n     * 根据url获取类别数组\n     * @param url\n     * @return\n     */\n    private String[] toCategoriesPath(URL url) {\n        String[] categories;\n        if (Constants.ANY_VALUE.equals(url.getParameter(Constants.CATEGORY_KEY))) {\n            //url的category参数=*，则取所有的类别，即 categories = providers、consumers、routers、configurators\n            categories = new String[]{\n\t\t\tConstants.PROVIDERS_CATEGORY, \n\t\t\tConstants.CONSUMERS_CATEGORY,\n\t\t\tConstants.ROUTERS_CATEGORY, \n\t\t\tConstants.CONFIGURATORS_CATEGORY\n\t    };\n        } else {\n            //如果category参数为空，则取默认类别：providers\n            categories = url.getParameter(Constants.CATEGORY_KEY, new String[]{Constants.DEFAULT_CATEGORY});\n        }\n        String[] paths = new String[categories.length];\n        for (int i = 0; i < categories.length; i++) {\n            //例如：/dubbo/com.xxx.demoService/providers (interface != *)\n            //例如：/dubbo/providers (interface = *)\n            paths[i] = toServicePath(url) + Constants.PATH_SEPARATOR + categories[i];\n        }\n        return paths;\n    }\n\n    /**\n     * 获取url对应的类别地址\n     * /dubbo/com.alibaba.dubbo.demo.demoService/providers\n     * @param url\n     * @return\n     */\n    private String toCategoryPath(URL url) {\n        return toServicePath(url) + Constants.PATH_SEPARATOR + url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);\n    }\n\n    /**\n     * 获取url对应的url地址(将会在zk上创建该地址)\n     * @param url\n     * @return /dubbo/com.alibaba.dubbo.demo.DemoService/providers/dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=7112&side=provider&timestamp=1534931882323\n     */\n    private String toUrlPath(URL url) {\n        return toCategoryPath(url) + Constants.PATH_SEPARATOR + URL.encode(url.toFullString());\n    }\n\n    /**\n     * 返回值为空的话，不会返回默认值\n     * @param consumer\n     * @param providers\n     * @return\n     */\n    private List<URL> toUrlsWithoutEmpty(URL consumer, List<String> providers) {\n        List<URL> urls = new ArrayList<URL>();\n        if (providers != null && !providers.isEmpty()) {\n            for (String provider : providers) {\n                //解码\n                provider = URL.decode(provider);\n                if (provider.contains(\"://\")) {\n                    URL url = URL.valueOf(provider);\n                    //是否匹配\n                    if (UrlUtils.isMatch(consumer, url)) {\n                        urls.add(url);\n                    }\n                }\n            }\n        }\n        return urls;\n    }\n\n    /**\n     * 如果为空的话，则返回一个默认值\n     * @param consumer provider://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&category=configurators&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=6504&side=provider&timestamp=1534927826842\n     * @param path /dubbo/com.alibaba.dubbo.demo.DemoService/configurators\n     * @param providers\n     * @return\n     */\n    private List<URL> toUrlsWithEmpty(URL consumer, String path, List<String> providers) {\n        List<URL> urls = toUrlsWithoutEmpty(consumer, providers);\n        if (urls == null || urls.isEmpty()) {\n            int i = path.lastIndexOf('/');\n            //获取类别\n            String category = i < 0 ? path : path.substring(i + 1);\n            //设置empty协议，并设置category属性\n            URL empty = consumer.setProtocol(Constants.EMPTY_PROTOCOL).addParameter(Constants.CATEGORY_KEY, category);\n            urls.add(empty);\n        }\n        return urls;\n    }\n}\n```\n可以看到zk注册中心根据NotifyListener接口与RegistryDirectory类进行通信，通过notify方法通知消费者有更新。通过ZookeeperClient与Zookeeper进行交互。\n接下来，我们来看下是dubbo是如何通过工厂创建ZookeeperRegistry实例的。\n\n### Zookeeper注册中心工厂\n先来看下ZookeeperRegistryFactory类，该类继承自AbstractRegistryFactory，用来创建具体的ZookeeperRegistry实例\n```java\npublic class ZookeeperRegistryFactory extends AbstractRegistryFactory {\n\n    private ZookeeperTransporter zookeeperTransporter;\n\n    public void setZookeeperTransporter(ZookeeperTransporter zookeeperTransporter) {\n        this.zookeeperTransporter = zookeeperTransporter;\n    }\n   \n    /**\n     * @param url 注册中心url\n     */\n    @Override\n    public Registry createRegistry(URL url) {\n        //创建zk注册中心\n        return new ZookeeperRegistry(url, zookeeperTransporter);\n    }\n}\n```\nZookeeperTransporter是一个接口，dubbo支持多个zk客户端实现，例如Curator、ZkClient，该接口就是用来创建具体的客户端实现的，可以看到默认是使用curator客户端。\n```java\n@SPI(\"curator\")\npublic interface ZookeeperTransporter {\n    @Adaptive({Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY})\n    ZookeeperClient connect(URL url);\n}\n\npublic class CuratorZookeeperTransporter implements ZookeeperTransporter {\n    @Override\n    public ZookeeperClient connect(URL url) {\n        //返回Curator实现\n        return new CuratorZookeeperClient(url);\n    }\n}\n\npublic class ZkclientZookeeperTransporter implements ZookeeperTransporter {\n    @Override\n    public ZookeeperClient connect(URL url) {\n        //返回Zkclient实现\n        return new ZkclientZookeeperClient(url);\n    }\n}\n```\n下面我们就来看看各个ZookeeperClient的实现。\n\n#### ZookeeperClient接口\n该接口定义了一些针对zk的基本操作\n```java\npublic interface ZookeeperClient {\n    /**\n     * 创建一个节点\n     * @param path 节点路径\n     * @param ephemeral 是否临时节点\n     */\n    void create(String path, boolean ephemeral);\n\n    /**\n     * 删除一个节点\n     * @param path\n     */\n    void delete(String path);\n\n    /**\n     * 获取某个节点的子节点路径\n     * @param path\n     * @return\n     */\n    List<String> getChildren(String path);\n\n    /**\n     * 添加节点监听器\n     * @param path 节点路径\n     * @param listener 监听器\n     * @return\n     */\n    List<String> addChildListener(String path, ChildListener listener);\n\n    /**\n     * 移除节点监听器\n     * @param path\n     * @param listener\n     */\n    void removeChildListener(String path, ChildListener listener);\n\n    /**\n     * 添加变更事件监听\n     * @param listener\n     */\n    void addStateListener(StateListener listener);\n    /**\n     * 移除变更事件监听\n     */\n    void removeStateListener(StateListener listener);\n    /**\n     * 是否已连接\n     * @return\n     */\n    boolean isConnected();\n    /**\n     * 关闭\n     */\n    void close();\n    /**\n     * 获取注册中心url\n     */\n    URL getUrl();\n}\n```\n##### AbstractZookeeperClient抽象类\n```java\npublic abstract class AbstractZookeeperClient<TargetChildListener> implements ZookeeperClient {\n\n    protected static final Logger logger = LoggerFactory.getLogger(AbstractZookeeperClient.class);\n\n    /**\n     * 注册中心url\n     */\n    private final URL url;\n\n    /**\n     * 缓存监听\n     */\n    private final Set<StateListener> stateListeners = new CopyOnWriteArraySet<StateListener>();\n\n    /**\n     * 节点监听缓存\n     */\n    private final ConcurrentMap<String, ConcurrentMap<ChildListener, TargetChildListener>>\n            childListeners = new ConcurrentHashMap<String, ConcurrentMap<ChildListener, TargetChildListener>>();\n\n    /**\n     * 客户端是否已停止\n     */\n    private volatile boolean closed = false;\n\n    public AbstractZookeeperClient(URL url) {\n        this.url = url;\n    }\n\n    @Override\n    public URL getUrl() {\n        return url;\n    }\n\n    @Override\n    public void create(String path, boolean ephemeral) {\n        int i = path.lastIndexOf('/');\n        if (i > 0) {\n            //获取到父路径\n            String parentPath = path.substring(0, i);\n            if (!checkExists(parentPath)) {\n                //父路径不存在的话，进行递归创建\n                create(parentPath, false);\n            }\n        }\n        if (ephemeral) {\n            //创建临时节点\n            createEphemeral(path);\n        } else {\n            //创建持久节点\n            createPersistent(path);\n        }\n    }\n\n    @Override\n    public void addStateListener(StateListener listener) {\n        stateListeners.add(listener);\n    }\n    @Override\n    public void removeStateListener(StateListener listener) {\n        stateListeners.remove(listener);\n    }\n    public Set<StateListener> getSessionListeners() {\n        return stateListeners;\n    }\n    @Override\n    public List<String> addChildListener(String path, final ChildListener listener) {\n        //从缓存中获取path节点的监听\n        ConcurrentMap<ChildListener, TargetChildListener> listeners = childListeners.get(path);\n        if (listeners == null) {\n            childListeners.putIfAbsent(path, new ConcurrentHashMap<ChildListener, TargetChildListener>());\n            listeners = childListeners.get(path);\n        }\n        TargetChildListener targetListener = listeners.get(listener);\n        if (targetListener == null) {\n            //为节点path新创建一个监听，并放入listeners中\n            listeners.putIfAbsent(listener, createTargetChildListener(path, listener));\n            targetListener = listeners.get(listener);\n        }\n        //添加目标节点监听\n        return addTargetChildListener(path, targetListener);\n    }\n\n    @Override\n    public void removeChildListener(String path, ChildListener listener) {\n        //从缓存中获取path节点的监听\n        ConcurrentMap<ChildListener, TargetChildListener> listeners = childListeners.get(path);\n        if (listeners != null) {\n            //从缓存中移除监听listener\n            TargetChildListener targetListener = listeners.remove(listener);\n            if (targetListener != null) {\n                //移除目标节点的监听targetListener\n                removeTargetChildListener(path, targetListener);\n            }\n        }\n    }\n\n    /**\n     * 状态变更事件\n     * @param state\n     */\n    protected void stateChanged(int state) {\n        //遍历所有的监听器\n        for (StateListener sessionListener : getSessionListeners()) {\n\t    //执行变更事件\n            sessionListener.stateChanged(state);\n        }\n    }\n\n    @Override\n    public void close() {\n        if (closed) {\n\t    //已关闭\n            return;\n        }\n        closed = true;\n        try {\n            doClose();\n        } catch (Throwable t) {\n            logger.warn(t.getMessage(), t);\n        }\n    }\n    //************模板方法************\n    //关闭\n    protected abstract void doClose();\n    //创建持久节点\n    protected abstract void createPersistent(String path);\n    //创建临时节点\n    protected abstract void createEphemeral(String path);\n    //检测节点是否存在\n    protected abstract boolean checkExists(String path);\n    //创建目标节点监听\n    protected abstract TargetChildListener createTargetChildListener(String path, ChildListener listener);\n    //添加目标节点监听\n    protected abstract List<String> addTargetChildListener(String path, TargetChildListener listener);\n    //移除目标节点监听\n    protected abstract void removeTargetChildListener(String path, TargetChildListener listener);\n}\n```\n##### CuratorZookeeperClient实现\n```java\npublic class CuratorZookeeperClient extends AbstractZookeeperClient<CuratorWatcher> {\n    \n    //Curator客户端，对zk的操作都是由它来完成\n    private final CuratorFramework client;\n\n    public CuratorZookeeperClient(URL url) {\n        //设置注册中心url\n        super(url);\n        try {\n            CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()\n                    //指定注册中心url地址,多个地址使用逗号分隔\n                    .connectString(url.getBackupAddress())\n                    //设置重试策略，最大重试1次，重试间隔1000毫秒\n                    .retryPolicy(new RetryNTimes(1, 1000))\n                    //设置连接超时,单位ms,默认1500ms,这里设置5秒\n                    .connectionTimeoutMs(5000);\n            //获取url的username:password\n            String authority = url.getAuthority();\n            if (authority != null && authority.length() > 0) {\n                //添加授权\n                builder = builder.authorization(\"digest\", authority.getBytes());\n            }\n            //生成curator客户端\n            client = builder.build();\n            //监听客户端链接状态\n            client.getConnectionStateListenable().addListener(new ConnectionStateListener() {\n                @Override\n                public void stateChanged(CuratorFramework client, ConnectionState state) {\n                    if (state == ConnectionState.LOST) {\n                        //断开状态，则触发链接断开事件\n                        CuratorZookeeperClient.this.stateChanged(StateListener.DISCONNECTED);\n                    } else if (state == ConnectionState.CONNECTED) {\n                        //已连接状态，则触发链接事件\n                        CuratorZookeeperClient.this.stateChanged(StateListener.CONNECTED);\n                    } else if (state == ConnectionState.RECONNECTED) {\n                        //重连状态，则触发重连事件\n                        CuratorZookeeperClient.this.stateChanged(StateListener.RECONNECTED);\n                    }\n                }\n            });\n            //启动客户端\n            client.start();\n        } catch (Exception e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public void createPersistent(String path) {\n        try {\n            //创建持久化节点path\n            client.create().forPath(path);\n        } catch (NodeExistsException e) {\n        } catch (Exception e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public void createEphemeral(String path) {\n        try {\n            //创建临时节点path\n            client.create().withMode(CreateMode.EPHEMERAL).forPath(path);\n        } catch (NodeExistsException e) {\n        } catch (Exception e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public void delete(String path) {\n        try {\n            //删除节点path\n            client.delete().forPath(path);\n        } catch (NoNodeException e) {\n        } catch (Exception e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public List<String> getChildren(String path) {\n        try {\n            //获取path节点的子节点列表\n            return client.getChildren().forPath(path);\n        } catch (NoNodeException e) {\n            return null;\n        } catch (Exception e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public boolean checkExists(String path) {\n        try {\n            //检测path节点是否已存在\n            if (client.checkExists().forPath(path) != null) {\n                return true;\n            }\n        } catch (Exception e) {\n        }\n        return false;\n    }\n    @Override\n    public boolean isConnected() {\n        //是否已连接状态\n        return client.getZookeeperClient().isConnected();\n    }\n\n    @Override\n    public void doClose() {\n        //关闭客户端\n        client.close();\n    }\n\n    @Override\n    public CuratorWatcher createTargetChildListener(String path, ChildListener listener) {\n        //新创建一个目标节点监听\n        return new CuratorWatcherImpl(listener);\n    }\n\n    @Override\n    public List<String> addTargetChildListener(String path, CuratorWatcher listener) {\n        try {\n            //获取path子节点，并添加监听\n            return client.getChildren().usingWatcher(listener).forPath(path);\n        } catch (NoNodeException e) {\n            return null;\n        } catch (Exception e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public void removeTargetChildListener(String path, CuratorWatcher listener) {\n        //移除监听\n        ((CuratorWatcherImpl) listener).unwatch();\n    }\n   \n    /**\n     * 该内部类实现了CuratorWatcher接口\n     */\n    private class CuratorWatcherImpl implements CuratorWatcher {\n        //监听\n        private volatile ChildListener listener;\n        public CuratorWatcherImpl(ChildListener listener) {\n            this.listener = listener;\n        }\n        /**\n         * 取消监听\n         */\n        public void unwatch() {\n            this.listener = null;\n        }\n        @Override\n        public void process(WatchedEvent event) throws Exception {\n            if (listener != null) {\n                //变更节点\n                String path = event.getPath() == null ? \"\" : event.getPath();\n                //触发变更事件\n                listener.childChanged(path,\n                        //如果path为空，curator使用watcher将会抛出异常\n                        //如果客户端连接、断开连接服务器，zookeeper将会排队watched event事件\n                        StringUtils.isNotEmpty(path)\n                                //为path的子节点增加监听(当前CuratorWatcherImpl,只能使用1次)\n                                ? client.getChildren().usingWatcher(this).forPath(path)\n                                : Collections.<String>emptyList());\n            }\n        }\n    }\n}\n```\n##### ZkclientZookeeperClient实现\n```java\npublic class ZkclientZookeeperClient extends AbstractZookeeperClient<IZkChildListener> {\n    /**\n     * ZkClient包装类，下面的操作都会交给它来执行\n     */\n    private final ZkClientWrapper client;\n\n    private volatile KeeperState state = KeeperState.SyncConnected;\n\n    public ZkclientZookeeperClient(URL url) {\n        //设置注册中心地址\n        super(url);\n        //创建zkClient客户端\n        client = new ZkClientWrapper(url.getBackupAddress(), 30000);\n        //添加监听\n        client.addListener(new IZkStateListener() {\n            @Override\n            public void handleStateChanged(KeeperState state) throws Exception {\n\t\t//设置当前状态\n\t\tZkclientZookeeperClient.this.state = state;\n                if (state == KeeperState.Disconnected) {\n                    //触发断开连接事件\n                    stateChanged(StateListener.DISCONNECTED);\n                } else if (state == KeeperState.SyncConnected) {\n                    //触发连接成功事件\n                    stateChanged(StateListener.CONNECTED);\n                }\n            }\n            @Override\n            public void handleNewSession() throws Exception {\n                //触发重新连接事件\n                stateChanged(StateListener.RECONNECTED);\n            }\n        });\n        client.start();\n    }\n    @Override\n    public void createPersistent(String path) {\n        try {\n            client.createPersistent(path);\n        } catch (ZkNodeExistsException e) {\n        }\n    }\n    @Override\n    public void createEphemeral(String path) {\n        try {\n            client.createEphemeral(path);\n        } catch (ZkNodeExistsException e) {\n        }\n    }\n    @Override\n    public void delete(String path) {\n        try {\n            client.delete(path);\n        } catch (ZkNoNodeException e) {\n        }\n    }\n    @Override\n    public List<String> getChildren(String path) {\n        try {\n            return client.getChildren(path);\n        } catch (ZkNoNodeException e) {\n            return null;\n        }\n    }\n    @Override\n    public boolean checkExists(String path) {\n        try {\n            return client.exists(path);\n        } catch (Throwable t) {\n        }\n        return false;\n    }\n    @Override\n    public boolean isConnected() {\n        return state == KeeperState.SyncConnected;\n    }\n    @Override\n    public void doClose() {\n        client.close();\n    }\n    @Override\n    public IZkChildListener createTargetChildListener(String path, final ChildListener listener) {\n        return new IZkChildListener() {\n            @Override\n            public void handleChildChange(String parentPath, List<String> currentChilds) throws Exception {\n                //触发节点变更事件\n                listener.childChanged(parentPath, currentChilds);\n            }\n        };\n    }\n    @Override\n    public List<String> addTargetChildListener(String path, final IZkChildListener listener) {\n        return client.subscribeChildChanges(path, listener);\n    }\n    @Override\n    public void removeTargetChildListener(String path, IZkChildListener listener) {\n        client.unsubscribeChildChanges(path, listener);\n    }\n}\n```\n###### ZkClientWrapper包装类\nZkclient包装类可以在连接失效后自动监控连接的状态，使用方式与curator一致\n```java\npublic class ZkClientWrapper {\n\n    /**\n     * 获取客户端超时时间\n     */\n    private long timeout;\n    /**\n     * ZkClient客户端\n     */\n    private ZkClient client;\n    /**\n     * 当前状态\n     */\n    private volatile KeeperState state;\n\n    /**\n     * 可监听的FutureTask\n     */\n    private ListenableFutureTask<ZkClient> listenableFutureTask;\n    /**\n     * 客户端是否已启动\n     */\n    private volatile boolean started = false;\n\n    /**\n     * @param serverAddr 注册中心url\n     */\n    public ZkClientWrapper(final String serverAddr, long timeout) {\n        //设置超时\n        this.timeout = timeout;\n\n        //创建一个FutureTask，用来创建zkClient客户端\n        listenableFutureTask = ListenableFutureTask.create(new Callable<ZkClient>() {\n            @Override\n            public ZkClient call() throws Exception {\n\t        //创建ZkClient客户端\n                return new ZkClient(serverAddr, Integer.MAX_VALUE);\n            }\n        });\n    }\n   \n    /**\n     * 启动zkclient\n     */\n    public void start() {\n        if (!started) {\n            //新建守护线程，创建zkClient客户端\n            Thread connectThread = new Thread(listenableFutureTask);\n            connectThread.setName(\"DubboZkclientConnector\");\n            connectThread.setDaemon(true);\n            connectThread.start();\n            try {\n                //获取新创建的客户端\n                client = listenableFutureTask.get(timeout, TimeUnit.MILLISECONDS);\n            } catch (Throwable t) {\n\t        //获取client超时\n                logger.error(\"Timeout! zookeeper server can not be connected in : \" + timeout + \"ms!\", t);\n            }\n            started = true;\n        } else {\n            logger.warn(\"Zkclient has already been started!\");\n        }\n    }\n  \n    /**\n     * 添加监听listener\n     */\n    public void addListener(final IZkStateListener listener) {\n        //使用listenableFutureTask监听client的创建，client创建成功后在订阅该listener\n        listenableFutureTask.addListener(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    client = listenableFutureTask.get();\n                    //获取到客户端后，订阅listener\n                    client.subscribeStateChanges(listener);\n                } catch (InterruptedException e) {\n                    logger.warn(Thread.currentThread().getName() + \" was interrupted unexpectedly, which may cause unpredictable exception!\");\n                } catch (ExecutionException e) {\n                    logger.error(\"Got an exception when trying to create zkclient instance, can not connect to zookeeper server, please check!\", e);\n                }\n            }\n        });\n    }\n\n    public boolean isConnected() {\n        //是否已连接\n        return client != null && state == KeeperState.SyncConnected;\n    }\n\n    public void createPersistent(String path) {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        //创建持久化节点\n        client.createPersistent(path, true);\n    }\n\n    public void createEphemeral(String path) {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        //创建临时节点\n        client.createEphemeral(path);\n    }\n\n    public void delete(String path) {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        //删除节点\n        client.delete(path);\n    }\n\n    public List<String> getChildren(String path) {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        //获取path节点的子节点\n        return client.getChildren(path);\n    }\n\n    public boolean exists(String path) {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        //判断path节点是否存在\n        return client.exists(path);\n    }\n\n    public void close() {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        client.close();\n    }\n\n    public List<String> subscribeChildChanges(String path, final IZkChildListener listener) {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        //订阅path节点变更事件\n        return client.subscribeChildChanges(path, listener);\n    }\n\n    public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        //取消订阅path节点变更事件\n        client.unsubscribeChildChanges(path, listener);\n    }\n}\n```\n\n关于zk注册中心的内容就介绍到这里，下一小节介绍其他注册中心的实现。\n\n","tags":["dubbo"]},{"title":"《k8s权威指南》- 笔记","url":"/blog/2018/08/19/k8s权威指南-笔记/","content":"Kubernetes是基于容器技术，目的是实现资源动态管理，以及跨多个数据中心的资源利用率的最大化的分布式架构方案。如果我们的系统设计遵循k8s的设计思想，那么传统系统架构中那些和业务没有多大关系的底层代码和功能模块，都可以统统不用考虑，我们不必在头疼于服务监控、故障处理等模块的开发，使用k8s提供的解决方案，我们可以节省大量的开发成本，降低系统运维的难度。\nk8s具有完备的集群管理能力，支持多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务发现和注册机制、内建的负载均衡器、故障发现和自我修复、服务滚动升级和在线自动扩容、可扩展的资源自动调度机制、以及多粒度的资源配额管理能力。\n\n在介绍k8s基础知识前，我们先来看下k8s基础组件图，然后我们参考着图一起来讲解。\n![](img/k8s.png)\n\n### Master\nMaster是整个k8s集群的控制节点，负责整个集群的管理和控制，基本上所有的控制命令都需要发给它，由它来负责具体的执行过程，因此Master节点非常重要，建议使用独立的服务器来部署，高可用部署建议用3台服务器。\nMaster节点上运行着3个重要的进程：\n* kube-apiserver：提供Http Rest接口的服务进程，是k8s里所有资源增、删、改、查等操作的唯一入口，也是集群控制的入口进程。\n* kube-controller-manager：k8s里面所有资源对象的自动化控制中心。\n* kube-schedule：负责资源调度(Pod调度)的进程。\n另外，Master节点上还需要启动一个etcd服务，因为k8s里所有资源对象的数据全部都是保存在etcd里面的。\n\n### Node\n除了Master节点以外，k8s集群里的其他机器被称为Node节点，每个Node节点都会被Master节点分配一些工作负载(docker容器),当某个Node节点宕机时，其上的工作负载会被Master自动转移到其他Node节点上去。\n每个Node节点上同样运行着一组重要进程：\n* kubelet：负责Pod对应的容器的创建、启停等任务，同时与Master节点密切协作，实现集群管理的基本功能。\n* kube-proxy：实现k8s Service的通信与负载均衡机制的重要组件。\n* Docker Engine：docker引擎，负责本机docker容器的创建和管理工作。\nNode节点可以在运行期间动态添加到k8s集群中，前提是该节点正确启动了上述进程。默认情况下，kubelet会向Master节点注册自己，然后kubelet会定时的向Master节点汇报自身的情报信息，例如：操作系统版本、docker版本、机器CPU内存情况、以及当前有哪些Pod在运行。这样Master便会知道每个Node节点的资源使用情况，并实现高效均衡的资源调度策略。如果某个Node节点超过指定时间没有上报信息，会被Master节点判定为\"失联\"，该Node节点状态将会被标记为不可用(Not Ready),随后，Master会触发相应的自动流程，将不可用的Node节点上的工作负载转移到其他Node节点上。\n### Service\nService是k8s的核心，它其实就是微服务架构中的一个\"微服务\"，每个Service对象都有如下特征：\n* 拥有一个唯一指定的名称(比如mysql-server)\n* 拥有一个虚拟IP(Cluster IP、Service IP 或 VIP，由k8s分配)和端口号(服务的访问入口地址)\n* 能够提供某种远程服务能力\n* 被映射到了提供这种服务能力的一组容器应用上\nService的服务进程目前都基于Socket通信方式对外提供服务，比如Redis、Mysql、Tomcat，或者是实现了某个具体业务的一个特定的Tcp Server进程，虽然一个Service通常由多个相关的服务进程来提供服务，每个服务进程都有一个独立的Endpoint(IP + Port)访问点(例如Tomcat有服务端口和管理端口)，但k8s能够让我们通过Service(Cluster IP + Service Port)连接到指定的Service上，通过k8s内建的透明负载均衡和故障恢复机制，不管后端有多少服务进程，也不管某个服务进程是否会由于发生故障而重新部署到其他机器上，都不会影响到我们对服务的正常调用，更重要的是这个Service一旦创建成功，就不会在发生变化，这意味着，在k8s集群中，我们再也不用为了服务的IP地址变来变去的问题而头疼了。\n通过上图，我们可以看到，前端应用Pod通过Service的入口地址，访问到了该Service背后一组由Pod副本组成的集群实例。Service是通过Label Select标签选择器机制与其后端Pod副本集群关联起来的，而ReplicationController的作用实际上是保证Service的服务能力和服务质量始终处于预期的标准(根据ReplicationController的副本数量配置，k8s会保证启动相应副本数的容器)\n\n\n### Pod\n容器提供了强大隔离功能，k8s为了实现Service服务隔离设计了Pod对象，将每个服务进程包装到相应的Pod中，使其成为Pod中运行的一个容器，为了建立Service和Pod的关联关系，k8s首先给每个Pod贴上一个标签(Label),例如给运行Mysql的Pod贴上name=mysql标签，给运行redis的Pod贴上name=redis的标签，然后给相应的Service定义标签选择器(Label Selector)，比如Redis集群Service的标签选择器的选择条件为name=redis，那么该Redis集群Service将会作用于所有包含name=redis标签的Pod上,这样一来，就解决了Service和Pod的关联问题。\n通过上图，我们可以看到Pod运行在Node节点上，通常每个Node节点上可以运行几百个Pod，而且运行一个被称为\"根容器\"的Pause容器。因为在一组容器作为一个单元的情况下，我们很难对一个\"整体\"进行简单的判断，例如，一个容器挂掉了，那么此时算是整体死亡吗？是N/M的死亡率吗？引入业务无关且不易挂掉的Pause容器作为Pod的根容器，以它的状态代表整个容器组的状态，就简单的解决了这个问题。另外，Pod里的多个业务容器共享Pause容器的IP，共享Pause容器挂接的Volume，这样即简化了密切关联的业务容器之间的通信问题，也很好的解决了它们之间的文件共享问题。\nk8s为每个Pod都分配了一个唯一的Pod IP，一个Pod里的多个容器共享该Pod IP地址，k8s要求底层网络支持集群内任意两个Pod之间的TCP/IP直接通信，这通常采用\"虚拟二层网络\"技术来实现，例如：Flannel、Open vSwitch等，因此，我们需要牢记一点：在k8s里，一个Pod里的容器与另外主机上的Pod容器能够直接通信。\nPod分为两种类型：普通的Pod和静态的Pod，静态Pod比较特殊，它并不在k8s的etcd中存储，而是存在在某个具体的Node上的一个具体文件中，并且只在此Node上运行，而普通的Pod一旦创建，就会被放入etcd中存储，随后会被k8s的Master调度到某个具体的Node上进行绑定，随后该Pod被对应的Node上的kubelet进程实例化为一组相关的Docker容器并启动起来。在默认情况下，当Pod里的某个容器停止时，k8s会自动检测到这个问题并且重启该Pod(重启Pod里的所有容器)，如果Pod所在的Node宕机，则会将这个Node上的所有Pod重新调度到其他节点上运行。\n\n\nPod IP 加上容器的Port，就组成了Endpoint，它代表着此Pod里的一个服务进程的对外通信地址，一个Pod也存在着具有多个Endpoint的情况，比如当我们把Tomcat定义为一个Pod时，可以对外暴露管理端口和服务端口这两个Endpoint.\n\nk8s的Event是一个事件的记录，记录了事件的最早产生时间、最后重现事件、重复次数、发起者、类型，以及导致此事件的原因等众多信息，Event通常会关联到某个具体的资源对象上，是排查故障的重要参考信息。\n\n#### Service 和 Pod\n既然每个Pod都会被分配唯一的Pod IP，而且每个Pod都提供了一个独立的Endpoint(Pod IP + 容器Port)以被客户端访问，现在多个Pod副本就组成了一个集群来提供服务，那么客户端该如何来访问它们呢？\n一般的做法是部署一个负载均衡器，为这组Pod开启一个对外的服务端口如8000端口，并且将这些Pod的Endpoint列表加入8000端口的转发列表中，客户端就可以通过负载均衡器的对外IP地址+服务端口来访问此服务了，而客户端的请求最后会被转发到哪个Pod，则由负载均衡器的算法来决定。\nk8s也遵循了上述常规做法，运行在每个Node上的kube-proxy进程其实就是一个智能的软件负载均衡器，它负责把对Service的请求转发到后端的某个Pod实例上，并在内部实现服务的负载均衡和回话保持机制。但k8s发明了一种很巧妙的设计：Service不是共用一个负载均衡器的IP地址，而是每个Service被分配了一个全局唯一的虚拟的Cluster IP，这样一来，每个服务就变成了具备唯一IP地址的\"通信节点\"，服务调用就变成了最基础的TCP网络通信问题。\n我们知道Pod的Endpoint地址会随着Pod的销毁和重新创建而发生改变，因此新Pod的IP地址和旧Pod的IP地址不同。而Service的一旦被创建，k8s就会自动为它分配一个可用的Cluster IP，而且在Service的整个生命周期内，它的Cluster IP都不会发生改变，于是服务发现这个问题在k8s的架构里就得以轻松解决：只需要用Service的Name和Service的Cluster IP做一个DNS域名映射就可以完美解决问题。\n那么如何实现通过Service的Name来查找对应的Cluster IP呢？\n最早以前，k8s采用了Linux环境变量的方式，为每个Service生成一些对应的环境变量，并在每个Pod的容器启动时，自动注入这些环境变量，但是这样使用起来仍然不够直观。后来k8s通过Add-On增值包的方式引入了DNS系统，把Service的Name作为DNS的域名，这样一来，程序就可以直接使用Service的Name来建立通信了。\n\n#### 外部系统访问Service的问题\n我们再来看下k8s里面的三种IP：\n\n* Node IP\nNode节点的IP，是每个Node节点的物理网卡的IP，这是一个真实存在的物理网络，所有属于这个网络的服务器之间都能通过这个网络直接通信，不管它们中是否有不属于该k8s集群的节点。这也表明，k8s集群之外的节点想要访问k8s集群内的某个节点或者TCP/IP服务时，必须要通过Node IP进行通信。\n* Pod IP\nPod IP是每个Pod的IP地址，它是Docker Engine根据docker0网桥的IP地址段进行分配的，通常是一个虚拟的二层网络，前面我们说过，k8s要求位于不同Node上的Pod能够彼此直接通信，所以一个Pod里的容器访问另一个Pod里的容器，就是通过Pod IP所在的虚拟二层网络进行通信的，而真实的TCP/IP流量则是通过Node IP所在的物理网卡流出的。\n* Cluster IP\n它也是一个虚拟IP，仅作用于k8s的Service对象，并由k8s管理和分配IP地址(来源于Cluster IP地址池)。Cluster IP只能结合Service Port组成一个具体的通信端口，单独的Cluster IP不具备TCP/IP通信基础。\n\n通过上面的说明，我们明白了，Service的Cluster IP属于k8s集群内部的地址，无法在集群外部直接使用这个地址。那么用户该如何访问我们的tomcat-service呢？使用NodePort是解决上述问题最有效的方法。\nNodePort的实现方式是：在k8s集群里的每个Node上为需要外部访问的Service开启一个对应的TCP监听端口，外部系统只需要用任意一个Node的IP地址+具体的NodePort端口就可以访问该服务。假如我们配置了NodePort=31002，然后在任意的Node上运行netstat命令，就可以看到有NodePort端口被监听。\n\n\n### Label\n一个Label就是一个key=value的键值对，其中key和value由用户自己定义，Label可以附加到各种资源对象上，例如：Node、Pod、Servoce、Replication Controller等，一个资源对象可以定义任意数量的Label，同一个Label也可以添加到任意数量的资源对象上，Label可以在资源对象定义时确定，也可以在资源对象创建后动态添加或者删除。\n我们可以通过给指定的资源对象附加多个不同的Label来实现多维度的资源分组管理功能，以便于灵活方便的进行资源分配、调度、配置、部署等管理工作。例如：部署不同版本的应用到不同的环境中。\n一些常用的Label标签示例如下：\n* 版本标签：\"release\":\"stable\",\"release\":\"canary\"\n* 环境标签：\"env\":\"test\",\"env\":\"uat\",\"env\":\"pro\"\n给某个资源对象附加一些标签，随后我们可以通过Label Selector(标签选择器)查询和筛选拥有某些Label标签的资源对象。\n当前有两种Lavel Selector的表达式：基于等式的和基于集合的，例如：\n* name = redis-slave ，匹配所有拥有name = redis-slave标签的资源对象\n* env != pro，匹配所有不具有env = pro标签的资源对象\n* name in (redis-master,redis-slave)，匹配所有拥有name = redis-master 或者 name = redis-slave标签的资源对象\n* name not in (php)，匹配所有不具有name = php标签的资源对象\n可以通过使用多个Label Selector进行组合来实现复杂的条件选择，多个Label Selector使用逗号进行分割，几个条件之间是\"AND\"的关系，例如：\nname = redis-slave,env != pro\n\nLabel Selector在k8s中的有如下重要场景：\n* kube-contoller进程通过资源对象RC上定义的Label Selector来筛选要监控的Pod副本的数量，从而实现Pod副本的数量始终符合预期设定的全自动控制流程。\n* kube-proxy进程通过Service的Label Selector来选择对应的Pod，自动建立起每个Service到对应Pod的请求转发路由表，从而实现Service的智能路由负载均衡机制。\n* 通过对某些Node定义特定的Label，并且在Pod定义文件中使用NodeSelector这种标签调度策略，kube-schedule进程可以实现Pod\"定向调度\"的特性。\n总结：使用Label可以给资源对象创建多组标签，Label和Label Selector共同构成了k8s系统中最核心的应用模型，使得被管理对象能够被精细的分组管理，同时实现了整个集群的高可用性。\n\n\n### Replication Controller\n\nRC定义了一个期望的场景，即声明某种Pod的副本数量在任意时刻都符合某个预期值。所以RC的定义包括如下几个部分：\n* Pod期待的副本数\n* 用于筛选目标Pod的Label Selector\n* 当Pod的副本数量小于预期数量时，用户创建新Pod的Pod模板\n\n当我们定义了一个RC，并提交到k8s集群以后，Master节点上的Controller Manager组件就会得到通知，定期巡检系统中当前存活的目标Pod，并确保目标Pod的实例的数量刚好等于此Pod的期望值，如果有过多的Pod副本在运行，系统就会停掉一些Pod，否则系统会在创建一些Pod，通过RC，k8s实现了用户应用集群的高可用性，也大大减少了运维的手工操作。\n此外，在运行时，我们可以通过修改RC的副本数量，来实现Pod的动态缩放功能。\n需要注意的是，删除RC定义并不会影响通过该RC已创建好的Pod，为了删除所有的Pod，可以设置副本数为0，然后更新该RC，或者使用kubectl工具命令来一次性删除RC及其管理的Pod。\n当我们的应用升级时，通常会build一个新的Docker镜像，并用新的镜像版本来替换旧的版本的方式来达到目的。如果我们想要平滑的升级，即停止一台旧的，启动一台新的，在整个升级过程中，此消彼长，而运行中的Pod数量始终是10个，几分钟过后，当所有的Pod都已经是新版本时，升级过程完成。通过RC的机制，k8s可以很容易的实现\"滚动升级\"。\n在新版本中k8s新增加了一个Replica Set资源对象，它和RC唯一的区别是：Replica Set是基于集合的Label Selector，而RC是基于等式的Label Selector.当前我们很少单独使用Replica Set，它主要被Deployment这个更高层次的资源对象所使用，从而形成一整套Pod创建、删除、更新的编排机制，当我们使用Deployment时，无需关心它是如何创建和维护Replica Set的，这一切都是自动发生的.\n\n最后，我们总结下关于RC的一些特性和作用：\n* 在大多数情况下，我们通过定义一个RC实现Pod的创建过程及副本数量的自动控制\n* RC里包括完成的Pod定义模板\n* RC通过Label Selector机制实现对Pod副本的自动控制\n* 通过改变RC里的Pod副本数量，可以实现Pod的扩容和缩容功能\n* 通过改变RC里Pod模板中的镜像版本，可以实现Pod的滚动升级功能\n\n\n### Deployment\nDeployment是加强版的RC，它是为了更好的解决Pod的编排问题，在内部使用了Replica Set来实现相应的目的。Deployment的典型使用场景如下：\n* 创建一个Deployment对象来生成对应的Replica Set并完成Pod副本的创建过程。\n* 检查Deployment的状态来查看部署动作是否完成(Pod副本的数量是否达到预期的值)\n* 更新Deployment以创建新的Pod(比如镜像升级)\n* 如果当前Deployment不稳定，则回滚到一个早先的Deployment版本\n* 暂停Deployment以便于一次性修改多个Pod模板的配置项，之后在恢复Deployment，进行新的发布\n* 扩展Deployment以应对高负载\n* 查看Deployment的状态，以此作为发布是否成功的指标\n* 清理不再需要的旧版本的ReplicaSets\n其中Replica Set的名称以Deployment的名称为前缀，Pod的命名以Deployment对应的Replica Set的名字作为前缀，这种命名很清晰的表明了一个Replica Set创建了哪些Pod，对于Pod滚动升级这种复杂的过程来说，很容易进行排查错误。\n\n### Horizontal Pod Autoscaler\n前面我们提到，通过手工执行kubectl scale命令，可以实现Pod的扩容和缩容，但是这并不符合Google对k8s的定位目标————自动化、智能化，分布式系统应该可以根据当前负载的变化情况自动触发水平扩展或缩容的行为，因为这一过程可能是频繁发生的、不可预料的，所以手动来控制的方式不现实。\nHPA与RC、Deployment一样，也属于一种资源对象，通过追踪分析RC控制的所有目标Pod的负载变化情况，来确定是否需要针对性的调整目标Pod的副本数，这是HPA的实现原理，当前，HPA可以有如下两种方式作为Pod负载的度量指标：\n* CPUUtilizationPercentage\n* 应用程序自定义的度量指标，比如服务在每秒内的相应请求数(TPS或QPS)\nCPUUtilizationPercentage是一个算术平均值，即目标Pod所有副本自身的CPU利用率的平均值，一个Pod自身的CPU利用率是该Pod当前CPU的使用量(通常是一分钟内的平均值)除以它的Pod Request的值。比如：我们定义一个Pod的Pod Request为0.4，而当前Pod的CPU使用量为0.2，则它的CPU使用率为50%，如此一来，我们便可以算出来一个RC控制的所有Pod副本的CPU利用率的算术平均值了，如果某一时刻CPUUtilizationPercentage的值超过了80%，则意味着当前Pod的副本数很可能不足以支撑接下来更多的请求，需要进行动态扩容，而当请求高峰时段过去后，Pod的CPU利用率又会降下来，此时对应的Pod的副本数应该自动减少到一个合理的水平。\n\n### StatefulSet\n在k8s系统中，Pod的管理对象RC、Deployment、DaemonSet和Job都是无状态的服务。但现实中有很多服务是有状态的，比如Mysql集群、MongoDB集群、Akka集群、Zookeeper集群等，这些集群有如下共同点：\n* 每个节点都有一个固定的身份ID，通过这个ID，集群中的成员可以互相发现并进行通信\n* 集群的规模比较固定，不能随意变动\n* 即群里的每个节点都是有状态的，通常会持久化数据到永久存储中\n* 如果磁盘损坏，则集群里的某个节点无法正常运行，集群功能受损\n如果用RC/Deployment控制的Pod副本数的方式来实现上述有状态的集群，则我们会发现第一点是无法满足的，因为Pod的名称是随机产生的，Pod的IP地址也是在运行期才确定且可能有变动的，我们事先无法为每个Pod确定唯一不变的ID，另外，为了能够在其他节点上恢复某个失败的节点，这种集群中的Pod需要挂接某种共享存储，为了解决这个问题，k8s引入了StatefulSet这个新的资源对象，它有如下特性：\n* StatefulSet里的每个Pod都有稳定、唯一的网络标识，可以用来发现集群内的其他成员。假设StatefulSet的名字叫kafka，那么它的第一个Pod叫kakfa-0，第二个叫kafka-1，以此类推\n* StatefulSet控制的Pod副本的启停顺序是受控的，操作第n个Pod时，前n-1个Pod已经是运行且准备好的状态\n* StatefulSet里的Pod采用稳定的持久化存储卷，通过PV/PVC来实现，为了保护数据的安全，删除Pod时默认不会删除与StatefulSet相关的存储卷\nStatefulSet除了要与PV卷捆绑使用以存储Pod的状态数据，还要与Headless Service配合使用，即在每个StatefulSet的定义中要声明它属于哪个Headless Service。Headless Service与Service的区别在于，它没有Cluster IP，如果解析Headless Service的DNS域名，则返回的是该Service对应的全部Pod的Endpoint列表，StatefulSet在Headless Service的基础上又为StatefulSet控制的每一个Pod实例创建了一个DNS域名，域名格式如下：\n```shell\n$(podname).$(headless Service name)\n```\n比如一个3节点的Kafka的StatefulSet集群，对应的Headless Service的名称为kafka，StatefulSet的名称为kafka，则StatefulSet里面的3个Pod的DNS名称分别为：kafka-0.kafka、kafka-1.kafka、kafka-2.kafka，这些DNS名称可以直接在集群的配置文件中固定下来。\n\n### Volume\nVolume是Pod中能够被多个容器访问的共享目录，它与Docker中的Volume比较类似，但两者不能等价。首先，k8s中的Volume定义在Pod上，然后被一个Pod里面的多个容器挂载到具体的文件目录下；其次，k8s中的Volume与Pod的生命周期相同，但与容器的生命周期无关，当容器终止或者重启时，Volume中的数据也不会丢失。最后，k8s的Volume支持多种类型的Volume，例如：GlusterFS、Ceph等先进的分布式文件系统。\nVolume的使用比较简单，在大多少情况下，我们只需要先在Pod上声明一个Volume，然后在容器里引用该Volume，并挂载到容器里的某个目录上。\n除了可以让一个Pod里的多个容器共享文件、让容器的数据写到宿主机的磁盘上或者写文件到网络存储中，k8s的Volume还扩展出了一种非常有实用价值的功能，即容器配置文件集中化定义和管理，这是通过ConfigMap资源对象来实现的。\n### Persistent Volume\n之前我们提到的Volume是定义在Pod上的，属于计算资源的一部分，而网络存储是相对独立于计算资源而存在的一种实体资源，比如在使用虚拟机的情况下，我们通常会先定义一个网络存储，然后从中划出一个网盘并挂接到虚拟机上。PV(Persistent Volume)和与之相关联的PVC(Persistent Volume Claim)也起到了类似的作用.\nPV可以理解成k8s集群中某个网络存储中对应的一块存储，它与Volume类似，但是有如下区别：\n* PV只能是网络存储，不属于任何Node，但可以在每个Node上使用\n* PV并不是定义在Pod上的，而是独立于Pod之外定义\n* PV目前支持的类型包括：NFS、gcePersistentDisk、AWSElasticBlockStore、GlusterFS等\n如果某个Pod想要申请某种类型的PV，则需要先定义一个PVC对象，然后在Pod的Volume定义中引用上述PVC即可。\n另外PV是有状态的对象：\n* Available：空闲状态\n* Bound: 已经绑定到某个PVC上\n* Released：对应的PVC已经删除，但资源还没有被集群回收\n* Failed：PV自动回收失败\n\n### Namespace\nNamespace在很多情况下用于实现多租户的资源隔离，Namespace通过将集群内部的资源对象\"分配\"到不同的Namespace中，形成逻辑上分组的不同项目、小组或用户组，便于不同的分组在共享使用整个集群的资源的同时还能被分别管理。\n\nk8s集群在启动后，会创建一个名为\"default\"的Namespace，如果不特别指明Namespace，则用户创建的Pod、RC、Service都将被系统创建到这个默认的default名下。\n当我们为每个租户创建一个Namespace来实现多租户的资源隔离时，还能结合k8s的资源配额管理，限定不同租户能占用的资源，例如CPU使用量、内存使用量等。\n\n### Annotation\nAnnotation和Label类似，也是使用kv对定义，不同的是，Label有严格的命名规则，它定义的是k8s对象的元数据，并且用户Label Selector。而Annotation则是用户任意定义的附加信息，以便于外部工具进行查找。很多时候，k8s的模块自身会通过Annotation的方式标记资源对象的一些特殊信息。通常来说，用Annotation来记录如下信息：\n* build信息、release信息、Docker镜像信息等，例如时间戳、release id号、PR号、镜像hash值、docker registry地址等\n* 日志库、监控库、分析库等资源库的地址信息\n* 程序调试工具信息，例如工具名称、版本号等\n* 团队的联系信息，例如：手机号、负责人名称、网址等\n\n","tags":["k8s"]},{"title":"Dubbo源码阅读之注册中心","url":"/blog/2018/08/17/Dubbo源码阅读之注册中心/","content":">注册中心是Dubbo实现服务化管理的核心组件,类似于目录服务的作用,主要用来存储Dubbo发布的服务信息(譬如提供者url串、路由信息等),Dubbo框架支持zookeeper、redis、multicast等注册中心,下面我们就详细看下Dubbo的注册中心是如何实现的。\n\n先来看下注册中心相关的类图\n![](img/registry.png)\n\n### Registry接口\n```java\npublic interface Registry extends Node, RegistryService {\n}\n```\n#### Node接口\n```java\npublic interface Node {\n    /**\n     * 获取url\n     * @return url.\n     */\n    URL getUrl();\n\n    /**\n     * 是否可用\n     * @return available.\n     */\n    boolean isAvailable();\n\n    /**\n     * 销毁\n     */\n    void destroy();\n}\n```\n\n#### RegistryService接口\n```java\npublic interface RegistryService {\n    /**\n     * 注册数据，例如：提供者服务，消费者服务，路由规则，覆盖规则和其他数据\n     * 注册时需要满足以下邀约：\n     * 1、当Url设置check = false参数时，注册失败时，异常不会抛出，并且会在后台重试，否则，异常将会抛出\n     * 2、当url设置dynamic=false参数时，它需要被永久存储，否则，当注册有异常退出时，它应该被自动删除掉\n     * 3、当url设置category=routers参数时，这意味着分类存储，默认的分类是提供者，并且数据可以通过分类部分得到通知\n     * 4、当注册中心重启，网络抖动，数据不可以丢失，包括自动从虚线中删除数据\n     * 5、允许具有相同URL但是参数不同的URL共存，他们不可以互相覆盖\n     *\n     * @param url 注册信息，不允许为空\n     * 例如：dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&application=kylin\n     */\n    void register(URL url);\n\n    /**\n     * 取消注册\n     * 1、如果它是dynamic=false的持久化存储数据，注册信息不可以发现时，会抛出IllegalStateException异常，\n     *    否则它是忽略的。\n     * 2、根据完整的url匹配进行取消注册\n     * @param url 注册信息,不可以为空 \n     * 例如： dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&application=kylin\n     */\n    void unregister(URL url);\n\n    /**\n     * 订阅符合条件的注册数据，并在注册数据发生改变时自动推送\n     *\n     * 1、当URL设置check=false参数时，当注册失败时，异常不会抛出，并在后台重试。\n     * 2、当url设置category=routers时，它只会通知指定的分类数据，多个分类用逗号分隔，\n     *      并允许使用*号匹配，这表明所有分类数据都已经订阅。\n     * 3、允许interface, group, version,classifier作为一个条件查询，\n     *      例如：interface=com.alibaba.foo.BarService&version=1.0.0\n     * 4、查询条件允许*号匹配，订阅所有接口的所有数据包的所有版本,\n     *      例如：interface=*&group=*&version=*&classifier=*\n     * 5、当注册中心重启、网络抖动时，有必要自动恢复订阅请求。\n     * 6、允许具有相同的url但是参数不同的URL共存,它们不可以互相覆盖\n     * 7、订阅的进程必须是阻塞的，当第一条通知完成后返回。\n     * @param url 订阅条件，不允许为空\n     * 例如: consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&application=kylin\n     * @param listener 变更事件的监听者，不可以为空\n     */\n    void subscribe(URL url, NotifyListener listener);\n\n    /**\n     * 取消订阅\n     *  1、如果没有订阅，直接忽略\n     *  2、取消订阅，需要URL全匹配\n     * @param url  订阅条件，不可以为空\n     * 例如： consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&application=kylin\n     * @param listener 变更事件的监听者,不允许为空\n     */\n    void unsubscribe(URL url, NotifyListener listener);\n\n    /**\n     * 查询符合条件的注册数据，对应于订阅的push模式，这是pull模式并只返回一个结果\n     * @param url 查询条件，不允许为空\n     *   e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&application=kylin\n     * @return 已注册的信息列表, 可能为空, 意义与{NotifyListener#notify(List<URL>)}的参数相同.\n     */\n    List<URL> lookup(URL url);\n}\n```\n\n### NotifyListener接口\n监听器，监听服务的变更\n```java\npublic interface NotifyListener {\n    /**\n     * 当收到服务更改的通知时触发该方法\n     * 1、始终是在服务接口和数据类型的纬度上通知。也就是说，不会通知属于一个服务的部分相同类型的数据，用户无需比较先前通知的结果\n     * 2、订阅时的第一个通知必须是服务所有类型的完整通知\n     * 3、在变更时，允许单独通知不同类型的数据，例如：providers, consumers, routers, overrides,它只允许通知其中一种类型，\n     *    但此类型的数据必须是完整的，而不是增量的\n     * 4、如果数据类型为空，则需要通过url数据的类别参数标识空协议\n     * 5、notifications保证通知的顺序(即registry的实现),例如：单线程推送、队列序列化、版本比较\n     * @param urls 已注册的信息列表,非空,这意味着，它和RegistryService#lookup(URL)方法的返回值相同.\n     */\n    void notify(List<URL> urls);\n}\n```\n\n### AbstractRegistry抽象类\n```java\npublic abstract class AbstractRegistry implements Registry {\n\n    /**\n     * URL地址分隔符，用来文件缓存，服务提供者URL分隔\n     * URL address separator, used in file cache, service provider URL separation\n     */\n    private static final char URL_SEPARATOR = ' ';\n    /**\n     * URL地址正则表达式分隔器，用来解析文件缓存中的服务提供者的URL列表\n     * 这里是空格分隔\n     * URL address separated regular expression for parsing the service provider URL list in the file cache\n     */\n    private static final String URL_SPLIT = \"\\\\s+\";\n    /**\n     * 日志输出\n     * Log output\n     */\n    protected final Logger logger = LoggerFactory.getLogger(getClass());\n    /**\n     * 本地磁盘缓存，其中key“value.registies”用来记录注册中心的列表。\n     * 其他的是通知服务提供者的列表\n     * Local disk cache, where the special key value.registies records the list of registry centers,\n     * and the others are the list of notified service providers\n     */\n    private final Properties properties = new Properties();\n    /**\n     * 文件缓存定时写线程\n     * File cache timing writing\n     */\n    private final ExecutorService registryCacheExecutor = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"DubboSaveRegistryCache\", true));\n    /**\n     * 是否同步保存文件\n     * Is it synchronized to save the file\n     */\n    private final boolean syncSaveFile;\n    /**\n     * 每次更新缓存文件时，都会自增，作为版本号\n     */\n    private final AtomicLong lastCacheChanged = new AtomicLong();\n    /**\n     * 已注册的地址\n     * 暴露的服务的URL集合，即export参数指定的URL\n     */\n    private final Set<URL> registered = new ConcurrentHashSet<URL>();\n    /**\n     * 已订阅的记录\n     * URL变化时，触发NotifyListener\n     * 例如：<服务提供者URL，OverrideListener>\n     */\n    private final ConcurrentMap<URL, Set<NotifyListener>> subscribed = new ConcurrentHashMap<URL, Set<NotifyListener>>();\n    /**\n     * 已通知的url\n     * 会将 <订阅url的服务唯一名称,待通知类别Url列表>写入注册中心缓存文件\n     * <订阅url,<待通知类别, 待通知类别Url列表>>\n     */\n    private final ConcurrentMap<URL, Map<String, List<URL>>> notified = new ConcurrentHashMap<URL, Map<String, List<URL>>>();\n\n    /**\n     * 注册中心URL\n     */\n    private URL registryUrl;\n    /**\n     * 本地磁盘缓存文件(dubbo注册中心缓存)\n     * Local disk cache file\n     */\n    private File file;\n\n    /**\n     *\n     * @param url multicast://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&dubbo=2.0.0&interface=com.alibaba.dubbo.registry.RegistryService&pid=3000&qos.port=22222&timestamp=1528800181027\n     */\n    public AbstractRegistry(URL url) {\n        //校验url不为空，并设置registryUrl = url\n        setUrl(url);\n        // Start file save timer\n        //是否同步保存文件，默认是异步\n        syncSaveFile = url.getParameter(Constants.REGISTRY_FILESAVE_SYNC_KEY, false);\n        //文件名，默认值是：C:\\Users\\Administrator/.dubbo/dubbo-registry-demo-provider-224.5.6.7:1234.cache\n        String filename = url.getParameter(Constants.FILE_KEY, System.getProperty(\"user.home\") + \"/.dubbo/dubbo-registry-\" + url.getParameter(Constants.APPLICATION_KEY) + \"-\" + url.getAddress() + \".cache\");\n        File file = null;\n        if (ConfigUtils.isNotEmpty(filename)) {\n            //创建文件目录\n            file = new File(filename);\n            if (!file.exists() && file.getParentFile() != null && !file.getParentFile().exists()) {\n                if (!file.getParentFile().mkdirs()) {\n                    throw new IllegalArgumentException(\"Invalid registry store file \" + file + \", cause: Failed to create directory \" + file.getParentFile() + \"!\");\n                }\n            }\n        }\n        this.file = file;\n        //加载注册中心缓存file\n        loadProperties();\n        //使用所有的url，进行通知\n        notify(url.getBackupUrls());\n    }\n\n\n    /**\n     * urls 为空的话，会根据url生成一个protocol = empty的URL放入urls并返回（即NotifyListener接口的第4条邀约）\n     * @param url 订阅url\n     * @param urls 注册中心url列表\n     * @return\n     */\n    protected static List<URL> filterEmpty(URL url, List<URL> urls) {\n        if (urls == null || urls.isEmpty()) {\n            //urls为空的话，则设置url的protocol = empty\n            List<URL> result = new ArrayList<URL>(1);\n            //设置protocol = empty\n            result.add(url.setProtocol(Constants.EMPTY_PROTOCOL));\n            return result;\n        }\n        return urls;\n    }\n\n    @Override\n    public URL getUrl() {\n        return registryUrl;\n    }\n\n    protected void setUrl(URL url) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"registry url == null\");\n        }\n\t//设置注册中心url\n        this.registryUrl = url;\n    }\n\n    public Set<URL> getRegistered() {\n        return registered;\n    }\n\n    public Map<URL, Set<NotifyListener>> getSubscribed() {\n        return subscribed;\n    }\n\n    public Map<URL, Map<String, List<URL>>> getNotified() {\n        return notified;\n    }\n\n    public File getCacheFile() {\n        return file;\n    }\n\n    public Properties getCacheProperties() {\n        return properties;\n    }\n\n    public AtomicLong getLastCacheChanged() {\n        return lastCacheChanged;\n    }\n\n    /**\n     * 保存注册中心缓存文件\n     * @param version 版本\n     */\n    public void doSaveProperties(long version) {\n        //如果version小与当前的版本号，说明在执行该方法时，lastCacheChanged又被更新了\n        //因此这里只需要直接返回,等待下一次执行\n        if (version < lastCacheChanged.get()) {\n            return;\n        }\n        if (file == null) {\n            return;\n        }\n        // Save\n        try {\n            //创建一个文件锁\n            File lockfile = new File(file.getAbsolutePath() + \".lock\");\n            if (!lockfile.exists()) {\n                lockfile.createNewFile();\n            }\n            RandomAccessFile raf = new RandomAccessFile(lockfile, \"rw\");\n            try {\n                FileChannel channel = raf.getChannel();\n                try {\n                    //获取排它锁\n                    FileLock lock = channel.tryLock();\n                    if (lock == null) {\n                        //不可以锁定注册中心缓存文件,忽略并稍后重试\n                        //可能多个java进程使用该文件，请配置：dubbo.registry.file=xxx.properties\n                        throw new IOException(\"Can not lock the registry cache file \" + file.getAbsolutePath() + \", ignore and retry later, maybe multi java process use the file, please config: dubbo.registry.file=xxx.properties\");\n                    }\n                    // Save\n                    try {\n                        //缓存文件不存在的话，新创建\n                        if (!file.exists()) {\n                            file.createNewFile();\n                        }\n                        FileOutputStream outputFile = new FileOutputStream(file);\n                        try {\n                            //保存properties文件\n                            properties.store(outputFile, \"Dubbo Registry Cache\");\n                        } finally {\n                            outputFile.close();\n                        }\n                    } finally {\n                        //释放锁\n                        lock.release();\n                    }\n                } finally {\n                    channel.close();\n                }\n            } finally {\n                raf.close();\n            }\n        } catch (Throwable e) {\n            if (version < lastCacheChanged.get()) {\n                return;\n            } else {\n                //如果version >= 当前版本的话，则执行异步保存properties文件\n                registryCacheExecutor.execute(new SaveProperties(lastCacheChanged.incrementAndGet()));\n            }\n            logger.warn(\"Failed to save registry store file, cause: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * 加载注册中心缓存文件\n     */\n    private void loadProperties() {\n        if (file != null && file.exists()) {\n            InputStream in = null;\n            try {\n                in = new FileInputStream(file);\n                properties.load(in);\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"Load registry store file \" + file + \", data: \" + properties);\n                }\n            } catch (Throwable e) {\n                logger.warn(\"Failed to load registry store file \" + file, e);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e) {\n                        logger.warn(e.getMessage(), e);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * 根据订阅url获取已缓存的待通知url列表\n     * 即从配置文件中找到属性key等于url.getServiceKey()的属性值\n     * @param url\n     * @return\n     */\n    public List<URL> getCacheUrls(URL url) {\n        for (Map.Entry<Object, Object> entry : properties.entrySet()) {\n            //订阅url的服务唯一名称\n            String key = (String) entry.getKey();\n            //类别待通知url列表，空格分隔\n            String value = (String) entry.getValue();\n\n            if (key != null && key.length() > 0 && key.equals(url.getServiceKey())\n                    //key的第一个字节是字母或者是下划线\n                    && (Character.isLetter(key.charAt(0)) || key.charAt(0) == '_')\n                    && value != null && value.length() > 0) {\n                //使用空格分隔value，拿到每一个url并放到List中\n                String[] arr = value.trim().split(URL_SPLIT);\n                List<URL> urls = new ArrayList<URL>();\n                for (String u : arr) {\n                    urls.add(URL.valueOf(u));\n                }\n                return urls;\n            }\n        }\n        return null;\n    }\n\n\n    @Override\n    public List<URL> lookup(URL url) {\n        List<URL> result = new ArrayList<URL>();\n        //根据订阅url获取已通知的url列表\n        Map<String, List<URL>> notifiedUrls = getNotified().get(url);\n        if (notifiedUrls != null && notifiedUrls.size() > 0) {\n            //notifiedUrls不为空\n            for (List<URL> urls : notifiedUrls.values()) {\n                for (URL u : urls) {\n                    //过滤掉protocol = empty的url\n                    if (!Constants.EMPTY_PROTOCOL.equals(u.getProtocol())) {\n                        result.add(u);\n                    }\n                }\n            }\n        } else {\n            final AtomicReference<List<URL>> reference = new AtomicReference<List<URL>>();\n            NotifyListener listener = new NotifyListener() {\n                @Override\n                public void notify(List<URL> urls) {\n                    reference.set(urls);\n                }\n            };\n            // 订阅逻辑保证第一次notify后再返回\n            subscribe(url, listener);\n            List<URL> urls = reference.get();\n            if (urls != null && !urls.isEmpty()) {\n                for (URL u : urls) {\n                    if (!Constants.EMPTY_PROTOCOL.equals(u.getProtocol())) {\n                        result.add(u);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public void register(URL url) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"register url == null\");\n        }\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Register: \" + url);\n        }\n        //保存注册url\n        registered.add(url);\n    }\n\n    @Override\n    public void unregister(URL url) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"unregister url == null\");\n        }\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Unregister: \" + url);\n        }\n        //取消注册url\n        registered.remove(url);\n    }\n\n    @Override\n    public void subscribe(URL url, NotifyListener listener) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"subscribe url == null\");\n        }\n        if (listener == null) {\n            throw new IllegalArgumentException(\"subscribe listener == null\");\n        }\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Subscribe: \" + url);\n        }\n        //保存订阅url\n        Set<NotifyListener> listeners = subscribed.get(url);\n        if (listeners == null) {\n            subscribed.putIfAbsent(url, new ConcurrentHashSet<NotifyListener>());\n            listeners = subscribed.get(url);\n        }\n        listeners.add(listener);\n    }\n\n    @Override\n    public void unsubscribe(URL url, NotifyListener listener) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"unsubscribe url == null\");\n        }\n        if (listener == null) {\n            throw new IllegalArgumentException(\"unsubscribe listener == null\");\n        }\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Unsubscribe: \" + url);\n        }\n        //取消订阅url的listener\n        Set<NotifyListener> listeners = subscribed.get(url);\n        if (listeners != null) {\n            listeners.remove(listener);\n        }\n    }\n\n    /**\n     * 恢复注册和订阅\n     * @throws Exception\n     */\n    protected void recover() throws Exception {\n        //获取已注册的地址\n        Set<URL> recoverRegistered = new HashSet<URL>(getRegistered());\n        if (!recoverRegistered.isEmpty()) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Recover register url \" + recoverRegistered);\n            }\n            for (URL url : recoverRegistered) {\n                //重新注册url\n                register(url);\n            }\n        }\n        //获取已订阅的记录\n        Map<URL, Set<NotifyListener>> recoverSubscribed = new HashMap<URL, Set<NotifyListener>>(getSubscribed());\n        if (!recoverSubscribed.isEmpty()) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Recover subscribe url \" + recoverSubscribed.keySet());\n            }\n            for (Map.Entry<URL, Set<NotifyListener>> entry : recoverSubscribed.entrySet()) {\n                URL url = entry.getKey();\n                for (NotifyListener listener : entry.getValue()) {\n                    //重新订阅\n                    subscribe(url, listener);\n                }\n            }\n        }\n    }\n\n    /**\n     * 通知\n     * @param urls 注册中心url\n     */\n    protected void notify(List<URL> urls) {\n        if (urls == null || urls.isEmpty()) {\n            return;\n        }\n        //遍历已订阅的记录（例如服务暴露时那里会订阅事件）\n        for (Map.Entry<URL, Set<NotifyListener>> entry : getSubscribed().entrySet()) {\n            //订阅url\n            URL url = entry.getKey();\n            //检测是否匹配\n            if (!UrlUtils.isMatch(url, urls.get(0))) {\n                continue;\n            }\n            Set<NotifyListener> listeners = entry.getValue();\n            if (listeners != null) {\n                for (NotifyListener listener : listeners) {\n                    try {\n                        //通知注册中心\n                        notify(url, listener, filterEmpty(url, urls));\n                    } catch (Throwable t) {\n                        logger.error(\"Failed to notify registry event, urls: \" + urls + \", cause: \" + t.getMessage(), t);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param url 订阅url\n     * provider://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&category=configurators&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=7444&side=provider&timestamp=1528870218728\n     * @param listener\n     * @param urls 待通知的urls\n     */\n    protected void notify(URL url, NotifyListener listener, List<URL> urls) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"notify url == null\");\n        }\n        if (listener == null) {\n            throw new IllegalArgumentException(\"notify listener == null\");\n        }\n        if ((urls == null || urls.isEmpty()) && !Constants.ANY_VALUE.equals(url.getServiceInterface())) {\n            logger.warn(\"Ignore empty notify urls for subscribe url \" + url);\n            return;\n        }\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Notify urls for subscribe url \" + url + \", urls: \" + urls);\n        }\n        //<category,List<URL>>\n        Map<String, List<URL>> result = new HashMap<String, List<URL>>();\n        //遍历待通知urls，根据url中的category参数进行分组，保存到result中\n        for (URL u : urls) {\n            //url和u是否匹配(url的范围是否比u大)\n            if (UrlUtils.isMatch(url, u)) {\n                //获取待通知url的category，默认值是providers\n                String category = u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);\n                List<URL> categoryList = result.get(category);\n                if (categoryList == null) {\n                    categoryList = new ArrayList<URL>();\n                    result.put(category, categoryList);\n                }\n                categoryList.add(u);\n            }\n        }\n        if (result.size() == 0) {\n            //类别待通知url列表为空，直接返回\n            return;\n        }\n        //下面会将notified中的url及其values.values中的URL保存到缓存文件中\n        Map<String, List<URL>> categoryNotified = notified.get(url);\n        if (categoryNotified == null) {\n            notified.putIfAbsent(url, new ConcurrentHashMap<String, List<URL>>());\n            categoryNotified = notified.get(url);\n        }\n        for (Map.Entry<String, List<URL>> entry : result.entrySet()) {\n            //类别\n            String category = entry.getKey();\n            //类别待通知url列表\n            List<URL> categoryList = entry.getValue();\n            //保存<类别,类别待通知url列表>\n            categoryNotified.put(category, categoryList);\n            //保存注册中心缓存文件(将订阅url、待通知url列表保存到缓存文件)\n            saveProperties(url);\n            //触发通知(类别待通知url列表)\n            listener.notify(categoryList);\n        }\n    }\n\n    /**\n     * 保存注册中心缓存文件\n     * @param url 订阅url\n     */\n    private void saveProperties(URL url) {\n        if (file == null) {\n            return;\n        }\n        try {\n            //保存待通知url\n            StringBuilder buf = new StringBuilder();\n            //根据订阅url获取类别map\n            Map<String, List<URL>> categoryNotified = notified.get(url);\n            if (categoryNotified != null) {\n                //遍历类别待通知url列表\n                for (List<URL> us : categoryNotified.values()) {\n                    for (URL u : us) {\n                        //将待通知url添加到buf中，多个地址使用空格分隔\n                        if (buf.length() > 0) {\n                            buf.append(URL_SEPARATOR);\n                        }\n                        buf.append(u.toFullString());\n                    }\n                }\n            }\n            //保存配置到properties文件<订阅url的服务唯一名称标识,类别待通知url列表>\n            properties.setProperty(url.getServiceKey(), buf.toString());\n            //获取版本号\n            long version = lastCacheChanged.incrementAndGet();\n            if (syncSaveFile) {\n                //同步保存缓存文件\n                doSaveProperties(version);\n            } else {\n                //异步保存缓存文件\n                registryCacheExecutor.execute(new SaveProperties(version));\n            }\n        } catch (Throwable t) {\n            logger.warn(t.getMessage(), t);\n        }\n    }\n\n    @Override\n    public void destroy() {\n        if (logger.isInfoEnabled()) {\n            //销毁注册中心\n            logger.info(\"Destroy registry:\" + getUrl());\n        }\n        Set<URL> destroyRegistered = new HashSet<URL>(getRegistered());\n        if (!destroyRegistered.isEmpty()) {\n            //遍历已注册的url\n            for (URL url : new HashSet<URL>(getRegistered())) {\n                if (url.getParameter(Constants.DYNAMIC_KEY, true)) {\n                    try {\n                        //url的dynamic = true，取消注册url\n                        unregister(url);\n                        if (logger.isInfoEnabled()) {\n                            logger.info(\"Destroy unregister url \" + url);\n                        }\n                    } catch (Throwable t) {\n                        logger.warn(\"Failed to unregister url \" + url + \" to registry \" + getUrl() + \" on destroy, cause: \" + t.getMessage(), t);\n                    }\n                }\n            }\n        }\n        Map<URL, Set<NotifyListener>> destroySubscribed = new HashMap<URL, Set<NotifyListener>>(getSubscribed());\n        if (!destroySubscribed.isEmpty()) {\n            //遍历已订阅的，挨个取消订阅\n            for (Map.Entry<URL, Set<NotifyListener>> entry : destroySubscribed.entrySet()) {\n                //订阅的url\n                URL url = entry.getKey();\n                for (NotifyListener listener : entry.getValue()) {\n                    try {\n                        //取消订阅url\n                        unsubscribe(url, listener);\n                        if (logger.isInfoEnabled()) {\n                            logger.info(\"Destroy unsubscribe url \" + url);\n                        }\n                    } catch (Throwable t) {\n                        logger.warn(\"Failed to unsubscribe url \" + url + \" to registry \" + getUrl() + \" on destroy, cause: \" + t.getMessage(), t);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getUrl().toString();\n    }\n\n    /**\n     * 异步保存缓存文件的线程\n     */\n    private class SaveProperties implements Runnable {\n        private long version;\n        private SaveProperties(long version) {\n            this.version = version;\n        }\n        @Override\n        public void run() {\n            doSaveProperties(version);\n        }\n    }\n}\n```\n\n### FailbackRegistry抽象类\nFailbackRegistry抽象类增加了失败重试功能，MulticastRegistry、ZookeeperRegistry等都继承自它.\n```java\npublic abstract class FailbackRegistry extends AbstractRegistry {\n\n    /**\n     * 注册中心失败重试线程\n     */\n    private final ScheduledExecutorService retryExecutor =\n            Executors.newScheduledThreadPool(1,\n                    new NamedThreadFactory(\"DubboRegistryFailedRetryTimer\", true));\n\n    /**\n     * 用于失败重试的定时器，定期检查是有失败的请求，如果有，则无限重试\n     */\n    private final ScheduledFuture<?> retryFuture;\n\n    /**\n     * 注册失败的URL列表\n     */\n    private final Set<URL> failedRegistered = new ConcurrentHashSet<URL>();\n\n    /**\n     * 取消注册失败的URL列表\n     */\n    private final Set<URL> failedUnregistered = new ConcurrentHashSet<URL>();\n\n    /**\n     * 订阅失败的记录\n     * <订阅url，监听>\n     */\n    private final ConcurrentMap<URL, Set<NotifyListener>> failedSubscribed = new ConcurrentHashMap<URL, Set<NotifyListener>>();\n\n    /**\n     * 取消订阅失败的记录\n     * <订阅url，监听>\n     */\n    private final ConcurrentMap<URL, Set<NotifyListener>> failedUnsubscribed = new ConcurrentHashMap<URL, Set<NotifyListener>>();\n\n    /**\n     * 通知失败的URL\n     */\n    private final ConcurrentMap<URL, Map<NotifyListener, List<URL>>> failedNotified = new ConcurrentHashMap<URL, Map<NotifyListener, List<URL>>>();\n\n    public FailbackRegistry(URL url) {\n        //设置注册中心url\n        super(url);\n        //获取url对应的重试间隔时间，默认值是5秒\n        int retryPeriod = url.getParameter(Constants.REGISTRY_RETRY_PERIOD_KEY, Constants.DEFAULT_REGISTRY_RETRY_PERIOD);\n        this.retryFuture = retryExecutor.scheduleWithFixedDelay(new Runnable() {\n            @Override\n            public void run() {\n                //检测并连接到注册中心\n                try {\n\t\t    //执行重试\n                    retry();\n                } catch (Throwable t) {\n                    logger.error(\"Unexpected error occur at failed retry, cause: \" + t.getMessage(), t);\n                }\n            }\n        }, retryPeriod, retryPeriod, TimeUnit.MILLISECONDS);\n    }\n\n    public Future<?> getRetryFuture() {\n        return retryFuture;\n    }\n\n    public Set<URL> getFailedRegistered() {\n        return failedRegistered;\n    }\n\n    public Set<URL> getFailedUnregistered() {\n        return failedUnregistered;\n    }\n\n    public Map<URL, Set<NotifyListener>> getFailedSubscribed() {\n        return failedSubscribed;\n    }\n\n    public Map<URL, Set<NotifyListener>> getFailedUnsubscribed() {\n        return failedUnsubscribed;\n    }\n\n    public Map<URL, Map<NotifyListener, List<URL>>> getFailedNotified() {\n        return failedNotified;\n    }\n\n    /**\n     * 添加订阅失败的记录\n     * @param url 订阅url\n     * @param listener\n     */\n    private void addFailedSubscribed(URL url, NotifyListener listener) {\n        Set<NotifyListener> listeners = failedSubscribed.get(url);\n        if (listeners == null) {\n            failedSubscribed.putIfAbsent(url, new ConcurrentHashSet<NotifyListener>());\n            listeners = failedSubscribed.get(url);\n        }\n        listeners.add(listener);\n    }\n\n    /**\n     * 移除订阅失败的记录（从三个列表中都移除）\n     * @param url 订阅url\n     * @param listener\n     */\n    private void removeFailedSubscribed(URL url, NotifyListener listener) {\n        //订阅失败的记录\n        Set<NotifyListener> listeners = failedSubscribed.get(url);\n        if (listeners != null) {\n            listeners.remove(listener);\n        }\n        //取消订阅失败的记录\n        listeners = failedUnsubscribed.get(url);\n        if (listeners != null) {\n            listeners.remove(listener);\n        }\n        //通知失败的记录\n        Map<NotifyListener, List<URL>> notified = failedNotified.get(url);\n        if (notified != null) {\n            notified.remove(listener);\n        }\n    }\n\n    @Override\n    public void register(URL url) {\n        //保存url到集合缓存中\n        super.register(url);\n        //从已失败的记录中移除该url\n        failedRegistered.remove(url);\n        failedUnregistered.remove(url);\n        try {\n            //向服务端发送注册请求\n            doRegister(url);\n        } catch (Exception e) {\n            Throwable t = e;\n\n            //注册中心url以及服务提供者url中的check = true且url不是消费端\n            boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)\n                    && url.getParameter(Constants.CHECK_KEY, true)\n                    && !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());\n            //判断是否需要跳过故障恢复(SkipFailbackWrapperException异常只是作为标记)\n            boolean skipFailback = t instanceof SkipFailbackWrapperException;\n            if (check || skipFailback) {\n                //如果启动检测或者跳过故障恢复的话，则直接抛出异常\n                if (skipFailback) {\n                    t = t.getCause();\n                }\n                //注册url到注册中心发生失败\n                throw new IllegalStateException(\"Failed to register \" + url + \" to registry \" + getUrl().getAddress() + \", cause: \" + t.getMessage(), t);\n            } else {\n                logger.error(\"Failed to register \" + url + \", waiting for retry, cause: \" + t.getMessage(), t);\n            }\n            //注册失败的话，将url保存到注册失败列表中，定期重试\n            failedRegistered.add(url);\n        }\n    }\n\n    @Override\n    public void unregister(URL url) {\n        //从缓存集合中移除该url\n        super.unregister(url);\n        //从失败列表中移除该url\n        failedRegistered.remove(url);\n        failedUnregistered.remove(url);\n        try {\n            //向服务端发送取消注册请求\n            doUnregister(url);\n        } catch (Exception e) {\n            Throwable t = e;\n            //判断是否启动检测\n            boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)\n                    && url.getParameter(Constants.CHECK_KEY, true)\n                    //非消费者\n                    && !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());\n            //是否跳过故障恢复\n            boolean skipFailback = t instanceof SkipFailbackWrapperException;\n            if (check || skipFailback) {\n                if (skipFailback) {\n                    t = t.getCause();\n                }\n                //直接抛出异常\n                throw new IllegalStateException(\"Failed to unregister \" + url + \" to registry \" + getUrl().getAddress() + \", cause: \" + t.getMessage(), t);\n            } else {\n                //取消注册url执行失败，等待重试\n                logger.error(\"Failed to unregister \" + url + \", waiting for retry, cause: \" + t.getMessage(), t);\n            }\n            //将失败的url保存到失败列表，等待定期重试\n            failedUnregistered.add(url);\n        }\n    }\n\n    @Override\n    public void subscribe(URL url, NotifyListener listener) {\n        //将订阅保存到集合缓存\n        super.subscribe(url, listener);\n        //从失败列表中移除该订阅记录\n        removeFailedSubscribed(url, listener);\n        try {\n            //向服务端发送订阅请求\n            doSubscribe(url, listener);\n        } catch (Exception e) {\n            Throwable t = e;\n            //订阅失败的话，则从缓存文件中获取该订阅url对应的注册中心url列表(即类别待通知url列表)\n            List<URL> urls = getCacheUrls(url);\n            if (urls != null && !urls.isEmpty()) {\n                //触发通知\n                notify(url, listener, urls);\n                //订阅失败，将使用缓存列表\n                logger.error(\"Failed to subscribe \" + url + \", Using cached list: \" + urls + \" from cache file: \" + getUrl().getParameter(Constants.FILE_KEY, System.getProperty(\"user.home\") + \"/dubbo-registry-\" + url.getHost() + \".cache\") + \", cause: \" + t.getMessage(), t);\n            } else {\n                //是否启动检测\n                boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)\n                        && url.getParameter(Constants.CHECK_KEY, true);\n                //是否跳过故障恢复\n                boolean skipFailback = t instanceof SkipFailbackWrapperException;\n                if (check || skipFailback) {\n                    if (skipFailback) {\n                        t = t.getCause();\n                    }\n                    throw new IllegalStateException(\"Failed to subscribe \" + url + \", cause: \" + t.getMessage(), t);\n                } else {\n                    //订阅失败，等待重试\n                    logger.error(\"Failed to subscribe \" + url + \", waiting for retry, cause: \" + t.getMessage(), t);\n                }\n            }\n            //添加到订阅失败列表，请求重试\n            addFailedSubscribed(url, listener);\n        }\n    }\n\n    @Override\n    public void unsubscribe(URL url, NotifyListener listener) {\n        //将订阅从集合缓存中移除\n        super.unsubscribe(url, listener);\n        //从失败列表中移除订阅\n        removeFailedSubscribed(url, listener);\n        try {\n            //向服务端发送取消订阅请求\n            doUnsubscribe(url, listener);\n        } catch (Exception e) {\n            Throwable t = e;\n            //是否启动检测\n            boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)\n                    && url.getParameter(Constants.CHECK_KEY, true);\n            //是否跳过故障恢复\n            boolean skipFailback = t instanceof SkipFailbackWrapperException;\n            if (check || skipFailback) {\n                if (skipFailback) {\n                    t = t.getCause();\n                }\n                throw new IllegalStateException(\"Failed to unsubscribe \" + url + \" to registry \" + getUrl().getAddress() + \", cause: \" + t.getMessage(), t);\n            } else {\n                //取消订阅失败，等待重试\n                logger.error(\"Failed to unsubscribe \" + url + \", waiting for retry, cause: \" + t.getMessage(), t);\n            }\n            //添加到失败列表中，定期重试\n            Set<NotifyListener> listeners = failedUnsubscribed.get(url);\n            if (listeners == null) {\n                failedUnsubscribed.putIfAbsent(url, new ConcurrentHashSet<NotifyListener>());\n                listeners = failedUnsubscribed.get(url);\n            }\n            listeners.add(listener);\n        }\n    }\n\n    @Override\n    protected void notify(URL url, NotifyListener listener, List<URL> urls) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"notify url == null\");\n        }\n        if (listener == null) {\n            throw new IllegalArgumentException(\"notify listener == null\");\n        }\n        try {\n            //执行通知(调用父类中的notify方法)\n            doNotify(url, listener, urls);\n        } catch (Exception t) {\n            //通知失败，添加到失败列表，定期重试\n            Map<NotifyListener, List<URL>> listeners = failedNotified.get(url);\n            if (listeners == null) {\n                failedNotified.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, List<URL>>());\n                listeners = failedNotified.get(url);\n            }\n            listeners.put(listener, urls);\n            logger.error(\"Failed to notify for subscribe \" + url + \", waiting for retry, cause: \" + t.getMessage(), t);\n        }\n    }\n\n    protected void doNotify(URL url, NotifyListener listener, List<URL> urls) {\n        super.notify(url, listener, urls);\n    }\n\n    @Override\n    protected void recover() throws Exception {\n        //获取已注册列表\n        Set<URL> recoverRegistered = new HashSet<URL>(getRegistered());\n        if (!recoverRegistered.isEmpty()) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Recover register url \" + recoverRegistered);\n            }\n            //将已注册的添加到失败列表中，等待恢复\n            for (URL url : recoverRegistered) {\n                failedRegistered.add(url);\n            }\n        }\n        //获取已订阅的列表\n        Map<URL, Set<NotifyListener>> recoverSubscribed = new HashMap<URL, Set<NotifyListener>>(getSubscribed());\n        if (!recoverSubscribed.isEmpty()) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Recover subscribe url \" + recoverSubscribed.keySet());\n            }\n            for (Map.Entry<URL, Set<NotifyListener>> entry : recoverSubscribed.entrySet()) {\n                URL url = entry.getKey();\n                for (NotifyListener listener : entry.getValue()) {\n                    //将已订阅的添加到失败列表中，等待恢复\n                    addFailedSubscribed(url, listener);\n                }\n            }\n        }\n    }\n\n    /**\n     * 重试 之前操作失败的 记录\n     */\n    protected void retry() {\n        if (!failedRegistered.isEmpty()) {\n            //处理注册失败的数据(重新注册)\n            Set<URL> failed = new HashSet<URL>(failedRegistered);\n            if (failed.size() > 0) {\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"Retry register \" + failed);\n                }\n                try {\n                    for (URL url : failed) {\n                        try {\n                            //重试注册\n                            doRegister(url);\n                            //重新注册成功，则将其从失败列表中移除\n                            failedRegistered.remove(url);\n                        } catch (Throwable t) {\n                            // Ignore all the exceptions and wait for the next retry\n                            //忽略所有的异常，等待下次重试\n                            logger.warn(\"Failed to retry register \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                        }\n                    }\n                } catch (Throwable t) {\n                    logger.warn(\"Failed to retry register \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n        if (!failedUnregistered.isEmpty()) {\n            //处理取消注册失败的数据(重新执行取消注册)\n            Set<URL> failed = new HashSet<URL>(failedUnregistered);\n            if (!failed.isEmpty()) {\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"Retry unregister \" + failed);\n                }\n                try {\n                    for (URL url : failed) {\n                        try {\n                            //重试取消注册\n                            doUnregister(url);\n                            //重试成功，则从失败列表中移除出去\n                            failedUnregistered.remove(url);\n                        } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\n                            logger.warn(\"Failed to retry unregister  \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                        }\n                    }\n                } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\n                    logger.warn(\"Failed to retry unregister  \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n        if (!failedSubscribed.isEmpty()) {\n            //处理订阅失败的数据\n            Map<URL, Set<NotifyListener>> failed = new HashMap<URL, Set<NotifyListener>>(failedSubscribed);\n            for (Map.Entry<URL, Set<NotifyListener>> entry : new HashMap<URL, Set<NotifyListener>>(failed).entrySet()) {\n                if (entry.getValue() == null || entry.getValue().size() == 0) {\n                    //将待通知url列表为空的数据移除出去\n                    failed.remove(entry.getKey());\n                }\n            }\n            if (failed.size() > 0) {\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"Retry subscribe \" + failed);\n                }\n                try {\n                    for (Map.Entry<URL, Set<NotifyListener>> entry : failed.entrySet()) {\n                        URL url = entry.getKey();\n                        Set<NotifyListener> listeners = entry.getValue();\n                        for (NotifyListener listener : listeners) {\n                            try {\n                                //重试订阅\n                                doSubscribe(url, listener);\n                                //订阅成功，从失败列表中移除出去\n                                listeners.remove(listener);\n                            } catch (Throwable t) {\n                                logger.warn(\"Failed to retry subscribe \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                            }\n                        }\n                    }\n                } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\n                    logger.warn(\"Failed to retry subscribe \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n        if (!failedUnsubscribed.isEmpty()) {\n            //处理取消订阅失败的数据\n            Map<URL, Set<NotifyListener>> failed = new HashMap<URL, Set<NotifyListener>>(failedUnsubscribed);\n            for (Map.Entry<URL, Set<NotifyListener>> entry : new HashMap<URL, Set<NotifyListener>>(failed).entrySet()) {\n                if (entry.getValue() == null || entry.getValue().isEmpty()) {\n                    //将待通知url列表为空的数据移除出去\n                    failed.remove(entry.getKey());\n                }\n            }\n            if (failed.size() > 0) {\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"Retry unsubscribe \" + failed);\n                }\n                try {\n                    for (Map.Entry<URL, Set<NotifyListener>> entry : failed.entrySet()) {\n                        URL url = entry.getKey();\n                        Set<NotifyListener> listeners = entry.getValue();\n                        for (NotifyListener listener : listeners) {\n                            try {\n                                //重试取消订阅\n                                doUnsubscribe(url, listener);\n                                //重试成功，从失败列表中移除\n                                listeners.remove(listener);\n                            } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\n                                logger.warn(\"Failed to retry unsubscribe \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                            }\n                        }\n                    }\n                } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\n                    logger.warn(\"Failed to retry unsubscribe \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n        if (!failedNotified.isEmpty()) {\n            //处理通知失败的数据\n            Map<URL, Map<NotifyListener, List<URL>>> failed = new HashMap<URL, Map<NotifyListener, List<URL>>>(failedNotified);\n            for (Map.Entry<URL, Map<NotifyListener, List<URL>>> entry : new HashMap<URL, Map<NotifyListener, List<URL>>>(failed).entrySet()) {\n                if (entry.getValue() == null || entry.getValue().size() == 0) {\n                    failed.remove(entry.getKey());\n                }\n            }\n            if (failed.size() > 0) {\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"Retry notify \" + failed);\n                }\n                try {\n                    for (Map<NotifyListener, List<URL>> values : failed.values()) {\n                        for (Map.Entry<NotifyListener, List<URL>> entry : values.entrySet()) {\n                            try {\n                                NotifyListener listener = entry.getKey();\n                                List<URL> urls = entry.getValue();\n                                //重试通知\n                                listener.notify(urls);\n                                //重试成功，从失败列表中移除\n                                values.remove(listener);\n                            } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\n                                logger.warn(\"Failed to retry notify \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                            }\n                        }\n                    }\n                } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\n                    logger.warn(\"Failed to retry notify \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void destroy() {\n        //调用父类的销毁逻辑,取消注册等\n        super.destroy();\n        try {\n            //停止定时重试线程\n            retryFuture.cancel(true);\n        } catch (Throwable t) {\n            logger.warn(t.getMessage(), t);\n        }\n    }\n\n    // ==== Template method ====\n\n    /**\n     * 注册\n     * @param url\n     */\n    protected abstract void doRegister(URL url);\n\n    /**\n     * 取消注册\n     * @param url\n     */\n    protected abstract void doUnregister(URL url);\n\n    /**\n     * 订阅\n     * @param url\n     * @param listener\n     */\n    protected abstract void doSubscribe(URL url, NotifyListener listener);\n\n    /**\n     * 取消订阅\n     * @param url\n     * @param listener\n     */\n    protected abstract void doUnsubscribe(URL url, NotifyListener listener);\n}\n```\n\n#### DubboRegistry类\n```java\npublic class DubboRegistry extends FailbackRegistry {\n\n    private final static Logger logger = LoggerFactory.getLogger(DubboRegistry.class);\n\n    /**\n     * 重新连接检测周期：3秒\n     */\n    private static final int RECONNECT_PERIOD_DEFAULT = 3 * 1000;\n\n    /**\n     * 重新连接定时线程\n     */\n    private final ScheduledExecutorService scheduledExecutorService =\n            Executors.newScheduledThreadPool(1, new NamedThreadFactory(\"DubboRegistryReconnectTimer\", true));\n\n    /**\n     * 重新连接定时器，定期检查连接是否可用，如果不可用，无限重连\n     */\n    private final ScheduledFuture<?> reconnectFuture;\n\n    /**\n     * 客户端获取处理的锁\n     * 锁定客户端实例的创建过程，防止重复客户端\n     */\n    private final ReentrantLock clientLock = new ReentrantLock();\n\n    private final Invoker<RegistryService> registryInvoker;\n    \n    /**\n     * 注册中心\n     */\n    private final RegistryService registryService;\n\n    public DubboRegistry(Invoker<RegistryService> registryInvoker, RegistryService registryService) {\n        //设置注册中心url（registryInvoker.getUrl()）\n        super(registryInvoker.getUrl());\n        this.registryInvoker = registryInvoker;\n        this.registryService = registryService;\n        // 启动重连线程\n        int reconnectPeriod = registryInvoker.getUrl()\n                .getParameter(Constants.REGISTRY_RECONNECT_PERIOD_KEY, RECONNECT_PERIOD_DEFAULT);\n        reconnectFuture = scheduledExecutorService.scheduleWithFixedDelay(new Runnable() {\n            @Override\n            public void run() {\n                //检测并连接到注册中心\n                try {\n                    connect();\n                } catch (Throwable t) { \n                    logger.error(\"Unexpected error occur at reconnect, cause: \" + t.getMessage(), t);\n                }\n            }\n        }, reconnectPeriod, reconnectPeriod, TimeUnit.MILLISECONDS);\n    }\n    \n    /**\n     * 连接到注册中心\n     */\n    protected final void connect() {\n        try {\n            //检测是否是已连接的\n            if (isAvailable()) {\n                return;\n            }\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Reconnect to registry \" + getUrl());\n            }\n            //连接前先上锁\n            clientLock.lock();\n            try {\n                // Double check whether or not it is connected\n                //再次检测是否已连接\n                if (isAvailable()) {\n                    return;\n                }\n                //执行恢复\n                recover();\n            } finally {\n                //释放锁\n                clientLock.unlock();\n            }\n        } catch (Throwable t) {\n            // 如果设置了check = true，则直接抛异常，否则忽略异常，等待下次重试\n            if (getUrl().getParameter(Constants.CHECK_KEY, true)) {\n                if (t instanceof RuntimeException) {\n                    throw (RuntimeException) t;\n                }\n                throw new RuntimeException(t.getMessage(), t);\n            }\n            logger.error(\"Failed to connect to registry \" + getUrl().getAddress() + \" from provider/consumer \" + NetUtils.getLocalHost() + \" use dubbo \" + Version.getVersion() + \", cause: \" + t.getMessage(), t);\n        }\n    }\n\n    @Override\n    public boolean isAvailable() {\n        //registryInvoker为空的话说明不可用，直接返回\n        if (registryInvoker == null) {\n            return false;\n        }\n        return registryInvoker.isAvailable();\n    }\n\n    @Override\n    public void destroy() {\n        super.destroy();\n        try {\n            if (!reconnectFuture.isCancelled()) {\n                //取消重连定时器\n                reconnectFuture.cancel(true);\n            }\n        } catch (Throwable t) {\n            logger.warn(\"Failed to cancel reconnect timer\", t);\n        }\n        //销毁registryInvoker\n        registryInvoker.destroy();\n    }\n\n    @Override\n    protected void doRegister(URL url) {\n        //交由registryService来完成\n        registryService.register(url);\n    }\n\n    @Override\n    protected void doUnregister(URL url) {\n        registryService.unregister(url);\n    }\n\n    @Override\n    protected void doSubscribe(URL url, NotifyListener listener) {\n        registryService.subscribe(url, listener);\n    }\n\n    @Override\n    protected void doUnsubscribe(URL url, NotifyListener listener) {\n        registryService.unsubscribe(url, listener);\n    }\n\n    @Override\n    public List<URL> lookup(URL url) {\n        return registryService.lookup(url);\n    }\n}\n```\nFailbackRegistry的注册中心实现类，如ZookeeperRegistry类等，将会在单独的小节进行详细讲解，这里就先不介绍了。\n\n### RegistryFactory接口\n```java\n@SPI(\"dubbo\")\npublic interface RegistryFactory {\n    /**\n     * 根据url获取注册中心实例\n     *\n     * 1、当设置check=false时，链接不会检测，除此之外当断开连接时将会抛异常\n     * 2、支持URL上的username:password授权认证\n     * 3、支持backup=10.20.153.10配置候选注册中心集群地址\n     * 4、支持file=registry.cache本地磁盘文件缓存\n     * 5、支持timeout=1000请求超时配置\n     * 6、支持session=60000配置session超时或者到期设置\n     * @param url 注册中心地址，不允许为空\n     * @return 注册中心引用，永不返回空值\n     */\n    @Adaptive({\"protocol\"})\n    Registry getRegistry(URL url);\n}\n```\n#### AbstractRegistryFactory抽象类\n```java\npublic abstract class AbstractRegistryFactory implements RegistryFactory {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractRegistryFactory.class);\n\n    /**\n     * 用来锁定获取注册中心实例时的过程\n     */\n    private static final ReentrantLock LOCK = new ReentrantLock();\n\n    /**\n     * 注册中心集合\n     * Map<RegistryAddress, Registry>\n     * key = multicast://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService\n     */\n    private static final Map<String, Registry> REGISTRIES = new ConcurrentHashMap<String, Registry>();\n\n    /**\n     * 获取所有注册中心\n     * @return all registries\n     */\n    public static Collection<Registry> getRegistries() {\n        return Collections.unmodifiableCollection(REGISTRIES.values());\n    }\n\n    /**\n     * 关闭所有创建的注册中心\n     */\n    public static void destroyAll() {\n        //锁定注册中心关闭过程\n        LOCK.lock();\n        try {\n            for (Registry registry : getRegistries()) {\n                try {\n                    //调用destroy()方法进行销毁\n                    registry.destroy();\n                } catch (Throwable e) {\n                    LOGGER.error(e.getMessage(), e);\n                }\n            }\n            //清理缓存\n            REGISTRIES.clear();\n        } finally {\n            //释放锁\n            LOCK.unlock();\n        }\n    }\n\n    @Override\n    public Registry getRegistry(URL url) {\n        //设置path属性\n        url = url.setPath(RegistryService.class.getName())\n                //添加interface = com.alibaba.dubbo.registry.RegistryService\n                .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName())\n                //移除export、refer参数\n                .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY);\n        //key = multicast://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService\n        String key = url.toServiceString();\n        // Lock the registry access process to ensure a single instance of the registry\n        //加锁,确保该key对应的注册中心为单例\n        LOCK.lock();\n        try {\n            Registry registry = REGISTRIES.get(key);\n            if (registry != null) {\n                //缓存中存在，直接返回\n                return registry;\n            }\n            //根据url创建注册中心实例，这里由子类来实现\n            registry = createRegistry(url);\n            if (registry == null) {\n\t        //创建失败\n                throw new IllegalStateException(\"Can not create registry \" + url);\n            }\n            //放入缓存，并返回\n            REGISTRIES.put(key, registry);\n            return registry;\n        } finally {\n            // 释放锁\n            LOCK.unlock();\n        }\n    }\n\n    /**\n     * 创建注册中心实例\n     * @param url 注册中心url\n     * @return\n     */\n    protected abstract Registry createRegistry(URL url);\n}\n```\nAbstractRegistryFactory的实现类，如ZookeeperRegistryFactory等类，将在相关的小节单独介绍，这里就不多介绍了。\n\n### Directory接口\n接下来我们看看那Directory接口相关的内容\n```java\npublic interface Directory<T> extends Node {\n\n    /**\n     * 获取服务类型\n     */\n    Class<T> getInterface();\n\n    /**\n     * 获取invokers列表\n     */\n    List<Invoker<T>> list(Invocation invocation) throws RpcException;\n}\n```\n\n#### AbstractDirectory抽象类\n```java\npublic abstract class AbstractDirectory<T> implements Directory<T> {\n    \n    /**\n     * 注册中心url\n     */\n    private final URL url;\n\n    /**\n     * Directory是否已销毁\n     */\n    private volatile boolean destroyed = false;\n\n    /**\n     * 消费者url\n     */\n    private volatile URL consumerUrl;\n\n    /**\n     * 路由列表\n     */\n    private volatile List<Router> routers;\n\n    public AbstractDirectory(URL url, URL consumerUrl, List<Router> routers) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"url == null\");\n        }\n        this.url = url;\n        this.consumerUrl = consumerUrl;\n        //设置路由\n        setRouters(routers);\n    }\n\t\n    /**\n     * 从此list方法返回的InvokerList，已经被Routers过滤\n     */\n    @Override\n    public List<Invoker<T>> list(Invocation invocation) throws RpcException {\n        if (destroyed) {\n            throw new RpcException(\"Directory already destroyed .url: \" + getUrl());\n        }\n        //根据invocation获取invokers列表(根据方法名查询缓存methodInvokerMap)\n        List<Invoker<T>> invokers = doList(invocation);\n        List<Router> localRouters = this.routers;\n        if (localRouters != null && !localRouters.isEmpty()) {\n\t    //遍历路由\n            for (Router router : localRouters) {\n                try {\n                    if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) {\n\t\t\t//如果url的runtime配置为true,则每次都会进行route\n\t\t\t//执行路由，进行过滤\n                        invokers = router.route(invokers, getConsumerUrl(), invocation);\n                    }\n                } catch (Throwable t) {\n                    logger.error(\"Failed to execute router: \" + getUrl() + \", cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n        return invokers;\n    }\n\n    /**\n     * 设置路由\n     * 1、添加：收到notify通知的routers、当前url的router参数、new MockInvokersSelector()\n     * 2、将routers排序\n     * 3、缓存routers\n     * @param routers 收到notify通知的routers\n     */\n    protected void setRouters(List<Router> routers) {\n        routers = routers == null ? new ArrayList<Router>() : new ArrayList<Router>(routers);\n        //获取路由工厂扩展名称\n        String routerkey = url.getParameter(Constants.ROUTER_KEY);\n        if (routerkey != null && routerkey.length() > 0) {\n            //根据路由工厂扩展名获取扩展实例\n            RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getExtension(routerkey);\n            //根据url获取路由实例，并放入routers\n            routers.add(routerFactory.getRouter(url));\n        }\n        //添加支持mock协议的invoker选择器\n        routers.add(new MockInvokersSelector());\n        //排序\n        Collections.sort(routers);\n        this.routers = routers;\n    }\n    /**\n     * 根据invocation获取invokers列表\n     * @param invocation\n     * @return\n     * @throws RpcException\n     */\n    protected abstract List<Invoker<T>> doList(Invocation invocation) throws RpcException;\n}\n```\n#### RegistryDirectory实现类\n该实现类，我们在上一小节《Dubbo源码阅读之服务引用》中已经详细介绍过，这里只简单看下剩余的方法\n```java\npublic class RegistryDirectory<T> extends AbstractDirectory<T> implements NotifyListener {\n\n    //缓存 <服务url, Invoker>\n    private volatile Map<String, Invoker<T>> urlInvokerMap;\n\n    //缓存 <服务方法名称,List<Invoker>>\n    private volatile Map<String, List<Invoker<T>>> methodInvokerMap;\n\n    /**\n     * 通过调用方法名从本地缓存中找到invokers\n     * @param invocation\n     * @return\n     */\n    @Override\n    public List<Invoker<T>> doList(Invocation invocation) {\n        if (forbidden) {\n            //1、没有服务提供者。 2、服务提供者被禁用\n            throw new RpcException(RpcException.FORBIDDEN_EXCEPTION,\n                \"No provider available from registry \" + getUrl().getAddress() + \" for service \" + getConsumerUrl().getServiceKey() + \" on consumer \" +  NetUtils.getLocalHost()\n                        + \" use dubbo version \" + Version.getVersion() + \", please check status of providers(disabled, not registered or in blacklist).\");\n        }\n        List<Invoker<T>> invokers = null;\n        Map<String, List<Invoker<T>>> localMethodInvokerMap = this.methodInvokerMap;\n        if (localMethodInvokerMap != null && localMethodInvokerMap.size() > 0) {\n            //获取调用的方法名称\n            String methodName = RpcUtils.getMethodName(invocation);\n            //获取调用的方法参数\n            Object[] args = RpcUtils.getArguments(invocation);\n            if (args != null && args.length > 0 && args[0] != null \n\t\t\t&& (args[0] instanceof String || args[0].getClass().isEnum())) {\n                //第一个参数是字符串类型或者枚举类型\n                //可以根据第一个参数枚举路由\n                invokers = localMethodInvokerMap.get(methodName + \".\" + args[0]);\n            }\n            if (invokers == null) {\n                //通过方法名称查询\n                invokers = localMethodInvokerMap.get(methodName);\n            }\n            if (invokers == null) {\n                //通过*查询\n                invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);\n            }\n            if (invokers == null) {\n                //遍历本地缓存，找到最后一个invokers\n                Iterator<List<Invoker<T>>> iterator = localMethodInvokerMap.values().iterator();\n                if (iterator.hasNext()) {\n                    invokers = iterator.next();\n                }\n            }\n        }\n        return invokers == null ? new ArrayList<Invoker<T>>(0) : invokers;\n    }\n\n    @Override\n    public boolean isAvailable() {\n        if (isDestroyed()) {\n            return false;\n        }\n        Map<String, Invoker<T>> localUrlInvokerMap = urlInvokerMap;\n        if (localUrlInvokerMap != null && localUrlInvokerMap.size() > 0) {\n            for (Invoker<T> invoker : new ArrayList<Invoker<T>>(localUrlInvokerMap.values())) {\n                if (invoker.isAvailable()) {\n                    //本地缓存中的invoker，如果有一个可用，就返回可用\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * 关闭所有的invokers\n     */\n    private void destroyAllInvokers() {\n        Map<String, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap;\n        if (localUrlInvokerMap != null) {\n            for (Invoker<T> invoker : new ArrayList<Invoker<T>>(localUrlInvokerMap.values())) {\n                try {\n\t\t    //销毁invoker\n                    invoker.destroy();\n                } catch (Throwable t) {\n                    logger.warn(\"Failed to destroy service \" + serviceKey + \" to provider \" + invoker.getUrl(), t);\n                }\n            }\n            //清空缓存\n            localUrlInvokerMap.clear();\n        }\n        methodInvokerMap = null;\n    }\n}\n\n````\n#### StaticDirectory实现类\n静态目录服务,它的所有Invoker通过构造函数传入,在服务消费方引用服务的时候,服务对多注册中心进行引用时,将Invokers集合直接传入StaticDirectory构造器,再由Cluster伪装成一个Invoker\n```java\npublic class ReferenceConfig<T> extends AbstractReferenceConfig {\n\n\tprivate T createProxy(Map<String, String> map) {\n\t\t// 省略其他代码.....\n\t\tfor (URL url : urls) {\n\t\t    //记录\"远程引用\"\n\t\t    invokers.add(refprotocol.refer(interfaceClass, url));\n\t\t    if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n\t\t\t// use last registry url\n\t\t\t//使用最后注册的url\n\t\t\tregistryURL = url;\n\t\t    }\n\t\t}\n\t\tif (registryURL != null) {\n\t\t    //有注册中心协议的URL\n\t\t    //使用AvailableCluster\n\t\t    URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);\n\t\t    invoker = cluster.join(new StaticDirectory(u, invokers));\n\t\t} else { \n\t\t    //不是注册中心的url\n\t\t    invoker = cluster.join(new StaticDirectory(invokers));\n\t\t}\n\t}\n}\n```\n来看看实现\n```java\npublic class StaticDirectory<T> extends AbstractDirectory<T> {\n\n    private final List<Invoker<T>> invokers;\n\n    public StaticDirectory(URL url, List<Invoker<T>> invokers, List<Router> routers) {\n        \n\tsuper(url == null && invokers != null && !invokers.isEmpty() ? invokers.get(0).getUrl() : url, routers);\n        \n\tif (invokers == null || invokers.isEmpty()) {\n            throw new IllegalArgumentException(\"invokers == null\");\n        }\n        \n\tthis.invokers = invokers;\n    }\n\n    @Override\n    public Class<T> getInterface() {\n        return invokers.get(0).getInterface();\n    }\n\n    @Override\n    public boolean isAvailable() {\n        if (isDestroyed()) {\n            return false;\n        }\n        for (Invoker<T> invoker : invokers) {\n            //是否可用\n            if (invoker.isAvailable()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public void destroy() {\n        if (isDestroyed()) {\n\t    //已经销毁，直接返回\n            return;\n        }\n        super.destroy();\n        for (Invoker<T> invoker : invokers) {\n            //销毁\n            invoker.destroy();\n        }\n        invokers.clear();\n    }\n\n    @Override\n    protected List<Invoker<T>> doList(Invocation invocation) throws RpcException {\n        //返回构造方法传入的invokers集合\n        return invokers;\n    }\n\n}\n```\n这一小节就先介绍到这里，后面我们详细介绍各个注册中心实现。\n\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之服务暴露","url":"/blog/2018/08/16/Dubbo源码阅读之服务暴露/","content":">本小节详细介绍dubbo服务的暴露，可以先看下之前的文章《Dubbo源码阅读之集成Spring(0201)》\n\n### ServiceConfig类变量\n在ServiceConfig类中定义了如下变量，下文中会用到，我们先简单看下：\n```java\n//代理工厂\nprivate static final ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();\n\n//Protocol实例\nprivate static final Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();\n\n/**\n * dubbo协议服务URL\n * 记录暴露的服务URL\n * dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=192.168.99.60&bind.port=20880&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=4328&qos.port=22222&side=provider&timestamp=1528278313225\n */\nprivate final List<URL> urls = new ArrayList<URL>();\n\n/**\n * 记录暴露的服务端点\n * subscribeUrl = provider://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&category=configurators&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=4328&side=provider&timestamp=1528278313225\n * registerUrl = dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=192.168.99.60&bind.port=20880&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=4328&qos.port=22222&side=provider&timestamp=1528278313225\n */\nprivate final List<Exporter<?>> exporters = new ArrayList<Exporter<?>>();\n```\n\n\n首先我们先来了解下ProxyFactory接口\n\n### ProxyFactory接口\n\n#### getInvoker方法\n\ngetInvoker方法是在ProxyFactory接口中定义的。ProxyFactory接口相关类图如下：\n![](img/ProxyFactory.png)\n\n```java\n/**\n * 代理工厂\n */\n@SPI(\"javassist\")\npublic interface ProxyFactory {\n    /**\n     * 创建代理\n     * @param invoker\n     * @return proxy\n     */\n    @Adaptive({Constants.PROXY_KEY})\n    <T> T getProxy(Invoker<T> invoker) throws RpcException;\n\n    /**\n     * 创建invoker\n     * @param <T>\n     * @param proxy 接口实现类或者代理类\n     * @param type 接口类型\n     * @param url 注册中心url，本地为injvm\n     * @return invoker\n     */\n    @Adaptive({Constants.PROXY_KEY})\n    <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException;\n}\n\n/**\n * 抽象ProxyFactory\n */\npublic abstract class AbstractProxyFactory implements ProxyFactory {\n    @Override\n    public <T> T getProxy(Invoker<T> invoker) throws RpcException {\n        //接口数组\n        Class<?>[] interfaces = null;\n        //获取url的interfaces参数的值\n        String config = invoker.getUrl().getParameter(\"interfaces\");\n        if (config != null && config.length() > 0) {\n            //使用逗号\",\"分隔interfaces参数值\n            String[] types = Constants.COMMA_SPLIT_PATTERN.split(config);\n            if (types != null && types.length > 0) {\n                //这里会将\"远程服务接口类、EchoService类\"放入到接口数组中\n                interfaces = new Class<?>[types.length + 2];\n                interfaces[0] = invoker.getInterface();\n                interfaces[1] = EchoService.class;\n                //然后将\"interfaces参数的值\"放入到接口数组\n                for (int i = 0; i < types.length; i++) {\n                    interfaces[i + 1] = ReflectUtils.forName(types[i]);\n                }\n            }\n        }\n        if (interfaces == null) {\n            //interfaces数组为空的话，则将远程服务接口类、EchoService类放入到接口数组中\n            interfaces = new Class<?>[]{invoker.getInterface(), EchoService.class};\n        }\n        //然后调用子类体实现来获取代理类\n        return getProxy(invoker, interfaces);\n    }\n\n    /**\n     * 获取代理类\n     * @param invoker\n     * @param types  远程服务接口类数组：\n     *               invoker.getInterface()、\n     *               EchoService.class、\n     *               invoker.getUrl().getParameter(\"interfaces\")\n     * @param <T>\n     * @return\n     */\n    public abstract <T> T getProxy(Invoker<T> invoker, Class<?>[] types);\n}\n\n/**\n * jdk动态代理\n */\npublic class JdkProxyFactory extends AbstractProxyFactory {\n\n    @Override\n    public <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {\n        //为interfaces这些接口生成代理类\n        return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),\n                interfaces, new InvokerInvocationHandler(invoker));\n    }\n\n    @Override\n    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {\n\t//返回AbstractProxyInvoker抽象类（该类后面的小节会详细介绍）\n        return new AbstractProxyInvoker<T>(proxy, type, url) {\n\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class<?>[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n\n                //根据方法名称methodName和参数类型parameterTypes获取到指定方法\n                Method method = proxy.getClass().getMethod(methodName, parameterTypes);\n\n                //使用参数arguments调用该代理类的method方法\n                return method.invoke(proxy, arguments);\n            }\n        };\n    }\n}\n\n/**\n * 使用Javassist\n */\npublic class JavassistProxyFactory extends AbstractProxyFactory {\n\n    @Override\n    public <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {\n        //为interfaces这些接口生成代理类(后面会分析Proxy类，这是dubbo自己定义的类)\n        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));\n    }\n\n    @Override\n    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {\n        \n\t// TODO Wrapper类不能正确处理带$的类名\n        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);\n        \n\t//返回AbstractProxyInvoker抽象类（该类后面的小节会详细介绍）\n        return new AbstractProxyInvoker<T>(proxy, type, url) {\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class<?>[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n\n                //使用Wrapper包装类类调用远程服务方法\n                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);\n            }\n        };\n    }\n}\n```\n在JavassistProxyFactory类的getInvoker方法实现中，会为相应的接口类(例如：com.alibaba.dubbo.demo.DemoService)生成包装类，生成的逻辑会在单独的小节介绍，这里只简单看下大概生成的类。\n#### Wrapper包装类\n```java\npublic class com.alibaba.dubbo.common.bytecode.Wrapper0 extends Wrapper{\n\tpublic Wrapper0(){}\n\t//属性名称数组\n\tpublic static String[] pns;\n\n\t//<属性名称，属性类型>\n\tpublic static java.util.Map pts;\n\t\n\t//所有方法名称数组\n\tpublic static String[] mns;\n\t\n\t//已声明的方法名称数组\n\tpublic static String[] dmns;\n\t\n\t//针对每个方法都会定义一个mts数组变量\n\tpublic static Class[] mts0;\n\n\tpublic String[] getPropertyNames(){ \n\t\treturn pns; \n\t}\n\tpublic boolean hasProperty(String n){\n\t\treturn pts.containsKey($1); \n\t}\n\tpublic Class getPropertyType(String n){ \n\t\treturn (Class)pts.get($1); \n\t}\n\tpublic String[] getMethodNames(){ \n\t\treturn mns; \n\t}\n\tpublic String[] getDeclaredMethodNames(){ \n\t\treturn dmns; \n\t}\n\tpublic void setPropertyValue(Object o, String n, Object v){ \n\t\tcom.alibaba.dubbo.demo.DemoService w; \n\t\ttry{ \n\t\t\tw = ((com.alibaba.dubbo.demo.DemoService)$1); \n\t\t}catch(Throwable e){ \n\t\t\tthrow new IllegalArgumentException(e); \n\t\t} \n\t\tthrow new com.alibaba.dubbo.common.bytecode.NoSuchPropertyException(\"Not found property \\\"\"+$2+\"\\\" filed or setter method in class com.alibaba.dubbo.demo.DemoService.\"); \n\t}\n\tpublic Object getPropertyValue(Object o, String n){ \n\t\tcom.alibaba.dubbo.demo.DemoService w; \n\t\ttry{ \n\t\t\tw = ((com.alibaba.dubbo.demo.DemoService)$1); \n\t\t}catch(Throwable e){ \n\t\t\tthrow new IllegalArgumentException(e); \n\t\t} \n\t\tthrow new com.alibaba.dubbo.common.bytecode.NoSuchPropertyException(\"Not found property \\\"\"+$2+\"\\\" filed or setter method in class com.alibaba.dubbo.demo.DemoService.\"); \n\t}\n\t/**\n\t * 执行服务接口的方法\n\t * $1/$2/$3/$4分别对应相应下标的参数\n\t * @param o 服务接口实例\n\t * @param n 服务接口方法名\n\t * @param p 服务接口方法参数\n\t * @param v 服务接口方法参数值\n\t * @return 服务接口调用返回值\n\t */\n\tpublic Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws java.lang.reflect.InvocationTargetException{\n\t\tcom.alibaba.dubbo.demo.DemoService w; \n\t\ttry{ \n\t\t\tw = ((com.alibaba.dubbo.demo.DemoService)$1); \n\t\t}catch(Throwable e){ \n\t\t\tthrow new IllegalArgumentException(e); \n\t\t} \n\t\ttry{ \n\t\t\t//方法名称为sayHello 并且 只有一个参数\n\t\t\tif(\"sayHello\".equals($2) && $3.length == 1){  \n\t\t\t\t//调用接口方法sayHello\n\t\t\t\treturn ($w)w.sayHello((java.lang.String)$4[0]);\n\t\t\t} \n\t\t} catch(Throwable e) {      \n\t\t\tthrow new java.lang.reflect.InvocationTargetException(e);  \n\t\t} \n\t\tthrow new com.alibaba.dubbo.common.bytecode.NoSuchMethodException(\"Not found method \\\"\"+$2+\"\\\" in class com.alibaba.dubbo.demo.DemoService.\"); \n\t}\n}\n```\n\n### 暴露到注册中心\n\n我们先看下DelegateProviderMetaDataInvoker类。\n```java\n/**\n * DelegateProviderMetaDataInvoker类实现了invoker接口\n * 并且持有一个Invoker变量，操作都会委托给该变量\n */\npublic class DelegateProviderMetaDataInvoker<T> implements Invoker {\n    protected final Invoker<T> invoker;\n    private ServiceConfig metadata;\n\n    public DelegateProviderMetaDataInvoker(Invoker<T> invoker,ServiceConfig metadata) {\n        this.invoker = invoker;\n        this.metadata = metadata;\n    }\n\n    @Override\n    public Class<T> getInterface() {\n        return invoker.getInterface();\n    }\n\n    @Override\n    public URL getUrl() {\n        return invoker.getUrl();\n    }\n\n    @Override\n    public boolean isAvailable() {\n        return invoker.isAvailable();\n    }\n\n    @Override\n    public Result invoke(Invocation invocation) throws RpcException {\n        return invoker.invoke(invocation);\n    }\n\n    @Override\n    public void destroy() {\n        invoker.destroy();\n    }\n\n    public ServiceConfig getMetadata() {\n        return metadata;\n    }\n}\n```\n#### Protocol接口的export方法\n\n先来看下Protocol接口的定义，其export方法和refer方法存在@Adaptive注解。\n```java\n/**\n * 协议\n * Protocol. (API/SPI, Singleton, ThreadSafe)\n */\n@SPI(\"dubbo\")\npublic interface Protocol {\n\n    /**\n     * 当用户没有配置端口时，获取默认端口\n     * @return default port\n     */\n    int getDefaultPort();\n\n    /**\n     * 为远程调用暴露服务\n     * 1、接收到请求后协议应该记录请求源地址，通过: RpcContext.getContext().setRemoteAddress()\n     * 2、export()方法必须是幂等的，也就是说，暴露同一个URL的invoker两次时，调用1次和2次没有什么不同\n     * 3、传入的Invoker实例由框架实现并传入，协议不需要关心\n     *\n     * @param <T>     服务类型\n     * @param invoker 服务invoker\n     * @return 暴露服务的exporter引用，用来以后取消暴露服务\n     * @throws RpcException 当暴露服务出错时抛出，比如端口已占用\n     */\n    @Adaptive\n    <T> Exporter<T> export(Invoker<T> invoker) throws RpcException;\n\n    /**\n     * 引用一个远程服务\n     * 1、当用户调用 refer()所返回的 Invoker对象的invoke()时，协议需相应执行同URL远端export()传入的Invoker对象的invoke()方法.\n     * 2、refer()返回的Invoker由协议实现，一般来说，协议需要在此Invoker中发送远程请求。\n     * 3、当URL中设置了check=false时，这个实现不可以抛出异常，而是尝试着从连接失败中恢复\n     * @param T 远程服务类型\n     * @param type 远程服务接口类型\n     * @param url 远程服务的URL地址\n     * @return 执行服务的本地代理\n     * @throws RpcException when there's any error while connecting to the service provider\n     */\n    @Adaptive\n    <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException;\n\n    /**\n     * 销毁协议\n     * 1、取消该协议所有已经暴露和引用的服务\n     * 2、释放协议所有占用的资源，如：链接、端口等\n     * 3、协议在释放后，依然能暴露和引用新的服务\n     */\n    void destroy();\n}\n\n可以看到export方法是定义在Protocol接口中的，我们是通过ExtensionLoader类获取到Protocol的自适应扩展实例的，因此我们在调用export方法进行服务暴露时，实际上调用的是自适应扩展实例的export方法：\n```java\n//自适应扩展实现类\nProtocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();\n\n//获取invoker对象\nInvoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));\n//将invoker和当前对象(ServiceBean)包装成DelegateProviderMetaDataInvoker对象\nDelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\n//调用自适应扩展实现类的export方法\nExporter<?> exporter = protocol.export(wrapperInvoker);\n```\n那么，在获取自适应扩展实例时都进行了哪些操作呢？我们在《Dubbo源码阅读之SPI扩展机制》文章中介绍过Dubbo的SPI机制，这里就不再详细介绍了，只简单说明下是如何获取到Protocol实例的。\n首先我们我们通过ExtensionLoader.getExtensionLoader(Protocol.class)调用，获取到了Protocol的扩展加载器，然后调用它的getAdaptiveExtension()方法拿到自适应扩展实例(Dubbo为它自动生成的一个类，后面介绍)，在此过程中，会先去扫描3个相关路径找到所有的Protocol扩展实现类定义，\n最终会找到如下定义：\n```java\n#扩展名称=扩展实现类\nregistry=com.alibaba.dubbo.registry.integration.RegistryProtocol\nmock=com.alibaba.dubbo.rpc.support.MockProtocol\ninjvm=com.alibaba.dubbo.rpc.protocol.injvm.InjvmProtocol\ndubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol\n#Protocol包装类\nfilter=com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper\nlistener=com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper\n```\n\n然后检查每个扩展实现类，如果没有找到存在@Adaptive注解的扩展类，则Dubbo会为其生成一个自适应扩展类，生成的实现类如下：\n```java\n/**\n * 生成的实现类名为：Protocol$Adaptive，实现了Protocol接口\n * 只有接口方法上标有@Adaptive注解，才会为其生成实现，\n * 例如，Protocol接口的destroy()方法没有@Adaptive注解，因此下面的方法实现中直接抛了异常\n */\npublic class Protocol$Adaptive implements com.alibaba.dubbo.rpc.Protocol {\n\t\n\tpublic void destroy() {\n\t\t//提示 Protocol接口的destroy()方法没有@Adaptive注解，因此不支持\n\t\tthrow new UnsupportedOperationException(\"method public abstract void com.alibaba.dubbo.rpc.Protocol.destroy() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!\");\n\t}\n\t\n\tpublic int getDefaultPort() {\n\t\t//提示 Protocol接口的getDefaultPort()方法没有@Adaptive注解，因此不支持\n\t\tthrow new UnsupportedOperationException(\"method public abstract int com.alibaba.dubbo.rpc.Protocol.getDefaultPort() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!\");\n\t}\n\t\n\t/**\n\t * @param arg0 服务接口类\n\t * @param arg1 注册中心url\n\t */\n\tpublic com.alibaba.dubbo.rpc.Invoker refer(java.lang.Class arg0, com.alibaba.dubbo.common.URL arg1) throws com.alibaba.dubbo.rpc.RpcException {\n\t\tif (arg1 == null){\n\t\t\t//url参数不可以为空\n\t\t\tthrow new IllegalArgumentException(\"url == null\");\n\t\t}\n\t\t\n\t\tcom.alibaba.dubbo.common.URL url = arg1;\n\t\t\n\t\t//使用url的protocol属性值(这里为registry)，作为扩展名称，如果为空，则默认使用\"dubbo\"\n\t\tString extName = url.getProtocol() == null ? \"dubbo\" : url.getProtocol();\n\t\t\n\t\tif(extName == null) {\n\t\t\tthrow new IllegalStateException(\"Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(\" + url.toString() + \") use keys([protocol])\");\n\t\t}\n\t\t\n\t\t//获取扩展名称为extName的Protocol扩展实例\n\t\tcom.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);\n\t\t\n\t\t//调用该extension实例的refer方法\n\t\treturn extension.refer(arg0, arg1);\n\t}\n\t\t\n\tpublic com.alibaba.dubbo.rpc.Exporter export(com.alibaba.dubbo.rpc.Invoker arg0) throws com.alibaba.dubbo.rpc.RpcException {\n\t\tif (arg0 == null){\n\t\t    throw new IllegalArgumentException(\"com.alibaba.dubbo.rpc.Invoker argument == null\");\n\t\t} \n\t\t\n\t\tif (arg0.getUrl() == null) {\n\t\t    throw new IllegalArgumentException(\"com.alibaba.dubbo.rpc.Invoker argument getUrl() == null\");\n\t\t}\n\t\t\n\t\tcom.alibaba.dubbo.common.URL url = arg0.getUrl();\n\t\t\n\t\t//使用url的protocol属性值(这里为registry)，作为扩展名称，如果为空，则默认使用\"dubbo\"\n\t\tString extName = ( url.getProtocol() == null ? \"dubbo\" : url.getProtocol() );\n\t\t\n\t\tif(extName == null) {\n\t\t\tthrow new IllegalStateException(\"Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(\" + url.toString() + \") use keys([protocol])\");\n\t\t}\n\t\t\n\t\t//获取扩展名称为extName的Protocol扩展实例（此扩展实例已经被包装类包装过）\n\t\tcom.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);\n\t\t\n\t\t//调用该extension实例的export方法(包装类的export方法)\n\t\treturn extension.export(arg0);\n\t}\n}\n```\n在上面我们说到，调用export方法实际上是调用自适应扩展实现类的export方法，我们来看下其实现。\n首先校验invoker参数不可以为空，然后校验invoker对象的getUrl()方法返回的URL对象不可以为空，然后我们使用URL对象的protocol属性作为扩展名称extName(提示：在上一节的loadRegistries(boolean provider)加载注册中心url列表方法中，我们设置了注册中心url的protocol属性值为\"registry\")，然后根据扩展名称extName获取到真正的Protocol扩展实例(RegistryProtocol,然后RegistryProtocol会被包装)，最后调用该Protocol扩展实例的export方法。\n通过生成的自适应扩展实现类，我们可以根据不同的扩展名称调用不同的扩展实例。\n在getExtension(extName)方法中，获取到相应的扩展实例后(RegistryProtocol)，Dubbo会再去查看下该扩展是否存在相应的包装类，在上面我们扫描出来Protocol接口存在2个包装类，ProtocolFilterWrapper和ProtocolListenerWrapper，接着Dubbo会创建包装类的实例，并将刚才生成RegistryProtocol扩展实例通过构造函数参数传递到包装类中，通过包装类，Dubbo就实现了功能增强。\n因此，现在我们再回过头来看下export方法的调用：首先是调用自适应扩展实现类的export方法，在export方法内部，根据扩展名称获取到真实的扩展实例RegistryProtocol，然后又通过两个包装类将真实的扩展实例进行了包装，最后调用的是包装类的export方法。\n具体的调用链我们已经分析完了，现在我们来看下对应的代码。\n```java\n/**\n * 根据扩展名称创建扩展实例后，会获取包装类，将扩展实例进行包装\n */\nprivate T createExtension(String name) {\n\t//根据扩展名称name获取扩展实现类clazz\n\tClass<?> clazz = getExtensionClasses().get(name);\n\tif (clazz == null) {\n\t    //扩展实现类为空，则抛出异常\n\t    throw findException(name);\n\t}\n\ttry {\n\t    //先从缓存中获取扩展实现类的实例，如果没有获取到，则新建一个并放入缓存。\n\t    T instance = (T) EXTENSION_INSTANCES.get(clazz);\n\t    if (instance == null) {\n\t\tEXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());\n\t\tinstance = (T) EXTENSION_INSTANCES.get(clazz);\n\t    }\n\t    //处理扩展实现类实例的依赖注入\n\t    injectExtension(instance);\n\n\t    //获取到type接口的所有包装类\n\t    Set<Class<?>> wrapperClasses = cachedWrapperClasses;\n\t    if (wrapperClasses != null && !wrapperClasses.isEmpty()) {\n\t\t//遍历包装类\n\t\tfor (Class<?> wrapperClass : wrapperClasses) {\n\t\t    //包装类通过构造方法创建实例，然后进行依赖注入\n\t\t    instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));\n\t\t}\n\t    }\n\t    return instance;\n\t} catch (Throwable t) {\n\t    throw new IllegalStateException(\"Extension instance(name: \" + name + \", class: \" +\n\t\t    type + \")  could not be instantiated: \" + t.getMessage(), t);\n\t}\n}\n\npublic class ProtocolFilterWrapper implements Protocol {\n\t\n    //根据上面的分析，这里的protocol是ProtocolListenerWrapper\n    private final Protocol protocol;\n\n    public ProtocolFilterWrapper(Protocol protocol) {\n        if (protocol == null) {\n            throw new IllegalArgumentException(\"protocol == null\");\n        }\n        this.protocol = protocol;\n    }\n    \n    @Override\n    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n        \n        if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) {\n\t    //如果url的protocol属性为registry，则调用protocol的export方法\n            return protocol.export(invoker);\n        }\n        return protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));\n    }\n    //.....省略其他方法....\n}\n\n\npublic class ProtocolListenerWrapper implements Protocol{\n\t\n    //根据上面的分析，这里的protocol是RegistryProtocol\n    private final Protocol protocol;\n\n    public ProtocolListenerWrapper(Protocol protocol) {\n        if (protocol == null) {\n            throw new IllegalArgumentException(\"protocol == null\");\n        }\n        this.protocol = protocol;\n    }\n    \n     @Override\n    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n        if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) {\n\t    //如果url的protocol属性为registry，则调用protocol的export方法\n            return protocol.export(invoker);\n        }\n        return new ListenerExporterWrapper<T>(protocol.export(invoker),\n                Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener.class)\n                        .getActivateExtension(invoker.getUrl(), Constants.EXPORTER_LISTENER_KEY)));\n    }\n}\n```\n经过我们的分析，最终会调用RegistryProtocol的export方法进行服务暴露，接下来，我们就来分析下该方法。\n```java\n\n//获取invoker对象\nInvoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));\n\n//将invoker和当前对象(ServiceBean)包装成DelegateProviderMetaDataInvoker对象\nDelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\n\n\n/**\n * 通过invoker的url(即注册中心url)获取providerUrl的地址（即服务暴露的url）\n * @param origininvoker\n * @return\n */\nprivate URL getProviderUrl(final Invoker<?> origininvoker) {\n\t//获取参数export指定的服务地址\n\tString export = origininvoker.getUrl().getParameterAndDecoded(Constants.EXPORT_KEY);\n\tif (export == null || export.length() == 0) {\n\t    //注册中心服务暴露url为空\n\t    throw new IllegalArgumentException(\"The registry export url is null! registry: \" + origininvoker.getUrl());\n\t}\n\t//根据url字符串生成URL对象\n\tURL providerUrl = URL.valueOf(export);\n\treturn providerUrl;\n}\n\n/**\n * 获取originInvoker对象对应的缓存key（移除了dynamic、enabled属性的服务提供者url）\n */\nprivate String getCacheKey(final Invoker<?> originInvoker) {\n\t//获取服务暴露的url，即export参数对应的url\n\tURL providerUrl = getProviderUrl(originInvoker);\n\t//移除dynamic、enabled参数，剩下的url作为缓存key\n\tString key = providerUrl.removeParameters(\"dynamic\", \"enabled\").toFullString();\n\treturn key;\n}\n\n/**\n * 获取注册中心url(如果是注册中心协议，则修改了protocol属性值，属性值为url的registry参数值，并移除url的registry参数)\n * @param originInvoker\n * @return\n */\nprivate URL getRegistryUrl(Invoker<?> originInvoker) {\n\t//注册中心url\n\tURL registryUrl = originInvoker.getUrl();\n\t\n\tif (Constants.REGISTRY_PROTOCOL.equals(registryUrl.getProtocol())) {\n\t    //如果registryUrl的protocol属性为\"registry\"，则获取registryUrl的registry参数值，如果没有获取到，则默认protocol = dubbo\n\t    //这里获取到protocol = multicast\n\t    String protocol = registryUrl.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_DIRECTORY);\n\t    //设置registryUrl的protocol属性值，并移除registry参数\n\t    registryUrl = registryUrl.setProtocol(protocol).removeParameter(Constants.REGISTRY_KEY);\n\t}\n\treturn registryUrl;\n}\n\n/**\n *\n * 基于invoker的地址获取一个注册中心的实例\n * @param originInvoker\n * @return\n */\nprivate Registry getRegistry(final Invoker<?> originInvoker) {\n\tURL registryUrl = getRegistryUrl(originInvoker);\n\t//获取实例\n\treturn registryFactory.getRegistry(registryUrl);\n}\n\n/**\n * 返回注册到注册中心的地址并过滤一次url参数(即服务提供者url)\n * @param originInvoker\n * @return\n */\nprivate URL getRegistedProviderUrl(final Invoker<?> originInvoker) {\n\t//服务暴露的url，即export参数指定的url\n\tURL providerUrl = getProviderUrl(originInvoker);\n\n\t//在注册中心中看到的服务地址\n\tfinal URL registedProviderUrl = providerUrl.removeParameters(\n\t\t\t//删除不需要输出的参数key\n\t\t\tgetFilteredKeys(providerUrl)\n\t\t)\n\t\t//移除监控\n\t\t.removeParameter(Constants.MONITOR_KEY)\n\t\t//移除绑定ip、port\n\t\t.removeParameter(Constants.BIND_IP_KEY)\n\t\t.removeParameter(Constants.BIND_PORT_KEY)\n\t\t//移除qos\n\t\t.removeParameter(QOS_ENABLE)\n\t\t.removeParameter(QOS_PORT)\n\t\t.removeParameter(ACCEPT_FOREIGN_IP);\n\t\n\treturn registedProviderUrl;\n}\n\n/**\n * 服务暴露\n * originInvoker参数就是上面我们创建的wrapperInvoker\n */\n@Override\npublic <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcException {\n\t//暴露invoker(后面会分析该方法)\n\tfinal ExporterChangeableWrapper<T> exporter = doLocalExport(originInvoker);\n\t\n\t//获取注册中心地址,如：multicast://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&dubbo=2.0.0&export=dubbo%3A%2F%2F192.168.99.60%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26bind.ip%3D192.168.99.60%26bind.port%3D20880%26dubbo%3D2.0.0%26generic%3Dfalse%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D7520%26qos.port%3D22222%26side%3Dprovider%26timestamp%3D1528784828723&pid=7520&qos.port=22222&timestamp=1528784779675\n\tURL registryUrl = getRegistryUrl(originInvoker);\n\n\t//获取注册中心实例\n\tfinal Registry registry = getRegistry(originInvoker);\n\t\n\t//注册中心url的export参数指定的url(服务提供者url)，去掉了一些key\n\tfinal URL registedProviderUrl = getRegistedProviderUrl(originInvoker);\n\t\n\t//判断是否延迟发布，默认是true\n\tboolean register = registedProviderUrl.getParameter(\"register\", true);\n\t\n\t//注册服务提供者(保存到map缓存中)\n\tProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registedProviderUrl);\n\n\tif (register) {\n\t    //registryUrl注册中心url，registedProviderUrl服务提供者url\n\t    //获取注册中心，并将服务提供者注册到注册中心\n\t    register(registryUrl, registedProviderUrl);\n\t    \n\t    //根据originInvoker获取到ProviderInvokerWrapper并标识isReg = true\n\t    ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true);\n\t}\n\n\t// 当提供者订阅时，会影响一个场景，即同一JVM即暴露服务，又引用同一服务。\n\t// 因为subscribed使用服务的名称作为缓存key，它会导致订阅信息被覆盖\n\t//如：provider://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&category=configurators&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=5452&side=provider&timestamp=1528789631708\n\tfinal URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);\n\t\n\t//创建OverrideListener对象(后面小节会介绍)\n\tfinal OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);\n\t\n\t//保存overrideSubscribeUrl和overrideSubscribeListener\n\toverrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);\n\t\n\t//订阅服务(后面注册中心小节会介绍)\n\tregistry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);\n\t\n\t//确保每次发布时都返回一个新的exporter实例\n\treturn new DestroyableExporter<T>(exporter, originInvoker, overrideSubscribeUrl, registedProviderUrl);\n}\n\n/**\n * subscribedOverrideUrl\n * @param registedProviderUrl 服务提供者url\n * @return\n */\nprivate URL getSubscribedOverrideUrl(URL registedProviderUrl) {\n\t//设置protocol = provider,修改前 protocol = dubbo\n\t//设置category = configurators\n\t//设置check = false\n\treturn registedProviderUrl.setProtocol(Constants.PROVIDER_PROTOCOL)\n\t\t.addParameters(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY,\n\t\t\tConstants.CHECK_KEY, String.valueOf(false));\n}\n\n/**\n * 通过registryUrl获取注册中心，然后将服务提供者url注册到注册中心\n * @param registryUrl 注册中心url\n * @param registedProviderUrl 服务提供者url\n */\npublic void register(URL registryUrl, URL registedProviderUrl) {\n\t//根据注册中心url 获取注册中心实例\n\tRegistry registry = registryFactory.getRegistry(registryUrl);\n\t//注册 服务提供者 到注册中心\n\tregistry.register(registedProviderUrl);\n}\n\n/**\n * 为了解决RMI反复暴露端口冲突的问题，已经暴露的服务不需要再次暴露\n * <providerurl,exporter>\n */\nprivate final Map<String, ExporterChangeableWrapper<?>> bounds = new ConcurrentHashMap<String, ExporterChangeableWrapper<?>>();\n\n/**\n * <服务提供者url,NotifyListener>\n */\nprivate final Map<URL, NotifyListener> overrideListeners = new ConcurrentHashMap<URL, NotifyListener>();\n\n/**\n * 暴露originInvoker\n */\nprivate <T> ExporterChangeableWrapper<T> doLocalExport(final Invoker<T> originInvoker) {\n\t//获取缓存key\n\tString key = getCacheKey(originInvoker);\n\t\n\t//先检查是否暴露过，没有暴露过的话，则进行暴露\n\tExporterChangeableWrapper<T> exporter = (ExporterChangeableWrapper<T>) bounds.get(key);\n\tif (exporter == null) {\n\t    synchronized (bounds) {\n\t\texporter = (ExporterChangeableWrapper<T>) bounds.get(key);\n\t\tif (exporter == null) {\n\t\t    //根据originInvoker，及其服务提供者url，创建InvokerDelegete对象\n\t\t    final Invoker<?> invokerDelegete = new InvokerDelegete<T>(originInvoker, getProviderUrl(originInvoker));\n\t\t   \n\t\t    //1、因为invokerDelegete对象的getUrl方法将会返回服务提供者url，其protocol属性将会返回扩展名称dubbo，因此这里会调用DubboProtocol的export方法进行暴露\n\t\t    //2、创建ExporterChangeableWrapper对象\n\t\t    exporter = new ExporterChangeableWrapper<T>((Exporter<T>) protocol.export(invokerDelegete), originInvoker);\n\t\t    \n\t\t    //dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=192.168.99.60&bind.port=20880&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=6440&qos.port=22222&side=provider&timestamp=1528789363848\n\t\t    //URL url = exporter.getInvoker().getUrl();\n\t\t    //放入缓存\n\t\t    bounds.put(key, exporter);\n\t\t}\n\t    }\n\t}\n\treturn exporter;\n}\n\n/**\n * Invoker委托类\n */\npublic static class InvokerDelegete<T> extends InvokerWrapper<T> {\n\n\tprivate final Invoker<T> invoker;\n\n\t/**\n\t * @param invoker\n\t * @param url   服务提供者url\n\t */\n\tpublic InvokerDelegete(Invoker<T> invoker, URL url) {\n\t    super(invoker, url);\n\t    this.invoker = invoker;\n\t}\n\n\tpublic Invoker<T> getInvoker() {\n\t    if (invoker instanceof InvokerDelegete) {\n\t\treturn ((InvokerDelegete<T>) invoker).getInvoker();\n\t    } else {\n\t\treturn invoker;\n\t    }\n\t}\n}\n\n/**\n * exporter代理\n * 建立通过protocol已暴露的exporter和已返回的exporter的对应关系\n * 并且可以在覆盖时修改关系\n */\nprivate class ExporterChangeableWrapper<T> implements Exporter<T> {\n\n\tprivate final Invoker<T> originInvoker;\n\n\t//protocol.export(invokerDelegete)返回的Exporter\n\tprivate Exporter<T> exporter;\n\n\tpublic ExporterChangeableWrapper(Exporter<T> exporter, Invoker<T> originInvoker) {\n\t    this.exporter = exporter;\n\t    this.originInvoker = originInvoker;\n\t}\n\n\tpublic Invoker<T> getOriginInvoker() {\n\t    return originInvoker;\n\t}\n\n\t@Override\n\tpublic Invoker<T> getInvoker() {\n\t    return exporter.getInvoker();\n\t}\n\n\tpublic void setExporter(Exporter<T> exporter) {\n\t    this.exporter = exporter;\n\t}\n\n\t@Override\n\tpublic void unexport() {\n\t    String key = getCacheKey(this.originInvoker);\n\t    bounds.remove(key);\n\t    exporter.unexport();\n\t}\n}\n\n/**\n * 可销毁的Exporter\n */\nstatic private class DestroyableExporter<T> implements Exporter<T> {\n\t\n\tpublic static final ExecutorService executor = Executors.newSingleThreadExecutor(new NamedThreadFactory(\"Exporter-Unexport\", true));\n\n\tprivate Exporter<T> exporter;\n\tprivate Invoker<T> originInvoker;\n\n\t//overrideSubscribeUrl 订阅的url\n\tprivate URL subscribeUrl; \n\t\n\t//registedProviderUrl 注册的服务提供者url\n\tprivate URL registerUrl;\n\n\tpublic DestroyableExporter(Exporter<T> exporter, Invoker<T> originInvoker, URL subscribeUrl, URL registerUrl) {\n\t    this.exporter = exporter;\n\t    this.originInvoker = originInvoker;\n\t    this.subscribeUrl = subscribeUrl;\n\t    this.registerUrl = registerUrl;\n\t}\n\n\t@Override\n\tpublic Invoker<T> getInvoker() {\n\t    return exporter.getInvoker();\n\t}\n\n\t@Override\n\tpublic void unexport() {\n\t    //获取注册中心实例\n\t    Registry registry = RegistryProtocol.INSTANCE.getRegistry(originInvoker);\n\t    try {\n\t        //取消注册registerUrl\n\t\tregistry.unregister(registerUrl);\n\t    } catch (Throwable t) {\n\t\tlogger.warn(t.getMessage(), t);\n\t    }\n\t    try {\n\t        //移除监听\n\t\tNotifyListener listener = RegistryProtocol.INSTANCE.overrideListeners.remove(subscribeUrl);\n\t\t//取消订阅subscribeUrl\n\t\tregistry.unsubscribe(subscribeUrl, listener);\n\t    } catch (Throwable t) {\n\t\tlogger.warn(t.getMessage(), t);\n\t    }\n\t    //提交线程，取消暴露服务\n\t    executor.submit(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t    try {\n\t\t        //取消暴露服务时，等待注册中心通知所有的消费者的超时时间\n\t\t\tint timeout = ConfigUtils.getServerShutdownTimeout();\n\t\t\tif (timeout > 0) {\n\t\t\t    logger.info(\"Waiting \" + timeout + \"ms for registry to notify all consumers before unexport. Usually, this is called when you use dubbo API\");\n\t\t\t    Thread.sleep(timeout);\n\t\t\t}\n\t\t\t//取消暴露服务\n\t\t\texporter.unexport();\n\t\t    } catch (Throwable t) {\n\t\t\tlogger.warn(t.getMessage(), t);\n\t\t    }\n\t\t}\n\t    });\n\t}\n}\n```\n\nProviderConsumerRegTable类用来保存注册的服务提供者和消费者\n```java\npublic class ProviderConsumerRegTable {\n    /**\n     * <服务唯一名称,Set<服务提供者执行器>>\n     */\n    public static ConcurrentHashMap<String, Set<ProviderInvokerWrapper>> providerInvokers = new ConcurrentHashMap<String, Set<ProviderInvokerWrapper>>();\n    public static ConcurrentHashMap<String, Set<ConsumerInvokerWrapper>> consumerInvokers = new ConcurrentHashMap<String, Set<ConsumerInvokerWrapper>>();\n\n    /**\n     * 注册服务提供者\n     * @param invoker\n     * @param registryUrl 注册中心地址\n     * @param providerUrl 服务提供者url\n     */\n    public static void registerProvider(Invoker invoker, URL registryUrl, URL providerUrl) {\n\t//创建ProviderInvokerWrapper实例\n        ProviderInvokerWrapper wrapperInvoker = new ProviderInvokerWrapper(invoker, registryUrl, providerUrl);\n        \n\t//获取服务唯一名称标识\n        String serviceUniqueName = providerUrl.getServiceKey();\n\t\n\t//根据serviceUniqueName从缓存中获取\n\tSet<ProviderInvokerWrapper> invokers = providerInvokers.get(serviceUniqueName);\n        \n\tif (invokers == null) {\n            providerInvokers.putIfAbsent(serviceUniqueName, new ConcurrentHashSet<ProviderInvokerWrapper>());\n            invokers = providerInvokers.get(serviceUniqueName);\n        }\n        invokers.add(wrapperInvoker);\n    }\n}\n\n/**\n * 通过invoker 获取相应的ProviderInvokerWrapper\n * @param invoker\n * @return\n */\npublic static ProviderInvokerWrapper getProviderWrapper(Invoker invoker) {\n\t//获取服务提供者url\n\tURL providerUrl = invoker.getUrl();\n\tif (Constants.REGISTRY_PROTOCOL.equals(providerUrl.getProtocol())) {\n\t    //获取export参数的值，即(服务提供者url)\n\t    providerUrl = URL.valueOf(providerUrl.getParameterAndDecoded(Constants.EXPORT_KEY));\n\t}\n\t//获取服务唯一标识\n\tString serviceUniqueName = providerUrl.getServiceKey();\n\t//根据服务唯一标识获取invokers\n\tSet<ProviderInvokerWrapper> invokers = providerInvokers.get(serviceUniqueName);\n\tif (invokers == null) {\n\t    return null;\n\t}\n\tfor (ProviderInvokerWrapper providerWrapper : invokers) {\n\t    Invoker providerInvoker = providerWrapper.getInvoker();\n\t    //通过invoker获取providerWrapper\n\t    if (providerInvoker == invoker) {\n\t\treturn providerWrapper;\n\t    }\n\t}\n\treturn null;\n}\n\n\n/**\n * 重新暴露修改了url的invoker\n * @param originInvoker\n * @param newInvokerUrl\n */\n@SuppressWarnings(\"unchecked\")\nprivate <T> void doChangeLocalExport(final Invoker<T> originInvoker, URL newInvokerUrl) {\n        //获取originInvoker对应的缓存key\n\tString key = getCacheKey(originInvoker);\n\n\t//从缓存中获取该exporter\n\tfinal ExporterChangeableWrapper<T> exporter = (ExporterChangeableWrapper<T>) bounds.get(key);\n\t\n\tif (exporter == null) {\n\t    logger.warn(new IllegalStateException(\"error state, exporter should not be null\"));\n\t} else {\n\t    //重新生成invokerDelegete\n\t    final Invoker<T> invokerDelegete = new InvokerDelegete<T>(originInvoker, newInvokerUrl);\n\t    //重新暴露服务\n\t    exporter.setExporter(protocol.export(invokerDelegete));\n\t}\n}\n```\n\n接下来我们看下OverrideListener类\n```java\n/**\n * 1、确保由registryProtocol返回的exporter可以被正常销毁\n * 2、通知后，无需重新注册到注册中心\n * 3、通过暴露方法传递invoker，最好是exporter的invoker\n */\nprivate class OverrideListener implements NotifyListener {\n\t/**\n\t * 已订阅的url\n\t * protocol = provider\n\t */\n\tprivate final URL subscribeUrl;\n\n\tprivate final Invoker originInvoker;\n\n\tpublic OverrideListener(URL subscribeUrl, Invoker originalInvoker) {\n\t    this.subscribeUrl = subscribeUrl;\n\t    this.originInvoker = originalInvoker;\n\t}\n\n\t/**\n\t * 通知\n\t * @param urls 已注册的信息列表，它总是非空。这意味着与RegistryService#lookup(URL)有相同的返回值\n\t */\n\t@Override\n\tpublic synchronized void notify(List<URL> urls) {\n\t    logger.debug(\"original override urls: \" + urls);\n\t    \n\t    //获取匹配到的url\n\t    List<URL> matchedUrls = getMatchedUrls(urls, subscribeUrl);\n\t    logger.debug(\"subscribe url: \" + subscribeUrl + \", override urls: \" + matchedUrls);\n\n\t    //没有匹配到结果，直接返回\n\t    if (matchedUrls.isEmpty()) {\n\t\treturn;\n\t    }\n\t\t\n\t    //根据匹配的url生成configurators列表(后面小节会分析该方法)\n\t    List<Configurator> configurators = RegistryDirectory.toConfigurators(matchedUrls);\n\n\t    final Invoker<?> invoker;\n\t    if (originInvoker instanceof InvokerDelegete) {\n\t        //委托类，调用getInvoker()方法获取invoker\n\t\tinvoker = ((InvokerDelegete<?>) originInvoker).getInvoker();\n\t    } else {\n\t\tinvoker = originInvoker;\n\t    }\n\n\t    //originUrl即export参数对应的url(原始服务提供者url)\n\t    URL originUrl = RegistryProtocol.this.getProviderUrl(invoker);\n\t    \n\t    //这里的exporter就是在上步的doLocalExport()方法中生成的\n\t    String key = getCacheKey(originInvoker);\n\n\t    //根据缓存key从缓存中获取exporter\n\t    ExporterChangeableWrapper<?> exporter = bounds.get(key);\n\t    if (exporter == null) {\n\t\tlogger.warn(new IllegalStateException(\"error state, exporter should not be null\"));\n\t\treturn;\n\t    }\n\t    \n\t    //当前的url(旧的服务暴露的url)，可能已经合并了很多次\n\t    URL currentUrl = exporter.getInvoker().getUrl();\n\t   \n\t    //合并配置，生成新的服务暴露url\n\t    URL newUrl = getConfigedInvokerUrl(configurators, originUrl);\n\t    \n\t    if (!currentUrl.equals(newUrl)) {\n\t\t//已暴露的服务提供者url已经发生改变，重新暴露\n\t\tRegistryProtocol.this.doChangeLocalExport(originInvoker, newUrl);\n\n\t\tlogger.info(\"exported provider url changed, origin url: \" + originUrl + \", old export url: \" + currentUrl + \", new export url: \" + newUrl);\n\t    }\n\t}\n\t\n\t/**\n\t * 获取匹配的url\n\t * @param configuratorUrls\n\t * @param currentSubscribe 当前已订阅的url\n\t */\n\tprivate List<URL> getMatchedUrls(List<URL> configuratorUrls, URL currentSubscribe) {\n\t    List<URL> result = new ArrayList<URL>();\n\t    \n\t    for (URL url : configuratorUrls) {\n\t\tURL overrideUrl = url;\n\t\t//与旧版本兼容\n\t\tif (url.getParameter(Constants.CATEGORY_KEY) == null && Constants.OVERRIDE_PROTOCOL.equals(url.getProtocol())) {\n\t\t    //url的category参数为空，并且url协议为override时，则新增url的category参数 = configurators\n\t\t    overrideUrl = url.addParameter(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY);\n\t\t}\n\n\t\t//检测url是否可以应用到当前服务\n\t\t//consumerUrl,providerUrl\n\t\tif (UrlUtils.isMatch(currentSubscribe, overrideUrl)) {\n\t\t    //匹配，则将该url保存\n\t\t    result.add(url);\n\t\t}\n\t    }\n\t    return result;\n\t}\n\n\t/**\n\t * 合并configurators的url，返回新的url\n\t * @param configurators\n\t * @param url 原始服务提供者url\n\t * @return\n\t */\n\tprivate URL getConfigedInvokerUrl(List<Configurator> configurators, URL url) {\n\t    for (Configurator configurator : configurators) {\n\t        //配置url\n\t\turl = configurator.configure(url);\n\t    }\n\t    return url;\n\t}\n}\n```\n\n最后我们来看下DubboProtocol的export方法\n\n```java\n/**\n * 保存发布的服务\n * <URL的serviceKey,Exporter>\n * 通过key可以获取到服务发布对象DubboExporter，\n * 然后通过DubboExporter的getInvoker方法得到服务调用对象Invoker,从而调用服务\n */\nprotected final Map<String, Exporter<?>> exporterMap = new ConcurrentHashMap<String, Exporter<?>>();\n\n/**\n * 消费者端为调度事件暴露一个存根服务\n * <servicekey,stubmethods>\n */\nprivate final ConcurrentMap<String, String> stubServiceMethodsMap = new ConcurrentHashMap<String, String>();\n\n\n/**\n *\n * @param invoker 即新创建的InvokerDelegete对象\n */\n@Override\npublic <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n\t\n\t//服务提供者url\n\t//dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=192.168.99.60&bind.port=20880&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=7520&qos.port=22222&side=provider&timestamp=1528784828723\n\tURL url = invoker.getUrl();\n\n\t// 获取服务名称，格式为：group/ServiceName:version:port\n\t// 这里group和version没有设置，因此key = com.alibaba.dubbo.demo.DemoService:20880\n\tString key = serviceKey(url);\n\t\n\t//生成key值之后，结合Invoker和exportMap生成服务暴露对象exporter，\n\t//然后将生成的服务暴露对象exporter作为value值放入map中，从而实现服务发布\n\tDubboExporter<T> exporter = new DubboExporter<T>(invoker, key, exporterMap);\n\texporterMap.put(key, exporter);\n\n\t//为调度事件暴露一个存根服务，默认false\n\tBoolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);\n\t\n\t//是否是回调服务\n\tBoolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, false);\n\tif (isStubSupportEvent && !isCallbackservice) {\n\t    //存根服务方法\n\t    String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);\n\t    if (stubServiceMethods == null || stubServiceMethods.length() == 0) {\n\t\tif (logger.isWarnEnabled()) {\n\t\t    //设置了存根代理支持事件，但是没有发现存根方法\n\t\t    logger.warn(new IllegalStateException(\"consumer [\" + url.getParameter(Constants.INTERFACE_KEY) +\n\t\t\t    \"], has set stubproxy support event ,but no stub methods founded.\"));\n\t\t}\n\t    } else {\n\t\t//保存存根方法\n\t\tstubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);\n\t    }\n\t}\n\t//开启服务\n\topenServer(url);\n\t//优化序列化(加载优化序列化类,后面小节会详细介绍)\n\toptimizeSerialization(url);\n\t//返回exporter\n\treturn exporter;\n}\n\n/**\n * 保存已创建的服务器\n * <地址address，ExchangeServer>\n */\nprivate final Map<String, ExchangeServer> serverMap = new ConcurrentHashMap<String, ExchangeServer>();\n\n/**\n * 开启服务(后面会小节会详解讲解)\n * @param url\n */\nprivate void openServer(URL url) {\n\t//获取服务地址\n\tString key = url.getAddress();\n\t\n\t//客户端可以暴露一个只能服务端调用的服务\n\tboolean isServer = url.getParameter(Constants.IS_SERVER_KEY, true);\n\t\n\tif (isServer) {\n\t    //先从缓存中获取下该服务地址key对应的服务器\n\t    ExchangeServer server = serverMap.get(key);\n\t    if (server == null) {\n\t\t//创建服务器，并放入缓存\n\t\tserverMap.put(key, createServer(url));\n\t    } else {\n\t\t//服务器支持重置，与override一起使用\n\t\t//重置服务器\n\t\tserver.reset(url);\n\t    }\n\t}\n}\n\n\n/**\n * 创建服务器\n * @param url 服务提供者url\n * @return\n */\nprivate ExchangeServer createServer(URL url) {\n\t//当服务器关闭时，发送readonly事件，默认情况下，是启用的。\n\turl = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString());\n\t\n\t//默认情况下，启用心跳\n\turl = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));\n\t\n\t//获取Transporter扩展，默认使用netty\n\tString str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);\n\n\tif (str != null && str.length() > 0 && !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) {\n\t    //不支持的服务器类型\n\t    throw new RpcException(\"Unsupported server type: \" + str + \", url: \" + url);\n\t}\n\t//在url中添加codec=dubbo\n\turl = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);\n\t\n\tExchangeServer server;\n\ttry {\n\t    //Exchangers门面 绑定到服务器\n\t    server = Exchangers.bind(url, requestHandler);\n\t} catch (RemotingException e) {\n\t    throw new RpcException(\"Fail to start server(url: \" + url + \") \" + e.getMessage(), e);\n\t}\n\t\n\t//获取客户端扩展名称\n\tstr = url.getParameter(Constants.CLIENT_KEY);\n\t\n\tif (str != null && str.length() > 0) {\n\t    //获取支持的Transporter扩展名称列表\n\t    Set<String> supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();\n\t    if (!supportedTypes.contains(str)) {\n\t\t//不支持的客户端类型\n\t\tthrow new RpcException(\"Unsupported client type: \" + str);\n\t    }\n\t}\n\treturn server;\n}\n```\n\n\n### 暴露到本地\n\n主要的方法调用protocol.export上文我们已经介绍过了，这里就不再介绍了。\n\n```java\n/**\n * 暴露服务到本地注册中心\n * @param url 服务暴露的url\n */\nprivate void exportLocal(URL url) {\n\tif (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) {\n\t    //例如：injvm://127.0.0.1/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=192.168.99.60&bind.port=20880&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=4328&qos.port=22222&side=provider&timestamp=1528278313225\n\t    URL local = URL.valueOf(url.toFullString())\n\t\t    //设置injvm协议\n\t\t    .setProtocol(Constants.LOCAL_PROTOCOL)\n\t\t    //设置本地地址\n\t\t    .setHost(LOCALHOST)\n\t\t    //设置端口\n\t\t    .setPort(0);\n\n\t    //获取到实现类ref的Class对象，然后将它放入到ThreadLocal中\n\t    ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref));\n\n\t    //暴露服务(后面会分析export方法)\n\t    Exporter<?> exporter = protocol.export(\n\t\t    proxyFactory.getInvoker(ref, (Class) interfaceClass, local)\n\t    );\n\n\t    //保存暴露的服务到本地变量中\n\t    exporters.add(exporter);\n\t    logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to local registry\");\n\t}\n}\n```\n\n到此，关于服务暴露的内容，我们就介绍完毕了，下一小节，介绍如果引用服务.\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之集成Spring外部化配置(03)","url":"/blog/2018/08/08/Dubbo源码阅读之集成Spring-03外部化配置/","content":">这一小节，我们来看下支持外部化配置的相关类，因为本系列文章主要关注源码，具体的映射规则就不在介绍了，可以参考: https://zhuanlan.zhihu.com/p/32557951\n\n### 支持的注解\n\n#### DubboComponentScan注解\n@Import是Spring提供的注解，可以通过导入的方式将实例添加到BeanFactory中，不了解的童鞋可以去我的博客里面找一下，有单独的文章介绍。\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Import(DubboComponentScanRegistrar.class)\npublic @interface DubboComponentScan {\n\n    /**\n     * basePackages() 别名，例如，可以使用 @DubboComponentScan(\"org.my.pkg\") 替代 @DubboComponentScan(basePackages=\"org.my.pkg\")\n     * Alias for the {@link #basePackages()} attribute. Allows for more concise annotation\n     * declarations e.g.: {@code @DubboComponentScan(\"org.my.pkg\")} instead of\n     * {@code @DubboComponentScan(basePackages=\"org.my.pkg\")}.\n     *\n     * @return the base packages to scan\n     */\n    String[] value() default {};\n\n    /**\n     * 被标注@Service注解的类所在基础包路径\n     * @return the base packages to scan\n     */\n    String[] basePackages() default {};\n\n    /**\n     * 类型安全，用来替代 basePackages()\n     * @return the base packages to scan\n     */\n    Class<?>[] basePackageClasses() default {};\n}\n```\n然后我们看下DubboComponentScanRegistrar类，该类负责注册ServiceAnnotationBeanPostProcessor和ReferenceAnnotationBeanPostProcessor到BeanFactory\n```java\n/**\n * 实现了ImportBeanDefinitionRegistrar接口，允许我们注册特定的bean到Spring中\n * Dubbo {@link DubboComponentScan} Bean Registrar\n *\n * @see Service\n * @see DubboComponentScan\n * @see ImportBeanDefinitionRegistrar\n * @see ServiceAnnotationBeanPostProcessor\n * @see ReferenceAnnotationBeanPostProcessor\n * @since 2.5.7\n */\npublic class DubboComponentScanRegistrar implements ImportBeanDefinitionRegistrar {\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n\n        //获取待扫描的基础包路径\n        Set<String> packagesToScan = getPackagesToScan(importingClassMetadata);\n\n        //注册ServiceAnnotationBeanPostProcessor\n        registerServiceAnnotationBeanPostProcessor(packagesToScan, registry);\n        //注册ReferenceAnnotationBeanPostProcessor\n        registerReferenceAnnotationBeanPostProcessor(registry);\n\n    }\n\n    /**\n     * 注册ServiceAnnotationBeanPostProcessor类\n     *\n     * @param packagesToScan 待扫描的包路径，没有处理placeholders\n     * @param registry       {@link BeanDefinitionRegistry}\n     * @since 2.5.8\n     */\n    private void registerServiceAnnotationBeanPostProcessor(Set<String> packagesToScan,\n                                                            BeanDefinitionRegistry registry) {\n\n        BeanDefinitionBuilder builder = rootBeanDefinition(ServiceAnnotationBeanPostProcessor.class);\n        builder.addConstructorArgValue(packagesToScan);\n        builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();\n        //生成beanName并执行注册\n        BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry);\n\n    }\n\n    /**\n     * 注册ReferenceAnnotationBeanPostProcessor类\n     * @param registry {@link BeanDefinitionRegistry}\n     */\n    private void registerReferenceAnnotationBeanPostProcessor(BeanDefinitionRegistry registry) {\n\n        // Register @Reference Annotation Bean Processor\n        BeanRegistrar.registerInfrastructureBean(registry,\n                ReferenceAnnotationBeanPostProcessor.BEAN_NAME,\n                ReferenceAnnotationBeanPostProcessor.class);\n\n    }\n\n    /**\n     * 获取待扫描的基础包路径\n     * @param metadata\n     * @return\n     */\n    private Set<String> getPackagesToScan(AnnotationMetadata metadata) {\n        //获取@DubboComponentScan注解属性\n        AnnotationAttributes attributes = AnnotationAttributes.fromMap(\n                metadata.getAnnotationAttributes(DubboComponentScan.class.getName())\n        );\n        String[] basePackages = attributes.getStringArray(\"basePackages\");\n        Class<?>[] basePackageClasses = attributes.getClassArray(\"basePackageClasses\");\n        String[] value = attributes.getStringArray(\"value\");\n        //将basePackages、basePackageClasses、value属性指定的值合并起来\n        Set<String> packagesToScan = new LinkedHashSet<String>(Arrays.asList(value));\n        packagesToScan.addAll(Arrays.asList(basePackages));\n        for (Class<?> basePackageClass : basePackageClasses) {\n            //通过basePackageClass获取包名\n            packagesToScan.add(ClassUtils.getPackageName(basePackageClass));\n        }\n        if (packagesToScan.isEmpty()) {\n            //如果没有配置基础包路径的话，则取包名作为基础包路径\n            return Collections.singleton(ClassUtils.getPackageName(metadata.getClassName()));\n        }\n        return packagesToScan;\n    }\n}\n```\n\n#### EnableDubboConfig注解\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\n@Import(DubboConfigConfigurationSelector.class)\npublic @interface EnableDubboConfig {\n    /**\n     * 表明是否绑定到多个Spring-Bean,默认是false\n     */\n    boolean multiple() default false;\n}\n\n/**\n * 该类实现了ImportSelector接口，此接口是Spring中导入外部配置的核心接口，有兴趣的读者可以去了解下，这里就不多做介绍了。\n * Dubbo {@link AbstractConfig Config} Registrar\n * @see EnableDubboConfig\n * @see DubboConfigConfiguration\n * @since 2.5.8\n */\npublic class DubboConfigConfigurationSelector implements ImportSelector, Ordered {\n\n    /**\n     * 要导入到Spring容器中的组件全类名\n     * @param importingClassMetadata\n     * @return\n     */\n    @Override\n    public String[] selectImports(AnnotationMetadata importingClassMetadata) {\n\n        AnnotationAttributes attributes = AnnotationAttributes.fromMap(\n                importingClassMetadata\n                        .getAnnotationAttributes(EnableDubboConfig.class.getName())\n        );\n\n        //是否绑定到多个Spring-Bean\n        boolean multiple = attributes.getBoolean(\"multiple\");\n\n        if (multiple) {\n            //返回多dubbo配置bean绑定\n            return of(DubboConfigConfiguration.Multiple.class.getName());\n        } else {\n            return of(DubboConfigConfiguration.Single.class.getName());\n        }\n    }\n\n    private static <T> T[] of(T... values) {\n        return values;\n    }\n\n    @Override\n    public int getOrder() {\n        return HIGHEST_PRECEDENCE;\n    }\n}\n\n\npublic class DubboConfigConfiguration {\n\n    /**\n     * 单Dubbo配置Bean绑定\n     * Single Dubbo {@link AbstractConfig Config} Bean Binding\n     */\n    @EnableDubboConfigBindings({\n            @EnableDubboConfigBinding(prefix = \"dubbo.application\", type = ApplicationConfig.class),\n            @EnableDubboConfigBinding(prefix = \"dubbo.module\", type = ModuleConfig.class),\n            @EnableDubboConfigBinding(prefix = \"dubbo.registry\", type = RegistryConfig.class),\n            @EnableDubboConfigBinding(prefix = \"dubbo.protocol\", type = ProtocolConfig.class),\n            @EnableDubboConfigBinding(prefix = \"dubbo.monitor\", type = MonitorConfig.class),\n            @EnableDubboConfigBinding(prefix = \"dubbo.provider\", type = ProviderConfig.class),\n            @EnableDubboConfigBinding(prefix = \"dubbo.consumer\", type = ConsumerConfig.class)\n    })\n    public static class Single {\n\n    }\n\n    /**\n     * 多Dubbo配置Bean绑定\n     * Multiple Dubbo {@link AbstractConfig Config} Bean Binding\n     */\n    @EnableDubboConfigBindings({\n            @EnableDubboConfigBinding(prefix = \"dubbo.applications\", type = ApplicationConfig.class, multiple = true),\n            @EnableDubboConfigBinding(prefix = \"dubbo.modules\", type = ModuleConfig.class, multiple = true),\n            @EnableDubboConfigBinding(prefix = \"dubbo.registries\", type = RegistryConfig.class, multiple = true),\n            @EnableDubboConfigBinding(prefix = \"dubbo.protocols\", type = ProtocolConfig.class, multiple = true),\n            @EnableDubboConfigBinding(prefix = \"dubbo.monitors\", type = MonitorConfig.class, multiple = true),\n            @EnableDubboConfigBinding(prefix = \"dubbo.providers\", type = ProviderConfig.class, multiple = true),\n            @EnableDubboConfigBinding(prefix = \"dubbo.consumers\", type = ConsumerConfig.class, multiple = true)\n    })\n    public static class Multiple {\n\n    }\n}\n```\n使用方式:\n```java\n//将以下内容的外部化配置文件物理路径为：classpath:/META-INF/multiple-config.properties:\n#多Dubbo配置Bean绑定\n## dubbo.applications\ndubbo.applications.applicationBean.name = dubbo-demo-application\ndubbo.applications.applicationBean2.name = dubbo-demo-application2\ndubbo.applications.applicationBean3.name = dubbo-demo-application3\n\n//新建配置类DubboMultipleConfiguration\n@EnableDubboConfig(multiple = true)\n@PropertySource(\"META-INF/multiple-config.properties\")\nprivate static class DubboMultipleConfiguration {\n\n} \n\n\n//测试类\npublic class DubboConfigurationBootstrap {\n\tpublic static void main(String[] args) {\n\t\t//创建配置上下文\n\t\tAnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\n\t\t//注册当前配置 Bean\n       \t\tcontext.register(DubboMultipleConfiguration.class);\n       \t\tcontext.refresh();\n\n\t\t//获取ApplicationConfig Bean：\"applicationBean\"、\"applicationBean2\" 和 \"applicationBean3\"\n\t\tApplicationConfig applicationBean = context.getBean(\"applicationBean\", ApplicationConfig.class);\n\t\tApplicationConfig applicationBean2 = context.getBean(\"applicationBean2\", ApplicationConfig.class);\n\t\tApplicationConfig applicationBean3 = context.getBean(\"applicationBean3\", ApplicationConfig.class);\n\n\t\tSystem.out.printf(\"applicationBean.name = %s \\n\", applicationBean.getName());\n\t\tSystem.out.printf(\"applicationBean2.name = %s \\n\", applicationBean2.getName());\n\t\tSystem.out.printf(\"applicationBean3.name = %s \\n\", applicationBean3.getName());\n\t}\n}\n```\n\n#### @EnableDubboConfigBinding/@EnableDubboConfigBindings注解\n@EnableDubboConfig适合绝大多数外部化配置场景,然而无论是单Bean绑定,还是多Bean绑定,其外部化配置属性前缀是固化的,如dubbo.application以及dubbo.applications.\n当应用需要自定义外部化配置属性前缀,@EnableDubboConfigBinding能提供更大的弹性，支持单个外部化配置属性前缀(prefix)与Dubbo配置Bean类型(AbstractConfig子类)绑定,如果需要多次绑定时,可使用@EnableDubboConfigBindings.\n@EnableDubboConfigBinding在支持外部化配置属性与Dubbo配置类绑定时,与Dubbo过去的映射行为不同,被绑定的Dubbo配置类将会提升为Spring Bean,无需提前装配Dubbo配置类.同时,支持多Dubbo配置Bean装配.其Bean的绑定规则与@EnableDubboConfig一致.\n\n##### @EnableDubboConfigBinding注解\n\n```java\n@Target({ElementType.TYPE, ElementType.ANNOTATION_TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Import(DubboConfigBindingRegistrar.class)\npublic @interface EnableDubboConfigBinding {\n\n    /**\n     * 指定待绑定Dubbo配置类的外部化配置属性的前缀,比如dubbo.application为 ApplicationConfig的外部化配置属性的前缀.\n     * prefix()支持占位符(Placeholder),\n     * 并且其关联前缀值是否以\".\"作为结尾字符是可选的,即\"dubbo.application\"与\"dubbo.application.\"效果相同\n     * 例如：\"dubbo.application.\" 或 \"dubbo.application\"\n     * The name prefix of the properties that are valid to bind to {@link AbstractConfig Dubbo Config}.\n     *\n     * @return the name prefix of the properties to bind\n     */\n    String prefix();\n\n    /**\n     * 绑定的Dubbo配置类型,即Dubbo配置类,所有AbstractConfig的子类都可以\n     * @return The binding type of {@link AbstractConfig Dubbo Config}.\n     * @see AbstractConfig\n     * @see ApplicationConfig\n     * @see ModuleConfig\n     * @see RegistryConfig\n     */\n    Class<? extends AbstractConfig> type();\n\n    /**\n     * 是否需要将prefix()作为多个type()类型的Spring Bean外部化配置属性,默认值为false\n     * It indicates whether {@link #prefix()} binding to multiple Spring Beans.\n     *\n     * @return the default value is <code>false</code>\n     */\n    boolean multiple() default false;\n}\n\n\n/**\n * 实现了ImportBeanDefinitionRegistrar接口，允许我们注册特定的bean到Spring中\n * {@link AbstractConfig Dubbo Config} binding Bean registrar\n *\n * @see EnableDubboConfigBinding\n * @see DubboConfigBindingBeanPostProcessor\n * @since 2.5.8\n */\npublic class DubboConfigBindingRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware {\n\n    private final Log log = LogFactory.getLog(getClass());\n\n    private ConfigurableEnvironment environment;\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n\n        //获取@EnableDubboConfigBinding注解\n        AnnotationAttributes attributes = AnnotationAttributes.fromMap(\n                importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBinding.class.getName()));\n        //处理@EnableDubboConfigBinding注解属性并注册bean\n        registerBeanDefinitions(attributes, registry);\n    }\n\n    /**\n     * 读取@EnableDubboConfigBinding注解属性值，然后注册bean\n     * @param attributes\n     * @param registry\n     */\n    protected void registerBeanDefinitions(AnnotationAttributes attributes, BeanDefinitionRegistry registry) {\n\n        //获取@EnableDubboConfigBinding注解的prefix属性，并处理占位符\n        String prefix = environment.resolvePlaceholders(attributes.getString(\"prefix\"));\n        //获取@EnableDubboConfigBinding注解的type属性\n        Class<? extends AbstractConfig> configClass = attributes.getClass(\"type\");\n        //获取@EnableDubboConfigBinding注解的multiple属性\n        boolean multiple = attributes.getBoolean(\"multiple\");\n        //注册Dubbo配置bean\n        registerDubboConfigBeans(prefix, configClass, multiple, registry);\n    }\n\n    /**\n     * 注册bean\n     * @param prefix 属性前缀\n     * @param configClass 待配置的config类\n     * @param multiple\n     * @param registry\n     */\n    private void registerDubboConfigBeans(String prefix,\n                                          Class<? extends AbstractConfig> configClass,\n                                          boolean multiple,\n                                          BeanDefinitionRegistry registry) {\n\n        /**\n         * @Configuration\n           @PropertySource(value = \"classpath:resources.properties\", ignoreResourceNotFound = false)\n           public class AppConfig { }\n         */\n        //根据prefix从配置文件中找到相关的属性值\n        //多bean绑定：\n        //prefix:\n        //  applications.prefix = dubbo.apps.\n        //properties:\n        //  applicationBean.name = dubbo-demo-application\n        //  applicationBean2.name = dubbo-demo-application2\n        //单bean绑定：prefix = dubbo.module.\n        //  dubbo.module.id = moduleBean  =>  id = moduleBean\n        //  dubbo.module.name = dubbo-demo-module => name = dubbo-demo-module\n        Map<String, String> properties = getSubProperties(environment.getPropertySources(), prefix);\n\n        //如果没有配置属性的话，则直接返回\n        if (CollectionUtils.isEmpty(properties)) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"There is no property for binding to dubbo config class [\" + configClass.getName()\n                        + \"] within prefix [\" + prefix + \"]\");\n            }\n            return;\n        }\n\n        //获取bean名称列表(即外部配置文件中配置的)\n        Set<String> beanNames = multiple ? resolveMultipleBeanNames(properties) :\n                Collections.singleton(resolveSingleBeanName(properties, configClass, registry));\n        //遍历bean名称列表\n        for (String beanName : beanNames) {\n            //最终注册bean的地方\n            registerDubboConfigBean(beanName, configClass, registry);\n            //注册DubboConfigBindingBeanPostProcessor类\n            registerDubboConfigBindingBeanPostProcessor(prefix, beanName, multiple, registry);\n        }\n    }\n\n    /**\n     * 使用beanName注册bean：configClass\n     * @param beanName\n     * @param configClass 配置类\n     * @param registry\n     */\n    private void registerDubboConfigBean(String beanName, Class<? extends AbstractConfig> configClass,\n                                         BeanDefinitionRegistry registry) {\n\n        BeanDefinitionBuilder builder = rootBeanDefinition(configClass);\n        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();\n        //使用beanName注册bean：configClass\n        registry.registerBeanDefinition(beanName, beanDefinition);\n        if (log.isInfoEnabled()) {\n            log.info(\"The dubbo config bean definition [name : \" + beanName + \", class : \" + configClass.getName() +\n                    \"] has been registered.\");\n        }\n    }\n\n    /**\n     * 注册DubboConfigBindingBeanPostProcessor类\n     * 用来处理dubbo config bean\n     * @param prefix  属性前缀\n     * @param beanName 已注册的config配置类的beanName\n     * @param multiple \n     * @param registry\n     */\n    private void registerDubboConfigBindingBeanPostProcessor(String prefix, String beanName, boolean multiple,\n                                                             BeanDefinitionRegistry registry) {\n\n        Class<?> processorClass = DubboConfigBindingBeanPostProcessor.class;\n        \n        BeanDefinitionBuilder builder = rootBeanDefinition(processorClass);\n        \n        //如果是multiple的话，则最终前缀：prefix+\".\"+beanName\n        //否则的话，最终前缀：prefix\n        String actualPrefix = multiple ? normalizePrefix(prefix) + beanName : prefix;\n        \n        //通过构造函数注入属性：prefix、beanName\n        builder.addConstructorArgValue(actualPrefix).addConstructorArgValue(beanName);\n        //获取beanDefinition\n        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();\n        //设置不可代理\n        beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n        //注册DubboConfigBindingBeanPostProcessor\n        registerWithGeneratedName(beanDefinition, registry);\n\n        if (log.isInfoEnabled()) {\n            log.info(\"The BeanPostProcessor bean definition [\" + processorClass.getName()\n                    + \"] for dubbo config bean [name : \" + beanName + \"] has been registered.\");\n        }\n    }\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        Assert.isInstanceOf(ConfigurableEnvironment.class, environment);\n        this.environment = (ConfigurableEnvironment) environment;\n    }\n\n    /**\n     * 处理多个bean名称\n     * @param properties 如：\n     *          applicationBean.name = dubbo-demo-application\n     *          applicationBean2.name = dubbo-demo-application2\n     * @return applicationBean、applicationBean2\n     */\n    private Set<String> resolveMultipleBeanNames(Map<String, String> properties) {\n        //保存已解决的beanNames\n        Set<String> beanNames = new LinkedHashSet<String>();\n        //遍历所有的属性名：applicationBean.name、applicationBean2.name\n        for (String propertyName : properties.keySet()) {\n            //获取\".\"符号在属性名中第一次出现的位置\n            //即判断是否存在\".\"\n            int index = propertyName.indexOf(\".\");\n            if (index > 0) {\n                //获取bean名称：applicationBean、applicationBean2\n                String beanName = propertyName.substring(0, index);\n                //保存bean名称\n                beanNames.add(beanName);\n            }\n        }\n        return beanNames;\n    }\n\n    /**\n     * 处理单个bean名称\n     * @param properties 如：\n     *      dubbo.module.id = moduleBean  =>  id = moduleBean\n     *      dubbo.module.name = dubbo-demo-module => name = dubbo-demo-module\n     * @param configClass dubbo配置类\n     * @param registry\n     * @return\n     */\n    private String resolveSingleBeanName(Map<String, String> properties,\n                                         Class<? extends AbstractConfig> configClass,\n                                         BeanDefinitionRegistry registry) {\n        //获取id属性作为bean的名称\n        String beanName = properties.get(\"id\");\n        if (!StringUtils.hasText(beanName)) {\n            //id属性为空的话\n            BeanDefinitionBuilder builder = rootBeanDefinition(configClass);\n            //则使用工具类生成bean名称\n            beanName = BeanDefinitionReaderUtils.generateBeanName(\n                    builder.getRawBeanDefinition(), registry\n            );\n        }\n        return beanName;\n    }\n}\n```\n可以看到，为每个注册的Config-bean都注册了一个DubboConfigBindingBeanPostProcessor类，现在我们看下DubboConfigBindingBeanPostProcessor类，该类实现了BeanPostProcessor接口,\n实现该接口，可以在bean实例化前后，增加一些自己的逻辑处理，同时也实现了InitializingBean接口.\n```java\n/**\n * Dubbo Config Binding {@link BeanPostProcessor}\n *\n * @see EnableDubboConfigBinding\n * @see DubboConfigBindingRegistrar\n * @since 2.5.8\n */\npublic class DubboConfigBindingBeanPostProcessor implements BeanPostProcessor, ApplicationContextAware, InitializingBean {\n\n    /**\n     * 配置属性的前缀\n     */\n    private final String prefix;\n\n    /**\n     * 绑定的Config配置类的beanName\n     */\n    private final String beanName;\n\n    private DubboConfigBinder dubboConfigBinder;\n\n    private ApplicationContext applicationContext;\n\n    /**\n     * 是否忽略未知字段\n     */\n    private boolean ignoreUnknownFields = true;\n\n    /**\n     * 是否忽略无效字段\n     */\n    private boolean ignoreInvalidFields = true;\n\n    /**\n     * @param prefix   配置属性的前缀\n     * @param beanName 绑定的Config配置类的beanName\n     */\n    public DubboConfigBindingBeanPostProcessor(String prefix, String beanName) {\n        Assert.notNull(prefix, \"The prefix of Configuration Properties must not be null\");\n        Assert.notNull(beanName, \"The name of bean must not be null\");\n        this.prefix = prefix;\n        this.beanName = beanName;\n    }\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        //如果当前实例化的bean的beanName和该处理器保存的beanName相同的话,说明是该实例化bean对应的处理器\n        //这个在之前介绍DubboConfigBindingRegistrar类时有介绍\n        if (beanName.equals(this.beanName) && bean instanceof AbstractConfig) {\n            AbstractConfig dubboConfig = (AbstractConfig) bean;\n            //通过prefix绑定beanName的属性\n            dubboConfigBinder.bind(prefix, dubboConfig);\n            if (log.isInfoEnabled()) {\n                log.info(\"The properties of bean [name : \" + beanName + \"] have been binding by prefix of \" +\n                        \"configuration properties : \" + prefix);\n            }\n        }\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        return bean;\n    }\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        if (dubboConfigBinder == null) {\n            try {\n                //先从BeanFactory中获取DubboConfigBinder实例\n                dubboConfigBinder = applicationContext.getBean(DubboConfigBinder.class);\n            } catch (BeansException ignored) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"DubboConfigBinder Bean can't be found in ApplicationContext.\");\n                }\n                //使用默认实现\n                dubboConfigBinder = createDubboConfigBinder(applicationContext.getEnvironment());\n            }\n        }\n        //设置是否忽略未知字段、无效字段\n        dubboConfigBinder.setIgnoreUnknownFields(ignoreUnknownFields);\n        dubboConfigBinder.setIgnoreInvalidFields(ignoreInvalidFields);\n    }\n\n    /**\n     * 创建DubboConfigBinder实例(默认实现)\n     * @param environment\n     * @return {@link DefaultDubboConfigBinder}\n     */\n    protected DubboConfigBinder createDubboConfigBinder(Environment environment) {\n        DefaultDubboConfigBinder defaultDubboConfigBinder = new DefaultDubboConfigBinder();\n        defaultDubboConfigBinder.setEnvironment(environment);\n        return defaultDubboConfigBinder;\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        this.applicationContext = applicationContext;\n    }\n}\n```\n然后我们看下使用到的DubboConfigBinder接口\n```java\npublic interface DubboConfigBinder extends EnvironmentAware {\n    /**\n     * 设置是否忽略未知字段，即是否忽略在目标对象中没有相应字段的绑定参数。默认值是“true”\n     * 设置为false，可以强制所有的绑定的参数在目标对象中必须有一个相应的字段\n     *\n     * Set whether to ignore unknown fields, that is, whether to ignore bind\n     * parameters that do not have corresponding fields in the target object.\n     * <p>Default is \"true\". Turn this off to enforce that all bind parameters\n     * must have a matching field in the target object.\n     * @see #bind\n     */\n    void setIgnoreUnknownFields(boolean ignoreUnknownFields);\n\n    /**\n     * 是否忽略无效字段，即是否忽略在目标对象中存在相应字段，但是不可访问的绑定参数\n     * 默认为“false”\n     * Set whether to ignore invalid fields, that is, whether to ignore bind\n     * parameters that have corresponding fields in the target object which are\n     * not accessible (for example because of null values in the nested path).\n     * <p>Default is \"false\".\n     *\n     * @see #bind\n     */\n    void setIgnoreInvalidFields(boolean ignoreInvalidFields);\n\n    /**\n     * 以指定的前缀绑定相关属性到Dubbo配置对象中\n     * Bind the properties to Dubbo Config Object under specified prefix.\n     *\n     * @param prefix 属性前缀\n     * @param dubboConfig dubboConfig配置类实例\n     */\n    <C extends AbstractConfig> void bind(String prefix, C dubboConfig);\n}\n\n//抽象类\npublic abstract class AbstractDubboConfigBinder implements DubboConfigBinder {\n\n    /**\n     * 属性配置\n     */\n    private Iterable<PropertySource<?>> propertySources;\n\n    private boolean ignoreUnknownFields = true;\n\n    private boolean ignoreInvalidFields = false;\n\n    /**\n     * 获取多个PropertySource\n     */\n    protected Iterable<PropertySource<?>> getPropertySources() {\n        return propertySources;\n    }\n\n    public boolean isIgnoreUnknownFields() {\n        return ignoreUnknownFields;\n    }\n\n    @Override\n    public void setIgnoreUnknownFields(boolean ignoreUnknownFields) {\n        this.ignoreUnknownFields = ignoreUnknownFields;\n    }\n\n    public boolean isIgnoreInvalidFields() {\n        return ignoreInvalidFields;\n    }\n\n    @Override\n    public void setIgnoreInvalidFields(boolean ignoreInvalidFields) {\n        this.ignoreInvalidFields = ignoreInvalidFields;\n    }\n\n    @Override\n    public final void setEnvironment(Environment environment) {\n        if (environment instanceof ConfigurableEnvironment) {\n            //从environment中获取propertySources\n            this.propertySources = ((ConfigurableEnvironment) environment).getPropertySources();\n        }\n    }\n}\n\n\n/**\n * 默认实现 基于Spring的DataBinder\n */\npublic class DefaultDubboConfigBinder extends AbstractDubboConfigBinder {\n\n    @Override\n    public <C extends AbstractConfig> void bind(String prefix, C dubboConfig) {\n        //创建DataBinder实例，绑定dubboConfig配置类\n        DataBinder dataBinder = new DataBinder(dubboConfig);\n        // Set ignored*\n        //设置是否忽略无效字段、未知字段\n        dataBinder.setIgnoreInvalidFields(isIgnoreInvalidFields());\n        dataBinder.setIgnoreUnknownFields(isIgnoreUnknownFields());\n        //从PropertySources中获取指定前缀的属性\n        Map<String, String> properties = getSubProperties(getPropertySources(), prefix);\n        //将Map转换成MutablePropertyValues对象\n        MutablePropertyValues propertyValues = new MutablePropertyValues(properties);\n        // 进行绑定\n        dataBinder.bind(propertyValues);\n    }\n}\n```\n然后看下工具类PropertySourcesUtils中的getSubProperties方法：\n```java\n/**\n * 根据属性前缀，获取所有相关的属性和属性值\n * Get Sub {@link Properties}\n * @param propertySources {@link PropertySource} Iterable\n * @param prefix          the prefix of property name\n * @return Map<String,String>\n * @see Properties\n*/\npublic static Map<String, String> getSubProperties(Iterable<PropertySource<?>> propertySources, String prefix) {\n\tMap<String, String> subProperties = new LinkedHashMap<String, String>();\n\t//规范化前缀,即前缀结尾处补上\".\"符号\n\tString normalizedPrefix = normalizePrefix(prefix);\n\t//遍历每一个PropertySource\n\tfor (PropertySource<?> source : propertySources) {\n\t    if (source instanceof EnumerablePropertySource) {\n\t\t//遍历属性名称列表，找到以normalizedPrefix开头的属性名称\n\t\t//applications.prefix = dubbo.apps.\n\t\t//dubbo.apps.applicationBean.name = dubbo-demo-application\n\t\t//dubbo.apps.applicationBean2.name = dubbo-demo-application2\n\n\t\tfor (String name : ((EnumerablePropertySource<?>) source).getPropertyNames()) {\n\t\t    if (name.startsWith(normalizedPrefix)) {\n\t\t\t//截取子名称，如：subName = applicationBean.name/applicationBean2.name\n\t\t\tString subName = name.substring(normalizedPrefix.length());\n\t\t\t//更加属性名称name获取属性值value\n\t\t\tObject value = source.getProperty(name);\n\t\t\t//保存applicationBean.name = dubbo-demo-application\n\t\t\t//保存applicationBean2.name = dubbo-demo-application2\n\t\t\tsubProperties.put(subName, String.valueOf(value));\n\t\t    }\n\t\t}\n\t    }\n\t}\n\treturn subProperties;\n}\n```\n\n##### @EnableDubboConfigBindings注解\n该注解支持配置多个@EnableDubboConfigBinding注解\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Import(DubboConfigBindingsRegistrar.class)\npublic @interface EnableDubboConfigBindings {\n    /**\n     * The value of {@link EnableDubboConfigBindings}\n     * @return non-null\n     */\n    EnableDubboConfigBinding[] value();\n}\n\n\npublic class DubboConfigBindingsRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware {\n\n    private ConfigurableEnvironment environment;\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n\n        //获取@EnableDubboConfigBindings注解的属性值\n        AnnotationAttributes attributes = AnnotationAttributes.fromMap(\n                importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBindings.class.getName()));\n\n        AnnotationAttributes[] annotationAttributes = attributes.getAnnotationArray(\"value\");\n\n        //构造DubboConfigBindingRegistrar对象\n        DubboConfigBindingRegistrar registrar = new DubboConfigBindingRegistrar();\n        registrar.setEnvironment(environment);\n        //遍历@EnableDubboConfigBinding列表,处理每一个@EnableDubboConfigBinding注解\n        for (AnnotationAttributes element : annotationAttributes) {\n            //注册DubboConfigBindingRegistrar类\n            registrar.registerBeanDefinitions(element, registry);\n        }\n    }\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        Assert.isInstanceOf(ConfigurableEnvironment.class, environment);\n        this.environment = (ConfigurableEnvironment) environment;\n    }\n}\n```\n简单看下使用:\n```java\n//将以下内容的外部化配置文件物理路径为：classpath:/META-INF/bindings.properties\n# classpath:/META-INF/bindings.properties\n## 占位符值 : ApplicationConfig 外部配置属性前缀\napplications.prefix = dubbo.apps.\n\n## 多 ApplicationConfig Bean 绑定\ndubbo.apps.applicationBean.name = dubbo-demo-application\ndubbo.apps.applicationBean2.name = dubbo-demo-application2\ndubbo.apps.applicationBean3.name = dubbo-demo-application3\n\n## 单 ModuleConfig Bean 绑定\ndubbo.module.id = moduleBean\ndubbo.module.name = dubbo-demo-module\n\n## 单 RegistryConfig Bean 绑定\ndubbo.registry.address = zookeeper://192.168.99.100:32770\n\n\n/**\n * 新建一个DubboConfiguration类作为Dubbo配置Bean，添加@EnableDubboConfigBinding注解进行绑定\n * 然后配置@PropertySource注解指定外部配置文件\n */\n@EnableDubboConfigBindings({\n@EnableDubboConfigBinding(prefix = \"${applications.prefix}\",\n               type = ApplicationConfig.class, multiple = true), //多ApplicationConfig Bean绑定\n@EnableDubboConfigBinding(prefix = \"dubbo.module\", //不带\".\"后缀\n               type = ModuleConfig.class), //单ModuleConfig Bean绑定\n@EnableDubboConfigBinding(prefix = \"dubbo.registry.\", //带\".\"后缀\n               type = RegistryConfig.class) //单RegistryConfig Bean绑定\n})\n@PropertySource(\"META-INF/bindings.properties\")\n@Configuration\npublic class DubboConfiguration {\n\n}\n\n//新建测试类\npublic class DubboConfigurationBootstrap {\n\n\tpublic static void main(String[] args) {\n\t\t//创建配置上下文\n\t\tAnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\n\t\t//注册当前配置 Bean\n\t\tcontext.register(DubboConfiguration.class);\n\t\tcontext.refresh();\n\n\t\t//获取ApplicationConfig Bean：\"applicationBean\"、\"applicationBean2\" 和 \"applicationBean3\"\n\t\tApplicationConfig applicationBean = context.getBean(\"applicationBean\", ApplicationConfig.class);\n\t\tApplicationConfig applicationBean2 = context.getBean(\"applicationBean2\", ApplicationConfig.class);\n\t\tApplicationConfig applicationBean3 = context.getBean(\"applicationBean3\", ApplicationConfig.class);\n\t\t\n\t\t//applicationBean.name = dubbo-demo-application \n\t\t//applicationBean2.name = dubbo-demo-application2 \n\t\tcapplicationBean3.name = dubbo-demo-application3 \n\t\tSystem.out.printf(\"applicationBean.name = %s \\n\", applicationBean.getName());\n\t\tSystem.out.printf(\"applicationBean2.name = %s \\n\", applicationBean2.getName());\n\t\tSystem.out.printf(\"applicationBean3.name = %s \\n\", applicationBean3.getName());\n\n\t\t//获取ModuleConfig Bean：\"moduleBean\"\n\t\tModuleConfig moduleBean = context.getBean(\"moduleBean\", ModuleConfig.class);\n\t\t//moduleBean.name = dubbo-demo-module \n\t\tSystem.out.printf(\"moduleBean.name = %s \\n\", moduleBean.getName()); \n\n\t\t//获取RegistryConfig Bean\n\t\tRegistryConfig registry = context.getBean(RegistryConfig.class);\n\t\t//registry.address = zookeeper://192.168.99.100:32770 \n\t\tSystem.out.printf(\"registry.address = %s \\n\", registry.getAddress());\n\t}\n}\n```\n\n#### @EnableDubbo注解\n该注解等同于组合使用@DubboComponentScan和@EnableDubboConfig，上文已经介绍过，这里就不多介绍了。\n```java\n/**\n * 启用Dubbo组件作为SpringBean\n * 等同于组合使用@DubboComponentScan和@EnableDubboConfig\n */\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\n@EnableDubboConfig\n@DubboComponentScan\npublic @interface EnableDubbo {\n\n    /**\n     * 扫描@Service基础包路径\n     * Base packages to scan for annotated @Service classes.\n     * <p>\n     * Use {@link #scanBasePackageClasses()} for a type-safe alternative to String-based\n     * package names.\n     *\n     * @return the base packages to scan\n     * @see DubboComponentScan#basePackages()\n     */\n    @AliasFor(annotation = DubboComponentScan.class, attribute = \"basePackages\")\n    String[] scanBasePackages() default {};\n\n    /**\n     * Type-safe alternative to {@link #scanBasePackages()} for specifying the packages to\n     * scan for annotated @Service classes. The package of each class specified will be\n     * scanned.\n     *\n     * @return classes from the base packages to scan\n     * @see DubboComponentScan#basePackageClasses\n     */\n    @AliasFor(annotation = DubboComponentScan.class, attribute = \"basePackageClasses\")\n    Class<?>[] scanBasePackageClasses() default {};\n\n\n    /**\n     *\n     * It indicates whether {@link AbstractConfig} binding to multiple Spring Beans.\n     *\n     * @return the default value is <code>false</code>\n     * @see EnableDubboConfig#multiple()\n     */\n    @AliasFor(annotation = EnableDubboConfig.class, attribute = \"multiple\")\n    boolean multipleConfig() default false;\n}\n```\n\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之集成Spring注解解析(0202)","url":"/blog/2018/08/07/Dubbo源码阅读之集成Spring-0202注解解析/","content":">本小节将会介绍ReferenceAnnotationBeanPostProcessor类的实现\n\n### ReferenceAnnotationBeanPostProcessor类\n该类用来处理@Reference注解，它实现了BeanPostProcessor接口,实现postProcessPropertyValues方法可以处理每一个属性\n```java\npublic class ReferenceAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter\n        implements MergedBeanDefinitionPostProcessor, PriorityOrdered, ApplicationContextAware,BeanClassLoaderAware, DisposableBean {\n\n    /**\n     * ReferenceAnnotationBeanPostProcessor的bean-name\n     */\n    public static final String BEAN_NAME = \"referenceAnnotationBeanPostProcessor\";\n\n    private ApplicationContext applicationContext;\n\n    private ClassLoader classLoader;\n\n    /**\n     * beanName/className,ReferenceInjectionMetadata\n     */\n    private final ConcurrentMap<String, ReferenceInjectionMetadata> injectionMetadataCache =\n            new ConcurrentHashMap<String, ReferenceInjectionMetadata>(256);\n\n    /**\n     * cacheKey,referenceBean\n     */\n    private final ConcurrentMap<String, ReferenceBean<?>> referenceBeansCache =\n            new ConcurrentHashMap<String, ReferenceBean<?>>();\n\n    /**\n     * 设置某个属性时调用\n     * @param pvs\n     * @param pds\n     * @param bean\n     * @param beanName\n     * @return\n     * @throws BeanCreationException\n     */\n    @Override\n    public PropertyValues postProcessPropertyValues(\n            PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeanCreationException {\n        //获取bean的@Reference元数据信息\n        InjectionMetadata metadata = findReferenceMetadata(beanName, bean.getClass(), pvs);\n        try {\n            //对Bean的属性进行自动注入\n            //最终会调用内部类ReferenceFieldElement和ReferenceMethodElement的inject方法(后面会介绍)\n            metadata.inject(bean, beanName, pvs);\n        } catch (BeanCreationException ex) {\n            throw ex;\n        } catch (Throwable ex) {\n            throw new BeanCreationException(beanName, \"Injection of @Reference dependencies failed\", ex);\n        }\n        return pvs;\n    }\n\n    /**\n     * 获取clazz的@Reference元数据信息\n     * @param beanName 当前bean的名称\n     * @param clazz    当前bean的class\n     * @param pvs      当前bean的属性\n     * @return\n     */\n    private InjectionMetadata findReferenceMetadata(String beanName, Class<?> clazz, PropertyValues pvs) {\n        // Fall back to class name as cache key, for backwards compatibility with custom callers.\n        //使用beanName或者当前bean的类名称作为cacheKey\n        String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());\n        // 先从缓存中查询该cacheKey\n        ReferenceInjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);\n        //是否需要刷新(metadata == null || metadata.targetClass != clazz;则需要刷新)\n        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n            synchronized (this.injectionMetadataCache) {\n                metadata = this.injectionMetadataCache.get(cacheKey);\n                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n                    if (metadata != null) {\n                        metadata.clear(pvs);\n                    }\n                    try {\n                        //获取clazz中被@Reference注解标注的元数据信息(字段、方法)\n                        metadata = buildReferenceMetadata(clazz);\n                        //放入缓存\n                        this.injectionMetadataCache.put(cacheKey, metadata);\n                    } catch (NoClassDefFoundError err) {\n                        throw new IllegalStateException(\"Failed to introspect bean class [\" + clazz.getName() +\n                                \"] for reference metadata: could not find class that it depends on\", err);\n                    }\n                }\n            }\n        }\n        return metadata;\n    }\n\n    /**\n     * 获取beanClass类中被@Reference注解标注的方法和字段\n     * @param beanClass\n     * @return\n     */\n    private ReferenceInjectionMetadata buildReferenceMetadata(final Class<?> beanClass) {\n        //查到beanClass中存在@Reference注解的字段\n        Collection<ReferenceFieldElement> fieldElements = findFieldReferenceMetadata(beanClass);\n        //查到beanClass中存在@Reference注解的方法\n        Collection<ReferenceMethodElement> methodElements = findMethodReferenceMetadata(beanClass);\n        //创建新的元数据信息\n        return new ReferenceInjectionMetadata(beanClass, fieldElements, methodElements);\n    }\n\n\n    /**\n     * 从给定的类中查询到所有标注@Reference注解的字段\n     * 然后根据该字段和@Reference注解\n     * 创建ReferenceFieldElement类(InjectionMetadata.InjectedElement的子类)\n     * @param beanClass 当前bean的class\n     * @return non-null\n     */\n    private List<ReferenceFieldElement> findFieldReferenceMetadata(final Class<?> beanClass) {\n\n        final List<ReferenceFieldElement> elements = new LinkedList<ReferenceFieldElement>();\n        //操作字段时执行的回调\n        ReflectionUtils.doWithFields(beanClass, new ReflectionUtils.FieldCallback() {\n            @Override\n            public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException {\n                //获取字段上的@Reference注解\n                Reference reference = getAnnotation(field, Reference.class);\n                //是否存在@Reference注解\n                if (reference != null) {\n                    if (Modifier.isStatic(field.getModifiers())) {\n                        if (logger.isWarnEnabled()) {\n                            //@Reference不支持静态字段字段\n                            logger.warn(\"@Reference annotation is not supported on static fields: \" + field);\n                        }\n                        return;\n                    }\n                    //根据字段和@Reference注解创建ReferenceFieldElement对象,并保存\n                    elements.add(new ReferenceFieldElement(field, reference));\n                }\n            }\n        });\n        return elements;\n    }\n\n    /**\n     * 从标注@Reference注解的方法上找到（InjectionMetadata.InjectedElement）元数据\n     * @param beanClass 目标bean的class\n     * @return non-null {@link List}\n     */\n    private List<ReferenceMethodElement> findMethodReferenceMetadata(final Class<?> beanClass) {\n\n        final List<ReferenceMethodElement> elements = new LinkedList<ReferenceMethodElement>();\n\n        //操作方法时调用\n        ReflectionUtils.doWithMethods(beanClass, new ReflectionUtils.MethodCallback() {\n            @Override\n            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {\n\n                //获取桥接方法(https://blog.csdn.net/mhmyqn/article/details/47342577)\n                Method bridgedMethod = findBridgedMethod(method);\n\n                //参数和返回类型签名相同返回true\n                if (!isVisibilityBridgeMethodPair(method, bridgedMethod)) {\n                    return;\n                }\n                //从桥接方法上找到@Reference注解\n                Reference reference = findAnnotation(bridgedMethod, Reference.class);\n\n                //ClassUtils.getMostSpecificMethod\n                //通过给定的方法(可能来自接口)和当前反射调用中使用的目标类,找到相应的目标方法\n                if (reference != null && method.equals(ClassUtils.getMostSpecificMethod(method, beanClass))) {\n                    if (Modifier.isStatic(method.getModifiers())) {\n                        if (logger.isWarnEnabled()) {\n                            //@Reference不支持static方法\n                            logger.warn(\"@Reference annotation is not supported on static methods: \" + method);\n                        }\n                        return;\n                    }\n                    if (method.getParameterTypes().length == 0) {\n                        //@Reference注解只能用于带参数的方法\n                        if (logger.isWarnEnabled()) {\n                            logger.warn(\"@Reference  annotation should only be used on methods with parameters: \" +\n                                    method);\n                        }\n                    }\n                    //获取bridgedMethod方法的属性描述\n                    PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, beanClass);\n                    //创建ReferenceMethodElement对象，并保存\n                    elements.add(new ReferenceMethodElement(method, pd, reference));\n                }\n            }\n        });\n        return elements;\n    }\n\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        this.applicationContext = applicationContext;\n    }\n\n    @Override\n    public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n        if (beanType != null) {\n            InjectionMetadata metadata = findReferenceMetadata(beanName, beanType, null);\n            metadata.checkConfigMembers(beanDefinition);\n        }\n    }\n\n    @Override\n    public int getOrder() {\n        return LOWEST_PRECEDENCE;\n    }\n\n    @Override\n    public void destroy() throws Exception {\n\n        for (ReferenceBean referenceBean : referenceBeansCache.values()) {\n            if (logger.isInfoEnabled()) {\n                logger.info(referenceBean + \" was destroying!\");\n            }\n            //销毁referenceBean\n            referenceBean.destroy();\n        }\n        //清空injectionMetadataCache/referenceBeansCache\n        injectionMetadataCache.clear();\n        referenceBeansCache.clear();\n\n        if (logger.isInfoEnabled()) {\n            logger.info(getClass() + \" was destroying!\");\n        }\n    }\n\n    @Override\n    public void setBeanClassLoader(ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    /**\n     * 获取所有的ReferenceBean\n     * @return non-null {@link Collection}\n     * @since 2.5.9\n     */\n    public Collection<ReferenceBean<?>> getReferenceBeans() {\n        return this.referenceBeansCache.values();\n    }\n```\n##### ReferenceInjectionMetadata内部类\n```java\n    /**\n     * {@link Reference} {@link InjectionMetadata} implementation\n     *\n     * @since 2.5.11\n     */\n    private static class ReferenceInjectionMetadata extends InjectionMetadata {\n\n        private final Collection<ReferenceFieldElement> fieldElements;\n\n        private final Collection<ReferenceMethodElement> methodElements;\n\n        /**\n         * @param targetClass 目标类\n         * @param fieldElements 存在@Reference注解的字段\n         * @param methodElements 存在@Reference注解的方法\n         */\n        public ReferenceInjectionMetadata(Class<?> targetClass, Collection<ReferenceFieldElement> fieldElements,\n                                          Collection<ReferenceMethodElement> methodElements) {\n            super(targetClass, combine(fieldElements, methodElements));\n            this.fieldElements = fieldElements;\n            this.methodElements = methodElements;\n        }\n\n        /**\n         * 将fieldElements和methodElements进行合并\n         * @param elements\n         * @param <T>\n         * @return\n         */\n        private static <T> Collection<T> combine(Collection<? extends T>... elements) {\n            List<T> allElements = new ArrayList<T>();\n            for (Collection<? extends T> e : elements) {\n                allElements.addAll(e);\n            }\n            return allElements;\n        }\n\n        public Collection<ReferenceFieldElement> getFieldElements() {\n            return fieldElements;\n        }\n\n        public Collection<ReferenceMethodElement> getMethodElements() {\n            return methodElements;\n        }\n    }\n```\n\n##### ReferenceMethodElement内部类\n```java\n   /**\n     * 内部类，方法元数据，最终会调用该类的inject方法进行注入\n     */\n    private class ReferenceMethodElement extends InjectionMetadata.InjectedElement {\n\n        /**\n         * 标注@Reference注解的方法\n         */\n        private final Method method;\n\n        private final Reference reference;\n\t\n\t/**\n\t * 新生成的referenceBean\n\t */\n        private volatile ReferenceBean<?> referenceBean;\n\n        /**\n         * @param method\n         * @param pd 方法属性描述符\n         * @param reference\n         */\n        protected ReferenceMethodElement(Method method, PropertyDescriptor pd, Reference reference) {\n            super(method, pd);\n            this.method = method;\n            this.reference = reference;\n        }\n\n        @Override\n        protected void inject(Object bean, String beanName, PropertyValues pvs) throws Throwable {\n            //获取referenceClass\n            Class<?> referenceClass = pd.getPropertyType();\n            //获取referenceClass对应的referenceBean\n            referenceBean = buildReferenceBean(reference, referenceClass);\n\n            ReflectionUtils.makeAccessible(method);\n            //调用bean的method，注入依赖\n            method.invoke(bean, referenceBean.getObject());\n        }\n    }\n```\n##### ReferenceFieldElement内部类\n```java\n    /**\n     * 内部类，字段元数据，最终会调用该类的inject方法进行注入\n     */\n    private class ReferenceFieldElement extends InjectionMetadata.InjectedElement {\n        /**\n         * 标注@Reference注解的字段\n         */\n        private final Field field;\n\n        private final Reference reference;\n\n        private volatile ReferenceBean<?> referenceBean;\n\n        protected ReferenceFieldElement(Field field, Reference reference) {\n            super(field, null);\n            this.field = field;\n            this.reference = reference;\n        }\n\n        /**\n         * 注入\n         * @param bean  目标bean\n         * @param beanName 目标bean-name\n         * @param pvs\n         * @throws Throwable\n         */\n        @Override\n        protected void inject(Object bean, String beanName, PropertyValues pvs) throws Throwable {\n\n            //被@Reference注解标识的字段的类型\n            Class<?> referenceClass = field.getType();\n            //获取referenceClass对应的referenceBean\n            referenceBean = buildReferenceBean(reference, referenceClass);\n\n            ReflectionUtils.makeAccessible(field);\n            //注入依赖到目标bean中\n            field.set(bean, referenceBean.getObject());\n        }\n    }\n```\n##### buildReferenceBean方法\n```java\n    /**\n     * 根据@Reference注解和referenceClass生成ReferenceBean\n     * @param reference\n     * @param referenceClass 被@Reference注解标注的字段类型\n     * @return\n     * @throws Exception\n     */\n    private ReferenceBean<?> buildReferenceBean(Reference reference, Class<?> referenceClass) throws Exception {\n\n        //根据@Reference注解和referenceClass 生成缓存key\n        String referenceBeanCacheKey = generateReferenceBeanCacheKey(reference, referenceClass);\n\n        //先从缓存中获取ReferenceBean\n        ReferenceBean<?> referenceBean = referenceBeansCache.get(referenceBeanCacheKey);\n\n        if (referenceBean == null) {\n            //生成一个referenceBean并放入缓存(后面会分析该方法)\n            ReferenceBeanBuilder beanBuilder = ReferenceBeanBuilder\n                    .create(reference, classLoader, applicationContext)\n                    .interfaceClass(referenceClass);\n            referenceBean = beanBuilder.build();\n            referenceBeansCache.putIfAbsent(referenceBeanCacheKey, referenceBean);\n        }\n        return referenceBean;\n\n    }\n```\n```java\n    /**\n     * 为ReferenceBean创建一个缓存key\n     * @param reference {@link Reference}\n     * @param beanClass {@link Class}\n     * @return\n     */\n    private String generateReferenceBeanCacheKey(Reference reference, Class<?> beanClass) {\n        //获取接口名称(后面会分析该方法)\n        String interfaceName = resolveInterfaceName(reference, beanClass);\n        //生成缓存key\n        String key = reference.url() + \"/\" + interfaceName +\n                \"/\" + reference.version() +\n                \"/\" + reference.group();\n\n        Environment environment = applicationContext.getEnvironment();\n        //处理占位符\n        key = environment.resolvePlaceholders(key);\n        return key;\n    }\n\n    /**\n     * 获取接口名称interfaceName\n     * 先从@Reference注解属性找，找不到则取被注解的接口变量名称\n     * @param reference @Reference注解\n     * @param beanClass 被@Reference注解标注的类\n     * @return\n     * @throws IllegalStateException\n     */\n    private static String resolveInterfaceName(Reference reference, Class<?> beanClass)\n            throws IllegalStateException {\n\n        String interfaceName;\n        if (!\"\".equals(reference.interfaceName())) {\n            // @Reference注解的interfaceName属性不为空\n            interfaceName = reference.interfaceName();\n        } else if (!void.class.equals(reference.interfaceClass())) {\n            // @Reference注解的interfaceClass属性不为void\n            interfaceName = reference.interfaceClass().getName();\n        } else if (beanClass.isInterface()) {\n            // 被@Reference注解标注的类是接口类型\n            interfaceName = beanClass.getName();\n        } else {\n            //@Reference没有定义interfaceClass/interfaceName属性，beanClass不是一个接口\n            throw new IllegalStateException(\n                    \"The @Reference undefined interfaceClass or interfaceName, and the property type \"\n                            + beanClass.getName() + \" is not a interface.\");\n        }\n        return interfaceName;\n    }\n\n\n    /**\n     * 获取<field,ReferenceBean>\n     *\n     * @return non-null {@link Map}\n     * @since 2.5.11\n     */\n    public Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> getInjectedFieldReferenceBeanMap() {\n\n        Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> injectedElementReferenceBeanMap =\n                new LinkedHashMap<InjectionMetadata.InjectedElement, ReferenceBean<?>>();\n        for (ReferenceInjectionMetadata metadata : injectionMetadataCache.values()) {\n            Collection<ReferenceFieldElement> fieldElements = metadata.getFieldElements();\n            for (ReferenceFieldElement fieldElement : fieldElements) {\n                injectedElementReferenceBeanMap.put(fieldElement, fieldElement.referenceBean);\n            }\n        }\n        return injectedElementReferenceBeanMap;\n    }\n\n    /**\n     * 获取<方法，ReferenceBean>\n     * @return non-null {@link Map}\n     * @since 2.5.11\n     */\n    public Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> getInjectedMethodReferenceBeanMap() {\n\n        Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> injectedElementReferenceBeanMap =\n                new LinkedHashMap<InjectionMetadata.InjectedElement, ReferenceBean<?>>();\n\n        for (ReferenceInjectionMetadata metadata : injectionMetadataCache.values()) {\n            Collection<ReferenceMethodElement> methodElements = metadata.getMethodElements();\n            for (ReferenceMethodElement methodElement : methodElements) {\n                injectedElementReferenceBeanMap.put(methodElement, methodElement.referenceBean);\n            }\n        }\n        return injectedElementReferenceBeanMap;\n    }\n}\n```\n\n##### AbstractAnnotationConfigBeanBuilder类\n接下来我们看下ReferenceBean的创建\n\n```java\n//创建ReferenceBean\nReferenceBeanBuilder beanBuilder = ReferenceBeanBuilder\n          //create方法创建了ReferenceBeanBuilder实例\n\t  .create(reference, classLoader, applicationContext)\n\t  //设置referenceClass\n          .interfaceClass(referenceClass);\n//build方法创建ReferenceBean类\nReferenceBean<?> referenceBean = beanBuilder.build();\n```\n\n我们是通过ReferenceBeanBuilder类创建ReferenceBean的，而ReferenceBeanBuilder继承自AbstractAnnotationConfigBeanBuilder,\nAbstractAnnotationConfigBeanBuilder定义了创建配置bean的算法骨架(即build模板方法)，其他步骤都由子类ReferenceBeanBuilder负责实现。\n```java\n/**\n * Annotation bean配置构造器\n * Abstract Configurable {@link Annotation} Bean Builder\n * @since 2.5.7\n */\nabstract class AbstractAnnotationConfigBeanBuilder<A extends Annotation, B extends AbstractInterfaceConfig> {\n\n    protected final Log logger = LogFactory.getLog(getClass());\n\n    /**\n     * 注解\n     */\n    protected final A annotation;\n\n    protected final ApplicationContext applicationContext;\n\n    protected final ClassLoader classLoader;\n\n    protected Object bean;\n\n    /**\n     * 接口类\n     */\n    protected Class<?> interfaceClass;\n\n    protected AbstractAnnotationConfigBeanBuilder(A annotation, ClassLoader classLoader,\n                                                  ApplicationContext applicationContext) {\n        Assert.notNull(annotation, \"The Annotation must not be null!\");\n        Assert.notNull(classLoader, \"The ClassLoader must not be null!\");\n        Assert.notNull(applicationContext, \"The ApplicationContext must not be null!\");\n        this.annotation = annotation;\n        this.applicationContext = applicationContext;\n        this.classLoader = classLoader;\n    }\n\n    /**\n     * Build {@link B}\n     * @return non-null\n     * @throws Exception\n     */\n    public final B build() throws Exception {\n        //检测依赖\n        checkDependencies();\n        //构建B（子类实现）\n        B bean = doBuild();\n        //配置B\n        configureBean(bean);\n\n        if (logger.isInfoEnabled()) {\n            logger.info(bean + \" has been built.\");\n        }\n        return bean;\n\n    }\n\n    private void checkDependencies() {\n\n    }\n\n    /**\n     * Builds {@link B Bean}\n     *\n     * @return {@link B Bean}\n     */\n    protected abstract B doBuild();\n\n\n    protected void configureBean(B bean) throws Exception {\n\n        //子类实现\n        preConfigureBean(annotation, bean);\n\n        //配置RegistryConfig(即将RegistryConfig实例注入到B对象中)\n        configureRegistryConfigs(bean);\n\n        //配置MonitorConfig\n        configureMonitorConfig(bean);\n\n        //配置ApplicationConfig\n        configureApplicationConfig(bean);\n\n        //配置ModuleConfig\n        configureModuleConfig(bean);\n\n        //子类实现\n        postConfigureBean(annotation, bean);\n    }\n\n    protected abstract void preConfigureBean(A annotation, B bean) throws Exception;\n\n\n    /**\n     * 配置RegistryConfig\n     * @param bean\n     */\n    private void configureRegistryConfigs(B bean) {\n        //获取RegistryConfig的bean-names\n        String[] registryConfigBeanIds = resolveRegistryConfigBeanNames(annotation);\n        //根据bean-names从工厂中获取RegistryConfig实例\n        List<RegistryConfig> registryConfigs = getBeans(applicationContext, registryConfigBeanIds, RegistryConfig.class);\n        //将registryConfigs注入到B中\n        bean.setRegistries(registryConfigs);\n    }\n\n    /**\n     * 配置MonitorConfig\n     * @param bean\n     */\n    private void configureMonitorConfig(B bean) {\n        //获取MonitorConfig的bean-names\n        String monitorBeanName = resolveMonitorConfigBeanName(annotation);\n        //获取monitorConfig实例\n        MonitorConfig monitorConfig = getOptionalBean(applicationContext, monitorBeanName, MonitorConfig.class);\n        //将registryConfigs注入到B中\n        bean.setMonitor(monitorConfig);\n\n    }\n\n    /**\n     * 配置ApplicationConfig\n     * @param bean\n     */\n    private void configureApplicationConfig(B bean) {\n        //获取ApplicationConfig的bean-names\n        String applicationConfigBeanName = resolveApplicationConfigBeanName(annotation);\n\n        ApplicationConfig applicationConfig =\n                getOptionalBean(applicationContext, applicationConfigBeanName, ApplicationConfig.class);\n\n        bean.setApplication(applicationConfig);\n    }\n\n    /**\n     * 配置ModuleConfig\n     * @param bean\n     */\n    private void configureModuleConfig(B bean) {\n        //获取ModuleConfig的bean-names\n        String moduleConfigBeanName = resolveModuleConfigBeanName(annotation);\n\n        ModuleConfig moduleConfig =\n                getOptionalBean(applicationContext, moduleConfigBeanName, ModuleConfig.class);\n\n        bean.setModule(moduleConfig);\n\n    }\n\n    /**\n     * Resolves the bean name of {@link ModuleConfig}\n     *\n     * @param annotation {@link A}\n     * @return\n     */\n    protected abstract String resolveModuleConfigBeanName(A annotation);\n\n    /**\n     * Resolves the bean name of {@link ApplicationConfig}\n     *\n     * @param annotation {@link A}\n     * @return\n     */\n    protected abstract String resolveApplicationConfigBeanName(A annotation);\n\n\n    /**\n     * Resolves the bean ids of {@link com.alibaba.dubbo.config.RegistryConfig}\n     *\n     * @param annotation {@link A}\n     * @return non-empty array\n     */\n    protected abstract String[] resolveRegistryConfigBeanNames(A annotation);\n\n    /**\n     * Resolves the bean name of {@link MonitorConfig}\n     *\n     * @param annotation {@link A}\n     * @return\n     */\n    protected abstract String resolveMonitorConfigBeanName(A annotation);\n\n    /**\n     * Configures Bean\n     *\n     * @param annotation\n     * @param bean\n     */\n    protected abstract void postConfigureBean(A annotation, B bean) throws Exception;\n\n\n    public <T extends AbstractAnnotationConfigBeanBuilder<A, B>> T bean(Object bean) {\n        this.bean = bean;\n        return (T) this;\n    }\n\n    public <T extends AbstractAnnotationConfigBeanBuilder<A, B>> T interfaceClass(Class<?> interfaceClass) {\n        this.interfaceClass = interfaceClass;\n        return (T) this;\n    }\n}\n```\n##### ReferenceBeanBuilder实现类\n\n我们接下来看ReferenceBeanBuilder实现类\n```java\n/**\n * ReferenceBean 构造器\n */\nclass ReferenceBeanBuilder extends AbstractAnnotationConfigBeanBuilder<Reference, ReferenceBean> {\n\t\n    private ReferenceBeanBuilder(Reference annotation, ClassLoader classLoader, ApplicationContext applicationContext) {\n        super(annotation, classLoader, applicationContext);\n    }\n\n    /**\n     * 设置referenceBean实例的interfaceClass属性\n     * @param reference\n     * @param referenceBean\n     */\n    private void configureInterface(Reference reference, ReferenceBean referenceBean) {\n\n        //获取@Reference注解的interfaceClass属性\n        Class<?> interfaceClass = reference.interfaceClass();\n\n        if (void.class.equals(interfaceClass)) {\n            interfaceClass = null;\n            //interfaceClass属性没有配置,则取interfaceName属性\n            String interfaceClassName = reference.interfaceName();\n            if (StringUtils.hasText(interfaceClassName)) {\n                if (ClassUtils.isPresent(interfaceClassName, classLoader)) {\n                    //加载interfaceClassName类，作为interfaceClass\n                    interfaceClass = ClassUtils.resolveClassName(interfaceClassName, classLoader);\n                }\n            }\n        }\n        if (interfaceClass == null) {\n            //如果@Reference注解没有配置interfaceClass属性和interfaceName属性\n            //则使用创建对象时使用的interfaceClass\n            interfaceClass = this.interfaceClass;\n        }\n        //校验interfaceClass是接口类型\n        Assert.isTrue(interfaceClass.isInterface(),\n                \"The class of field or method that was annotated @Reference is not an interface!\");\n        //设置referenceBean对象的interfaceClass\n        referenceBean.setInterface(interfaceClass);\n    }\n\n\n    /**\n     * 设置referenceBean实例的consumer属性\n     * @param reference\n     * @param referenceBean\n     */\n    private void configureConsumerConfig(Reference reference, ReferenceBean<?> referenceBean) {\n        //获取@Reference注解的consumer属性\n        String consumerBeanName = reference.consumer();\n        //从工厂中获取ConsumerConfig实例\n        ConsumerConfig consumerConfig = getOptionalBean(applicationContext, consumerBeanName, ConsumerConfig.class);\n        //设置referenceBean实例的consumer属性\n        referenceBean.setConsumer(consumerConfig);\n    }\n\n    @Override\n    protected ReferenceBean doBuild() {\n        //创建ReferenceBean对象\n        return new ReferenceBean<Object>();\n    }\n\n    @Override\n    protected void preConfigureBean(Reference reference, ReferenceBean referenceBean) {\n        Assert.notNull(interfaceClass, \"The interface class must set first!\");\n\n        //根据referenceBean创建数据绑定对象\n        DataBinder dataBinder = new DataBinder(referenceBean);\n        //设置转换器\n        dataBinder.setConversionService(getConversionService());\n        //忽略的属性名称\n        String[] ignoreAttributeNames = of(\"application\", \"module\", \"consumer\", \"monitor\", \"registry\");\n        //dataBinder.setDisallowedFields(ignoreAttributeNames)\n        //绑定注解属性\n        dataBinder.bind(new AnnotationPropertyValuesAdapter(reference, applicationContext.getEnvironment(), ignoreAttributeNames));\n    }\n\n    /**\n     * 获取ConversionService\n     * @return\n     */\n    private ConversionService getConversionService() {\n        //创建默认转换器\n        DefaultConversionService conversionService = new DefaultConversionService();\n        //添加StringArray到String的转换\n        conversionService.addConverter(new StringArrayToStringConverter());\n        //添加StringArray到Map的转换\n        conversionService.addConverter(new StringArrayToMapConverter());\n        return conversionService;\n    }\n\n\n    @Override\n    protected String resolveModuleConfigBeanName(Reference annotation) {\n        //获取@Reference注解的module属性\n        return annotation.module();\n    }\n\n    @Override\n    protected String resolveApplicationConfigBeanName(Reference annotation) {\n        //获取@Reference注解的application属性\n        return annotation.application();\n    }\n\n    @Override\n    protected String[] resolveRegistryConfigBeanNames(Reference annotation) {\n        //获取@Reference注解的registry属性\n        return annotation.registry();\n    }\n\n    @Override\n    protected String resolveMonitorConfigBeanName(Reference annotation) {\n        //获取@Reference注解的monitor属性\n        return annotation.monitor();\n    }\n\n    @Override\n    protected void postConfigureBean(Reference annotation, ReferenceBean bean) throws Exception {\n\n        //设置applicationContext属性\n        bean.setApplicationContext(applicationContext);\n        //设置interfaceClass属性\n        configureInterface(annotation, bean);\n        //设置consumer属性\n        configureConsumerConfig(annotation, bean);\n        //属性都设置完了，开始调用bean的afterPropertiesSet方法(可见ReferenceBean实现了InitializingBean接口)\n        //在afterPropertiesSet()方法中会校验consumer/application/module/registry/monitor等属性是否为空，\n\t//为空的话,会从Spring容器中再次获取下,并重新赋值,然后会根据配置是否立即初始化该bean\n\tbean.afterPropertiesSet();\n    }\n\n    /**\n     * 创建ReferenceBeanBuilder实例\n     * @param annotation\n     * @param classLoader\n     * @param applicationContext\n     * @return\n     */\n    public static ReferenceBeanBuilder create(Reference annotation, ClassLoader classLoader,\n                                              ApplicationContext applicationContext) {\n        return new ReferenceBeanBuilder(annotation, classLoader, applicationContext);\n    }\n}\n```\n\n##### ReferenceBean类\n\n接下来来看ReferenceBean类,该类继承自ReferenceConfig类,并实现了FactoryBean接口。\n```java\n/**\n * ReferenceFactoryBean\n * @export\n */\npublic class ReferenceBean<T> extends ReferenceConfig<T> implements FactoryBean,\n        ApplicationContextAware, InitializingBean, DisposableBean {\n\n    private transient ApplicationContext applicationContext;\n\n    public ReferenceBean() {\n        super();\n    }\n\n    public ReferenceBean(Reference reference) {\n        //调用父类构造方法，在父类构造方法中会调用appendAnnotation方法处理@Reference注解的属性\n        super(reference);\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) {\n        this.applicationContext = applicationContext;\n        //将applicationContext添加到SpringExtensionFactory中\n        //SPI那一章节，我们介绍过SpringExtensionFactory类\n        SpringExtensionFactory.addApplicationContext(applicationContext);\n    }\n\n    @Override\n    public Object getObject() throws Exception {\n        //获取对象实例，调用父类中的get方法进行初始化\n        return get();\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        //调用父类中的getInterfaceClass方法获取对象类型(后面会分析该方法)\n        return getInterfaceClass();\n    }\n\n    @Override\n    @Parameter(excluded = true)\n    public boolean isSingleton() {\n        return true;\n    }\n\n    @Override\n    @SuppressWarnings({\"unchecked\"})\n    public void afterPropertiesSet() throws Exception {\n        //如果没有配置Consumer\n        if (getConsumer() == null) {\n            //获取IOC容器中的ConsumerConfig（只获取单例类型的）\n            Map<String, ConsumerConfig> consumerConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ConsumerConfig.class, false, false);\n            if (consumerConfigMap != null && consumerConfigMap.size() > 0) {\n                ConsumerConfig consumerConfig = null;\n                for (ConsumerConfig config : consumerConfigMap.values()) {\n                    //检查是否有重复的consumer配置(default属性)\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        if (consumerConfig != null) {\n                            throw new IllegalStateException(\"Duplicate consumer configs: \" + consumerConfig + \" and \" + config);\n                        }\n                        consumerConfig = config;\n                    }\n                }\n                if (consumerConfig != null) {\n                    //配置bean的consumer属性\n                    setConsumer(consumerConfig);\n                }\n            }\n        }\n        if (getApplication() == null\n                && (getConsumer() == null || getConsumer().getApplication() == null)) {\n            //从IOC容器中获取ApplicationConfig\n            Map<String, ApplicationConfig> applicationConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, false, false);\n            if (applicationConfigMap != null && applicationConfigMap.size() > 0) {\n                ApplicationConfig applicationConfig = null;\n                for (ApplicationConfig config : applicationConfigMap.values()) {\n                    //检测是否有重复的配置(default属性)\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        if (applicationConfig != null) {\n                            throw new IllegalStateException(\"Duplicate application configs: \" + applicationConfig + \" and \" + config);\n                        }\n                        applicationConfig = config;\n                    }\n                }\n                if (applicationConfig != null) {\n                    //设置bean的ApplicationConfig属性\n                    setApplication(applicationConfig);\n                }\n            }\n        }\n        if (getModule() == null\n                && (getConsumer() == null || getConsumer().getModule() == null)) {\n            //从IOC容器中获取ModuleConfig\n            Map<String, ModuleConfig> moduleConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, false, false);\n            if (moduleConfigMap != null && moduleConfigMap.size() > 0) {\n                ModuleConfig moduleConfig = null;\n                for (ModuleConfig config : moduleConfigMap.values()) {\n                    //检测是否有重复的moduleConfig\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        if (moduleConfig != null) {\n                            throw new IllegalStateException(\"Duplicate module configs: \" + moduleConfig + \" and \" + config);\n                        }\n                        moduleConfig = config;\n                    }\n                }\n                if (moduleConfig != null) {\n                    //设置module属性\n                    setModule(moduleConfig);\n                }\n            }\n        }\n        if ((getRegistries() == null || getRegistries().isEmpty())\n                && (getConsumer() == null || getConsumer().getRegistries() == null || getConsumer().getRegistries().isEmpty())\n                && (getApplication() == null || getApplication().getRegistries() == null || getApplication().getRegistries().isEmpty())) {\n            //从IOC容器中获取RegistryConfig\n            Map<String, RegistryConfig> registryConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, false, false);\n            if (registryConfigMap != null && registryConfigMap.size() > 0) {\n                List<RegistryConfig> registryConfigs = new ArrayList<RegistryConfig>();\n                        registryConfigs.add(config);\n                    }\n                }\n                if (registryConfigs != null && !registryConfigs.isEmpty()) {\n                    //设置registries属性\n                    super.setRegistries(registryConfigs);\n                }\n            }\n        }\n        if (getMonitor() == null\n                && (getConsumer() == null || getConsumer().getMonitor() == null)\n                && (getApplication() == null || getApplication().getMonitor() == null)) {\n            //从IOC容器中获取MonitorConfig\n            Map<String, MonitorConfig> monitorConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig.class, false, false);\n            if (monitorConfigMap != null && monitorConfigMap.size() > 0) {\n                MonitorConfig monitorConfig = null;\n                for (MonitorConfig config : monitorConfigMap.values()) {\n                    //检测是否有重复的MonitorConfig\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        if (monitorConfig != null) {\n                            throw new IllegalStateException(\"Duplicate monitor configs: \" + monitorConfig + \" and \" + config);\n                        }\n                        monitorConfig = config;\n                    }\n                }\n                if (monitorConfig != null) {\n                    //设置MonitorConfig属性\n                    setMonitor(monitorConfig);\n                }\n            }\n        }\n        //获取是否 立即初始化 属性init\n        Boolean b = isInit();\n        if (b == null && getConsumer() != null) {\n            //从ConsumerConfig属性中获取init\n            b = getConsumer().isInit();\n        }\n        if (b != null && b.booleanValue()) {\n            //执行初始化\n            getObject();\n        }\n    }\n\n    @Override\n    public void destroy() {\n        // do nothing\n    }\n}\n```\n接下来，我们来看下父类ReferenceConfig中的方法\n```java\n/**\n* 获取服务接口类\n* interfaceClass > GenericService.class > interfaceName\n* @return\n*/\npublic Class<?> getInterfaceClass() {\n\t//interfaceClass属性不为空，直接返回\n\tif (interfaceClass != null) {\n\t    return interfaceClass;\n\t}\n\t//Reference或者Consumer的generic属性为true，则使用GenericService类\n\tif (isGeneric()\n\t\t|| (getConsumer() != null && getConsumer().isGeneric())) {\n\t    return GenericService.class;\n\t}\n\ttry {\n\t    if (interfaceName != null && interfaceName.length() > 0) {\n\t\t//interfaceName属性不为空，加载该类\n\t\tthis.interfaceClass = Class.forName(interfaceName, true, Thread.currentThread()\n\t\t\t.getContextClassLoader());\n\t    }\n\t} catch (ClassNotFoundException t) {\n\t    throw new IllegalStateException(t.getMessage(), t);\n\t}\n\treturn interfaceClass;\n}\n\n\n/**\n * 是否已销毁\n */\nprivate transient volatile boolean destroyed;\n\n/**\n * 接口代理引用\n * interface proxy reference\n */\nprivate transient volatile T ref;\n\n\n/**\n * 获取接口代理引用\n */\npublic synchronized T get() {\n        //判断是否已经销毁\n        if (destroyed) {\n            throw new IllegalStateException(\"Already destroyed!\");\n        }\n        if (ref == null) {\n            //初始化\n            init();\n        }\n        return ref;\n}\n```\n\n#### init方法\n该init方法会生成接口代理引用ref。\n```java\npublic synchronized T get() {\n        //判断是否已经销毁\n        if (destroyed) {\n            throw new IllegalStateException(\"Already destroyed!\");\n        }\n        if (ref == null) {\n            //初始化\n            init();\n        }\n        return ref;\n}\n\nprivate void init() {\n\t//已经初始化过的话，则返回\n\tif (initialized) {\n\t    return;\n\t}\n\tinitialized = true;\n\t//检测是否配置了interface属性\n\tif (interfaceName == null || interfaceName.length() == 0) {\n\t    throw new IllegalStateException(\"<dubbo:reference interface=\\\"\\\" /> interface not allow null!\");\n\t}\n\t//获取Consumer的全局配置(设置ConsumerConfig对象的属性)(后面会分析该方法)\n\tcheckDefault();\n\t//加载当前ReferenceConfig对象(即ReferenceBean)的属性信息(后面会分析该方法)\n\tappendProperties(this);\n\t//当前ReferenceConfig没有配置generic属性的话，则使用Consumer的generic属性配置\n\tif (getGeneric() == null && getConsumer() != null) {\n\t    //设置generic属性\n\t    setGeneric(getConsumer().getGeneric());\n\t}\n\t//(generic ！= null) && (generic = “true” || \"nativejava\" || \"bean\") ProtocolUtils.isGeneric返回true\n\tif (ProtocolUtils.isGeneric(getGeneric())) {\n\t    //如果配置了使用通用接口，则设置服务接口类为GenericService类\n\t    interfaceClass = GenericService.class;\n\t} else {\n\t    //否则根据interfaceName加载服务接口类\n\t    try {\n\t\tinterfaceClass = Class.forName(interfaceName, true, Thread.currentThread()\n\t\t\t.getContextClassLoader());\n\t    } catch (ClassNotFoundException e) {\n\t\tthrow new IllegalStateException(e.getMessage(), e);\n\t    }\n\t    //检测methods方法是否都存在于接口服务类interfaceClass中(后面会分析该方法)\n\t    checkInterfaceAndMethods(interfaceClass, methods);\n\t}\n\t//1、根据服务接口名称从系统配置中查找resolve：即通过-DinterfaceName=resolve配置\n\t//2、resolve为空，则加载dubbo.resolve.file文件,从resolveFile中加载resolve\n\t//   a、从系统配置文件中加载resolve文件：即-Ddubbo.resolve.file=xxx配置\n\t//   b、使用dubbo的默认resolve文件：${user.home}/dubbo-resolve.properties\n\tString resolve = System.getProperty(interfaceName);\n\tString resolveFile = null;\n\tif (resolve == null || resolve.length() == 0) {\n\t    resolveFile = System.getProperty(\"dubbo.resolve.file\");\n\t    if (resolveFile == null || resolveFile.length() == 0) {\n\t\t//没有配置resolveFile的话，则使用dubbo默认的resolve文件\n\t\t//如：System.getProperty(\"user.home\") = C:\\Users\\Administrator\n\t\t//resolveFile = userResolveFile = C:\\Users\\Administrator\\dubbo-resolve.properties\n\t\tFile userResolveFile = new File(new File(System.getProperty(\"user.home\")), \"dubbo-resolve.properties\");\n\t\tif (userResolveFile.exists()) {\n\t\t    resolveFile = userResolveFile.getAbsolutePath();\n\t\t}\n\t    }\n\t    //加载resolveFile文件\n\t    if (resolveFile != null && resolveFile.length() > 0) {\n\t\tProperties properties = new Properties();\n\t\tFileInputStream fis = null;\n\t\ttry {\n\t\t    fis = new FileInputStream(new File(resolveFile));\n\t\t    properties.load(fis);\n\t\t} catch (IOException e) {\n\t\t    throw new IllegalStateException(\"Unload \" + resolveFile + \", cause: \" + e.getMessage(), e);\n\t\t} finally {\n\t\t    try {\n\t\t\tif (null != fis) {\n\t\t\t    fis.close();\n\t\t\t}\n\t\t    } catch (IOException e) {\n\t\t\tlogger.warn(e.getMessage(), e);\n\t\t    }\n\t\t}\n\t\t//从resolveFile配置文件中加载resolve\n\t\tresolve = properties.getProperty(interfaceName);\n\t    }\n\t}\n\tif (resolve != null && resolve.length() > 0) {\n\t    url = resolve;\n\t    if (logger.isWarnEnabled()) {\n\t\tif (resolveFile != null && resolveFile.length() > 0) {\n\t\t    //使用默认dubbo resolve file\n\t\t    logger.warn(\"Using default dubbo resolve file \" + resolveFile + \" replace \" + interfaceName + \"\" + resolve + \" to p2p invoke remote service.\");\n\t\t} else {\n\t\t    //可以使用-DinterfaceName=resolve配置p2p\n\t\t    logger.warn(\"Using -D\" + interfaceName + \"=\" + resolve + \" to p2p invoke remote service.\");\n\t\t}\n\t    }\n\t}\n\t//加载注册中心、监控中心优先级\n\t//consumer > module > application\n\tif (consumer != null) {\n\t    if (application == null) {\n\t\tapplication = consumer.getApplication();\n\t    }\n\t    if (module == null) {\n\t\tmodule = consumer.getModule();\n\t    }\n\t    if (registries == null) {\n\t\tregistries = consumer.getRegistries();\n\t    }\n\t    if (monitor == null) {\n\t\tmonitor = consumer.getMonitor();\n\t    }\n\t}\n\tif (module != null) {\n\t    if (registries == null) {\n\t\tregistries = module.getRegistries();\n\t    }\n\t    if (monitor == null) {\n\t\tmonitor = module.getMonitor();\n\t    }\n\t}\n\tif (application != null) {\n\t    //<dubbo:application name=\"demo-consumer\" qosPort=\"33333\" id=\"demo-consumer\" />\n\t    if (registries == null) {\n\t\tregistries = application.getRegistries();\n\t    }\n\t    if (monitor == null) {\n\t\tmonitor = application.getMonitor();\n\t    }\n\t}\n\t//检测Application配置(后面会分析该方法)\n\tcheckApplication();\n\t//检测Stub和Mock(后面会分析该方法)\n\tcheckStubAndMock(interfaceClass);\n\n\t//记录Consumer端的服务接口相关信息\n\tMap<String, String> map = new HashMap<String, String>();\n\t//保存方法属性的attributes\n\tMap<Object, Object> attributes = new HashMap<Object, Object>();\n\t//设置消费者端\n\tmap.put(Constants.SIDE_KEY, Constants.CONSUMER_SIDE);\n\t//设置dubbo版本\n\tmap.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());\n\t//设置时间戳\n\tmap.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n\tif (ConfigUtils.getPid() > 0) {\n\t    //设置父进程id\n\t    map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n\t}\n\tif (!isGeneric()) {\n\t    //不是通用泛型接口，则获取revision属性,默认等于version属性\n\t    String revision = Version.getVersion(interfaceClass, version);\n\t    if (revision != null && revision.length() > 0) {\n\t\tmap.put(\"revision\", revision);\n\t    }\n\t    //获取包装类，然后获取服务接口中的方法名称数组(后面会分析该方法)\n\t    String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();\n\t    if (methods.length == 0) {\n\t\t//在服务接口中，没有找到方法，则设置属性：methods = *\n\t\tlogger.warn(\"NO method found in service interface \" + interfaceClass.getName());\n\t\tmap.put(\"methods\", Constants.ANY_VALUE);\n\t    } else {\n\t\t//设置methods=逗号分隔的方法name\n\t\tmap.put(\"methods\", StringUtils.join(new HashSet<String>(Arrays.asList(methods)), \",\"));\n\t    }\n\t}\n\t//设置interface属性\n\tmap.put(Constants.INTERFACE_KEY, interfaceName);\n\t//添加附加参数(后面会分析该方法)\n\tappendParameters(map, application);\n\tappendParameters(map, module);\n\tappendParameters(map, consumer, Constants.DEFAULT_KEY);\n\tappendParameters(map, this);\n\t//获取服务前缀：group/interface:version\n\tString prefix = StringUtils.getServiceKey(map);\n\t//处理引用的方法列表\n\tif (methods != null && !methods.isEmpty()) {\n\t    for (MethodConfig method : methods) {\n\t\t//附加参数(后面会分析该方法)\n\t\tappendParameters(map, method, method.getName());\n\t\t//处理方法重试\n\t\tString retryKey = method.getName() + \".retry\";\n\t\tif (map.containsKey(retryKey)) {\n\t\t    //将属性retryKey从map中移除\n\t\t    String retryValue = map.remove(retryKey);\n\t\t    if (\"false\".equals(retryValue)) {\n\t\t\t//属性retryKey的值为false,则添加新的属性到map中(即禁用方法重试)\n\t\t\tmap.put(method.getName() + \".retries\", \"0\");\n\t\t    }\n\t\t}\n\t\t//附加属性(后面会分析该方法)\n\t\tappendAttributes(attributes, method, prefix + \".\" + method.getName());\n\t\t//attributes保存的是方法名，调用checkAndConvertImplicitConfig方法后将会保存Method实例\n\t\tcheckAndConvertImplicitConfig(method, map, attributes);\n\t    }\n\t}\n\t//从系统配置属性中获取：注册到注册中心的ip\n\tString hostToRegistry = ConfigUtils.getSystemProperty(Constants.DUBBO_IP_TO_REGISTRY);\n\tif (hostToRegistry == null || hostToRegistry.length() == 0) {\n\t    //获取本地地址,如：192.168.99.60\n\t    hostToRegistry = NetUtils.getLocalHost();\n\t} else if (isInvalidLocalHost(hostToRegistry)) {\n\t    //无效的地址\n\t    throw new IllegalArgumentException(\"Specified invalid registry ip from property:\" + Constants.DUBBO_IP_TO_REGISTRY + \", value:\" + hostToRegistry);\n\t}\n\t//设置属性：注册到注册中心的ip\n\tmap.put(Constants.REGISTER_IP_KEY, hostToRegistry);\n\n\t//保存方法属性到系统上下文中\n\tStaticContext.getSystemContext().putAll(attributes);\n\t\n\t//根据服务接口及其属性创建代理(后面会分析该方法)\n\tref = createProxy(map);\n\t\n\t//构造ConsumerModel对象,getUniqueServiceName()生成唯一服务名称\n\tConsumerModel consumerModel = new ConsumerModel(getUniqueServiceName(), this, ref, interfaceClass.getMethods());\n\t\n\t//根据服务名称注册消费者(后面会分析该方法)\n\tApplicationModel.initConsumerModel(getUniqueServiceName(), consumerModel);\n}\n```\n接下来，我们看上面使用到的方法\n\n##### checkDefault方法\n获取Consumer的全局配置\n```java\nprivate void checkDefault() {\n        if (consumer == null) {\n\t    //consumer为空，会新创建一个ConsumerConfig对象\n            consumer = new ConsumerConfig();\n        }\n\t//调用appendProperties方法\n        appendProperties(consumer);\n}\n```\n##### appendProperties方法\n该方法在init方法中大量出现，我们先看下它的实现，它是定义在AbstractConfig抽象类中的静态方法，参数是AbstractConfig类型。\n```java\n/**\n * 附加属性\n * 找到config的所有的setXXX方法，然后切割出属性XXX，然后从系统配置/dubbo配置文件中获取到属性的值，\n * 然后执行setXXX方法把属性值设置到config对象中\n * @param config\n */\nprotected static void appendProperties(AbstractConfig config) {\n\tif (config == null) {\n\t   //config为空，直接返回\n\t   return;\n\t}\n\t//生成前缀，如： dubbo.monitor.\n\tString prefix = \"dubbo.\" + getTagName(config.getClass()) + \".\";\n\t//获取config类的所有方法\n\tMethod[] methods = config.getClass().getMethods();\n\t//遍历方法列表\n\tfor (Method method : methods) {\n\t    try {\n\t\tString name = method.getName();\n\t\t//方法名长度>3，以set开头，修饰符是public，参数个数=1，参数类型是原始类型\n\t\tif (name.length() > 3 && name.startsWith(\"set\") && Modifier.isPublic(method.getModifiers())\n\t\t\t&& method.getParameterTypes().length == 1 && isPrimitive(method.getParameterTypes()[0])) {\n\t\t    //转换方法名称为属性名称，如：setFirstName将会转换成first.name\n\t\t    //例如：property = default\n\t\t    String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), \".\");\n\n\t\t    //1、从系统配置中获取：prefix + id + property\n\t\t    //2、从系统配置中获取：prefix + property\n\t\t    //3、从config类中找到属性get方法或者is方法，然后执行该方法\n\t\t\t//3.1、从config配置中获取 prefix + id + property属性\n\t\t\t//3.2、从config配置中获取 prefix + property属性\n\t\t\t//3.3、根据prefix + property获取旧版属性legacyKey,然后根据legacyKey从config配置中获取\n\t\t    //ConfigUtils.getProperty(后面会分析该方法)\n\t\t    //如果属性值value不为空的话，则调用该set方法，将属性设置到config对象中，整个方法流程执行结束\n\t\t\t\n\t\t    String value = null;\n\t\t    if (config.getId() != null && config.getId().length() > 0) {\n\t\t\t//如果id属性不为空，则属性名称为：prefix + id + property\n\t\t\t//例如：pn = dubbo.monitor.\"id\".default\n\t\t\tString pn = prefix + config.getId() + \".\" + property;\n\t\t\t//从系统配置中获取属性pn的值value\n\t\t\tvalue = System.getProperty(pn);\n\t\t\tif (!StringUtils.isBlank(value)) {\n\t\t\t    //如果系统中设置了pn属性，则使用该属性值\n\t\t\t    logger.info(\"Use System Property \" + pn + \" to config dubbo\");\n\t\t\t}\n\t\t    }\n\t\t    if (value == null || value.length() == 0) {\n\t\t\t//属性名称为：prefix + property\n\t\t\t//例如：dubbo.monitor.default\n\t\t\tString pn = prefix + property;\n\t\t\t//获取属性pn的系统属性值value\n\t\t\tvalue = System.getProperty(pn);\n\t\t\tif (!StringUtils.isBlank(value)) {\n\t\t\t    logger.info(\"Use System Property \" + pn + \" to config dubbo\");\n\t\t\t}\n\t\t    }\n\t\t    if (value == null || value.length() == 0) {\n\t\t\tMethod getter;\n\t\t\ttry {\n\t\t\t    //获取当前属性的get方法\n\t\t\t    getter = config.getClass().getMethod(\"get\" + name.substring(3), new Class<?>[0]);\n\t\t\t} catch (NoSuchMethodException e) {\n\t\t\t    try {\n\t\t\t\t//get方法不存在的话，则获取下is方法\n\t\t\t\tgetter = config.getClass().getMethod(\"is\" + name.substring(3), new Class<?>[0]);\n\t\t\t    } catch (NoSuchMethodException e2) {\n\t\t\t\tgetter = null;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (getter != null) {\n\t\t\t    //执行config对象的属性的getter方法，结果为空的话\n\t\t\t    if (getter.invoke(config, new Object[0]) == null) {\n\t\t\t\tif (config.getId() != null && config.getId().length() > 0) {\n\t\t\t\t    //id属性不为空\n\t\t\t\t    //如：dubbo.monitor.\"id\".default\n\t\t\t\t    value = ConfigUtils.getProperty(prefix + config.getId() + \".\" + property);\n\t\t\t\t}\n\t\t\t\tif (value == null || value.length() == 0) {\n\t\t\t\t    //如：dubbo.monitor.default\n\t\t\t\t    value = ConfigUtils.getProperty(prefix + property);\n\t\t\t\t}\n\t\t\t\tif (value == null || value.length() == 0) {\n\t\t\t\t    //从旧版属性中获取(如：dubbo.monitor.default)\n\t\t\t\t    String legacyKey = legacyProperties.get(prefix + property);\n\t\t\t\t    if (legacyKey != null && legacyKey.length() > 0) {\n\t\t\t\t\t//转换旧版属性值\n\t\t\t\t\tvalue = convertLegacyValue(legacyKey, ConfigUtils.getProperty(legacyKey));\n\t\t\t\t    }\n\t\t\t\t}\n\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (value != null && value.length() > 0) {\n\t\t\t//如果属性值不为空的话，则使用属性值作为参数执行config类的method方法\n\t\t\tmethod.invoke(\n\t\t\t\tconfig,\n\t\t\t\tnew Object[]{\n\t\t\t\t\t//转换原始类型\n\t\t\t\t\tconvertPrimitive(method.getParameterTypes()[0], value)\n\t\t\t\t}\n\n\t\t\t);\n\t\t    }\n\t\t}\n\t    } catch (Exception e) {\n\t\tlogger.error(e.getMessage(), e);\n\t    }\n\t}\n}\n```\n\n##### checkInterfaceAndMethods方法\n```java\n/**\n* 判断方法methods是否都在服务接口类中存在\n* @param interfaceClass 服务接口类\n* @param methods 引用的服务接口方法\n*/\nprotected void checkInterfaceAndMethods(Class<?> interfaceClass, List<MethodConfig> methods) {\n\tif (interfaceClass == null) {\n\t    //服务接口不可以为空\n\t    throw new IllegalStateException(\"interface not allow null!\");\n\t}\n\tif (!interfaceClass.isInterface()) {\n\t    // interfaceClass必须为接口类型\n\t    throw new IllegalStateException(\"The interface class \" + interfaceClass + \" is not a interface!\");\n\t}\n\t// 检查methods方法是否存在于interfaceClass接口中\n\tif (methods != null && !methods.isEmpty()) {\n\t    //遍历引用的方法\n\t    for (MethodConfig methodBean : methods) {\n\t\t//方法名\n\t\tString methodName = methodBean.getName();\n\t\tif (methodName == null || methodName.length() == 0) {\n\t\t    //<dubbo:method>标签的name属性必须设置\n\t\t    throw new IllegalStateException(\"<dubbo:method> name attribute is required! Please check: <dubbo:service interface=\\\"\" + interfaceClass.getName() + \"\\\" ... ><dubbo:method name=\\\"\\\" ... /></<dubbo:reference>\");\n\t\t}\n\t\tboolean hasMethod = false;\n\t\tfor (java.lang.reflect.Method method : interfaceClass.getMethods()) {\n\t\t    //方法名一样，则认为存在该方法\n\t\t    if (method.getName().equals(methodName)) {\n\t\t\thasMethod = true;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (!hasMethod) {\n\t\t    //引用的方法在服务接口中不存在\n\t\t    throw new IllegalStateException(\"The interface \" + interfaceClass.getName()\n\t\t\t    + \" not found method \" + methodName);\n\t\t}\n\t    }\n\t}\n}\n```\n##### checkApplication方法\n该方法用来验证application,application为空的话，会新建ApplicationConfig对象\n```java\nprotected void checkApplication() {\n\t// 处理兼容\n\tif (application == null) {\n\t    //从配置文件中加载application.name属性\n\t    String applicationName = ConfigUtils.getProperty(\"dubbo.application.name\");\n\t    if (applicationName != null && applicationName.length() > 0) {\n\t\t//新创建一个ApplicationConfig对象\n\t\tapplication = new ApplicationConfig();\n\t    }\n\t}\n\tif (application == null) {\n\t    //需要配置 <dubbo:application name=\\\"...\\\" />\n\t    throw new IllegalStateException(\n\t\t    \"No such application config! Please add <dubbo:application name=\\\"...\\\" /> to your spring config.\");\n\t}\n\t//添加application的属性\n\tappendProperties(application);\n\t//获取配置: 服务停止时的等待时间(优先获取SHUTDOWN_WAIT_KEY属性，在获取SHUTDOWN_WAIT_SECONDS_KEY(废弃))\n\tString wait = ConfigUtils.getProperty(Constants.SHUTDOWN_WAIT_KEY);\n\tif (wait != null && wait.trim().length() > 0) {\n\t    //设置到系统配置中\n\t    System.setProperty(Constants.SHUTDOWN_WAIT_KEY, wait.trim());\n\t} else {\n\t    wait = ConfigUtils.getProperty(Constants.SHUTDOWN_WAIT_SECONDS_KEY);\n\t    if (wait != null && wait.trim().length() > 0) {\n\t\tSystem.setProperty(Constants.SHUTDOWN_WAIT_SECONDS_KEY, wait.trim());\n\t    }\n\t}\n}\n```\n\n##### checkStubAndMock方法\n该方法用来检测: 服务接口本地实现类、服务接口本地存根类、mock\n```java\n/**\n* 检测local/stub/mock的配置是否正确\n* local/stub/mock(mock 可配置为\"return \")应该为interfaceClass或者为interfaceClass子类\n* @param interfaceClass 服务接口类\n*/\nprotected void checkStubAndMock(Class<?> interfaceClass) {\n\t//处理服务接口本地实现类\n\tif (ConfigUtils.isNotEmpty(local)) {\n\t    //如果local = true或者local = default(即local属性配置),则本地实现类名为：接口名称+Local,否则本地实现类名为：local属性\n\t    //加载本地实现类\n\t    Class<?> localClass = ConfigUtils.isDefault(local) ? ReflectUtils.forName(interfaceClass.getName() + \"Local\") : ReflectUtils.forName(local);\n\t    //检查本地实现类是否实现了服务接口\n\t    if (!interfaceClass.isAssignableFrom(localClass)) {\n\t\tthrow new IllegalStateException(\"The local implementation class \" + localClass.getName() + \" not implement interface \" + interfaceClass.getName());\n\t    }\n\t    try {\n\t\t//检测本地实现类中是否存在相应的构造方法，即：public 本地实现类名 (服务接口名){}\n\t\tReflectUtils.findConstructor(localClass, interfaceClass);\n\t    } catch (NoSuchMethodException e) {\n\t\tthrow new IllegalStateException(\"No such constructor \\\"public \" + localClass.getSimpleName() + \"(\" + interfaceClass.getName() + \")\\\" in local implementation class \" + localClass.getName());\n\t    }\n\t}\n\t//处理服务接口本地存根类\n\tif (ConfigUtils.isNotEmpty(stub)) {\n\t    //如果stub = true或者stub = default(即stub属性)，则本地存根类名为：接口名称+Stub,否则本地存根类名为：stub属性\n\t    //加载本地存根类\n\t    Class<?> localClass = ConfigUtils.isDefault(stub) ? ReflectUtils.forName(interfaceClass.getName() + \"Stub\") : ReflectUtils.forName(stub);\n\t    //检测本地存根类是否实现了服务接口\n\t    if (!interfaceClass.isAssignableFrom(localClass)) {\n\t\tthrow new IllegalStateException(\"The local implementation class \" + localClass.getName() + \" not implement interface \" + interfaceClass.getName());\n\t    }\n\t    try {\n\t\t//检测本地存根类是否存在相应的构造方法, 即：public 本地存根类名 (服务接口名){}\n\t\tReflectUtils.findConstructor(localClass, interfaceClass);\n\t    } catch (NoSuchMethodException e) {\n\t\tthrow new IllegalStateException(\"No such constructor \\\"public \" + localClass.getSimpleName() + \"(\" + interfaceClass.getName() + \")\\\" in local implementation class \" + localClass.getName());\n\t    }\n\t}\n\t//处理mock\n\tif (ConfigUtils.isNotEmpty(mock)) {\n\t    //判断mock属性是否以\"return \"开头\n\t    if (mock.startsWith(Constants.RETURN_PREFIX)) {\n\t\t//获取到\"return \"之后的值\n\t\tString value = mock.substring(Constants.RETURN_PREFIX.length());\n\t\ttry {\n\t\t    //解析mock值\n\t\t    MockInvoker.parseMockValue(value);\n\t\t} catch (Exception e) {\n\t\t    throw new IllegalStateException(\"Illegal mock json value in <dubbo:service ... mock=\\\"\" + mock + \"\\\" />\");\n\t\t}\n\t    } else {\n\t\t//获取mock类\n\t\t//如果mock = true或者mock = default(即mock属性)，则本地存根类名为：接口名称+Mock,否则本地存根类名为：mock属性\n\t\tClass<?> mockClass = ConfigUtils.isDefault(mock) ? ReflectUtils.forName(interfaceClass.getName() + \"Mock\") : ReflectUtils.forName(mock);\n\t\t//检测mock类是否实现了服务接口\n\t\tif (!interfaceClass.isAssignableFrom(mockClass)) {\n\t\t    throw new IllegalStateException(\"The mock implementation class \" + mockClass.getName() + \" not implement interface \" + interfaceClass.getName());\n\t\t}\n\t\ttry {\n\t\t    //检测默认构造方法，即：pulic mock类名 () {}\n\t\t    mockClass.getConstructor(new Class<?>[0]);\n\t\t} catch (NoSuchMethodException e) {\n\t\t    throw new IllegalStateException(\"No such empty constructor \\\"public \" + mockClass.getSimpleName() + \"()\\\" in mock implementation class \" + mockClass.getName());\n\t\t}\n\t    }\n\t}\n}\n```\n##### appendParameters方法\n```java\n/**\n* 附加参数\n* 1、获取config对象的方法列表，\n* 2、找到getXXX或者isXXX方法或者getParameters方法(会通过方法上的@Parameter注解判断是否需要过滤该属性)\n* 3、然后执行该方法，拿到方法返回值(会通过方法上的@Parameter注解判断是否需要编码及追加)。\n* 然后将属性(@Parameter注解配置或者通过getXXX获取，如果配置了prefix，则属性为: prefix.属性)\n* 以及值保存到parameters中\n*\n* @param parameters 当前参数Map\n* @param config  目标配置对象\n* @param prefix 属性配置前缀\n*/\nprotected static void appendParameters(Map<String, String> parameters, Object config, String prefix) {\n\tif (config == null) {\n\t    return;\n\t}\n\t//获取配置类config的所有方法\n\tMethod[] methods = config.getClass().getMethods();\n\tfor (Method method : methods) {\n\t    try {\n\t\tString name = method.getName();\n\t\t//方法名以get或者is开头，并且方法名不为getClass，并且存在public修饰符\n\t\t//并且不存在参数，并且方法返回类型为原始类型\n\t\tif ((name.startsWith(\"get\") || name.startsWith(\"is\"))\n\t\t\t&& !\"getClass\".equals(name)\n\t\t\t&& Modifier.isPublic(method.getModifiers())\n\t\t\t&& method.getParameterTypes().length == 0\n\t\t\t&& isPrimitive(method.getReturnType())) {\n\t\t    //获取方法上的@Parameter注解\n\t\t    Parameter parameter = method.getAnnotation(Parameter.class);\n\t\t    if (method.getReturnType() == Object.class || parameter != null && parameter.excluded()) {\n\t\t\t//如果当前方法的返回类型为Object，或者该方法存在@Parameter注解且excluded属性值为true\n\t\t\t//则跳过该方法，即忽略该属性\n\t\t\tcontinue;\n\t\t    }\n\t\t    int i = name.startsWith(\"get\") ? 3 : 2;\n\t\t    //根据方法名获取到属性名，如：getFirstName被转换成：first.name\n\t\t    String prop = StringUtils.camelToSplitName(name.substring(i, i + 1).toLowerCase() + name.substring(i + 1), \".\");\n\t\t    //key为@Parameter注解的key属性或者为根据当前方法名截取到的属性名\n\t\t    String key;\n\t\t    if (parameter != null && parameter.key() != null && parameter.key().length() > 0) {\n\t\t\t//如果@Parameter注解的key属性不为空，则使用key属性\n\t\t\tkey = parameter.key();\n\t\t    } else {\n\t\t\t//否则使用prop作为key\n\t\t\tkey = prop;\n\t\t    }\n\t\t    //执行config对象的method方法，获取到方法返回值\n\t\t    Object value = method.invoke(config, new Object[0]);\n\t\t    //将方法返回值转换成字符串，并去掉空格\n\t\t    String str = String.valueOf(value).trim();\n\t\t    if (value != null && str.length() > 0) {\n\t\t\t//方法返回值不为空\n\t\t\tif (parameter != null && parameter.escaped()) {\n\t\t\t    //根据@Parameter注解的escaped属性来决定是否需要对属性值进行编码\n\t\t\t    str = URL.encode(str);\n\t\t\t}\n\t\t\tif (parameter != null && parameter.append()) {\n\t\t\t    //如果配置了@Parameter注解的append属性为true\n\t\t\t    //则从参数Map中获取key对应的值pre\n\t\t\t    String pre = parameters.get(Constants.DEFAULT_KEY + \".\" + key);\n\t\t\t    if (pre != null && pre.length() > 0) {\n\t\t\t\t//追加方法返回值\n\t\t\t\tstr = pre + \",\" + str;\n\t\t\t    }\n\t\t\t    pre = parameters.get(key);\n\t\t\t    if (pre != null && pre.length() > 0) {\n\t\t\t\t//追加方法返回值\n\t\t\t\tstr = pre + \",\" + str;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (prefix != null && prefix.length() > 0) {\n\t\t\t    //如果前缀不为空，则拼接key\n\t\t\t    key = prefix + \".\" + key;\n\t\t\t}\n\t\t\t//将key、value保存到参数Map中\n\t\t\tparameters.put(key, str);\n\t\t    } else if (parameter != null && parameter.required()) {\n\t\t\t//如果方法返回值为空，且@Parameter注解的required属性为true\n\t\t\t//则抛出异常，提示config类的key属性的值为空\n\t\t\tthrow new IllegalStateException(config.getClass().getSimpleName() + \".\" + key + \" == null\");\n\t\t    }\n\t\t} else if (\"getParameters\".equals(name)\n\t\t\t&& Modifier.isPublic(method.getModifiers())\n\t\t\t&& method.getParameterTypes().length == 0\n\t\t\t&& method.getReturnType() == Map.class) {\n\t\t    //方法名称为getParameters，且方法有public修饰符，且参数为空，且方法返回值为Map\n\t\t    //则执行config对象的getParameters方法，获取到返回值Map\n\t\t    Map<String, String> map = (Map<String, String>) method.invoke(config, new Object[0]);\n\t\t    if (map != null && map.size() > 0) {\n\t\t\t//格式化前缀，前缀以“.”结尾\n\t\t\tString pre = (prefix != null && prefix.length() > 0 ? prefix + \".\" : \"\");\n\t\t\t//遍历getParameters方法返回值\n\t\t\tfor (Map.Entry<String, String> entry : map.entrySet()) {\n\t\t\t    //将属性以及属性值保存到parameters中\n\t\t\t    parameters.put(pre + entry.getKey().replace('-', '.'), entry.getValue());\n\t\t\t}\n\t\t    }\n\t\t}\n\t    } catch (Exception e) {\n\t\tthrow new IllegalStateException(e.getMessage(), e);\n\t    }\n\t}\n}\n```\n\n##### appendAttributes方法\n```java\n/**\n* 附加属性\n* 1、获取config对象的getXXX或者isXXX方法(会通过方法上的@Parameter注解判断是否需要过滤该属性)，\n* 然后调用该方法获取返回值value。\n* 2、然后根据@Parameter注解的key属性或者当前方法名称(取消get/is前缀)作为key（prefix+\".\"+key），\n* 3、最终将key和value保存到parameters中\n* @param parameters 保存方法属性\n* @param config MethodConfig等对象\n* @param prefix\n*/\nprotected static void appendAttributes(Map<Object, Object> parameters, Object config, String prefix) {\n\tif (config == null) {\n\t    return;\n\t}\n\tMethod[] methods = config.getClass().getMethods();\n\t//遍历config对象的方法\n\tfor (Method method : methods) {\n\t    try {\n\t\t//方法名\n\t\tString name = method.getName();\n\t\t//找到get方法或者is方法\n\t\tif ((name.startsWith(\"get\") || name.startsWith(\"is\"))\n\t\t\t&& !\"getClass\".equals(name)\n\t\t\t&& Modifier.isPublic(method.getModifiers())\n\t\t\t&& method.getParameterTypes().length == 0\n\t\t\t&& isPrimitive(method.getReturnType())) {\n\t\t    //获取方法上的@Parameter注解\n\t\t    Parameter parameter = method.getAnnotation(Parameter.class);\n\t\t    if (parameter == null || !parameter.attribute()) {\n\t\t\t//如果该方法没有@Parameter注解，或者@Parameter注解的attribute属性为false\n\t\t\t//则跳过该方法\n\t\t\tcontinue;\n\t\t    }\n\t\t    //优先获取@Parameter注解的key属性，否则获取当前方法名(去掉get或者is前缀)\n\t\t    String key;\n\t\t    if (parameter.key() != null && parameter.key().length() > 0) {\n\t\t\tkey = parameter.key();\n\t\t    } else {\n\t\t\tint i = name.startsWith(\"get\") ? 3 : 2;\n\t\t\tkey = name.substring(i, i + 1).toLowerCase() + name.substring(i + 1);\n\t\t    }\n\t\t    //执行config对象的当前方法，获取方法返回值\n\t\t    Object value = method.invoke(config, new Object[0]);\n\t\t    if (value != null) {\n\t\t\tif (prefix != null && prefix.length() > 0) {\n\t\t\t    //前缀不为空的话，拼接上前缀\n\t\t\t    key = prefix + \".\" + key;\n\t\t\t}\n\t\t\t//将属性和属性值放到parameters中\n\t\t\tparameters.put(key, value);\n\t\t    }\n\t\t}\n\t    } catch (Exception e) {\n\t\tthrow new IllegalStateException(e.getMessage(), e);\n\t    }\n\t}\n}\n```\n##### checkAndConvertImplicitConfig方法\n```java\n/**\n* 处理onreturn、onthrow、oninvoke属性，将attributes中的value，从\"方法名称\"转换成\"方法对象\"\n* 如：将<onReturnMethodKey,onReturnMethod方法名>转换为<onReturnMethodKey,onReturnMethod方法对象>\n* @param method 当前方法配置\n* @param map 当前所有属性map\n* @param attributes 当前方法的属性map\n*/\nprivate static void checkAndConvertImplicitConfig(MethodConfig method, Map<String, String> map, Map<Object, Object> attributes) {\n\t//检测配置冲突\n\tif (Boolean.FALSE.equals(method.isReturn()) && (method.getOnreturn() != null || method.getOnthrow() != null)) {\n\t    //当设置了onreturn或者onthrow时，必须同时设置isReturn为true\n\t    throw new IllegalStateException(\"method config error : return attribute must be set true when onreturn or onthrow has been setted.\");\n\t}\n\n\t//attributes存的是<onReturnMethodKey,onReturnMethod方法名>\n\t//经过转换后存的是<onReturnMethodKey,onReturnMethod方法类>\n\n\t//onReturnMethodKey是属性key\n\tString onReturnMethodKey = StaticContext.getKey(map, method.getName(), Constants.ON_RETURN_METHOD_KEY);\n\t//从attributes中获取属性onReturnMethodKey对应的值(方法名)\n\tObject onReturnMethod = attributes.get(onReturnMethodKey);\n\tif (onReturnMethod != null && onReturnMethod instanceof String) {\n\t    //getMethodByName方法根据方法名onReturnMethod从类method.getOnreturn().getClass()中找到相应的方法\n\t    attributes.put(onReturnMethodKey, getMethodByName(method.getOnreturn().getClass(), onReturnMethod.toString()));\n\t}\n\t//下面的类似\n\t//convert onthrow methodName to Method\n\tString onThrowMethodKey = StaticContext.getKey(map, method.getName(), Constants.ON_THROW_METHOD_KEY);\n\tObject onThrowMethod = attributes.get(onThrowMethodKey);\n\tif (onThrowMethod != null && onThrowMethod instanceof String) {\n\t    attributes.put(onThrowMethodKey, getMethodByName(method.getOnthrow().getClass(), onThrowMethod.toString()));\n\t}\n\t//convert oninvoke methodName to Method\n\tString onInvokeMethodKey = StaticContext.getKey(map, method.getName(), Constants.ON_INVOKE_METHOD_KEY);\n\tObject onInvokeMethod = attributes.get(onInvokeMethodKey);\n\tif (onInvokeMethod != null && onInvokeMethod instanceof String) {\n\t    attributes.put(onInvokeMethodKey, getMethodByName(method.getOninvoke().getClass(), onInvokeMethod.toString()));\n\t}\n}\n```\n\n##### StaticContext类\ninit方法中，最终会将方法的属性添加到StaticContext中\n```java\nStaticContext.getSystemContext().putAll(attributes);\n\n\n/**\n * 系统上下文，只是框架内部使用\n * System context, for internal use only\n */\npublic class StaticContext extends ConcurrentHashMap<Object, Object> {\n    private static final long serialVersionUID = 1L;\n    private static final String SYSTEMNAME = \"system\";\n    private static final ConcurrentMap<String, StaticContext> context_map = new ConcurrentHashMap<String, StaticContext>();\n    private String name;\n\n    private StaticContext(String name) {\n        super();\n        this.name = name;\n    }\n\n    /**\n     * 获取系统上下文,即key为system\n     * @return\n     */\n    public static StaticContext getSystemContext() {\n        return getContext(SYSTEMNAME);\n    }\n\n    /**\n     * 根据name获取上下文\n     * @param name\n     * @return\n     */\n    public static StaticContext getContext(String name) {\n        //通过name从context_map中获取StaticContext\n        StaticContext appContext = context_map.get(name);\n        if (appContext == null) {\n            //没有获取到StaticContext，则为name新建一个StaticContext，然后放入context_map中\n            appContext = context_map.putIfAbsent(name, new StaticContext(name));\n            if (appContext == null) {\n                appContext = context_map.get(name);\n            }\n        }\n        return appContext;\n    }\n\n    /**\n     * 从context_map中移除name对应的上下文\n     * @param name\n     * @return\n     */\n    public static StaticContext remove(String name) {\n        return context_map.remove(name);\n    }\n\n    public static String getKey(URL url, String methodName, String suffix) {\n        return getKey(url.getServiceKey(), methodName, suffix);\n    }\n\n    public static String getKey(Map<String, String> paras, String methodName, String suffix) {\n        return getKey(StringUtils.getServiceKey(paras), methodName, suffix);\n    }\n\n    /**\n     * 获取唯一标识\n     * @param servicekey 服务唯一标识\n     * @param methodName 方法名\n     * @param suffix  前缀\n     * @return\n     */\n    private static String getKey(String servicekey, String methodName, String suffix) {\n        StringBuffer sb = new StringBuffer().append(servicekey).append(\".\").append(methodName).append(\".\").append(suffix);\n        return sb.toString();\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n```\n\n##### getUniqueServiceName方法\n```java\n/**\n* 获取唯一服务名称（group和version可以为空）\n* group/interfaceName:version\n* @return\n*/\n@Parameter(excluded = true)\npublic String getUniqueServiceName() {\n\tStringBuilder buf = new StringBuilder();\n\tif (group != null && group.length() > 0) {\n\t    buf.append(group).append(\"/\");\n\t}\n\tbuf.append(interfaceName);\n\tif (version != null && version.length() > 0) {\n\t    buf.append(\":\").append(version);\n\t}\n\treturn buf.toString();\n}\n```\n##### ConsumerModel类\n```java\npublic class ConsumerModel {\n    /**\n     * 元数据(即ReferenceBean实例)\n     */\n    private ReferenceConfig metadata;\n    /**\n     * 代理对象\n     */\n    private Object proxyObject;\n    /**\n     * 唯一的服务接口名称\n     */\n    private String serviceName;\n\n    private final Map<Method, ConsumerMethodModel> methodModels = new IdentityHashMap<Method, ConsumerMethodModel>();\n\n    public ConsumerModel(String serviceName,ReferenceConfig metadata, Object proxyObject, Method[] methods) {\n        this.serviceName = serviceName;\n        this.metadata = metadata;\n        this.proxyObject = proxyObject;\n\n        if (proxyObject != null) {\n            //代理对象不为空,遍历服务接口方法列表，创建ConsumerMethodModel类\n            for (Method method : methods) {\n                //<服务接口方法，ConsumerMethodModel<服务接口方法,metadata实例>>\n                methodModels.put(method, new ConsumerMethodModel(method, metadata));\n            }\n        }\n    }\n\n    /**\n     * Return service metadata for consumer\n     * @return service metadata\n     */\n    public ReferenceConfig getMetadata() {\n        return metadata;\n    }\n\n    public Object getProxyObject() {\n        return proxyObject;\n    }\n\n    /**\n     * 获取消费者端的给定方法的MethodModel\n     * Return method model for the given method on consumer side\n     *\n     * @param method method object\n     * @return method model\n     */\n    public ConsumerMethodModel getMethodModel(Method method) {\n        return methodModels.get(method);\n    }\n\n    /**\n     * 获取当前服务的所有方法MethodModel\n     * Return all method models for the current service\n     *\n     * @return method model list\n     */\n    public List<ConsumerMethodModel> getAllMethods() {\n        return new ArrayList<ConsumerMethodModel>(methodModels.values());\n    }\n\n    public String getServiceName() {\n        return serviceName;\n    }\n}\n```\n\n##### ApplicationModel类\n接下来我们简单看下ApplicationModel.initConsumerModel(getUniqueServiceName(), consumerModel);\n```java\n/**\n* 将服务的ConsumerModel方法保存到本地Map中\n* @param serviceName\n* @param consumerModel\n* @return\n*/\npublic static boolean initConsumerModel(String serviceName, ConsumerModel consumerModel) {\n\tif (consumedServices.putIfAbsent(serviceName, consumerModel) != null) {\n\t    logger.warn(\"Already register the same consumer:\" + serviceName);\n\t    return false;\n\t}\n\treturn true;\n}\n```\n\ninit方法我们还剩下两个方法没有讲解：\n1、 ref = createProxy(map); 即创建代理对象\n2、String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames(); 即包装类\n\n计划这两个方法留着后面的章节(讲完注册中心等章节后)在讲解。\n\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之集成Spring注解解析(0201)","url":"/blog/2018/08/05/Dubbo源码阅读之集成Spring-0201注解解析/","content":">本小节介绍Annotation的解析\n\n### AnnotationBeanDefinitionParser解析类\n\n```java\n该类继承自AbstractSingleBeanDefinitionParser抽象类，该抽象类规范了注册bean的骨架(即模板方法)，我们只需要实现getBeanClass方法指定待注册的bean，以及实现doParse方法表明如何解析类。\npublic class AnnotationBeanDefinitionParser extends AbstractSingleBeanDefinitionParser {\n\n    /**\n     * 解析：<dubbo:annotation package=\"\"/>\n     * @param element\n     * @param parserContext\n     * @param builder\n     */\n    @Override\n    protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {\n        //获取配置的package属性\n        String packageToScan = element.getAttribute(\"package\");\n        //逗号分隔package\n        String[] packagesToScan = trimArrayElements(commaDelimitedListToStringArray(packageToScan));\n\n        //通过构造函数设置ServiceAnnotationBeanPostProcessor类的packagesToScan属性\n        builder.addConstructorArgValue(packagesToScan);\n        //标识为基础设施类，防止该bean被代理\n        builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\n        //注册@ReferenceAnnotationBeanPostProcessor\n        registerReferenceAnnotationBeanPostProcessor(parserContext.getRegistry());\n\n    }\n\n    @Override\n    protected boolean shouldGenerateIdAsFallback() {\n        return true;\n    }\n\n    /**\n     * 注册ReferenceAnnotationBeanPostProcessor类\n     * 该类用来处理@Reference\n     * Registers {@link ReferenceAnnotationBeanPostProcessor} into {@link BeanFactory}\n     * @param registry {@link BeanDefinitionRegistry}\n     */\n    private void registerReferenceAnnotationBeanPostProcessor(BeanDefinitionRegistry registry) {\n        // Register @Reference Annotation Bean Processor\n        BeanRegistrar.registerInfrastructureBean(registry,\n                ReferenceAnnotationBeanPostProcessor.BEAN_NAME,\n                ReferenceAnnotationBeanPostProcessor.class);\n    }\n\n    @Override\n    protected Class<?> getBeanClass(Element element) {\n        //解析注册ServiceAnnotationBeanPostProcessor类\n        return ServiceAnnotationBeanPostProcessor.class;\n    }\n}\n```\n我们将ServiceAnnotationBeanPostProcessor类和ReferenceAnnotationBeanPostProcessor类注册到了Bean工厂中了，接下来我们将用两小节(0201/0202)来介绍这两个类的实现，先来看ServiceAnnotationBeanPostProcessor类的实现(0201)，ReferenceAnnotationBeanPostProcessor类放到(0202)小节介绍\n\n\n#### ServiceAnnotationBeanPostProcessor类实现\n接下来我们来分析下ServiceAnnotationBeanPostProcessor类,该类用来处理@Service注解，它实现了BeanDefinitionRegistryPostProcessor接口,实现它的postProcessBeanDefinitionRegistry方法允许我们实现自定义的注册bean定义的逻辑。同时也实现了几个以Aware为结尾的接口，例如BeanClassLoaderAware，实现了这些接口后，则ServiceAnnotationBeanPostProcessor类被实例化后将会获取相对应的资源。\n```java\npublic class ServiceAnnotationBeanPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware,\n        ResourceLoaderAware, BeanClassLoaderAware {\n\n    //分隔符\t\n    private static final String SEPARATOR = \":\";\n\n    //扫描的包路径(上面的小节介绍过，注册该bean时，会扫描包路径)\n    private final Set<String> packagesToScan;\n    \n    //实现EnvironmentAware接口，实例化后会自动注入\n    private Environment environment;\n\n    private ResourceLoader resourceLoader;\n\n    private ClassLoader classLoader;\n \n    //构造方法，参数是需要扫描的包路径\n    public ServiceAnnotationBeanPostProcessor(String... packagesToScan) {\n        this(Arrays.asList(packagesToScan));\n    }\n\n    public ServiceAnnotationBeanPostProcessor(Collection<String> packagesToScan) {\n        this(new LinkedHashSet<String>(packagesToScan));\n    }\n\n    public ServiceAnnotationBeanPostProcessor(Set<String> packagesToScan) {\n        //保存包路径\n\tthis.packagesToScan = packagesToScan;\n    }\n\t\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n\t//处理待扫描包里面的占位符(后面会分析该方法)\n        Set<String> resolvedPackagesToScan = resolvePackagesToScan(packagesToScan);\n        \n        if (!CollectionUtils.isEmpty(resolvedPackagesToScan)) {\n            //扫描包，找到存在@Service注解的类，然后注册它(后面会分析该方法)\n\t    registerServiceBeans(resolvedPackagesToScan, registry);\n        } else {\n            if (logger.isWarnEnabled()) {\n                //没有配置带扫描的包路径，将会忽略ServiceBean的注册\n                logger.warn(\"packagesToScan is empty , ServiceBean registry will be ignored!\");\n            }\n        }\n    }\n   \n    /**\n     * 处理带扫描包里面的占位符\n     * @param packagesToScan\n     * @return\n     */\n    private Set<String> resolvePackagesToScan(Set<String> packagesToScan) {\n        Set<String> resolvedPackagesToScan = new LinkedHashSet<String>(packagesToScan.size());\n        //遍历带扫描的包\n        for (String packageToScan : packagesToScan) {\n            if (StringUtils.hasText(packageToScan)) {\n                //通过environment解决占位符\n                String resolvedPackageToScan = environment.resolvePlaceholders(packageToScan.trim());\n                resolvedPackagesToScan.add(resolvedPackageToScan);\n            }\n        }\n        return resolvedPackagesToScan;\n    }\n   \n    /**\n     * 注册存在@Service注解的类\n     * @param packagesToScan 待扫描的基础包路径\n     * @param registry       {@link BeanDefinitionRegistry}\n     */\n    private void registerServiceBeans(Set<String> packagesToScan, BeanDefinitionRegistry registry) {\n\n\t//创建扫描器，用来扫描指定的包路径(后面会介绍该类)\n        DubboClassPathBeanDefinitionScanner scanner =\n                new DubboClassPathBeanDefinitionScanner(registry, environment, resourceLoader);\n\n\t//获取BeanNameGenerator实例用来生成bean name(后面会介绍该方法)\n        BeanNameGenerator beanNameGenerator = resolveBeanNameGenerator(registry);\n        \n\t//将BeanNameGenerator设置到扫描器\n        scanner.setBeanNameGenerator(beanNameGenerator);\n        \n        //设置过滤器，只扫描存在@Service注解的\n        scanner.addIncludeFilter(new AnnotationTypeFilter(Service.class));\n\n\t//遍历基础包\n        for (String packageToScan : packagesToScan) {\n\n            // 首先注册@Service bean\n            scanner.scan(packageToScan);\n\n            // 找到该包下所有存在@Service的BeanDefinition(不论是否是@ComponentScan扫描的)，\n\t    //然后为该bean生成beanName，并将该beanName和BeanDefinition包装成BeanDefinitionHolder（后面会分析该方法）\n            Set<BeanDefinitionHolder> beanDefinitionHolders =\n                    findServiceBeanDefinitionHolders(scanner, packageToScan, registry, beanNameGenerator);\n\n            if (!CollectionUtils.isEmpty(beanDefinitionHolders)) {\n                \n\t\t//遍历beanDefinitionHolders\n                for (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) {\n\t\t    //根据@Service注解 和 beanDefinition  注册ServiceBean类(后面会分析该方法)\n                    registerServiceBean(beanDefinitionHolder, registry, scanner);\n                }\n\n                if (logger.isInfoEnabled()) {\n\t\t    //输出扫描出来的@Service bean的数量，以及扫描的包路径\n                    logger.info(beanDefinitionHolders.size() + \" annotated Dubbo's @Service Components { \" +\n                            beanDefinitionHolders +\n                            \" } were scanned under package[\" + packageToScan + \"]\");\n                }\n            } else {\n                //没有扫描到\n                if (logger.isWarnEnabled()) {\n                    logger.warn(\"No Spring Bean annotating Dubbo's @Service was found under package[\"\n                            + packageToScan + \"]\");\n                }\n            }\n        }\n    }\n\n    /**\n     * 获取BeanNameGenerator\n     * @since 2.5.8\n     */\n    private BeanNameGenerator resolveBeanNameGenerator(BeanDefinitionRegistry registry) {\n\n        BeanNameGenerator beanNameGenerator = null;\n\n        if (registry instanceof SingletonBeanRegistry) {\n\t    //单例bean\n            SingletonBeanRegistry singletonBeanRegistry = SingletonBeanRegistry.class.cast(registry);\n\t    //获取beanName生成器\n            beanNameGenerator = (BeanNameGenerator) singletonBeanRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n        }\n        if (beanNameGenerator == null) {\n            if (logger.isInfoEnabled()) {\n\n                logger.info(\"BeanNameGenerator bean can't be found in BeanFactory with name [\"\n                        + CONFIGURATION_BEAN_NAME_GENERATOR + \"]\");\n                logger.info(\"BeanNameGenerator will be a instance of \" +\n                        AnnotationBeanNameGenerator.class.getName() +\n                        \" , it maybe a potential problem on bean name generation.\");\n            }\n\t    //使用AnnotationBeanNameGenerator\n            beanNameGenerator = new AnnotationBeanNameGenerator();\n        }\n        return beanNameGenerator;\n    }\n\n    /**\n     * 扫描包路径，通过过滤器找到存在@Service注解的bean，然后为该bean生成beanName，\n     * 然后将该beanName和beanDefinition封装成BeanDefinitionHolder对象，返回BeanDefinitionHolder列表\n     */\n    private Set<BeanDefinitionHolder> findServiceBeanDefinitionHolders(\n            ClassPathBeanDefinitionScanner scanner, String packageToScan, BeanDefinitionRegistry registry,\n            BeanNameGenerator beanNameGenerator) {\n \t\n\t//扫描基础包，查询候选组件（通过过滤器过滤出来的，即存在@Service注解的bean）\n        Set<BeanDefinition> beanDefinitions = scanner.findCandidateComponents(packageToScan);\n\n        Set<BeanDefinitionHolder> beanDefinitionHolders = new LinkedHashSet<BeanDefinitionHolder>(beanDefinitions.size());\n\n        for (BeanDefinition beanDefinition : beanDefinitions) {\n\t    //根据beanDefinition生成bean名称\n            String beanName = beanNameGenerator.generateBeanName(beanDefinition, registry);\n           \n\t    //根据beanName和beanDefinition创建BeanDefinitionHolder对象\n\t    BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(beanDefinition, beanName);\n           \n\t    //保存到列表\t\n\t    beanDefinitionHolders.add(beanDefinitionHolder);\n        }\n        return beanDefinitionHolders;\n    }\n\n    /**\n     * 根据@Service注解 和 beanDefinition  注册ServiceBean类\n     * Registers {@link ServiceBean} from new annotated {@link Service} {@link BeanDefinition}\n     */\n    private void registerServiceBean(BeanDefinitionHolder beanDefinitionHolder, BeanDefinitionRegistry registry,\n                                     DubboClassPathBeanDefinitionScanner scanner) {\n\t\n\t//从beanDefinitionHolder中获取beanName，然后加载该类(后面会分析该方法)\n        Class<?> beanClass = resolveClass(beanDefinitionHolder);\n\n\t//查询该bean的@Service注解(后面会分析该方法)\n        Service service = findAnnotation(beanClass, Service.class);\n\t\t\n\t//获取interfaceClass接口(后面会分析该方法)\n        Class<?> interfaceClass = resolveServiceInterfaceClass(beanClass, service);\n\t\n\t//获取bean的名称\n        String annotatedServiceBeanName = beanDefinitionHolder.getBeanName();\n\t\n\t//构建ServiceBean定义(后面会分析该方法)\n        AbstractBeanDefinition serviceBeanDefinition =\n                buildServiceBeanDefinition(service, interfaceClass, annotatedServiceBeanName);\n\t\n        //生成ServiceBean的beanName(后面会分析该方法)\n        String beanName = generateServiceBeanName(service, interfaceClass, annotatedServiceBeanName);\n\n\t//检测重复的候选bean\n        if (scanner.checkCandidate(beanName, serviceBeanDefinition)) {\n\t    //注解ServiceBean\n            registry.registerBeanDefinition(beanName, serviceBeanDefinition);\n\n            if (logger.isInfoEnabled()) {\n                logger.warn(\"The BeanDefinition[\" + serviceBeanDefinition +\n                        \"] of ServiceBean has been registered with name : \" + beanName);\n            }\n        } else {\n\t    //发现重复的bean定义，@DubboComponentScan多次扫描到同一个包？\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"The Duplicated BeanDefinition[\" + serviceBeanDefinition +\n                        \"] of ServiceBean[ bean name : \" + beanName +\n                        \"] was be found , Did @DubboComponentScan scan to same package in many times?\");\n            }\n        }\n    }\n\n    /**\n     * 生成ServiceBean的bean name\n     *\n     * @param service  @Service注解\n     * @param interfaceClass 存在@Service注解的类的接口\n     * @param annotatedServiceBeanName 存在@Service注解的Bean name\n     * @return ServiceBean@interfaceClassName#annotatedServiceBeanName\n     * @since 2.5.9\n     */\n    private String generateServiceBeanName(Service service, Class<?> interfaceClass, String annotatedServiceBeanName) {\n\t//添加\"ServiceBean\"\n        StringBuilder beanNameBuilder = new StringBuilder(ServiceBean.class.getSimpleName());\n\n\t//添加分隔符\":\" 和 annotatedServiceBeanName \n        beanNameBuilder.append(SEPARATOR).append(annotatedServiceBeanName);\n\n        //获取接口的全限定名\n        String interfaceClassName = interfaceClass.getName();\n  \n        //添加分隔符\":\" 和 interfaceClassName\n        beanNameBuilder.append(SEPARATOR).append(interfaceClassName);\n       \n  \t//获取@Service注解的version属性\n        String version = service.version();\n\t\n        if (StringUtils.hasText(version)) {\n            //添加分隔符\":\" 和 version\n\t    beanNameBuilder.append(SEPARATOR).append(version);\n        }\n\t\n\t//获取Service的group属性\n        String group = service.group();\n        if (StringUtils.hasText(group)) {\n\t    //添加分隔符\":\" 和 group\n            beanNameBuilder.append(SEPARATOR).append(group);\n        }\n\t//返回生成的bean名称\n        return beanNameBuilder.toString();\n    }\n\n    /**\n     * 处理@Service注解里的interfaceClass()，该interfaceClass不可以为空，并且必须是接口类型\n     * 1、获取@Service注解中的interfaceClass()\n     * 2、获取@Service注解中的interfaceName()，并加载\n     * 3、获取@Service注解类的第1个接口\n     * @param annotatedServiceBeanClass 存在@Service注解的类\n     * @param service @Service注解\n     * @return\n     */\n    private Class<?> resolveServiceInterfaceClass(Class<?> annotatedServiceBeanClass, Service service) {\n        \n\t//interfaceClass默认为@Service注解的interfaceClass属性\n        Class<?> interfaceClass = service.interfaceClass();\n\t\n\t\n        if (void.class.equals(interfaceClass)) {\n\t    //@Service注解的interfaceClass属性为空\n            interfaceClass = null;\n\t\t\n\t    //获取@Service注解的interfaceName属性\n            String interfaceClassName = service.interfaceName();\n            if (StringUtils.hasText(interfaceClassName)) {\n\t\t//判断是否存在interfaceClassName类\n                if (ClassUtils.isPresent(interfaceClassName, classLoader)) {\n\t\t    //加载interfaceClassName类，并赋值给interfaceClass\n                    interfaceClass = resolveClassName(interfaceClassName, classLoader);\n                }\n            }\n        }\n\n        if (interfaceClass == null) {\n\t    //获取该类的所有接口\n            Class<?>[] allInterfaces = annotatedServiceBeanClass.getInterfaces();\n            if (allInterfaces.length > 0) {\n\t\t//取第一个接口，赋值给interfaceClass\n                interfaceClass = allInterfaces[0];\n            }\n\n        }\n\t//验证不为空，且interfaceClass为接口\n        Assert.notNull(interfaceClass,\n                \"@Service interfaceClass() or interfaceName() or interface class must be present!\");\n\n        Assert.isTrue(interfaceClass.isInterface(),\n                \"The type that was annotated @Service is not an interface!\");\n\n        return interfaceClass;\n    }\n\t\n    private Class<?> resolveClass(BeanDefinitionHolder beanDefinitionHolder) {\n\t//获取bean定义\n        BeanDefinition beanDefinition = beanDefinitionHolder.getBeanDefinition();\n        return resolveClass(beanDefinition);\n\n    }\n\t\n    /**\n     * 加载类\n     */\n    private Class<?> resolveClass(BeanDefinition beanDefinition) {\n\t//获取bean的类名\n        String beanClassName = beanDefinition.getBeanClassName();\n \t//加载该类\t\n        return resolveClassName(beanClassName, classLoader);\n    }\n\n    /**\n     * 构建ServiceBean定义\n     * @param service  @Service注解\n     * @param interfaceClass 接口类\n     * @param annotatedServiceBeanName 存在@Service注解的类的bean name\n     */\n    private AbstractBeanDefinition buildServiceBeanDefinition(Service service, Class<?> interfaceClass,\n                                                              String annotatedServiceBeanName) {\n\t\n\t//获取ServiceBean的BeanDefinition构造器\n        BeanDefinitionBuilder builder = rootBeanDefinition(ServiceBean.class);\n\t\n\t//获取BeanDefinition\n        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();\n\t\n\t//获取ServiceBean的属性\n        MutablePropertyValues propertyValues = beanDefinition.getPropertyValues();\n\n\t//忽略的属性名称,这些属性的值后面会设置，从@Service注解中获取\n        String[] ignoreAttributeNames = of(\"provider\", \"monitor\", \"application\", \"module\", \"registry\", \"protocol\", \"interface\");\n\t\n\t//添加属性值(后面会介绍该类)\n        propertyValues.addPropertyValues(new AnnotationPropertyValuesAdapter(service, environment, ignoreAttributeNames));\n\n        //为ServiceBean添加ref属性，属性值为annotatedServiceBeanName(即存在@Service注解的bean name)(后面会分析该方法)\t\n        addPropertyReference(builder, \"ref\", annotatedServiceBeanName);\n        //为ServiceBean添加interface属性，属性值为interfaceClass接口的名称\n        builder.addPropertyValue(\"interface\", interfaceClass.getName());\n\n\t//获取@Service注解的provider属性(即com.alibaba.dubbo.config.ProviderConfig)\n        String providerConfigBeanName = service.provider();\n        if (StringUtils.hasText(providerConfigBeanName)) {\n\t    //为ServiceBean添加provider属性，属性值为providerConfigBeanName\n            addPropertyReference(builder, \"provider\", providerConfigBeanName);\n        }\n\n        //获取@Service注解的monitor属性(即com.alibaba.dubbo.config.MonitorConfig)\n\tString monitorConfigBeanName = service.monitor();\n        if (StringUtils.hasText(monitorConfigBeanName)) {\n\t    //为ServiceBean添加monitor属性，属性值为monitorConfigBeanName\n            addPropertyReference(builder, \"monitor\", monitorConfigBeanName);\n        }\n\n\t//获取@Service注解的application属性(即com.alibaba.dubbo.config.ApplicationConfig)\n        String applicationConfigBeanName = service.application();\n        if (StringUtils.hasText(applicationConfigBeanName)) {\n\t    //为ServiceBean添加application属性，属性值为applicationConfigBeanName\n            addPropertyReference(builder, \"application\", applicationConfigBeanName);\n        }\n\n\t//获取@Service注解的module属性(即com.alibaba.dubbo.config.ModuleConfig)\n\tString moduleConfigBeanName = service.module();\n        if (StringUtils.hasText(moduleConfigBeanName)) {\n\t    //为ServiceBean添加module属性，属性值为moduleConfigBeanName\n            addPropertyReference(builder, \"module\", moduleConfigBeanName);\n        }\n\n\n\t//获取@Service注解的registry属性(即com.alibaba.dubbo.config.RegistryConfig)\n        String[] registryConfigBeanNames = service.registry();\n\t//遍历registryConfigBeanNames，处理占位符，然后包装成RuntimeBeanReference并返回(后面会分析该方法)\n        List<RuntimeBeanReference> registryRuntimeBeanReferences = toRuntimeBeanReferences(registryConfigBeanNames);\n\n        if (!registryRuntimeBeanReferences.isEmpty()) {\n            //为ServiceBean添加registries属性\n\t    builder.addPropertyValue(\"registries\", registryRuntimeBeanReferences);\n        }\n\n        //获取@Service的protocol属性(即com.alibaba.dubbo.config.ProtocolConfig)\n\tString[] protocolConfigBeanNames = service.protocol();\n\t//处理占位符\n        List<RuntimeBeanReference> protocolRuntimeBeanReferences = toRuntimeBeanReferences(protocolConfigBeanNames);\n\n        if (!protocolRuntimeBeanReferences.isEmpty()) {\n            //为ServiceBean添加protocols属性\n\t    builder.addPropertyValue(\"protocols\", protocolRuntimeBeanReferences);\n        }\n\t//返回@ServiceBean定义\n        return builder.getBeanDefinition();\n    }\n\n\t\n    /**\n     * 处理占位符，并包装成包装成RuntimeBeanReference对象\n     * @param beanNames\n     * @return\n     */\n    private ManagedList<RuntimeBeanReference> toRuntimeBeanReferences(String... beanNames) {\n        ManagedList<RuntimeBeanReference> runtimeBeanReferences = new ManagedList<RuntimeBeanReference>();\n        if (!ObjectUtils.isEmpty(beanNames)) {\n            //遍历bean names\n            for (String beanName : beanNames) {\n\t\t//解决占位符\n                String resolvedBeanName = environment.resolvePlaceholders(beanName);\n\t\t//将beanName包装成RuntimeBeanReference对象\n                runtimeBeanReferences.add(new RuntimeBeanReference(resolvedBeanName));\n            }\n        }\n        return runtimeBeanReferences;\n    }\n    \n    /**\n     * 为ServiceBean添加propertyName属性，属性值为beanName\n     * @param builder ServiceBean定义构造器\n     * @param propertyName 属性名称\n     * @param beanName 存在@Service直接的bean name\n     */\n    private void addPropertyReference(BeanDefinitionBuilder builder, String propertyName, String beanName) {\n        //处理占位符\n\tString resolvedBeanName = environment.resolvePlaceholders(beanName);\n        //为ServiceBean添加propertyName属性，属性值为resolvedBeanName\n\tbuilder.addPropertyReference(propertyName, resolvedBeanName);\n    }\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        this.environment = environment;\n    }\n\n    @Override\n    public void setResourceLoader(ResourceLoader resourceLoader) {\n        this.resourceLoader = resourceLoader;\n    }\n\n    @Override\n    public void setBeanClassLoader(ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n}\n```\n我们再看下用到的其他类\n##### DubboClassPathBeanDefinitionScanner\n该类继承自ClassPathBeanDefinitionScanner,它提供自动扫描功能,根据提供的基础包路径,扫描classpath下该基础包路径,找到符合条件的类并注册为Spring的一个Bean,\n默认情况下,ClassPathBeanDefinitionScanner将会扫描所有用Spring指定了的注解标识的类,包括@Component、@Service、@Repository、@Controller,\n也可以对扫描的机制进行配置,设置一些Filter,只有满足Filter的类才能被注册为Bean.\n```java\npublic class DubboClassPathBeanDefinitionScanner extends ClassPathBeanDefinitionScanner {\n\n    public DubboClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry,\n                                               boolean useDefaultFilters,\n                                               Environment environment,\n                                               ResourceLoader resourceLoader) {\n        super(registry, useDefaultFilters);\n        \n\tsetEnvironment(environment);\n\n        setResourceLoader(resourceLoader);\n\n\t//会调用AnnotationConfigUtils类的registerAnnotationConfigProcessors方法\n        registerAnnotationConfigProcessors(registry);\n    }\n    public DubboClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry,\n                                               Environment environment,\n                                               ResourceLoader resourceLoader) {\n        this(registry, false, environment, resourceLoader);\n    }\n\n    @Override\n    public Set<BeanDefinitionHolder> doScan(String... basePackages) {\n        return super.doScan(basePackages);\n    }\n\n    @Override\n    public boolean checkCandidate(String beanName, BeanDefinition beanDefinition) throws IllegalStateException {\n        //检测beanName是否已经存在\n        return super.checkCandidate(beanName, beanDefinition);\n    }\n}\n```\n接下来我们看下AnnotationConfigUtils类的registerAnnotationConfigProcessors方法\n```java\npublic static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(\n\t\t\tBeanDefinitionRegistry registry, Object source) {\n\n\t//···省略···\n\tSet<BeanDefinitionHolder> beanDefs = new LinkedHashSet(4);\n\tRootBeanDefinition def;\n\n\t//注册ConfigurationClassPostProcessor\n\tif (!registry.containsBeanDefinition(\"org.springframework.context.annotation.internalConfigurationAnnotationProcessor\")) {\n\t    //1.在spring使用AnnotationConfigBeanDefinitionParser解析xml文件的时候  也就是配置annotation-config的时候\n            //2.启动在AnnotationConfigApplicationContext容器的时候\n\t    def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);\n\t    def.setSource(source);\n\t    beanDefs.add(registerPostProcessor(registry, def, \"org.springframework.context.annotation.internalConfigurationAnnotationProcessor\"));\n\t}\n\t\n\t//注册AutowiredAnnotationBeanPostProcessor \n\tif (!registry.containsBeanDefinition(\"org.springframework.context.annotation.internalAutowiredAnnotationProcessor\")) {\n\t    def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);\n\t    def.setSource(source);\n\t    beanDefs.add(registerPostProcessor(registry, def, \"org.springframework.context.annotation.internalAutowiredAnnotationProcessor\"));\n\t}\n\n\t//···省略···\n\treturn beanDefs;\n}\n```\n##### AnnotationPropertyValuesAdapter\n该类实现了Spring的PropertyValues接口，此接口是PropertyValue的集合管理类,用来储存键值对.MutablePropertyValues是其常用实现类\n在该适配器内部就是用了MutablePropertyValues实现类来进行操作。\n```java\n//我们在上文构建ServiceBean定义的时候会创建AnnotationPropertyValuesAdapter类，相关代码如下：\n//String[] ignoreAttributeNames = of(\"provider\", \"monitor\", \"application\", \"module\", \"registry\", \"protocol\", \"interface\");\n//propertyValues.addPropertyValues(new AnnotationPropertyValuesAdapter(service, environment, ignoreAttributeNames));\n//其中service参数是@Service注解，而environment参数类实现了PropertyResolver接口\n\n\nclass AnnotationPropertyValuesAdapter implements PropertyValues {\n     \n    //传过来的注解\n    private final Annotation annotation;\n    \n    //属性解决器,规范了解析底层任意property资源的接口\n    private final PropertyResolver propertyResolver;\n\n    //是否忽略默认值\n    private final boolean ignoreDefaultValue;\n\t\n    //委托类,即MutablePropertyValues\n    private final PropertyValues delegate;\n\n    public AnnotationPropertyValuesAdapter(Annotation annotation, PropertyResolver propertyResolver, boolean ignoreDefaultValue, String... ignoreAttributeNames) {\n        this.annotation = annotation;\n        this.propertyResolver = propertyResolver;\n        this.ignoreDefaultValue = ignoreDefaultValue;\n        //生成MutablePropertyValues\n        this.delegate = adapt(annotation, ignoreDefaultValue, ignoreAttributeNames);\n    }\n\n    public AnnotationPropertyValuesAdapter(Annotation annotation, PropertyResolver propertyResolver, String... ignoreAttributeNames) {\n        this(annotation, propertyResolver, true, ignoreAttributeNames);\n    }\n\n    private PropertyValues adapt(Annotation annotation, boolean ignoreDefaultValue, String... ignoreAttributeNames) {\n        //创建MutablePropertyValues类(后面会分析该方法getAttributes()\n\treturn new MutablePropertyValues(getAttributes(annotation, propertyResolver, ignoreDefaultValue, ignoreAttributeNames));\n    }\n\n    public Annotation getAnnotation() {\n        return annotation;\n    }\n\n    public boolean isIgnoreDefaultValue() {\n        return ignoreDefaultValue;\n    }\n\n    @Override\n    public PropertyValue[] getPropertyValues() {\n\t//调用委托类的方法\n        return delegate.getPropertyValues();\n    }\n\n    @Override\n    public PropertyValue getPropertyValue(String propertyName) {\n        //调用委托类的方法获取属性值\n        return delegate.getPropertyValue(propertyName);\n    }\n\n    @Override\n    public PropertyValues changesSince(PropertyValues old) {\n        return delegate.changesSince(old);\n    }\n\n    @Override\n    public boolean contains(String propertyName) {\n        return delegate.contains(propertyName);\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return delegate.isEmpty();\n    }\n}\n```\n下面我们看下AnnotationUtils.getAttributes方法\n```java\n/**\n * 获取注解的属性集合\n * @param annotation   注解\n * @param propertyResolver 属性解决器\n *    1、根据属性名称获取属性值（替换后的）\n *    2、替换${propertyName:defaultValue}格式的占位符为实际值\n * @param ignoreDefaultValue 是否忽略默认值\n * @param ignoreAttributeNames 需要忽略的属性名\n * @return <属性名，属性值>\n */\npublic static Map<String, Object> getAttributes(Annotation annotation,\n\t\t\t\t\t    PropertyResolver propertyResolver,\n\t\t\t\t\t    boolean ignoreDefaultValue,\n\t\t\t\t\t    String... ignoreAttributeNames) {\n\t\n\t//需要忽略的属性名\n\tSet<String> ignoreAttributeNamesSet = new HashSet<String>(arrayToList(ignoreAttributeNames));\n\n\t//获取annotation注解的属性map(调用的Spring的AnnotationUtils.getAnnotationAttributes方法)\n\tMap<String, Object> attributes = getAnnotationAttributes(annotation);\n\t//属性名,真实属性值\n\tMap<String, Object> actualAttributes = new LinkedHashMap<String, Object>();\n\t\n\t//是否需要处理占位符\n\tboolean requiredResolve = propertyResolver != null;\n\n\tfor (Map.Entry<String, Object> entry : attributes.entrySet()) {\n\t    //属性名称\n\t    String attributeName = entry.getKey();\n\t    //属性值\n\t    Object attributeValue = entry.getValue();\n\n\t    //忽略默认属性值\n\t    if (ignoreDefaultValue && nullSafeEquals(attributeValue, getDefaultValue(annotation, attributeName))) {\n\t\t//属性值和默认值相等，则跳过该属性\n\t\tcontinue;\n\t    }\n\n\t    //忽略属性名\n\t    if (ignoreAttributeNamesSet.contains(attributeName)) {\n\t\t//如果待忽略的属性名列表包含该属性名，则跳过该属性\n\t\tcontinue;\n\t    }\n\n\t    // 处理占位符,属性值为字符串类型\n\t    if (requiredResolve && attributeValue instanceof String) {\n\t\t//获取真实属性值\n\t\tString resolvedValue = propertyResolver.resolvePlaceholders(valueOf(attributeValue));\n\t\t//格式化真实属性值\n\t\tattributeValue = trimAllWhitespace(resolvedValue);\n\t    }\n\t    //保存属性名和真实属性值\n\t    actualAttributes.put(attributeName, attributeValue);\n\t}\n\treturn actualAttributes;\n}\n```\n\n##### ServiceBean类\n在上面的内容中，我们完成了ServiceBean类的注册，现在我们详细看看ServiceBean类.该类继承自ServiceConfig类，并且实现了众多Spring接口\n```java\n/**\n * ServiceFactoryBean\n * InitializingBean接口在bean实例化完成后将会自动调用afterPropertiesSet方法\n * DisposableBean接口在bean销毁之前调用destroy方法\n * ApplicationContextAware接口在bean实例化完成后将会注入ApplicationContext属性\n * ApplicationListener接口Spring容器初始化完成后会回调onApplicationEvent方法\n * BeanNameAware接口注入bean名称\n *\n * @export\n */\npublic class ServiceBean<T> extends ServiceConfig<T> implements InitializingBean, DisposableBean, ApplicationContextAware, ApplicationListener<ContextRefreshedEvent>, BeanNameAware {\n\n    private static final long serialVersionUID = 213195494150089726L;\n\n\n    private static transient ApplicationContext SPRING_CONTEXT;\n\n    /**\n     * @Service注解\n     */\n    private final transient Service service;\n\n    private transient ApplicationContext applicationContext;\n\n    private transient String beanName;\n\n    /**\n     * 是否支持ApplicationListener\n     */\n    private transient boolean supportedApplicationListener;\n\n    public ServiceBean() {\n        super();\n        this.service = null;\n    }\n\n    public ServiceBean(Service service) {\n        super(service);\n        this.service = service;\n    }\n\n    /**\n     * 获取Spring ApplicationContext\n     * @return\n     */\n    public static ApplicationContext getSpringContext() {\n        return SPRING_CONTEXT;\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) {\n        //设置ApplicationContext\n        this.applicationContext = applicationContext;\n        SpringExtensionFactory.addApplicationContext(applicationContext);\n        if (applicationContext != null) {\n            SPRING_CONTEXT = applicationContext;\n            try {\n                //backward compatibility to spring 2.0.1\n                //从applicationContext中获取到addApplicationListener方法\n                Method method = applicationContext.getClass().getMethod(\"addApplicationListener\", new Class<?>[]{ApplicationListener.class});\n                //调用applicationContext的addApplicationListener方法，将当前对象添加进去\n                method.invoke(applicationContext, new Object[]{this});\n                //设置支持ApplicationListener\n                supportedApplicationListener = true;\n            } catch (Throwable t) {\n                if (applicationContext instanceof AbstractApplicationContext) {\n                    try {\n                        // 向后兼容\n                        // backward compatibility to spring 2.0.1\n                        Method method = AbstractApplicationContext.class.getDeclaredMethod(\"addListener\", new Class<?>[]{ApplicationListener.class});\n                        if (!method.isAccessible()) {\n                            method.setAccessible(true);\n                        }\n                        method.invoke(applicationContext, new Object[]{this});\n                        supportedApplicationListener = true;\n                    } catch (Throwable t2) {\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void setBeanName(String name) {\n        this.beanName = name;\n    }\n\n    public Service getService() {\n        return service;\n    }\n\n    @Override\n    public void onApplicationEvent(ContextRefreshedEvent event) {\n\t//没有配置delay，或者delay = -1\n        if (isDelay() && !isExported() && !isUnexported()) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"The service ready on spring started. service: \" + getInterface());\n            }\n            //暴露服务(后面会分析该方法)\n            export();\n        }\n    }\n\n    /**\n     * 两种情况：\n     * 1、设置了延迟暴露(delay != null && delay != -1)，dubbo在Spring实例化bean的时候会对实现了InitializingBean的类进行回调，\n     * 回调方法是afterPropertySet()，如果设置了延迟暴露，dubbo在这个方法中进行服务的发布。\n     * 2、没有设置延迟或者延迟为-1，dubbo会在Spring实例化完bean之后，\n     * 在刷新容器最后一步发布ContextRefreshEvent事件的时候，\n     * 通知实现了ApplicationListener的类进行回调onApplicationEvent，dubbo会在这个方法中发布服务\n     * @return\n     */\n    private boolean isDelay() {\n        //获取delay属性\n        Integer delay = getDelay();\n        //获取服务提供者\n        ProviderConfig provider = getProvider();\n        if (delay == null && provider != null) {\n            //delay属性为空，则取服务提供者的delay属性\n            delay = provider.getDelay();\n        }\n        //(支持spring监听事件 && 没有设置延迟或者延迟为-1) 则返回true\n        return supportedApplicationListener && (delay == null || delay == -1);\n    }\n\n\t\n    /**\n     * 1、会判断ServiceBean的ProviderConfig、ApplicationConfig、ModuleConfig、List<RegistryConfig>、MonitorConfig、List<ProtocolConfig>属性是否为空，为空的话，从Spring容器中获取，然后进行赋值，其中还会检测是否存在重复的配置(default属性)\n     * 2、接着会判断并设置path属性(使用beanName)\n     * 3、根据delay属性判断是否需要暴露服务\n     */\n    @Override\n    @SuppressWarnings({\"unchecked\", \"deprecation\"})\n    public void afterPropertiesSet() throws Exception {\n        //没有配置Provider\n        if (getProvider() == null) {\n            //从IOC容器中获取到所有的Provider\n            Map<String, ProviderConfig> providerConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProviderConfig.class, false, false);\n            if (providerConfigMap != null && providerConfigMap.size() > 0) {\n                //从IOC容器中获取到所有的Protocol\n                Map<String, ProtocolConfig> protocolConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, false, false);\n                if ((protocolConfigMap == null || protocolConfigMap.size() == 0)\n                        && providerConfigMap.size() > 1) {\n                    // backward compatibility\n                    //如果没有配置Protocol，但是存在Provider的话，遍历Provider列表\n                    //从Provider列表中找到isDefault属性为true的Provider，并保存起来\n                    List<ProviderConfig> providerConfigs = new ArrayList<ProviderConfig>();\n                    for (ProviderConfig config : providerConfigMap.values()) {\n                        if (config.isDefault() != null && config.isDefault().booleanValue()) {\n                            //找到default为true的Provider\n                            providerConfigs.add(config);\n                        }\n                    }\n                    if (!providerConfigs.isEmpty()) {\n                        //根据Provider构造Protocol(废弃方法)\n                        setProviders(providerConfigs);\n                    }\n                } else {\n                    ProviderConfig providerConfig = null;\n                    //从provider列表中找到default属性为null或者为true的provider，如果找到多个则抛异常\n                    for (ProviderConfig config : providerConfigMap.values()) {\n                        //没有配置isDefault属性或者isDefault = true\n                        //检测是否存在重复的Provider配置\n                        if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                            if (providerConfig != null) {\n                                throw new IllegalStateException(\"Duplicate provider configs: \" + providerConfig + \" and \" + config);\n                            }\n                            providerConfig = config;\n                        }\n                    }\n                    if (providerConfig != null) {\n                        //设置Provider\n                        setProvider(providerConfig);\n                    }\n                }\n            }\n        }\n        if (getApplication() == null\n                && (getProvider() == null || getProvider().getApplication() == null)) {\n            //从IOC容器中找到所有的ApplicationConfig\n            Map<String, ApplicationConfig> applicationConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, false, false);\n            if (applicationConfigMap != null && applicationConfigMap.size() > 0) {\n                ApplicationConfig applicationConfig = null;\n                //检测是否存在重复的Application配置(default属性为null或者为true)\n                for (ApplicationConfig config : applicationConfigMap.values()) {\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        if (applicationConfig != null) {\n                            throw new IllegalStateException(\"Duplicate application configs: \" + applicationConfig + \" and \" + config);\n                        }\n                        applicationConfig = config;\n                    }\n                }\n                if (applicationConfig != null) {\n                    setApplication(applicationConfig);\n                }\n            }\n        }\n        if (getModule() == null\n                && (getProvider() == null || getProvider().getModule() == null)) {\n            //从IOC容器中找到所有的ModuleConfig\n            Map<String, ModuleConfig> moduleConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, false, false);\n            if (moduleConfigMap != null && moduleConfigMap.size() > 0) {\n                ModuleConfig moduleConfig = null;\n                //检测是否存在重复的Module配置(default属性为null或者为true)\n                for (ModuleConfig config : moduleConfigMap.values()) {\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        if (moduleConfig != null) {\n                            throw new IllegalStateException(\"Duplicate module configs: \" + moduleConfig + \" and \" + config);\n                        }\n                        moduleConfig = config;\n                    }\n                }\n                if (moduleConfig != null) {\n                    setModule(moduleConfig);\n                }\n            }\n        }\n        //register为空或者Provider中的register为空或者Application中的register为空\n        if ((getRegistries() == null || getRegistries().isEmpty())\n                && (getProvider() == null || getProvider().getRegistries() == null || getProvider().getRegistries().isEmpty())\n                && (getApplication() == null || getApplication().getRegistries() == null || getApplication().getRegistries().isEmpty())) {\n            //从IOC容器中获取RegistryConfig\n            Map<String, RegistryConfig> registryConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, false, false);\n            if (registryConfigMap != null && registryConfigMap.size() > 0) {\n                List<RegistryConfig> registryConfigs = new ArrayList<RegistryConfig>();\n                //遍历registry列表，从中找到default属性为null或者为true的registry，并保存起来\n                for (RegistryConfig config : registryConfigMap.values()) {\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        registryConfigs.add(config);\n                    }\n                }\n                if (registryConfigs != null && !registryConfigs.isEmpty()) {\n                    super.setRegistries(registryConfigs);\n                }\n            }\n        }\n        if (getMonitor() == null\n                && (getProvider() == null || getProvider().getMonitor() == null)\n                && (getApplication() == null || getApplication().getMonitor() == null)) {\n            Map<String, MonitorConfig> monitorConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig.class, false, false);\n            if (monitorConfigMap != null && monitorConfigMap.size() > 0) {\n                MonitorConfig monitorConfig = null;\n                //检测是否存在重复的monitor配置(default属性为空或者为true)\n                for (MonitorConfig config : monitorConfigMap.values()) {\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        if (monitorConfig != null) {\n                            throw new IllegalStateException(\"Duplicate monitor configs: \" + monitorConfig + \" and \" + config);\n                        }\n                        monitorConfig = config;\n                    }\n                }\n                if (monitorConfig != null) {\n\t\t    //设置monitor\n                    setMonitor(monitorConfig);\n                }\n            }\n        }\n        if ((getProtocols() == null || getProtocols().isEmpty())\n                && (getProvider() == null || getProvider().getProtocols() == null || getProvider().getProtocols().isEmpty())) {\n            //从IOC容器中获取ProtocolConfig\n            Map<String, ProtocolConfig> protocolConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, false, false);\n            if (protocolConfigMap != null && protocolConfigMap.size() > 0) {\n                List<ProtocolConfig> protocolConfigs = new ArrayList<ProtocolConfig>();\n                //遍历Protocol列表，从中找到default属性为空，或者为true的Protocol，并保存起来\n                for (ProtocolConfig config : protocolConfigMap.values()) {\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        protocolConfigs.add(config);\n                    }\n                }\n                if (protocolConfigs != null && !protocolConfigs.isEmpty()) {\n                    super.setProtocols(protocolConfigs);\n                }\n            }\n        }\n        if (getPath() == null || getPath().length() == 0) {\n            //path服务名称为空的话\n            if (beanName != null && beanName.length() > 0\n                    && getInterface() != null && getInterface().length() > 0\n                    && beanName.startsWith(getInterface())) {\n                //使用beanName作为服务名称\n                setPath(beanName);\n            }\n        }\n        if (!isDelay()) {\n            //配置了delay属性，暴露服务(后面会分析该方法)\n            export();\n        }\n    }\n\n    @Override\n    public void destroy() throws Exception {\n        // This will only be called for singleton scope bean, and expected to be called by spring shutdown hook when BeanFactory/ApplicationContext destroys.\n        // We will guarantee dubbo related resources being released with dubbo shutdown hook.\n        //unexport();\n    }\n\n    // merged from dubbox\n    @Override\n    protected Class getServiceClass(T ref) {\n        if (AopUtils.isAopProxy(ref)) {\n            //从Aop代理类中获取到目标对象\n            return AopUtils.getTargetClass(ref);\n        }\n        return super.getServiceClass(ref);\n    }\n}\n```\n###### export方法\nexport方法是定义在ServiceBean的父类ServiceConfig中的\n```java\npublic synchronized void export() {\n\tif (provider != null) {\n\t    if (export == null) {\n\t\t//export属性为空的话，则获取provider中的export属性\n\t\texport = provider.getExport();\n\t    }\n\t    if (delay == null) {\n\t\t//delay属性为空的话，则获取provider中的delay属性\n\t\tdelay = provider.getDelay();\n\t    }\n\t}\n\tif (export != null && !export) {\n\t    //如果不暴露服务，直接返回\n\t    return;\n\t}\n\n\tif (delay != null && delay > 0) {\n\t    //delay大于0的话，会启动线程，延迟暴露服务\n\t    delayExportExecutor.schedule(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t    doExport();\n\t\t}\n\t    }, delay, TimeUnit.MILLISECONDS);\n\t} else {\n\t    //直接暴露服务\n\t    doExport();\n\t}\n}\n```\n可以看到最终会调用doExport方法进行服务暴露\n```java\nprotected synchronized void doExport() {\n\tif (unexported) {\n\t    //检测是否已经取消服务暴露\n\t    throw new IllegalStateException(\"Already unexported!\");\n\t}\n\tif (exported) {\n\t    //已经暴露过服务，直接返回\n\t    return;\n\t}\n\texported = true;\n\t//检查服务接口interface属性是否配置\n\tif (interfaceName == null || interfaceName.length() == 0) {\n\t    throw new IllegalStateException(\"<dubbo:service interface=\\\"\\\" /> interface not allow null!\");\n\t}\n\t//检测ProviderConfig是否已配置，没有配置则进行配置(此方法在\"Dubbo源码阅读之集成Spring(03)\"中介绍过)\n\tcheckDefault();\n\tif (provider != null) {\n\t    //从provider中获取缺失的配置\n\t    if (application == null) {\n\t\tapplication = provider.getApplication();\n\t    }\n\t    if (module == null) {\n\t\tmodule = provider.getModule();\n\t    }\n\t    if (registries == null) {\n\t\tregistries = provider.getRegistries();\n\t    }\n\t    if (monitor == null) {\n\t\tmonitor = provider.getMonitor();\n\t    }\n\t    if (protocols == null) {\n\t\tprotocols = provider.getProtocols();\n\t    }\n\t}\n\tif (module != null) {\n\t    //从module中获取注册中心和监控中心\n\t    if (registries == null) {\n\t\tregistries = module.getRegistries();\n\t    }\n\t    if (monitor == null) {\n\t\tmonitor = module.getMonitor();\n\t    }\n\t}\n\tif (application != null) {\n\t    //从application中获取注册中心和监控中心\n\t    if (registries == null) {\n\t\tregistries = application.getRegistries();\n\t    }\n\t    if (monitor == null) {\n\t\tmonitor = application.getMonitor();\n\t    }\n\t}\n\t//获取服务接口类interfaceClass\n\tif (ref instanceof GenericService) {\n\t    //服务接口为GenericService类型\n\t    interfaceClass = GenericService.class;\n\t    if (StringUtils.isEmpty(generic)) {\n\t\t//generic属性为空的话，则设置为true\n\t\tgeneric = Boolean.TRUE.toString();\n\t    }\n\t} else {\n\t    try {\n\t\t//加载interfaceName类\n\t\tinterfaceClass = Class.forName(interfaceName, true, Thread.currentThread()\n\t\t\t.getContextClassLoader());\n\t    } catch (ClassNotFoundException e) {\n\t\tthrow new IllegalStateException(e.getMessage(), e);\n\t    }\n\t    //检测方法列表methods是否都在接口interfaceClass中存在\n\t    checkInterfaceAndMethods(interfaceClass, methods);\n\t    //校验ref类(ref不可以为空，并且实现了interfaceClass接口)\n\t    checkRef();\n\t    //将generic属性设置成false\n\t    generic = Boolean.FALSE.toString();\n\t}\n\t//处理服务接口本地实现类\n\tif (local != null) {\n\t    if (\"true\".equals(local)) {\n\t\t//默认情况下，实现类名称为：interfaceName + \"Local\"\n\t\tlocal = interfaceName + \"Local\";\n\t    }\n\t    Class<?> localClass;\n\t    try {\n\t\t//加载实现类\n\t\tlocalClass = ClassHelper.forNameWithThreadContextClassLoader(local);\n\t    } catch (ClassNotFoundException e) {\t\n\t\t//没有找到该实现类\n\t\tthrow new IllegalStateException(e.getMessage(), e);\n\t    }\n\t    //校验服务接口本地实现类是否实现了interfaceClass接口\n\t    if (!interfaceClass.isAssignableFrom(localClass)) {\n\t\tthrow new IllegalStateException(\"The local implementation class \" + localClass.getName() + \" not implement interface \" + interfaceName);\n\t    }\n\t}\n\t//处理服务接口本地存根实现类\n\tif (stub != null) {\n\t    if (\"true\".equals(stub)) {\n\t\t//默认情况下，实现类名称为：interfaceName + \"Stub\"\n\t\tstub = interfaceName + \"Stub\";\n\t    }\n\t    Class<?> stubClass;\n\t    try {\n\t\t//加载实现类\n\t\tstubClass = ClassHelper.forNameWithThreadContextClassLoader(stub);\n\t    } catch (ClassNotFoundException e) {\n\t\tthrow new IllegalStateException(e.getMessage(), e);\n\t    }\n\t    //校验该存根类是否实现了interfaceClass接口\n\t    if (!interfaceClass.isAssignableFrom(stubClass)) {\n\t\tthrow new IllegalStateException(\"The stub implementation class \" + stubClass.getName() + \" not implement interface \" + interfaceName);\n\t    }\n\t}\n\t//检测ApplicationConfig是否为空(会调用appendProperties方法添加属性，该方法在之前博文介绍过)\n\tcheckApplication();\n\t//检测注册中心list是否为空(从配置文件中获取dubbo.registry.address属性，然后创建RegistryConfig对象，添加属性，放入到list中)\n\tcheckRegistry();\n\t//检测协议protocols是否为空，如果为空且provider不为空，则先从provider对象中获取\n\t//然后遍历protocols，处理name(name为空，则设置为dubbo)并添加属性。\n\tcheckProtocol();\n\t//为ServiceBean对象添加属性\n\tappendProperties(this);\n\t//检测local/stub/mock配置是否正确\n\t//local/stub/mock(mock 可配置为\"return \")应该为interfaceClass或者为interfaceClass子类\n\tcheckStubAndMock(interfaceClass);\n\t//服务名称path为空的话，则设置为interfaceName\n\tif (path == null || path.length() == 0) {\n\t    path = interfaceName;\n\t}\n\t//暴露url(后面会分析该方法)\n\tdoExportUrls();\n\t//根据服务唯一名称、当前ServiceBean实例、ref 创建ProviderModel实例(后面会分析)\n\tProviderModel providerModel = new ProviderModel(getUniqueServiceName(), this, ref);\n\t//根据服务唯一名称，注册提供者服务，即放到类ApplicationModel中的变量名为providedServices的map中\n\tApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);\n}\n```\n\n###### doExportUrls方法\n该方法内部会调用loadRegistries方法构造注册中心url地址，然后调用doExportUrlsFor1Protocol方法进行服务url的暴露。\n```java\n/**\n * 暴露url\n *\nprivate void doExportUrls() {\n\t//构造注册中心地址(后面会分析该方法)\n\t//例如：registry://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&dubbo=2.0.0&pid=6384&qos.port=22222&registry=multicast&timestamp=1528347455956\n\tList<URL> registryURLs = loadRegistries(true);\n\t\n\t//例如：<dubbo:protocol name=\"dubbo\" port=\"20880\" id=\"dubbo\" />\n\tfor (ProtocolConfig protocolConfig : protocols) {\n\t    //暴露服务url\t\n\t    doExportUrlsFor1Protocol(protocolConfig, registryURLs);\n\t}\n}\n\n/**\n * 构造注册中心URL\n * 优先使用系统配置中的注册中心列表，如果没有配置，则使用RegistryConfig中配置的\n * @param provider 是否是提供者\n * @return\n */\nprotected List<URL> loadRegistries(boolean provider) {\n\t//检测registries变量(即ArrayList<RegistryConfig>。<dubbo:registry address=\"...\" />）\n\tcheckRegistry();\n\tList<URL> registryList = new ArrayList<URL>();\n\t//遍历registries\n\tif (registries != null && !registries.isEmpty()) {\n\t    for (RegistryConfig config : registries) {\n\t\t//获取当前注册中心地址\n\t\tString address = config.getAddress();\n\t\tif (address == null || address.length() == 0) {\n\t\t    //将address设置为*\n\t\t    address = Constants.ANYHOST_VALUE;\n\t\t}\n\t\t//从系统属性中获取注册中心地址\n\t\tString sysaddress = System.getProperty(\"dubbo.registry.address\");\n\t\tif (sysaddress != null && sysaddress.length() > 0) {\n\t\t    //如果系统注册中心地址不为空，则优先使用系统注册中心地址\n\t\t    address = sysaddress;\n\t\t}\n\t\tif (address != null && address.length() > 0\n\t\t\t&& !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) {\n\t\t    //地址可用\n\n\t\t    Map<String, String> map = new HashMap<String, String>();\n\t\t    //附加参数，即找到application、config类中的属性，并添加到map中\n\t\t    appendParameters(map, application);\n\t\t    appendParameters(map, config);\n\t\t    //添加服务名称\n\t\t    map.put(\"path\", RegistryService.class.getName());\n\t\t    //添加dubbo版本\n\t\t    map.put(\"dubbo\", Version.getVersion());\n\t\t    //添加时间戳\n\t\t    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n\t\t    if (ConfigUtils.getPid() > 0) {\n\t\t\t//添加pid\n\t\t\tmap.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n\t\t    }\n\t\t    //添加protocol\n\t\t    if (!map.containsKey(\"protocol\")) {\n\t\t\t//存在扩展名称为remote的RegistryFactory，则设置protocol属性为remote，否则设置为dubbo\n\t\t\tif (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension(\"remote\")) {\n\t\t\t    map.put(\"protocol\", \"remote\");\n\t\t\t} else {\n\t\t\t    map.put(\"protocol\", \"dubbo\");\n\t\t\t}\n\t\t    }\n\t\t    //根据当前注册中心地址和map生产url列表（后面会分析该方法）\n\t\t    List<URL> urls = UrlUtils.parseURLs(address, map);\n\t\t    for (URL url : urls) {\n\t\t\t//向url中添加registry参数，参数值为url的protocol属性(例如：registry=multicast)\n\t\t\turl = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());\n\t\t\t//重新设置url的protocol属性值为“registry”(后面暴露服务时，将会使用该protocol属性值作为扩展名称，获取对应的Protocol实例，因此将会使用RegistryProtocol实例，下一节会详细分析)\n\t\t\turl = url.setProtocol(Constants.REGISTRY_PROTOCOL);\n\t\t\tif ((provider && url.getParameter(Constants.REGISTER_KEY, true))\n\t\t\t\t|| (!provider && url.getParameter(Constants.SUBSCRIBE_KEY, true))) {\n\t\t\t    //提供者 && url中的register参数值为true\n\t\t\t    //不是提供者 && url中的subscribe参数值为true\n\t\t\t    //则将该url添加到registryList列表中\n\t\t\t    registryList.add(url);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\treturn registryList;\n}\n\n/**\n * @param address 注册中心地址列表(\"|\"或者\";\"分隔)\n * @param defaults map参数\n * @return\n */\npublic static List<URL> parseURLs(String address, Map<String, String> defaults) {\n        if (address == null || address.length() == 0) {\n\t    //注册中心地址为空，返回null\n            return null;\n        }\n        //通过“|”或者“;”分隔注册中心地址\n        String[] addresses = Constants.REGISTRY_SPLIT_PATTERN.split(address);\n        if (addresses == null || addresses.length == 0) {\n            return null;\n        }\n        List<URL> registries = new ArrayList<URL>();\n\t//遍历每一个注册中心地址\n        for (String addr : addresses) {\n            //通过注册中心地址addr和map参数构造注册中心URL对象（后面会分析方法）\n            registries.add(parseURL(addr, defaults));\n        }\n\t//返回注册中心地址url列表\n        return registries;\n}\n\n/**\n * 生成注册中心URL\n * 1、根据注册中心地址address生成url字符串(处理备用地址)\n * 2、从defaults集合中获取属性(protocol、username、password、port、path)默认值\n * 3、根据defaults新生成集合defaultParameters，并移除(protocol、username、password、port、path)属性\n * 4、根据url字符串生成URL对象，并获取该URL对象的属性值(protocol、username、password、port、path、parameters),\n *    其中parameters属性值是新生成的一个map。\n * 5、判断URL对象的这些属性值(protocol、username、password、port、path、parameters)是否为空，如果为空，则使用属性默认值，并标识发生了改变。\n * 6、如果发生了改变。则根据新的属性值重新生成一个URL对象并返回。\n * @param address 注册中心地址(可能是多个，使用\",\"分隔)\n * @param defaults map参数\n * @return\n */\npublic static URL parseURL(String address, Map<String, String> defaults) {\n\tif (address == null || address.length() == 0) {\n\t    return null;\n\t}\n\t//该url最终会被解析成URL对象\n\tString url;\n\tif (address.indexOf(\"://\") >= 0) {\n\t    //该注册中心地址包含\"://\"\n\t    url = address;\n\t} else {\n\t    //使用逗号\",\"分隔address地址\n\t    String[] addresses = Constants.COMMA_SPLIT_PATTERN.split(address);\n\t    //将addresses数组第1个元素赋值给url\n\t    url = addresses[0];\n\t    if (addresses.length > 1) {\n\t\t//遍历addresses数组后面的元素(即查看是否存在备用的注册中心地址)\n\t\t//backup记录注册中心备用地址\n\t\tStringBuilder backup = new StringBuilder();\n\t\tfor (int i = 1; i < addresses.length; i++) {\n\t\t    if (i > 1) {\n\t\t\tbackup.append(\",\");\n\t\t    }\n\t\t    backup.append(addresses[i]);\n\t\t}\n\t\t//将注册中心备用地址添加到url的backup参数中\n\t\turl += \"?\" + Constants.BACKUP_KEY + \"=\" + backup.toString();\n\t    }\n\t}\n\t//从defaults中获取protocol属性\n\tString defaultProtocol = defaults == null ? null : defaults.get(\"protocol\");\n\tif (defaultProtocol == null || defaultProtocol.length() == 0) {\n\t    //如果protocol属性值为空，则设置为dubbo\n\t    defaultProtocol = \"dubbo\";\n\t}\n\t//从defaults中获取username属性和password属性\n\tString defaultUsername = defaults == null ? null : defaults.get(\"username\");\n\tString defaultPassword = defaults == null ? null : defaults.get(\"password\");\n\t//从defaults中获取port属性\n\tint defaultPort = StringUtils.parseInteger(defaults == null ? null : defaults.get(\"port\"));\n\t//从defaults中获取path属性\n\tString defaultPath = defaults == null ? null : defaults.get(\"path\");\n\t//根据defaults新生成一个map集合defaultParameters\n\tMap<String, String> defaultParameters = defaults == null ? null : new HashMap<String, String>(defaults);\n\tif (defaultParameters != null) {\n\t    //移除defaultParameters集合中的以下属性\n\t    defaultParameters.remove(\"protocol\");\n\t    defaultParameters.remove(\"username\");\n\t    defaultParameters.remove(\"password\");\n\t    defaultParameters.remove(\"host\");\n\t    defaultParameters.remove(\"port\");\n\t    defaultParameters.remove(\"path\");\n\t}\n\t//根据url字符串生成URL对象\n\tURL u = URL.valueOf(url);\n\t//如果新生成的URL中的某属性值为空，且该属性的默认值不为空，则意味着发生了改变，changed会被设置为true\n\tboolean changed = false;\n\t\n\t//获取URL对象中的protocol、username、password、host、port、path属性\n\tString protocol = u.getProtocol();\n\tString username = u.getUsername();\n\tString password = u.getPassword();\n\tString host = u.getHost();\n\tint port = u.getPort();\n\tString path = u.getPath();\n\t\n\t//获取URL对象的参数map\n\tMap<String, String> parameters = new HashMap<String, String>(u.getParameters());\n\tif ((protocol == null || protocol.length() == 0) && defaultProtocol != null && defaultProtocol.length() > 0) {\n\t    changed = true;\n\t    //使用protocol默认值设置URL的protocol属性\n\t    protocol = defaultProtocol;\n\t}\n\tif ((username == null || username.length() == 0) && defaultUsername != null && defaultUsername.length() > 0) {\n\t    changed = true;\n\t    //使用username默认值设置URL的username属性\n\t    username = defaultUsername;\n\t}\n\tif ((password == null || password.length() == 0) && defaultPassword != null && defaultPassword.length() > 0) {\n\t    changed = true;\n\t    //使用password默认值设置URL的password属性\n\t    password = defaultPassword;\n\t}\n\t/*if (u.isAnyHost() || u.isLocalHost()) {\n\t    changed = true;\n\t    host = NetUtils.getLocalHost();\n\t}*/\n\tif (port <= 0) {\n\t    //URL的port属性值小于0，且默认的port值大于0，则使用defaultPort设置URL的port属性\n\t    if (defaultPort > 0) {\n\t\tchanged = true;\n\t\tport = defaultPort;\n\t    } else {\n\t\t//默认port如果也小于0的话，则设置URL的port属性为9090\n\t\tchanged = true;\n\t\tport = 9090;\n\t    }\n\t}\n\tif (path == null || path.length() == 0) {\n\t    //使用默认服务名称设置URL的path属性\n\t    if (defaultPath != null && defaultPath.length() > 0) {\n\t\tchanged = true;\n\t\tpath = defaultPath;\n\t    }\n\t}\n\t//遍历默认参数集合\n\tif (defaultParameters != null && defaultParameters.size() > 0) {\n\t    for (Map.Entry<String, String> entry : defaultParameters.entrySet()) {\n\t\t//默认参数key\n\t\tString key = entry.getKey();\n\t\t//默认参数值defaultValue\n\t\tString defaultValue = entry.getValue();\n\t\tif (defaultValue != null && defaultValue.length() > 0) {\n\t\t    //查看URL参数集合中该参数key对应的值\n\t\t    String value = parameters.get(key);\n\t\t    if (value == null || value.length() == 0) {\n\t\t\t//如果URL中的参数值为空，则使用该参数key的默认值defaultValue\n\t\t\tchanged = true;\n\t\t\tparameters.put(key, defaultValue);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (changed) {\n\t    //当前URL的属性值发送改变了，则重新生成一个URL对象\n\t    u = new URL(protocol, username, password, host, port, path, parameters);\n\t}\n\treturn u;\n}\n```\n加载注册中心URL地址的方法分析完了，我们再来看doExportUrlsFor1Protocol方法\n```java\n/**\n * 暴露服务Url到各个注册中心\n * 1、map装配参数\n * 2、利用map中的参数构建URL，为暴露服务做准备\n * 3、根据范围选择是暴露本地服务，还是暴露远程服务\n * 4、根据代理工厂生成服务代理对象invoker\n * 5、根据配置的协议，暴露服务代理\n * @param protocolConfig 例如: <dubbo:protocol name=\"dubbo\" port=\"20880\" id=\"dubbo\" />\n * @param registryURLs 例如: registry://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&dubbo=2.0.0&pid=4328&qos.port=22222&registry=multicast&timestamp=1528278313174\n */\nprivate void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> registryURLs) {\n\t//获取协议名称\n\tString name = protocolConfig.getName();\n\tif (name == null || name.length() == 0) {\n\t    name = \"dubbo\";\n\t}\n\tMap<String, String> map = new HashMap<String, String>();\n\t//添加side参数，值为provider，标识服务提供端\n\tmap.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);\n\t//添加dubbo版本\n\tmap.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());\n\t//添加时间戳\n\tmap.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n\tif (ConfigUtils.getPid() > 0) {\n\t    //添加pid\n\t    map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n\t}\n\t//添加参数到map\n\tappendParameters(map, application);\n\tappendParameters(map, module);\n\tappendParameters(map, provider, Constants.DEFAULT_KEY);\n\tappendParameters(map, protocolConfig);\n\t//当前ServiceConfig(ServiceBean)\n\tappendParameters(map, this);\n\n\tif (methods != null && !methods.isEmpty()) {\n\t    //遍历服务方法\n\t    for (MethodConfig method : methods) {\n\t\t//将method的属性添加到map中\n\t\tappendParameters(map, method, method.getName());\n\t\t//设置方法重试次数(retryKey是map的key)\n\t\tString retryKey = method.getName() + \".retry\";\n\t\tif (map.containsKey(retryKey)) {\n\t\t    String retryValue = map.remove(retryKey);\n\t\t    if (\"false\".equals(retryValue)) {\n\t\t        //retryValue值为false的话，说明不启用重试\n\t\t\tmap.put(method.getName() + \".retries\", \"0\");\n\t\t    }\n\t\t}\n\t\t//获取当前服务方法的参数\n\t\tList<ArgumentConfig> arguments = method.getArguments();\n\t\tif (arguments != null && !arguments.isEmpty()) {\n\t\t    //遍历当前服务方法的参数配置\n\t\t    for (ArgumentConfig argument : arguments) {\n\t\t\tif (argument.getType() != null && argument.getType().length() > 0) {\n\t\t\t    //遍历服务接口的方法列表\n\t\t\t    Method[] methods = interfaceClass.getMethods();\n\t\t\t    if (methods != null && methods.length > 0) {\n\t\t\t\tfor (int i = 0; i < methods.length; i++) {\n\t\t\t\t    //方法名\n\t\t\t\t    String methodName = methods[i].getName();\n\t\t\t\t    if (methodName.equals(method.getName())) {\n\t\t\t\t\t//方法名称一样,获取方法参数类型数组\n\t\t\t\t\tClass<?>[] argtypes = methods[i].getParameterTypes();\n\t\t\t\t\t// one callback in the method\n\t\t\t\t\tif (argument.getIndex() != -1) {\n\t\t\t\t\t    //校验参数的类型是否匹配\n\t\t\t\t\t    if (argtypes[argument.getIndex()].getName().equals(argument.getType())) {\n\t\t\t\t\t\t//将方法的参数的属性添加到map，前缀为：方法名.参数索引\n\t\t\t\t\t\tappendParameters(map, argument, method.getName() + \".\" + argument.getIndex());\n\t\t\t\t\t    } else {\n\t\t\t\t\t\t//参数配置错误，索引和类型不匹配\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"argument config error : the index attribute and type attribute not match :index :\" + argument.getIndex() + \", type:\" + argument.getType());\n\t\t\t\t\t    }\n\t\t\t\t\t} else {\n\t\t\t\t\t    // multiple callbacks in the method\n\t\t\t\t\t    for (int j = 0; j < argtypes.length; j++) {\n\t\t\t\t\t\t//当前参数类型\n\t\t\t\t\t\tClass<?> argclazz = argtypes[j];\n\t\t\t\t\t\t//参数类型名称匹配\n\t\t\t\t\t\tif (argclazz.getName().equals(argument.getType())) {\n\t\t\t\t\t\t    appendParameters(map, argument, method.getName() + \".\" + j);\n\t\t\t\t\t\t    if (argument.getIndex() != -1 && argument.getIndex() != j) {\n\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"argument config error : the index attribute and type attribute not match :index :\" + argument.getIndex() + \", type:\" + argument.getType());\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t}\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t} else if (argument.getIndex() != -1) {\n\t\t\t    appendParameters(map, argument, method.getName() + \".\" + argument.getIndex());\n\t\t\t} else {\n\t\t\t    //<dubbo:argument index='0' .../> or <dubbo:argument type=xxx .../>\n\t\t\t    throw new IllegalArgumentException(\"argument config must set index or type attribute.eg: <dubbo:argument index='0' .../> or <dubbo:argument type=xxx .../>\");\n\t\t\t}\n\n\t\t    }\n\t\t}\n\t    } // end of methods for\n\t}\n\t//(generic ！= null) && (generic = “true” || \"nativejava\" || \"bean\") 返回 true\n\tif (ProtocolUtils.isGeneric(generic)) {\n\t    //添加generic参数\n\t    map.put(Constants.GENERIC_KEY, generic);\n\t    //添加methods参数，值为\"*\"\n\t    map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);\n\t} else {\n\t    String revision = Version.getVersion(interfaceClass, version);\n\t    if (revision != null && revision.length() > 0) {\n\t        //添加版本\n\t\tmap.put(\"revision\", revision);\n\t    }\n\t    //生成interfaceClass类的包装类，获取方法名称\n\t    String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();\n\t    if (methods.length == 0) {\n\t\t//服务接口中没有发现方法定义\n\t\tlogger.warn(\"NO method found in service interface \" + interfaceClass.getName());\n\t\t//添加methods参数，值为\"*\"\n\t\tmap.put(Constants.METHODS_KEY, Constants.ANY_VALUE);\n\t    } else {\n\t\t//添加methods参数，值为逗号分隔的方法名称\n\t\tmap.put(Constants.METHODS_KEY, StringUtils.join(new HashSet<String>(Arrays.asList(methods)), \",\"));\n\t    }\n\t}\n\tif (!ConfigUtils.isEmpty(token)) {\n\t    //token为true或者token为default，则isDefault方法返回true\n\t    if (ConfigUtils.isDefault(token)) {\n\t\t//添加token参数，值为uuid\n\t\tmap.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());\n\t    } else {\n\t\t//添加token参数\n\t\tmap.put(Constants.TOKEN_KEY, token);\n\t    }\n\t}\n\t//判断协议名称是否为\"injvm\"\n\tif (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) {\n\t    //本地协议，不注册\n\t    protocolConfig.setRegister(false);\n\t    //添加notify参数，值为false\n\t    map.put(\"notify\", \"false\");\n\t}\n\t//暴露服务\n\t//获取上下文地址\n\tString contextPath = protocolConfig.getContextpath();\n\tif ((contextPath == null || contextPath.length() == 0) && provider != null) {\n\t    //获取provider对象配置的上下文地址\n\t    contextPath = provider.getContextpath();\n\t}\n\t//获取注册ip(后面会分析该方法)\n\tString host = this.findConfigedHosts(protocolConfig, registryURLs, map);\n\t//获取注册端口(后面会分析该方法)\n\tInteger port = this.findConfigedPorts(protocolConfig, name, map);\n\t//根据协议名称name、主机host、端口port、上下文、map参数构建URL对象(服务暴露的url地址)\n\t//例如url：dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=192.168.99.60&bind.port=20880&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=7184&qos.port=22222&side=provider&timestamp=1528347825839\n\tURL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? \"\" : contextPath + \"/\") + path, map);\n\t//查看ConfiguratorFactory(override/absent)是否存在url.getProtocol()扩展，存在的话，则配置该url对象\n\t//override会覆盖参数配置，absent只有参数不存在时才会添加(后面的章节会介绍该扩展)\n\tif (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class).hasExtension(url.getProtocol())) {\n\t    url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)\n\t\t    .getExtension(url.getProtocol()).getConfigurator(url).configure(url);\n\t}\n\t//获取url的scope参数\n\tString scope = url.getParameter(Constants.SCOPE_KEY);\n\t\n\t//只有scope != none 时才会暴露服务，scope = null时会同时暴露本地服务和远程服务\n\tif (!Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) {\n\t    //scope != remote 暴露本地服务\n\t    if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) {\n\t\t//本地暴露(后面小节会分析该方法)\n\t\texportLocal(url);\n\t    }\n\t    if (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) {\n\t         //scope != local 暴露到远程\n\t\tif (logger.isInfoEnabled()) {\n\t\t    //暴露dubbo服务interfaceClass到url\n\t\t    logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to url \" + url);\n\t\t}\n\t\tif (registryURLs != null && !registryURLs.isEmpty()) {\n\t\t    //注册中心地址registryURLs不为空，则遍历注册中心地址，将服务暴露到各个注册中心\n\t\t    for (URL registryURL : registryURLs) {\n\t\t\t\n\t\t\t//添加dynamic参数到url中，参数值从当前注册中心的参数中获取\n\t\t\turl = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));\n\t\t\t\n\t\t\t//构造监控url(后面会分析该方法)\n\t\t\tURL monitorUrl = loadMonitor(registryURL);\n\t\t\tif (monitorUrl != null) {\n\t\t\t    //添加monitor参数(编码)到url中\n\t\t\t    url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());\n\t\t\t}\n\t\t\t\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t    //注册dubbo服务 interfaceClass的url 到注册中心registryURL上\n\t\t\t    logger.info(\"Register dubbo service \" + interfaceClass.getName() + \" url \" + url + \" to registry \" + registryURL);\n\t\t\t}\n\t\t\t\n\t\t\t//registryURL地址上添加export参数，参数值为服务暴露的url(即interfaceClass的url)\n\t\t\t//根据ref、interfaceClass、registryURL创建服务代理对象Invoker(后面小节会分析该方法)\n\t\t\tInvoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));\n\t\t\t\n\t\t\t//将invoker和当前对象this包装成DelegateProviderMetaDataInvoker对象(后面小节会分析该方法)\n\t\t\tDelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\t\t\t\n\t\t\t//在此处开始暴露服务\n\t\t\t//调用export方法暴露服务，得到exporter对象(后面小节会分析该方法)\n\t\t\tExporter<?> exporter = protocol.export(wrapperInvoker);\n\t\t\t//保存暴露的服务到本地变量exporters中\n\t\t\texporters.add(exporter);\n\t\t    }\n\t\t} else {\n\t\t    //注册中心地址registryURLs为空\n\t\t    Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);\n\t\t    DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\t\t    Exporter<?> exporter = protocol.export(wrapperInvoker);\n\t\t    exporters.add(exporter);\n\t\t}\n\t    }\n\t}\n\t//保存暴露的服务url\n\tthis.urls.add(url);\n}\n```\n我们依次看下上面用到的方法: findConfigedHosts、findConfigedPorts、loadMonitor\nexportLocal、getInvoker、export方法将在后面的章节(Dubbo源码阅读之服务暴露)进行详细介绍。\n```java\n/**\n * 为服务提供者 获取注册ip和绑定ip，可以单独配置\n * Register & bind IP address for service provider, can be configured separately.\n * Configuration priority:\n * environment variables -> java system properties -> host property in config file ->\n * /etc/hosts -> default network address -> first available network address\n * @param protocolConfig\n * @param registryURLs\n * @param map\n * @return 注册ip\n */\nprivate String findConfigedHosts(ProtocolConfig protocolConfig, List<URL> registryURLs, Map<String, String> map) {\n\tboolean anyhost = false;\n\t//从系统配置中获取获取绑定ip\n\tString hostToBind = getValueFromConfig(protocolConfig, Constants.DUBBO_IP_TO_BIND);\n\tif (hostToBind != null && hostToBind.length() > 0 && isInvalidLocalHost(hostToBind)) {\n\t    //无效的ip\n\t    throw new IllegalArgumentException(\"Specified invalid bind ip from property:\" + Constants.DUBBO_IP_TO_BIND + \", value:\" + hostToBind);\n\t}\n\tif (hostToBind == null || hostToBind.length() == 0) {\n\t    //从协议配置中获取服务ip地址\n\t    hostToBind = protocolConfig.getHost();\n\t    if (provider != null && (hostToBind == null || hostToBind.length() == 0)) {\n\t\t//从服务提供者中获取服务ip地址\n\t\thostToBind = provider.getHost();\n\t    }\n\t    if (isInvalidLocalHost(hostToBind)) {\n\t\t//仍然是无效的地址，则设置anyhost=true\n\t\tanyhost = true;\n\t\ttry {\n\t\t    //获取本地地址\n\t\t    hostToBind = InetAddress.getLocalHost().getHostAddress();\n\t\t} catch (UnknownHostException e) {\n\t\t    logger.warn(e.getMessage(), e);\n\t\t}\n\t\tif (isInvalidLocalHost(hostToBind)) {\n\t\t    //仍然是无效的地址，遍历注册中心url列表\n\t\t    if (registryURLs != null && !registryURLs.isEmpty()) {\n\t\t\tfor (URL registryURL : registryURLs) {\n\t\t\t    if (Constants.MULTICAST.equalsIgnoreCase(registryURL.getParameter(\"registry\"))) {\n\t\t\t\t// 跳过组播registry，因为我们不可以通过Socket连接到它\n\t\t\t\tcontinue;\n\t\t\t    }\n\t\t\t    try {\n\t\t\t\tSocket socket = new Socket();\n\t\t\t\ttry {\n\t\t\t\t    //根据注册中心host和port构建SocketAddress\n\t\t\t\t    SocketAddress addr = new InetSocketAddress(registryURL.getHost(), registryURL.getPort());\n\t\t\t\t    //连接到该地址\n\t\t\t\t    socket.connect(addr, 1000);\n\t\t\t\t    //连接成功的话，则获取到绑定地址，并跳出循环\n\t\t\t\t    hostToBind = socket.getLocalAddress().getHostAddress();\n\t\t\t\t    break;\n\t\t\t\t} finally {\n\t\t\t\t    try {\n\t\t\t\t\tsocket.close();\n\t\t\t\t    } catch (Throwable e) {\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    } catch (Exception e) {\n\t\t\t\tlogger.warn(e.getMessage(), e);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (isInvalidLocalHost(hostToBind)) {\n\t\t\t//仍然为无效本地地址的话，则使用本地地址\n\t\t\thostToBind = getLocalHost();\n\t\t    }\n\t\t}\n\t    }\n\t}\n\t//添加bind.ip参数\n\tmap.put(Constants.BIND_IP_KEY, hostToBind);\n\t// 默认情况下，注册ip不用于绑定ip\n\t// 获取注册ip\n\tString hostToRegistry = getValueFromConfig(protocolConfig, Constants.DUBBO_IP_TO_REGISTRY);\n\tif (hostToRegistry != null && hostToRegistry.length() > 0 && isInvalidLocalHost(hostToRegistry)) {\n\t    throw new IllegalArgumentException(\"Specified invalid registry ip from property:\" + Constants.DUBBO_IP_TO_REGISTRY + \", value:\" + hostToRegistry);\n\t} else if (hostToRegistry == null || hostToRegistry.length() == 0) {\n\t    //默认情况下，绑定ip用于注册ip\n\t    hostToRegistry = hostToBind;\n\t}\n\t//添加anyhost参数\n\tmap.put(Constants.ANYHOST_KEY, String.valueOf(anyhost));\n\treturn hostToRegistry;\n}\n\n/**\n * 为服务提供者 获取注册端口和绑定端口\n * Register port and bind port for the provider, can be configured separately\n * Configuration priority:\n * environment variable -> java system properties -> port property in protocol config file\n * -> protocol default port\n * @param protocolConfig\n * @param name\n * @return 注册端口\n */\nprivate Integer findConfigedPorts(ProtocolConfig protocolConfig, String name, Map<String, String> map) {\n\tInteger portToBind = null;\n\n\t//从系统配置中获取绑定端口\n\tString port = getValueFromConfig(protocolConfig, Constants.DUBBO_PORT_TO_BIND);\n\tportToBind = parsePort(port);\n\n\tif (portToBind == null) {\n\t    //从协议配置中获取绑定端口\n\t    portToBind = protocolConfig.getPort();\n\t    if (provider != null && (portToBind == null || portToBind == 0)) {\n\t\t//从服务提供者中获取绑定端口\n\t\tportToBind = provider.getPort();\n\t    }\n\t    //根据协议名称获取默认绑定端口\n\t    final int defaultPort = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(name).getDefaultPort();\n\t    if (portToBind == null || portToBind == 0) {\n\t\tportToBind = defaultPort;\n\t    }\n\t    if (portToBind == null || portToBind <= 0) {\n\t\t//获取随机端口\n\t\tportToBind = getRandomPort(name);\n\t\tif (portToBind == null || portToBind < 0) {\n\t\t    //获取可用端口\n\t\t    portToBind = getAvailablePort(defaultPort);\n\t\t    //设置随机端口(放入map缓存)\n\t\t    putRandomPort(name, portToBind);\n\t\t}\n\t\tlogger.warn(\"Use random available port(\" + portToBind + \") for protocol \" + name);\n\t    }\n\t}\n\t//保存绑定端口，稍后用作url的key\n\tmap.put(Constants.BIND_PORT_KEY, String.valueOf(portToBind));\n\t// registry port, not used as bind port by default\n\tString portToRegistryStr = getValueFromConfig(protocolConfig, Constants.DUBBO_PORT_TO_REGISTRY);\n\tInteger portToRegistry = parsePort(portToRegistryStr);\n\tif (portToRegistry == null) {\n\t    //注册端口使用绑定端口\n\t    portToRegistry = portToBind;\n\t}\n\treturn portToRegistry;\n}\n\n/**\n * 构造监控URL\n * @param registryURL 注册中心URL\n * @return\n */\nprotected URL loadMonitor(URL registryURL) {\n\tif (monitor == null) {\n\t    //获取监控地址、监控协议配置\n\t    String monitorAddress = ConfigUtils.getProperty(\"dubbo.monitor.address\");\n\t    String monitorProtocol = ConfigUtils.getProperty(\"dubbo.monitor.protocol\");\n\t    if ((monitorAddress == null || monitorAddress.length() == 0) && (monitorProtocol == null || monitorProtocol.length() == 0)) {\n\t\t//如果监控地址和监控协议为空，则返回Null\n\t\treturn null;\n\t    }\n\t    //构造监控配置对象(地址、协议)\n\t    monitor = new MonitorConfig();\n\t    if (monitorAddress != null && monitorAddress.length() > 0) {\n\t\tmonitor.setAddress(monitorAddress);\n\t    }\n\t    if (monitorProtocol != null && monitorProtocol.length() > 0) {\n\t\tmonitor.setProtocol(monitorProtocol);\n\t    }\n\t}\n\t//添加属性\n\tappendProperties(monitor);\n\t//参数\n\tMap<String, String> map = new HashMap<String, String>();\n\t//添加interface参数\n\tmap.put(Constants.INTERFACE_KEY, MonitorService.class.getName());\n\t//添加dubbo版本\n\tmap.put(\"dubbo\", Version.getVersion());\n\t//添加时间戳\n\tmap.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n\tif (ConfigUtils.getPid() > 0) {\n\t    //添加pid\n\t    map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n\t}\n\t//添加monitor属性\n\tappendParameters(map, monitor);\n\t//获取monitor地址，优先使用系统配置值\n\tString address = monitor.getAddress();\n\tString sysaddress = System.getProperty(\"dubbo.monitor.address\");\n\tif (sysaddress != null && sysaddress.length() > 0) {\n\t    address = sysaddress;\n\t}\n\tif (ConfigUtils.isNotEmpty(address)) {\n\t    if (!map.containsKey(Constants.PROTOCOL_KEY)) {\n\t\t//协议地址不为空，且map中不包含protocol属性时，则设置protocol\n\t\tif (ExtensionLoader.getExtensionLoader(MonitorFactory.class).hasExtension(\"logstat\")) {\n\t\t    //包含logstat扩展\n\t\t    map.put(Constants.PROTOCOL_KEY, \"logstat\");\n\t\t} else {\n\t\t    //添加protocol属性\n\t\t    map.put(Constants.PROTOCOL_KEY, \"dubbo\");\n\t\t}\n\t    }\n\t    //生成URL对象\n\t    return UrlUtils.parseURL(address, map);\n\t} else if (Constants.REGISTRY_PROTOCOL.equals(monitor.getProtocol()) && registryURL != null) {\n\t    //监控address为空\n\t    //registryURL不为空，且monitor的协议为registry注册中心协议\n\t    return registryURL.setProtocol(\"dubbo\")\n\t\t    //添加protocol属性为registry\n\t\t    .addParameter(Constants.PROTOCOL_KEY, \"registry\")\n\t\t    //添加refer属性，属性值为map参数\n\t\t    .addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map));\n\t}\n\treturn null;\n}\n```\n\n由于本小节主要是讲ServiceAnnotationBeanPostProcessor类实现，关于服务暴露的内容将会放到下一小节介绍。\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之集成Spring-标签解析(02)","url":"/blog/2018/08/04/Dubbo源码阅读之集成Spring-02标签解析/","content":">本小节将会介绍dubbo标签的解析.\n\n上节讲到Dubbo解析标签的类是DubboBeanDefinitionParser,现在我们就来分析下该类,该类实现了Spring的BeanDefinitionParser接口，我们需要实现它的parse方法:\n\n### DubboBeanDefinitionParser解析类\n```java\npublic class DubboBeanDefinitionParser implements BeanDefinitionParser{\n \n    private static final Pattern GROUP_AND_VERION = Pattern.compile(\"^[\\\\-.0-9_a-zA-Z]+(\\\\:[\\\\-.0-9_a-zA-Z]+)?$\");\n    \n    //带解析实例化的bean类\n    private final Class<?> beanClass;\n    \n    //是否必填\n    private final boolean required;\n\n    public DubboBeanDefinitionParser(Class<?> beanClass, boolean required) {\n        this.beanClass = beanClass;\n        this.required = required;\n    }\n\n    @Override\n    public BeanDefinition parse(Element element, ParserContext parserContext) {\n        //调用了内部的parse方法\n        return parse(element, parserContext, beanClass, required);\n    }\n   \n    private static BeanDefinition parse(Element element, ParserContext parserContext,\n                                        Class<?> beanClass, boolean required) {\n        //创建RootBeanDefinition实例\n        RootBeanDefinition beanDefinition = new RootBeanDefinition();\n        //设置要实例化的类\n        beanDefinition.setBeanClass(beanClass);\n        //是否延迟初始化\n        beanDefinition.setLazyInit(false);\n        \n        //获取元素的id属性作为bean的id\n        String id = element.getAttribute(\"id\");\n        if ((id == null || id.length() == 0) && required) {\n            //如果id属性为空，并且是必填的，则取元素的name属性\n            String generatedBeanName = element.getAttribute(\"name\");\n            if (generatedBeanName == null || generatedBeanName.length() == 0) {\n                //如果name属性为空，则生成一个bean名称\n                //判断当前要实例化的bean类是否是ProtocolConfig类（即当前是否为<dubbo:protocol>标签）\n                if (ProtocolConfig.class.equals(beanClass)) {\n                    //当前是ProtocolConfig类，则设置bean名称为dubbo\n                    generatedBeanName = \"dubbo\";\n                } else {\n                    //不是ProtocolConfig类,则使用interface属性做为bean的名称\n                    generatedBeanName = element.getAttribute(\"interface\");\n                }\n            }\n            //如果bean名称为空，则使用当前实例化的类的名称\n            if (generatedBeanName == null || generatedBeanName.length() == 0) {\n                generatedBeanName = beanClass.getName();\n            }\n            //同时将bean的id属性设置为bean的名称\n            id = generatedBeanName;\n            int counter = 2;\n            //如果上下文中已经存在该id，则对该bean的id做防重处理\n            while (parserContext.getRegistry().containsBeanDefinition(id)) {\n                id = generatedBeanName + (counter++);\n            }\n        }\n        if (id != null && id.length() > 0) {\n            //如果id属性不为空，则校验Spring中是否已存在该id\n            if (parserContext.getRegistry().containsBeanDefinition(id)) {\n                throw new IllegalStateException(\"Duplicate spring bean id \" + id);\n            }\n            //通过id注册该bean\n            parserContext.getRegistry().registerBeanDefinition(id, beanDefinition);\n            //设置bean的id属性值\n            beanDefinition.getPropertyValues().addPropertyValue(\"id\", id);\n        }\n        //进一步解析<dubbo:protocol/>标签\n        //如：<dubbo:protocol name=\"dubbo\" port=\"20880\"/>\n        if (ProtocolConfig.class.equals(beanClass)) {\n            //如果当前要实例化的bean是ProtocolConfig类，则遍历Spring所有已经注册的bean的名称\n            for (String name : parserContext.getRegistry().getBeanDefinitionNames()) {\n                //根据bean名称获取已注册的bean定义\n                BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name);\n                //查看已注册的bean定义中是否存在protocol属性\n                PropertyValue property = definition.getPropertyValues().getPropertyValue(\"protocol\");\n                if (property != null) {\n                    //存在protocol属性，则获取protocol属性值\n                    Object value = property.getValue();\n                    //如果protocol属性值为ProtocolConfig类型，并且当前实例化的bean的id等于protocol属性值的name属性值的话，\n                    //则将当前实例化的bean包装成RuntimeBeanReference类型\n                    //然后将已注册的bean的protocol属性的值设为刚才新创建的RuntimeBeanReference\n                    //也就是说将当前解析的bean（ProtocolConfig）设置到其他已注册的bean的protocol属性中\n                    if (value instanceof ProtocolConfig && id.equals(((ProtocolConfig) value).getName())) {\n                        definition.getPropertyValues().addPropertyValue(\"protocol\", new RuntimeBeanReference(id));\n                    }\n                }\n            }\n        } else if (ServiceBean.class.equals(beanClass)) {\n            //进一步解析<dubbo:service/>标签，这里的逻辑就是处理下面的第二种配置\n            //如：<dubbo:service protocol=\"dubbo\" ref=\"userService\" interface=\"org.dubbo.service.UserInterface\" retries=\"0\" />\n            //   <bean id=\"userService\" class=\"org.dubbo.service.impl.UserServiceImpl\" />\n            //和如下配置相同\n            //<dubbo:service interface=\"org.dubbo.service.UserInterface\" class=\"org.dubbo.service.impl.UserServiceImpl\" protocol=\"dubbo\" retries=\"0\">\n            //   <property name=\"name\" value=\"dubbo\" ref=\"\"/>\n            //   <property name=\"age\" value=\"5\" ref=\"\"/>\n            //</dubbo:service>\n\n            //如果当前要实例化的bean是ServiceBean类,则获取class属性并解析\n            String className = element.getAttribute(\"class\");\n            if (className != null && className.length() > 0) {\n                //如果class属性不为空，则实例化该class属性指定的类\n                RootBeanDefinition classDefinition = new RootBeanDefinition();\n                classDefinition.setBeanClass(ReflectUtils.forName(className));\n                classDefinition.setLazyInit(false);\n                //解析子标签元素(即上面例子中的property属性)(后面会介绍parseProperties方法)\n                parseProperties(element.getChildNodes(), classDefinition);\n                //为当前待实例化的bean定义增加ref属性值（即class属性对应的bean，id为 beanId + impl）\n                beanDefinition.getPropertyValues().addPropertyValue(\"ref\", new BeanDefinitionHolder(classDefinition, id + \"Impl\"));\n            }\n        } else if (ProviderConfig.class.equals(beanClass)) {\n            //进一步处理<dubbo:provider/>标签(后面会分析parseNested方法)\n            parseNested(element, parserContext, ServiceBean.class, true, \"service\", \"provider\", id, beanDefinition);\n        } else if (ConsumerConfig.class.equals(beanClass)) {\n            //进一步处理<dubbo:consumer/>标签的子标签<dubbo:reference/>\n            parseNested(element, parserContext, ReferenceBean.class, false, \"reference\", \"consumer\", id, beanDefinition);\n        }\n        \n\t//当前待实例化的bean的所有的属性(通过set方法获取到)\n        Set<String> props = new HashSet<String>();\n        ManagedMap parameters = null;\n        //遍历待实例化类的所有方法,找到set方法\n        for (Method setter : beanClass.getMethods()) {\n            \n            String name = setter.getName();\n            \n            //找到set方法，条件如下：方法名长度大于3，以set开头，是public修饰符，参数类型长度为1\n            if (name.length() > 3 && name.startsWith(\"set\")\n                    && Modifier.isPublic(setter.getModifiers())\n                    && setter.getParameterTypes().length == 1) {\n               \n                 //获取参数类型\n                Class<?> type = setter.getParameterTypes()[0];\n\n                //如setFirstName(String firstName)方法\n                //将会得到property=first-name\n                String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), \"-\");\n          \n\t        //将属性名称添加到props集合中\n                props.add(property);\n               \n                //获取到属性的get方法\n                Method getter = null;\n               \n                try {\n                    getter = beanClass.getMethod(\"get\" + name.substring(3), new Class<?>[0]);\n                } catch (NoSuchMethodException e) {\n                    try {\n                        //如果没有找到get方法，则尝试找到isXXX方法\n                        getter = beanClass.getMethod(\"is\" + name.substring(3), new Class<?>[0]);\n                    } catch (NoSuchMethodException e2) {\n                    }\n                }\n                if (getter == null\n                        || !Modifier.isPublic(getter.getModifiers())\n                        || !type.equals(getter.getReturnType())) {\n                    //如果get方法为空、不是public限定符、或者get方法返回值和set方法参数类型不一致的话，\n                    //则跳过该property的处理，进行下一个property的处理\n                    continue;\n                }\n                if (\"parameters\".equals(property)) {\n                    //如果当前property为parameters，则解析当前元素的子元素(<dubbo:parameter>标签)(后面会分析parseParameters方法)\n                    parameters = parseParameters(element.getChildNodes(), beanDefinition);\n                } else if (\"methods\".equals(property)) {\n                    //如果当前property为methods，则解析当前元素的子元素(<dubbo:method>标签)(后面会分析parseMethods方法)\n                    parseMethods(id, element.getChildNodes(), beanDefinition, parserContext);\n                } else if (\"arguments\".equals(property)) {\n                    //如果当前property为arguments，则解析当前元素的子元素(<dubbo:argument>标签)(后面会分析parseArguments方法)\n                    parseArguments(id, element.getChildNodes(), beanDefinition, parserContext);\n                } else {\n                    //从xml定义中获取property属性值\n                    String value = element.getAttribute(property);\n                    if (value != null) {\n                        value = value.trim();\n                        if (value.length() > 0) {\n                            if (\"registry\".equals(property) && RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(value)) {\n                                //如果当前属性为registry，并且属性值为N/A\n                                //则为当前bean定义添加属性registry，并且属性值为RegistryConfig对象(该对象的address属性值为不可用)\n                                RegistryConfig registryConfig = new RegistryConfig();\n                                registryConfig.setAddress(RegistryConfig.NO_AVAILABLE);\n                                beanDefinition.getPropertyValues().addPropertyValue(property, registryConfig);\n                            } else if (\"registry\".equals(property) && value.indexOf(',') != -1) {\n                                //如果当前属性为registry，并且属性值包含逗号\",\",即有多个值，则进一步解析(后面会分析parseMultiRef方法)\n                                parseMultiRef(\"registries\", value, beanDefinition, parserContext);\n                            } else if (\"provider\".equals(property) && value.indexOf(',') != -1) {\n                                //如果当前属性为providers，并且属性值包含逗号\",\",即有多个值，则进一步解析\n                                parseMultiRef(\"providers\", value, beanDefinition, parserContext);\n                            } else if (\"protocol\".equals(property) && value.indexOf(',') != -1) {\n                                //如果当前属性为protocol，并且属性值包含逗号\",\",即有多个值，则进一步解析\n                                parseMultiRef(\"protocols\", value, beanDefinition, parserContext);\n                            } else {\n                                Object reference;\n                                //判断set方法的参数类型是否是原始类型\n                                if (isPrimitive(type)) {\n                                     if (\"async\".equals(property) && \"false\".equals(value)\n                                            || \"timeout\".equals(property) && \"0\".equals(value)\n                                            || \"delay\".equals(property) && \"0\".equals(value)\n                                            || \"version\".equals(property) && \"0.0.0\".equals(value)\n                                            || \"stat\".equals(property) && \"-1\".equals(value)\n                                            || \"reliable\".equals(property) && \"false\".equals(value)) {\n                                        // backward compatibility for the default value in old version's xsd\n                                        //兼容老版本\n\t\t\t\t\tvalue = null;\n                                    }\n\t\t\t\t    //原始类型，直接只用xml中配置的属性值\n                                    reference = value;\n                                } else if (\"protocol\".equals(property)\n                                        //属性名为protocol，并且当前存在该属性值对应的扩展\n                                        && ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(value)\n                                        //当前上下文不包含扩展的bean定义\n                                        //该扩展bean的类名称不等于ProtocolConfig类名称\n                                        && (!parserContext.getRegistry().containsBeanDefinition(value)\n                                        || !ProtocolConfig.class.getName().equals(parserContext.getRegistry().getBeanDefinition(value).getBeanClassName()))) {\n                                    //如果元素标签名称为dubbo:provider，则提示使用dubbo:protocol进行替换\n                                    if (\"dubbo:provider\".equals(element.getTagName())) {\n                                        logger.warn(\"Recommended replace <dubbo:provider protocol=\\\"\" + value + \"\\\" ... /> to <dubbo:protocol name=\\\"\" + value + \"\\\" ... />\");\n                                    }\n                                    // backward compatibility 向后兼容\n                                    // 设置协议名称为value\n                                    ProtocolConfig protocol = new ProtocolConfig();\n                                    protocol.setName(value);\n                                    //设置reference值为protocol\n                                    reference = protocol;\n                                } else if (\"onreturn\".equals(property)) {\n                                    //获取\".\"在属性值中最后出现的位置\n                                    int index = value.lastIndexOf(\".\");\n                                    \n \t\t\t\t     //截取value从首字符到index字符\n                                    String returnRef = value.substring(0, index);\n                                    \n\t\t\t\t    //从index+1字符开始进行截取\n                                    String returnMethod = value.substring(index + 1);\n\t\t\t\t\t\n\t\t\t\t    //包装成RuntimeBeanReference\n                                    reference = new RuntimeBeanReference(returnRef);\n                                    \n \t\t\t\t    //为当前bean定义增加属性onreturnMethod\n                                    beanDefinition.getPropertyValues().addPropertyValue(\"onreturnMethod\", returnMethod);\n                                } else if (\"onthrow\".equals(property)) {\n                                   //处理onthrow属性 \n\t\t\t\t   int index = value.lastIndexOf(\".\");\n                                   String throwRef = value.substring(0, index);\n                                   String throwMethod = value.substring(index + 1);\n                                    \n\t\t\t\t   reference = new RuntimeBeanReference(throwRef);\n                                   \n\t\t\t\t    //为当前bean定义增加属性onthrowMethod\n                                    beanDefinition.getPropertyValues().addPropertyValue(\"onthrowMethod\", throwMethod);\n                                } else if (\"oninvoke\".equals(property)) {\n                                    int index = value.lastIndexOf(\".\");\n                                    String invokeRef = value.substring(0, index);\n                                    String invokeRefMethod = value.substring(index + 1);\n                                    \n\t\t\t\t    reference = new RuntimeBeanReference(invokeRef);\n                                    //为当前bean定义增加属性oninvokeMethod\n                                    beanDefinition.getPropertyValues().addPropertyValue(\"oninvokeMethod\", invokeRefMethod);\n                                }else {\n                                    //如果当前属性为ref，并且当前上下文中包含属性值value对应的bean定义\n                                    if (\"ref\".equals(property) && parserContext.getRegistry().containsBeanDefinition(value)) {\n                                        //获取属性值value对应的bean定义\n                                        BeanDefinition refBean = parserContext.getRegistry().getBeanDefinition(value);\n                                        //检测是否是单例\n                                        if (!refBean.isSingleton()) {\n                                            //暴露的服务ref值必须是单例\n                                            throw new IllegalStateException(\"The exported service ref \" + value + \" must be singleton! Please set the \" + value + \" bean scope to singleton, eg: <bean id=\\\"\" + value + \"\\\" scope=\\\"singleton\\\" ...>\");\n                                        }\n                                    }\n                                    reference = new RuntimeBeanReference(value);\n                                }\n                                //为当前bean定义添加属性property，属性值为reference\n                                beanDefinition.getPropertyValues().addPropertyValue(property, reference);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        //获取元素的所有属性\n        NamedNodeMap attributes = element.getAttributes();\n\t//属性数量\n        int len = attributes.getLength();\n        //遍历所有属性，看看是否有不再set属性集合中的元素，如果有，则将他们添加到自定义参数map中，然后设置当前待实例化bean的parameters参数\n        for (int i = 0; i < len; i++) {\n            Node node = attributes.item(i);\n            String name = node.getLocalName();\n            //如果当前set属性集合中不包含该属性，则将该属性以及属性值添加到自定义parameters中\n            if (!props.contains(name)) {\n                if (parameters == null) {\n                    parameters = new ManagedMap();\n                }\n                //获取该节点属性值\n                String value = node.getNodeValue();\n                //将值包装成TypedStringValue类型，并放入自定义参数map中\n                parameters.put(name, new TypedStringValue(value, String.class));\n            }\n        }\n        if (parameters != null) {\n            //为当前bean定义添加属性parameters\n            beanDefinition.getPropertyValues().addPropertyValue(\"parameters\", parameters);\n        }\n\t//返回bean定义\n        return beanDefinition;\n    }\n\n}\n```\n#### parseProperties方法\n\n```java\n/**\n* 解析子标签元素\n* @param nodeList\n* @param beanDefinition 待实例化的bean\n*/\nprivate static void parseProperties(NodeList nodeList, RootBeanDefinition beanDefinition) {\n\t\n\t//<dubbo:service interface=\"org.dubbo.service.UserInterface\" class=\"org.dubbo.service.impl.UserService\" protocol=\"dubbo\" retries=\"0\">\n   \t//\t<property name=\"name\" value=\"dubbo\" ref=\"\"/>\n   \t//\t<property name=\"age\" value=\"5\" ref=\"\"/>\n\t//</dubbo:service>\n\tif (nodeList != null && nodeList.getLength() > 0) {\n\t   //遍历所有property节点 \n\t   for (int i = 0; i < nodeList.getLength(); i++) {\n\t\t//当前节点\n\t\tNode node = nodeList.item(i);\n\t\tif (node instanceof Element) {\n\t\t    //如果节点名称为property或者节点限定名称为property\n\t\t    if (\"property\".equals(node.getNodeName())\n\t\t\t    || \"property\".equals(node.getLocalName())) {\n\t\t\t\n\t\t\t//获取property节点的name属性\n\t\t\tString name = ((Element) node).getAttribute(\"name\");\n\t\t\tif (name != null && name.length() > 0) {\n\t\t\t    //获取property节点的value属性\n\t\t\t    String value = ((Element) node).getAttribute(\"value\");\n\t\t\t   \n\t\t\t    //获取property节点的ref属性\n\t\t\t    String ref = ((Element) node).getAttribute(\"ref\");\n\t\t\t    \n\t\t\t    if (value != null && value.length() > 0) {\n\t\t\t\t//为bean定义设置属性以及属性值\n\t\t\t\tbeanDefinition.getPropertyValues().addPropertyValue(name, value);\n\t\t\t    } else if (ref != null && ref.length() > 0) {\n\t\t\t\t//为bean定义设置属性以及属性值（引用）\n\t\t\t\tbeanDefinition.getPropertyValues().addPropertyValue(name, new RuntimeBeanReference(ref));\n\t\t\t    } else {\n\t\t\t\t//不支持的子标签\n\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported <property name=\\\"\" + name + \"\\\"> sub tag, Only supported <property name=\\\"\" + name + \"\\\" ref=\\\"...\\\" /> or <property name=\\\"\" + name + \"\\\" value=\\\"...\\\" />\");\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n}\n```\n\n#### parseNested方法\n\n```java\nparseNested(element, parserContext, ServiceBean.class, true, \"service\", \"provider\", id, beanDefinition);\nparseNested(element, parserContext, ReferenceBean.class, false, \"reference\", \"consumer\", id, beanDefinition);\n\n\n\n/**\n* 解析嵌套标签\n* 即：\n*   <dubbo:provider>\n*        <dubbo:service interface=\"\">\n*            <dubbo:method name=\"\"></dubbo:method>\n*        </dubbo:service>\n*        <dubbo:service interface=\"\">\n*            <dubbo:method name=\"\"></dubbo:method>\n*        </dubbo:service>\n*   </dubbo:provider>\n* @param element  当前元素：<dubbo:provider>\n* @param parserContext 上下文\n* @param beanClass  ServiceBean.class/ReferenceBean.class\n* @param required   true/false\n* @param tag   标签      service/reference\n* @param property 属性   provider/consumer\n* @param ref   待实例化bean的Id\n* @param beanDefinition 待实例化bean定义\n*/\nprivate static void parseNested(Element element, ParserContext parserContext, Class<?> beanClass,\n\t\t\t    boolean required, String tag, String property, \n\t\t\t    String ref,BeanDefinition beanDefinition) {\n        //获取当前元素的子节点\n\tNodeList nodeList = element.getChildNodes();\n\tif (nodeList != null && nodeList.getLength() > 0) {\n\t    boolean first = true;\n\t    //遍历子节点\n\t    for (int i = 0; i < nodeList.getLength(); i++) {\n\t\t//当前子节点\n\t\tNode node = nodeList.item(i);\n\t\tif (node instanceof Element) {\n\t\t    //如果当前子节点的名称等于tag\n\t\t    if (tag.equals(node.getNodeName())\n\t\t\t    || tag.equals(node.getLocalName())) {\n\t\t\t//是否第一个子节点\n\t\t\tif (first) {\n\t\t\t    first = false;\n\t\t\t    //获取当前元素default属性\n\t\t\t    String isDefault = element.getAttribute(\"default\");\n\t\t\t    if (isDefault == null || isDefault.length() == 0) {\n\t\t\t\t//如果default属性为空，则为bean定义增加default属性，并将属性值设置成false\n\t\t\t\tbeanDefinition.getPropertyValues().addPropertyValue(\"default\", \"false\");\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t        //调用parse方法递归解析beanClass（即ServiceBean.class/ReferenceBean.class）\n\t\t\tBeanDefinition subDefinition = parse((Element) node, parserContext, beanClass, required);\n\t\t\t\n\t\t\t//如果子bean不为空，且ref不为空，则为子bean增加property属性(provider/consumer)(即将父bean设置进去,ref参数)\n\t\t\tif (subDefinition != null && ref != null && ref.length() > 0) {\n\t\t\t    subDefinition.getPropertyValues().addPropertyValue(property, new RuntimeBeanReference(ref));\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n}\n```\n#### parseParameters方法\n```java\n/**\n* 当前property为parameters，解析参数标签 <dubbo:parameter>\n* @param nodeList 所有子节点列表\n* @param beanDefinition 当前待实例化的bean\n* @return 自定义参数集合\n*/\nprivate static ManagedMap parseParameters(NodeList nodeList, RootBeanDefinition beanDefinition) {\n\tif (nodeList != null && nodeList.getLength() > 0) {\n\t    \n\t    ManagedMap parameters = null;\n            \n\t    //遍历子节点\n\t    for (int i = 0; i < nodeList.getLength(); i++) {\n\t\t\n\t\tNode node = nodeList.item(i);\n\t\t\n\t\tif (node instanceof Element) {\n\t\t    \n\t\t    //如果子节点名称是parameter\n\t\t    if (\"parameter\".equals(node.getNodeName())\n\t\t\t    || \"parameter\".equals(node.getLocalName())) {\n\t\t\t\n\t\t\tif (parameters == null) {\n\t\t\t    parameters = new ManagedMap();\n\t\t\t}\n\t\t\t\n\t\t\t//获取子节点的key属性、value属性、hide属性\n\t\t\tString key = ((Element) node).getAttribute(\"key\");\n\t\t\tString value = ((Element) node).getAttribute(\"value\");\n\t\t\tboolean hide = \"true\".equals(((Element) node).getAttribute(\"hide\"));\n\t\t\t\n\t\t\tif (hide) {\n\t\t\t    //如果需要隐藏的话，则修改key属性的值\n\t\t\t    key = Constants.HIDE_KEY_PREFIX + key;\n\t\t\t}\n\t\t\t\n\t\t\t//保存参数信息\n\t\t\tparameters.put(key, new TypedStringValue(value, String.class));\n\t\t    }\n\t\t}\n\t    }\n\t    return parameters;\n\t}\n\treturn null;\n}\n```\n\n#### parseMethods方法\n```java\n\n/**\n *\n * 当前property为methods，解析<dubbo:method>标签\n * @param id 当前待实例化的bean-id\n * @param nodeList 所有子节点列表\n * @param beanDefinition 待实例化bean\n * @param parserContext\n */\nprivate static void parseMethods(String id, NodeList nodeList, \n\t\t\t\tRootBeanDefinition beanDefinition,\n\t\t\t\tParserContext parserContext) {\n\n\tif (nodeList != null && nodeList.getLength() > 0) {\n\t    ManagedList methods = null;\n\t    \n\t    //遍历子节点列表\n\t    for (int i = 0; i < nodeList.getLength(); i++) {\n\t\t\n\t\tNode node = nodeList.item(i);\n\t\t\n\t\tif (node instanceof Element) {\n        if (ProtocolConfig.class.equals(beanClass)) {\n            //如果当前要实例化的bean是ProtocolConfig类，则遍历Spring所有已经注册的bean的名称\n            for (String name : parserContext.getRegistry().getBeanDefinitionNames()) {\n                //根据bean名称获取已注册的bean定义\n                BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name);\n                //查看已注册的bean定义中是否存在protocol属性\n                PropertyValue property = definition.getPropertyValues().getPropertyValue(\"protocol\");\n                if (property != null) {\n                    //存在protocol属性，则获取protocol属性值\n                    Object value = property.getValue();\n                    //如果protocol属性值为ProtocolConfig类型，并且当前实例化的bean的id等于protocol属性值的name属性值的话，\n                    //则将当前实例化的bean包装成RuntimeBeanReference类型\n                    //然后将已注册的bean的protocol属性的值设为刚才新创建的RuntimeBeanReference\n                    //也就是说将当前解析的bean（ProtocolConfig）设置到其他已注册的bean的protocol属性中\n                    if (value instanceof ProtocolConfig && id.equals(((ProtocolConfig) value).getName())) {\n                        definition.getPropertyValues().addPropertyValue(\"protocol\", new RuntimeBeanReference(id));\n                    }\n                }\n            }\n        } else if (ServiceBean.class.equals(beanClass)) {\n            //进一步解析<dubbo:service/>标签，这里的逻辑就是处理下面的第二种配置\n            //如：<dubbo:service protocol=\"dubbo\" ref=\"userService\" interface=\"org.dubbo.service.UserInterface\" retries=\"0\" />\n            //   <bean id=\"userService\" class=\"org.dubbo.service.impl.UserServiceImpl\" />\n            //和如下配置相同\n            //<dubbo:service interface=\"org.dubbo.service.UserInterface\" class=\"org.dubbo.service.impl.UserServiceImpl\" protocol=\"dubbo\" retries=\"0\">\n            //   <property name=\"name\" value=\"dubbo\" ref=\"\"/>\n            //   <property name=\"age\" value=\"5\" ref=\"\"/>\n            //</dubbo:service>\n\n            //如果当前要实例化的bean是ServiceBean类,则获取class属性并解析\n            String className = element.getAttribute(\"class\");\n            if (className != null && className.length() > 0) {\n                //如果class属性不为空，则实例化该class属性指定的类\n                RootBeanDefinition classDefinition = new RootBeanDefinition();\n                classDefinition.setBeanClass(ReflectUtils.forName(className));\n                classDefinition.setLazyInit(false);\n                //解析子标签元素(即上面例子中的property属性)(后面会介绍parseProperties方法)\n                parseProperties(element.getChildNodes(), classDefinition);\n                //为当前待实例化的bean定义增加ref属性值（即class属性对应的bean，id为 beanId + impl）\n                beanDefinition.getPropertyValues().addPropertyValue(\"ref\", new BeanDefinitionHolder(classDefinition, id + \"Impl\"));\n            }\n        } else if (ProviderConfig.class.equals(beanClass)) {\n            //进一步处理<dubbo:provider/>标签(后面会分析parseNested方法)\n            parseNested(element, parserContext, ServiceBean.class, true, \"service\", \"provider\", id, beanDefinition);\n        } else if (ConsumerConfig.class.equals(beanClass)) {\n            //进一步处理<dubbo:consumer/>标签的子标签<dubbo:reference/>\n            parseNested(element, parserContext, ReferenceBean.class, false, \"reference\", \"consumer\", id, beanDefinition);\n        }\n        \n\t//当前待实例化的bean的所有的属性(通过set方法获取到)\n        Set<String> props = new HashSet<String>();\n        ManagedMap parameters = null;\n        //遍历待实例化类的所有方法,找到set方法\n        for (Method setter : beanClass.getMethods()) {\n            \n            String name = setter.getName();\n            \n            //找到set方法，条件如下：方法名长度大于3，以set开头，是public修饰符，参数类型长度为1\n            if (name.length() > 3 && name.startsWith(\"set\")\n                    && Modifier.isPublic(setter.getModifiers())\n                    && setter.getParameterTypes().length == 1) {\n               \n                 //获取参数类型\n                Class<?> type = setter.getParameterTypes()[0];\n\n                //如setFirstName(String firstName)方法\n                //将会得到property=first-name\n                String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), \"-\");\n          \n\t        //将属性名称添加到props集合中\n                props.add(property);\n               \n                //获取到属性的get方法\n                Method getter = null;\n               \n                try {\n                    getter = beanClass.getMethod(\"get\" + name.substring(3), new Class<?>[0]);\n                } catch (NoSuchMethodException e) {\n                    try {\n                        //如果没有找到get方法，则尝试找到isXXX方法\n                        getter = beanClass.getMethod(\"is\" + name.substring(3), new Class<?>[0]);\n                    } catch (NoSuchMethodException e2) {\n                    }\n                }\n                if (getter == null\n                        || !Modifier.isPublic(getter.getModifiers())\n                        || !type.equals(getter.getReturnType())) {\n                    //如果get方法为空、不是public限定符、或者get方法返回值和set方法参数类型不一致的话，\n                    //则跳过该property的处理，进行下一个property的处理\n                    continue;\n                }\n                if (\"parameters\".equals(property)) {\n                    //如果当前property为parameters，则解析当前元素的子元素(<dubbo:parameter>标签)(后面会分析parseParameters方法)\n                    parameters = parseParameters(element.getChildNodes(), beanDefinition);\n                } else if (\"methods\".equals(property)) {\n                    //如果当前property为methods，则解析当前元素的子元素(<dubbo:method>标签)(后面会分析parseMethods方法)\n                    parseMethods(id, element.getChildNodes(), beanDefinition, parserContext);\n                } else if (\"arguments\".equals(property)) {\n                    //如果当前property为arguments，则解析当前元素的子元素(<dubbo:argument>标签)(后面会分析parseArguments方法)\n                    parseArguments(id, element.getChildNodes(), beanDefinition, parserContext);\n                } else {\n                    //从xml定义中获取property属性值\n                    String value = element.getAttribute(property);\n                    if (value != null) {\n                        value = value.trim();\n                        if (value.length() > 0) {\n                            if (\"registry\".equals(property) && RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(value)) {\n                                //如果当前属性为registry，并且属性值为N/A\n                                //则为当前bean定义添加属性registry，并且属性值为RegistryConfig对象(该对象的address属性值为不可用)\n                                RegistryConfig registryConfig = new RegistryConfig();\n                                registryConfig.setAddress(RegistryConfig.NO_AVAILABLE);\n                                beanDefinition.getPropertyValues().addPropertyValue(property, registryConfig);\n                            } else if (\"registry\".equals(property) && value.indexOf(',') != -1) {\n                                //如果当前属性为registry，并且属性值包含逗号\",\",即有多个值，则进一步解析(后面会分析parseMultiRef方法)\n                                parseMultiRef(\"registries\", value, beanDefinition, parserContext);\n                            } else if (\"provider\".equals(property) && value.indexOf(',') != -1) {\n                                //如果当前属性为providers，并且属性值包含逗号\",\",即有多个值，则进一步解析\n                                parseMultiRef(\"providers\", value, beanDefinition, parserContext);\n                            } else if (\"protocol\".equals(property) && value.indexOf(',') != -1) {\n                                //如果当前属性为protocol，并且属性值包含逗号\",\",即有多个值，则进一步解析\n                                parseMultiRef(\"protocols\", value, beanDefinition, parserContext);\n                            } else {\n                                Object reference;\n                                //判断set方法的参数类型是否是原始类型\n                                if (isPrimitive(type)) {\n                                     if (\"async\".equals(property) && \"false\".equals(value)\n                                            || \"timeout\".equals(property) && \"0\".equals(value)\n\t\t\t    \n\t\t    //当前节点的名称为\"method\"\n\t\t    if (\"method\".equals(node.getNodeName()) || \"method\".equals(node.getLocalName())) {\n\t\t\t\n\t\t\t//获取当前节点的name属性\n\t\t\tString methodName = element.getAttribute(\"name\");\n\t\t\t\n\t\t\tif (methodName == null || methodName.length() == 0) {\n\t\t\t    //name属性不可以为空\n\t\t\t    throw new IllegalStateException(\"<dubbo:method> name attribute == null\");\n\t\t\t}\n\t\t\t\n\t\t\tif (methods == null) {\n\t\t\t    methods = new ManagedList();\n\t\t\t}\n\t\t\t\n\t\t\t//调用parse方法递归解析MethodConfig.class\n\t\t\tBeanDefinition methodBeanDefinition = parse(((Element) node),\n\t\t\t\tparserContext, \n\t\t\t\tMethodConfig.class, \n\t\t\t\tfalse\n\t\t\t);\n\t\t\t\n\t\t\t//新生成的bean的名称\n\t\t\tString name = id + \".\" + methodName;\n\t\t\t\n\t\t\t//将bean名称和bean定义关联起来\n\t\t\tBeanDefinitionHolder methodBeanDefinitionHolder = new BeanDefinitionHolder(\n\t\t\t\tmethodBeanDefinition, name);\n\t\t\t//保存新生成的bean\n\t\t\tmethods.add(methodBeanDefinitionHolder);\n\t\t    }\n\t\t}\n\t    }\n\t    if (methods != null) {\n\t\t//为待实例化的bean添加methods属性\n\t\tbeanDefinition.getPropertyValues().addPropertyValue(\"methods\", methods);\n\t    }\n\t}\n}\n\n```\n\n#### parseArguments方法\n```java\n/**\n* 当前property为arguments，解析<dubbo:argument>标签\n* @param id  当前待实例化的bean-id\n* @param nodeList 子节点列表\n* @param beanDefinition 当前待实例化的bean\n* @param parserContext\n*/\nprivate static void parseArguments(String id, NodeList nodeList, RootBeanDefinition beanDefinition,\n\t\t\t       ParserContext parserContext) {\n\n\tif (nodeList != null && nodeList.getLength() > 0) {\n\t    \n\t    ManagedList arguments = null;\n\n\t    //遍历子节点\n\t    for (int i = 0; i < nodeList.getLength(); i++) {\n\t\t\n\t\tNode node = nodeList.item(i);\n\n\t\tif (node instanceof Element) {\n\t\t    \n\t\t    Element element = (Element) node;\n\n\t\t    //当前子节点名称为argument\n\t\t    if (\"argument\".equals(node.getNodeName()) || \"argument\".equals(node.getLocalName())) {\n\t\t\t\n\t\t\t//获取当前子节点的index属性\n\t\t\tString argumentIndex = element.getAttribute(\"index\");\n\t\t\t\n\t\t\tif (arguments == null) {\n\t\t\t    arguments = new ManagedList();\n\t\t\t}\n\n\t\t\t//调用parse方法递归解析ArgumentConfig.class\n\t\t\tBeanDefinition argumentBeanDefinition = parse(((Element) node),\n\t\t\t\tparserContext, \n\t\t\t\tArgumentConfig.class, \n\t\t\t\tfalse\n\t\t\t);\n\n\t\t\t//新生成的bean的名称\n\t\t\tString name = id + \".\" + argumentIndex;\n\n\t\t\t//将新生成的bean名称和bean定义关联起来\n\t\t\tBeanDefinitionHolder argumentBeanDefinitionHolder = new BeanDefinitionHolder(\n\t\t\t\targumentBeanDefinition, name);\n        if (!beanDefinitionRegistry.containsBeanDefinition(beanName)) {\n            //该bean还没有注册的话，则进行注册\n\t    RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType);\n            \n\t    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n            \n\t    beanDefinitionRegistry.registerBeanDefinition(beanName, beanDefinition);\n        }\n    }\n}\n```\n\nDubboBeanDefinitionParser解析类就介绍完毕了，最后给一个的parse方法的处理流程图.\n![](img/DubboBeanDefinitionParser.png)\n\n\n\n\n\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之集成Spring标签配置类(01)","url":"/blog/2018/08/04/Dubbo源码阅读之集成Spring-01标签配置类/","content":"\n>本小节将会介绍下如何在Spring环境中使用Dubbo，以及Dubbo标签实体类\n\n* Spring中使用Dubbo的Demo\n* Dubbo标签解析\n\n\n### Spring中使用Dubbo的Demo\n我们先来看下Dubbo源码中dubbo-demo包中的例子。\n\n#### dubbo-demo-api\n首先在dubbo-demo-api模块中定义了一个接口：\n```java\npublic interface DemoService {\n    String sayHello(String name);\n}\n```\n\n然后在dubbo-demo-provider模块和dubbo-demo-consumer模块中分别引入dubbo-demo-api模块。\n\n#### dubbo-demo-provider\n我们先来看下dubbo-demo-provider服务提供端,新建一个DemoService接口的实现类DemoServiceImpl：\n```java\npublic class DemoServiceImpl implements DemoService {\n    @Override\n    public String sayHello(String name) {\n        System.out.println(\"[\" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()) + \"] Hello \" + name + \", request from consumer: \" + RpcContext.getContext().getRemoteAddress());\n        return \"Hello \" + name + \", response from provider: \" + RpcContext.getContext().getLocalAddress();\n    }\n}\n```\n然后在Spring配置文件中进行配置：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\"\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd\n       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\">\n    \n    <dubbo:application name=\"demo-provider\"/>\n    \n    <dubbo:registry address=\"multicast://224.5.6.7:1234\"/>\n    \n    <dubbo:protocol name=\"dubbo\" port=\"20880\"/>\n    \n    <bean id=\"demoService\" class=\"com.alibaba.dubbo.demo.provider.DemoServiceImpl\"/>\n    \n    <!--暴露服务-->\n    <dubbo:service interface=\"com.alibaba.dubbo.demo.DemoService\" ref=\"demoService\"/>\n</beans>\n```\n可以看到我们首先在配置文件中引入了dubbo自定义的schema文件，然后我们就可以在配置文件中使用dubbo自定义的标签了。这些标签我们后面会讲解。\n接下来我们新建一个Provider类，该类用来加载Spring配置文件，同时也启动了我们的服务器：\n```java\npublic class Provider {\n\n    public static void main(String[] args) throws Exception {\n        System.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n        //加载Spring配置\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{\"META-INF/spring/dubbo-demo-provider.xml\"});\n        context.start();\n        System.in.read(); // press any key to exit\n    }\n}\n```\n\n#### dubbo-demo-consumer\n\n我们在消费者端同样需要配置Spring配置文件：\n```xml\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\"\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd\n       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\">\n\n    <dubbo:application name=\"demo-consumer\"/>\n\n    <dubbo:registry address=\"multicast://224.5.6.7:1234\"/>\n    \n    <!--引用DemoService服务-->\n    <dubbo:reference id=\"demoService\" check=\"false\" interface=\"com.alibaba.dubbo.demo.DemoService\"/>\n\n</beans>\n```\n接着我们新建一个Consumer类：\n```java\npublic class Consumer {\n\n    public static void main(String[] args) {\n        System.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{\"META-INF/spring/dubbo-demo-consumer.xml\"});\n        context.start();\n\n        //获取远程服务代理\n        DemoService demoService = (DemoService) context.getBean(\"demoService\");\n       \n        while (true) {\n            try {\n                Thread.sleep(1000);\n                //调用远程服务方法\n                String hello = demoService.sayHello(\"world\");\n                //输出调用结果\n                System.out.println(hello);\n            } catch (Throwable throwable) {\n                throwable.printStackTrace();\n            }\n        }\n    }\n}\n```\n启动起来服务器和客户端，我们就可以看到输出结果了。经过上面的例子，我们可以看到使用Dubbo调用远程服务就像调用本地的服务一样简单。后面我们将详细介绍Dubbo是如何做到这些的。\n\n\n### Dubbo标签解析\n\n总体上Dubbo是通过自定义Spring标签，然后解析这些标签，将这些标签属性映射成一个个配置类，接着将这些类配置到Spring工厂，交给Spring容器来管理的方式来和Spring整合到一起的。\n这部分源码主要在dubbo-config包中，我们先看下Spring自定义标签的机制以及Dubbo标签对应的实体类，下一小节在具体分析如何解析标签。\n\n#### Spring自定义标签\n在dubbo-config-spring模块的resources目录下有三个文件，分别为：dubbo.xsd、spring.handlers、spring.schemas。\ndubbo.xsd文件中定义了所有支持的dubbo标签，spring.schemas文件中则指定了dubbo.xsd文件：\n```java\nhttp\\://dubbo.apache.org/schema/dubbo/dubbo.xsd=META-INF/dubbo.xsd\n```\n因此，我们需要分别在服务器、客户端的spring配置文件中引入该xsd文件，才可以使用dubbo标签。\n而spring.handlers文件中则指定了解析dubbo标签的类:\n```java\nhttp\\://dubbo.apache.org/schema/dubbo=com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler\n```\n我们就以com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler类作为入口，看看dubbo是如何解析标签的。\n\n我们来看下DubboNamespaceHandler类，该类继承自Spring的NamespaceHandlerSupport类，通过实现init方法来将dubbo标签节点和解析类进行关联：\n```java\npublic class DubboNamespaceHandler extends NamespaceHandlerSupport {\n    static {\n        //检测是否有重复的DubboNamespaceHandler类，这里不会抛异常，只会打印错误日志\n        Version.checkDuplicate(DubboNamespaceHandler.class);\n    }\n\n    /**\n     * 将节点名和解析类关联起来，NamespaceHandler通过节点名会找到相应的解析类\n     */\n    @Override\n    public void init() {\n        registerBeanDefinitionParser(\"application\", new DubboBeanDefinitionParser(ApplicationConfig.class, true));\n        registerBeanDefinitionParser(\"module\", new DubboBeanDefinitionParser(ModuleConfig.class, true));\n        registerBeanDefinitionParser(\"registry\", new DubboBeanDefinitionParser(RegistryConfig.class, true));\n        registerBeanDefinitionParser(\"monitor\", new DubboBeanDefinitionParser(MonitorConfig.class, true));\n        registerBeanDefinitionParser(\"provider\", new DubboBeanDefinitionParser(ProviderConfig.class, true));\n        registerBeanDefinitionParser(\"consumer\", new DubboBeanDefinitionParser(ConsumerConfig.class, true));\n        registerBeanDefinitionParser(\"protocol\", new DubboBeanDefinitionParser(ProtocolConfig.class, true));\n        registerBeanDefinitionParser(\"service\", new DubboBeanDefinitionParser(ServiceBean.class, true));\n        registerBeanDefinitionParser(\"reference\", new DubboBeanDefinitionParser(ReferenceBean.class, false));\n        registerBeanDefinitionParser(\"annotation\", new AnnotationBeanDefinitionParser());\n    }\n}\n```\n可以看到这里定义了dubbo标签的解析类DubboBeanDefinitionParser，同时也定义了该标签对应的bean(即xxxConfig类、xxxBean类)，这些bean最终交由Spring容器来管理。在介绍它们之前，我们先看一些通用的注解类,这些注解可以添加在bean类中的方法上，在解析标签的时候会用上这些注解。\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD})\npublic @interface Parameter {\n\n    String key() default \"\";\n\n    boolean required() default false;\n\n    /**\n     * 是否排除该方法\n     * @return\n     */\n    boolean excluded() default false;\n\n    /**\n     * 是否编码\n     * @return\n     */\n    boolean escaped() default false;\n\n    /**\n     * 属性为false的话，则不执行附加属性方法\n     * @return\n     */\n    boolean attribute() default false;\n\n    boolean append() default false;\n}\n```\n\n#### Dubbo标签对应的实体类\n在dubbo-config-api模块下的com.alibaba.dubbo.config包中定义了dubbo标签对应的实体类，我们先了解下这些实体类，然后再看如何解析它们。\n\n##### ApplicationConfig\n我们对照着使用方法一起看下：\n```xml\n <!--dubbo:application中可配置的属性都定义在ApplicationConfig实体类中-->\n <dubbo:application name=\"demo-provider\"/>\n```\nApplicationConfig类继承自AbstractConfig抽象类，该抽象类提供了一些解析配置的公共方法。\n```java\npublic class ApplicationConfig extends AbstractConfig {\n\n    private static final long serialVersionUID = 5508512956753757169L;\n\n    /**\n     * 服务治理（必填）\n     * 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样，\n     * 此参数不是匹配条件，你当前项目叫什么名字就填什么，和提供者消费者角色无关\n     * application\n     */\n    private String name;\n\n    /**\n     * 服务治理\n     * 当前应用模块版本\n     * application.version\n     */\n    private String version;\n\n    /**\n     * 服务治理\n     * 应用负责人，用于服务治理，请填写负责人公司邮箱前缀\n     * owner\n     */\n    private String owner;\n\n    /**\n     * 服务治理\n     * 组织名称(BU或部门)，用于注册中心区分服务来源，此配置项建议不要使用autoconfig，直接写死在配 置中，比如 china,intl,itu,crm,asc,dw,aliexpress 等\n     * organization\n     */\n    private String organization;\n\n    /**\n     * 服务治理\n     * 用于服务分层对应的架构。如，intl、china。不同的架构使用不同的分层\n     * architecture\n     */\n    private String architecture;\n\n    /**\n     * 服务治理\n     * 环境，例如：dev、test、production\n     * environment\n     */\n    private String environment;\n\n    /**\n     * 性能优化（javassist）\n     * Java字节码编译器，用于动态类的生成，可选：jdk或javassist\n     * compiler \n     */\n    private String compiler;\n\n    /**\n     * 性能优化（slf4j）\n     * 日志输出方式，可选： slf4j,jcl,log4j,jdk\n     * logger\n     */\n    private String logger;\n\n    /**\n     * 注册中心列表\n     */\n    private List<RegistryConfig> registries;\n\n    /**\n     * 监控中心\n     */\n    private MonitorConfig monitor;\n\n    /**\n     * 是否是默认的\n     */\n    private Boolean isDefault;\n\n    /**\n     * 保存线程转储的目录\n     */\n    private String dumpDirectory;\n\n    /**\n     * 是否启用qos\n     */\n    private Boolean qosEnable;\n\n    /**\n     * qos端口\n     */\n    private Integer qosPort;\n    /**\n     * 是否可以接受国外ip\n     */\n    private Boolean qosAcceptForeignIp;\n\n    /**\n     *  自定义参数\n     */\n    private Map<String, String> parameters;\n\n    public ApplicationConfig() {\n    }\n\n    public ApplicationConfig(String name) {\n        setName(name);\n    }\n\n    @Parameter(key = Constants.APPLICATION_KEY, required = true)\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        checkName(\"name\", name);\n        this.name = name;\n        if (id == null || id.length() == 0) {\n            id = name;\n        }\n    }\n\n    @Parameter(key = \"application.version\")\n    public String getVersion() {\n        return version;\n    }\n    public void setCompiler(String compiler) {\n        this.compiler = compiler;\n        AdaptiveCompiler.setDefaultCompiler(compiler);\n    }\n    public void setLogger(String logger) {\n        this.logger = logger;\n        LoggerFactory.setLoggerAdapter(logger);\n    }\n    // ...省略其他相似方法\n}\n```\n##### ModuleConfig\n```java\npublic class ModuleConfig extends AbstractConfig {\n\n    private static final long serialVersionUID = 5508512956753757169L;\n\n    /**\n     * 服务治理（必填）\n     * 当前模块名称，用于注册中心计算模块间依赖关系\n     * module\n     */\n    private String name;\n\n    /**\n     * 服务治理\n     * 当前模块的版本\n     * module.version\n     */\n    private String version;\n\n    /**\n     * 服务治理\n     * 模块负责人，用于服务治理，请填 写负责人公司邮箱前缀\n     * owner\n     */\n    private String owner;\n\n    /**\n     * 服务治理\n     * 组织名称(BU或部门)，用于注册中心区分服务来源，此配置项建议不要使用autoconfig，直接写死在配 置中，比如 china,intl,itu,crm,asc,dw,aliexpress 等\n     * organization\n     */\n    private String organization;\n\n    /**\n     * 注册中心列表\n     * registry centers\n     */\n    private List<RegistryConfig> registries;\n\n    /**\n     * 监控中心\n     * monitor center\n     */\n    private MonitorConfig monitor;\n\n    /**\n     * 是否是默认\n     */\n    private Boolean isDefault;\n\n    public ModuleConfig(String name) {\n        setName(name);\n    }\n\n    @Parameter(key = \"module\", required = true)\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        checkName(\"name\", name);\n        this.name = name;\n        //id为空的话，使用name的值\n        if (id == null || id.length() == 0) {\n            id = name;\n        }\n    }\n\n    @Parameter(key = \"module.version\")\n    public String getVersion() {\n        return version;\n    }\n    \n    public void setOwner(String owner) {\n        checkName(\"owner\", owner);\n        this.owner = owner;\n    }\n    \n    public void setOrganization(String organization) {\n        checkName(\"organization\", organization);\n        this.organization = organization;\n    }\n\n    public RegistryConfig getRegistry() {\n        return registries == null || registries.isEmpty() ? null : registries.get(0);\n    }\n\n    public void setRegistry(RegistryConfig registry) {\n        List<RegistryConfig> registries = new ArrayList<RegistryConfig>(1);\n        registries.add(registry);\n        this.registries = registries;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public void setRegistries(List<? extends RegistryConfig> registries) {\n        this.registries = (List<RegistryConfig>) registries;\n    }\n    // ...省略其他类似get、set方法\n}\n```\n\n##### RegistryConfig\n注册中心配置，如果有多个不同的注册中心，可以声明多个 <dubbo:registry> 标签，并在 <dubbo:service> 或 <dubbo:reference> 的 registry 属性指定使用的注册中心.\n```java\npublic class RegistryConfig extends AbstractConfig {\n\n    /**\n     * 不可用标识\n     */\n    public static final String NO_AVAILABLE = \"N/A\";\n\n    /**\n     * 服务发现（必填）\n     * 注册中心服务器地址，如果地址没有端口缺省为9090，同一集群内的多个地址用逗号分隔，如：ip:port,ip:port\n     * 不同集群的注册中心，请配置多个 <dubbo:registry> 标签\n     * <host:port>\n     */\n    private String address;\n\n    /**\n     * 服务治理\n     * 登录注册中心用户名，如果注册中心不需要验证可不填\n     * <username>\n     */\n    private String username;\n\n    /**\n     * 服务治理\n     * 登录注册中心密码，如果注册中心不需要验证可不填\n     * <password>\n     */\n    private String password;\n\n    /**\n     * 服务发现\n     * 注册中心默认端口,当address没有带端口时使用此端口做为缺省值\n     * <port>\n     */\n    private Integer port;\n\n    /**\n     * 服务发现(dubbo)\n     * 注册中心地址协议,支持dubbo,http,local三种协议,分别表示: dubbo地址,http地址,本地注册中心\n     * <protocol>\n     */\n    private String protocol;\n\n    /**\n     * 性能调优(netty)\n     * 网络传输方式，可选mina,netty\n     * registry.transporter\n     */\n    private String transporter;\n\n    private String server;\n\n    private String client;\n    \n    private String cluster;\n\n    private String group;\n\n    private String version;\n\n    /**\n     * 性能调优(5000)\n     * 注册中心请求超时时间(毫秒)\n     * registry.timeout\t\n     */\n    private Integer timeout;\n\n    /** \n     * 性能调优(60000)\n     * 注册中心会话超时时间(毫秒)，用于检测提供者非正常断线后的脏数据，比如用心跳检测的实现，此时间就是心跳间隔，不同注册中心实现不一样\n     * registry.session\n     */\n    private Integer session;\n\n    /**\n     * 服务治理\n     * 使用文件缓存注 册中心地址列表及服务提供者列表，应用重启时将基于此文件恢复，注意：两个注册中心不能使用同一文件存储\n     * registry.file\n     */\n    private String file;\n\n    /**\n     * 性能调优(0)\n     * 停止时等待通知完成时间(毫秒)\n     * registry.wait\n     */\n    private Integer wait;\n\n    /**\n     * 服务治理(true)\n     * 在启动时，是否检测注册中心是否可用\n     * check\n     */\n    private Boolean check;\n\n    /**\n     * 服务治理(true)\n     * 服务是否动态注册，如果设为 false，注册后将显示后disable状态，需人工启用，并且服务提供者停止时，也不会自动取消册，需人工禁用\n     * dynamic\n     */\n    private Boolean dynamic;\n\n    /**\n     * 服务治理（true）\n     * 是否向此注册中心注册服务，如果设为false，将只订阅，不注册\n     * register\n     */\n    private Boolean register;\n\n    /**\n     * 服务治理（true）\n     * 是否向此注册中心订阅服务，如果设为false，将只注册，不订阅\n     * subscribe \n     */\n    private Boolean subscribe;\n\n    /**\n     * 自定义参数\n     */\n    private Map<String, String> parameters;\n\n    /**\n     * 是否是默认\n     */\n    private Boolean isDefault;\n\n    public RegistryConfig() {\n    }\n\n    public static void destroyAll() {\n        AbstractRegistryFactory.destroyAll();\n    }\n\n    public void setProtocol(String protocol) {\n        checkName(\"protocol\", protocol);\n        this.protocol = protocol;\n    }\n\n    @Parameter(excluded = true)\n    public String getAddress() {\n        return address;\n    }\n\n    public void setUsername(String username) {\n        checkName(\"username\", username);\n        this.username = username;\n    }\n\n    public void setFile(String file) {\n        checkPathLength(\"file\", file);\n        this.file = file;\n    }\n\n    public void setTransporter(String transporter) { \n        checkName(\"transporter\", transporter);\n        this.transporter = transporter;\n    }\n\n    public void setServer(String server) {\n        checkName(\"server\", server);\n        this.server = server;\n    }\n\n    public void setClient(String client) {\n        checkName(\"client\", client);\n        this.client = client;\n    }\n\n}\n```\n##### MonitorConfig\n```java\npublic class MonitorConfig extends AbstractConfig {\n\n    /**\n     * 服务治理(dubbo)\n     * 监控中心协议，如果为protocol=”registry”，表示从注册中心发现监控中心地址，否则直连监控中心\n     * protocol\n     */\n    private String protocol;\n    \n    /**\n     * 服务治理(N/A)\n     * 直连监控中心服务器地址，address=”10.20.130.230:12080”\n     * <url>\n     */\n    private String address;\n\n    private String username;\n\n    private String password;\n\n    private String group;\n\n    private String version;\n\n    private String interval;\n\n    private Map<String, String> parameters;\n\n    private Boolean isDefault;\n\n    public MonitorConfig(String address) {\n        this.address = address;\n    }\n\n    @Parameter(excluded = true)\n    public String getAddress() {\n        return address;\n    }\n\n    @Parameter(excluded = true)\n    public String getProtocol() {\n        return protocol;\n    }\n\n    @Parameter(excluded = true)\n    public String getUsername() {\n        return username;\n    }\n    @Parameter(excluded = true)\n    public String getPassword() {\n        return password;\n    }\n\n    public void setParameters(Map<String, String> parameters) {\n        checkParameterName(parameters);\n        this.parameters = parameters;\n    }\n\n}\n```\n##### ProviderConfig\n该类继承自AbstractServiceConfig类\n```java\npublic class ProviderConfig extends AbstractServiceConfig {\n\n    //如果没有设置协议的属性值，那么默认值将会生效\n    /**\n     * 服务ip地址（当有多个网卡可用时使用）(自动查找本机IP)\n     * <host>\n     */\n    private String host;\n\n    /**\n     * 服务端口\n     * port\n     */\n    private Integer port;\n\n    /**\n     * 上下文路径\n     * contextpath\n     */\n    private String contextpath;\n\n    /**\n     * 线程池(fixed)\n     * threadpool\n     */\n    private String threadpool;\n\n    /**\n     * 线程池大小（固定大小）\n     */\n    private Integer threads;\n\n    /**\n     * IO线程池大小（CPU数+1）\n     * iothreads\n     */\n    private Integer iothreads;\n\n    /**\n     * 线程池队列长度(0)\n     * queues\n     */\n    private Integer queues;\n\n    /**\n     * 最大可接受的连接(0)\n     * accepts\n     */\n    private Integer accepts;\n\n    /**\n     * 协议编解码器（dubbo）\n     * codec\n     */\n    private String codec;\n\n    /**\n     * 编码（UTF-8）\n     * charset\n     */\n    private String charset;\n\n    /**\n     * payload最大长度(88388608(=8M))\n     * payload\n     */\n    private Integer payload;\n\n    /**\n     * buffer大小(8192)\n     * buffer\n     */\n    private Integer buffer;\n\n    /**\n     * transporter\n     */\n    private String transporter;\n\n    /**\n     * how information gets exchanged\n     */\n    private String exchanger;\n\n    /**\n     * 性能调优\n     * 线程调度模式\n     * 协议的消息派发方式，用于指定线程模型，比如：dubbo协议的all,direct,message,execution,connection等\n     */\n    private String dispatcher;\n\n    /**\n     * networker\n     */\n    private String networker;\n\n    /**\n     * 服务器实现\n     * dubbo协议缺省 为netty，http协议缺省为servlet\n     * server\n     */\n    private String server;\n\n    /**\n     * 客户端实现\n     * dubbo协议缺省 为netty\n     * client\n     */\n    private String client;\n\n    /**\n     * 支持telnet命令,逗号分割\n     */\n    private String telnet;\n\n    /**\n     * 命令行提示符\n     */\n    private String prompt;\n\n    /**\n     * 状态检测\n     */\n    private String status;\n\n    /**\n     * 停止的时候等待多久\n     */\n    private Integer wait;\n\n    private Boolean isDefault;\n\n    @Parameter(excluded = true)\n    public Boolean isDefault() {\n        return isDefault;\n    }\n\n    @Parameter(excluded = true)\n    public String getHost() {\n        return host;\n    }\n\n    @Parameter(excluded = true)\n    public Integer getPort() {\n        return port;\n    }\n\n    @Parameter(excluded = true)\n    public String getContextpath() {\n        return contextpath;\n    }\n\n    public void setContextpath(String contextpath) {\n        checkPathName(\"contextpath\", contextpath);\n        this.contextpath = contextpath;\n    }\n\n    public void setThreadpool(String threadpool) {\n        checkExtension(ThreadPool.class, \"threadpool\", threadpool);\n        this.threadpool = threadpool;\n    }\n\n    public void setTelnet(String telnet) {\n        checkMultiExtension(TelnetHandler.class, \"telnet\", telnet);\n        this.telnet = telnet;\n    }\n\n    @Parameter(escaped = true)\n    public String getPrompt() {\n        return prompt;\n    }\n    public void setStatus(String status) {\n        checkMultiExtension(StatusChecker.class, \"status\", status);\n        this.status = status;\n    }\n\n    @Override\n    public String getCluster() {\n        return super.getCluster();\n    }\n\n    @Override\n    public Integer getConnections() {\n        return super.getConnections();\n    }\n\n    @Override\n    public Integer getTimeout() {\n        return super.getTimeout();\n    }\n\n    @Override\n    public Integer getRetries() {\n        return super.getRetries();\n    }\n\n    @Override\n    public String getLoadbalance() {\n        return super.getLoadbalance();\n    }\n\n    @Override\n    public Boolean isAsync() {\n        return super.isAsync();\n    }\n\n    @Override\n    public Integer getActives() {\n        return super.getActives();\n    }\n\n    public void setTransporter(String transporter) {\n        checkExtension(Transporter.class, \"transporter\", transporter);\n        this.transporter = transporter;\n    }\n\n    public void setExchanger(String exchanger) {\n        checkExtension(Exchanger.class, \"exchanger\", exchanger);\n        this.exchanger = exchanger;\n    }\n\n    public void setDispatcher(String dispatcher) {\n        checkExtension(Dispatcher.class, Constants.DISPATCHER_KEY, exchanger);\n        checkExtension(Dispatcher.class, \"dispather\", exchanger);\n        this.dispatcher = dispatcher;\n    }\n}\n```\n##### AbstractMethodConfig\n该抽象类继承自AbstractConfig\n```java\npublic abstract class AbstractMethodConfig extends AbstractConfig {\n\n    /**\n     * 远程调用超时(1000毫秒)\n     * timeout for remote invocation in milliseconds\n     */\n    protected Integer timeout;\n\n    /**\n     * 重试次数（2）\n     */\n    protected Integer retries;\n\n    /**\n     * 最大并发调用(0)\n     * max concurrent invocations\n     */\n    protected Integer actives;\n\n    /**\n     * 负载均衡（random）\n     */\n    protected String loadbalance;\n\n    /**\n     * 是否异步\n     */\n    protected Boolean async;\n\n    /**\n     * 是否确认异步发送\n     */\n    protected Boolean sent;\n\n    /**\n     * 当服务调用失败时，被调用的mack类的名字\n     * mock\n     */\n    protected String mock;\n\n    /**\n     * 合并\n     */\n    protected String merger;\n\n    /**\n     * 缓存\n     */\n    protected String cache;\n\n    /**\n     * 验证\n     */\n    protected String validation;\n\n    /**\n     * 自定义参数\n     */\n    protected Map<String, String> parameters;\n\n    public void setLoadbalance(String loadbalance) {\n        checkExtension(LoadBalance.class, \"loadbalance\", loadbalance);\n        this.loadbalance = loadbalance;\n    }\n\n    @Parameter(escaped = true)\n    public String getMock() {\n        return mock;\n    }\n\n    public void setMock(Boolean mock) {\n        if (mock == null) {\n            setMock((String) null);\n        } else {\n            setMock(String.valueOf(mock));\n        }\n    }\n\n    public void setMock(String mock) {\n        if (mock != null && mock.startsWith(Constants.RETURN_PREFIX)) {\n            checkLength(\"mock\", mock);\n        } else {\n            checkName(\"mock\", mock);\n        }\n        this.mock = mock;\n    }\n}\n```\n\n##### AbstractInterfaceConfig\n该类继承自AbstractMethodConfig\n```java\npublic abstract class AbstractInterfaceConfig extends AbstractMethodConfig {\n\n    /**\n     * 服务接口的本地实现类名称\n     */\n    protected String local;\n\n    /**\n     * 服务接口的本地存根类名称\n     */\n    protected String stub;\n\n    /**\n     * 服务监控\n     */\n    protected MonitorConfig monitor;\n\n    /**\n     * 代理类型\n     */\n    protected String proxy;\n\n    /**\n     * 性能调优（failover）\n     * 集群方式，可选：failover/failfast/failsafe/failback/forking\n     * default.cluster\n     */\n    protected String cluster;\n\n    /**\n     * 过滤器\n     */\n    protected String filter;\n\n    /**\n     * 监听器\n     */\n    protected String listener;\n\n    /**\n     * 所有者\n     */\n    protected String owner;\n\n    /**\n     * 连接限制，0标识共享连接（0）\n     * 否则它定义委托给当前服务的连接\n     * default.connections\t\n     */\n    protected Integer connections;\n\n    protected String layer;\n\n    /**\n     * application配置\n     */\n    protected ApplicationConfig application;\n\n    /**\n     *  module配置\n     */\n    protected ModuleConfig module;\n\n    /**\n     * 注册中心内地址\n     * <dubbo:registry address=\"multicast://224.5.6.7:1234\" id=\"com.alibaba.dubbo.config.RegistryConfig\" />\n     */\n    protected List<RegistryConfig> registries;\n\n    /**\n     * 连接事件\n     * connection events\n     */\n    protected String onconnect;\n\n    /**\n     * 断开连接事件\n     * disconnection events\n     */\n    protected String ondisconnect;\n\n    /**\n     * 回调限制\n     * callback limits\n     */\n    private Integer callbacks;\n\n    /**\n     * 引用/暴露服务的作用域\n     * 如果它是local，则意味着只在当前虚拟机中进行搜索\n     */\n    private String scope;\n\n    public void setStub(Boolean stub) {\n        if (stub == null) {\n            setStub((String) null);\n        } else {\n            setStub(String.valueOf(stub));\n        }\n    }\n\n    public void setStub(String stub) {\n        checkName(\"stub\", stub);\n        this.stub = stub;\n    }\n\n    public void setCluster(String cluster) {\n        checkExtension(Cluster.class, \"cluster\", cluster);\n        this.cluster = cluster;\n    }\n\n    public void setProxy(String proxy) {\n        checkExtension(ProxyFactory.class, \"proxy\", proxy);\n        this.proxy = proxy;\n    }\n\n    @Parameter(key = Constants.REFERENCE_FILTER_KEY, append = true)\n    public String getFilter() {\n        return filter;\n    }\n\n    public void setFilter(String filter) {\n        checkMultiExtension(Filter.class, \"filter\", filter);\n        this.filter = filter;\n    }\n\n    @Parameter(key = Constants.INVOKER_LISTENER_KEY, append = true)\n    public String getListener() {\n        return listener;\n    }\n\n    public void setListener(String listener) {\n        checkMultiExtension(InvokerListener.class, \"listener\", listener);\n        this.listener = listener;\n    }\n    public void setLayer(String layer) {\n        checkNameHasSymbol(\"layer\", layer);\n        this.layer = layer;\n    }\n\n    public RegistryConfig getRegistry() {\n        return registries == null || registries.isEmpty() ? null : registries.get(0);\n    }\n\n    public void setRegistry(RegistryConfig registry) {\n        List<RegistryConfig> registries = new ArrayList<RegistryConfig>(1);\n        registries.add(registry);\n        this.registries = registries;\n    }\n    //省略其他方法...后面会介绍\n}\n```\n##### AbstractServiceConfig\n该抽象类继承自AbstractInterfaceConfig\n```java\npublic abstract class AbstractServiceConfig extends AbstractInterfaceConfig {\n\n\n    /**\n     * 版本(0.0.0)\n     */\n    protected String version;\n\n    /**\n     * 组\n     */\n    protected String group;\n\n    /**\n     * 服务是否被弃用\n     */\n    protected Boolean deprecated;\n\n    /**\n     * 延迟暴露\n     */\n    protected Integer delay;\n\n    /**\n     * 是否暴露服务\n     */\n    protected Boolean export;\n\n    /**\n     * 权重\n     */\n    protected Integer weight;\n\n    /**\n     * 文档中心\n     */\n    protected String document;\n\n    /**\n     * 是否在注册中心注册为动态服务(true)\n     */\n    protected Boolean dynamic;\n\n    /**\n     * 是否使用token\n     */\n    protected String token;\n\n    /**\n     * 访问日志\n     * access log\n     */\n    protected String accesslog;\n    protected List<ProtocolConfig> protocols;\n    /**\n     * 允许最大执行时间\n     * max allowed execute times\n     */\n    private Integer executes;\n    /**\n     * 是否注册\n     * whether to register\n     */\n    private Boolean register;\n\n    /**\n     * 根据指定的稳定吞吐率和预热期来创建RateLimiter\n     * warm up period\n     */\n    private Integer warmup;\n\n    /**\n     * dubbo协议缺省为hessian2， rmi协议缺省为java，http协议缺省为json\n     * serialization\n     */\n    private String serialization;\n\n\n    public void setVersion(String version) {\n        checkKey(\"version\", version);\n        this.version = version;\n    }\n\n    public void setGroup(String group) {\n        checkKey(\"group\", group);\n        this.group = group;\n    }\n\n    @Parameter(escaped = true)\n    public String getDocument() {\n        return document;\n    }\n\n    public void setToken(String token) {\n        checkName(\"token\", token);\n        this.token = token;\n    }\n\n    public void setToken(Boolean token) {\n        if (token == null) {\n            setToken((String) null);\n        } else {\n            setToken(String.valueOf(token));\n        }\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public void setProtocols(List<? extends ProtocolConfig> protocols) {\n        this.protocols = (List<ProtocolConfig>) protocols;\n    }\n\n    public ProtocolConfig getProtocol() {\n        return protocols == null || protocols.isEmpty() ? null : protocols.get(0);\n    }\n\n    public void setProtocol(ProtocolConfig protocol) {\n        this.protocols = Arrays.asList(new ProtocolConfig[]{protocol});\n    }\n\n    public void setAccesslog(Boolean accesslog) {\n        if (accesslog == null) {\n            setAccesslog((String) null);\n        } else {\n            setAccesslog(String.valueOf(accesslog));\n        }\n    }\n\n    @Override\n    @Parameter(key = Constants.SERVICE_FILTER_KEY, append = true)\n    public String getFilter() {\n        return super.getFilter();\n    }\n\n    @Override\n    @Parameter(key = Constants.EXPORTER_LISTENER_KEY, append = true)\n    public String getListener() {\n        return super.getListener();\n    }\n\n    @Override\n    public void setListener(String listener) {\n        checkMultiExtension(ExporterListener.class, \"listener\", listener);\n        super.setListener(listener);\n    }\n}\n\n```\n##### ConsumerConfig\n```java\npublic class ConsumerConfig extends AbstractReferenceConfig {\n\n    private Boolean isDefault;\n\n    /**\n     * 使用的网络框架客户端：netty, mina, etc\n     */\n    private String client;\n\n    @Override\n    public void setTimeout(Integer timeout) {\n        super.setTimeout(timeout);\n        //设置rmi超时时间\n        String rmiTimeout = System.getProperty(\"sun.rmi.transport.tcp.responseTimeout\");\n        if (timeout != null && timeout > 0\n                && (rmiTimeout == null || rmiTimeout.length() == 0)) {\n            System.setProperty(\"sun.rmi.transport.tcp.responseTimeout\", String.valueOf(timeout));\n        }\n    }\n}\n```\n##### AbstractReferenceConfig\n```java\npublic abstract class AbstractReferenceConfig extends AbstractInterfaceConfig {\n\n    //如果Reference的属性没有配置，则默认值将会生效\n\n    /**\n     * 检测服务提供者是否存在\n     */\n    protected Boolean check;\n\n    /**\n     * 1、是否立即初始化，如果为true,bean加载时会立即调用消费者初始化\n     * 2、消费者bean被使用者调用时，调用getObject->get->init\n     */\n    protected Boolean init;\n\n    /**\n     * 是否使用缺省泛化接口\n     */\n    protected String generic;\n\n    /**\n     * scope = local\n     * 是否从当前虚拟机中查找reference的实例\n     * whether to find reference's instance from the current JVM\n     */\n    protected Boolean injvm;\n\n    /**\n     * 惰性创建连接\n     * lazy create connection\n     */\n    protected Boolean lazy;\n\n    /**\n     * 重连\n     */\n    protected String reconnect;\n\t\n    protected Boolean sticky;\n\n    /**\n     * stub中是否支持事件\n     * Constants.DEFAULT_STUB_EVENT\n     */\n    protected Boolean stubevent;\n\n    /**\n     * 默认版本\n     */\n    protected String version;\n\n    protected String group;\n\n    @Parameter(excluded = true)\n    public Boolean isGeneric() {\n        return ProtocolUtils.isGeneric(generic);\n    }\n\n    public void setGeneric(Boolean generic) {\n        if (generic != null) {\n            this.generic = generic.toString();\n        }\n    }\n\n    @Override\n    @Parameter(key = Constants.REFERENCE_FILTER_KEY, append = true)\n    public String getFilter() {\n        return super.getFilter();\n    }\n\n    @Override\n    @Parameter(key = Constants.INVOKER_LISTENER_KEY, append = true)\n    public String getListener() {\n        return super.getListener();\n    }\n\n    @Override\n    public void setListener(String listener) {\n        checkMultiExtension(InvokerListener.class, \"listener\", listener);\n        super.setListener(listener);\n    }\n\n    @Parameter(key = Constants.LAZY_CONNECT_KEY)\n    public Boolean getLazy() {\n        return lazy;\n    }\n\n    @Override\n    public void setOnconnect(String onconnect) {\n        if (onconnect != null && onconnect.length() > 0) {\n            this.stubevent = true;\n        }\n        super.setOnconnect(onconnect);\n    }\n\n    @Override\n    public void setOndisconnect(String ondisconnect) {\n        if (ondisconnect != null && ondisconnect.length() > 0) {\n            this.stubevent = true;\n        }\n        super.setOndisconnect(ondisconnect);\n    }\n\n    @Parameter(key = Constants.STUB_EVENT_KEY)\n    public Boolean getStubevent() {\n        return stubevent;\n    }\n\n    @Parameter(key = Constants.RECONNECT_KEY)\n    public String getReconnect() {\n        return reconnect;\n    }\n\n    @Parameter(key = Constants.CLUSTER_STICKY_KEY)\n    public Boolean getSticky() {\n        return sticky;\n    }\n}\n```\n\n##### ProtocolConfig\n```java\npublic class ProtocolConfig extends AbstractConfig {\n\n    private static final long serialVersionUID = 6913423882496634749L;\n\n    /**\n     * 性能调优(必填dubbo)\n     * 协议名称\n     * \t<protocol>\n     */\n    private String name;\n\n    /**\n     * 服务发现(自动查找本机IP)\n     * 服务主机名，多网卡选择或指定VIP及域名时使用，为空则自动查找本机IP，-建议不要配置，让Dubbo自动获取本机IP\n     * host\n     */\n    private String host;\n\n    /**\n     * 服务端口\n     * dubbo协议缺省端口为20880,rmi协议缺省端口为1099,http 和hessian协议缺省端口为80\n     * 如果配置为-1 或者没有配置port，则会分配一个没有被占用的端口\n     * Dubbo 2.4.0+，分配的端口在协议缺省端口的基础上增长，确保端口段可控\n     * <port>\n     */\n    private Integer port;\n\n    /**\n     * 服务发现\n     * 提供者上下文路径，为服务path的前缀\n     * <path>\n     */\n    private String contextpath;\n\n    /**\n     * 性能调优（fixed）\n     * 线程池类型，可选：fixed/cached\n     * threadpool\n     */\n    private String threadpool;\n\n    /**\n     * 性能调优(100)\n     * 服务线程池大小(固定大小)\n     * threads\n     */\n    private Integer threads;\n\n    /**\n     * 性能调优(cpu个数+1)\n     * IO线程池大小（固定大小）\n     */\n    private Integer iothreads;\n\n    /**\n     * 性能调优(0)\n     * 线程池队列大小，当线程池满时，排队等待执行的队列大小，\n     * 建议不要设置，当线程程池时应立即失败，重试其它服务提供机器，而不是排队，除非有特殊需求\n     * queues\n     */\n    private Integer queues;\n\n    /**\n     * 性能调优(0)\n     * 服务提供方最大可接受连接数\n     * accepts \n     */\n    private Integer accepts;\n\n    /**\n     * 性能调优(dubbo)\n     * 协议编码方式\n     * codec\n     */\n    private String codec;\n\n    /**\n     * 性能调优(dubbo协议缺省为hessian2，rmi协议缺省为java，http协议 缺省为json)\n     * 协议序列化方式，当协议支持多种序列化方式时使用，比如：dubbo协议的dubbo,hessian2,java,compactedjava，以及http协议的json等\n     * serialization\n     */\n    private String serialization;\n\n    /**\n     * 序列化编码(UTF-8)\n     * charset\n     */\n    private String charset;\n\n    /**\n     * 性能调优(88388608(=8M))\n     * 请求及响应数据包大小限制，单位：字节\n     * payload\n     */\n    private Integer payload;\n\n    /**\n     * 性能调优(8192)\n     * 网络读写缓冲区大小\n     * buffer\n     */\n    private Integer buffer;\n\n    /**\n     * 性能调优（0）\n     * 心跳间隔，对于长连接，当物理层断开时，比如拔网线，TCP的FIN消息来不及发送，\n     * 对方收不到断开事件，此时需要心跳来帮助检查连接是否已断开\n     * heartbeat\n     */\n    private Integer heartbeat;\n\n    /**\n     * 服务治理\n     * 设为true，将向logger中输出访问日志，也可填写访问日志文件路径，直接把访问日志输出到指定文件\n     * accesslog\n     */\n    private String accesslog;\n\t\n    /**\n     * 性能调优(dubbo协议缺省为netty)\n     * 协议的服务端和客户端实现类型，比如：dubbo协议的mina,netty等，可以分拆为server和client配置\n     * transporter\n     */\n    private String transporter;\n\n    private String exchanger;\n\n    /**\n     * 性能(dubbo协议缺省为all)\n     * 协议的消息派发方式，用于指定线程模型，比如：dubbo协议的all,direct,message,execution,connection等\n     * dispatcher\n     */\n    private String dispatcher;\n\n    /**\n     * networker\n     */\n    private String networker;\n\n    /**\n     * 性能调优(dubbo协议缺省为netty，http协议缺省为servlet)\n     * 协议的服务器端实现类型，比如：dubbo协议的mina,netty等，http协议的jetty,servlet等\n     * server\n     */\n    private String server;\n\n    /**\n     * 性能调优(协议缺省为netty)\n     * 客户端实现\n     * client\n     */\n    private String client;\n\n    /**\n     * 服务治理\n     * 支持的telnet命令，逗号分隔\n     * telnet\n     */\n    private String telnet;\n\n    /**\n     * 命令行提示\n     */\n    private String prompt;\n\n    /**\n     * 状态检测\n     */\n    private String status;\n\n    /**\n     * 服务治理（true）\n     * 该协议的服务是否注册到注册中心\n     */\n    private Boolean register;\n\n    /**\n     * 是否长连接\n     * TODO add this to provider config\n     */\n    private Boolean keepAlive;\n\n    /**\n     * TODO add this to provider config\n     */\n    private String optimizer;\n\n    private String extension;\n\n    private Map<String, String> parameters;\n\n    private Boolean isDefault;\n  \n    /**\n     * 是否已经销毁\n     */\n    private static final AtomicBoolean destroyed = new AtomicBoolean(false);\n\n    public ProtocolConfig() {\n    }\n\n    public ProtocolConfig(String name) {\n        setName(name);\n    }\n\n    public ProtocolConfig(String name, int port) {\n        setName(name);\n        setPort(port);\n    }\n\n    @Parameter(excluded = true)\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        checkName(\"name\", name);\n        this.name = name;\n        if (id == null || id.length() == 0) {\n            id = name;\n        }\n    }\n\n    @Parameter(excluded = true)\n    public String getHost() {\n        return host;\n    }\n\n    @Parameter(excluded = true)\n    public Integer getPort() {\n        return port;\n    }\n\n    @Parameter(excluded = true)\n    public String getContextpath() {\n        return contextpath;\n    }\n\n    public void setContextpath(String contextpath) {\n        checkPathName(\"contextpath\", contextpath);\n        this.contextpath = contextpath;\n    }\n\n    public void setThreadpool(String threadpool) {\n        checkExtension(ThreadPool.class, \"threadpool\", threadpool);\n        this.threadpool = threadpool;\n    }\n\n    public void setCodec(String codec) {\n        if (\"dubbo\".equals(name)) {\n            checkMultiExtension(Codec.class, \"codec\", codec);\n        }\n        this.codec = codec;\n    }\n\n    public void setSerialization(String serialization) {\n        if (\"dubbo\".equals(name)) {\n            checkMultiExtension(Serialization.class, \"serialization\", serialization);\n        }\n        this.serialization = serialization;\n    }\n\n    public void setServer(String server) {\n        if (\"dubbo\".equals(name)) {\n            checkMultiExtension(Transporter.class, \"server\", server);\n        }\n        this.server = server;\n    }\n\n    public void setClient(String client) {\n        if (\"dubbo\".equals(name)) {\n            checkMultiExtension(Transporter.class, \"client\", client);\n        }\n        this.client = client;\n    }\n\n    public void setTelnet(String telnet) {\n        checkMultiExtension(TelnetHandler.class, \"telnet\", telnet);\n        this.telnet = telnet;\n    }\n\n    @Parameter(escaped = true)\n    public String getPrompt() {\n        return prompt;\n    }\n\n    public void setStatus(String status) {\n        checkMultiExtension(StatusChecker.class, \"status\", status);\n        this.status = status;\n    }\n\n    public void setTransporter(String transporter) {\n        checkExtension(Transporter.class, \"transporter\", transporter);\n        this.transporter = transporter;\n    }\n\n    public void setExchanger(String exchanger) {\n        checkExtension(Exchanger.class, \"exchanger\", exchanger);\n        this.exchanger = exchanger;\n    }\n\n    public void setDispatcher(String dispatcher) {\n        checkExtension(Dispatcher.class, \"dispacther\", dispatcher);\n        this.dispatcher = dispatcher;\n    }\n\n    public void destory() {\n        if (name != null) {\n\t    //获取Protocol扩展实例，然后调用destroy方法\n            ExtensionLoader.getExtensionLoader(Protocol.class)\n                    .getExtension(name)\n                    .destroy();\n        }\n    }\n}\n```\n##### ServiceConfig\n```java\npublic class ServiceConfig<T> extends AbstractServiceConfig {\n\n    /**\n     * 服务发现\n     * 服务接口名称\n     */\n    private String interfaceName;\n   \n    /**\n     * 服务接口类\n     */\n    private Class<?> interfaceClass;\n   \n    /**\n     * 服务发现(必填)\n     * 服务对象实现引用\n     */\n    private T ref;\n    \n    /**\n     * 服务发现(缺省为接口名)\n     * 服务路径(注意：1.0不支持自定义路径，总是使用接口名，如果有1.0调 2.0，配置服务路径可能不兼容\n     * <path>\n     */\n    private String path;\n    \n    /**\n     * 服务方法配置\n     */\n    private List<MethodConfig> methods;\n   \n    /**\n     * 提供者\n     */\n    private ProviderConfig provider;\n\n\n    /**\n     * 泛化接口\n     */\n    private volatile String generic;\n}\n\n```\n##### ReferenceConfig\n```java\npublic class ReferenceConfig<T> extends AbstractReferenceConfig {\n\n    /**\n     * 引用的接口名称\n     */\n    private String interfaceName;\n\n    /**\n     * 引用的接口类\n     */\n    private Class<?> interfaceClass;\n    \n    /**\n     * 客户端类型\n     */\n    private String client;\n    \n    /**\n     * 点对点调用url\n     */\n    private String url;\n    \n    /**\n     * 引用接口方法配置\n     */\n    private List<MethodConfig> methods;\n    \n    /**\n     * 默认配置\n     */\n    private ConsumerConfig consumer;\n    \n    /**\n     * 协议\n     */\n    private String protocol;\n\n    /**\n     * 接口代理引用\n     * interface proxy reference\n     */\n    private transient volatile T ref;\n\n    private transient volatile Invoker<?> invoker;\n\n    /**\n     * 是否已初始化\n     */\n    private transient volatile boolean initialized;\n\n    /**\n     * 是否已销毁\n     */\n    private transient volatile boolean destroyed;\n}\n```\n\n### 覆盖和优先级\n以timeout为例，这里按照优先级从高到低排列(retries,loadbalance, actives也应用相同的规则)：\n* 方法级别，接口级别，默认/全局级别\n* 相同的级别下，消费者比提供者有更高的优先级\n![](img/level.jpg)\n\n这一小节我们就先介绍到这里，下一小节开始介绍具体的解析逻辑。\n\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之Logger模块","url":"/blog/2018/07/31/Dubbo源码阅读之Logger模块/","content":">本文主要分析Dubbo是如何封装常用的日志框架的，以及在Dubbo中如何使用日志。\n\n在com.alibaba.dubbo.common.logger包中定义了如下几个和日志相关的类和接口：\n\n* Level枚举类\n* Logger接口\n* LoggerAdapter接口\n* LoggerFactory类\n\n### Level枚举类\n该枚举类从低到高定义了如下几个日志级别：\n```java\nALL,TRACE,DEBUG,INFO,WARN,ERROR,OFF\n```\n### Logger接口\n该接口定义了一些输出相应级别日志的方法，如：\n```JAVA\npublic interface Logger {\n\t//输出debug级别日志\n\tpublic void debug(Throwable e);\n\tpublic void debug(String msg, Throwable e);\n\tpublic boolean isDebugEnabled();\n\n\t//省略其他类似方法\n\t...\n}\n```\n### LoggerAdapter接口\n该接口为Logger提供者，定义了获取Logger、设置level级别、设置logger文件等方法,SPI注解我们后面的章节会详细介绍:\n```JAVA\n@SPI\npublic interface LoggerAdapter{\n    //获取Logger\n    Logger getLogger(Class<?> key);\n    //获取Logger\n    Logger getLogger(String key);\n    //获取当前logger日志级别\n    Level getLevel();\n    //设置当前logger级别\n    void setLevel(Level level);\n    //获取当前logger文件\n    File getFile();\n    //设置当前logger文件\n    void setFile(File file);\n}\n```\n### JdkLogger/JdkLoggerAdapter例子\n如果需要将日志框架集成到Dubbo中，需要实现上面定义的Logger接口和LoggerAdapter接口。\nDubbo默认已经集成了commons-logging、java.util.logging.Logger、org.apache.log4j.Logger、org.slf4j.Logger。\n作为例子，我们看下jdkLogger，其他的都类似。\n```JAVA\n//JdkLogger实现了Dubbo框架定义的Logger接口\npublic class JdkLogger implements Logger {\n\n    //持有java.util.logging.Logger实例\t\n    private final java.util.logging.Logger logger;\n\n    public JdkLogger(java.util.logging.Logger logger) {\n\t//构造方法，设置logger实例\n        this.logger = logger;\n    }\n\n    //实现了Logger接口中定义的方法\n    //都是委托给了java.util.logging.Logger实例来打印相应级别的日志\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.log(Level.INFO, msg, e);\n    }\n    \n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    } \n     \n    //省略其他类似方法\n    ...\n}\n\n//JdkLoggerAdapter实现了Dubbo框架定义的LoggerAdapter接口\npublic class JdkLoggerAdapter implements LoggerAdapter {\n\t\n\t//全局日志名称\n\tprivate static final String GLOBAL_LOGGER_NAME = \"global\";\n\t\n\t//存放日志的文件\n\tprivate File file;\n\t\t\n\t//该构造方法读取jdk日志配置文件logging.properties，设置日志文件file\n\tpublic JdkLoggerAdapter() {\n\t\ttry {\n\t\t    //获取jdk日志配置文件logging.properties\n\t\t    InputStream in = Thread.currentThread()\n\t\t\t    .getContextClassLoader()\n\t\t\t    .getResourceAsStream(\"logging.properties\");\n\t\t    if (in != null) {\n\t\t\t//读取配置\n\t\t\tLogManager.getLogManager().readConfiguration(in);\n\t\t    } else {\n\t\t\t//在classpath中没找到jdk日志配置文件logging.properties\n\t\t\tSystem.err.println(\"No such logging.properties in classpath for jdk logging config!\");\n\t\t    }\n\t\t} catch (Throwable t) {\n\t\t    System.err.println(\"Failed to load logging.properties in classpath for jdk logging config, cause: \" + t.getMessage());\n\t\t}\n\t\ttry {\n\t\t    //获取与此Logger关联的Handlers\n\t\t    Handler[] handlers =\n\t\t\t    java.util.logging.Logger.getLogger(GLOBAL_LOGGER_NAME)\n\t\t\t\t    .getHandlers();\n\t\t    for (Handler handler : handlers) {\n\t\t\tif (handler instanceof FileHandler) {\n\t\t\t    FileHandler fileHandler = (FileHandler) handler;\n\t\t\t    //通过反射找到files字段\n\t\t\t    Field field = fileHandler.getClass().getField(\"files\");\n\t\t\t    //获取fileHandler对象的field字段的值\n\t\t\t    File[] files = (File[]) field.get(fileHandler);\n\t\t\t    if (files != null && files.length > 0) {\n\t\t\t\t//设置file，即日志文件\n\t\t\t\tfile = files[0];\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t} catch (Throwable t) {\n\t\t}\n\t }\n\t\t\n\t //getLogger方法，返回一个JdkLogger对象，构造JdkLogger对象时传入了java.util.logging.Logger的Logger\n\t @Override\n\t public Logger getLogger(Class<?> key) {\n\t        //将最终使用的日志框架包装成了Dubbo的Logger对象\n\t\treturn new JdkLogger(java.util.logging.Logger.getLogger(key == null ? \"\" : key.getName()));\n\t }\n\n\t //返回日志文件\n\t @Override\n\t public File getFile() {\n\t\treturn file;\n\t }\n\n\t //获取日志级别\n\t @Override\n\t public Level getLevel() {\n\t        //这里通过fromJdkLevel方法将jdk的logger级别转换成了dubbo定义的level级别\n\t\treturn fromJdkLevel(java.util.logging.Logger.getLogger(GLOBAL_LOGGER_NAME).getLevel());\n\t }\n\n         //设置日志级别\n         @Override\n\t public void setLevel(Level level) {\n\t         //这里通过toJdkLevel方法将dubbo定义的level级别转换成了jdk的logger级别\n\t\tjava.util.logging.Logger.getLogger(GLOBAL_LOGGER_NAME).setLevel(toJdkLevel(level));\n\t }\n\n\t //fromJdkLevel和toJdkLevel方法比较简单，这里就不列出来了\n}\n```\n\n### LoggerFactory类\n该类是Logger工厂，定义了获取Logger的静态方法，需要使用日志时都是直接操作该类拿到Logger。\nLOGGERS和LOGGER_ADAPTER静态变量后面会介绍。\n```\npublic class LoggerFactory {\n\n    //缓存已创建Logger的类<类名称，该类对应的Logger>\n    private static final ConcurrentMap<String, FailsafeLogger> LOGGERS =\n            new ConcurrentHashMap<String, FailsafeLogger>();\n    \n    //当前使用的日志框架\n    private static volatile LoggerAdapter LOGGER_ADAPTER;\n}\n```\n例如在ScriptRouter类中，可以这样使用:\n```\npublic class ScriptRouter{\n\tprivate static final Logger logger = LoggerFactory.getLogger(ScriptRouter.class);\n\tpublic void error(){\n\t\tlogger.debug(\"route error , rule has been ignored\");\n\t}\n}\n```\n接下来，我们看下LoggerFactory中的getLogger方法定义：\n```java\npublic static Logger getLogger(Class<?> key) {\n        //根据name从LOGGERS缓存中获取FailsafeLogger\n        FailsafeLogger logger = LOGGERS.get(key.getName());\n        if (logger == null) {\n            //如果logger为空，则为类key创建一个FailsafeLogger，并放入缓存LOGGERS\n            LOGGERS.putIfAbsent(key.getName(), new FailsafeLogger(LOGGER_ADAPTER.getLogger(key)));\n            logger = LOGGERS.get(key.getName());\n        }\n        return logger;\n}\n```\n获取Logger时，我们是从LOGGERS变量中获取的，可见LOGGERS是用来缓存我们已创建的Logger对象的。\n而创建FailsafeLogger对象时，我们是根据key从LOGGER_ADAPTER变量中获取的Logger。\n由此可知，我们是通过LOGGER_ADAPTER变量(即LoggerAdapter接口)的getLogger(key)方法获取到了最终使用的日志框架，然后包装成了FailsafeLogger变量缓存起来。\n我们先来大概看下FailsafeLogger类的定义，然后在看下LOGGER_ADAPTER变量是在何时被赋值的。\n```java\npublic class FailsafeLogger implements Logger{\n\t\n     //包含了最终日志框架的logger\n     private Logger logger;\n\n     public FailsafeLogger(Logger logger) {\n        this.logger = logger;\n     }\n     \n     //在日志信息上附加dubbo上下文信息，如：dubbo版本、主机地址\n     private String appendContextMessage(String msg) {\n        return \" [DUBBO] \" + msg + \", dubbo version: \" + Version.getVersion() + \", current host: \" + NetUtils.getLocalHost();\n     }\n\n     @Override\n     public void info(String msg) {\n        try {\n\t    //输出附加了上下文信息的日志\n            logger.info(appendContextMessage(msg));\n        } catch (Throwable t) {\n        }\n     }\n\n     @Override\n     public boolean isInfoEnabled() {\n        try {\n            return logger.isInfoEnabled();\n        } catch (Throwable t) {\n            return false;\n        }\n     }\n     \n     //省略其他类似方法\n     ...\n}\n```\n我们在来看下LOGGER_ADAPTER变量是如何被赋值的，实际上，在LoggerFactory类初始化时，便会试着设置当前使用的日志框架：\n```java\nstatic {\n        //从JVM系统属性中获取配置的日志框架，即通过：java -Ddubbo.application.logger=slf4j配置\n        String logger = System.getProperty(\"dubbo.application.logger\");\n        if (\"slf4j\".equals(logger)) {\n            //如果是slf4j，则设置当前使用的日志框架为Slf4jLoggerAdapter\n            setLoggerAdapter(new Slf4jLoggerAdapter());\n        } else if (\"jcl\".equals(logger)) {\n            setLoggerAdapter(new JclLoggerAdapter());\n        } else if (\"log4j\".equals(logger)) {\n            setLoggerAdapter(new Log4jLoggerAdapter());\n        } else if (\"jdk\".equals(logger)) {\n            setLoggerAdapter(new JdkLoggerAdapter());\n        } else {\n            //如果没有匹配到，则挨个尝试可用的日志框架\n            try {\n                setLoggerAdapter(new Log4jLoggerAdapter());\n            } catch (Throwable e1) {\n                try {\n                    setLoggerAdapter(new Slf4jLoggerAdapter());\n                } catch (Throwable e2) {\n                    try {\n                        setLoggerAdapter(new JclLoggerAdapter());\n                    } catch (Throwable e3) {\n                        setLoggerAdapter(new JdkLoggerAdapter());\n                    }\n                }\n            }\n        }\n}\n\n//设置并修改当前使用的LoggerAdapter\npublic static void setLoggerAdapter(LoggerAdapter loggerAdapter) {\n        if (loggerAdapter != null) {\n            //首先获取LoggerFactory类的Logger\n            Logger logger = loggerAdapter.getLogger(LoggerFactory.class.getName());\n            //然后输出即将使用的logger：loggerAdapter\n            logger.info(\"using logger: \" + loggerAdapter.getClass().getName());\n            //设置LOGGER_ADAPTER变量为loggerAdapter\n            LoggerFactory.LOGGER_ADAPTER = loggerAdapter;\n            //遍历已创建logger的类列表，然后修改logger为新设置的loggerAdapter\n            for (Map.Entry<String, FailsafeLogger> entry : LOGGERS.entrySet()) {\n                //设置FailsafeLogger的logger为loggerAdapter创建的logger\n                entry.getValue().setLogger(LOGGER_ADAPTER.getLogger(entry.getKey()));\n            }\n        }\n}\n\n//获取当前日志级别\npublic static Level getLevel() {\n       //返回LOGGER_ADAPTER的日志级别\n       return LOGGER_ADAPTER.getLevel();\n}\n\n//设置当前日志级别\npublic static void setLevel(Level level) {\n       LOGGER_ADAPTER.setLevel(level);\n}\n\n//获取当前日志文件\npublic static File getFile() {\n        return LOGGER_ADAPTER.getFile();\n}\n```\n\n到此，我们就介绍完Dubbo-Logger相关的内容了，Dubbo作为常用的中间件，集成了可选的日志框架，是非常值得我们学习，最后，给一个类图加深下理解。\n\n![](img/log.png)\n\n\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之SPI扩展机制","url":"/blog/2018/07/31/Dubbo源码阅读之SPI扩展机制/","content":">本文主要分析Dubbo的SPI扩展机制。\n\n* [Java的SPI机制](https://docs.oracle.com/javase/1.5.0/docs/guide/jar/jar.html#Service%20Provider)\n* Dubbo的SPI机制\n\n### Java的SPI机制\nSPI全称为(Service Provider Interface)，是JDK内置的一种服务提供发现机制。通过SPI服务加载机制进行服务的注册和发现，可以实现基于接口的编程，避免在Java代码中写死服务的提供者，实现多个模块的解耦。\n根据Java的SPI规范，我们可以定义一个服务接口，具体的实现由对应的实现者（Service Provider服务提供者）提供，然后在使用的时候只要根据SPI的规范去获取对应的服务提供者的服务实现即可。我们看一个简单的例子：\n```java\npackage java.spi;\npublic interface Developer {\n    public String getPrograme();\n}\n\npackage java.spi;\npublic class JavaDeveloper implements Developer {\n    @Override\n    public String getPrograme() {\n        return \"Java\";\n    }\n}\n\npackage java.spi;\npublic class PerlDeveloper implements Developer {\n    @Override\n    public String getPrograme() {\n        return \"Perl\";\n    }\n}\n```\n然后在META-INF\\services目录下创建名为java.spi.Developer的文件，文件内容是接口实现类的全限定名：\n```java\njava.spi.JavaDeveloper\njava.spi.PerlDeveloper\n```\n将文件导出为jar包，新建一个项目，在项目中导入该jar,然后新建一个测试类：\n```java\nimport java.util.ServiceLoader;\nimport cn.edu.knowledge.spi.Developer;\npublic class Test {\n    public static void main(String[] arg) {\n         ServiceLoader<Developer> serviceLoader = ServiceLoader.load(Developer.class);\n\t for (Developer developer : Developer) {\n\t        //将会输出: I use Java; I use Perl;\n\t\tSystem.out.println(\"I use \"+developer.getPrograme());\n\t }\n    }\n}\n```\n\n### Dubbo的SPI机制\nDubbo的扩展点加载是对JDK内置的SPI机制的一种加强。继续使用上面的例子介绍，\nMETA-INF\\services\\java.spi.Developer文件中的内容将会变为key=value形式：\n```java\njava=java.spi.JavaDeveloper\nperl=java.spi.PerlDeveloper\n```\n其中，key为扩展名称，value为扩展实例。扩展配置文件修改为这样子是因为，如果扩展实现中的方法或者静态字段引用了第三方库，而第三方库不存在时，那么这个类将会初始化失败，在这种情况下，如果使用以前的格式，Dubbo不可以弄清楚扩展的id，因此不可以映射这个扩展的异常信息。\n例如：\n无法加载扩展(\"mina\"),当用户配置使用mina，Dubbo将会抱怨无法加载扩展，而不是报告提取哪一个扩展实现失败及原因。\n\n与Java标准SPI相比，Dubbo SPI又增加了如下功能：\n* Dubbo可以通过getExtension（String key）只加载某一个想要的扩展，Java的SPI机制则需要加载全部的实现类。\n* 对于扩展实现IOC依赖注入功能，如果扩展实现A含有setB()方法，而接口B有B1和B2两个具体的实现，此时Dubbo并不会具体注入B1或者B2，而是会注入一个自动生成的接口B实现：B$Adpative，该实现者能够根据参数的不同，自动引用B1或者B2来完成相应的功能。\n* 对扩展采用装饰器模式进行功能增强。\n\n### Dubbo SPI相关接口\n#### SPI接口\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE})\npublic @interface SPI {\n    //默认扩展名称\n    String value() default \"\";\n}\n```\n当接口上表明了@SPI注解时，Dubbo将会依次从如下目录中读取相应的扩展点：\nMETA-INF/dubbo/internal/\nMETA-INF/dubbo/\nMETA-INF/services/\n\n#### Adaptive接口\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD})\npublic @interface Adaptive {\n    String[] value() default {};\n}\n```\nExtensionLoader注入依赖扩展实例时，该接口为其提供了有用的信息。\nvalue方法决定要注入哪个目标扩展。目标扩展由URL中传递的参数决定，value方法提供了url上的参数名称。如果在URL中没有找到指定的参数名称，则将使用默认的扩展（在其接口上的@SPI注解中进行指定）。\n例如,给定字符串：value={\"key1\", \"key2\"}，如果在URL中发现参数key1，则使用参数key1的值作为扩展名称，如果在URL中没有发现参数key1或者参数key1的值为空，则尝试使用参数key2的值作为扩展名称，如果key2也不存在，则使用默认的扩展，否则抛异常。\n如果默认的扩展名称在@SPI注解中没有提供，则使用规则生成一个name，这个name将用作URL中的搜索参数。规则为：将接口类名从大写字符开始分成几个部分, 并将各部分用点 \".\" 分开。\n例如：com.alibaba.dubbo.xxx.YyyInvokerWrapper，则生成的name为yyy.invoker.wrapper，将会使用该name从url中进行搜索。\n\n#### Activate接口\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD})\npublic @interface Activate {\n    /**\n     * 当group数组中有一个group匹配时，就激活当前扩展。\n     * 将使用传递给ExtensionLoader#getActivateExtension(URL, String, String)方法的group(第三个参数)来和该注解的group进行匹配\n     */\n    String[] group() default {};\n\n    /**\n     * 当指定的key出现在URL的参数中时，则激活当前扩展 \n     * 例如：给定@Activate(\"cache, validation\")时，只有url中出现cache或者validation参数时，才会激活当前扩展\n     */\n    String[] value() default {};\n    \n    //相对顺序 扩展列表中的哪些扩展将要放到当前扩展前面\n    String[] before() default {};\n\n    //相对顺序 扩展列表中的哪些扩展将要放到当前扩展后面\n    String[] after() default {};\n    \n    //绝对顺序\n    int order() default 0;\n}\n```\n用于激活扩展。此注解对于使用给定条件自动激活某些扩展是非常有用的，比如：如果有多个Filter实现，@Activate可以用来加载某些Filter。\nSPI提供者可以调用ExtensionLoader#getActivateExtension(URL, String, String)方法找到所有符合条件的activated扩展。\n\n#### ExtensionFactory接口\n```\n@SPI\npublic interface ExtensionFactory {\n    /**\n     * 获取扩展实现类实例\n     * Get extension.\n     * @param type object type. 扩展接口类型\n     * @param name object name. 扩展名称\n     * @return object instance. 返回扩展实例\n     */\n    <T> T getExtension(Class<T> type, String name);\n}\n```\n该接口根据扩展类型和扩展名称获取扩展实例。可以看到该接口声明上也加上了@SPI注解，说明存在多种实现，Dubbo提供了三种实现，分别为AdaptiveExtensionFactory、SpiExtensionFactory、SpringExtensionFactory，后面会详细介绍具体实现。\n\n\n### ExtensionLoader类\nExtensionLoader类用来处理Dubbo扩展,里面定义了大量的实用方法，该类支持以下主要功能：\n\n* 自动注入依赖扩展\n* 在wrapper中，自动包装扩展\n* 默认扩展是一个adaptive实例\n\nExtensionLoader类代码量比较多，我们先来看下ExtensionLoader类的getExtensionLoader方法，通过该方法可以得到指定扩展类型接口的扩展加载器，\n例如我们想要得到ProxyFactory类型的ExtensionLoader，可以这样做：\n```java\nExtensionLoader<ProxyFactory> loader = ExtensionLoader.getExtensionLoader(ProxyFactory.class);\n```\n#### getExtensionLoader方法\n我们来看getExtensionLoader方法:\n```java\n/**\n * 获取扩展类型接口的扩展加载器\n * 1、校验扩展类型\n * 2、从缓存中获取扩展类型对应的扩展加载器\n * 3、缓存中不存在，则新建一个并放入缓存\n */\npublic static <T> ExtensionLoader<T> getExtensionLoader(Class<T> type) {\n        //扩展类型不可以为空\n        if (type == null) {\n            throw new IllegalArgumentException(\"Extension type == null\");\n        }\n\t//扩展类型必须为接口\n        if (!type.isInterface()) {\n            throw new IllegalArgumentException(\"Extension type(\" + type + \") is not interface!\");\n        }\n\t//检测扩展类型接口是否是一个扩展点，判断依据是：接口必须有@SPI注解\n        if (!withExtensionAnnotation(type)) {\n            throw new IllegalArgumentException(\"Extension type(\" + type +\n                    \") is not extension, because WITHOUT @\" + SPI.class.getSimpleName() + \" Annotation!\");\n        }\n        //首先从缓存中获取该扩展类型的ExtensionLoader\n        ExtensionLoader<T> loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);\n        if (loader == null) {\n            //缓存中不存在，则为扩展类型type新建一个ExtensionLoader，并放入缓存\n            EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader<T>(type));\n            loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);\n        }\n\t//返回扩展类型的ExtensionLoader\n        return loader;\n}\n\n/**\n * 私有构造方法\n */\nprivate ExtensionLoader(Class<?> type) {\n        //保存扩展类型接口\n        this.type = type;\n        //ExtensionFactory接口的扩展实现类不需要进行注入依赖，因此这里将objectFactory设置成null\n\t//其他扩展接口可能依赖其他扩展接口，因此需要进行依赖注入，通过objectFactory可以获取到某个扩展类型的扩展实例\n        objectFactory = (type == ExtensionFactory.class ? null :\n                    ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()\n        );\n}\n```\n其中type和objectFactory是ExtensionLoader类中定义的实例变量,EXTENSION_LOADERS缓存是静态常量：\n```java\n/**\n * 扩展接口的类型\n */\nprivate final Class<?> type;\n\n/**\n * 扩展工厂，通过扩展工厂可以获取到某个扩展类型的扩展实例\n */\nprivate final ExtensionFactory objectFactory;\n\n/**\n * 每个扩展类型接口(即带有@SPI注解的接口)，都有一个相对应的ExtensionLoader实例\n * <扩展类型接口，ExtensionLoader实例>\n */\nprivate static final ConcurrentMap<Class<?>, ExtensionLoader<?>> EXTENSION_LOADERS =\n\t\tnew ConcurrentHashMap<Class<?>, ExtensionLoader<?>>();\n```\n#### getExtension方法\n有了ExtensionLoader实例后，就可以通过该实例的getExtension(String name)方法加载扩展类型的指定实例：\n```java\n/**\n * 通过扩展名称name获取扩展实例\n */\npublic T getExtension(String name) {\n\t//扩展名称不可以为空\n        if (name == null || name.length() == 0) {\n            throw new IllegalArgumentException(\"Extension name == null\");\n        }\n        if (\"true\".equals(name)) {\n            //name = true 返回默认扩展实例（后面会分析该方法）\n            return getDefaultExtension();\n        }\n\t//根据扩展名称从cachedInstances实例变量中获取扩展实例\n\t//扩展实例被放入到Holder对象中，Holder类是一个持有值的助手类，提供了get/set方法\n        Holder<Object> holder = cachedInstances.get(name);\n        if (holder == null) {\n            //缓存中不存在的话，则为扩展名称name新建一个Holder实例。\n            cachedInstances.putIfAbsent(name, new Holder<Object>());\n            holder = cachedInstances.get(name);\n        }\n\t//从holder对象中获取到扩展名称name对应的扩展实例\n        Object instance = holder.get();\n        if (instance == null) {\n\t    //扩展实例为空，则为扩展名称name新建一个扩展实例并放入Holder对象中。\n\t    //这里可能会存在多个线程同时访问，因此需要同步创建扩展实例\n            synchronized (holder) {\n\t        //再次判断holder对象中的扩展实例是否为空\n                instance = holder.get();\n                if (instance == null) {\n                    //根据扩展名称name创建扩展实例（后面会分析该方法）\n                    instance = createExtension(name);\n\t\t    //放入缓存\n                    holder.set(instance);\n                }\n            }\n        }\n\t//返回扩展实例\n        return (T) instance;\n}\n```\n在看getDefaultExtension方法和createExtension方法之前，我们先看下上面getExtension方法中出现的变量定义：\n```java\n/**\n * 缓存 <扩展名称，扩展实例>\n */\nprivate final ConcurrentMap<String, Holder<Object>> cachedInstances =\n    new ConcurrentHashMap<String, Holder<Object>>();\n\n/**\n * 持有一个值的助手类\n */\npublic class Holder<T> {\n\n    private volatile T value;\n\n    public void set(T value) {\n        this.value = value;\n    }\n    public T get() {\n        return value;\n    }\n}\n```\n#### getDefaultExtension方法\n接下来我们来看getDefaultExtension方法，该方法用来获取默认扩展实例。在该方法内部又调用了多个方法，我们一步步来分析，分析完整个流程后，我们在看createExtension方法.\n```java\n/**\n * 返回默认扩展实例，如果没有配置默认扩展名称(@SPI注解上配置的)，则返回null\n */\npublic T getDefaultExtension() {\n        //获取扩展接口type对应的扩展实现类集合(后面会分析该方法)\n\tgetExtensionClasses();\n\t//判断cachedDefaultName变量是否为空\n\t//cachedDefaultName变量是在getExtensionClasses()方法中进行赋值的，我们稍后去看\n\tif (null == cachedDefaultName || cachedDefaultName.length() == 0 || \"true\".equals(cachedDefaultName)) {\n\t\treturn null;\n\t}\n\t//获取默认扩展名称对应的扩展实例\n\treturn getExtension(cachedDefaultName);\n}\n```\n#### getExtensionClasses方法(加载扩展实现类)\n```java\n/**\n * 获取扩展接口type对应的扩展实现类集合，先从缓存获取，缓存没有的话，再去重新加载\n * @return\n */\nprivate Map<String, Class<?>> getExtensionClasses() {\n\t//先从cachedClasses缓存中获取\n\tMap<String, Class<?>> classes = cachedClasses.get();\n\tif (classes == null) {\n\t\t//缓存中为空，同步加载\n\t\tsynchronized (cachedClasses) {\n\t\t\t//再次判断\n\t\t\tclasses = cachedClasses.get();\n\t\t\tif (classes == null) {\n\t\t\t\t//重新加载扩展实现类（后面会分析该方法）\n\t\t\t\tclasses = loadExtensionClasses();\n\t\t\t\t//放入缓存\n\t\t\t\tcachedClasses.set(classes);\n\t\t\t}\n\t\t}\n\t}\n\treturn classes;\n}\n\n/**\n * 默认扩展名称,@SPI注解上配置的值\n */\nprivate String cachedDefaultName;\n\n/**\n * 用来缓存扩展接口type对应的所有扩展实现类\n * <扩展名称，扩展实现类>\n */\nprivate final Holder<Map<String, Class<?>>> cachedClasses = new Holder<Map<String, Class<?>>>();\n\n\n/**\n * 加载扩展接口type对应的所有扩展实现类\n * 在getExtensionClasses中会进行同步\n * synchronized in getExtensionClasses\n * @return\n */\nprivate Map<String, Class<?>> loadExtensionClasses() {\n\t//获取扩展接口type上的@SPI注解\n\tfinal SPI defaultAnnotation = type.getAnnotation(SPI.class);\n\tif (defaultAnnotation != null) {\n\t\t//存在@SPI注解，则获取注解值(即默认扩展名称)\n\t\tString value = defaultAnnotation.value();\n\t\tif ((value = value.trim()).length() > 0) {\n\t\t\t//使用逗号分隔扩展名称\n\t\t\tString[] names = NAME_SEPARATOR.split(value);\n\t\t\tif (names.length > 1) {\n\t\t\t    //存在多个默认扩展名称，则抛异常\n\t\t\t    throw new IllegalStateException(\"more than 1 default extension name on extension \" + type.getName()\n\t\t\t\t    + \": \" + Arrays.toString(names));\n\t\t\t}\n\t\t\tif (names.length == 1) {\n\t\t\t    //保存默认扩展名称到cachedDefaultName\n\t\t\t    cachedDefaultName = names[0];\n\t\t\t}\n\t\t}\n\t}\n\t//开始加载扩展类，依次从3个目录进行加载,保存到extensionClasses中\n\tMap<String, Class<?>> extensionClasses = new HashMap<String, Class<?>>();\n\t//目录看下面的常量定义(后面会分析该方法)\n\tloadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY);\n\tloadDirectory(extensionClasses, DUBBO_DIRECTORY);\n\tloadDirectory(extensionClasses, SERVICES_DIRECTORY);\n\treturn extensionClasses;\n}\n\n/**\n * 扩展所在目录\n */\nprivate static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n\nprivate static final String DUBBO_DIRECTORY = \"META-INF/dubbo/\";\n\nprivate static final String DUBBO_INTERNAL_DIRECTORY = DUBBO_DIRECTORY + \"internal/\";\n\n/**\n * 获取ExtensionLoader的类加载器\n * @return\n */\nprivate static ClassLoader findClassLoader() {\n\treturn ExtensionLoader.class.getClassLoader();\n}\n\n/**\n * 扫描相应目录，加载扩展并保存到extensionClasses集合\n * @param extensionClasses 保存扩展类的Map集合\n * @param dir  扫描目录\n */\nprivate void loadDirectory(Map<String, Class<?>> extensionClasses, String dir) {\n\t//待加载的文件名，如：fileName = META-INF/dubbo/internal/com.alibaba.dubbo.rpc.ProxyFactory\n\tString fileName = dir + type.getName();\n\ttry {\n\t    Enumeration<java.net.URL> urls;\n\t    //获取ExtensionLoader类加载器(后面会分析该方法)\n\t    ClassLoader classLoader = findClassLoader();\n\t    if (classLoader != null) {\n\t\t//当前类加载器不为空，加载该文件\n\t\turls = classLoader.getResources(fileName);\n\t    } else {\n\t\t//当前类加载器为空，则从用来加载类的搜索路径中查找改文件\n\t\turls = ClassLoader.getSystemResources(fileName);\n\t    }\n\t    if (urls != null) {\n\t\twhile (urls.hasMoreElements()) {\n\t\t    //获取到资源定位符\n\t\t    java.net.URL resourceURL = urls.nextElement();\n\t\t    //加载资源,即读取并解析配置文件，然后加载类(后面会分析该方法)\n\t\t    loadResource(extensionClasses, classLoader, resourceURL);\n\t\t}\n\t    }\n\t} catch (Throwable t) {\n\t    logger.error(\"Exception when load extension class(interface: \" +\n\t\t    type + \", description file: \" + fileName + \").\", t);\n\t}\n}\n\n/**\n * 解析配置文件，然后加载扩展类\n * @param extensionClasses 保存扩展类的集合\n * @param classLoader  类加载器\n * @param resourceURL  资源定位符\n */\nprivate void loadResource(Map<String, Class<?>> extensionClasses, ClassLoader classLoader, java.net.URL resourceURL) {\n\ttry {\n\t    BufferedReader reader = new BufferedReader(new InputStreamReader(resourceURL.openStream(), \"utf-8\"));\n\t    try {\n\t\tString line;\n\t\t//读取配置文件每一行\n\t\twhile ((line = reader.readLine()) != null) {\n\t\t    //判断当前行是否包含#号，#号后面的内容都是注释，需要去掉\n\t\t    final int ci = line.indexOf('#');\n\t\t    if (ci >= 0) {\n\t\t\t//截取#号之前的内容，并重新设置line\n\t\t\tline = line.substring(0, ci);\n\t\t    }\n\t\t    line = line.trim();\n\t\t    if (line.length() > 0) {\n\t\t\ttry {\n\t\t\t    String name = null;\n\t\t\t    //当前行是否包含=号\n\t\t\t    int i = line.indexOf('=');\n\t\t\t    if (i > 0) {\n\t\t\t\t//当前行存在=号，则使用=号分隔line，获取到key-value(line)\n\t\t\t\t//name就是key，即定义的扩展名称\n\t\t\t\t//line就是value，即定义的扩展实现类全限定名\n\t\t\t\tname = line.substring(0, i).trim();\n\t\t\t\tline = line.substring(i + 1).trim();\n\t\t\t    }\n\t\t\t    //如果line不等于空，则需要加载该扩展实现类\n\t\t\t    if (line.length() > 0) {\n\t\t\t\t//加载扩展实现类(后面会分析该方法)\n\t\t\t\tloadClass(\n\t\t\t\t\textensionClasses,\n\t\t\t\t\tresourceURL,\n\t\t\t\t\t//加载扩展实现类\n\t\t\t\t\tClass.forName(line, true, classLoader),\n\t\t\t\t\tname\n\t\t\t\t);\n\t\t\t    }\n\t\t\t} catch (Throwable t) {\n\t\t\t    IllegalStateException e = new IllegalStateException(\"Failed to load extension class(interface: \" + type + \", class line: \" + line + \") in \" + resourceURL + \", cause: \" + t.getMessage(), t);\n\t\t\t    //解析行出错，记录错误行到exceptions实例变量中\n\t\t\t    exceptions.put(line, e);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    } finally {\n\t\treader.close();\n\t    }\n\t} catch (Throwable t) {\n\t    logger.error(\"Exception when load extension class(interface: \" +\n\t\t    type + \", class file: \" + resourceURL + \") in \" + resourceURL, t);\n\t}\n}\n\n/**\n * 保存解析配置文件发生的异常信息\n * <当前key-value行，异常信息>\n */\nprivate Map<String, IllegalStateException> exceptions = new ConcurrentHashMap<String, IllegalStateException>();\n\n/**\n * 当前扩展类型接口type对应的扩展自适应类\n * 即存在@Adaptive注解的扩展实现类\n * 每个扩展类型接口type只能有一个实现类有@Adaptive注解，如果多个扩展实现类都有@Adaptive，则会抛异常\n */\nprivate volatile Class<?> cachedAdaptiveClass = null;\n\n/**\n * 如果扩展实现类是一个包装类，\n * 则会将该该实现类添加到cachedWrapperClasses集合中\n */\nprivate Set<Class<?>> cachedWrapperClasses;\n\n/**\n * 扩展名称正则表达式，将会使用该正则表达式切割扩展名称name，即使用逗号分隔\n */\nprivate static final Pattern NAME_SEPARATOR = Pattern.compile(\"\\\\s*[,]+\\\\s*\");\n\n/**\n * 缓存<扩展名称，Activate注解>\n * 如果是逗号分隔的多个name，则取第1个扩展名称name\n * Activate为当前扩展实现类上的@Activate注解\n */\nprivate final Map<String, Activate> cachedActivates = new ConcurrentHashMap<String, Activate>();\n\n/**\n * 缓存<扩展实现类，扩展名称>\n */\nprivate final ConcurrentMap<Class<?>, String> cachedNames = new ConcurrentHashMap<Class<?>, String>();\n\n\n/**\n * 加载扩展实现类\n * @param extensionClasses 保存扩展实现类的map\n * @param resourceURL 资源文件定位符\n * @param clazz 扩展实现类，即实现了type接口的类\n * @param name  扩展名称，即配置文件中的key\n * @throws NoSuchMethodException\n */\nprivate void loadClass(Map<String, Class<?>> extensionClasses,\n\t\t   java.net.URL resourceURL,\n\t\t   Class<?> clazz,\n\t\t   String name) throws NoSuchMethodException {\n\t//检测实现类clazz是否是type的子类型，即clazz是否实现了接口type\n\tif (!type.isAssignableFrom(clazz)) {\n\t    throw new IllegalStateException(\"Error when load extension class(interface: \" +\n\t\t    type + \", class line: \" + clazz.getName() + \"), class \"\n\t\t    + clazz.getName() + \"is not subtype of interface.\");\n\t}\n\t//检测实现类clazz是否有@Adaptive注解\n\tif (clazz.isAnnotationPresent(Adaptive.class)) {\n\t    if (cachedAdaptiveClass == null) {\n\t        //cachedAdaptiveClass变量为空，则将cachedAdaptiveClass赋值为clazz\n\t\tcachedAdaptiveClass = clazz;\n\t    } else if (!cachedAdaptiveClass.equals(clazz)) {\n\t        //cachedAdaptiveClass变量不为空，则判断cachedAdaptiveClass是否和当前实现类class是否是同一个\n\t\t//如果不是同一个，则抛异常：每个扩展类型type不可以存在多个自适应扩展类\n\t\tthrow new IllegalStateException(\"More than 1 adaptive class found: \"\n\t\t\t+ cachedAdaptiveClass.getClass().getName()\n\t\t\t+ \", \" + clazz.getClass().getName());\n\t    }\n\t} else if (isWrapperClass(clazz)) {\n\t    //实现类clazz是包装类(后面会分析该方法)\n\t    Set<Class<?>> wrappers = cachedWrapperClasses;\n\t    if (wrappers == null) {\n\t\tcachedWrapperClasses = new ConcurrentHashSet<Class<?>>();\n\t\twrappers = cachedWrapperClasses;\n\t    }\n\t    //将该扩展实现类添加到包装类集合中\n\t    wrappers.add(clazz);\n\t} else {\n\t    //检测该实现类是否有默认构造方法\n\t    clazz.getConstructor();\n\t    if (name == null || name.length() == 0) {\n\t\t//扩展名称name为空时，则根据规则重新设置name(后面会分析该方法)\n\t\tname = findAnnotationName(clazz);\n\t\tif (name == null || name.length() == 0) {\n\t\t    //name仍然为空\n\t\t    if (clazz.getSimpleName().length() > type.getSimpleName().length()\n\t\t\t    && clazz.getSimpleName().endsWith(type.getSimpleName())) {\n\t\t\t//如果当前扩展实现类的类名以扩展接口type的名称结尾，则截取接口类名称之前的部分作为name，并转换成小写\n\t\t\t//例如：当clazz = JavassistProxyFactory，type = ProxyFactory时，则name = javassist\n\t\t\tname = clazz.getSimpleName().substring(0, clazz.getSimpleName().length() - type.getSimpleName().length()).toLowerCase();\n\t\t    } else {\n\t\t\t//扩展实现类class没有对应的扩展名称，抛异常\n\t\t\tthrow new IllegalStateException(\"No such extension name for the class \" + clazz.getName() + \" in the config \" + resourceURL);\n\t\t    }\n\t\t}\n\t    }\n\t    //使用逗号分隔扩展名称name\n\t    String[] names = NAME_SEPARATOR.split(name);\n\t    if (names != null && names.length > 0) {\n\t        //获取扩展实现类上的@Activate注解\n\t\tActivate activate = clazz.getAnnotation(Activate.class);\n\t\tif (activate != null) {\n\t\t    //存在@Activate注解\n\t\t    //则将第1个扩展名称和@Activate注解缓存起来\n\t\t    cachedActivates.put(names[0], activate);\n\t\t}\n\t\t//遍历扩展名称\n\t\tfor (String n : names) {\n\t\t    if (!cachedNames.containsKey(clazz)) {\n\t\t\t//如果<扩展实现类,name>缓存中不包含该扩展实现类,则保存到缓存\n\t\t\tcachedNames.put(clazz, n);\n\t\t    }\n\t\t    //通过扩展名称n从扩展实现类集合中获取扩展实现类c\n\t\t    Class<?> c = extensionClasses.get(n);\n\t\t    if (c == null) {\n\t\t\t//扩展实现类c不存在，则保存<扩展名称n，扩展实现类clazz>到缓存\n\t\t\textensionClasses.put(n, clazz);\n\t\t    } else if (c != clazz) {\n\t\t\t//一个扩展名称对应多个扩展实现类，则抛异常\n\t\t\tthrow new IllegalStateException(\"Duplicate extension \" + type.getName() + \" name \" + n + \" on \" + c.getName() + \" and \" + clazz.getName());\n\t\t    }\n\t\t}\n\t    }\n\t}\n}\n\n/**\n * 检测扩展实例类clazz是否是包装类。\n * 判断依据是：扩展实现类clazz中有一个接收扩展接口(type接口)作为参数的构造方法\n * @param clazz 扩展实现类\n * @return\n */\nprivate boolean isWrapperClass(Class<?> clazz) {\n\ttry {\n\t    clazz.getConstructor(type);\n\t    return true;\n\t} catch (NoSuchMethodException e) {\n\t    return false;\n\t}\n}\n```\n加载扩展类型接口type对应的扩展实现类流程到此就全部结束了(即上文中介绍的getExtensionClasses()方法流程)。\n\n#### createExtension方法(创建扩展实现类实例)\n我们回到上文中遗留的createExtension(name)方法，看看是如何根据扩展名称name创建扩展实现类实例的。\n```java\n/**\n * 根据扩展名称name创建扩展实现类实例\n * @param name 扩展名称\n * @return 扩展实现类实例\n */\n@SuppressWarnings(\"unchecked\")\nprivate T createExtension(String name) {\n\t//根据扩展名称name获取扩展实现类clazz\n\t//getExtensionClasses()方法我们上文已经介绍过了，拿到扩展类型接口type对应的所有扩展实现类\n\tClass<?> clazz = getExtensionClasses().get(name);\n\tif (clazz == null) {\n\t    //根据扩展名称没有获取到扩展实现类，则抛出异常\n\t    throw findException(name);\n\t}\n\ttry {\n\t    //先从缓存中获取扩展实现类的实例\n\t    T instance = (T) EXTENSION_INSTANCES.get(clazz);\n\t    if (instance == null) {\n\t        //如果没有获取到实例，则新建一个实现类clazz的实例并放入缓存。\n\t\tEXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());\n\t\tinstance = (T) EXTENSION_INSTANCES.get(clazz);\n\t    }\n\t    //处理实现类实例的依赖注入(后面会分析该方法)\n\t    injectExtension(instance);\n\t    //处理包装类\n\t    Set<Class<?>> wrapperClasses = cachedWrapperClasses;\n\t    if (wrapperClasses != null && !wrapperClasses.isEmpty()) {\n\t        //当前扩展接口type存在包装类扩展实现类\n\t\t//遍历包装类列表\n\t\tfor (Class<?> wrapperClass : wrapperClasses) {\n\t\t    //通过参数为type接口的构造方法创建包装类实例(将当前实例instance传递进去)，然后处理包装类的依赖注入\n\t\t    //这里可能会有多个包装类，依次进行包装\n\t\t    instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));\n\t\t}\n\t    }\n\t    //返回扩展实例\n\t    return instance;\n\t} catch (Throwable t) {\n\t    throw new IllegalStateException(\"Extension instance(name: \" + name + \", class: \" +\n\t\t    type + \")  could not be instantiated: \" + t.getMessage(), t);\n\t}\n}\n\n/**\n * 处理扩展实现类实例instance的依赖项，进行依赖注入\n * 通过set方法注入依赖项\n * @param instance 扩展实现类的实例\n * @return\n */\nprivate T injectExtension(T instance) {\n\ttry {\n\t    //判断加载器是否为空\n\t    if (objectFactory != null) {\n\t        //遍历实现类中的方法\n\t\tfor (Method method : instance.getClass().getMethods()) {\n\t\t    //找到参数长度为1、public修饰符的set方法\n\t\t    if (method.getName().startsWith(\"set\")\n\t\t\t    && method.getParameterTypes().length == 1\n\t\t\t    && Modifier.isPublic(method.getModifiers())) {\n\t\t\t//获取set方法的参数类型\n\t\t\tClass<?> pt = method.getParameterTypes()[0];\n\t\t\ttry {\n\t\t\t    //截取set方法的方法名，去掉\"set\"字符，并将余下的字符转换成小写字母，作为属性\n\t\t\t    String property = method.getName().length() > 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : \"\";\n\t\t\t    //从扩展工厂中找到该依赖项实例(pt为依赖项的类型，property为依赖项的名称)\n\t\t\t    Object object = objectFactory.getExtension(pt, property);\n\t\t\t    if (object != null) {\n\t\t\t\t//依赖项实例存在的话，通过该set方法则将该依赖项实例注入到扩展实现类实例instance中\n\t\t\t\tmethod.invoke(instance, object);\n\t\t\t    }\n\t\t\t} catch (Exception e) {\n\t\t\t    logger.error(\"fail to inject via method \" + method.getName()\n\t\t\t\t    + \" of interface \" + type.getName() + \": \" + e.getMessage(), e);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t} catch (Exception e) {\n\t    logger.error(e.getMessage(), e);\n\t}\n\t//返回扩展实现类的实例\n\treturn instance;\n}\n```\n以上便是获取扩展实例的过程，最终会将扩展实例放入到缓存变量cachedInstances中,即<扩展名称，扩展实例>。\n\n#### getActivateExtension方法\n接下来我们在看下ExtensionLoader类中的getActivateExtension方法，通过该方法可以得到已启用的扩展列表\n```java\n/**\n * key为url中标识扩展名称的参数\n */\npublic List<T> getActivateExtension(URL url, String key) {\n\t//调用了下面的重载方法\n\treturn getActivateExtension(url, key, null);\n}\n\npublic List<T> getActivateExtension(URL url, String key, String group) {\n\t//从url中获取参数key对应的值(即获取扩展名称)\n\tString value = url.getParameter(key);\n\t//调用了下面的重载方法\n\treturn getActivateExtension(\n\t\turl, \n\t\tvalue == null || value.length() == 0 ? null : Constants.COMMA_SPLIT_PATTERN.split(value), \n\t\tgroup\n\t);\n}\n\n/**\n * 获取已启用的扩展列表\n * url \n * values为扩展名称列表\n * group为配置的组\n */\npublic List<T> getActivateExtension(URL url, String[] values, String group) {\n\tList<T> exts = new ArrayList<T>();\n\t//扩展名称数组\n\tList<String> names = values == null ? new ArrayList<String>(0) : Arrays.asList(values);\n\t//names是否包含-default\n\tif (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) {\n\t    //先获取下扩展接口type的扩展实现类集合(上文介绍过该方法)\n\t    //执行getExtensionClasses方法时，会将存在@Activate注解的实现类缓存起来：<扩展名称，Activate注解>\n\t    getExtensionClasses();\n\t    //遍历cachedActivates集合\n\t    for (Map.Entry<String, Activate> entry : cachedActivates.entrySet()) {\n\t\t//扩展名称\n\t\tString name = entry.getKey();\n\t\t//@Activate注解\n\t\tActivate activate = entry.getValue();\n\t\t//group是否匹配(后面会分析该方法)\n\t\tif (isMatchGroup(group, activate.group())) {\n\t\t    //根据扩展名称name获取扩展实例\n\t\t    T ext = getExtension(name);\n\t\t    if (!names.contains(name)\n\t\t\t    && !names.contains(Constants.REMOVE_VALUE_PREFIX + name)\n\t\t\t    && isActive(activate, url)) {\n\t\t\t//当扩展名称数组不包含该扩展名name，并且不包含-name，并且已激活时，\n\t\t\t//将当前扩展实例添加到返回结果集中\n\t\t\texts.add(ext);\n\t\t    }\n\t\t}\n\t    }\n\t    //按照配置的before()和after()/order()进行排序\n\t    Collections.sort(exts, ActivateComparator.COMPARATOR);\n\t}\n\tList<T> usrs = new ArrayList<T>();\n\tfor (int i = 0; i < names.size(); i++) {\n\t    //当前扩展名称name\n\t    String name = names.get(i);\n\t    if (!name.startsWith(Constants.REMOVE_VALUE_PREFIX)\n\t\t    //当前扩展名称name不是以-开头，并且扩展名称数组names不包含-name时，\n\t\t    && !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) {\n\t\tif (Constants.DEFAULT_KEY.equals(name)) {\n\t\t    //当前扩展名称name=default\n\t\t    if (!usrs.isEmpty()) {\n\t\t        //usrs不为空，将usrs集合添加到exts头部\n\t\t\texts.addAll(0, usrs);\n\t\t\t//清空usrs\n\t\t\tusrs.clear();\n\t\t    }\n\t\t} else {\n\t\t    //当前扩展名称name != default时，获取该name的扩展实例，并存起来\n\t\t    T ext = getExtension(name);\n\t\t    usrs.add(ext);\n\t\t}\n\t    }\n\t}\n\tif (!usrs.isEmpty()) {\n\t    exts.addAll(usrs);\n\t}\n\treturn exts;\n}\n\n/**\n * group是否匹配\n * 1、group为空，则匹配\n * 2、group在groups中存在，则匹配\n * @param group\n * @param groups @Activate中配置的group数组\n * @return\n */\nprivate boolean isMatchGroup(String group, String[] groups) {\n\tif (group == null || group.length() == 0) {\n\t    return true;\n\t}\n\tif (groups != null && groups.length > 0) {\n\t    for (String g : groups) {\n\t\tif (group.equals(g)) {\n\t\t    return true;\n\t\t}\n\t    }\n\t}\n\treturn false;\n}\n/**\n * 是否已激活\n * 1、@activate没有配置value()\n * 2、@Activate中配置的value()在url的参数列表中存在,且url参数对应的value不为空\n * @param activate\n * @param url\n * @return\n */\nprivate boolean isActive(Activate activate, URL url) {\n        //获取@Activate注解中配置的keys\n\tString[] keys = activate.value();\n\tif (keys.length == 0) {\n\t    return true;\n\t}\n\tfor (String key : keys) {\n\t    for (Map.Entry<String, String> entry : url.getParameters().entrySet()) {\n\t\tString k = entry.getKey();\n\t\tString v = entry.getValue();\n\t\tif ((k.equals(key) || k.endsWith(\".\" + key))\n\t\t\t&& ConfigUtils.isNotEmpty(v)) {\n\t\t    return true;\n\t\t}\n\t    }\n\t}\n\treturn false;\n}\n```\n\n#### getAdaptiveExtension方法\n接下来看下getAdaptiveExtension方法，该方法用来获取扩展接口type对应的自适应扩展实例。\n```java\n\n/**\n * 缓存的自适应实例\n */\nprivate final Holder<Object> cachedAdaptiveInstance = new Holder<Object>();\n\n/**\n * 记录创建自适应扩展实例时发生的异常\n */\nprivate volatile Throwable createAdaptiveInstanceError;\n\n\n/**\n * 获取扩展接口type的自适应扩展实例\n */\npublic T getAdaptiveExtension() {\n\t//先从缓存中获取\n\tObject instance = cachedAdaptiveInstance.get();\n\tif (instance == null) {\n\t    //缓存中不存在\n\t    //判断createAdaptiveInstanceError变量是否为空，不为空说明之前创建自适应实例时发生了异常\n\t    if (createAdaptiveInstanceError == null) {\n\t        //没有发生异常，同步创建自适应扩展实例\n\t\tsynchronized (cachedAdaptiveInstance) {\n\t\t    //再次验证缓存中是否存在该实例\n\t\t    instance = cachedAdaptiveInstance.get();\n\t\t    if (instance == null) {\n\t\t\ttry {\n\t\t\t    //创建自适应扩展实例(后面会分析该方法)\n\t\t\t    instance = createAdaptiveExtension();\n\t\t\t    //将创建好的实例保存进缓存\n\t\t\t    cachedAdaptiveInstance.set(instance);\n\t\t\t} catch (Throwable t) {\n\t\t\t    //创建实例时发生异常，记录异常\n\t\t\t    createAdaptiveInstanceError = t;\n\t\t\t    throw new IllegalStateException(\"fail to create adaptive instance: \" + t.toString(), t);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    } else {\n\t\tthrow new IllegalStateException(\"fail to create adaptive instance: \" + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);\n\t    }\n\t}\n\treturn (T) instance;\n}\n\n/**\n * 为扩展接口type创建自适应扩展实例，并处理依赖注入\n * @return\n */\nprivate T createAdaptiveExtension() {\n\ttry {\n\t    //在这里调用了getAdaptiveExtensionClass方法获取到自适应扩展类，然后生成实例\n\t    return injectExtension((T) getAdaptiveExtensionClass().newInstance());\n\t} catch (Exception e) {\n\t    throw new IllegalStateException(\"Can not create adaptive extension \" + type + \", cause: \" + e.getMessage(), e);\n\t}\n}\n\n/**\n * 获取扩展接口type的自适应扩展类\n * @return\n */\nprivate Class<?> getAdaptiveExtensionClass() {\n        //加载扩展接口type对应的所有扩展实现类(上文介绍过该方法)\n\tgetExtensionClasses();\n\t//查看缓存中是否已经存在扩展接口type对应的自适应扩展类，如果存在，则直接返回(调用getExtensionClasses方法时，会去设置cachedAdaptiveClass值)\n\tif (cachedAdaptiveClass != null) {\n\t    return cachedAdaptiveClass;\n\t}\n\t//不存在的话，为该扩展接口type创建一个自适应扩展类(后面会分析该方法)\n\treturn cachedAdaptiveClass = createAdaptiveExtensionClass();\n}\n\n/**\n * 扩展接口type不存在自适应扩展类的时候，dubbo默认会为其创建\n * 创建条件：type接口的方法中必须有一个带@Adaptive注解的方法dubbo才会创建自适应扩展类\n * @return\n */\nprivate Class<?> createAdaptiveExtensionClass() {\n\t//生成自适应扩展实现类的代码(后面会分析该方法)\n\tString code = createAdaptiveExtensionClassCode();\n\t//获取类加载器\n\tClassLoader classLoader = findClassLoader();\n\t//获取Compiler自适应扩展实例\n\tcom.alibaba.dubbo.common.compiler.Compiler compiler =\n\t\tExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class)\n\t\t\t.getAdaptiveExtension();\n\t//编译code(后面会分析该方法)\n\treturn compiler.compile(code, classLoader);\n}\n```\n\n接下来的createAdaptiveExtensionClassCode方法比较长，在分析之前，我们先来看下ProxyFactory接口，我们将使用该接口作为例子(即假设当前扩展接口type为ProxyFactory),配合着该方法一起看：\n```java\n@SPI(\"javassist\")\npublic interface ProxyFactory {\n    \n    //@Adaptive({\"proxy\"})\n    @Adaptive({Constants.PROXY_KEY})\n    <T> T getProxy(Invoker<T> invoker) throws RpcException;\n   \n    @Adaptive({Constants.PROXY_KEY})\n    <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException;\n```\n可以看到该接口上添加了@SPI(\"javassist\")注解、接口方法上添加了@Adaptive({Constants.PROXY_KEY})\n\n```java\n/**\n* 为扩展接口type生成自适应扩展类的类代码\n* 假设 type = com.alibaba.dubbo.rpc.ProxyFactory\n* @return\n*/\nprivate String createAdaptiveExtensionClassCode() {\n\tStringBuilder codeBuilder = new StringBuilder();\n\t//获取扩展接口type的方法列表，查看方法上是否存在@Adaptive注解，\n\t//如果不存在@Adaptive注解，则不用生成自适应扩展类\n\tMethod[] methods = type.getMethods();\n\tboolean hasAdaptiveAnnotation = false;\n\tfor (Method m : methods) {\n\t    if (m.isAnnotationPresent(Adaptive.class)) {\n\t\thasAdaptiveAnnotation = true;\n\t\tbreak;\n\t    }\n\t}\n\t// 不存在带有@Adaptive注解的方法，因此不需要生成自适应扩展类\n\tif (!hasAdaptiveAnnotation) {\n\t    throw new IllegalStateException(\"No adaptive method on extension \" + type.getName() + \", refuse to create the adaptive class!\");\n\t}\n\t//添加包声明：type扩展接口所在包包名\n\t//package com.alibaba.dubbo.rpc;\n\tcodeBuilder.append(\"package \").append(type.getPackage().getName()).append(\";\");\n\n\t//import com.alibaba.dubbo.common.extension.ExtensionLoader;\n\tcodeBuilder.append(\"\\nimport \").append(ExtensionLoader.class.getName()).append(\";\");\n\t\n\t//可以看到生成的实现类名称为ProxyFactory$Adaptive，实现了ProxyFactory接口\n\t//public class com.alibaba.dubbo.rpc.ProxyFactory$Adaptive implements com.alibaba.dubbo.rpc.ProxyFactory{\n\tcodeBuilder.append(\"\\npublic class \")\n\t\t.append(type.getSimpleName())\n\t\t.append(\"$Adaptive\")\n\t\t.append(\" implements \")\n\t\t.append(type.getCanonicalName()).append(\" {\");\n\n\t//遍历type接口的方法\n\tfor (Method method : methods) {\n\t    //接口方法返回类型\n\t    Class<?> rt = method.getReturnType();\n\t    //接口方法参数类型数组\n\t    Class<?>[] pts = method.getParameterTypes();\n\t    //接口方法异常类型数组\n\t    Class<?>[] ets = method.getExceptionTypes();\n\t   \n\t    //判断当前方法上是否存在@Adaptive注解\n\t    Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class);\n            //方法内容\n\t    StringBuilder code = new StringBuilder(512);\n\t    if (adaptiveAnnotation == null) {\n\t\t//添加异常：type接口的当前方法不是一个adaptive方法\n\t\tcode.append(\"throw new UnsupportedOperationException(\\\"method \")\n\t\t\t.append(method.toString()).append(\" of interface \")\n\t\t\t.append(type.getName()).append(\" is not adaptive method!\\\");\");\n\t    } else {\n\t\t//获取到的当前方法的\"URL类型参数/返回URL类型的get方法的参数\"的下标（在当前方法参数中的下标）\n\t\tint urlTypeIndex = -1;\n\t\t//遍历当前方法参数\n\t\tfor (int i = 0; i < pts.length; ++i) {\n\t\t    if (pts[i].equals(URL.class)) {\n\t\t        //第i个下标是URL类型的参数\n\t\t\turlTypeIndex = i;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (urlTypeIndex != -1) {\n\t\t    //从当前方法参数中找到了URL类型的参数\n\t\t    //添加\"校验Url类型参数是否为空\"的code\n\t\t    String s = String.format(\"\\nif (arg%d == null) throw new IllegalArgumentException(\\\"url == null\\\");\",\n\t\t\t    urlTypeIndex);\n\t\t    code.append(s);\n\t\t    \n\t\t    //添加\"声明url类型的变量\"的code\n\t\t    //URL url = arg{$urlTypeIndex}\n\t\t    s = String.format(\"\\n%s url = arg%d;\", URL.class.getName(), urlTypeIndex);\n\t\t    code.append(s);\n\t\t}else {\n\t\t    //从当前方法参数中没有找到URL类型的参数\n\t\t    //返回URL类型的get方法的名称\n\t\t    String attribMethod = null;\n\n\t\t    //遍历参数列表，查询每个参数的方法列表，查找返回URL类型的get方法\n\t\t    LBL_PTS:\n\t\t    //遍历当前方法参数\n\t\t    for (int i = 0; i < pts.length; ++i) {\n\t\t\t//遍历方法第i个参数的所有方法\n\t\t\tMethod[] ms = pts[i].getMethods();\n\t\t\tfor (Method m : ms) {\n\t\t\t    //当前方法名\n\t\t\t    String name = m.getName();\n\t\t\t    //当前方法没有参数，且返回值是URL类型，以get开头或者长度>3,且是public修饰，没有static修饰\n\t\t\t    if ((name.startsWith(\"get\") || name.length() > 3)\n\t\t\t\t    && Modifier.isPublic(m.getModifiers())\n\t\t\t\t    && !Modifier.isStatic(m.getModifiers())\n\t\t\t\t    && m.getParameterTypes().length == 0\n\t\t\t\t    && m.getReturnType() == URL.class) {\n\t\t\t\t//方法的第i个参数是\"返回URL类型的get方法\"\n\t\t\t\turlTypeIndex = i;\n\t\t\t\t//“返回URL类型的get方法的名称”\n\t\t\t\tattribMethod = name;\n\t\t\t\t//跳转到LBL_PTS\n\t\t\t\tbreak LBL_PTS;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (attribMethod == null) {\n\t\t\t//没有找到返回URL类型的方法，抛异常\n\t\t\tthrow new IllegalStateException(\"fail to create adaptive class for interface \" + type.getName()\n\t\t\t\t+ \": not found url parameter or url attribute in parameters of method \" + method.getName());\n\t\t    }\n\t\t\t\n\t\t    //添加“方法第urlTypeIndex个参数为空的判断”\n\t\t    String s = String.format(\"\\nif (arg%d == null) throw new IllegalArgumentException(\\\"%s argument == null\\\");\",\n\t\t\t    urlTypeIndex, pts[urlTypeIndex].getName());\n\t\t    code.append(s);\n\t\t\t\n\t\t    //添加“方法第urlTypeIndex个参数的attribMethod方法的返回值为空的判断”\n\t\t    s = String.format(\"\\nif (arg%d.%s() == null) throw new IllegalArgumentException(\\\"%s argument %s() == null\\\");\",\n\t\t\t    urlTypeIndex, attribMethod, pts[urlTypeIndex].getName(), attribMethod);\n\t\t    code.append(s);\n\n\t\t    //添加：com.alibaba.dubbo.common.URL url = arg{$urlTypeIndex}.attribMethod();\n\t\t    s = String.format(\"%s url = arg%d.%s();\", URL.class.getName(), urlTypeIndex, attribMethod);\n\t\t    code.append(s);\n\t\t}\n\t\t//@Adaptive注解的value值\n\t\tString[] value = adaptiveAnnotation.value();\n\t\tif (value.length == 0) {\n\t\t    //没有设置value，则根据扩展接口名称按照一定规则生成value\n\t\t    //如：ProxyFactory 将生成value：proxy.factory\n\t\t    //则charArray = [P,r,o,x,y,F,a,c,t,o,r,y]\n\t\t    char[] charArray = type.getSimpleName().toCharArray();\n\t\t    StringBuilder sb = new StringBuilder(128);\n\t\t    for (int i = 0; i < charArray.length; i++) {\n\t\t\tif (Character.isUpperCase(charArray[i])) {\n\t\t\t    //当前字符是大写的\n\t\t\t    if (i != 0) {\n\t\t\t        //当前字符不是第1个字符，则添加“.”到sb中\n\t\t\t\tsb.append(\".\");\n\t\t\t    }\n\t\t\t    //将当前字符转为小写，并添加到sb中\n\t\t\t    sb.append(Character.toLowerCase(charArray[i]));\n\t\t\t} else {\n\t\t\t    //当前字符是小写的，直接添加到sb中\n\t\t\t    sb.append(charArray[i]);\n\t\t\t}\n\t\t    }\n\t\t    //生成的value = [{\"proxy.factory\"}]\n\t\t    value = new String[]{sb.toString()};\n\t\t}\n\t\t//当前方法中是否存在Invocation类型的参数\n\t\tboolean hasInvocation = false;\n\t\tfor (int i = 0; i < pts.length; ++i) {\n\t\t    //当前方法的第i个参数名称是否为“com.alibaba.dubbo.rpc.Invocation”\n\t\t    if (pts[i].getName().equals(\"com.alibaba.dubbo.rpc.Invocation\")) {\n\t\t\t//添加\"校验参数Invocation是否为空\"的code\n\t\t\tString s = String.format(\"\\nif (arg%d == null) throw new IllegalArgumentException(\\\"invocation == null\\\");\", i);\n\t\t\tcode.append(s);\n\t\t\t//添加\"获取方法名\"的code\n\t\t\ts = String.format(\"\\nString methodName = arg%d.getMethodName();\", i);\n\t\t\tcode.append(s);\n\t\t\t//标识 存在Invocation类型的参数\n\t\t\thasInvocation = true;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t//@SPI注解上配置的值，默认扩展名称\n\t\tString defaultExtName = cachedDefaultName;\n\t\tString getNameCode = null;\n\t\t//遍历@Adaptive注解的value数组\n\t\tfor (int i = value.length - 1; i >= 0; --i) {\n\t\t    if (i == value.length - 1) {\n\t\t        //当前i为value的最后1个元素\n\t\t\tif (null != defaultExtName) {\n\t\t\t    //默认扩展名称不为空，如果没有获取到值，则会使用默认值\n\t\t\t    //第i个元素是否等于protocol\n\t\t\t    if (!\"protocol\".equals(value[i])) {\n\t\t\t\tif (hasInvocation) {\n\t\t\t\t    //存在Invocation类型的参数\n\t\t\t\t    //调用url的getMethodParameter方法，获取value[i]对应的扩展名，如果为空，则取默认扩展名defaultExtName\n\t\t\t\t    getNameCode = String.format(\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName);\n\t\t\t\t} else {\n\t\t\t\t    //不存在Invocation类型的参数\n\t\t\t\t    //从url的value[i]参数中(当前例子为proxy)获取扩展名，如果没有获取到，则使用默认扩展名javassist\n\t\t\t\t    //url.getParameter(\"proxy\",\"javassist\")\n\t\t\t\t    getNameCode = String.format(\"url.getParameter(\\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName);\n\t\t\t\t}\n\t\t\t    } else {\n\t\t\t        //第i个元素等于protocol\n\t\t\t\t//从url中获取protocol属性值，如果没有获取到，则使用默认扩展名defaultExtName\n\t\t\t\tgetNameCode = String.format(\"( url.getProtocol() == null ? \\\"%s\\\" : url.getProtocol() )\", defaultExtName);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    //默认扩展名称为空，如果没有获取到值，则不会使用默认值\n\t\t\t    if (!\"protocol\".equals(value[i])) {\n\t\t\t\tif (hasInvocation) {\n\t\t\t\t    getNameCode = String.format(\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName);\n\t\t\t\t} else {\n\t\t\t\t    //从url中获取参数value[i]对应的值\n\t\t\t\t    getNameCode = String.format(\"url.getParameter(\\\"%s\\\")\", value[i]);\n\t\t\t\t}\n\t\t\t    } else {\n\t\t\t        //从url中获取protocol属性值\n\t\t\t\tgetNameCode = \"url.getProtocol()\";\n\t\t\t    }\n\t\t\t}\n\t\t    } else {\n\t\t        //当前第i个元素不是value最后一个元素\n\t\t\tif (!\"protocol\".equals(value[i])) {\n\t\t\t    if (hasInvocation) {\n\t\t\t\tgetNameCode = String.format(\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName);\n\t\t\t    } else {\n\t\t\t\tgetNameCode = String.format(\"url.getParameter(\\\"%s\\\", %s)\", value[i], getNameCode);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    getNameCode = String.format(\"url.getProtocol() == null ? (%s) : url.getProtocol()\", getNameCode);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\t\n\t\t//添加：String extName = url.getParameter(\"proxy\", \"javassist\");\n\t\t//获取扩展名\n\t\tcode.append(\"\\nString extName = \").append(getNameCode).append(\";\");\n\t\t\n\t\t//添加“校验扩展名不为空”的code\n\t\tString s = String.format(\"\\nif(extName == null) \" +\n\t\t\t\t\"throw new IllegalStateException(\\\"Fail to get extension(%s) name from url(\\\" + url.toString() + \\\") use keys(%s)\\\");\",\n\t\t\ttype.getName(), Arrays.toString(value));\n\t\tcode.append(s);\n\n\t\t//添加\"根据扩展名获取扩展实例\"的code\n\t\t//com.alibaba.dubbo.rpc.ProxyFactory extension = (com.alibaba.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.ProxyFactory.class).getExtension(extName) ;\n\t\ts = String.format(\"\\n%s extension = (%<s)%s.getExtensionLoader(%s.class).getExtension(extName);\",\n\t\t\ttype.getName(), ExtensionLoader.class.getSimpleName(), type.getName());\n\t\tcode.append(s);\n\n\t\t//处理返回值\n\t\tif (!rt.equals(void.class)) {\n\t\t    //返回值不是void类型\n\t\t    code.append(\"\\nreturn \");\n\t\t}\n\n\t\t//例如：return extension.getInvoker(arg0);\n\t\t//这里的逻辑就是：根据扩展名称的不同获取相应的扩展实现，然后调用方法，并返回\n\t\ts = String.format(\"extension.%s(\", method.getName());\n\t\t//先填写调用信息\n\t\tcode.append(s);\n\t\t\n\t\t//遍历当前方法参数，添加方法参数\n\t\tfor (int i = 0; i < pts.length; i++) {\n\t\t    if (i != 0) {\n\t\t\tcode.append(\", \");\n\t\t    }\n\t\t    code.append(\"arg\").append(i);\n\t\t}\n\t\tcode.append(\");\");\n\t    }\n\n\t    //生成方法签名code\n\t    //如：public java.lang.Object getProxy(com.alibaba.dubbo.rpc.Invoker arg0) throws com.alibaba.dubbo.rpc.RpcException\n\t    codeBuilder.append(\"\\npublic \")\n\t\t    .append(rt.getCanonicalName())\n\t\t    .append(\" \")\n\t\t    .append(method.getName())\n\t\t    .append(\"(\");\n\n            //添加参数\n\t    for (int i = 0; i < pts.length; i++) {\n\t\tif (i > 0) {\n\t\t    codeBuilder.append(\", \");\n\t\t}\n\t\tcodeBuilder.append(pts[i].getCanonicalName());\n\t\tcodeBuilder.append(\" \");\n\t\tcodeBuilder.append(\"arg\").append(i);\n\t    }\n\t    codeBuilder.append(\")\");\n\n\t    //添加异常\n\t    if (ets.length > 0) {\n\t\tcodeBuilder.append(\" throws \");\n\t\tfor (int i = 0; i < ets.length; i++) {\n\t\t    if (i > 0) {\n\t\t\tcodeBuilder.append(\", \");\n\t\t    }\n\t\t    codeBuilder.append(ets[i].getCanonicalName());\n\t\t}\n\t    }\n\t   \n\t    codeBuilder.append(\" {\");\n\t     //将方法code添加到方法代码块中\n\t    codeBuilder.append(code.toString());\n\t    codeBuilder.append(\"\\n}\");\n\t}\n\tcodeBuilder.append(\"\\n}\");\n\tif (logger.isDebugEnabled()) {\n\t    logger.debug(codeBuilder.toString());\n\t}\n\t//返回生产的code\n\treturn codeBuilder.toString();\n}\n```\n以type = com.alibaba.dubbo.rpc.ProxyFactory为例子，生成的代码大概如下所示:\n```java\npackage com.alibaba.dubbo.rpc;\nimport com.alibaba.dubbo.common.extension.ExtensionLoader;\n\npublic class ProxyFactory$Adaptive implements com.alibaba.dubbo.rpc.ProxyFactory {\n\n    public java.lang.Object getProxy(com.alibaba.dubbo.rpc.Invoker arg0) throws com.alibaba.dubbo.rpc.RpcException {\n\t if (arg0 == null){\n\t    throw new IllegalArgumentException(\"com.alibaba.dubbo.rpc.Invoker argument == null\");\n\t }\n\t if (arg0.getUrl() == null) {\n\t    throw new IllegalArgumentException(\"com.alibaba.dubbo.rpc.Invoker argument getUrl() == null\");\n\t }\n\t com.alibaba.dubbo.common.URL url = arg0.getUrl();\n\t String extName = url.getParameter(\"proxy\", \"javassist\");\n\t if(extName == null) {\n\t    throw new IllegalStateException(\"Fail to get extension(com.alibaba.dubbo.rpc.ProxyFactory) name from url(\" + url.toString() + \") use keys([proxy])\");\n\t }\n\t com.alibaba.dubbo.rpc.ProxyFactory extension = (com.alibaba.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.ProxyFactory.class).getExtension(extName);\n\t return extension.getProxy(arg0);\n    }\n\n    public com.alibaba.dubbo.rpc.Invoker getInvoker(java.lang.Object arg0, java.lang.Class arg1, com.alibaba.dubbo.common.URL arg2) throws com.alibaba.dubbo.rpc.RpcException {\n\tif (arg2 == null) {\n\t    throw new IllegalArgumentException(\"url == null\");\n\t}\n\tcom.alibaba.dubbo.common.URL url = arg2;\n\tString extName = url.getParameter(\"proxy\", \"javassist\");\n\tif(extName == null){\n\t    throw new IllegalStateException(\"Fail to get extension(com.alibaba.dubbo.rpc.ProxyFactory) name from url(\" + url.toString() + \") use keys([proxy])\");\n\t}\n\tcom.alibaba.dubbo.rpc.ProxyFactory extension = (com.alibaba.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.ProxyFactory.class).getExtension(extName);\n\treturn extension.getInvoker(arg0, arg1, arg2);\n    }\n}\n```\n以上就是生成自适应实现类的全部内容，生成好代码后，会交由Compiler扩展进行编译得到Class对象，然后在本小节开头介绍的createAdaptiveExtension()方法中进行实例化，并进行依赖注入。\n本文内容过多，Compiler编译的部分就放到后面的博文中在介绍了。另外ExtensionLoader类中也提供了很多辅助方法，内容比较简单，在这里就不详细介绍了。\n\n### ExtensionFactory工厂实现\n```\n@SPI\npublic interface ExtensionFactory {\n    /**\n     * 获取扩展实现类实例\n     * Get extension.\n     * @param type object type. 扩展接口类型\n     * @param name object name. 扩展名称\n     * @return object instance. 返回扩展实例\n     */\n    <T> T getExtension(Class<T> type, String name);\n}\n```\n该接口根据扩展类型和扩展名称获取扩展实例。可以看到该接口声明上也加上了@SPI注解，说明存在多种实现，Dubbo提供了三种实现，分别为AdaptiveExtensionFactory、SpiExtensionFactory、SpringExtensionFactory.\n\n#### SpringExtensionFactory\n```java\npublic class SpringExtensionFactory implements ExtensionFactory {\n\n    /**\n     * 保存所有的ApplicationContext上下文对象\n     */\n    private static final Set<ApplicationContext> contexts = new ConcurrentHashSet<ApplicationContext>();\n\n    /**\n     * 添加ApplicationContext\n     */\n    public static void addApplicationContext(ApplicationContext context) {\n        contexts.add(context);\n    }\n\n    /**\n     * 移除ApplicationContext\n     */\n    public static void removeApplicationContext(ApplicationContext context) {\n        contexts.remove(context);\n    }\n\n    @Override\n    public <T> T getExtension(Class<T> type, String name) {\n        //遍历所有的context\n        for (ApplicationContext context : contexts) {\n            //判断该context上下文是否包含此bean\n            if (context.containsBean(name)) {\n                //根据名称获取context中的bean\n                Object bean = context.getBean(name);\n                //判断该bean是否是type类型的实例，如果是的话，则返回该bean\n                if (type.isInstance(bean)) {\n                    return (T) bean;\n                }\n            }\n        }\n        return null;\n    }\n}\n```\n\n#### SpiExtensionFactory\n\n```java\npublic class SpiExtensionFactory implements ExtensionFactory {\n\n    @Override\n    public <T> T getExtension(Class<T> type, String name) {\n        //判断类型type是否是接口，并且存在@SPI注解\n        if (type.isInterface() && type.isAnnotationPresent(SPI.class)) {\n            //获取扩展接口type的扩展加载器\n            ExtensionLoader<T> loader = ExtensionLoader.getExtensionLoader(type);\n\t    //通过扩展加载器获取接口type支持的所有扩展的名称列表\n            if (!loader.getSupportedExtensions().isEmpty()) {\n                //返回自适应扩展实例\n                return loader.getAdaptiveExtension();\n            }\n        }\n        return null;\n    }\n}\n```\n\n#### AdaptiveExtensionFactory\n该ExtensionFactory实现存在@Adaptive注解，因此它是自适应实现。\n\n```java\n@Adaptive\npublic class AdaptiveExtensionFactory implements ExtensionFactory {\n\n    /**\n     * ExtensionFactory扩展实现类实例集合\n     */\n    private final List<ExtensionFactory> factories;\n\n    public AdaptiveExtensionFactory() {\n        //获取ExtensionFactory.class对应的扩展加载器\n        ExtensionLoader<ExtensionFactory> loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);\n        \n        List<ExtensionFactory> list = new ArrayList<ExtensionFactory>();\n        \n        //遍历扩展接口ExtensionFactory支持的扩展名称列表(spi、spring)\n        for (String name : loader.getSupportedExtensions()) {\n            //根据扩展名称name加载扩展实现类实例\n            list.add(loader.getExtension(name));\n        }\n        factories = Collections.unmodifiableList(list);\n    }\n\n    /**\n     * 自适应的扩展工厂，挨个遍历spring和spi，从中查询指定类型的实例\n     * @param type object type. 扩展接口类型\n     * @param name object name. 扩展名称\n     * @param <T>\n     * @return\n     */\n    @Override\n    public <T> T getExtension(Class<T> type, String name) {\n        //遍历ExtensionFactory实现类集合，从中挨个查找指定类型的扩展\n        for (ExtensionFactory factory : factories) {\n            //获取type类型的扩展实例\n            T extension = factory.getExtension(type, name);\n            if (extension != null) {\n               //实例不为空，返回实例 \n               return extension;\n            }\n        }\n        return null;\n    }\n}\n```\n\n到此，关于SPI的实现就全部介绍完了，下一小节将会介绍和Sping集成相关的内容。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["dubbo"]},{"title":"Spring注解之@Import注解","url":"/blog/2018/07/30/Spring注解之-Import注解/","content":">本小节介绍Spring提供的@Import注解\n\n* @Import注解的作用\n* @Import注解的定义\n* @Import注解的使用\n\n### @Import注解的作用\n表示要导入1个或多个@Configuration配置类。提供了与Spring XML中的<import/>元素等效的作用.\n@Import注解允许我们使用导入的方式将实例添加到Spring BeanFactory中.允许我们导入@Configuration类、ImportSelector接口和ImportBeanDefinitionRegistrar接口的实现类,类似于AnnotationConfigApplicationContext类的register方法。\n\n### @Import注解的定义\n可以看到该注解只可以使用在类上.\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Import {\n\t/**\n\t * {@link Configuration}, {@link ImportSelector}, {@link ImportBeanDefinitionRegistrar}\n\t * or regular component classes to import.\n\t */\n\tClass<?>[] value();\n}\n```\n### @Import注解的使用\n\n接下来，我们分别介绍这三种使用方式,我们先创建一些测试类和测试方法:\n```java\npackage org.dubbo.import;\npublic class A{}\n\npublic class B{}\n\npublic class C{}\n\npublic class D{}\n\n//测试方法\npublic static void main(String args[]){\n   //创建配置上下文\n   AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\n   //注册当前配置 Bean\n   context.register(DubboConfiguration.class);\n   context.refresh();\n   \n   //获取所有已注册的beanNames\n   String[] beanNames = context.getBeanDefinitionNames();\n   for(String beanName : beanNames){\n       //输出beanNames\n       System.out.println(\"beanName -> \"+ beanName);\n   }\n}\n```\n\n#### Configuration方式\n```java\n@Import({A.class,B.class})\n@Configuration\npublic class DubboConfig{} \n```\n执行测试方法，将会输出：\n```java\nbeanName -> DubboConfig\nbeanName -> org.dubbo.import.A\nbeanName -> org.dubbo.import.B\n```\n\n#### 实现ImportSelector接口方式\n```java\n/**\n * ImportSelector实现类\n */\npublic class DubboImportSelector implements ImportSelector{\n    public String[] selectImports(AnnotationMetadata metadata) {\n        return new String[]{\"org.dubbo.import.C\"};\n    }\n}\n\n/**\n * 修改配置\n */\n@Import({A.class,B.class,DubboImportSelector.class})\n@Configuration\npublic class DubboConfig{}\n```\n\n执行测试方法，将会输出：\n```java\nbeanName -> DubboConfig\nbeanName -> org.dubbo.import.A\nbeanName -> org.dubbo.import.B\nbeanName -> org.dubbo.import.C\n```\n\n#### 实现ImportBeanDefinitionRegistrar接口方式\n\n```java\n/**\n *\n * ImportBeanDefinitionRegistrar实现类\n */\npublic class DubboImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar{\n    \n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata metadata,BeanDefinitionRegistry registry) {\n        //创建一个D类的rootBeanDefinition对象\n        RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(D.class);\n        //注册beanName=d的bean\n        registry.registerBeanDefinition(\"d\", rootBeanDefinition);\n    }\n}\n\n/**\n * 修改配置\n */\n@Import({A.class,B.class,DubboImportSelector.class,DubboImportBeanDefinitionRegistrar.class})\n@Configuration\npublic class DubboConfig{}\n```\n\n然后执行测试方法，将会输出：\n```java\nbeanName -> DubboConfig\nbeanName -> org.dubbo.import.A\nbeanName -> org.dubbo.import.B\nbeanName -> org.dubbo.import.C\nbeanName -> org.dubbo.import.D\n```\n\n可以看到，我们成功将A/B/C/D添加到了BeanFactory中.\n","tags":["spring"]},{"title":"自己动手实现Idea插件","url":"/blog/2018/07/29/自己动手实现Idea插件/","content":">在阅读开源项目源代码的时候，会时常一起读作者写的注释来理解代码的意图，对于英文不好的码农来说实在是比较吃力，或者当我们在写代码的时候，为了一个变量名称纠结半天时，都会需要一个强大的词典来支持我们的工作，用有道词典的话，启动过慢、电脑太卡、来回切换屏幕会感觉很不爽还好Idea提供了强大的插件扩展能力，能让我们在集成开发环境中嵌入翻译引擎，当然只要有足够的想象力，可以在Idea集成环境中开发各种插件，自定义自己的开发环境，比如下面的炫酷插件\n![](img/1.gif)\n本文就向大家介绍一下如何开发一个Idea翻译插件。\n首先，打开Idea集成开发环境，然后新建一个Idea plugin项目：\n![](img/2.jpg)\n然后输入项目名称，以及项目位置，并点击Finish按钮完成创建：\n![](img/3.jpg)\n创建好项目以后，结构如下图：\n![](img/4.jpg)\n然后我们在src目录下创建一个easy.form的包，并在该包路径下创建一个名称为TranslationForm的 GUI Form：\n![](img/5.jpg)\n![](img/6.jpg)\n此时，Idea会自动帮我们生成一个TranslationForm.form文件和一个TranslationForm类。我们可以通过在TranslationForm.form文件中拖拽组件迅速构建一个配置面板（玩过Visual Studio的童鞋一定对这个功能很熟悉了），与此同时，Idea会自动在TranslationForm类中生成相应的组件元素：\n![](img/7.jpg)\n在这里，我们新创建了一个主面板JPanel，然后在该面板下创建了6个子元素JRadioButton单选按钮，以及一个标签JLabel。现在挑一个单选按钮讲解下，其他的都类似：\n![](img/8.jpg)\nButton Group选项是定义一个按钮组，我们这里定义了一个engineGroup的按钮组，用来对按钮进行归组。field name选项就是将要在TranslationForm类中动态创建的变量名称，text就是显示的文本，selected标识是否默认选中，enabled标识是否启用，这里只简单设置了这几个选项，还有其他丰富的选项，有兴趣的童鞋可以自行研究尝试。\n接下来我们看下我们的TranslationForm类：\n![](img/9.jpg)\n可以看到Idea为我们的各个组件元素都自动生成相对应的变量，同时，我们也自定义了一个selectValue变量（用来保存当前值）和currentSelectButton变量（用来保存当前选中的按钮），再来看下该类中的方法：\n![](img/10.jpg)\n在构造函数中，我们定义了一个监听器用来监听当前用户选择的选项，并保存起来，后文会用到。\n组件开发完毕,我们再来看下配置。\n如何让Idea能够保存起来我们的配置，以便下次启动时能够自动加载用户相应的配置，其实，刚创建完项目后，在resources/META-INF/目录下会生成一个plugin.xml文件：\n![](img/11.jpg)\n![](img/12.jpg)\n![](img/13.jpg)\n在extensions标签下，我们指定了实例easy.config.TranslationConfig类以及实现实现类easy.config.TranslationSetting，该实现类就是用来管理我们的配置信息的。在application-components标签下，我们定义了easy.idea.MyPluginRegistration实现类，Idea组件是插件整合的基础概念，有三种组件类型：application-level、project-level和module-level。 Application-level组件在IDEA启动时就被创建并初始化。在action标签下的add-to-group中的group-id很重要，它指定了你的插件在整个idea界面上的入口，这个值可以指定的很多（比如代码区域的右键菜单、编辑器顶部的菜单）。action节点中重要的是class和text，class是指定插件的入口action，一般情况下，一个插件定义一个就行了，相当于main函数吧，而text是指定插件的具体的名称，就是点击这个text然后执行class指定的类。\n我们先来看下MyPluginRegistration类，在这里我们简单的注册了我们的ToChineseAction类：\n![](img/14.jpg)\n我们再来看下TranslationSetting类，该类实现了PersistentStateComponent接口，这样组件的状态将会自动保存和加载：\n![](img/15.jpg)\n我们指定了@State和@Storage注解，这样组件的状态将会保存到一个XML文件中。在该类我们定义了一个engine的变量，用来保存当前用户选择的翻译引擎（谷歌、欧米等），同时提供了getState方法、loadState方法来设置获取配置。其中Constant.ELEMENT_NAME就是\"TranslationSetting\"，Constant.ELEMENT_ATTR_NAME就是\"engine\"，是我们自己定义的变量。\n\n我们再来看下TranslationConfig类：\n![](img/16.jpg)\n在该类中，我们定义了TranslationForm类和TranslationSetting类的变量。isModified方法是用来判断选项是否被修改过（如：我们是否更换了翻译引擎）。getDisplayName是在配置面板上显示的名称，如：\n![](img/17.jpg)\napply方法是用来将设置用户选择的翻译引擎，reset方法是重置用户选择项：\n![](img/18.jpg)\ncreateComponent方法是用来创建组件：\n![](img/19.jpg)\n现在我们来看下ToChineseAction类：\n![](img/20.jpg)\n在该类中持有一个TranslationSetting类的引用，用来获取当前用户选择的翻译引擎。我们首先获取代码编辑区对象，然后判断用户是否选中了一些文本，如果选中了文本，则获取到选中的内容，然后调用formatText方法将没用的干扰文本去掉，最后获取翻译引擎，执行翻译，并将翻译结果以气泡的方式展示出来。\n![](img/21.jpg)\n效果如下：\n![](img/22.jpg)\n我们再来看下ToEnglishAction类，该类和ToChineseAction类似，唯一的不同就是提示面板不一样：该类是先弹出来一个框提示用户输入中文，然后将中文翻译成相应的英文：\n![](img/23.jpg)\n效果如下：\n![](img/24.jpg)\n![](img/25.jpg)\n关于Idea插件开发的部分就介绍完毕了，具体怎么执行翻译的呢？有兴趣的可以去看下源码(https://github.com/limengyu1990/easy-translation)，这里就不多介绍了，同时可以去Idea官方插件库中下载该插件试用：\n![](img/26.jpg)\n","tags":["plugin"]},{"title":"ScalaSTM官网翻译","url":"/blog/2018/07/29/ScalaSTM官网翻译/","content":"\n### 欢迎\n欢迎来自 Scala STM 的创造者。我们已经为 scala 构建了一个轻量级的软件事务性内存, 灵感来自于Haskell STMs和Clojure, 同时利用了Scala 的力量和性能。\nScalaSTM 是一个没有依赖关系的单一 JAR, 包括\n* 支持多个 STM 实现的 API\n* 基于 CCSTM 的参考实现\n* 可扩展的并发sets和maps(具有快速快照), 可以在事务内部或外部使用\n\nScalaSTM 提供一个可变单元称为一个Ref，如果使用不可变对象和 Ref-s构建共享数据结构, 则可以从多个threads或actors访问该结构。没有同步、没有死锁或争用条件以及良好的可伸缩性。包括并发sets和maps, 我们也有一个更容易和更安全的替代wait和notifyAll。\n\n### 介绍\n#### STM是什么？\nSTM（软件事务性内存）是介于代码的关键部分 (atomic原子块) 和程序堆之间的中介。STM 在atomic原子块中读取和写入过程中进行干预, 允许它检查and/or避免干扰其他线程。如果多个线程的负载和存储变得交错, 则将回滚该atomic原子块的所有写入, 然后重试整个块。如果关键部分的访问不是交错的, 则它就像是以原子的样子完成的, 并且可以提交原子块。其他threads或actors只能看到已提交的更改。\nSTMs 使用乐观并发控制。他们乐观地认为, atomic原子块将能够并行运行, 然后备份和重试, 如果推测是不正确的。保留旧版本的数据以便备份可能会带来一些开销, 但乐观并发通常比其他方法具有更好的可伸缩性。\n\n#### ScalaSTM - 没有魔力\n有几个雄心勃勃的尝试来创建 STMs, 可以并行运行现有的顺序命令代码。这是一项难度很大的任务, 需要大量的魔力, 因为对 STM 的调用需要插入到一个atomic原子块内的非final字段或数组元素的每个负载和存储中。良好的性能也很难, 因为大量的读写。\nScalaSTM API 通过只管理 Ref-s, 避免了对魔力的需要。这意味着要管理的内存位置较少, 因此不需要字节码检测或编译器修改。就像在Haskell和Clojure中 一样, Ref 的效用通过语言对不可变数据结构的良好支持被放大。ScalaSTM 还包括可在事务中使用的并发sets和maps。\n\n#### ScalaSTM是给谁的呢？\nScalaSTM 是程序员用来协调threads或actors对共享数据的访问。在服务器中, 这可能是活动连接或缓存的列表。在客户端中, 这可能是部分结果或工作线程状态。\n\n优点：\n* 说出你的意思。你编写atomic原子, ScalaSTM 原子执行它没有deadlocks 或者 races。不需要将锁映射到数据。嵌套的原子块做了正确的事情, 所以你可以从简单的开始构造复杂的线程安全的操作。\n* 读取规模。系统中的所有线程都可以在不相互干扰的情况下读取数据。乐观算法比悲观方法更好地利用了现代架构上的缓存。\n* 异常自动触发清理。如果atomic原子块引发异常, 则所有 Ref-s 都将重置为其原始状态。(如果愿意, 可以更改此默认值）\n* 等待复杂的条件是容易的。如果一个atomic原子块找不到它要查找的状态, 它可以调用重试备份并等待其任何输入更改。如果有多种方式标识成功, 你可以将它们链接起来，ScalaSTM 将尝试他们所有。\n* 简单。ScalaSTM 只是一个独立的库, 所以它不会影响应用程序中不使用它的部分。这意味着可以将其包含在框架或隐藏组件中。\n缺点：\n* 每次读或写两个额外字符。如果 x 是 Ref, 则 x () 读取其值, x () = v 写入它的值。\n* 单线程开销。在大多数情况下, 当程序实际上没有并行运行时, STMs 的速度会减慢。我们已经得到了实际成本相当低, 所以对于大多数使用者来说这不会是一个问题。即使在单线程程序中，回滚也非常有用，以便在异常情况下自动清除。\n* 回滚与I/O混合的不是很好。只会自动撤消对 Ref-s 的更改。ScalaSTM API 提供了hooks , 因此您可以执行手动补偿或数据库集成, 但无法撤回数据包或像素。当然, 当你持有一个锁的时候你可能不应该做I/O。\n\n### 快速开始\n作为一个简单的例子,我们将构建一个可以被多个线程或actor安全使用的双向链表。我们将会教我们的列表如何成为一个阻塞队列,然后我们将添加从多个队列中选择下一个可用元素的能力。\n\n#### 安装\n如果你使用`sbt`，把下面的依赖添加到你的工程中build.sbt文件中，\n然后运行`sbt update`\nMaven2的配置可以从如下链接获取：https://nbronson.github.io/scala-stm/releases.html\n\n#### 对共享变量使用Ref\n在我们的可变链表中， 我们需要每个节点的下一个和上一个指针是线程安全的。通常， 如果一个线程可能在另一个线程访问它 (读取或写入) 的同时写一个变量，那么STM需要通过Ref来参与。\nRef是单个的可变单元，还有事务性集合(如TMap和Tset)，它们是scala.collection.mutable.集合的替代品.\n![](img/1.jpg)\n为了让代码更简单，我们通过一个额外的header节点使列表循环，在创建时，这个header节点的next节点和prev节点指向自身，next节点和prev节点总是非空的。\n\n#### 用atomic包装你的代码\n如果 x 是 Ref, 则 x () 获取存储在 x 中的值, x () = v 将其设置为值 v。\n只能在atomic代码块内读取和写入Ref-s。这在编译时通过要求可用的隐式InTxn 值来进行检查，Atomic代码块是一个需要一个lnTxn参数的函数，因此可以通过将参数标记为隐式的来满足此要求。\n![](img/2.jpg)\n\n#### 组合atomic操作\nAtomic代码块嵌套，因此你可以通过一个简单的开始构建复合操作.\n![](img/3.jpg)\n\n#### 优化单一操作事务\nRef.single返回一个Ref.View类型的实例，这个行为就像原始的Ref只是它也可以在一个atomic代码块之外访问。Ref.View上的每一个方法都类似于单操作事务，因此name.Ref.View提供了多种执行读写的方法，例如swap，compareAndSet和transform。如果一个atomic块只访问一个Ref，那么使用Ref.View可能会更简洁、更高效。\n![](img/4.jpg)\n\n#### 等待条件变化\n当一个atomic代码块无法在当前输入状态下完成时使用retry关键字。在atomic代码块内调用retry将导致它回滚，等待它的一个输入更改，然后重试执行。这大致类似于调用wait等待ScalaSTM 自动生成相匹配 notifyAll 的调用。作为其实现乐观并发的一部分，STM跟踪了一个atomic代码块的read集合，Ref-s的集合已在事务期间读取（即在事务过程中读取的 Ref-s 集合），这意味着STM可以有效的阻塞当前线程，直到另一个线程已经写入其read集合中的一个元素，在这段时间内，可以重试该atomic代码块，这使得等待复杂的条件变得微不足道，并可避免丢失唤醒。\n为了演示，我们将会添加一个函数到我们的列表，等待直到这个列表是非空的，然后移除并返回第一个元素：\n![](img/5.jpg)\n\n#### 等待多个事件\n在atomic代码块结束后重试的另一种方法是提供另一种选择。你可以用 orAtomic去链接atomic代码块;如果上层的调用retry, 则会尝试较低的替代方案。这就允许你组合功能如使用retry阻塞或者从一个阻塞行为中进行转换。\n例如，我们可以通过提供一个可选方案并使用阻塞版本的removeFirst 来构造一个返回Option的方法：\n![](img/6.jpg)\n这样也很容易从一个返回故障代码的函数切换到返回一个块的函数，下面的select方法阻塞直到他的输入是非空的，然后从列表中移除并返回第一个元素：\n![](img/7.jpg)\n\n#### 当心回滚\n在乐观并发能够成功之前, ScalaSTM 可能需要多次尝试一个atomic代码块，任何对 STM 的调用都可能会发现故障并触发回滚和重试。如果本地非 Ref 变量的生存期长于atomic代码块， 则不会回滚, 因此应该避免它们。不过, 只在atomic代码块的内部或仅在外部使用的局部变量是很好的。\n\n下面，badToString 是不正确的， 因为它在atomic代码块的外部和内部使用可变 StringBuilder。返回值将会明确提到列表中的所有元素, 但它其中的一些内容可能会出现两次或更多次。\ntoString是正确的, 因为对于每次atomic尝试它都使用一个新的 StringBuilder。\n![](img/8.jpg)\n\n#### 查看源代码\n此列表示例是 GitHub 上源代码的一部分: ConcurrentIntList.scala\n文章来源：https://nbronson.github.io/scala-stm/quick_start.html\n示例源代码：https://github.com/nbronson/scala-stm/blob/master/src/test/scala/scala/concurrent/stm/examples/ConcurrentIntList.scala\n\n### 真人秀哲学家Demo\n\nDijkstra 创建了餐厅哲学家的问题, 作为并发系统中的死锁的例子 (维基百科上的用餐哲学家)。每个哲学家必须拿起两个叉子吃他的饭, 但没有足够的叉子, 他们都吃一次。哲学家必须有某种策略, 以确保他们不都拿起一分叉, 然后永远等待一秒钟。\n许多解决方案都可能避免死锁, 但 STM 提供了一个特别简单的方法。ScalaSTM 的atomic原子块提供了一种方法, 让哲学家同时拿起两个叉子, 这是大多数实现者不可用的能力。\n![](img/9.jpg)\n这表明当结合重试时，Ref [Boolean] 表现的可以像锁一样。\n\n#### 添加一个摄像头\n在这个时代, 食客们更有可能不得不在真人秀节目上比在闭门的情况下为叉子而战。与基于信号量或代理的解决方案不同, STM 解决方案可以很容易地添加摄像头的外部透视图。在实际系统中, 外部视图可能来自管理控制台 (读取和写入)、检查点线程或 GUI 组件。\n\n#### 记录所有权\n首先, 我们将更改叉子, 以便他们使用一个选项来记录所有者的存在和所有者的名称。请注意, 当使用Ref工厂方法创建 Ref[Option[String]] 时, 我们需要强制 类型为\"None\" 。如果我们没有这样做, 那么所有者将最终作为一个 Ref [None], 这不是很有用。\n我们还将给每个哲学家一个名称和一个 Ref[Int] 来记录他们的进展。为方便起见, Ref和Ref.View为具有关联Numeric[A] 的类型 A 提供就地算术运算 (如+=)。\n![](img/10.jpg)\n\n#### 捕获快照\n捕捉系统状态的图像现在就像遍历原子块中的叉子和哲学家一样容易。事务不能访问在原子块外声明的可变对象 (或 var), 这一点很重要。下面的可变 StringBuilder 是在原子块内创建的, 所以它是安全的。\n![](img/11.jpg)\n\n#### Demo全部源码\n此示例的完整源可用作 github 的 ScalaSTM 源的一部分: RealityShowPhilosophers.scala.它包括一个摄像头线程, 它可以一秒钟打印图像60次, 以及处理线程停止。\n下面是运行 RealityShowPhilosophers 的摘录。注意, 因为叉子被拾起并且立刻被放下, 摄像头从未观察一个哲学家只拿着一个叉子。\n![](img/12.jpg)\n\n#### 异常\n当原子块引发异常时会发生什么情况？STM 社区中存在关于是否应回滚或提交事务的辩论。ScalaSTM 使用一种混合的方法来尝试做正确的事情。\n\n#### 异常 -> 回滚 + 重新抛出\n如果atomic原子块引发异常, ScalaSTM 将其回滚, 然后重新抛出该异常。当异常被再次引发时, atomic原子块将被左回滚。对于表示实际错误的异常, 这是一个很好的默认行为, 因为它防止了任何共享数据结构的损坏。\n\n\n#### 控制流异常 –> 提交 + 重新抛出\n有时, 异常表示非本地控制转移, 而不是一个意外的错误。在这种情况下, 应该提交事务。ScalaSTM 测试每个异常转义一个atomic原子块以确定哪个行为是合适的 (查看scaladoc文档TxnExecutor.isControlFlow了解更多)。默认情况下, 扩展 scala.util.control.ControlThrowable 的所有异常都被视为控制流。\n\n#### 异常和嵌套\n以前有关异常处理的规则适用于嵌套事务。这意味着在提交外部事务时可能会回滚嵌套事务。例如, 在下面的代码运行后, 最后将保存值 \"outer\"：\n![](img/13.jpg)\n为了使嵌套更廉价, ScalaSTM 尝试将所有嵌套级别拼合成一个顶级事务。如果内部事务引发异常, 则没有足够的信息来执行部分回滚, 因此 ScalaSTM 将以精确嵌套的模式重新启动整个事务。此优化称为包容。\n\n#### 语法速查表 \nRef, Ref.View and atomic\n![](img/14.jpg)\n\n\n\n\n\n\n","tags":["STM"]},{"title":"FSM状态机","url":"/blog/2018/07/29/FSM状态机/","content":"> 本文主要讲解如何使用状态模式来消除大量的if-else条件判断代码\n\n在我们的App中，订单模块会有很多的状态，例如待付款、付款中、已预约、已取消、已评价等。我们抽一个取消的流程来看下，取消时需要判断当前状态是否允许取消，伪代码如下：\n![](img/1.jpg)\n\n如果状态类型很少的话，这样子判断还可以，一旦我们的状态类型多起来的话，那么我们这里就会是一大堆的if-else条件判断，不仅难以阅读，而且维护起来容易出错。\n我们有三种方式来重构这样的代码：\n* 设计模式之状态模式\n* 领域驱动设计之状态建模\n* 状态机\n\n### 设计模式之状态模式\n![](img/2.jpg)\n其中State是状态接口，ConcreteState是各个具体的状态实现。我们在这里定义个订单状态接口OrderState：\n![](img/3.jpg)\n![](img/4.jpg)\n![](img/5.jpg)\n\n可以看到不是每个状态都能够支持所有操作的，例如：支付中的状态不可以进行支付操作；未支付的状态不可以进行退款操作等。当然我们可以创建一个抽象类AbstractOrderState，把操作的默认实现都放进去，具体的状态实现只覆盖自己能进行的操作。\n然后我们定义一个Context，即订单实体类Order，它持有一个State字段，通过State实现所有的状态转换逻辑：\n![](img/6.jpg)\n通过状态模式，可以省略一大堆条件判断，逻辑实现起来更清晰。\n\n\n### 领域驱动设计之状态建模\n在领域驱动设计中，我们可以定义一些操作接口，然后将每种状态的订单都定义为一个实体类，让这些实体类实现需要的操作接口：\n![](img/7.jpg)\n\n### 状态机\n不管是状态模式还是状态实体，多个状态之间的转换，还是分散在各个状态的实现里的。其实所有的状态转换都可以概括为：\n```scala\nState(S) x Event(E) -> Actions (A), State(S')\n```\n即如果当前状态为S，接收到一个事件E，则执行动作A，同时状态转换为S‘。\nAkka 框架实现了一个有限状态机FSM，它定义了强有力的DSL语法，可以把状态转换和业务处理逻辑分离开来。我们这节主要讲解下Akka FSM的使用。我们先假设我们的订单流程如下面流程图所示：\n![](img/8.jpg)\n然后我们定义一些状态，OrderState继承自FSMState：\n![](img/11.jpg)\n![](img/12.jpg)\n![](img/13.jpg)\n然后我们定义一些Command和DomainEvent。DomainEvent将会被写入日志，它与Command的关系是：我们可以给FSM发送Command，FSM执行Command时会产生DomainEvent，然后这些产生的DomainEvent会被写入日志：\n![](img/14.jpg)\n![](img/15.jpg)\n然后我们定义我们的状态数据：\n![](img/16.jpg)\n然后我们创建我们的状态机MedicalOrderFSM：\n![](img/17.jpg)\n可以看到我们的状态机继承自PersistentFSM trait，我们看下PersistentFSM trait：\n![](img/18.jpg)\nPersistentFSM继承了PersistentActor，说明它具备了事件持久化和日志恢复能力。继承的另一个类型PersistentFSMBase是FSM trait的重新定义，针对状态机的持久化特性设计了一套持久化状态转换的DSL。三个类参数S,D,E分别代表状态类型（State）、状态数据（Data）、领域事件（Event），与FSM比较：PersistentFSM除增加了event参数外，State类型是以FSMState类型为基础的，方便对State进行序列化（serialization）.\n![](img/19.jpg)\n然后我们就可以使用DSL来定义我们的状态机处理流程：\n```scala\nstartWith(initState,initData)  //定义状态机起始状态\nwhen(stateA) {...}   //处理各种状态\nwhen(stateB) {...}\nwhenUnhandled {...}   //处理共性状态\nonTransition {...}  //状态转变跟踪\n```\n状态转换是通过stay(保持当前状态)、goto(到下一个状态)、stop(停止)实现的：\n![](img/20.jpg)\n可以看到stay是通过goto来实现的：\n![](img/21.jpg)\n我们挑一个看下：\n![](img/22.jpg)\n状态机默认状态为InitState，他可以处理CreateOrderCommand，然后跳转到WaitingPayState状态(待支付)，然后应用CreateOrderEvent事件。\n只有状态转换（即InitState转换成WaitingPayState）和数据转换都成功（即CreateOrderEvent执行成功），状态机的本次状态流程才会最终完成，任何一个执行失败，都会执行回滚。这里执行成功后，我们调用saveStateSnapshot保存当前快照，用来重启后状态恢复。\n然后我们定义一个Tracker Actor用来处理事件流：\n![](img/23.jpg)\n然后我们可以测试下我们的状态机，因为actor是轻量级的，因此我们的一个订单交由一个actor来处理，每个actor大概有30字节，1G的内存可以有上百万的actor：\n![](img/24.jpg)\n![](img/25.jpg)\n\n可以看到我们创建了两个订单，状态由“初始状态0“变成了“待支付3“。\n![](img/26.jpg)\n然后对订单支付，可以看到支付成后，状态由“待支付3“变成了“已支付4”。\n我们的状态机状态数据会异步的写到外部存储中，这里使用的是mysql-async组件：\n![](img/27.jpg)\n今天就先简单介绍到这里，后面有时间会分享下Akka FSM的源码。\n\n\n","tags":["akka"]}]