[{"title":"Haskell-Categories","url":"/blog/2019/10/16/Haskell-Categories/"},{"title":"Haskell-Applicatives","url":"/blog/2019/10/16/Haskell-Applicatives/","content":"\n像`monads`一样，`Applicatives`是泛函上位于`functors`(函子)和`monad`之间的各种计算的抽象结构。\n```haskell\npure :: Applicative f => a -> f a\n(<$>) :: Functor f => (a -> b) -> f a -> f b\n(<*>) :: f (a -> b) -> f a -> f b\n```\n自`GHC 7.6`起，`Applicative`定义为:\n```haskell\nclass Functor f => Applicative f where\n  pure :: a -> f a\n  (<*>) :: f (a -> b) -> f a -> f b\n\n(<$>) :: Functor f => (a -> b) -> f a -> f b\n(<$>) = fmap\n```\n`Applicative`具有以下法律:\n```haskell\npure id <*> v = v\npure f <*> pure x = pure (f x)\nu <*> pure y = pure ($ y) <*> u\nu <*> (v <*> w) = pure (.) <*> u <*> v <*> w\n```\n例如，考虑`Maybe`的实例：\n```haskell\ninstance Applicative Maybe where\n  pure              = Just\n  Nothing <*> _     = Nothing\n  _ <*> Nothing     = Nothing\n  Just f <*> Just x = Just (f x)\n```\n根据经验，只要我们使用`m >>= return . f`我们可能想要的是`applicative functor`(应用函子)，而不是`monad`(单子)函数。\n```haskell\nimport Network.HTTP\nimport Control.Applicative ((<$>),(<*>))\n\nexample1 :: Maybe Integer\nexample1 = (+) <$> m1 <*> m2\n  where\n    m1 = Just 3\n    m2 = Nothing\n-- Nothing\n\nexample2 :: [(Int, Int, Int)]\nexample2 = (,,) <$> m1 <*> m2 <*> m3\n  where\n    m1 = [1,2]\n    m2 = [10,20]\n    m3 = [100,200]\n-- [(1,10,100),(1,10,200),(1,20,100),(1,20,200),(2,10,100),(2,10,200),(2,20,100),(2,20,200)]\n\nexample3 :: IO String\nexample3 = (++) <$> fetch1 <*> fetch2\n  where\n    fetch1 = simpleHTTP (getRequest \"http://www.fpcomplete.com/\") >>= getResponseBody\n    fetch2 = simpleHTTP (getRequest \"http://www.haskell.org/\") >>= getResponseBody\n```\n模式`f <$> a <*> b ...`出現的频率很高，以至于有一系列函数可以提升固定数量参数的`applicative`。这种模式也经常出现在`monads`(`liftM`，`liftM2`，`liftM3`)上。\n```haskell\nliftA :: Applicative f => (a -> b) -> f a -> f b\nliftA f a = pure f <*> a\n\nliftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c\nliftA2 f a b = f <$> a <*> b\n\nliftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\nliftA3 f a b c = f <$> a <*> b <*> c\n```\n`Applicative`还具有`*>`和`<*`函数,它們在放弃其中一个参数的值的同时`sequence applicative actions`。\n运算符`*>`舍弃左侧，而`<*`舍弃右侧。例如，在一元解析器组合器库中，`*>`将使用第一个解析器参数解析，但返回第二个。\n`Applicative`函数`<$>`和`<*>`由`monad`的`liftM`和`ap`概括。\n\n```haskell\nimport Control.Monad\nimport Control.Applicative\n\ndata C a b = C a b\n\nmnd :: Monad m => m a -> m b -> m (C a b)\nmnd a b = C `liftM` a `ap` b\n\napl :: Applicative f => f a -> f b -> f (C a b)\napl a b = C <$> a <*> b\n```\n\n請看: [Applicative Programming with Effects](http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf)\n\n### Alternative\n`Alternative`是`Applicative`类的一个扩展，它有一个零元素和一个与零相关的二进制操作。\n```haskell\nclass Applicative f => Alternative f where\n  -- | The identity of '<|>'\n  empty :: f a\n  -- | An associative binary operation\n  (<|>) :: f a -> f a -> f a\n  -- | One or more.\n  some :: f a -> f [a]\n  -- | Zero or more.\n  many :: f a -> f [a]\n\noptional :: Alternative f => f a -> f (Maybe a)\n\nwhen :: (Alternative f) => Bool -> f () -> f ()\nwhen p s = if p then s else return ()\n\nguard :: (Alternative f) => Bool -> f ()\nguard True  = pure ()\nguard False = mzero\ninstance Alternative Maybe where\n    empty = Nothing\n    Nothing <|> r = r\n    l       <|> _ = l\n\ninstance Alternative [] where\n    empty = []\n    (<|>) = (++)\nλ: foldl1 (<|>) [Nothing, Just 5, Just 3]\nJust 5\n```\n这些实例经常出现在解析器中，在解析器中，`alternative`运算符可以对`alternative`(可選擇的)解析分支建模。\n\n### Arrows\n`category`(范畴)是一种代数结构，它包括一个`identity`的概念和一个`associative`(结合)并`preserves`(保留/保存/维护)`identity`的组合操作。\n```haskell\nclass Category cat where\n  id :: cat a a\n  (.) :: cat b c -> cat a b -> cat a c\ninstance Category (->) where\n  id = Prelude.id\n  (.) = (Prelude..)\n(<<<) :: Category cat => cat b c -> cat a b -> cat a c\n(<<<) = (.)\n\n(>>>) :: Category cat => cat a b -> cat b c -> cat a c\nf >>> g = g . f\n```\n`Arrows`(箭头)是一個具有`products`(产品)概念的`categories`(范畴)的`extension`(延伸)。\n```haskell\nclass Category a => Arrow a where\n  arr :: (b -> c) -> a b c\n  first :: a b c -> a (b,d) (c,d)\n  second :: a b c -> a (d,b) (d,c)\n  (***) :: a b c -> a b' c' -> a (b,b') (c,c')\n  (&&&) :: a b c -> a b c' -> a b (c,c')\n```\n典型的例子是`functions`(函数)。\n```haskell\ninstance Arrow (->) where\n  arr f = f\n  first f = f *** id\n  second f = id *** f\n  (***) f g ~(x,y) = (f x, g y)\n```\n在这种形式中，多个参数的函数可以使用箭头组合符以更`point-free`的形式來實現。\n例如，`histogram`(直方图)函数具有很好的`one-liner`(单线)。\n```haskell\nimport Data.List (group, sort)\n\nhistogram :: Ord a => [a] -> [(a, Int)]\nhistogram = map (head &&& length) . group . sort\nλ: histogram \"Hello world\"\n[(' ',1),('H',1),('d',1),('e',1),('l',3),('o',2),('r',1),('w',1)]\n```\n#### Arrow notation (Arrow表示法)\n`GHC`有内置的语法使用`proc`表示法组合`arrows`(箭头)。在脫糖后，下列各项等效：\n```haskell\n{-# LANGUAGE Arrows #-}\n\naddA :: Arrow a => a b Int -> a b Int -> a b Int\naddA f g = proc x -> do\n                y <- f -< x\n                z <- g -< x\n                returnA -< y + z\naddA f g = arr (\\ x -> (x, x)) >>>\n           first f >>> arr (\\ (y, x) -> (x, y)) >>>\n           first g >>> arr (\\ (z, y) -> y + z)\naddA f g = f &&& g >>> arr (\\ (y, z) -> y + z)\n```\n实际上，这种符号并不经常使用，将来可能会被弃用。\n\n請看: [Arrow Notation](https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/arrow-notation.html)\n\n### Bifunctors\n`Bifunctors`是`functors`(函子)的一个`generalization`(推广/归纳)，它包含由两个参数参数化的类型，并且每个参数包含两个`map`函数。\n```haskell\nclass Bifunctor p where\n  bimap :: (a -> b) -> (c -> d) -> p a c -> p b d\n  first :: (a -> b) -> p a c -> p b c\n  second :: (b -> c) -> p a b -> p a c\n```\n`bifunctor`定律是`usual functor`(一般函子)的自然推广。也就是说，他们以`usual`(通常)的方式`respect`(遵守)`identities`(身份)和`composition`(构成):\n```haskell\nbimap id id ≡ id\nfirst id ≡ id\nsecond id ≡ id\nbimap f g ≡ first f . second g\n```\n典型的例子是`2-tuples`(2元组)。\n```haskell\nλ: first (+1) (1,2)\n(2,2)\nλ: second (+1) (1,2)\n(1,3)\nλ: bimap (+1) (+1) (1,2)\n(2,3)\n\nλ: first (+1) (Left 3)\nLeft 4\nλ: second (+1) (Left 3)\nLeft 3\nλ: second (+1) (Right 3)\nRight 4\n```\n\n### Polyvariadic Functions (多元函數)\n类型类的一个令人惊讶的应用是: 通过在函数类型上定义`instances`(实例)来构造接受任意数量参数的函数的能力。\n参数可以是任意类型，但是结果收集的参数必须转换为`single`(单一)类型或解包为`sum`类型。\n\n```haskell\n{-# LANGUAGE FlexibleInstances #-}\n\nclass Arg a where\n  collect' :: [String] -> a\n\n-- extract to IO\ninstance Arg (IO ()) where\n  collect' acc = mapM_ putStrLn acc\n\n-- extract to [String]\ninstance Arg [String] where\n  collect' acc = acc\n\ninstance (Show a, Arg r) => Arg (a -> r) where\n  collect' acc = \\x -> collect' (acc ++ [show x])\n\ncollect :: Arg t => t\ncollect = collect' []\n\nexample1 :: [String]\nexample1 = collect 'a' 2 3.0\n\nexample2 :: IO ()\nexample2 = collect () \"foo\" [1,2,3]\n```\n\n請看: [Polyvariadic functions](http://okmij.org/ftp/Haskell/polyvariadic.html)","tags":["Applicatives"]},{"title":"Haskell-Advanced-Monads","url":"/blog/2019/10/16/Haskell-Advanced-Monads/"},{"title":"Haskell-Monad-Transformers","url":"/blog/2019/10/16/Haskell-Monad-Transformers/","content":"\n### mtl / transformers\n所以，前一章对`Monads`的描述有点不可信。现代的`Haskell monad`库通常使用一种更通用的形式，用`monad transformers`来编写，它允许我们将`monad`合在一起形成复合`monad`。前面提到的`monad`被包含在由`Identity`单子组成的`transformer`形式的特例中。\n```haskell\nMonad\t| Transformer  |  Type\t      |  Transformed Type\n--------|--------------|--------------|---------------------\nMaybe\t| MaybeT\t   |  Maybe a\t  |  m (Maybe a)\nReader\t| ReaderT\t   |  r -> a\t  |  r -> m a\nWriter\t| WriterT\t   |  (a,w)\t      |  m (a,w)\nState\t| StateT\t   |  s -> (a,s)  |\t s -> m (a,s)\n```\n```haskell\ntype State  s = StateT  s Identity\ntype Writer w = WriterT w Identity\ntype Reader r = ReaderT r Identity\n\ninstance Monad m => MonadState s (StateT s m)\ninstance Monad m => MonadReader r (ReaderT r m)\ninstance (Monoid w, Monad m) => MonadWriter w (WriterT w m)\n```\n就通用性而言，`mtl`库是这些`monad`最常见的通用接口，它本身依赖于`transformers`库，该库将上述基本`monad`概括为`transformers`.\n\n### Transformers\n`monad transformers`的核心是使我们能够将`monadic`计算嵌套`stack`堆栈中，这个堆栈有一个接口，用於在`levels`(级别)之间交换值，称为`lift`。\n```haskell\nlift :: (Monad m, MonadTrans t) => m a -> t m a\nliftIO :: MonadIO m => IO a -> m a\nclass MonadTrans t where\n    lift :: Monad m => m a -> t m a\n\nclass (Monad m) => MonadIO m where\n    liftIO :: IO a -> m a\n\ninstance MonadIO IO where\n    liftIO = id\n```\n就像基本的`monad`类具有法律一样，`monad transformers`也具有一些法律:\n```haskell\nLaw #1\n\n    lift . return = return\n\nLaw #2\n\n    lift (m >>= f) = lift m >>= (lift . f)\n\n或等效地:\n\nLaw #1\n\n     lift (return x)\n\n    = return x\n\nLaw #2\n\n    do x <- lift m\n     lift (f x)\n\n    = lift $ do x <- m\n                f x\n```\n\n请记住，`transformers`是由`outside-in`(从外向内)组成的，但由`inside out`(内而外)展开，這很有用。\n\n請看: [Monad Transformers: Step-By-Step](http://catamorph.de/publications/2004-10-01-monad-transformers.html)\n\n### Basics\n最基本的使用要求我们为外层的每个`monad transformers`使用`T-variants`(变量)，并在层之间显式地`lift`和`return`值。\n\n`monad`的`kind`為`(* -> *)`,所以把`monad`转换成`monad`的`monad transformers`有`((* -> *) -> * -> *)`:\n```haskell\nMonad (m :: * -> *)\nMonadTrans (t :: (* -> *) -> * -> *)\n```\n因此，例如，如果我们想同时使用`Reader`和`Maybe`单子构成一个复合计算，我们现在可以将`Maybe`放在`ReaderT`内以形成`ReaderT t Maybe a`.\n```haskell\nimport Control.Monad.Reader\n\ntype Env = [(String, Int)]\ntype Eval a = ReaderT Env Maybe a\n\ndata Expr\n  = Val Int\n  | Add Expr Expr\n  | Var String\n  deriving (Show)\n\neval :: Expr -> Eval Int\neval ex = case ex of\n\n  Val n -> return n\n\n  Add x y -> do\n    a <- eval x\n    b <- eval y\n    return (a+b)\n\n  Var x -> do\n    env <- ask\n    val <- lift (lookup x env)\n    return val\n\nenv :: Env\nenv = [(\"x\", 2), (\"y\", 5)]\n\nex1 :: Eval Int\nex1 = eval (Add (Val 2) (Add (Val 1) (Var \"x\")))\n\nexample1, example2 :: Maybe Int\nexample1 = runReaderT ex1 env\nexample2 = runReaderT ex1 []\n```\n这种方法的基本局限性在于，我们发现我們有自己有很多的`lift.lift.lifting`和`return.return.returning`。\n\n\n### ReaderT\n例如，`Reader monad`存在三种可能形式。第一个是`Haskell 98`版本，该版本已不存在，但对于理解基本思想很有用。另外两个是`transformers`和`mtl`变体。\n```haskell\nReader\n\n    newtype Reader r a = Reader { runReader :: r -> a }\n\n    instance MonadReader r (Reader r) where\n    ask       = Reader id\n    local f m = Reader (runReader m . f)\n\nReaderT\n\n    newtype ReaderT r m a = ReaderT { runReaderT :: r -> m a }\n\n    instance (Monad m) => Monad (ReaderT r m) where\n    return a = ReaderT $ \\_ -> return a\n    m >>= k  = ReaderT $ \\r -> do\n        a <- runReaderT m r\n        runReaderT (k a) r\n\n    instance MonadTrans (ReaderT r) where\n        lift m = ReaderT $ \\_ -> m\n\nMonadReader\n\n    class (Monad m) => MonadReader r m | m -> r where\n        ask   :: m r\n        local :: (r -> r) -> m a -> m a\n\n    instance (Monad m) => MonadReader r (ReaderT r m) where\n        ask       = ReaderT return\n        local f m = ReaderT $ \\r -> runReaderT m (f r)\n```\n因此，假设`ask`的三个变体为:\n```haskell\nask :: Reader r r\nask :: Monad m => ReaderT r m r\nask :: MonadReader r m => m r\n```\n实际上，现代`Haskell`仅使用最后一个。\n\n### Newtype Deriving\n通过`Newtypes`，我们可以引用具有单个构造函数的数据类型作为新的`distinct`(独特/不同)类型，而装箱不会增加运行时间，这与具有单个构造函数的代数数据类型不同。\n`around`(圍繞)字符串和数字类型的`Newtype`包装器通常可以大大减少意外错误。\n\n考虑使用`newtype`区分具有不同语义的两个不同文本`Blob`的情况。\n两者都具有与`text`(文本)对象相同的运行时表示形式，但都是`distinguished statically`(静态区分)的，\n这样明文就不会意外地与加密文本互换。\n```haskell\nnewtype Plaintext = Plaintext Text\nnewtype Crytpotext = Cryptotext Text\n\nencrypt :: Key -> Plaintext -> Cryptotext\ndecrypt :: Key -> Cryptotext -> Plaintext\n```\n另一个常见的用例是使用`newtypes`来派生逻辑，以在我们的业务逻辑中派生自定义`monad transformers`。\n使用`-XGeneralizedNewtypeDeriving`，我们可以恢复在我们的`transformer`堆栈中组成的底层类型的实例的函數。\n```haskell\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\nnewtype Velocity = Velocity { unVelocity :: Double }\n  deriving (Eq, Ord)\n\nv :: Velocity\nv = Velocity 2.718\n\nx :: Double\nx = 2.718\n\n-- Type error is caught at compile time even though\n-- they are the same value at runtime!\nerr = v + x\n\nnewtype Quantity v a = Quantity a\n  deriving (Eq, Ord, Num, Show)\n\ndata Haskeller\ntype Haskellers = Quantity Haskeller Int\n\na = Quantity 2 :: Haskellers\nb = Quantity 6 :: Haskellers\n\ntotalHaskellers :: Haskellers\ntotalHaskellers = a + b\nCouldn't match type `Double' with `Velocity'\nExpected type: Velocity\n  Actual type: Double\nIn the second argument of `(+)', namely `x'\nIn the expression: v + x\n```\n将`newtype deriving`与`mtl`库类型类一起使用，我们可以生成不需要在`transform`(转换器)堆栈中显式提升的`flattened transformer`(扁平转换器)类型。例如，这里有一个小的`stack machine`(堆栈机)，它包含了`Reader, Writer, State monad`。\n```haskell\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\nimport Control.Monad.Reader\nimport Control.Monad.Writer\nimport Control.Monad.State\n\ntype Stack   = [Int]\ntype Output  = [Int]\ntype Program = [Instr]\n\ntype VM a = ReaderT Program (WriterT Output (State Stack)) a\n\nnewtype Comp a = Comp { unComp :: VM a }\n  deriving (Monad, MonadReader Program, MonadWriter Output, MonadState Stack)\n\ndata Instr = Push Int | Pop | Puts\n\nevalInstr :: Instr -> Comp ()\nevalInstr instr = case instr of\n  Pop    -> modify tail\n  Push n -> modify (n:)\n  Puts   -> do\n    tos <- gets head\n    tell [tos]\n\neval :: Comp ()\neval = do\n  instr <- ask\n  case instr of\n    []     -> return ()\n    (i:is) -> evalInstr i >> local (const is) eval\n\nexecVM :: Program -> Output\nexecVM = flip evalState [] . execWriterT . runReaderT (unComp eval)\n\nprogram :: Program\nprogram = [\n     Push 42,\n     Push 27,\n     Puts,\n     Pop,\n     Puts,\n     Pop\n  ]\n\nmain :: IO ()\nmain = mapM_ print $ execVM program\n```\n在`newtype`构造函数上的模式匹配不会编译成任何东西.\n例如，`extractB`函数不会像`extractA`那样仔细检查`MkB`构造函数，\n因为`MkB`在运行时不存在，所以它纯粹是一个编译时结构。\n```haskell\ndata A = MkA Int\nnewtype B = MkB Int\n\nextractA :: A -> Int\nextractA (MkA x) = x\n\nextractB :: B -> Int\nextractB (MkB x) = x\n```\n\n### Efficiency (效率)\n第二个`monad transformer`法则保证连续的`lift`(提升)操作的`sequencing`(顺序)在语义上等同于将结果提升到外部`monad`中。\n```haskell\ndo x <- lift m  ==  lift $ do x <- m\n   lift (f x)                 f x\n```\n\n虽然它们可以保证得到相同的结果，但是在使用`monad traversal and looping`(遍历和循环)函数时，在`monad`级别之间`lift`(提升)结果的操作并不是没有代价的，而且经常会出现。\n例如，下面左侧的所有三个函数的效率都低于右侧，后者在基本`monad`中执行绑定，而不是在每次迭代时都进行`lift`(提升)。\n```haskell\n-- Less Efficient      More Efficient\nforever (lift m)    == lift (forever m)\nmapM_ (lift . f) xs == lift (mapM_ f xs)\nforM_ xs (lift . f) == lift (forM_ xs f)\n```\n\n### Monad Morphisms (单子态射)\n基本的`monad transformer`程序包提供了一个`MonadTrans`类，用于提升到另一个`monad`:\n```haskell\nlift :: Monad m => m a -> t m a\n```\n但是通常我们需要与`monad transformer`堆栈一起工作和操作，以产生新的`transformer`，修改现有的`transformers`或用新的`layers`(层)扩展上游库。`mmorph`库提供了直接在`transformer`堆栈上构成`monad morphism transformation`(形态变换)的功能。\n等效的变压器类型等级映射是“提升”功能。\n等效的`type transformer`(类型转换器)`type-level`映射是`hoist`功能.\n```haskell\nhoist :: Monad m => (forall a. m a -> n a) -> t m b -> t n b\n```\n`Hoist`接收`monad`态射(从`m a`到`n a`的映射)并应用于变压器堆栈的内部值`monad`，从而转换外层下的值.\n`monad morphism`(态射)`generalize`将一个`Identity`单子带入任何其他单子`monad m`.\n```haskell\ngeneralize :: Monad m => Identity a -> m a\n```\n例如，它将`State s a`(即`StateT s Identity a`)概括为`StateT s a`.\n因此，我们可以`generalize`(概括)一个现有的`transformer`以在其上`lift`(提升)一個`IO`层。\n```haskell\nimport Control.Monad.State\nimport Control.Monad.Morph\n\ntype Eval a = State [Int] a\n\nrunEval :: [Int] -> Eval a -> a\nrunEval = flip evalState\n\npop :: Eval Int\npop = do\n  top <- gets head\n  modify tail\n  return top\n\npush :: Int -> Eval ()\npush x = modify (x:)\n\nev1 :: Eval Int\nev1 = do\n  push 3\n  push 4\n  pop\n  pop\n\nev2  :: StateT [Int] IO ()\nev2 = do\n  result <- hoist generalize ev1\n  liftIO $ putStrLn $ \"Result: \" ++ show result\n```\n請看: [mmorph](https://hackage.haskell.org/package/mmorph)\n","tags":["Monad-Transformers"]},{"title":"Haskell-Monads","url":"/blog/2019/10/16/Haskell-Monads/","content":"\n### Eightfold Path to Monad Satori (通往Monad Satori的八重路)\n关于所谓的`monads`的奥秘，抒情诗已经大量涌出。相反，我建议一个启发之路:\n* 不要读`monad`教程。\n* 不，真的，不要读`monad`的教程。\n* 學習[Haskell types](http://book.realworldhaskell.org/read/types-and-functions.html)\n* 学习什么是`typeclass`(类型类)。\n* 阅读[Typeclassopedia](http://wiki.haskell.org/Typeclassopedia)。\n* 阅读`monad`的定义。\n* 在代码中使用`monads`。\n* 不要写`monad`类比教程。\n\n换句话说，了解`monad的`唯一途径是阅读好的源代码，启动`GHC`并编写一些代码。 类比和隐喻不会导致理解。\n\n### Monadic Myths(神話)\n以下均为`false`:\n* `Monads`是不纯的。\n* `Monads`是关于`effects`(效果)的。\n* `Monads`是关于状态的。\n* `Monads`与命令式排序有关。\n* `Monads`与`IO`有关。\n* `Monads`依赖懒惰。\n* `Monads`是该语言的后门，可以产生副作用。\n* `Monads`是`Haskell`内部的嵌入式命令式语言。\n* `Monads`需要了解抽象数学。\n* `Monads`是`Haskell`独有的。\n\n請看: [What a Monad Is Not](http://wiki.haskell.org/What_a_Monad_is_not)\n\n### Monadic Methods\n`Monads`并不复杂。它们被实现为具有兩個方法的`typeclass`: `return`和`(>=)`(发音为`bind`)。\n\n为了实现`monad`实例，这两个函数必须根据`typetype`定义中描述的一致性进行定义：\n\n```haskell\n-- 'm'指实现 Monad typeClass 的类型构造函数(例如: Maybe,Either等)\nclass Monad m where\n  return :: a -> m a\n  (>>=)  :: m a -> (a -> m b) -> m b\n```\n`Monad`类定义中的第一个类型签名是用于`return`的。\n\n对于`return`一词可能有的任何先入之见都应该丢弃: 它在`Haskell`的上下文中具有完全不同的含义，并且与`C`，`Python`或`Java`等语言的行为截然不同。\n在`Haskell`中，`return`不是函数产生什么值的最终仲裁者，而是将类型为`a`的值注入到`monadic`上下文语境(例如`Maybe`，`Either`等)中，表示为`m a`。\n\n实现`Monad`实例的另一个重要函數是`(>>=)`。\n此中缀操作符有两个参数。\n在其左侧是类型为`m a`的值，而在右侧是类型为`(a -> m b)`的函数。`bind`(绑定)操作得出的最终值类型为`m b`。\n\n第三个辅助函数(`(>>)`)是根据放弃其参数的绑定操作定义的。\n```haskell\n(>>) :: Monad m => m a -> m b -> m b\nm >> k = m >>= \\_ -> k\n```\n这个定义是说`(>>)`有一個`left`和`right`參數，它们分别是类型为`m a`和`m b`的单子数，而中缀操作符返回类型为`m b`的值。\n\n`(>>)`的实际实现表示，当将`m`传递到带有`k`的右侧的`(>>)`时，将始终返回值`k`。\n\n### Laws\n除了`(>>=)`和`return`的特定实现之外，所有`monad`实例还必须满足三个定律。\n\n#### Law 1\n第一定律说，当将`(return a)`通过`(>>=)`传递给函数`f`时，该表达式与`f a`完全等效。\n```haskell\nreturn a >>= f ≡ f a  -- 'a'是指值，而不是类型\n```\n在讨论下两个定律时，我们将提到一个值`m`。\n这个符号是包装在`monadic`上下文中的值的简写。这样的值具有`m a`类型，可以更具体地用`Nothing`、`Just x`或`Right x`等值来表示。\n需要注意的是，这些值`m`的具体实例化中有一些包含多个组件。在讨论第二和第三单子定律时，我们将看到一些例子来说明这一点。\n\n#### Law 2\n第二定律指出，通过`(>>=)`传递给`return`的`monadic`值`m`与其自身完全等效。\n换句话说，使用`bind`将`monadic`值传递给`return`不会改变初始值。\n```haskell\nm >>= return ≡ m  -- 'm'是指类型为'm a'的值\n```\n存在一种更明确的写第二条`Monad`定律的方法。在下面的示例代码中，第一个表达式显示了第二定律如何应用于由[non-nullary](https://wiki.haskell.org/Constructor#Type_constructor)类型构造函数表示的值。第二个片段显示了由`nullary`类型构造函数表示的值在第二定律的上下文中如何工作。\n```haskell\n(SomeMonad val) >>= return ≡ SomeMonad val  -- 'SomeMonad val'具有类型'm a'，就像`Law 2`第一个示例中的`m`一样\n\nNullaryMonadType >>= return ≡ NullaryMonadType\n```\n\n#### Law 3\n虽然前两条法律比较明确，但第三条法律可能更难理解。\n\n这条定律规定，当一个`monadic`值`m`通过`(>>=)`传递给函数`f`，然后將该表达式的结果传递给`>>=g`時，\n整个表达式完全等同于将`m`传递给一个`lambda`表达式，该`lambda`表达式接受一个参数`x`，并产出应用于`x`的函数`f`。\n根据`bind`的定义，`f x`必须返回包装在同一个`monad`中的值。由于此属性，该表达式的结果值可以通过`(>>=)`传递给函数`g`，该函数也返回一个`monadic`值。\n```haskell\n-- 'm'的类型为'm a'\n-- 函数'f'和'g'类型分别為'(a -> m b)'和'(b -> m c)'\n(m >>= f) >>= g ≡ m >>= (\\x -> f x >>= g)\n```\n同样，可以用更明确的代码编写该定律。就像在`Law 2`的明确示例中一样，`m`已由`SomeMonad val`代替，以非常清楚地表明，`monadic`值可以有多个`components`(分量)。\n尽管代码中的变化很小，但是更容易看到值(即`val`)与`lambda`表达式中的`x`对应。在将`(SomeMonad val)`通过`(>>=)`传递给`f`之后，函数`f`在`val`上运行，并返回仍封装在`SomeMonad`类型构造函数中的结果。\n\n我们可以将此新值称为`SomeMonad newVal`。由于它仍然包裹在`monad`上下文中，因此可以将`SomeMonad newVal`通过绑定操作传递到函数`g`中。\n\n```haskell\n((SomeMonad val) >>= f) >>= g ≡ (SomeMonad val) >>= (\\x -> f x >>= g)\n```\n\n請看: [Monad Laws](http://wiki.haskell.org/Monad_laws)\n\n### Do Notation (Do表示法)\nhaskell中的`Monadic`语法是以加糖的形式编写的，称为`do`符号。这种特殊语法的优点是它更容易编写，并且完全等同于`monad`操作的应用程序。根据以下规则递归定义脫糖:\n```haskell\n-- 将'f'绑定到a，然后继续对'm'进行脱糖\ndo { a <- f ; m } ≡ f >>= \\a -> do { m }  \n\n-- 评估`f`，然后继续对'm'进行脱糖\ndo { f ; m } ≡ f >> do { m }\n\ndo { m } ≡ m\n```\n因此，通过应用脱糖规则，以下表达式是等效的:\n```haskell\ndo\n  -- 將f,g和h分別绑定到名称a，b和c。\n  -- 然后将这些名称传递给`return`,\n  -- 以确保所有值都包裹在适当的monad上下文中\n  a <- f\n  b <- g\n  c <- h\n  return (a, b, c)\n\ndo {\n    -- 注意: {}和;字符在do符号中很少使用\n    a <- f;\n    b <- g;\n    c <- h;\n    return (a, b, c)\n}\n\nf >>= \\a ->\n  g >>= \\b ->\n    h >>= \\c ->\n      return (a, b, c)\n```\n如果将`bind`运算符写为`uncurried`(非咖喱)函数（这不是`Haskell`使用它的方式），则相同的`desugaring`操作可能看起来像以下带有`lambda`的嵌套绑定链。\n```haskell\nbindMonad(f, lambda a:\n  bindMonad(g, lambda b:\n    bindMonad(h, lambda c:\n      returnMonad (a,b,c))))\n```\n在`do-notation`中，上面的[monad laws](http://dev.stephendiehl.com/hask/#laws)等效地写成:\n```haskell\n-- Law 1\n\n  do y <- return x\n     f y\n\n= do f x\n\n-- Law 2\n\n  do x <- m\n     return x\n\n= do m\n\n-- Law 3\n\n  do b <- do a <- m\n             f a\n     g b\n\n= do a <- m\n     b <- f a\n     g b\n\n= do a <- m\n     do b <- f a\n        g b\n```\n請看: [Haskell 2010: Do Expressions](http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14)\n\n### Maybe\n`Maybe monad`是`monad`实例的最简单的第一个示例。`Maybe monad`對计算进行建模，该计算可能在计算过程中的任何时候失敗，无法产生值。\n\n`Maybe`类型具有两个值构造函数。第一个`Just`是一个表示成功计算的一元构造函数，第二个`Nothing`是一个表示失败的`nullary`(无效)构造函数。\n```haskell\ndata Maybe a = Nothing | Just a\n```\n`Maybe`的`monad`实例通过:在可能传递给`bind`操作的可能输入上(即`Nothing`或`Just x`)进行模式匹配来描述`Maybe`的`(>>=)`实现。\n\n該实例声明还提供了`return`的实现，在这种情况下，它只是`Just`。\n\n```haskell\ninstance Monad Maybe where\n    -- 'k'是一個具有(a -> Maybe a)類型的函數\n    (Just x) >>= k = k x\n    Nothing  >>= k = Nothing\n    -- Just的类型签名是(a -> Maybe a)\n    -- 换句话说，与上面的typeclass声明中的·return·类型极为相似。\n    return = Just\n```\n以下代码显示了在`Maybe monad`中执行的一些简单操作。\n\n在第一个示例中，值`Just 3`通过`(>>=)`传递给lambda函数`\\x -> return（x + 1)`。\n`x`是指`Just 3`的`Int`部分，我们可以在`lambda`表达式的后半部分使用`x`，其中`return (x + 1)`的值等于`Just 4`，表示一個成功的计算。\n```haskell\n(Just 3) >>= (\\x -> return (x + 1))\n-- Just 4\n```\n在第二个示例中，值`Nothing`通过`(>>=)`传递到与上一个示例相同的`lambda`函数。\n但是，根据`Maybe Monad`实例，每当`Nothing`绑定到一个函数时，表达式的结果将为`Nothing`。\n```haskell\nNothing >>= (\\x -> return (x + 1))\n-- Nothing\n```\n下一個例子中，將`return`應用到`4`,並返回`Just 4`.\n```haskell\nreturn 4 :: Maybe Int\n-- Just 4\n```\n下面的代码示例演示在`Maybe monad`中使用`do`表示法进行可能失败的加法运算。还提供了脫糖的示例。\n```haskell\nexample1 :: Maybe Int\nexample1 = do\n  a <- Just 3    -- Bind 3 to name a\n  b <- Just 4    -- Bind 4 to name b\n  -- 评估(a + b)，\n  -- 然后使用'return'以确保结果在Maybe monad中，\n  -- 以便满足类型签名\n  return $ a + b  -- Just 7\n\n-- 這是脫糖操作，等同於example1\ndesugared1 :: Maybe Int\ndesugared1 = Just 3 >>= \\a ->\n               Just 4 >>= \\b ->\n                 return $ a + b  -- Just 7\n\n\nexample2 :: Maybe Int\nexample2 = do\n  a <- Just 3   -- Bind 3 to name a\n  b <- Nothing  -- Bind Nothing to name b\n  -- 由於Maybe monad中的加法实际上可以返回'Nothing',这个结果可能有些令人惊讶\n  -- 出现此结果是因为其中一个值Nothing指示计算失败。\n  -- 由于计算在过程中的某一步失败，因此整个计算失败，最终结果为'Nothing'。\n  return $ a + b  -- Nothing\n\n-- 這是脫糖操作，等同於example2\ndesugared2 :: Maybe Int\ndesugared2 = Just 3 >>= \\a ->\n               Nothing >>= \\b ->\n                  return $ a + b\n-- Nothing\n```\n\n### List\n`List monad`是`monad`实例的第二个最简单的示例。和往常一样，此`monad`同时实现`(>>=)`和`return`。\n`bind`的定义是，当列表`m`绑定到函数`f`时，结果是`map f`在列表`m`上的`concatenation`(串联)。\n`return`方法仅取一个值`x`并注入一个`singleton`列表`[x]`.\n\n```haskell\ninstance Monad [] where\n  m >>= f   =  concat (map f m)  -- 'm' is a list\n  return x  =  [x]\n```\n为了演示`List monad`的方法，我们将定义两个函数:`m`和`f`。\n`m`是一个简单列表，而`f`是一个函数，它接收单个`Int`參數并返回擁有兩個元素的列表`[1，0]`。\n```haskell\nm :: [Int]\nm = [1,2,3,4]\n\nf :: Int -> [Int]\nf = \\x -> [1,0]\n```\n评估过程如下:\n```haskell\nm >>= f\n==> [1,2,3,4] >>= \\x -> [1,0]\n==> concat (map (\\x -> [1,0]) [1,2,3,4])\n==> concat ([[1,0],[1,0],[1,0],[1,0]])\n==> [1,0,1,0,1,0,1,0]\n```\nHaskell中的列表`comprehension`语法可以根据列表`monad`来实现。\n对于更明显的`monadic`实现，列表`comprehension`可以被视为语法糖。\n示例`a`和`b`说明了这些用例。\n\n第一个示例(`a`)说明了如何编写列表`comprehension`。\n尽管语法一开始看起来很奇怪，但其中的某些元素可能看起来很熟悉。\n例如，`<-`的用法就像在`do`表示法中的`bind`(绑定): 它将列表的元素绑定到名称。\n\n但是，有一个主要区别是显而易见的：例子`a`似乎缺少对`return`的调用。不过，不用担心，`[]`扮演了这个角色。编译器可以轻松地将此语法脫糖为显式调用`return`。此外，它还可以提醒用户该计算是在`List monad`中进行的。\n```haskell\na = [\n      f x y |   -- 对应于示例b中的'f x y'\n      x <- xs,\n      y <- ys,\n      x == y     -- 对应于示例b中的'guard $ x == y'\n    ]\n```\n第二个示例(`b`)显示了用`do`表示符重写的列表`comprehension`:\n```haskell\n-- 与a相同\nb = do\n  x <- xs\n  y <- ys\n  guard $ x == y  -- 对应于示例a中的'x == y'\n  return $ f x y  -- 对应于示例a中的'[]' and 'f x y'\n```\n最后的例子是`List`单子的进一步说明。\n每个函数下面都返回一个三元组列表，其中包含三个列表的可能组合，这三个列表绑定了名称`a`,`b`和`c`。\n注意: 在元组的`a`位置只能使用绑定到`a`的列表中的值; 对于绑定到`b`和`c`的列表也是如此。\n```haskell\nexample :: [(Int, Int, Int)]\nexample = do\n  a <- [1,2]\n  b <- [10,20]\n  c <- [100,200]\n  return (a,b,c)\n-- [(1,10,100),(1,10,200),(1,20,100),(1,20,200),(2,10,100),(2,10,200),(2,20,100),(2,20,200)]\n\ndesugared :: [(Int, Int, Int)]\ndesugared = [1, 2] >>= \\a ->\n              [10, 20] >>= \\b ->\n                [100, 200] >>= \\c ->\n                  return (a, b, c)\n-- [(1,10,100),(1,10,200),(1,20,100),(1,20,200),(2,10,100),(2,10,200),(2,20,100),(2,20,200)]\n```\n\n### IO\n`IO`可能是`Haskell中`最著名的例子(一种`monad`)。\n\n`IO a`类型的值是一种计算，当执行时，它会在返回`a`类型的值之前执行一些`I/O`。这些计算称为`actions`(动作)。\n在`main`中执行的`IO`动作是程序可以在外部世界上操作或访问信息的方式。`IO`操作使程序可以执行许多操作，包括但不限于:\n* 将字符串打印到终端\n* 从终端读取和分析输入\n* 读取或写入系统上的文件\n* 建立到远程计算机的ssh连接\n* 从无线电天线接收信号进行处理\n\n将`I/O`概念化为`monad`，使开发人员可以访问程序外部的信息，但可以使用纯函數对数据进行操作。以下示例将说明我们如何使用`IO`操作和`IO`值来接收来自`stdin`的输入并将其打印到`stdout`。\n\n在`Haskell`中执行`I/O`的最直接有用的功能可能是`putStrLn`。此函数接收`String`并返回`IO ()`。\n在`main`中调用它將会把`String`打印到`stdout`，后跟换行符。\n\n```haskell\nputStrLn :: String -> IO ()\n```\n这是一些向终端打印內容的代码。执行`putStrLn`的第一次调用，导致将`String`打印到`stdout`。其结果绑定到丢弃其参数的`lambda`表达式，然后执行下一个`putStrLn`。\n```haskell\nmain :: IO ()\nmain = putStrLn \"Vesihiisi sihisi hississäään.\" >>=\n         \\_ -> putStrLn \"Or in English: 'The water devil was hissing in her elevator'.\"\n\n-- Sugared code, written with do notation\nmain :: IO ()\nmain = do putStrLn \"Vesihiisi sihisi hississäään.\"\n          putStrLn \"Or in English: 'The water devil was hissing in her elevator'.\"\n```\n另一个有用的函数是`getLine`，其类型为`IO String`。此函数从`stdin`获取一行输入。然后，开发人员可以将此行绑定到名称，以便对程序中的值进行操作。\n```haskell\ngetLine :: IO String\n```\n下面的代码演示了这两个函數的简单组合以及简化的`IO`代码。首先，`putStrLn`将一个`String`打印到`stdout`，要求用户提供其名称，结果绑定到一个`lambda`上，该`lambda`放弃它的参数。然后，执行`getLine`，向用户提供输入其名称的提示。接下来，将所得的`IO`字符串绑定到`name`，并传递给`putStrLn`。最后，程序将名称打印到终端。\n```haskell\nmain :: IO ()\nmain = do putStrLn \"What is your name: \"\n          name <- getLine\n          putStrLn name\n```\n下面代码块是上一个示例的经过脫糖的等效代码: 但是，`(>>=)`的使用是明确的:\n```haskell\nmain :: IO ()\nmain = putStrLn \"What is your name:\" >>=\n       \\_    -> getLine >>=\n       \\name -> putStrLn name\n```\n最后一个示例的执行方式与前两个示例相同。但是，此示例使用特別的`(>>)`运算符代替将结果绑定到丢弃其参数的`lambda`。\n```haskell\nmain :: IO ()\nmain = putStrLn \"What is your name: \" >> (getLine >>= (\\name -> putStrLn name))\n```\n請看: [Haskell 2010: Basic/Input Output](http://www.haskell.org/onlinereport/haskell2010/haskellch7.html)\n\n### What's the point? (有什么意义?)\n虽然很难（如果不是不可能的话）, 去接触、查看或以其他方式与`monad`进行物理交互，但是这个结构对程序员有一些非常有趣的含义。例如，考虑非直观的事实，我们现在有一个`uniform`(统一)的接口来讨论三种非常不同的，但基本的编程思想: `Failure`,`Collections`和`Effects`.\n\n让我们写下一个名为`sequence`的新函数，它`folds`(折叠)函數`mcons`到单子计算`list`上.\n我们可以认为`mcons`类似于列表构造函数(即`(a:b:[])`)，但它通过`bind`从两个`monadic`值`(p，q)`中提取两个列表元素.\n然後，将绑定值与列表构造器`:`联接在一起，最后再通过`return`在适当的单子上下文中重新包装。\n```haskell\nsequence :: Monad m => [m a] -> m [a]\nsequence = foldr mcons (return [])\n\n-- \nmcons :: Monad m => m t -> m [t] -> m [t]\nmcons p q = do\n  x <- p  -- 'x'表示单個值, [m a]中的每個值將會傳遞給p\n  y <- q  -- 初始值,m []\n  -- y是列表,因此,可以在其前面加上x\n  return (x:y)\n```\n就上述每个单子而言，此函數有什麼意义？\n\n#### Maybe\n在[Maybe context](http://dev.stephendiehl.com/hask/#maybe)中对值列表进行`Sequencing`使我们能够收集可能会失败的一系列计算的结果。但是，`sequence`仅在每次计算成功时才产生`aggregated`(合计)值。换句话说，即使传递给`sequence`的初始列表中的`Maybe`值之一是`Nothing`，`sequence`的结果也将是`Nothing`.\n```haskell\nsequence :: [Maybe a] -> Maybe [a]\nsequence [Just 3, Just 4] -- Just [3,4]\n\n-- 由于结果之一为Nothing，因此整个计算失败\nsequence [Just 3, Just 4, Nothing] -- Nothing\n```\n#### List\n[list monad](http://dev.stephendiehl.com/hask/#list)的`bind`操作形成两个操作数中元素的成对列表。\n因此，将`mcons`中包含的绑定`folding`(折叠)到具有`sequence`的列表列表上，可以实现任意数量列表的通用笛卡尔积。\n```haskell\nsequence :: [[a]] -> [[a]]\nsequence [[1,2,3],[10,20,30]]\n-- [[1,10],[1,20],[1,30],[2,10],[2,20],[2,30],[3,10],[3,20],[3,30]]\n```\n\n#### IO\n在[IO context](http://dev.stephendiehl.com/hask/#io)上下文中应用`sequence`仍然会产生不同的结果。函数获取`IO actions`的列表，按顺序执行这些操作，然后按顺序返回结果值的列表。\n```haskell\nsequence :: [IO a] -> IO [a]\nsequence [getLine, getLine, getLine]\n-- a\n-- b\n-- 9\n-- [\"a\", \"b\", \"9\"] 所有输入作为IO [String]返回到列表中.\n```\n因此，我们有了它，通常彼此独立定义的三个基本计算概念(`Failure`,`Collections`和`Effects`)实际上都共享这种相似的结构。可以对这种统一模式进行抽象，然后将其重复使用以构建适用于所有当前和将来实现的更高抽象。如果您想要了解`monad`的动机，就是这样！这些见解是我所希望知道的关于`monad`回顾的本质。\n\n請看: [Control.Monad](http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#g:4)\n\n### Reader Monad\n`reader monad`允許我们可以在`monadic`上下文中访问共享的不可变状态。\n```haskell\nask :: Reader r r\nasks :: (r -> a) -> Reader r a\nlocal :: (r -> r) -> Reader r a -> Reader r a\nrunReader :: Reader r a -> r -> a\nimport Control.Monad.Reader\n\ndata MyContext = MyContext\n  { foo :: String\n  , bar :: Int\n  } deriving (Show)\n\ncomputation :: Reader MyContext (Maybe String)\ncomputation = do\n  n <- asks bar\n  x <- asks foo\n  if n > 0\n    then return (Just x)\n    else return Nothing\n\nex1 :: Maybe String\nex1 = runReader computation $ MyContext \"hello\" 1\n\nex2 :: Maybe String\nex2 = runReader computation $ MyContext \"haskell\" 0\n```\n`Reader monad`的簡單實現:\n```haskell\nnewtype Reader r a = Reader { runReader :: r -> a }\n\ninstance Monad (Reader r) where\n  return a = Reader $ \\_ -> a\n  m >>= k  = Reader $ \\r -> runReader (k (runReader m r)) r\n\nask :: Reader a a\nask = Reader id\n\nasks :: (r -> a) -> Reader r a\nasks f = Reader f\n\nlocal :: (r -> r) -> Reader r a -> Reader r a\nlocal f m = Reader $ runReader m . f\n```\n\n### Writer Monad\n`writer monad`使我们能够从`monadic`上下文中`emit`(發出)懒惰的值流。\n```haskell\ntell :: w -> Writer w ()\nexecWriter :: Writer w a -> w\nrunWriter :: Writer w a -> (a, w)\nimport Control.Monad.Writer\n\ntype MyWriter = Writer [Int] String\n\nexample :: MyWriter\nexample  = do\n  tell [1..3]\n  tell [3..5]\n  return \"foo\"\n\noutput :: (String, [Int])\noutput = runWriter example\n-- (\"foo\", [1, 2, 3, 3, 4, 5])\n```\n`Writer monad`的簡單實現:\n```haskell\nimport Data.Monoid\n\nnewtype Writer w a = Writer { runWriter :: (a, w) }\n\ninstance Monoid w => Monad (Writer w) where\n  return a = Writer (a, mempty)\n  m >>= k  = Writer $ let\n      (a, w)  = runWriter m\n      (b, w') = runWriter (k a)\n      in (b, w `mappend` w')\n\nexecWriter :: Writer w a -> w\nexecWriter m = snd (runWriter m)\n\ntell :: w -> Writer w ()\ntell w = Writer ((), w)\n```\n这个实现是懒惰的，因此必须注意，实际上只想生成一个`thunk`流。大多数情况下，`lazy writer`不适合使用，而是通过在`StateT monad`中嵌入一些`monomial`(单值/单项式的)对象或使用严格版本来实现等效结构。\n```haskell\nimport Control.Monad.Writer.Strict\n```\n\n### State Monad\n`State monad`允许有状态`monadic`上下文中的函数访问和修改共享状态。\n```haskell\nrunState  :: State s a -> s -> (a, s)\nevalState :: State s a -> s -> a\nexecState :: State s a -> s -> s\nimport Control.Monad.State\n\ntest :: State Int Int\ntest = do\n  put 3\n  modify (+1)\n  get\n\nmain :: IO ()\nmain = print $ execState test 0\n```\n状态`monad`常常被错误地描述为不纯净，但事实上它是完全纯净的，通过显式传递状态也可以达到同样的效果。`State monad`的简单实现只需要几行代码:\n```haskell\nnewtype State s a = State { runState :: s -> (a,s) }\n\ninstance Monad (State s) where\n  return a = State $ \\s -> (a, s)\n\n  State act >>= k = State $ \\s ->\n    let (a, s') = act s\n    in runState (k a) s'\n\nget :: State s s\nget = State $ \\s -> (s, s)\n\nput :: s -> State s ()\nput s = State $ \\_ -> ((), s)\n\nmodify :: (s -> s) -> State s ()\nmodify f = get >>= \\x -> put (f x)\n\nevalState :: State s a -> s -> a\nevalState act = fst . runState act\n\nexecState :: State s a -> s -> s\nexecState act = snd . runState act\n```\n\n### Monad Tutorials\n已经编写了这么多`monad`教程，以至于产生了一个问题：什么使`monads`在初学`Haskell`时如此困难？我认为这是三个方面的原因:\n\n* 1.关于脱糖的间接作用有几个层次(`There are several levels on indirection with desugaring.`)。\n\n  我们所写的许多`haskell`代碼都经过了彻底的重新编排，并在幕后转化为一种全新的形式。\n  大多数`monad`教程不会手动展开`do-sugar`。\n  这使得初学者认为`monad`是一种在代码中嵌入伪命令式语言的方法，并进一步助长了这样一种误解，即像`IO`这样的特定实例在其`full generality`(全部方面)都是`monad`。\n  ```haskell\n  main = do\n    x <- getLine\n    putStrLn x\n    return ()\n  ```\n  能够手动脱糖对理解至关重要。\n  ```hhaskell\n  main =\n    getLine >>= \\x ->\n      putStrLn x >>= \\_ ->\n        return ()\n  ```\n\n* 2.用于高阶函数的非对称二进制中缀运算符在其他语言中并不常见。\n  ```haskell\n  (>>=) :: Monad m => m a -> (a -> m b) -> m b\n  ```\n  在运算符的左侧，我们有一个`m a`，在右侧，我们有`a -> m b`。尽管某些语言确实具有中缀运算符，而这些运算符本身就是高阶函数，但这种情况仍然很少见。\n\n  因此，对于一个已脫糖的函数,`(>>=)`运算符实际上是通过将函数组合在一起来构建一个更大的函数，这可能会令人困惑。\n  ```haskell\n  main =\n    getLine >>= \\x ->\n      putStrLn >>= \\_ ->\n        return ()\n  ```\n  以前缀形式编写，它变得更易于消化。\n  ```haskell\n  main =\n    (>>=) getLine (\\x ->\n      (>>=) putStrLn (\\_ ->\n            return ()\n      )\n    )\n  ```\n  也许从其他语言中完全删除操作符可能更直观。\n  ```haskell\n  main = bind getLine (\\x -> bind putStrLn (\\_ -> return ()))\n    where\n      bind x y = x >>= y\n  ```\n\n* 3.`Ad-hoc`(特定)多态性在其他语言中并不常见。\n\n  如果不熟悉类型推断，`Haskell`的重载实现可能是不直观的。它是从用户那里抽象出来的，但是`(>>=)`或`bind`函数实际上是三个参数的函数，带有额外的`typeclass dictionary`参数(`$dMonad`)隐式地缠绕在周围。\n  ```haskell\n  main $dMonad = bind $dMonad getLine (\\x -> bind $dMonad putStrLn (\\_ -> return $dMonad ()))\n  ```\n  除非`monad`类的参数与一个具体的类实例`unified`(统一)(通过`inference`推理)，否则`instance dictionary ($dMonadIO)`会被整个拼接在一起。\n  ```haskell\n  main :: IO ()\n  main = bind $dMonadIO getLine (\\x -> bind $dMonadIO putStrLn (\\_ -> return $dMonadIO ()))\n  ```\n\n现在，所有这些转换都是微不足道的，一旦我们理解了它们，它们通常不会被讨论。\n在我看来，`monad`教程的基本谬误并不是说`monad`的直觉很难传达(也不需要隐喻!)但是，新手们经常在对点(1)(2)和(3)的理解不完全的情况下来到`monads`，然后发现一个简单的事实，即`monads`是`haskell`构造的第一个例子，`haskell`构造是这三者的`confluence`(融合)。\n\n\n請看: [Monad Tutorial Fallacy](http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/)","tags":["Monads"]},{"title":"Haskell-Type-Classes","url":"/blog/2019/10/16/Haskell-Type-Classes/","content":"> http://dev.stephendiehl.com/hask/#type-classes\n类型类扩展\n\n### Minimal Annotations\n當`TypeClasses`的方法存在默认实现的情况下，可能有几种方法來实现`TypeClass`。\n例如，`Eq`完全是通过定义两个值相等或不相等来定义的，即意味着取另一个值的`negation`(否定/反面)。我们可以用不平等来定义平等，反之亦然。\n```haskell\nclass Eq a where\n  (==), (/=) :: a -> a -> Bool\n  x == y = not (x /= y)\n  x /= y = not (x == y)\n```\n在`7.6.1`之前，无法指定实现类型类所需的`minimal`(最小)定义.\n```haskell\nclass Eq a where\n  (==), (/=) :: a -> a -> Bool\n  x == y = not (x /= y)\n  x /= y = not (x == y)\n  {-# MINIMAL (==) #-}\n  {-# MINIMAL (/=) #-}\n```\n`Minimal pragmas`(最小的编译指示)是布尔表达式，以`|`作为逻辑`OR`，必须定义任何一个定义)。`,`(逗号)表示逻辑`AND`，必须同时定义两个定义。\n```haskell\n{-# MINIMAL (==) | (/=) #-} -- Either (==) or (/=)\n{-# MINIMAL (==) , (/=) #-} -- Both (==) and (/=)\n```\n当定义的实例不符合最小标准时，编译`-Wmissing-methods`会发出警告。\n\n### FlexibleInstances\n```haskell\n{-# LANGUAGE FlexibleInstances #-}\n\nclass MyClass a\n\n-- Without flexible instances, all instance heads must be type variable. The\n-- following would be legal.\n-- 如果没有`flexible`实例，所有实例heads都必须是类型變量的。以下是合法的。\ninstance MyClass (Maybe a)\n\n-- With flexible instances, typeclass heads can be arbitrary nested types. The\n-- following would be forbidden without it.\n-- 使用`flexible`实例，类型类heads可以是任意嵌套类型。如果没有`flexible`，以下内容将被禁止。\ninstance MyClass (Maybe Int)\n```\n\n### FlexibleContexts\n```haskell\n{-# LANGUAGE FlexibleContexts #-}\n\nclass MyClass a\n\n-- Without flexible contexts, all contexts must be type variable. The\n-- following would be legal.\n-- 如果没有`flexible`实例, 所有contexts都必须是类型變量的。以下是合法的。\ninstance (MyClass a) => MyClass (Either a b)\n\n-- With flexible contexts, typeclass contexts can be arbitrary nested types. The\n-- following would be forbidden without it.\n-- 使用`flexible`实例，类型类上下文可以是任意嵌套类型。如果没有`flexible`，以下内容将被禁止。\ninstance (MyClass (Maybe a)) => MyClass (Either a b)\n```\n\n### OverlappingInstances\n类型类通常是全局一致的，在程序中的任何调用站点，只有一个`instance`(实例)可以明确地解析为一种类型。\n但是，有一些扩展可以放宽此限制，并执行更多的`instance`搜索手动指导(`manual direction`)。\n`OverlappingInstances`会放宽相关条件(可以有多个实例)，但会引入一种标准，它将解析到最具体的一个。\n```haskell\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE OverlappingInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n\nclass MyClass a b where\n  fn :: (a,b)\n\ninstance MyClass Int b where\n  fn = error \"b\"\n\ninstance MyClass a Int where\n  fn = error \"a\"\n\ninstance MyClass Int Int where\n  fn = error \"c\"\n\nexample :: (Int, Int)\nexample = fn\n```\n从历史上讲，在模块级别启用该方法并不是最好的主意，因为通常来说，我们在模块中定义多个类，而其中的`subset`(子集)可能是`incoherent`(不连贯的)。\n因此，从`7.1`0开始，我们现在可以只注释具用`OVERLAPPING`和`INCOHERENT`编译指示符的实例。\n```haskell\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n\nclass MyClass a b where\n  fn :: (a,b)\n\ninstance {-# OVERLAPPING #-} MyClass Int b where\n  fn = error \"b\"\n\ninstance {-# OVERLAPPING #-} MyClass a Int where\n  fn = error \"a\"\n\ninstance {-# OVERLAPPING #-} MyClass Int Int where\n  fn = error \"c\"\n\nexample :: (Int, Int)\nexample = fn\n```\n\n### IncoherentInstances(不连贯的实例)\n`Incoherent Instances`放宽了只有一个特定实例的限制，可以任意选择一个(基于其内部表示形式的任意排序)，然后生成的程序将进行类型检查。這是相当疯狂的，通常是不良设计的标志。\n```haskell\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE IncoherentInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n\nclass MyClass a b where\n  fn :: (a,b)\n\ninstance MyClass Int b where\n  fn = error \"a\"\n\ninstance MyClass a Int where\n  fn = error \"b\"\n\nexample :: (Int, Int)\nexample = fn\n```\n\n还有一个`Incoherent Instances`:\n\n```haskell\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n\nclass MyClass a b where\n  fn :: (a,b)\n\ninstance {-# INCOHERENT #-} MyClass a Int where\n  fn = error \"general\"\n\ninstance {-# INCOHERENT #-} MyClass Int Int where\n  fn = error \"specific\"\n\nexample :: (Int, Int)\nexample = fn\n```\n\n### TypeSynonymInstances\n```haskell\n{-# LANGUAGE TypeSynonymInstances #-}\n{-# LANGUAGE FlexibleInstances #-}\n\ntype IntList = [Int]\n\nclass MyClass a\n\n-- Without type synonym instances, we're forced to manually expand out type\n-- synonyms in the typeclass head.\ninstance MyClass [Int]\n\n-- With it GHC will do this for us automatically. Type synonyms still need to\n-- be fully applied.\ninstance MyClass IntList\n```","tags":["Type-Classes"]},{"title":"Haskell-Laziness","url":"/blog/2019/10/16/Haskell-Laziness/","content":"又是一个泼了很多墨水的话题。在`Haskell`领域中有一个正在进行的关于`lazy`(懒惰)和`strict`(严格)评估之间的折衷的讨论，并且有一些细微的论据认为两种范式都應該是默认的。\n`Haskell`采用一种混合方法，允许在需要时进行严格的评估，默认情况下使用惰性。不用说，我们总能找到严格评估比懒惰评估表现出更糟糕行为的例子，反之亦然。\n\n总体上，惰性评估的主要优势在于，可以对无界和有界数据结构进行操作的算法可以使用相同的类型签名，并且无需额外重构其逻辑或强制进行中间计算就可以组成该算法。\n\n试图将懒惰添加到严格的评估模型上的语言通常会将算法类别分为两类: 一类是手动调整以使用`unbounded`(无界)结构的算法，另一类是在`bounded`(有界)结构上操作的算法。\n\n在严格的语言中，惰性和严格处理之间的`mixing`(混合)和匹配常常需要在内存中`manifesting`(显示)大型中间结构，而这样的组合只`just work`(适用于)惰性语言。\n\n由于`Haskell`是唯一一种在设计空间中真正探索这一点的语言，从而达到了工业級的程度；关于惰性评估的知识并没有被广泛地吸收到集体程序员意识中，而且对于新手来说往往是不直观的。这并没有反映在模型本身，仅仅反映在需要更多的`instruction material`(指导材料)和优化惰性编译器的研究上。\n\n`Haskell`的`paradox`(悖论)在于，它探索了许多明确的独特思想(懒惰、`purity`(纯度)、`typeclasses`(类型类))，以至于很难将任何一种思想的讨论从整个实现的`gestalt`(格式塔)中分离出来。\n\n請看:\n* [Oh My Laziness!](http://alpmestan.com/posts/2013-10-02-oh-my-laziness.html)\n* [Reasoning about Laziness](http://www.slideshare.net/tibbe/reasoning-about-laziness)\n* [Lazy Evaluation of Haskell](http://www.vex.net/~trebla/haskell/lazy.xhtml)\n* [More Points For Lazy Evaluation](http://augustss.blogspot.hu/2011/05/more-points-for-lazy-evaluation-in.html)\n* [How Lazy Evaluation Works in Haskell](https://hackhands.com/lazy-evaluation-works-haskell/)\n\n### Strictness\n`lambda`演算有几种评估模型:\n\n* **Strict**     如果在函数主体之前评估所有参数，则评估是严格的。\n* **Non-strict** 如果在输入函数主体之前不一定要对参数进行求值，则评估是非严格的。\n\n这些想法产生了几种模型，`Haskell`本身使用`call-by-need`模型。\n```haskell\nModel\t        Strictness\t    Description\nCall-by-value\tStrict\t        参数在進入函数前評估\nCall-by-name\tNon-strict\t    传递的参数未評估\nCall-by-need\tNon-strict\t    传递的参数未評估，但表达式只求值一次(共享)\n```\n### Seq and WHNF\n如果最外层的构造函数或`lambda`不能进一步`reduced`(减少)，则称该`term`(项)为`weak head normal-form`(弱头范式)。\n\n如果一个`term`(术语)是完全求值的，并且其中包含的所有子表达式和`thunk`都是求值的，则该术语称为`normal form`(标准形式)。\n```haskell\n-- In Normal Form\n42\n(2, \"foo\")\n\\x -> x + 1\n\n-- Not in Normal Form\n1 + 2\n(\\x -> x + 1) 2\n\"foo\" ++ \"bar\"\n(1 + 1, \"foo\")\n\n-- In Weak Head Normal Form\n(1 + 1, \"foo\")\n\\x -> 2 + 2\n'f' : (\"oo\" ++ \"bar\")\n\n-- Not In Weak Head Normal Form\n1 + 1\n(\\x -> x + 1) 2\n\"foo\" ++ \"bar\"\n```\n在`Haskell`中，`normal evaluation`(普通的求值)只发生在`Core`中`case`语句的外部构造函数处。\n如果在`List`上进行模式匹配，则不会隐式强制`List`中的所有值。\n数据结构中的元素只能由最外部的构造函数`evaluated`(计算)。\n例如，要`evaluate`(评估)`List`的长度，我们只需要仔细检查外部`Cons`构造函数，而不用考虑它们的内部值。\n```haskell\nλ: length [undefined, 1]\n2\n\nλ: head [undefined, 1]\nPrelude.undefined\n\nλ: snd (undefined, 1)\n1\n\nλ: fst (undefined, 1)\nPrelude.undefined\n```\n例如，在惰性语言中，下列程序即使包含`diverging terms`(发散项)也会终止。\n```haskell\nignore :: a -> Int\nignore x = 0\n\nloop :: a\nloop = loop\n\nmain :: IO ()\nmain = print $ ignore loop\n```\n在像`OCaml`这样的严格语言中(暂时忽略其`suspensions`(暂停/悬挂))，同一程序有所不同。\n```OCaml\nlet ignore x = 0;; \nlet rec loop a = loop a;;\n\nprint_int (ignore (loop ()));\n```\n在`Haskell`中，创建了一个`thunk`以代表未评估的计算。\n对`thunk`的评估称为`forcing`(强迫)`thunk`。\n结果是一個`update`(更新)，一个引用透明的效果，该效果用计算值替换了`thunk`的内存表示形式。基本思想是，一個`thunk`仅更新一次(尽管它可能在多线程环境中同时被强制执行)，并且其结果值在随后引用时被共享。\n\n命令`:sprint`可用于`introspect`(反省)表达式中未评估的`thunks`的状态，而无需强制执行评估。例如:\n```haskell\nλ: let a = [1..] :: [Integer]\nλ: let b = map (+ 1) a\n\nλ: :sprint a\na = _s\nλ: :sprint b\nb = _\nλ: a !! 4\n5\nλ: :sprint a\na = 1 : 2 : 3 : 4 : 5 : _\nλ: b !! 10\n12\nλ: :sprint a\na = 1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : 10 : 11 : _\nλ: :sprint b\nb = _ : _ : _ : _ : _ : _ : _ : _ : _ : _ : 12 : _\n```\n在计算`thunk`时，它的内存表示被一种称为`blackhole`(黑洞)的特殊形式所代替，它表示计算正在进行，并允许在计算可能依赖于自身完成时出现短路。这是`GHC`运行时一些更微妙的细节的实现。\n\n`seq`函数通过要求在对第二个参数求值之前对第一个参数求值到`WHNF`，引入了对两个`terms`(项)的顺序求值的人为依赖。\n`seq`函数的实现是`GHC`的一个实现细节。\n```haskell\nseq :: a -> b -> b\n\n⊥ `seq` a = ⊥\na `seq` b = b\n```\n众所周知，臭名昭著的`foldl`在不小心使用时会泄漏空间，而且没有应用几个编译器优化。严格的`foldl'`变体使用`seq`来克服这个问题。\n```haskell\nfoldl :: (a -> b -> a) -> a -> [b] -> a\nfoldl f z [] = z\nfoldl f z (x:xs) = foldl f (f z x) xs\nfoldl' :: (a -> b -> a) -> a -> [b] -> a\nfoldl' _ z [] = z\nfoldl' f z (x:xs) = let z' = f z x in z' `seq` foldl' f z' xs\n```\n实际上，`strictness analyzer`(严格性分析器)和`-O2`上的`inliner`(内联)的结合将确保只要函数在调用站点上是`inlinable`(可以內联)的，就會使用`foldl`的严格变体，因此通常不需要手动使用`foldl'`。\n\n需要特别注意的是，`GHCi`的运行没有应用任何优化，因此在`GHCi`中性能较差的同一程序在使用`GHC`编译时可能没有相同的性能特征。\n\n### Strictness Annotations\n`BangPatterns`扩展允许使用另一种语法来强制将函数的参数包装在`seq`中。参数上的`bang`运算符会在执行模式匹配之前强制将其评估结果转换为弱头范式。这可以用于在整个递归中保持对特定参数的评估，而不用创建庞大的`trunks`链。\n```haskell\n{-# LANGUAGE BangPatterns #-}\n\nsum :: Num a => [a] -> a\nsum = go 0\n  where\n    go !acc (x:xs) = go (acc + x) xs\n    go  acc []     = acc\n```\n这将被有效地分解为以下代码:\n```haskell\nsum :: Num a => [a] -> a\nsum = go 0\n  where\n    go acc _ | acc `seq` False = undefined\n    go acc (x:xs)              = go (acc + x) xs\n    go acc []                  = acc\n```\n对`seq'd`参数的函数应用非常常见，以至于它有一个特殊的运算符。\n```haskell\n($!) :: (a -> b) -> a -> b\nf $! x  = let !vx = x in f vx\n```\n\n### Strict Haskell\n从`GHC 8.0`开始，`strictness`(严格性)注释可以自动应用于模块中的所有定义。在以前的版本中，必须通过所有`sites`(站点)上的显式`syntactic`语法注释进行定义。\n\n#### StrictData\n启用`StrictData`会使默认情况下，对其启用的任何模块的构造函数字段都体现為`strict`(严格)。\n```haskell\n{-# LANGUAGE StrictData #-}\n\ndata Employee = Employee\n  { name :: T.Text\n  , age :: Int\n  }\n```\n等效于:\n```haskell\ndata Employee = Employee\n  { name :: !T.Text\n  , age :: !Int\n  }\n```\n#### Strict\n`Strict`意味着`-XStrictData`，并将`strictness annotations`(严格性注释)扩展到函数的所有参数。\n```haskell\nf x y = x + y\n```\n等效于带有显式`bang`模式的以下函数声明：\n```haskell\nf !x !y = x + y\n```\n在模块级别，这有效地使`Haskell`成为一种`call-by-value`语言，但有一些警告。\n现在，对函数的所有参数进行了显式求值，并且该模块中构造函数中的所有数据在构造时都处于`head normal form`。\n但是，在语言指南中有一些细微之处可以更好地解释。\n\n請看: [Strict Extensions](https://downloads.haskell.org/~ghc/master/users-guide//glasgow_exts.html?highlight=typefamilydependencies#strict-by-default-pattern-bindings)\n\n### Deepseq\n很多时候，出于性能的原因，我们需要对数据结构进行深入评估，使其具有`normal form`(正常形式)，而不会对任何`terms`(术语)进行评估。`deepseq`库执行此任务。\n\n`NFData`类型类(普通形式数据)允许我们跨任何本身实现`NFData`的子类型对结构的所有元素进行`seq`。\n```haskell\nclass NFData a where\n  rnf :: a -> ()\n  rnf a = a `seq` ()\n\ndeepseq :: NFData a => a -> b -> b\n($!!) :: (NFData a) => (a -> b) -> a -> b\ninstance NFData Int\ninstance NFData (a -> b)\n\ninstance NFData a => NFData (Maybe a) where\n    rnf Nothing  = ()\n    rnf (Just x) = rnf x\n\ninstance NFData a => NFData [a] where\n    rnf [] = ()\n    rnf (x:xs) = rnf x `seq` rnf xs\n[1, undefined] `seq` ()\n-- ()\n\n[1, undefined] `deepseq` ()\n-- Prelude.undefined\n```\n为了强制对数据结构本身进行充分评估，我们在`deepseq`的两个位置共享相同的参数。\n```haskell\nforce :: NFData a => a -> a\nforce x = x `deepseq` x\n```\n\n### Irrefutable Patterns (无可辩驳的模式)\n惰性模式不`require`(需要)外部构造函数上的匹配，而是根据需要惰性地调用值的访问器。在存在`bottom`的情况下，我们會在使用地点失败，而不是在外部模式匹配。\n```haskell\nf :: (a, b) -> Int\nf (a,b) = const 1 a\n\ng :: (a, b) -> Int\ng ~(a,b) = const 1 a\n\n-- λ: f undefined\n-- *** Exception: Prelude.undefined\n-- λ: g undefined\n-- 1\n\nj :: Maybe t -> t\nj ~(Just x) = x\n\nk :: Maybe t -> t\nk (Just x) = x\n\n-- λ: j Nothing\n-- *** Exception: src/05-laziness/lazy_patterns.hs:15:1-15: Irrefutable pattern failed for pattern (Just x)\n--\n-- λ: k Nothing\n-- *** Exception: src/05-laziness/lazy_patterns.hs:18:1-14: Non-exhaustive patterns in function k\n```","tags":["Laziness"]},{"title":"Haskell-Data-Structures","url":"/blog/2019/10/16/Haskell-Data-Structures/"},{"title":"Haskell-Mathematics","url":"/blog/2019/10/16/Haskell-Mathematics/"},{"title":"Haskell-FFI","url":"/blog/2019/10/16/Haskell-FFI/"},{"title":"Haskell-Concurrency","url":"/blog/2019/10/16/Haskell-Concurrency/"},{"title":"Haskell-GHC","url":"/blog/2019/10/16/Haskell-GHC/"},{"title":"Haskell-Template-Haskell","url":"/blog/2019/10/16/Haskell-Template-Haskell/","tags":["Template-Haskell"]},{"title":"Haskell-Streaming","url":"/blog/2019/10/16/Haskell-Streaming/","content":"> http://dev.stephendiehl.com/hask/#streaming\n\n\n### Lazy IO\n使用常规的`monadic`方法处理通过`IO`积累的数据的问题在于，`Prelude`工具要求我们在开始计算之前就一次在内存中显示大量数据。\n```haskell\nmapM :: (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)\nsequence :: (Monad m, Traversable t) => t (m a) -> m (t a)\n```\n从文件中读取将为强制读取的字符串创建一个`thunk`，然后读取文件。问题在于，这种方法将`IO effects`(效果)的顺序与评估顺序联系在一起，而这很难在很大程度上进行推理。\n\n考虑到通常情況下,`monad`法律(在没有`Seq`的情况下)保证这些计算应该是`identical`(相同/恒等)的。但是，使用惰性`IO`可以构造一个`degenerate`(简并)的案例。\n```haskell\nimport System.IO\n\nmain :: IO ()\nmain = do\n  withFile \"foo.txt\" ReadMode $ \\fd -> do\n    contents <- hGetContents fd\n    print contents\n  -- \"foo\\n\"\n\n  contents <- withFile \"foo.txt\" ReadMode hGetContents\n  print contents\n  -- \"\"\n```\n因此，我们需要一个系统，以确保在使用恒定内存的情况下进行确定性资源处理。为此，`Conduits`和`Pipes`库都使用不同的(虽然在很大程度上是等效的)方法解决了此问题。\n\n### Pipes\n```haskell\nawait :: Monad m => Pipe a y m a\nyield :: Monad m => a -> Pipe x a m ()\n\n(>->) :: Monad m\n      => Pipe a b m r\n      -> Pipe b c m r\n      -> Pipe a c m r\n\nrunEffect :: Monad m => Effect m r -> m r\ntoListM :: Monad m => Producer a m () -> m [a]\n```\n`Pipes`是一个流处理库，非常强调组合的静态语义。最简单的用法是将`pipe`函数与`(>->)`組合运算符相连接，其中每个组件都可以通过`await`和`yield`函數順著`stream`來`push`(推)和`pull`(拉)值。\n```haskell\nimport Pipes\nimport Pipes.Prelude as P\nimport Control.Monad\nimport Control.Monad.Identity\n\na :: Producer Int Identity ()\na = forM_ [1..10] yield\n\nb :: Pipe Int Int Identity ()\nb =  forever $ do\n  x <- await\n  yield (x*2)\n  yield (x*3)\n  yield (x*4)\n\nc :: Pipe Int Int Identity ()\nc = forever $ do\n  x <- await\n  if (x `mod` 2) == 0\n    then yield x\n    else return ()\n\nresult :: [Int]\nresult = P.toList $ a >-> b >-> c\n```\n例如，我们可以构造一个`FizzBuzz`管道:\n```haskell\n{-# LANGUAGE MultiWayIf #-}\n\nimport Pipes\nimport qualified Pipes.Prelude as P\n\ncount :: Producer Integer IO ()\ncount = each [1..100]\n\nfizzbuzz :: Pipe Integer String IO ()\nfizzbuzz = do\n  n <- await\n  if | n `mod` 15 == 0 -> yield \"FizzBuzz\"\n     | n `mod` 5  == 0 -> yield \"Fizz\"\n     | n `mod` 3  == 0 -> yield \"Buzz\"\n     | otherwise       -> return ()\n  fizzbuzz\n\nmain :: IO ()\nmain = runEffect $ count >-> fizzbuzz >-> P.stdoutLn\n```\n为了继续使用我们的`Lazy IO`构建的`degenerate`(简并)案例，现在考虑一下，我们现在可以在文件上`compose`(组合)和`sequence deterministic actions`(顺序确定的操作)，而不必担心`effect`(影响)顺序。\n```haskell\nimport Pipes\nimport Pipes.Prelude as P\nimport System.IO\n\nreadF :: FilePath -> Producer String IO ()\nreadF file = do\n    lift $ putStrLn $ \"Opened\" ++ file\n    h <- lift $ openFile file ReadMode\n    fromHandle h\n    lift $ putStrLn $ \"Closed\" ++ file\n    lift $ hClose h\n\nmain :: IO ()\nmain = runEffect $ readF \"foo.txt\" >-> P.take 3 >-> stdoutLn\n```\n这只是`pipes`功能的简单示例。\n关于管道的文档非常详尽,并且做了大量的工作，使得这个库非常`thorough`(全面/透彻/周密)。\n`pipes`是一个`accessible`(可访问的)、范畴理论驱动的设计的光辉范例。\n\n請看: [Pipes Tutorial](http://hackage.haskell.org/package/pipes-4.1.0/docs/Pipes-Tutorial.html)\n\n### Safe Pipes\n```haskell\nbracket :: MonadSafe m => Base m a -> (a -> Base m b) -> (a -> m c) -> m c\n```\n作为一个激励性的例子，`ZeroMQ`是一个网络消息库，它通过传统的`Unix套`接字抽象为各种网络拓扑。\n最值得注意的是，它并非旨在保证在发生错误时能为`delivery`(交付)或`recovery`(恢复)提供任何形式的事務性保证，因此有必要在其之上设计一个层,以在应用程序层提供所需的行为。\n\n在`Haskell`中，我们希望保证，如果在`socket`上进行轮询，我们会及时收到消息，或者将资源视为处于错误状态并从中恢复。\n使用`pipes-safe`，我们可以管理惰性`io`资源的生命周期，并可以安全地处理`failures`(故障)、`resource termination`(资源终止)和`finalization gracefully`(优雅地完成)。\n在其他语言中，这种逻辑可能会被分散在几个地方，或者放在一些全局上下文中，容易引入错误和微妙的`race`(种族/競爭)条件。使用管道，我们得到了一个很好的紧凑的抽象设计，正好适合这种用例。\n\n例如，现在我们可以将`ZeroMQ`套接字创建和终结放在`SafeT monad transformer`中，它保证在成功传递消息之后，我们能按预期执行管道功能，或者在失败时，`halt`(停止)执行并`finalize`(终结)套接字。\n```haskell\nimport Pipes\nimport Pipes.Safe\nimport qualified Pipes.Prelude as P\n\nimport System.Timeout (timeout)\nimport Data.ByteString.Char8\nimport qualified System.ZMQ as ZMQ\n\ndata Opts = Opts\n  { _addr    :: String  -- ^ ZMQ socket address\n  , _timeout :: Int     -- ^ Time in milliseconds for socket timeout\n  }\n\nrecvTimeout :: Opts -> ZMQ.Socket a -> Producer ByteString (SafeT IO) ()\nrecvTimeout opts sock = do\n  body <- liftIO $ timeout (_timeout opts) (ZMQ.receive sock [])\n  case body of\n    Just msg -> do\n      liftIO $ ZMQ.send sock msg []\n      yield msg\n      recvTimeout opts sock\n    Nothing  -> liftIO $ print \"socket timed out\"\n\ncollect :: ZMQ.Context\n        -> Opts\n        -> Producer ByteString (SafeT IO) ()\ncollect ctx opts = bracket zinit zclose (recvTimeout opts)\n  where\n    -- Initialize the socket\n    zinit = do\n      liftIO $ print \"waiting for messages\"\n      sock <- ZMQ.socket ctx ZMQ.Rep\n      ZMQ.bind sock (_addr opts)\n      return sock\n\n    -- On timeout or completion guarantee the socket get closed.\n    zclose sock = do\n      liftIO $ print \"finalizing\"\n      ZMQ.close sock\n\nrunZmq :: ZMQ.Context -> Opts -> IO ()\nrunZmq ctx opts = runSafeT $ runEffect $\n  collect ctx opts >-> P.take 10 >-> P.print\n\nmain :: IO ()\nmain = do\n  ctx <- ZMQ.init 1\n  let opts = Opts {_addr = \"tcp://127.0.0.1:8000\", _timeout = 1000000 }\n  runZmq ctx opts\n  ZMQ.term ctx\n```\n\n### Conduits\n```haskell\nawait :: Monad m => ConduitM i o m (Maybe i)\nyield :: Monad m => o -> ConduitM i o m ()\n($$) :: Monad m => Source m a -> Sink a m b -> m b\n(=$) :: Monad m => Conduit a m b -> Sink b m c -> Sink a m c\n\ntype Sink i = ConduitM i Void\ntype Source m o = ConduitM () o m ()\ntype Conduit i m o = ConduitM i o m ()\n```\n尽管在解决`IO`资源的恒定空间确定性资源处理(`constant space deterministic resource handling for IO resources`)的同一问题的哲学方法上不同，但`Conduits`在概念上是相似的。\n\n第一个初始区别是，`await`函数现在返回一个`Maybe`，它允许对`termination`(终止)进行不同的处理。`composition`(合成)运算符还分为`connecting`(连接)运算符`($$)`和`fusing`(融合)运算符`(=$)`，分别用于组合`Sources`和`Sink`以及`Conduit`和`Sink`。\n```haskell\n{-# LANGUAGE MultiWayIf #-}\n\nimport Data.Conduit\nimport Control.Monad.Trans\nimport qualified Data.Conduit.List as CL\n\nsource :: Source IO Int\nsource = CL.sourceList [1..100]\n\nconduit :: Conduit Int IO String\nconduit = do\n  val <- await\n  liftIO $ print val\n  case val of\n    Nothing -> return ()\n    Just n -> do\n      if | n `mod` 15 == 0 -> yield \"FizzBuzz\"\n         | n `mod` 5  == 0 -> yield \"Fizz\"\n         | n `mod` 3  == 0 -> yield \"Buzz\"\n         | otherwise       -> return ()\n      conduit\n\nsink :: Sink String IO ()\nsink = CL.mapM_ putStrLn\n\nmain :: IO ()\nmain = source $$ conduit =$ sink\n```\n\n請看: [Conduit Overview](https://www.fpcomplete.com/user/snoyberg/library-documentation/conduit-overview)\n\n\n","tags":["Streaming"]},{"title":"Haskell-Parsing","url":"/blog/2019/10/16/Haskell-Parsing/"},{"title":"Haskell-Error-Handling","url":"/blog/2019/10/16/Haskell-Error-Handling/","content":"> http://dev.stephendiehl.com/hask/#error-handling\n\n### Control.Exception\n处理`errors`的最底层(也是最危险的)方法是使用`throw`和`catch`函数，这些函数使我们可以在纯代码中抛出可扩展的异常，但可以在`IO`中捕获生成的异常。\n特别要注意的是，`throw`的返回值`inhabits`(驻留在)所有类型中。对于不使用`low-level`系统操作的自定义代码，没有理由使用此选项。\n```haskell\nthrow :: Exception e => e -> a\ncatch :: Exception e => IO a -> (e -> IO a) -> IO a\ntry :: Exception e => IO a -> IO (Either e a)\nevaluate :: a -> IO a\n{-# LANGUAGE DeriveDataTypeable #-}\n\nimport Data.Typeable\nimport Control.Exception\n\ndata MyException = MyException\n    deriving (Show, Typeable)\n\ninstance Exception MyException\n\nevil :: [Int]\nevil = [throw MyException]\n\nexample1 :: Int\nexample1 = head evil\n\nexample2 :: Int\nexample2 = length evil\n\nmain :: IO ()\nmain = do\n  a <- try (evaluate example1) :: IO (Either MyException Int)\n  print a\n\n  b <- try (return example2) :: IO (Either MyException Int)\n  print b\n```\n因为除非需要該值，否则将不会评估該值，因此，如果希望确定是否捕获到异常，可以在调用`catch`之前将其深深地强制转换为`head normal form`(普通形式)。标准库没有提供`strictCatch`，但是在`deepseq`方面有一个简单的实现。\n```haskell\nstrictCatch :: (NFData a, Exception e) => IO a -> (e -> IO a) -> IO a\nstrictCatch = catch . (toNF =<<)\n```\n\n### Exceptions\n前一种方法的问题是必须依赖于`IO`内部`GHC`的异步异常处理来处理基本操作。\n`Exceptions`提供了与`Control.exception`相同的`api`，但却放松了对`IO`的依赖。\n```haskell\n{-# LANGUAGE DeriveDataTypeable #-}\n\nimport Data.Typeable\nimport Control.Monad.Catch\nimport Control.Monad.Identity\n\ndata MyException = MyException\n    deriving (Show, Typeable)\n\ninstance Exception MyException\n\nexample :: MonadCatch m => Int -> Int -> m Int\nexample x y | y == 0 = throwM MyException\n            | otherwise = return $ x `div` y\n\npure :: MonadCatch m => m (Either MyException Int)\npure = do\n  a <- try (example 1 2)\n  b <- try (example 1 0)\n  return (a >> b)\n```\n請看: [exceptions](http://hackage.haskell.org/package/exceptions)\n\n### ExceptT\n从`mtl 2.2`或更高版本开始，`ErrorT`类已由`ExceptT`取代。在`transformers`(变压器)级别。\n```haskell\nnewtype ExceptT e m a = ExceptT (m (Either e a))\n\nrunExceptT :: ExceptT e m a -> m (Either e a)\nrunExceptT (ExceptT m) = m\n\ninstance (Monad m) => Monad (ExceptT e m) where\n    return a = ExceptT $ return (Right a)\n    m >>= k = ExceptT $ do\n        a <- runExceptT m\n        case a of\n            Left e -> return (Left e)\n            Right x -> runExceptT (k x)\n    fail = ExceptT . fail\n\nthrowE :: (Monad m) => e -> ExceptT e m a\nthrowE = ExceptT . return . Left\n\ncatchE :: (Monad m) =>\n    ExceptT e m a               -- ^ the inner computation\n    -> (e -> ExceptT e' m a)    -- ^ a handler for exceptions in the inner\n                                -- computation\n    -> ExceptT e' m a\nm `catchE` h = ExceptT $ do\n    a <- runExceptT m\n    case a of\n        Left  l -> runExceptT (h l)\n        Right r -> return (Right r)\n```\n使用`mtl`:\n```haskell\ninstance MonadTrans (ExceptT e) where\n    lift = ExceptT . liftM Right\n\nclass (Monad m) => MonadError e m | m -> e where\n    throwError :: e -> m a\n    catchError :: m a -> (e -> m a) -> m a\n\ninstance MonadError IOException IO where\n    throwError = ioError\n    catchError = catch\n\ninstance MonadError e (Either e) where\n    throwError             = Left\n    Left  l `catchError` h = h l\n    Right r `catchError` _ = Right r\n```\n請看: [Control.Monad.Except](https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html)\n\n### spoon\n有时，您将不得不处理那些在任何时候都可能抛出的看似纯粹的函数。像这样的函數在标准库中有很多，在`Hackage`中有更多。\n\n您只想`purely`(純粹)处理此逻辑，就好像它返回一个正确的`Maybe a`一样，但是要捕获该逻辑，您需要在`IO`内安装一个`IO`处理程序来捕获它。\n`Spoon`允许我们安全地(`purely`的，尽管它使用对`unsafePerformIO`的引用透明调用)来捕获这些异常并将它们放在它們所属的`Maybe`中。\n\n`spoon`函数将其参数评估为`head normal form`，而`teaspoon`则将其参数评估为[weak head normal form](http://dev.stephendiehl.com/hask/#seq-and-whnf)。\n```haskell\nimport Control.Spoon\n\ngoBoom :: Int -> Int -> Int\ngoBoom x y = x `div` y\n\n-- evaluate to normal form\ntest1 :: Maybe [Int]\ntest1 = spoon [1, 2, undefined]\n\n-- evaluate to weak head normal form\ntest2 :: Maybe [Int]\ntest2 = teaspoon [1, 2, undefined]\n\nmain :: IO ()\nmain = do\n  maybe (putStrLn \"Nothing\") (print . length) test1\n  maybe (putStrLn \"Nothing\") (print . length) test2\n```\n\n請看: [Spoon](https://hackage.haskell.org/package/spoon)\n\n### safe-exceptions\n> TODO","tags":["Error-Handling"]},{"title":"Haskell-Quantification","url":"/blog/2019/10/09/Haskell-Quantification/","content":">这是高级部分，编写Haskell通常不需要。\n\n### Universal Quantification\n`Universal Quantification`(通用量化)是`Haskell`中编码多态性的主要机制。\n`Universal Quantification`的本质是，我们可以表达对一组类型以相同方式操作的函数，并且其函数行为完全取决于此范围内所有类型的行为。\n```haskell\n{-# LANGUAGE ExplicitForAll #-}\n\n-- ∀a. [a]\nexample1 :: forall a. [a]\nexample1 = []\n\n-- ∀a. [a]\nexample2 :: forall a. [a]\nexample2 = [undefined]\n\n-- ∀a. ∀b. (a → b) → [a] → [b]\nmap' :: forall a. forall b. (a -> b) -> [a] -> [b]\nmap' f = foldr ((:) . f) []\n\n-- ∀a. [a] → [a]\nreverse' :: forall a. [a] -> [a]\nreverse' = foldl (flip (:)) []\n```\n通常，在类型签名中省略量词，因为在`Haskell`的`vanilla`表面语言中，毫无疑问地假定自由类型变量已被普遍量化。\n\n### Free theorems(定理)\n\n通用量化的类型变量实际上暗含着有关函数实现的相当多的深层属性，这些属性可以从其类型签名中得出。\n例如，确保`Haskell`中的`identity`函數只有一种实现，因为该信息只可以出現在主體內。\n```haskell\nid :: forall a. a -> a\nid x = x\n\nfmap :: Functor f => (a -> b) -> f a -> f b\n```\n`fmap`的`Free theorems`:\n```haskell\nforall f g. fmap f . fmap g = fmap (f . g)\n```\n請看: [Theorems for Free](http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi?)\n\n### Type Systems\n`Hindley-Milner`类型系统在历史上很重要, 它是第一个接受多态性和可以始终确定主要类型的推理技术的`typed  lambda`计算之一。\n```haskell\ne : x\n  | λx:t.e            -- value abstraction\n  | e1 e2             -- application\n  | let x = e1 in e2  -- let\n\nt : t -> t     -- function types\n  | a          -- type variables\n\nσ : ∀ a . t    -- type scheme\n```\n在一个实现中，该函数泛化将类型内的所有`type variables`转换为产生`type scheme`的多态类型变量。\n該函数实例化将`scheme`映射到一個`type`，但是任何多态变量都转换为非绑定类型变量。\n\n### Rank-N Types\n`System-F`是`Haskell`底层的类型系统。从某种意义上说，`System-F`包含`HM`类型系统，因为`HM`中可表达的每种类型都可以在`System-F`中表达。\n`System-F`在文案中有时被称为`Girald-Reynolds polymorphic lambda calculus(Girald-Reynolds多态Lambda演算)`或者`second-order lambda calculus（二阶Lambda演算）`。\n```haskell\nt : t -> t     -- function types\n  | a          -- type variables\n  | ∀ a . t    -- forall\n\ne : x          -- variables\n  | λ(x:t).e   -- value abstraction\n  | e1 e2      -- value application\n  | Λa.e       -- type abstraction\n  | e_t        -- type application\n```\n一个与`GHC Core`等效的示例:\n```haskell\nid : ∀ t. t -> t\nid = Λt. λx:t. x\n-- id :: forall t. t -> t\n-- id = \\ (@ t) (x :: t) -> x\n\ntr : ∀ a. ∀ b. a -> b -> a\ntr = Λa. Λb. λx:a. λy:b. x\n-- tr :: forall a b. a -> b -> a\n-- tr = \\ (@ a) (@ b) (x :: a) (y :: b) -> x\n\nfl : ∀ a. ∀ b. a -> b -> b\nfl = Λa. Λb. λx:a. λy:b. y\n-- fl :: forall a b. a -> b -> b\n-- fl = \\ (@ a) (@ b) (x :: a) (y :: b) -> y\n\nnil : ∀ a. [a]\nnil = Λa. Λb. λz:b. λf:(a -> b -> b). z\n-- nil :: forall a. [a]\n-- nil = \\ (@ a) (@ b) (z :: b) (f :: a -> b -> b) -> z\n\ncons : ∀ a. a -> [a] -> [a]\ncons = Λa. λx:a. λxs:(∀ b. b -> (a -> b -> b) -> b).\n    Λb. λz:b. λf : (a -> b -> b). f x (xs_b z f)\n-- cons :: forall a. a -> [a] -> [a]\n-- cons = \\ (@ a) (x :: a) (xs :: forall b. b -> (a -> b -> b) -> b)\n--     (@ b) (z :: b) (f :: a -> b -> b) -> f x (xs @ b z f)\n```\n通常，当`Haskell`的类型检查器推断类型签名时，它将所有类型变量的量词放在最外面的位置，这样在类型表达式的主体内就不会出现量词，这被称为`prenex`限制。\n这限制了整个类的类型签名，這些簽名本來可以在`System-F`中表达，但是这样做的好处是使推断更加容易。\n```haskell\n{-# LANGUAGE RankNTypes #-}\n\n-- Can't unify ( Bool ~ Char )\nrank1 :: forall a. (a -> a) -> (Bool, Char)\nrank1 f = (f True, f 'a')\n\nrank2 :: (forall a. a -> a) -> (Bool, Char)\nrank2 f = (f True, f 'a')\n\nauto :: (forall a. a -> a) -> (forall b. b -> b)\nauto x = x\n\nxauto :: forall a. (forall b. b -> b) -> a -> a\nxauto f = f\nMonomorphic Rank 0: t\nPolymorphic Rank 1: forall a. a -> t\nPolymorphic Rank 2: (forall a. a -> t) -> t\nPolymorphic Rank 3: ((forall a. a -> t) -> t) -> t\n```\n需要特别注意的是，由`higher ranked`类型的显式量词绑定的类型变量可能无法逃脱其封闭范围。\n类型检查器将通过强制绑定在`rank-n`类型内部的变量(称为`skolem`常量)将不会与推理引擎所推断的自由元类型变量统一，从而显式实施此操作。\n类型检查器将显式地强制执行此操作，方法是强制在`rank-n`类型内部绑定的变量(称为`skolem`常量)不能与由推理引擎推断的自由元类型变量相统一。\n```haskell\n{-# LANGUAGE RankNTypes #-}\n\nescape :: (forall a. a -> a) -> Int\nescape f = f 0\n\ng x = escape (\\a -> x)\n```\n在此示例中，为了使表达式具有良好的类型,`f`必须具有`(Int -> Int)`,这意味着在整个类型上具有`a 〜 Int`，\n但是由于`a`绑定在量词下，因此它一定不能与`Int`统一，因此类型检查器必须失败，并出现`skolem`捕获错误。\n```haskell\nCouldn't match expected type `a' with actual type `t'\n`a' is a rigid type variable bound by a type expected by the context: a -> a\n`t' is a rigid type variable bound by the inferred type of g :: t -> Int\nIn the expression: x In the first argument of `escape', namely `(\\a -> x)'\nIn the expression: escape (\\a -> x)\n```\n实际上，这可以用于我们的优势，以便对特定类型变量的范围和使用实施几种类型的不变量。\n例如，`ST monad`使用一個`second rank`类型来防止捕获具有单独状态线程的`ST monad`之间的引用，在这些状态线程中，`s`类型变量绑定在`rank-2`类型内并且不能转义，从而静态地保证了`ST`内部不会泄漏，因此可确保其引用透明性。\n\n### Existential Quantification(存在量化)\n`existential`(存在)类型是具有一组特殊的包装和拆包语义的类型和`term`对。\n生产者知道`existential`中编码的值的类型,但是`existential`值的消費者不知道。\n```haskell\n{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE RankNTypes #-}\n\n-- ∃ t. (t, t → t, t → String)\ndata Box = forall a. Box a (a -> a) (a -> String)\n\nboxa :: Box\nboxa = Box 1 negate show\n\nboxb :: Box\nboxb = Box \"foo\" reverse show\n\napply :: Box -> String\napply (Box x f p) = p (f x)\n\n-- ∃ t. Show t => t\ndata SBox = forall a. Show a => SBox a\n\nboxes :: [SBox]\nboxes = [SBox (), SBox 2, SBox \"foo\"]\n\nshowBox :: SBox -> String\nshowBox (SBox a) = show a\n\nmain :: IO ()\nmain = mapM_ (putStrLn . showBox) boxes\n-- ()\n-- 2\n-- \"foo\"\n```\n`SBox`上的`existential`收集了一个纯粹根据其`Show`接口和一个不透明指针定义的值的集合，\n没有其他有关值的信息，并且无法以任何其他方式访问或解包它们。\n\n传递`existential`类型可以使我们向数据类型的使用者隐藏信息，并限制函数可以使用的行为。\n传递带有`existential`变量的记录，可以使类型与固定的一组函数\"捆绑\"在一起，这些函数在其隐藏的内部操作。\n```haskell\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ExistentialQuantification #-}\n\n-- a b are existentially bound type variables, m is a free type variable\n-- a b是existentially绑定类型变量，m是自由类型变量\ndata MonadI m = MonadI\n  { _return :: forall a . a -> m a\n  , _bind   :: forall a b . m a -> (a -> m b) -> m b\n  }\n\nmonadMaybe:: MonadI Maybe\nmonadMaybe = MonadI\n  { _return = Just\n  , _bind   = \\m f -> case m of\n      Nothing -> Nothing\n      Just x  -> f x\n  }\n```\n\n### Impredicative Types(強制性類型)\n>这是高级部分，编写Haskell通常不需要。\n\n尽管非常脆弱，但是`GHC`对强制性多态性的支持也很有限，它允许使用多态类型实例化类型变量。\n\n这暗示着这放宽了量词必须在`arrow`(箭头)类型之前的限制，现在它们可以放置在类型构造函数内部。\n```haskell\n-- Can't unify ( Int ~ Char )\nrevUni :: forall a. Maybe ([a] -> [a]) -> Maybe ([Int], [Char])\nrevUni (Just g) = Just (g [3], g \"hello\")\nrevUni Nothing  = Nothing\n{-# LANGUAGE ImpredicativeTypes #-}\n\n-- Uses higher-ranked polymorphism.\nf :: (forall a. [a] -> a) -> (Int, Char)\nf get = (get [1,2], get ['a', 'b', 'c'])\n\n-- Uses impredicative polymorphism.\ng :: Maybe (forall a. [a] -> a) -> (Int, Char)\ng Nothing = (0, '0')\ng (Just get) = (get [1,2], get ['a','b','c'])\n```\n很少使用此扩展，并且考虑到`-XImpredicativeTypes`从根本上被破坏了。 尽管`GHC`非常谨慎地告诉我们在类型签名中意外打错时启用它！\n\n一些值得注意的细节，($)操作符以一种非常特殊的方式连接到`GHC`中，以便仅在`ST monad`中使用($)操作符时，通过($)将`runST`的`impredicative instantiation`(強制性实例化)应用到($)中。如果这听起来像是丑陋的骇客，那是因为它确实是，但是相当方便。\n\n例如，如果我们定义一个行为应该与($)相同的函数`apply`，我们将得到一个关于多态实例化的错误，即使它们的定义是相同的!\n```haskell\n{-# LANGUAGE RankNTypes #-}\n\nimport Control.Monad.ST\n\nf `apply` x =  f x\n\nfoo :: (forall s. ST s a) -> a\nfoo st = runST $ st\n\nbar :: (forall s. ST s a) -> a\nbar st = runST `apply` st\n    Couldn't match expected type `forall s. ST s a'\n                with actual type `ST s0 a'\n    In the second argument of `apply', namely `st'\n    In the expression: runST `apply` st\n    In an equation for `bar': bar st = runST `apply` st\n```\n請看: [SPJ Notes on $](https://www.haskell.org/pipermail/glasgow-haskell-users/2010-November/019431.html)\n\n### Scoped Type Variables\n通常，在函数的顶级签名中使用的类型变量仅作用于类型签名，而不是作用在`terms`和`let/where`子句中的函数主体及其严格签名。\n```haskell\n{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\npoly :: forall a b c. a -> b -> c -> (a, a)\npoly x y z = (f x y, f x z)\n  where\n    -- second argument is universally quantified from inference\n    -- 第二个參數是根据推论普遍量化的\n    -- f :: forall t0 t1. t0 -> t1 -> t0\n    f x' _ = x'\n\nmono :: forall a b c. a -> b -> c -> (a, a)\nmono x y z = (f x y, f x z)\n  where\n    -- b is not implictly universally quantified because it is in scope\n    -- b没有被隐含地普遍量化，因为它在范围内\n    f :: a -> b -> a\n    f x' _ = x'\n\nexample :: IO ()\nexample = do\n  x :: [Int] <- readLn\n  print x\n\n```\n\n","tags":["Quantification"]},{"title":"Haskell-Generics","url":"/blog/2019/10/09/Haskell-Generics/","content":"> http://dev.stephendiehl.com/hask/#generics\n\n`Haskell`有几种技术可以自动生成用于各种任务的类型类，这些任务主要由样板代码生成组成，例如:\n* **Pretty Printing** (漂亮打印)\n* **Equality** (平等/相等)\n* **Serialization** (序列化)\n* **Ordering** (比較)\n* **Traversal** (遍历)\n\n这些是通过以下几节中概述的几种工具和技术来实现的:\n* **Typeable / Dynamic**\n* **Scrap Your Boilerplate** (报废/扔掉你的样板)\n* **GHC.Generics**\n* **generics-sop**\n\n### Typeable\n`Typeable`类用于为任意类型创建运行时类型信息。\n```haskell\ntypeOf :: Typeable a => a -> TypeRep\n{-# LANGUAGE DeriveDataTypeable #-}\n\nimport Data.Typeable\n\ndata Animal = Cat | Dog deriving Typeable\ndata Zoo a = Zoo [a] deriving Typeable\n\nequal :: (Typeable a, Typeable b) => a -> b -> Bool\nequal a b = typeOf a == typeOf b\n\nexample1 :: TypeRep\nexample1 = typeOf Cat\n-- Animal\n\nexample2 :: TypeRep\nexample2 = typeOf (Zoo [Cat, Dog])\n-- Zoo Animal\n\nexample3 :: TypeRep\nexample3 = typeOf ((1, 6.636e-34, \"foo\") :: (Int, Double, String))\n-- (Int,Double,[Char])\n\nexample4 :: Bool\nexample4 = equal False ()\n-- False\n```\n使用`typeable`实例允许我们编写一个类型安全的`cast`函数，该函数可以安全地使用`unsafecast`，并提供结果类型与输入匹配的证明。\n```haskell\ncast :: (Typeable a, Typeable b) => a -> Maybe b\ncast x\n  | typeOf x == typeOf ret = Just ret\n  | otherwise = Nothing\n  where\n    ret = unsafeCast x\n```\n历史上值得注意的是，目前在`GHC 7.6`中可以编写我们自己的`Typeable`类，但是它允许我们引入可能导致崩溃的危险行为，除非`GHC`本身否則不应该这样做。从`GHC 7.8`开始，已經禁止我們手写`Typeable`实例。 从`GHC 7.10`开始，默认情况下已启用`-XAutoDeriveTypeable`擴展。\n\n請看: [Typeable and Data in Haskell](http://chrisdone.com/posts/data-typeable)\n\n### Dynamic\n由于我们有一种查询运行时类型信息的方法，因此可以使用此机器实现`Dynamic`(动态)类型。\n这允许我们将任何`monotype`(单型)打包成一个`uniform`(统一)的类型，该类型可以传递给任何采用动态类型的函数，然后可以用类型安全的方式解包基础值。\n```haskell\ntoDyn :: Typeable a => a -> Dynamic\nfromDyn :: Typeable a => Dynamic -> a -> a\nfromDynamic :: Typeable a => Dynamic -> Maybe a\ncast :: (Typeable a, Typeable b) => a -> Maybe b\nimport Data.Dynamic\nimport Data.Maybe\n\ndynamicBox :: Dynamic\ndynamicBox = toDyn (6.62 :: Double)\n\nexample1 :: Maybe Int\nexample1 = fromDynamic dynamicBox\n-- Nothing\n\nexample2 :: Maybe Double\nexample2 = fromDynamic dynamicBox\n-- Just 6.62\n\nexample3 :: Int\nexample3 = fromDyn dynamicBox 0\n-- 0\n\nexample4 :: Double\nexample4 = fromDyn dynamicBox 0.0\n-- 6.62\n```\n在`GHC 7.8`中，`Typeable`类是`poly-kinded`(多类型)的，因此`polymorphic`(多态)函数可以应用于函数和`higher kinded`(更高种类)的类型。\n>使用`dynamic`有点罕见，除了在处理外部内存和`ffi`接口的奇怪情况下。将它用于业务逻辑被认为是一种代码异味。考虑一个更惯用的解决方案。\n\n### Data\n正如`Typeable`允许我们创建运行时类型信息一样，`Data`类也允许我们根据需要向运行时`reflect`(反映)有关`datatypes`结构的信息。\n```haskell\nclass Typeable a => Data a where\n  gfoldl  :: (forall d b. Data d => c (d -> b) -> d -> c b)\n          -> (forall g. g -> c g)\n          -> a\n          -> c a\n\n  gunfold :: (forall b r. Data b => c (b -> r) -> c r)\n          -> (forall r. r -> c r)\n          -> Constr\n          -> c a\n\n  toConstr :: a -> Constr\n  dataTypeOf :: a -> DataType\n  gmapQl :: (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r\n```\n`gfoldl`和`gunfold`的类型有些令人生畏(其取决于`RankNTypes`),最好的理解方法是看一些示例。首先，最简单的情况是`sum`类型`Animal`将产生以下代码:\n```haskell\ndata Animal = Cat | Dog deriving Typeable\ninstance Data Animal where\n  gfoldl k z Cat = z Cat\n  gfoldl k z Dog = z Dog\n\n  gunfold k z c\n    = case constrIndex c of\n        1 -> z Cat\n        2 -> z Dog\n\n  toConstr Cat = cCat\n  toConstr Dog = cDog\n\n  dataTypeOf _ = tAnimal\n\ntAnimal :: DataType\ntAnimal = mkDataType \"Main.Animal\" [cCat, cDog]\n\ncCat :: Constr\ncCat = mkConstr tAnimal \"Cat\" [] Prefix\n\ncDog :: Constr\ncDog = mkConstr tAnimal \"Dog\" [] Prefix\n```\n\n对于带有非空容器的类型，我们会得到一些更有趣的东西。考虑列表类型:\n```haskell\ninstance Data a => Data [a] where\n  gfoldl _ z []     = z []\n  gfoldl k z (x:xs) = z (:) `k` x `k` xs\n\n  toConstr []    = nilConstr\n  toConstr (_:_) = consConstr\n\n  gunfold k z c\n    = case constrIndex c of\n        1 -> z []\n        2 -> k (k (z (:)))\n\n  dataTypeOf _ = listDataType\n\nnilConstr :: Constr\nnilConstr = mkConstr listDataType \"[]\" [] Prefix\n\nconsConstr :: Constr\nconsConstr = mkConstr listDataType \"(:)\" [] Infix\n\nlistDataType :: DataType\nlistDataType = mkDataType \"Prelude.[]\" [nilConstr,consConstr]\n```\n看一下`gfoldl`，我们看到`Data`有一个函数的实现，通过在每个元素上应用函数`k`并在`spine`(书脊)上应用`z`，我们可以遍历构造函数的元素。例如，看一个2元组的实例:\n```haskell\ninstance (Data a, Data b) => Data (a,b) where\n  gfoldl k z (a,b) = z (,) `k` a `k` b\n\n  toConstr (_,_) = tuple2Constr\n\n  gunfold k z c\n    = case constrIndex c of\n      1 -> k (k (z (,)))\n\n  dataTypeOf _  = tuple2DataType\n\ntuple2Constr :: Constr\ntuple2Constr = mkConstr tuple2DataType \"(,)\" [] Infix\n\ntuple2DataType :: DataType\ntuple2DataType = mkDataType \"Prelude.(,)\" [tuple2Constr]\n```\n这非常整洁，现在在同一类型类中，我们有一种`generic`(通用)的方法可以对任何`Data`实例进行内省并编写依赖于其子项的结构和类型的逻辑。\n现在，我们可以编写一个函数，该函数允许我们根据运行时类型上的模式匹配`traverse`(遍历)`Data`的任意实例和`twiddle`(旋转)值。 \n因此，让我们写下一个为`n`元组和列表增加`Value`类型的函数。\n```haskell\n{-# LANGUAGE DeriveDataTypeable #-}\n\nimport Data.Data\nimport Control.Monad.Identity\nimport Control.Applicative\n\ndata Animal = Cat | Dog deriving (Data, Typeable)\n\nnewtype Val = Val Int deriving (Show, Data, Typeable)\n\nincr :: Typeable a => a -> a\nincr = maybe id id (cast f)\n  where f (Val x) = Val (x * 100)\n\nover :: Data a => a -> a\nover x = runIdentity $ gfoldl cont base (incr x)\n  where\n    cont k d = k <*> (pure $ over d)\n    base = pure\n\nexample1 :: Constr\nexample1 = toConstr Dog\n-- Dog\n\nexample2 :: DataType\nexample2 = dataTypeOf Cat\n-- DataType {tycon = \"Main.Animal\", datarep = AlgRep [Cat,Dog]}\n\nexample3 :: [Val]\nexample3 = over [Val 1, Val 2, Val 3]\n-- [Val 100,Val 200,Val 300]\n\nexample4 :: (Val, Val, Val)\nexample4 = over (Val 1, Val 2, Val 3)\n-- (Val 100,Val 200,Val 300)\n```\n我们还可以编写`generic`(通用)操作，例如计算数据类型中参数的数量。\n```haskell\nnumHoles :: Data a => a -> Int\nnumHoles = gmapQl (+) 0 (const 1)\n\nexample1 :: Int\nexample1 = numHoles (1,2,3,4,5,6,7)\n-- 7\n\nexample2 :: Int\nexample2 = numHoles (Just 3)\n-- 1\n```\n\n### Syb\n使用`Data`提供的接口，我们可以在运行时检索所需的信息，检查表达式的类型并重写它们，收集`terms`(项)，并找到与特定谓词匹配的`subterms`(子项)。\n```haskell\neverywhere :: (forall a. Data a => a -> a) -> forall a. Data a => a -> a\neverywhereM :: Monad m => GenericM m -> GenericM m\nsomewhere :: MonadPlus m => GenericM m -> GenericM m\nlistify :: Typeable r => (r -> Bool) -> GenericQ [r]\neverything :: (r -> r -> r) -> GenericQ r -> GenericQ r\n```\n例如，假设我们有一些自定义的`datatypes`(数据类型)集合，我们要为其编写`generic`(通用)转换，以根据重写规则集转换数值子表达式。 我们可以使用`syb`简洁地编写转换规则。\n```haskell\n{-# LANGUAGE DeriveDataTypeable #-}\n\nimport Data.Data\nimport Data.Typeable\nimport Data.Generics.Schemes\nimport Data.Generics.Aliases (mkT)\n\ndata MyTuple a = MyTuple a Float\n  deriving (Data, Typeable, Show)\n\nexampleT :: Data a => MyTuple a -> MyTuple a\nexampleT = everywhere (mkT go1) . everywhere (mkT go2)\n  where\n    go1 :: Int -> Int\n    go1 x = succ x\n\n    go2 :: Float -> Float\n    go2 x = succ x\n\nfindFloat :: Data x => x -> Maybe Float\nfindFloat = gfindtype\n\nmain :: IO ()\nmain = do\n  let term = MyTuple (MyTuple (1 :: Int) 2.0) 3.0\n  print (exampleT term)\n  print (gsize term)\n  print (findFloat term)\n  print (listify ((>0) :: (Int -> Bool)) term)\n```\n* [Data.Generics.Schemes](https://hackage.haskell.org/package/syb-0.6/docs/Data-Generics-Schemes.html)\n\n### Generic\n最现代的`generic programming`(泛型编程)方法是使用`type families`来实现更好的派生任意类型类的结构属性的方法。\n`Generic`(泛型)实现了一个类型类，该类具有一个关联的类型`Rep`(`Representation`表示)和一对函数，这些函数形成一个`2-sided inverse`(双面逆)(`isomorphism`同构)，用于在`associated`(相关联)类型和相关`derived`(派生)类型之间进行转换。\n```haskell\nclass Generic a where\n  type Rep a\n  from :: a -> Rep a\n  to :: Rep a -> a\n\nclass Datatype d where\n  datatypeName :: t d f a -> String\n  moduleName :: t d f a -> String\n\nclass Constructor c where\n  conName :: t c f a -> String\n```\n[GHC.Generics](https://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc-prim-0.2.0.0/GHC-Generics.html)\n`GHC.Generics`定义了一组`named types`(命名类型)，用于对`Haskell`中可用的类型的各种`structural properties`(结构特性)进行建模。\n```haskell\n-- | Sums: encode choice between constructors\ninfixr 5 :+:\ndata (:+:) f g p = L1 (f p) | R1 (g p)\n\n-- | Products: encode multiple arguments to constructors\ninfixr 6 :*:\ndata (:*:) f g p = f p :*: g p\n\n-- | Tag for M1: datatype\ndata D\n-- | Tag for M1: constructor\ndata C\n\n-- | Constants, additional parameters and recursion of kind *\nnewtype K1 i c p = K1 { unK1 :: c }\n\n-- | Meta-information (constructor names, etc.)\nnewtype M1 i c f p = M1 { unM1 :: f p }\n\n-- | Type synonym for encoding meta-information for datatypes\ntype D1 = M1 D\n\n-- | Type synonym for encoding meta-information for constructors\ntype C1 = M1 C\n```\n如果我们要手工为一个简单的类型编写`Generic`(通用)实例，那么使用派生机制`GHC`可以为我们机械地生成该`Generic`(通用)实例:\n```haskell\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE TypeFamilies #-}\n\nimport GHC.Generics\n\ndata Animal\n  = Dog\n  | Cat\n\ninstance Generic Animal where\n  type Rep Animal = D1 T_Animal ((C1 C_Dog U1) :+: (C1 C_Cat U1))\n\n  from Dog = M1 (L1 (M1 U1))\n  from Cat = M1 (R1 (M1 U1))\n\n  to (M1 (L1 (M1 U1))) = Dog\n  to (M1 (R1 (M1 U1))) = Cat\n\ndata T_Animal\ndata C_Dog\ndata C_Cat\n\ninstance Datatype T_Animal where\n  datatypeName _ = \"Animal\"\n  moduleName _ = \"Main\"\n\ninstance Constructor C_Dog where\n  conName _ = \"Dog\"\n\ninstance Constructor C_Cat where\n  conName _ = \"Cat\"\n```\n在`GHCi`中使用`kind!`我们可以查看与`Generic`(泛型)实例相关联的`type family`表示(`Rep/Representative`)\n```haskell\nλ: :kind! Rep Animal\nRep Animal :: * -> *\n= M1 D T_Animal (M1 C C_Dog U1 :+: M1 C C_Cat U1)\n\nλ: :kind! Rep ()\nRep () :: * -> *\n= M1 D GHC.Generics.D1() (M1 C GHC.Generics.C1_0() U1)\n\nλ: :kind! Rep [()]\nRep [()] :: * -> *\n= M1\n    D\n    GHC.Generics.D1[]\n    (M1 C GHC.Generics.C1_0[] U1\n     :+: M1\n           C\n           GHC.Generics.C1_1[]\n           (M1 S NoSelector (K1 R ()) :*: M1 S NoSelector (K1 R [()])))\n```\n现在聪明的一点是，我们没有在`datatype`(数据类型)上编写`generic`(泛型)函数，而是在`Rep`上编写了它，然后使用`from`来`reify`(具体化)结果.\n因此，对于`Haskell`默认`Eq`的等效版本，它改用`generic deriving`(泛型派生)，我们可以这样写:\n```haskell\nclass GEq' f where\n  geq' :: f a -> f a -> Bool\n\ninstance GEq' U1 where\n  geq' _ _ = True\n\ninstance (GEq c) => GEq' (K1 i c) where\n  geq' (K1 a) (K1 b) = geq a b\n\ninstance (GEq' a) => GEq' (M1 i c a) where\n  geq' (M1 a) (M1 b) = geq' a b\n\n-- Equality for sums.\ninstance (GEq' a, GEq' b) => GEq' (a :+: b) where\n  geq' (L1 a) (L1 b) = geq' a b\n  geq' (R1 a) (R1 b) = geq' a b\n  geq' _      _      = False\n\n-- Equality for products.\ninstance (GEq' a, GEq' b) => GEq' (a :*: b) where\n  geq' (a1 :*: b1) (a2 :*: b2) = geq' a1 a2 && geq' b1 b2\n```\n为了适应编写类的两种方法(`generic-deriving`或自定义实现),我们可以使用`DefaultSignatures`扩展来允许用户将`typeclass`函数留空，并遵从`Generic`(泛型)或定义它们自己的函数。\n```haskell\n{-# LANGUAGE DefaultSignatures #-}\n\nclass GEq a where\n  geq :: a -> a -> Bool\n\n  default geq :: (Generic a, GEq' (Rep a)) => a -> a -> Bool\n  geq x y = geq' (from x) (from y)\n```\n现在，使用我们库的任何人都只需要(派生)`derive Generic`并创建我们的`typeclass`实例的空实例，而无需为`GEq`编写任何样板。\n\n以下是`deriving equality generics`(派生相等泛型)的完整示例:\n```haskell\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE DefaultSignatures #-}\n\nimport GHC.Generics\n\n-- Auxiliary class\nclass GEq' f where\n  geq' :: f a -> f a -> Bool\n\ninstance GEq' U1 where\n  geq' _ _ = True\n\ninstance (GEq c) => GEq' (K1 i c) where\n  geq' (K1 a) (K1 b) = geq a b\n\ninstance (GEq' a) => GEq' (M1 i c a) where\n  geq' (M1 a) (M1 b) = geq' a b\n\ninstance (GEq' a, GEq' b) => GEq' (a :+: b) where\n  geq' (L1 a) (L1 b) = geq' a b\n  geq' (R1 a) (R1 b) = geq' a b\n  geq' _      _      = False\n\ninstance (GEq' a, GEq' b) => GEq' (a :*: b) where\n  geq' (a1 :*: b1) (a2 :*: b2) = geq' a1 a2 && geq' b1 b2\n\n--\nclass GEq a where\n  geq :: a -> a -> Bool\n  default geq :: (Generic a, GEq' (Rep a)) => a -> a -> Bool\n  geq x y = geq' (from x) (from y)\n\n-- Base equalities\ninstance GEq Char where geq = (==)\ninstance GEq Int where geq = (==)\ninstance GEq Float where geq = (==)\n\n-- Equalities derived from structure of (:+:) and (:*:)\ninstance GEq a => GEq (Maybe a)\ninstance (GEq a, GEq b) => GEq (a,b)\n\nmain :: IO ()\nmain = do\n  print $ geq 2 (3 :: Int)\n  print $ geq 'a' 'b'\n  print $ geq (Just 'a') (Just 'a')\n  print $ geq ('a','b') ('a', 'b')\n```\n請看:\n* [Cooking Classes with Datatype Generic Programming](http://www.stephendiehl.com/posts/generics.html)\n* [Datatype-generic Programming in Haskell](http://www.andres-loeh.de/DGP-Intro.pdf)\n* [generic-deriving](http://hackage.haskell.org/package/generic-deriving-1.6.3)\n\n### Generic Deriving\n使用`Generics`(泛型)，许多通用库提供了一种派生`common`(通用)类型类实例的机制。一些真实的例子：\n[hashable](http://hackage.haskell.org/package/hashable)库允许我们派生`hash`函数。\n```haskell\n{-# LANGUAGE DeriveGeneric #-}\n\nimport GHC.Generics (Generic)\nimport Data.Hashable\n\ndata Color = Red | Green | Blue deriving (Generic, Show)\n\ninstance Hashable Color where\n\nexample1 :: Int\nexample1 = hash Red\n-- 839657738087498284\n\nexample2 :: Int\nexample2 = hashWithSalt 0xDEADBEEF Red\n-- 62679985974121021\n```\n[cereal](http://hackage.haskell.org/package/cereal-0.4.0.1)库允许我们派生二进制表示。\n```haskell\n{-# LANGUAGE DeriveGeneric #-}\n\nimport Data.Word\nimport Data.ByteString\nimport Data.Serialize\n\nimport GHC.Generics\n\ndata Val = A [Val] | B [(Val, Val)] | C\n  deriving (Generic, Show)\n\ninstance Serialize Val where\n\nencoded :: ByteString\nencoded = encode (A [B [(C, C)]])\n-- \"\\NUL\\NUL\\NUL\\NUL\\NUL\\NUL\\NUL\\NUL\\SOH\\SOH\\NUL\\NUL\\NUL\\NUL\\NUL\\NUL\\NUL\\SOH\\STX\\STX\"\n\nbytes :: [Word8]\nbytes = unpack encoded\n-- [0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,2,2]\n\ndecoded :: Either String Val\ndecoded = decode encoded\n```\n[aeson](http://hackage.haskell.org/package/aeson)库允许我们為`JSON instances`派生JSON表示形式。\n```haskell\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Data.Aeson\nimport GHC.Generics\n\ndata Point = Point { _x :: Double, _y :: Double }\n   deriving (Show, Generic)\n\ninstance FromJSON Point\ninstance ToJSON Point\n\nexample1 :: Maybe Point\nexample1 = decode \"{\\\"x\\\":3.0,\\\"y\\\":-1.0}\"\n\nexample2 = encode $ Point 123.4 20\n```\n請看: [A Generic Deriving Mechanism for Haskell](http://dreixel.net/research/pdf/gdmh.pdf) (Haskell的通用派生机制)\n\n#### Higher Kinded Generics\n使用相同的接口`GHC.Generics`为`higher-kinded`(更高种类)的`generics`(泛型)提供了单独的类型类。\n```haskell\nclass Generic1 f where\n  type Rep1 f :: * -> *\n  from1  :: f a -> (Rep1 f) a\n  to1    :: (Rep1 f) a -> f a\n```\n例如`Maybe`的`Rep1`实例格式为：\n```haskell\ntype instance Rep1 Maybe\n  = D1\n      GHC.Generics.D1Maybe\n      (C1 C1_0Maybe U1\n       :+: C1 C1_1Maybe (S1 NoSelector Par1))\n```\n\n### generics-sop\n> TODO\n\n\n### Uniplate\n`Uniplate`是用于编写遍历和转换任意数据结构的泛型库。这对于编写`AST`转换和`rewriting systems`(重写系统)非常有用。\n```haskell\nplate :: from -> Type from to\n(|*)  :: Type (to -> from) to -> to -> Type from to\n(|-)  :: Type (item -> from) to -> item -> Type from to\n\ndescend   :: Uniplate on => (on -> on) -> on -> on\ntransform :: Uniplate on => (on -> on) -> on -> on\nrewrite   :: Uniplate on => (on -> Maybe on) -> on -> on\n```\n`descend`函数将对表达式的每个直接后代应用一个函数，然后将它们`combines`(组合)到父表达式。\n\n`transform`函數将对表达式中的所有项执行一次自下而上的转换。\n\n`rewrite`函数将把表达式中的所有项彻底转换为`fixed point`(不动点)，使用`Maybe`表示终止。\n```haskell\nimport Data.Generics.Uniplate.Direct\n\ndata Expr a\n  = Fls\n  | Tru\n  | Var a\n  | Not (Expr a)\n  | And (Expr a) (Expr a)\n  | Or  (Expr a) (Expr a)\n  deriving (Show, Eq)\n\ninstance Uniplate (Expr a) where\n  uniplate (Not f)     = plate Not |* f\n  uniplate (And f1 f2) = plate And |* f1 |* f2\n  uniplate (Or f1 f2)  = plate Or |* f1 |* f2\n  uniplate x           = plate x\n\nsimplify :: Expr a -> Expr a\nsimplify = transform simp\n where\n   simp (Not (Not f)) = f\n   simp (Not Fls) = Tru\n   simp (Not Tru) = Fls\n   simp x = x\n\nreduce :: Show a => Expr a -> Expr a\nreduce = rewrite cnf\n  where\n    -- double negation\n    cnf (Not (Not p)) = Just p\n\n    -- de Morgan\n    cnf (Not (p `Or` q))  = Just $ (Not p) `And` (Not q)\n    cnf (Not (p `And` q)) = Just $ (Not p) `Or` (Not q)\n\n    -- distribute conjunctions\n    cnf (p `Or` (q `And` r)) = Just $ (p `Or` q) `And` (p `Or` r)\n    cnf ((p `And` q) `Or` r) = Just $ (p `Or` q) `And` (p `Or` r)\n    cnf _ = Nothing\n\n\nexample1 :: Expr String\nexample1 = simplify (Not (Not (Not (Not (Var \"a\")))))\n-- Var \"a\"\n\nexample2 :: [String]\nexample2 = [a | Var a <- universe ex]\n  where\n    ex = Or (And (Var \"a\") (Var \"b\")) (Not (And (Var \"c\") (Var \"d\")))\n-- [\"a\",\"b\",\"c\",\"d\"]\n\nexample3 :: Expr String\nexample3 = reduce $ ((a `And` b) `Or` (c `And` d)) `Or` e\n  where\n    a = Var \"a\"\n    b = Var \"b\"\n    c = Var \"c\"\n    d = Var \"d\"\n    e = Var \"e\"\n```\n另外，`Uniplate`实例可以从`Data`实例自动派生而无需显式编写`Uniplate`实例。这种方法在显式的手写实例上会产生少量开销。\n```haskell\nimport Data.Data\nimport Data.Typeable\nimport Data.Generics.Uniplate.Data\n\ndata Expr a\n  = Fls\n  | Tru\n  | Lit a\n  | Not (Expr a)\n  | And (Expr a) (Expr a)\n  | Or (Expr a) (Expr a)\n  deriving (Data, Typeable, Show, Eq)\n```\n\n#### Biplate\n`Biplates`泛化目标类型不一定与源类型相同的`plates`(板)，它使用多参数类型类来指示`sub-target`(子目标)的`type sub`(类型子)。\n`Uniplate`函数都具有等价的广义`biplate`形式。\n```haskell\ndescendBi   :: Biplate from to => (to -> to) -> from -> from\ntransformBi :: Biplate from to => (to -> to) -> from -> from\nrewriteBi   :: Biplate from to => (to -> Maybe to) -> from -> from\n\ndescendBiM   :: (Monad m, Biplate from to) => (to -> m to) -> from -> m from\ntransformBiM :: (Monad m, Biplate from to) => (to -> m to) -> from -> m from\nrewriteBiM   :: (Monad m, Biplate from to) => (to -> m (Maybe to)) -> from -> m from\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE FlexibleContexts #-}\n\nimport Data.Generics.Uniplate.Direct\n\ntype Name = String\n\ndata Expr\n  = Var Name\n  | Lam Name Expr\n  | App Expr Expr\n  deriving Show\n\ndata Stmt\n  = Decl [Stmt]\n  | Let Name Expr\n  deriving Show\n\ninstance Uniplate Expr where\n  uniplate (Var x  ) = plate Var |- x\n  uniplate (App x y) = plate App |* x |* y\n  uniplate (Lam x y) = plate Lam |- x |* y\n\ninstance Biplate Expr Expr where\n  biplate = plateSelf\n\ninstance Uniplate Stmt where\n  uniplate (Decl x  ) = plate Decl ||* x\n  uniplate (Let x y) = plate Let |-  x |- y\n\ninstance Biplate Stmt Stmt where\n  biplate = plateSelf\n\ninstance Biplate Stmt Expr where\n  biplate (Decl x) = plate Decl ||+ x\n  biplate (Let x y) = plate Let |- x |* y\n\nrename :: Name -> Name -> Expr -> Expr\nrename from to = rewrite f\n  where\n    f (Var a) | a == from = Just (Var to)\n    f (Lam a b) | a == from = Just (Lam to b)\n    f _ = Nothing\n\ns, k, sk :: Expr\ns = Lam \"x\" (Lam \"y\" (Lam \"z\" (App (App (Var \"x\") (Var \"z\")) (App (Var \"y\") (Var \"z\")))))\nk = Lam \"x\" (Lam \"y\" (Var \"x\"))\nsk = App s k\n\nm :: Stmt\nm = descendBi f $ Decl [ (Let \"s\" s) , Let \"k\" k , Let \"sk\" sk ]\n  where\n    f = rename \"x\" \"a\"\n      . rename \"y\" \"b\"\n      . rename \"z\" \"c\"\n```","tags":["Generics"]},{"title":"Haskell-Promotion","url":"/blog/2019/10/09/Haskell-Promotion/","content":"> http://dev.stephendiehl.com/hask/#promotion\n\n### Higher Kinded Types\n`higher kinded types`是什麼?\n与大多数其他语言相比，`Haskell`中的`kind`系统是独特的，因为它允许构造将`types`(类型)和`type constructors`(类型构造函数)带到其他类型的`datatypes`(数据类型)。\n据说这样的系统支持`higher kinded types`。\n\n`haskell`中的所有`Kind`註解都必然会产生一個`kind *`，尽管左边的任何`terms`(术语)都可能是`higher-kinded`(`* -> *`)。\n常见的例子是`Monad`，它的种类为`* -> *`。\n但是我们也已经在`free monads`中看到了这种`higher-kindedness`。\n```haskell\ndata Free f a where\n  Pure :: a -> Free f a\n  Free :: f (Free f a) -> Free f a\n\ndata Cofree f a where\n  Cofree :: a -> f (Cofree f a) -> Cofree f a\nFree :: (* -> *) -> * -> *\nCofree :: (* -> *) -> * -> *\n```\n例如，对于某些`monokinded`(单种)类型`a`的`Cofree Maybe a`可以通过`Maybe :: * -> *`来建模非空列表。\n```haskell\n-- Cofree Maybe a is a non-empty list\ntestCofree :: Cofree Maybe Int\ntestCofree = (Cofree 1 (Just (Cofree 2 Nothing)))\n```\n\n### Kind Polymorphism\n> 这是高级部分，编写Haskell通常不需要了解`kind polymorphism`(种类多态性)。\n\n`regular`(正则/常規)值级函数接受一个函数并将其应用于一个参数，它被普遍地推广到通常的`hindley-milner`方法中。\n```haskell\napp :: forall a b. (a -> b) -> a -> b\napp f a = f a\n```\n但是，当我们在`type-level`(类型级别)执行相同的操作时，我们会发现丢失了有关所应用构造函数的`polymorphism`(多态性)的信息。\n```haskell\n-- TApp :: (* -> *) -> * -> *\ndata TApp f a = MkTApp (f a)\n```\n启用`-XPolyKinds`擴展也会允许`kind`级别的`polymorphic`(多态)变量。\n```haskell\n-- Default:   (* -> *) -> * -> *\n-- PolyKinds: (k -> *) -> k -> *\ndata TApp f a = MkTApp (f a)\n\n-- Default:   ((* -> *) -> (* -> *)) -> (* -> *)\n-- PolyKinds: ((k -> *) -> (k -> *)) -> (k -> *)\ndata Mu f a = Roll (f (Mu f) a)\n\n-- Default:   * -> *\n-- PolyKinds: k -> *\ndata Proxy a = Proxy\n```\n使用`polykinded`(多种类)的`Proxy`类型允许我们在任意`kind`(种类)的构造函数上写下类型类函数。\n```haskell\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n\ndata Proxy a = Proxy\ndata Rep = Rep\n\nclass PolyClass a where\n  foo :: Proxy a -> Rep\n  foo = const Rep\n\n-- () :: *\n-- [] :: * -> *\n-- Either :: * -> * -> *\n\ninstance PolyClass ()\ninstance PolyClass []\ninstance PolyClass Either\n```\n例如，我们现在可以在类型级别上写下`polymorphic`(多态)`S K combinators`(组合器)。\n```haskell\n{-# LANGUAGE PolyKinds #-}\n\nnewtype I (a :: *) = I a\nnewtype K (a :: *) (b :: k) = K a\nnewtype Flip (f :: k1 -> k2 -> *) (x :: k2) (y :: k1) = Flip (f y x)\n\nunI :: I a -> a\nunI (I x) = x\n\nunK :: K a b -> a\nunK (K x) = x\n\nunFlip :: Flip f x y -> f y x\nunFlip (Flip x) = x\n```\n\n### Data Kinds\n> 这是高级部分，编写Haskell通常不需要了解`Data Kinds`。\n\n`-XDataKinds`扩展允许我们在值级别和类型级别使用`refer to`(引用)构造函数。考虑一个简单的`sum`类型:\n```haskell\ndata S a b = L a | R b\n\n-- S :: * -> * -> *\n-- L :: a -> S a b\n-- R :: b -> S a b\n```\n启用扩展后，我们可以看到我们的类型构造函数现在已自动升级，因此可以将`L`或`R`视为类型为`S`的数据构造函数或`kind`(種類)为`S`的`L`类型的数据构造器。\n\n```haskell\n{-# LANGUAGE DataKinds #-}\n\ndata S a b = L a | R b\n\n-- S :: * -> * -> *\n-- L :: * -> S * *\n-- R :: * -> S * *\n```\n可以在类型签名中以单引号作为前缀来引用升级的数据构造函数。\n同样重要的是，默认情况下，这些提升的构造函数不随模块一起导出，但是可以为勾选的`promoted`(提升)类型创建`type synonym`(类型同义词)实例，并直接将其导出。\n```haskell\ndata Foo = Bar | Baz\ntype Bar = 'Bar\ntype Baz = 'Baz\n```\n将此与`type families`相结合，我们看到可以通过将`types`(类型)提升到`kind`(种类)级别来编写有意义的类型级别的函数。\n```haskell\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE DataKinds #-}\n\nimport Prelude hiding (Bool(..))\n\ndata Bool = False | True\n\ntype family Not (a :: Bool) :: Bool\n\ntype instance Not True = False\ntype instance Not False = True\n\nfalse :: Not True ~ False => a\nfalse = undefined\n\ntrue :: Not False ~ True => a\ntrue = undefined\n\n-- Fails at compile time.\n-- Couldn't match type 'False with 'True\ninvalid :: Not True ~ True => a\ninvalid = undefined\n```\n\n\n### Size-Indexed Vectors\n\n使用这种新结构，我们现在可以创建一个`Vec`类型，该类型通过其长度和元素类型进行参数化，因为我们有一种`kind`(种类)丰富的语言，足以在广义代数数据类型的`kind`(种类)签名中对后继类型进行编码。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FlexibleContexts #-}\n\ndata Nat = Z | S Nat deriving (Eq, Show)\n\ntype Zero  = Z\ntype One   = S Zero\ntype Two   = S One\ntype Three = S Two\ntype Four  = S Three\ntype Five  = S Four\n\ndata Vec :: Nat -> * -> * where\n  Nil :: Vec Z a\n  Cons :: a -> Vec n a -> Vec (S n) a\n\ninstance Show a => Show (Vec n a) where\n  show Nil         = \"Nil\"\n  show (Cons x xs) = \"Cons \" ++ show x ++ \" (\" ++ show xs ++ \")\"\n\nclass FromList n where\n  fromList :: [a] -> Vec n a\n\ninstance FromList Z where\n  fromList [] = Nil\n\ninstance FromList n => FromList (S n) where\n  fromList (x:xs) = Cons x $ fromList xs\n\n\nlengthVec :: Vec n a -> Nat\nlengthVec Nil = Z\nlengthVec (Cons x xs) = S (lengthVec xs)\n\nzipVec :: Vec n a -> Vec n b -> Vec n (a,b)\nzipVec Nil Nil = Nil\nzipVec (Cons x xs) (Cons y ys) = Cons (x,y) (zipVec xs ys)\n\nvec4 :: Vec Four Int\nvec4 = fromList [0, 1, 2, 3]\n\nvec5 :: Vec Five Int\nvec5 = fromList [0, 1, 2, 3, 4]\n\n\nexample1 :: Nat\nexample1 = lengthVec vec4\n-- S (S (S (S Z)))\n\nexample2 :: Vec Four (Int, Int)\nexample2 = zipVec vec4 vec4\n-- Cons (0,0) (Cons (1,1) (Cons (2,2) (Cons (3,3) (Nil))))\n```\n所以现在如果我们尝试`zip`两个形状错误的`vec`类型，那么在编译时会得到一个关于`off by one`错误的错误。\n```haskell\nexample2 = zipVec vec4 vec5\n-- Couldn't match type 'S 'Z with 'Z\n-- Expected type: Vec Four Int\n--   Actual type: Vec Five Int\n```\n我们可以使用相同的技术来创建一个由空或非空标志静态索引的容器,这样,如果我们尝试获取空列表的头部,则会得到编译时错误,或者等效地声明为我們有义务向编译器证明我们传递给`head`函数的参数是非空的。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FlexibleContexts #-}\n\ndata Size = Empty | NonEmpty\n\ndata List a b where\n  Nil  :: List Empty a\n  Cons :: a -> List b a -> List NonEmpty a\n\nhead' :: List NonEmpty a -> a\nhead' (Cons x _) = x\n\nexample1 :: Int\nexample1 = head' (1 `Cons` (2 `Cons` Nil))\n\n-- Cannot match type Empty with NonEmpty\nexample2 :: Int\nexample2 = head' Nil\nCouldn't match type None with Many\nExpected type: List NonEmpty Int\n  Actual type: List Empty Int\n```\n\n請看: [Giving Haskell a Promotion](https://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf)\n\n\n### Typelevel Numbers\n`GHC`的`type literals`(类型文字)也可以用来代替显式`Peano`算术。\n\n`GHC 7.6`在执行`reduction`(约简)方面非常保守，而`GHC 7.8`则要少得多，它可以解决许多涉及自然数的类型级约束，但有时仍需要一点儿`coaxing`(哄骗)。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE TypeOperators #-}\n\nimport GHC.TypeLits\n\ndata Vec :: Nat -> * -> * where\n  Nil :: Vec 0 a\n  Cons :: a -> Vec n a -> Vec (1 + n) a\n\n-- GHC 7.6 will not reduce\n-- vec3 :: Vec (1 + (1 + (1 + 0))) Int\n\nvec3 :: Vec 3 Int\nvec3 = 0 `Cons` (1 `Cons` (2 `Cons` Nil))\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE FlexibleContexts #-}\n\nimport GHC.TypeLits\nimport Data.Type.Equality\n\ndata Foo :: Nat -> * where\n  Small    :: (n <= 2)  => Foo n\n  Big      :: (3 <= n) => Foo n\n\n  Empty    :: ((n == 0) ~ True) => Foo n\n  NonEmpty :: ((n == 0) ~ False) => Foo n\n\nbig :: Foo 10\nbig = Big\n\nsmall :: Foo 2\nsmall = Small\n\nempty :: Foo 0\nempty = Empty\n\nnonempty :: Foo 3\nnonempty = NonEmpty\n```\n請看: [Type-Level Literals](http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/type-level-literals.html)  \n\n### Typelevel Strings\n> TODO\n\n### Custom Errors\n从`GHC 8.0`开始，我们可以使用`type families`提供自定义类型错误。\n消息本身`hook into`(挂接)到`GHC`中，并使用在`GHC.TypeLits`中找到的小`datatype`(数据类型)表示。\n```haskell\ndata ErrorMessage where\n  Text :: Symbol -> ErrorMessage\n  ShowType :: t -> ErrorMessage\n\n  -- Put two messages next to each other\n  (:<>:) :: ErrorMessage -> ErrorMessage -> ErrorMessage\n\n  -- Put two messages on top of each other\n  (:$$:) :: ErrorMessage -> ErrorMessage -> ErrorMessage\n```\n如果在表达式的签名中找到這些表达式中的任意一個，`GHC`将报告以下形式的错误消息：\n```haskell\nexample.hs:1:1: error:\n    • My custom error message line 1.\n    • My custom error message line 2.\n    • In the expression: example\n      In an equation for ‘foo’: foo = ECoerce (EFloat 3) (EInt 4)\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nimport GHC.TypeLits\n\ninstance\n  -- Error Message\n  TypeError (Text \"Equality is not defined for functions\"\n  :$$:\n  (ShowType a :<>: Text \" -> \" :<>: ShowType b))\n\n  -- Instance head\n  => Eq (a -> b) where (==) = undefined\n\n-- Fail when we try to equate two functions\nexample = id == id\n```\n一个不太人为的示例是创建一个类型安全的嵌入式`DSL`，该类型的`DSL`在类型级别上强制实现`semantics`(语义上)的`invariants`(不变性)。 一段时间以来，我们已经能够使用`GADT`和`type-families`来做这种事情，但是错误报告却非常可怕。使用`GHC 8.0`，我们可以拥有`type-families`，它可以发出有用的类型错误，以反映实际出了什么问题，并将其集成到`GHC`中。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nimport GHC.TypeLits\n\ntype family Coerce a b where\n  Coerce Int Int     = Int\n  Coerce Float Float = Float\n  Coerce Int Float   = Float\n  Coerce Float Int   = TypeError (Text \"Cannot cast to smaller type\")\n\ndata Expr a where\n  EInt    :: Int -> Expr Int\n  EFloat  :: Float -> Expr Float\n  ECoerce :: Expr b -> Expr c -> Expr (Coerce b c)\n\nfoo :: Expr Int\nfoo = ECoerce (EFloat 3) (EInt 4)\n```\n\n### Type Equality\n继续以在`Haskell`中构建更详尽的证明为主题，`ghc 7.8`最近附带了`data.type.equality`模块，该模块为我们提供了一组扩展的类型级操作集，用于将`the equality of types`(类型相等)表示为`values`(值)、`constraints`(约束)和`promoted booleans`(提升的布尔值)。\n```haskell\n(~)   :: k -> k -> Constraint\n(==)  :: k -> k -> Bool\n(<=)  :: Nat -> Nat -> Constraint\n(<=?) :: Nat -> Nat -> Bool\n(+)   :: Nat -> Nat -> Nat\n(-)   :: Nat -> Nat -> Nat\n(*)   :: Nat -> Nat -> Nat\n(^)   :: Nat -> Nat -> Nat\n(:~:)     :: k -> k -> *\nRefl      :: a1 :~: a1\nsym       :: (a :~: b) -> b :~: a\ntrans     :: (a :~: b) -> (b :~: c) -> a :~: c\ncastWith  :: (a :~: b) -> a -> b\ngcastWith :: (a :~: b) -> (a ~ b => r) -> r\n```\n这样，我们就有了一种更强大的语言来编写可以在编译时检查的`restrictions`(限制/限定/框框)，以及一种将允许我们(稍后)编写更高级的证明的机制。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE ConstraintKinds #-}\n\nimport GHC.TypeLits\nimport Data.Type.Equality\n\ntype Not a b = ((b == a) ~ False)\n\nrestrictUnit :: Not () a => a -> a\nrestrictUnit = id\n\nrestrictChar :: Not Char a => a -> a\nrestrictChar = id\n```\n\n### Proxies (代理人)\n对`phantom`(幻影)类型使用`kind polymorphism`(種類多态性)使我们可以表达`Proxy`类型，\n该代理类型由一个没有参数的构造函数`inhabited`(所驻留)，但带有一個(可以携带任意一個類型的)`polykinded`(多種類)幻像类型变量。\n```haskell\n{-# LANGUAGE PolyKinds #-}\n\n-- | A concrete, poly-kinded proxy type\ndata Proxy t = Proxy\nimport Data.Proxy\n\na :: Proxy ()\na = Proxy\n\nb :: Proxy 3\nb = Proxy\n\nc :: Proxy \"symbol\"\nc = Proxy\n\nd :: Proxy Maybe\nd = Proxy\n\ne :: Proxy (Maybe ())\ne = Proxy\n```\n如果我们通常将`undefined`作为类型类字典的`witness`(见证)来传递，我们可以改为传递一个带有幻像类型的`Proxy`对象，而无需`bottom`(底部)。\n(`Using scoped type variables we can then operate with the phantom parameter and manipulate wherever is needed.`)\n使用作用域类型变量，我们可以与`phantom`参数`operate with`(合作)，并在需要的地方进行`manipulate`(操作)。\n\n```haskell\nt1 :: a\nt1 = (undefined :: a)\n\nt2 :: Proxy a\nt2 Proxy :: Proxy a\n```\n\n### Promoted Syntax\n我们已经看到使用`DataKinds`提升(`promoted`)了构造函数，但就像在`value-level`上，`GHC`还允许我们为列表和元组使用一些语法糖，而不是显式的`cons`和`pair`。这是通过`-XTypeOperators`扩展启用的，该扩展在`type-level`引入了列表语法和任意`arity`(數)元组。\n```haskell\ndata HList :: [*] -> * where\n  HNil  :: HList '[]\n  HCons :: a -> HList t -> HList (a ': t)\n\ndata Tuple :: (*,*) -> * where\n  Tuple :: a -> b -> Tuple '(a,b)\n```\n使用此方法，我们可以构造所有各种`composite`(复合)类型级别的对象。\n```haskell\nλ: :kind 1\n1 :: Nat\n\nλ: :kind \"foo\"\n\"foo\" :: Symbol\n\nλ: :kind [1,2,3]\n[1,2,3] :: [Nat]\n\nλ: :kind [Int, Bool, Char]\n[Int, Bool, Char] :: [*]\n\nλ: :kind Just [Int, Bool, Char]\nJust [Int, Bool, Char] :: Maybe [*]\n\nλ: :kind '(\"a\", Int)\n(,) Symbol *\n\nλ: :kind [ '(\"a\", Int), '(\"b\", Bool) ]\n[ '(\"a\", Int), '(\"b\", Bool) ] :: [(,) Symbol *]\n```\n\n### Singleton Types\n> 这是高级部分，编写Haskell通常不需要`Singleton Types`知识。\n\n单例类型是具有单个值`inhabitant`(居民/實例)的类型。可以使用`GADTs`或`data families`以多种方式构造`Singleton`(单例)类型。\n```haskell\ndata instance Sing (a :: Nat) where\n  SZ :: Sing 'Z\n  SS :: Sing n -> Sing ('S n)\n\ndata instance Sing (a :: Maybe k) where\n  SNothing :: Sing 'Nothing\n  SJust :: Sing x -> Sing ('Just x)\n\ndata instance Sing (a :: Bool) where\n  STrue :: Sing True\n  SFalse :: Sing False\n```\n#### Promoted Naturals\n![](img/01.png)\n`singleton`类型是`haskell`中伪造`dependent types`(依赖类型)的小型家庭工业的一个组成部分，即使用基于值的`terms`(术语)构造类型。\n单例类型是通过将类型和值之间的映射建模为类型的结构属性来`cheating`(作弊)的一种方式。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE TypeSynonymInstances #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nimport Data.Proxy\nimport GHC.Exts (Any)\nimport Prelude hiding (succ)\n\ndata Nat = Z | S Nat\n\n-- kind-indexed data family\ndata family Sing (a :: k)\n\ndata instance Sing (a :: Nat) where\n  SZ :: Sing 'Z\n  SS :: Sing n -> Sing ('S n)\n\ndata instance Sing (a :: Maybe k) where\n  SNothing :: Sing 'Nothing\n  SJust :: Sing x -> Sing ('Just x)\n\ndata instance Sing (a :: Bool) where\n  STrue :: Sing True\n  SFalse :: Sing False\n\ndata Fin (n :: Nat) where\n  FZ :: Fin (S n)\n  FS :: Fin n -> Fin (S n)\n\ndata Vec a n where\n  Nil  :: Vec a Z\n  Cons :: a -> Vec a n -> Vec a (S n)\n\nclass SingI (a :: k) where\n  sing :: Sing a\n\ninstance SingI Z where\n  sing = SZ\n\ninstance SingI n => SingI (S n) where\n  sing = SS sing\n\nderiving instance Show Nat\nderiving instance Show (SNat a)\nderiving instance Show (SBool a)\nderiving instance Show (Fin a)\nderiving instance Show a => Show (Vec a n)\n\ntype family (m :: Nat) :+ (n :: Nat) :: Nat where\n  Z :+ n = n\n  S m :+ n = S (m :+ n)\n\ntype SNat (k :: Nat) = Sing k\ntype SBool (k :: Bool) = Sing k\ntype SMaybe (b :: a) (k :: Maybe a) = Sing k\n\nsize :: Vec a n -> SNat n\nsize Nil         = SZ\nsize (Cons x xs) = SS (size xs)\n\nforget :: SNat n -> Nat\nforget SZ = Z\nforget (SS n) = S (forget n)\n\nnatToInt :: Integral n => Nat -> n\nnatToInt Z     = 0\nnatToInt (S n) = natToInt n + 1\n\nintToNat :: (Integral a, Ord a) => a -> Nat\nintToNat 0 = Z\nintToNat n = S $ intToNat (n - 1)\n\nsNatToInt :: Num n => SNat x -> n\nsNatToInt SZ     = 0\nsNatToInt (SS n) = sNatToInt n + 1\n\nindex :: Fin n -> Vec a n -> a\nindex FZ (Cons x _)      = x\nindex (FS n) (Cons _ xs) = index n xs\n\n\ntest1 :: Fin (S (S (S Z)))\ntest1 = FS (FS FZ)\n\ntest2 :: Int\ntest2 = index FZ (1 `Cons` (2 `Cons` Nil))\n\ntest3 :: Sing ('Just ('S ('S Z)))\ntest3 = SJust (SS (SS SZ))\n\ntest4 :: Sing ('S ('S Z))\ntest4 = SS (SS SZ)\n\n-- polymorphic constructor SingI\ntest5 :: Sing ('S ('S Z))\ntest5 = sing\n```\n`GHC.TypeLits`中提供的内置单例类型具有有用的实现，即:即使存在下，类型级别的值也可以反映到值级别并`back up`(备份)到类型级别。\n```haskell\nsomeNatVal :: Integer -> Maybe SomeNat\nsomeSymbolVal :: String -> SomeSymbol\n\nnatVal :: KnownNat n => proxy n -> Integer\nsymbolVal :: KnownSymbol n => proxy n -> String\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE TypeOperators #-}\n\nimport Data.Proxy\nimport GHC.TypeLits\n\na :: Integer\na = natVal (Proxy :: Proxy 1)\n-- 1\n\nb :: String\nb = symbolVal (Proxy :: Proxy \"foo\")\n-- \"foo\"\n\nc :: Integer\nc = natVal (Proxy :: Proxy (2 + 3))\n-- 5\n```\n\n### Closed Type Families\n到目前为止，在我们使用的类型族(称为`open type families`)中，没有概念涉及类型级函数中的`equations`(方程)的顺序。\n`type-family`可以在代码解析中的任何位置进行扩展，只需按顺序通过可用的定义即可进行扩展。`Closed type-families`(封闭类型家族)允许另一种声明，该声明为`resolution`(解决方案)提供`a base cas`(基本情况)，从而使我们能够实际地对类型(在类型上)编写递归函数。\n例如，考虑我们是否要编写一个函数，该函数对函数类型中的参数进行计数，并在值级别进行`reifies`(具体化)。\n```haskell\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nimport Data.Proxy\nimport GHC.TypeLits\n\ntype family Count (f :: *) :: Nat where\n  Count (a -> b) = 1 + (Count b)\n  Count x = 1\n\ntype Fn1 = Int -> Int\ntype Fn2 = Int -> Int -> Int -> Int\n\nfn1 :: Integer\nfn1 = natVal (Proxy :: Proxy (Count Fn1))\n-- 2\n\nfn2 :: Integer\nfn2 = natVal (Proxy :: Proxy (Count Fn2))\n-- 4\n```\n我们现在可以写下的各种函数都相当出色，允许我们在类型级别编写有意义的逻辑。\n```haskell\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nimport GHC.TypeLits\nimport Data.Proxy\nimport Data.Type.Equality\n\n-- Type-level functions over type-level lists.\n\ntype family Reverse (xs :: [k]) :: [k] where\n  Reverse '[] = '[]\n  Reverse xs = Rev xs '[]\n\ntype family Rev (xs :: [k]) (ys :: [k]) :: [k] where\n  Rev '[] i = i\n  Rev (x ': xs) i = Rev xs (x ': i)\n\ntype family Length (as :: [k]) :: Nat where\n  Length '[] = 0\n  Length (x ': xs) = 1 + Length xs\n\ntype family If (p :: Bool) (a :: k) (b :: k) :: k where\n  If True a b = a\n  If False a b = b\n\ntype family Concat (as :: [k]) (bs :: [k]) :: [k] where\n  Concat a '[] = a\n  Concat '[] b = b\n  Concat (a ': as) bs = a ': Concat as bs\n\ntype family Map (f :: a -> b) (as :: [a]) :: [b] where\n  Map f '[] = '[]\n  Map f (x ': xs) = f x ': Map f xs\n\ntype family Sum (xs :: [Nat]) :: Nat where\n  Sum '[] = 0\n  Sum (x ': xs) = x + Sum xs\n\nex1 :: Reverse [1,2,3] ~ [3,2,1] => Proxy a\nex1 = Proxy\n\nex2 :: Length [1,2,3] ~ 3 => Proxy a\nex2 = Proxy\n\nex3 :: (Length [1,2,3]) ~ (Length (Reverse [1,2,3])) => Proxy a\nex3 = Proxy\n\n-- Reflecting type level computations back to the value level.\nex4 :: Integer\nex4 = natVal (Proxy :: Proxy (Length (Concat [1,2,3] [4,5,6])))\n-- 6\n\nex5 :: Integer\nex5 = natVal (Proxy :: Proxy (Sum [1,2,3]))\n-- 6\n\n-- Couldn't match type ‘2’ with ‘1’\nex6 :: Reverse [1,2,3] ~ [3,1,2] => Proxy a\nex6 = Proxy\n```\n`type family`函数的结果也不一定要`kinded`(归)为`(*)`。例如，允许使用`Nat`或`Constraint`(约束)。\n```haskell\ntype family Elem (a :: k) (bs :: [k]) :: Constraint where\n  Elem a (a ': bs) = (() :: Constraint)\n  Elem a (b ': bs) = a `Elem` bs\n\ntype family Sum (ns :: [Nat]) :: Nat where\n  Sum '[] = 0\n  Sum (n ': ns) = n + Sum ns\n```\n\n### Kind Indexed Type Families\n> 这是高级部分，编写Haskell通常不需要。\n\n正如通常在`types`(类型)上对`typeclasses`建立索引一样，\n`type families`也可以在`kinds`(种类)上建立索引，这些`kinds`(种类)作为类型变量的显式`kind`(种类)签名给出。\n```haskell\ntype family (a :: k) == (b :: k) :: Bool\ntype instance a == b = EqStar a b\ntype instance a == b = EqArrow a b\ntype instance a == b = EqBool a b\n\ntype family EqStar (a :: *) (b :: *) where\n  EqStar a a = True\n  EqStar a b = False\n\ntype family EqArrow (a :: k1 -> k2) (b :: k1 -> k2) where\n  EqArrow a a = True\n  EqArrow a b = False\n\ntype family EqBool a b where\n  EqBool True  True  = True\n  EqBool False False = True\n  EqBool a     b     = False\n\ntype family EqList a b where\n  EqList '[]        '[]        = True\n  EqList (h1 ': t1) (h2 ': t2) = (h1 == h2) && (t1 == t2)\n  EqList a          b          = False\n\ntype family a && b where\n  True && True = True\n  a    && a    = False\n```\n\n### Promoted Symbols\n```haskell\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE ConstraintKinds #-}\n\n\nimport GHC.TypeLits\nimport Data.Type.Equality\n\ndata Label (l :: Symbol) = Get\n\nclass Has a l b | a l -> b where\n  from :: a -> Label l -> b\n\ndata Point2D = Point2 Double Double deriving Show\ndata Point3D = Point3 Double Double Double deriving Show\n\ninstance Has Point2D \"x\" Double where\n  from (Point2 x _) _ = x\n\ninstance Has Point2D \"y\" Double where\n  from (Point2 _ y) _ = y\n\n\ninstance Has Point3D \"x\" Double where\n  from (Point3 x _ _) _ = x\n\ninstance Has Point3D \"y\" Double where\n  from (Point3 _ y _) _ = y\n\ninstance Has Point3D \"z\" Double where\n  from (Point3 _ _ z) _ = z\n\n\ninfixl 6 #\n\n(#) :: a -> (a -> b) -> b\n(#) = flip ($)\n\n_x :: Has a \"x\" b => a -> b\n_x pnt = from pnt (Get :: Label \"x\")\n\n_y :: Has a \"y\" b => a -> b\n_y pnt = from pnt (Get :: Label \"y\")\n\n_z :: Has a \"z\" b => a -> b\n_z pnt = from pnt (Get :: Label \"z\")\n\ntype Point a r = (Has a \"x\" r, Has a \"y\" r)\n\ndistance :: (Point a r, Point b r, Floating r) => a -> b -> r\ndistance p1 p2 = sqrt (d1^2 + d2^2)\n  where\n    d1 = (p1 # _x) + (p1 # _y)\n    d2 = (p2 # _x) + (p2 # _y)\n\nmain :: IO ()\nmain = do\n  print $ (Point2 10 20) # _x\n\n  -- Fails with: No instance for (Has Point2D \"z\" a0)\n  -- print $ (Point2 10 20) # _z\n\n  print $ (Point3 10 20 30) # _x\n  print $ (Point3 10 20 30) # _z\n\n  print $ distance (Point2 1 3) (Point2 2 7)\n  print $ distance (Point2 1 3) (Point3 2 7 4)\n  print $ distance (Point3 1 3 5) (Point3 2 7 3)\n```\n由于`record`与`tuple`基本上没有区别，因此我们也可以对记录字段名执行相同的`kind`构造。\n```haskell\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE ExistentialQuantification #-}\n{-# LANGUAGE ConstraintKinds #-}\n\n\nimport GHC.TypeLits\n\nnewtype Field (n :: Symbol) v = Field { unField :: v }\n  deriving Show\n\ndata Person1 = Person1\n  { _age      :: Field \"age\" Int\n  , _name     :: Field \"name\" String\n  }\n\ndata Person2 = Person2\n  { _age'  :: Field \"age\" Int\n  , _name' :: Field \"name\" String\n  , _lib'  :: Field \"lib\" String\n  }\n\nderiving instance Show Person1\nderiving instance Show Person2\n\ndata Label (l :: Symbol) = Get\n\nclass Has a l b | a l -> b where\n  from :: a -> Label l -> b\n\ninstance Has Person1 \"age\" Int where\n  from (Person1 a _) _ = unField a\n\ninstance Has Person1 \"name\" String where\n  from (Person1 _ a) _ = unField a\n\ninstance Has Person2 \"age\" Int where\n  from (Person2 a _ _) _ = unField a\n\ninstance Has Person2 \"name\" String where\n  from (Person2 _ a _) _ = unField a\n\nage :: Has a \"age\" b => a -> b\nage pnt = from pnt (Get :: Label \"age\")\n\nname :: Has a \"name\" b => a -> b\nname pnt = from pnt (Get :: Label \"name\")\n\n-- Parameterized constraint kind for \"Simon-ness\" of a record.\ntype Simon a = (Has a \"name\" String, Has a \"age\" Int)\n\nspj :: Person1\nspj = Person1 (Field 56) (Field \"Simon Peyton Jones\")\n\nsmarlow :: Person2\nsmarlow = Person2 (Field 38) (Field \"Simon Marlow\") (Field \"rts\")\n\n\ncatNames :: (Simon a, Simon b) => a -> b -> String\ncatNames a b = name a ++ name b\n\naddAges :: (Simon a, Simon b) => a -> b -> Int\naddAges a b = age a + age b\n\n\nnames :: String\nnames = name smarlow ++ \",\" ++ name spj\n-- \"Simon Marlow,Simon Peyton Jones\"\n\nages :: Int\nages = age spj + age smarlow\n-- 94\n```\n值得注意的是，这种方法大部分只是所有样板类实例化，可以使用`TemplateHaskell`或`Generic deriving`(泛型派生)将其抽象化。\n\n### HLists\n> 这是高级部分，编写Haskell通常不需要。\n`heterogeneous`(异类)列表是`cons`列表，其类型静态地编码其值的`ordered types`(有序类型)。\n```haskell\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE KindSignatures #-}\n\ninfixr 5 :::\n\ndata HList (ts :: [ * ]) where\n  Nil :: HList '[]\n  (:::) :: t -> HList ts -> HList (t ': ts)\n\n-- Take the head of a non-empty list with the first value as Bool type.\nheadBool :: HList (Bool ': xs) -> Bool\nheadBool hlist = case hlist of\n  (a ::: _) -> a\n\nhlength :: HList x -> Int\nhlength Nil = 0\nhlength (_ ::: b) = 1 + (hlength b)\n\n\ntuple :: (Bool, (String, (Double, ())))\ntuple = (True, (\"foo\", (3.14, ())))\n\nhlist :: HList '[Bool, String , Double , ()]\nhlist = True ::: \"foo\" ::: 3.14 ::: () ::: Nil\n```\n当然，这立即引发了一个问题，即在存在`type-heterogeneity`(类型异质性)的情况下如何将这样的列表打印成字符串。\n\n在这种情况下，我们可以将`type-families`与`constraint kinds`(约束类型)结合使用，以对`HLists`参数应用`Show`来生成`HList`中所有类型都是`Showable`的`aggregate constraint`(聚合约束)，然后派生`Show`实例。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nimport GHC.Exts (Constraint)\n\ninfixr 5 :::\n\ndata HList (ts :: [ * ]) where\n  Nil :: HList '[]\n  (:::) :: t -> HList ts -> HList (t ': ts)\n\ntype family Map (f :: a -> b) (xs :: [a]) :: [b]\ntype instance Map f '[] = '[]\ntype instance Map f (x ': xs) = f x ': Map f xs\n\ntype family Constraints (cs :: [Constraint]) :: Constraint\ntype instance Constraints '[] = ()\ntype instance Constraints (c ': cs) = (c, Constraints cs)\n\ntype AllHave (c :: k -> Constraint) (xs :: [k]) = Constraints (Map c xs)\n\nshowHList :: AllHave Show xs => HList xs -> [String]\nshowHList Nil = []\nshowHList (x ::: xs) = (show x) : showHList xs\n\ninstance AllHave Show xs => Show (HList xs) where\n  show = show . showHList\n\nexample1 :: HList '[Bool, String , Double , ()]\nexample1 = True ::: \"foo\" ::: 3.14 ::: () ::: Nil\n-- [\"True\",\"\\\"foo\\\"\",\"3.14\",\"()\"]\n```\n\n### Typelevel Dictionaries\n\n关于`promotion`(晋升)的讨论大部分是关于我们是否可以在类型级别创建数据结构以在编译时存储信息的问题。例如，类型级别`association list`(关联列表)可用于对类型级别`symbols`(符号)和任何其他`promotable`(可推广)类型之间的映射进行建模。与`type-families`一起，我们可以写下类型级别的`traversal`(遍历)和`lookup`(查找)函数。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nimport GHC.TypeLits\nimport Data.Proxy\nimport Data.Type.Equality\n\ntype family If (p :: Bool) (a :: k) (b :: k) :: k where\n  If True a b = a\n  If False a b = b\n\ntype family Lookup (k :: a) (ls :: [(a, b)]) :: Maybe b where\n  Lookup k '[] = 'Nothing\n  Lookup k ('(a, b) ': xs) = If (a == k) ('Just b) (Lookup k xs)\n\ntype M = [\n    '(\"a\", 1)\n  , '(\"b\", 2)\n  , '(\"c\", 3)\n  , '(\"d\", 4)\n  ]\n\ntype K = \"a\"\ntype (!!) m (k :: Symbol) a = (Lookup k m) ~ Just a\n\nvalue :: Integer\nvalue = natVal ( Proxy :: (M !! \"a\") a => Proxy a )\n```\n如果我们要求`GHC`展开类型签名，则可以查看类型级映射查找函数的显式实现。\n```haskell\n(!!)\n  :: If\n       (GHC.TypeLits.EqSymbol \"a\" k)\n       ('Just 1)\n       (If\n          (GHC.TypeLits.EqSymbol \"b\" k)\n          ('Just 2)\n          (If\n             (GHC.TypeLits.EqSymbol \"c\" k)\n             ('Just 3)\n             (If (GHC.TypeLits.EqSymbol \"d\" k) ('Just 4) 'Nothing)))\n     ~ 'Just v =>\n     Proxy k -> Proxy v\n```\n\n### Advanced Proofs\n> 这是高级部分，编写Haskell通常不需要。\n\n现在我们有了`length-indexed`(长度索引)的向量，让我们编写反向函数，它有多难？\n所以我们去写下这样的东西:\n```haskell\nreverseNaive :: forall n a. Vec a n -> Vec a n\nreverseNaive xs = go Nil xs -- Error: n + 0 != n\n  where\n    go :: Vec a m -> Vec a n -> Vec a (n :+ m)\n    go acc Nil = acc\n    go acc (Cons x xs) = go (Cons x acc) xs -- Error: n + succ m != succ (n + m)\n```\n运行此命令，我们发现`GHC`对代码中的两行感到不满意:\n```haskell\nCouldn't match type ‘n’ with ‘n :+ 'Z’\n    Expected type: Vec a n\n      Actual type: Vec a (n :+ 'Z)\n\nCould not deduce ((n1 :+ 'S m) ~ 'S (n1 :+ m))\n    Expected type: Vec a1 (k :+ m)\n      Actual type: Vec a1 (n1 :+ 'S m)\n```\n当我们从向量中展开元素时，由于向后合并向量的子部分，最终将对索引进行大量类型级别的算术运算，但结果是，我们发现`GHC`会遇到一些`unification`(统一)错误，因为它不知道自然数的基本算术属性。即`forall n. n + 0 = 0 `和`forall n m. n + (1 + m) = 1 + (n + m)`。当然，我们应该在类型级别上构建一个可以直观地对算术进行建模的系统，但是`GHC`只是一个笨拙的编译器，它不能自动推论自然数和`Peano`数之间的`isomorphism`(同构)，这当然不应该是真正的假设。\n\n因此，在这些`call sites`(调用站点)中，我们现在都有一个证明义务来构造证明条款。回想一下我们对`GADTs`的`propositional equality`(命题平等)的讨论，我们实际上已经有了这样的机制来构造它。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE ExplicitForAll #-}\n\nimport Data.Type.Equality\n\ndata Nat = Z | S Nat\n\ndata SNat n where\n  Zero :: SNat Z\n  Succ :: SNat n -> SNat (S n)\n\ndata Vec :: * -> Nat -> * where\n  Nil :: Vec a Z\n  Cons :: a -> Vec a n -> Vec a (S n)\n\ninstance Show a => Show (Vec a n) where\n  show Nil         = \"Nil\"\n  show (Cons x xs) = \"Cons \" ++ show x ++ \" (\" ++ show xs ++ \")\"\n\ntype family (m :: Nat) :+ (n :: Nat) :: Nat where\n  Z :+ n = n\n  S m :+ n = S (m :+ n)\n\n-- (a ~ b) implies (f a ~ f b)\ncong :: a :~: b -> f a :~: f b\ncong Refl = Refl\n\n-- (a ~ b) implies (f a) implies (f b)\nsubst :: a :~: b -> f a -> f b\nsubst Refl = id\n\nplus_zero :: forall n. SNat n -> (n :+ Z) :~: n\nplus_zero Zero = Refl\nplus_zero (Succ n) = cong (plus_zero n)\n\nplus_suc :: forall n m. SNat n -> SNat m -> (n :+ (S m)) :~: (S (n :+ m))\nplus_suc Zero m = Refl\nplus_suc (Succ n) m = cong (plus_suc n m)\n\nsize :: Vec a n -> SNat n\nsize Nil         = Zero\nsize (Cons _ xs) = Succ $ size xs\n\nreverse :: forall n a. Vec a n -> Vec a n\nreverse xs = subst (plus_zero (size xs)) $ go Nil xs\n  where\n    go :: Vec a m -> Vec a k -> Vec a (k :+ m)\n    go acc Nil = acc\n    go acc (Cons x xs) = subst (plus_suc (size xs) (size acc)) $ go (Cons x acc) xs\n\nappend :: Vec a n -> Vec a m -> Vec a (n :+ m)\nappend (Cons x xs) ys = Cons x (append xs ys)\nappend Nil         ys = ys\n\nvec :: Vec Int (S (S (S Z)))\nvec = 1 `Cons` (2 `Cons` (3 `Cons` Nil))\n\ntest :: Vec Int (S (S (S Z)))\ntest = Main.reverse vec\n```\n我们可以考虑是否可以避免使用`singleton`(单例)技巧，而只使用类型级自然数，从技术上讲，这种方法应该是可行的，尽管似乎`GHC 7.8`中的自然数求解器可以确定某些属性，但不能确定某些属性完成`reverse`函数的自然数证明。\n```haskell\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nimport Prelude hiding (Eq)\nimport GHC.TypeLits\nimport Data.Type.Equality\n\ntype Z = 0\n\ntype family S (n :: Nat) :: Nat where\n  S n = n + 1\n\n-- Yes!\neq_zero :: Z :~: Z\neq_zero = Refl\n\n-- Yes!\nzero_plus_one :: (Z + 1) :~: (1 + Z)\nzero_plus_one = Refl\n\n-- Yes!\nplus_zero :: forall n. (n + Z) :~: n\nplus_zero = Refl\n\n-- Yes!\nplus_one :: forall n. (n + S Z) :~: S n\nplus_one = Refl\n\n-- No.\nplus_suc :: forall n m. (n + (S m)) :~: (S (n + m))\nplus_suc = Refl\n```\n请注意，在`GHC 7.6`中可能有一种我不知道的方法。\n在`GHC 7.10`中，有一些计划中的变更，以解决这些问题。特别是，有计划允许`pluggable`(可插拔)类型的系统扩展，这些扩展可以将这类问题外包给第三方`SMT`求解器，后者可以解决此类`numeric relations`(数字关系)并将此信息返回给`GHC`的`typechecker`(类型检查器)。\n\n顺便说一句，这是对`Agda`中等效证明的直接音译，它是通过相同的方法完成的，但没有`song and dance`(歌舞)来`get around`(解决)缺少依赖类型的问题。\n```haskell\nmodule Vector where\n\ninfixr 10 _∷_\n\ndata ℕ : Set where\n  zero : ℕ\n  suc  : ℕ → ℕ\n\n{-# BUILTIN NATURAL ℕ    #-}\n{-# BUILTIN ZERO    zero #-}\n{-# BUILTIN SUC     suc  #-}\n\ninfixl 6 _+_\n\n_+_ : ℕ → ℕ → ℕ\n0 + n = n\nsuc m + n = suc (m + n)\n\ndata Vec (A : Set) : ℕ → Set where\n  []  : Vec A 0\n  _∷_ : ∀ {n} → A → Vec A n → Vec A (suc n)\n\n_++_ : ∀ {A n m} → Vec A n → Vec A m → Vec A (n + m)\n[] ++ ys = ys\n(x ∷ xs) ++ ys = x ∷ (xs ++ ys)\n\ninfix 4 _≡_\n\ndata _≡_ {A : Set} (x : A) : A → Set where\n  refl : x ≡ x\n\nsubst : {A : Set} → (P : A → Set) → ∀{x y} → x ≡ y → P x → P y\nsubst P refl p = p\n\ncong : {A B : Set} (f : A → B) → {x y : A} → x ≡ y → f x ≡ f y\ncong f refl = refl\n\nvec : ∀ {A} (k : ℕ) → Set\nvec {A} k = Vec A k\n\nplus_zero : {n : ℕ} → n + 0 ≡ n \nplus_zero {zero}  = refl\nplus_zero {suc n} = cong suc plus_zero\n\nplus_suc : {n : ℕ} → n + (suc 0) ≡ suc n \nplus_suc {zero}  = refl\nplus_suc {suc n} = cong suc (plus_suc {n})\n\nreverse : ∀ {A n} → Vec A n → Vec A n\nreverse []       = []\nreverse {A} {suc n} (x ∷ xs) = subst vec (plus_suc {n}) (reverse xs ++ (x  ∷ []))\n```\n\n### Liquid Haskell\n> 这是高级部分，编写Haskell通常不需要`LiquidLiskell`的知识。\n\n`LiquidHaskell`是`GHC`类型系统的一个扩展，它使用`annotation`(注释)语法增加了`refinement`(细化)类型的能力。外部可以检查函数的类型签名，以获得比默认ghc提供的更丰富的类型语义，包括需要外部smt解算器验证的`non-exhaustive`(非穷尽)模式和复杂的算术属性。例如, `LiquidHaskell`可以静态地验证在`Maybe a`上操作的函数总是被赋予`Just`，或者算术函数总是产生一个甚至是正数的`Int`。\n\n要在`Ubuntu`中安装`LiquidHaskell`，请在`/etc/sources.list中`添加以下行:\n```haskell\ndeb http://ppa.launchpad.net/hvr/z3/ubuntu trusty main\n```\n然后安装外部`SMT`求解器:\n```haskell\n$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys F6F88286\n$ sudo apt-get install z3\n```\n然后`clone repo`(存储库)并使用`stack`进行构建:\n```haskell\n$ git clone --recursive git@github.com:ucsd-progsys/liquidhaskell.git\n$ cd liquidhaskell\n$ stack install\n```\n確保`$HOME/.local/bin`在你的`$PATH`中.\n```haskell\nimport Prelude hiding (mod, gcd)\n\n{-@ mod :: a:Nat -> b:{v:Nat| 0 < v} -> {v:Nat | v < b} @-}\nmod :: Int -> Int -> Int\nmod a b\n  | a < b = a\n  | otherwise = mod (a - b) b\n\n{-@ gcd :: a:Nat -> b:{v:Nat | v < a} -> Int @-}\ngcd :: Int -> Int -> Int\ngcd a 0 = a\ngcd a b = gcd b (a `mod` b)\n```\n可以使用`liquid`命令行工具通过`solver`(求解器)运行该模块。\n```haskell\n$ liquid example.hs\nDone solving.\n\n**** DONE:  solve **************************************************************\n\n\n**** DONE:  annotate ***********************************************************\n\n\n**** RESULT: SAFE **************************************************************\n```\n有关更多详细文档和更多用例，请参见官方文档:\n[Liquid Haskell Documentation](https://ucsd-progsys.github.io/liquidhaskell-tutorial/01-intro.html)\n\n\n\n\n","tags":["Promotion"]},{"title":"Haskell-Type-Families","url":"/blog/2019/10/09/Haskell-Type-Families/","content":"> http://dev.stephendiehl.com/hask/#type-families\n\n### MultiParam Typeclasses\n原始`Haskell 98`类型类的解析是通过非常简单的上下文约简来进行的，该上下文约简可以最大程度地减少谓词之间的相互依赖性，解析超类，并将类型简化为普通形式。例如：\n```haskell\n(Eq [a], Ord [a]) => [a]\n==> Ord a => [a]\n```\n如果单个参数`typeclass`表示类型的属性(即,它在类中还是不在`class`中),则多参数`typeclass`表示类型之间的关系。例如，如果我们要表达这种关系，则可以将一个类型转换为另一种类型，则可以使用类似以下的类:\n```haskell\n{-# LANGUAGE MultiParamTypeClasses #-}\n\nimport Data.Char\n\nclass Convertible a b where\n  convert :: a -> b\n\ninstance Convertible Int Integer where\n  convert = toInteger\n\ninstance Convertible Int Char where\n  convert = chr\n\ninstance Convertible Char Int where\n  convert = ord\n```\n当然，现在我们的`Convertible Int`实例不再是唯一的，\n因此，不再存在一个很好的过程来仅根据`a`来确定`b`的推断类型。\n为了解决这个问题，让我们添加一个函數依赖项`a -> b`,它告诉`GHC`实例`a`唯一地确定了`b`可以成为的实例。因此，我们将看到将`Int`与`Integer`和`Char`都衝突关联的两个实例。\n```haskell\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE FunctionalDependencies #-}\n\nimport Data.Char\n\nclass Convertible a b | a -> b where\n  convert :: a -> b\n\ninstance Convertible Int Char where\n  convert = chr\n\ninstance Convertible Char Int where\n  convert = ord\n\nFunctional dependencies conflict between instance declarations:\n  instance Convertible Int Integer\n  instance Convertible Int Char\n```\n现在，有一个更简单的过程来唯一地确定实例，并且多参数`typeclass`变得更加可用和可推断。\n有效的函數依赖`| a-> b`表示我们不能使用相同的`a`但不同的`b`定义多个多参数`typeclass`实例。\n```haskell\nλ: convert (42 :: Int)\n'*'\nλ: convert '*'\n42\n```\n现在，让事情变得不那么简单。\n启用`UndecidableInstances`会放宽对上下文`reduction`(缩减)的约束，这种约束只能使该类的约束在结构上小于其头部。\n结果，隐式计算现在可以在类型类实例搜索中进行。\n结合`Peano`数字的类型级别表示，我们发现我们可以在类型级别对基本算术进行编码。\n```haskell\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE UndecidableInstances #-}\n\ndata Z\ndata S n\n\ntype Zero  = Z\ntype One   = S Zero\ntype Two   = S One\ntype Three = S Two\ntype Four  = S Three\n\nzero :: Zero\nzero = undefined\n\none :: One\none = undefined\n\ntwo :: Two\ntwo = undefined\n\nthree :: Three\nthree = undefined\n\nfour :: Four\nfour = undefined\n\nclass Eval a where\n  eval :: a -> Int\n\ninstance Eval Zero where\n  eval _ = 0\n\ninstance Eval n => Eval (S n) where\n  eval m = 1 + eval (prev m)\n\nclass Pred a b | a -> b where\n  prev :: a -> b\n\ninstance Pred Zero Zero where\n  prev = undefined\n\ninstance Pred (S n) n where\n  prev = undefined\n\nclass Add a b c | a b -> c where\n  add :: a -> b -> c\n\ninstance Add Zero a a where\n  add = undefined\n\ninstance Add a b c => Add (S a) b (S c) where\n  add = undefined\n\nf :: Three\nf = add one two\n\ng :: S (S (S (S Z)))\ng = add two two\n\nh :: Int\nh = eval (add three four)\n```\n如果类型类的上下文看上去与`Prolog`相似，那么您没看错，如果人们将上下文限定符(`=>`)作为旋转門`:-`逆向读取，那么它就是完全相同的方程式。\n```haskell\nadd(0, A, A).\nadd(s(A), B, s(C)) :- add(A, B, C).\n\npred(0, 0).\npred(S(A), A).\n```\n这是在滥用类型类，如果使用不当，可能会在编译时终止或溢出。在未仔细考虑其含义的情况下，不应打开`UndecidableInstances`。\n```haskell\n<interactive>:1:1:\n    Context reduction stack overflow; size = 201\n```\n\n### Type Families\n`Type Families`允许我们在类型域中编写函数，这些函数将类型作为参数，这些参数可以生成类型或索引在其参数上的值，这些值在编译时进行类型检查时执行。`Type Families`有两种变体:`data families`和`type synonym families`。\n* **`type families`** are named function on types\n* **`data families`** are type-indexed data types\n\n首先，让我们看一下`type synonym families`，有两种等效的语法构造方法。在类型类中声明为关联的`type families`，或者在`toplevel`声明为独立的声明。下列形式在语义上是等效的，尽管非关联的形式严格来说更为笼统：\n```haskell\n-- (1) Unassociated form\ntype family Rep a\ntype instance Rep Int = Char\ntype instance Rep Char = Int\n\nclass Convertible a where\n  convert :: a -> Rep a\n\ninstance Convertible Int where\n  convert = chr\n\ninstance Convertible Char where\n  convert = ord\n\n-- (2) Associated form\nclass Convertible a where\n  type Rep a\n  convert :: a -> Rep a\n\ninstance Convertible Int where\n  type Rep Int = Char\n  convert = chr\n\ninstance Convertible Char where\n  type Rep Char = Int\n  convert = ord\n```\n使用我们用于`multiparameter`+`functional dependencies`的示例，我们看到`type family`方法和`functional dependencies`之间有直接的转换。这两种方法具有相同的表达能力。\n\n可以在`GHCi`中使用`:kind!`命令查询关联的`type family`。\n```haskell\nλ: :kind! Rep Int\nRep Int :: *\n= Char\nλ: :kind! Rep Char\nRep Char :: *\n= Int\n```\n另一方面，`Data families`使我们可以创建新型的参数化数据构造函数。\n通常，我们只能定义`typeclasses`函数，它们的行为会导致统一的结果，这纯粹是`typeclasses`参数的结果。\n`With data families we can allow specialized behavior indexed on the type.`(使用`data families`，我们可以允许在类型上建立专门的行为索引)。\n\n例如，如果我们想创建更复杂的向量结构(位掩码向量，元组向量，...),这些结构暴露出统一的API,但在内部处理其数据布局中的差异,则可以使用`data families`来实现这一点:\n```haskell\n{-# LANGUAGE TypeFamilies #-}\n\nimport qualified Data.Vector.Unboxed as V\n\ndata family Array a\ndata instance Array Int       = IArray (V.Vector Int)\ndata instance Array Bool      = BArray (V.Vector Bool)\ndata instance Array (a,b)     = PArray (Array a) (Array b)\ndata instance Array (Maybe a) = MArray (V.Vector Bool) (Array a)\n\nclass IArray a where\n  index :: Array a -> Int -> a\n\ninstance IArray Int where\n  index (IArray xs) i = xs V.! i\n\ninstance IArray Bool where\n  index (BArray xs) i = xs V.! i\n\n-- Vector of pairs\ninstance (IArray a, IArray b) => IArray (a, b) where\n  index (PArray xs ys) i = (index xs i, index ys i)\n\n-- Vector of missing values\ninstance (IArray a) => IArray (Maybe a) where\n  index (MArray bm xs) i =\n    case bm V.! i of\n      True  -> Nothing\n      False -> Just $ index xs i\n```\n\n### Injectivity(內射性)\n`type-families`定义的类型级别函数不一定是`injectivity`的，函数可以将两个不同的输入类型映射到相同的输出类型。\n这不同于`injectivity`类型构造器(也是类型级别的函数)的行为。\n\n例如: 對於`Maybe`构造函數，`Maybe t1 = Maybe t2`意味著`t1 = t2`.\n```haskell\ndata Maybe a = Nothing | Just a\n-- Maybe a ~ Maybe b  implies  a ~ b\n\ntype instance F Int = Bool\ntype instance F Char = Bool\n\n-- F a ~ F b does not imply  a ~ b, in general\n```\n\n### Roles\n> 这是高级部分，编写Haskell通常不需要。\n\n`Roles`是`datatypes`的类型变量参数的进一步规范。\n* `nominal`(名义上的)\n* `representational`(代表性的/表示形式)\n* `phantom`(幻影)\n\n他们被添加到语言中,以解决围绕`newtype`及其运行时表示之间的`correspondence`(对应关系)的一个令人讨厌且长期存在的`bug`。\n`roles`引入的基本区别是类型相等有两个概念。当两种类型的名称相同时，它们在名义上是相等的。这是`Haskell`或`Core`中通常的等式。当两种类型具有相同的表示形式时，它们在表示上是相等的。(如果类型具有`higher-kinded`(较高的种类)，则所有名义上相等的实例化将导致表示形式相同的类型。)\n\n* nominal - 兩個類型是相同的\n* representational - 兩個類型具有相同的運行時表示形式\n```haskell\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n\nnewtype Age = MkAge { unAge :: Int }\n\ntype family Inspect x\ntype instance Inspect Age = Int\ntype instance Inspect Int = Bool\n\nclass Boom a where\n  boom :: a -> Inspect a\n\ninstance Boom Int where\n  boom = (== 0)\n\nderiving instance Boom Age\n\n-- GHC 7.6.3 exhibits undefined behavior\nfailure = boom (MkAge 3)\n-- -6341068275333450897\n```\n`Roles`通常是自动推断的，但是通过`RoleAnnotations`扩展，可以手动对其进行注释。除极少数情况外，这不是必需的，尽管有助于了解幕后情况。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE RoleAnnotations #-}\n\ndata Nat = Zero | Suc Nat\n\ntype role Vec nominal representational\ndata Vec :: Nat -> * -> * where\n  Nil  :: Vec Zero a\n  (:*) :: a -> Vec n a -> Vec (Suc n) a\n\ntype role App representational nominal\ndata App (f :: k -> *) (a :: k) = App (f a)\n\ntype role Mu nominal nominal\ndata Mu (f :: (k -> *) -> k -> *) (a :: k) = Roll (f (Mu f) a)\n\ntype role Proxy phantom\ndata Proxy (a :: k) = Proxy\ncoerce :: Coercible * a b => a -> b\nclass (~R#) k k a b => Coercible k a b\n```\n\n[Safe Zero-cost Coercions for Haskell](http://cs.brynmawr.edu/~rae/papers/2014/coercible/coercible.pdf) (Haskell的安全零成本强制转换)\n\n[Data.Coerce](https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Coerce.html#t:Coercible)\n\n請看:   \n* [Roles](https://ghc.haskell.org/trac/ghc/wiki/Roles)\n* [Roles: A New Feature of GHC](http://typesandkinds.wordpress.com/2013/08/15/roles-a-new-feature-of-ghc/)\n\n\n### Mono-traversable(单行遍历)\n使用`type families`，`mono-traversable`可以将`Functor`，`Foldable`和`Traversable`的概念进行概括(归纳)，以包括`monomorphic`(单态)和`polymorphic`(多态)类型。\n```haskell\nomap :: MonoFunctor mono => (Element mono -> Element mono) -> mono -> mono\n\notraverse :: (Applicative f, MonoTraversable mono)\n          => (Element mono -> f (Element mono)) -> mono -> f mono\n\nofoldMap :: (Monoid m, MonoFoldable mono)\n         => (Element mono -> m) -> mono -> m\nofoldl' :: MonoFoldable mono\n        => (a -> Element mono -> a) -> a -> mono -> a\nofoldr :: MonoFoldable mono\n        => (Element mono -> b -> b) -> b -> mono -> b\n```\n例如，自此以来，文本类型通常不接受任何这些类型类，但是现在我们可以写出对`Foldable`和`Traversable`接口进行建模的实例。\n```haskell\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Data.Text\nimport Data.Char\nimport Data.Monoid\nimport Data.MonoTraversable\nimport Control.Applicative\n\nbs :: Text\nbs = \"Hello Haskell.\"\n\nshift :: Text\nshift = omap (chr . (+1) . ord) bs\n-- \"Ifmmp!Ibtlfmm/\"\n\nbackwards :: [Char]\nbackwards = ofoldl' (flip (:)) \"\" bs\n-- \".lleksaH olleH\"\n\n\ndata MyMonoType = MNil | MCons Int MyMonoType deriving Show\n\ntype instance Element MyMonoType = Int\n\ninstance MonoFunctor MyMonoType where\n  omap f MNil = MNil\n  omap f (MCons x xs) = f x `MCons` omap f xs\n\ninstance MonoFoldable MyMonoType where\n  ofoldMap f   = ofoldr (mappend . f) mempty\n  ofoldr       = mfoldr\n  ofoldl'      = mfoldl'\n  ofoldr1Ex f  = ofoldr1Ex f . mtoList\n  ofoldl1Ex' f = ofoldl1Ex' f . mtoList\n\ninstance MonoTraversable MyMonoType where\n  omapM f xs = mapM f (mtoList xs) >>= return . mfromList\n  otraverse f = ofoldr acons (pure MNil)\n    where acons x ys = MCons <$> f x <*> ys\n\nmtoList :: MyMonoType -> [Int]\nmtoList (MNil) = []\nmtoList (MCons x xs) = x : (mtoList xs)\n\nmfromList :: [Int] -> MyMonoType\nmfromList [] = MNil\nmfromList (x:xs) = MCons x (mfromList xs)\n\nmfoldr :: (Int -> a -> a) -> a -> MyMonoType -> a\nmfoldr f z MNil =  z\nmfoldr f z (MCons x xs) =  f x (mfoldr f z xs)\n\nmfoldl' :: (a -> Int -> a) -> a -> MyMonoType -> a\nmfoldl' f z MNil = z\nmfoldl' f z (MCons x xs) = let z' = z `f` x\n                           in seq z' $ mfoldl' f z' xs\n\nex1 :: Int\nex1 = mfoldl' (+) 0 (mfromList [1..25])\n\nex2 :: MyMonoType\nex2 = omap (+1) (mfromList [1..25])\n```\n請看: [From Semigroups to Monads](http://fundeps.com/tables/FromSemigroupToMonads.pdf)\n\n### NonEmpty\n与其让许多`Prelude`函数的`degenerate`(退化/简并)情况适应列表的空值情况，不如将静态列表强制构造为某种类型的`inhabitant`(實例)，有时是更可取的。\n```haskell\ninfixr 5 :|, <|\ndata NonEmpty a = a :| [a]\n\nhead :: NonEmpty a -> a\ntoList :: NonEmpty a -> [a]\nfromList :: [a] -> NonEmpty a\nhead :: NonEmpty a -> a\nhead ~(a :| _) = a\nimport Data.List.NonEmpty\nimport Prelude hiding (head, tail, foldl1)\nimport Data.Foldable (foldl1)\n\na :: NonEmpty Integer\na = fromList [1,2,3]\n-- 1 :| [2,3]\n\nb :: NonEmpty Integer\nb = 1 :| [2,3]\n-- 1 :| [2,3]\n\nc :: NonEmpty Integer\nc = fromList []\n-- *** Exception: NonEmpty.fromList: empty list\n\nd :: Integer\nd = foldl1 (+) $ fromList [1..100]\n-- 5050\n```\n\n### Manual Proofs (手工證明)\n> 这是高级部分，编写Haskell通常不需要。\n\n计算机科学中最深刻的成果之一是`curry-howard`对应关系，即逻辑命题可以用类型来建模，而将这些类型实例化就构成了这些命题的证明。程序就是证明，证明就是程序。\n```haskell\nTypes\t          Logic\nA\t              proposition\na : A\t          proof\nB(x)\t          predicate\nVoid        \t  ⊥\nUnit\t          ⊤\nA + B\t          A ∨ B\nA × B\t          A ∧ B\nA -> B            A ⇒ B\n```\n在依赖类型的语言中，我们可以充分利用这个结果；在`haskell`中，我们没有依赖类型提供的优势，但仍然可以证明微不足道的结果。例如，现在我们可以为加法建立类型级別的函数的模型，并提供零是加法恒等式的一个小证明。\n```haskell\nP 0                   [ base step ]\n∀n. P n  → P (1+n)    [ inductive step ]\n-------------------\n∀n. P(n)\nAxiom 1: a + 0 = a\nAxiom 2: a + suc b = suc (a + b)\n\n  0 + suc a\n= suc (0 + a)  [by Axiom 2]\n= suc a        [Induction hypothesis]\n∎\n```\n翻译成`Haskell`的公理只是简单的类型化定义，而归纳数据类型的递归构成了我们证明的归纳步骤。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE ExplicitForAll #-}\n{-# LANGUAGE TypeOperators #-}\n\ndata Z\ndata S n\n\ndata SNat n where\n  Zero :: SNat Z\n  Succ :: SNat n -> SNat (S n)\n\ndata Eql a b where\n  Refl :: Eql a a\n\ntype family Add m n\ntype instance Add Z n = n\ntype instance Add (S m) n = S (Add m n)\n\nadd :: SNat n -> SNat m -> SNat (Add n m)\nadd Zero     m = m\nadd (Succ n) m = Succ (add n m)\n\ncong :: Eql a b -> Eql (f a) (f b)\ncong Refl = Refl\n\n-- ∀n. 0 + suc n = suc n\nplus_suc :: forall n.  SNat n\n         -> Eql (Add Z (S n)) (S n)\nplus_suc Zero = Refl\nplus_suc (Succ n) = cong (plus_suc n)\n\n-- ∀n. 0 + n = n\nplus_zero :: forall n. SNat n\n         -> Eql (Add Z n) n\nplus_zero Zero = Refl\nplus_zero (Succ n) = cong (plus_zero n)\n```\n使用`TypeOperators`扩展，我们还可以在`type-level`使用中缀符号。\n```haskell\ndata a :=: b where\n  Refl :: a :=: a\n\ncong :: a :=: b -> (f a) :=: (f b)\ncong Refl = Refl\n\ntype family (n :: Nat) :+ (m :: Nat) :: Nat\ntype instance Zero     :+ m = m\ntype instance (Succ n) :+ m = Succ (n :+ m)\n\nplus_suc :: forall n m. SNat n -> SNat m -> (n :+ (S m)) :=: (S (n :+ m))\nplus_suc Zero m = Refl\nplus_suc (Succ n) m = cong (plus_suc n m)\n```\n\n### Constraint Kinds (约束种类)\n> 这是高级部分，编写Haskell通常不需要。\n\n`GHC`的实现还通过启用`-XConstraintKinds`扩展，公開了将`Haskell`中的限定词绑定为类型本身的謂詞。\n使用此扩展，我们将`constraints`(约束)作为第一类类型处理。\n```haskell\nNum :: * -> Constraint\nOdd :: * -> Constraint\ntype T1 a = (Num a, Ord a)\n```\n空约束集由`() :: Constraint`表示。\n对于一个虚构的示例，如果我们想创建一个通用的`Sized`类，该类带有对所涉及容器的元素的约束，则可以使用`type families`非常简单地实现此目的。\n```haskell\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE ConstraintKinds #-}\n\nimport GHC.Exts (Constraint)\nimport Data.Hashable\nimport Data.HashSet\n\ntype family Con a :: Constraint\ntype instance Con [a] = (Ord a, Eq a)\ntype instance Con (HashSet a) = (Hashable a)\n\nclass Sized a where\n  gsize :: Con a => a -> Int\n\ninstance Sized [a] where\n  gsize = length\n\ninstance Sized (HashSet a) where\n  gsize = size\n```\n其中一个用例是捕获受函数约束的`typeclass`字典并将其具体化为一个值。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE ConstraintKinds #-}\n{-# LANGUAGE KindSignatures #-}\n\nimport GHC.Exts (Constraint)\n\ndata Dict :: Constraint -> * where\n  Dict :: (c) => Dict c\n\ndShow :: Dict (Show a) -> a -> String\ndShow Dict x = show x\n\ndEqNum :: Dict (Eq a, Num a) -> a -> Bool\ndEqNum Dict x = x == 0\n\n\nfShow :: String\nfShow = dShow Dict 10\n\nfEqual :: Bool\nfEqual = dEqNum Dict 0\n```\n\n### TypeFamilyDependencies\n`Type families`在历史上不是内射的，也就是说，它们不能保证将其参数的不同元素映射到其结果的相同元素。语法类似于`multiparmater typeclass functional dependencies`(多参数类型类函数依赖项)，因为生成的类型由一组`type families`参数唯一确定。\n```haskell\n{-# LANGUAGE XTypeFamilyDependencies #-}\n\ntype family F a b c = (result :: k) | result -> a b c\ntype instance F Int  Char Bool = Bool\ntype instance F Char Bool Int  = Int\ntype instance F Bool Int  Char = Char\n```\n請看: [Injective type families for Haskell](http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf) (Haskell的内射性`type families`)\n","tags":["Type-Families"]},{"title":"Haskell-interpreters","url":"/blog/2019/10/09/Haskell-interpreters/","content":"`λ`演算为许多语言奠定了理论和实践基础。每个微积分的核心是三个组成部分:\n* **Var** - 表識一個變量\n* **Lam** - 表識一個lambda抽象\n* **App** - 表識一個應用\n![](img/img01.png)\n对这些构造和数据结构表示进行建模的方法有很多，但是它们或多或少都包含这三个要素。\n例如，在`lambda`的`binders`和`variables`上使用字符串名称的`lambda`演算可能如下所示：\n```haskell\ntype Name = String\n\ndata Exp\n  = Var Name\n  | Lam Name Exp\n  | App Exp Exp\n```\n在`lambda`表达式中，出现在表达式主体中的所有变量都被外部`lambda`绑定器引用，則该表达式被称为是`closed`，而具有未绑定的自由变量的表达式则是`open`的。\n\n### HOAS\n高阶抽象语法(`HOAS`)是在一种语言中实现`lambda`演算的一种技术，其中`lambda`表达式的绑定直接映射到宿主语言(即`Haskell`)的`lambda`绑定，从而通过利用`Haskell`的实现为我们的自定义语言提供`substitution`(替换)机制。\n```haskell\n{-# LANGUAGE GADTs #-}\n\ndata Expr a where\n  Con :: a -> Expr a\n  Lam :: (Expr a -> Expr b) -> Expr (a -> b)\n  App :: Expr (a -> b) -> Expr a -> Expr b\n\ni :: Expr (a -> a)\ni = Lam (\\x -> x)\n\nk :: Expr (a -> b -> a)\nk = Lam (\\x -> Lam (\\y -> x))\n\ns :: Expr ((a -> b -> c) -> (a -> b) -> (a -> c))\ns = Lam (\\x -> Lam (\\y -> Lam (\\z -> App (App x z) (App y z))))\n\neval :: Expr a -> a\neval (Con v) = v\neval (Lam f) = \\x -> eval (f (Con x))\neval (App e1 e2) = (eval e1) (eval e2)\n\n\nskk :: Expr (a -> a)\nskk = App (App s k) k\n\nexample :: Integer\nexample = eval skk 1\n-- 1\n```\n漂亮的打印`HOAS`术语也可能非常复杂，因为该函数的主体位于`Haskell lambda`绑定器下。\n\n### PHOAS\n称为`PHOAS`的`HOAS`形式略有不同，它使用在`binder`类型上参数化的`lambda`数据类型。\n在这种形式下，评估需要将其拆包为单独的`Value`类型以包装`lambda`表达式。\n```haskell\n{-# LANGUAGE RankNTypes #-}\n\ndata ExprP a\n  = VarP a\n  | AppP (ExprP a) (ExprP a)\n  | LamP (a -> ExprP a)\n  | LitP Integer\n\ndata Value\n  = VLit Integer\n  | VFun (Value -> Value)\n\nfromVFun :: Value -> (Value -> Value)\nfromVFun val = case val of\n  VFun f -> f\n  _      -> error \"not a function\"\n\nfromVLit :: Value -> Integer\nfromVLit val = case val of\n  VLit n -> n\n  _      -> error \"not a integer\"\n\nnewtype Expr = Expr { unExpr :: forall a . ExprP a }\n\neval :: Expr -> Value\neval e = ev (unExpr e) where\n  ev (LamP f)      = VFun(ev . f)\n  ev (VarP v)      = v\n  ev (AppP e1 e2)  = fromVFun (ev e1) (ev e2)\n  ev (LitP n)      = VLit n\n\ni :: ExprP a\ni = LamP (\\a -> VarP a)\n\nk :: ExprP a\nk = LamP (\\x -> LamP (\\y -> VarP x))\n\ns :: ExprP a\ns = LamP (\\x -> LamP (\\y -> LamP (\\z -> AppP (AppP (VarP x) (VarP z)) (AppP (VarP y) (VarP z)))))\n\nskk :: ExprP a\nskk = AppP (AppP s k) k\n\nexample :: Integer\nexample = fromVLit $ eval $ Expr (AppP skk (LitP 3))\n```\n請看:\n* [PHOAS](http://adam.chlipala.net/papers/PhoasICFP08/PhoasICFP08Talk.pdf)\n* [Encoding Higher-Order Abstract Syntax with Parametric Polymorphism](http://www.seas.upenn.edu/~sweirich/papers/itabox/icfp-published-version.pdf)\n\n### Final Interpreters\n使用类型类，我们可以实现`Final Interpreters`，该解释器使用绑定到类型类的函數而不是数据构造函数对一组可扩展`terms`(术语)进行建模。\n类型类的实例在这些术语上形成解释器。\n\n例如，我们可以编写一种包含基本算术的小语言，然后在不更改基数的情况下使用乘法运算符追溯性地扩展我们的表达式语言。同时，我们的解释器逻辑在扩展新表达式后仍保持不变。\n```haskell\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE TypeSynonymInstances #-}\n{-# LANGUAGE NoMonomorphismRestriction #-}\n\nclass Expr repr where\n  lit :: Int -> repr\n  neg :: repr -> repr\n  add :: repr -> repr -> repr\n  mul :: repr -> repr -> repr\n\ninstance Expr Int where\n  lit n = n\n  neg a = -a\n  add a b = a + b\n  mul a b = a * b\n\ninstance Expr String where\n  lit n = show n\n  neg a = \"(-\" ++ a ++ \")\"\n  add a b = \"(\" ++ a ++ \" + \" ++ b ++ \")\"\n  mul a b = \"(\" ++ a ++ \" * \" ++ b ++ \")\"\n\nclass BoolExpr repr where\n  eq :: repr -> repr -> repr\n  tr :: repr\n  fl :: repr\n\ninstance BoolExpr Int where\n  eq a b = if a == b then tr else fl\n  tr = 1\n  fl = 0\n\ninstance BoolExpr String where\n  eq a b = \"(\" ++ a ++ \" == \" ++ b ++ \")\"\n  tr = \"true\"\n  fl = \"false\"\n\neval :: Int -> Int\neval = id\n\nrender :: String -> String\nrender = id\n\nexpr :: (BoolExpr repr, Expr repr) => repr\nexpr = eq (add (lit 1) (lit 2)) (lit 3)\n\nresult :: Int\nresult = eval expr\n-- 1\n\nstring :: String\nstring = render expr\n-- \"((1 + 2) == 3)\"\n```\n\n### Finally Tagless\n同样，也可以使用`final interpreter`和`Identity`函子来为`lambda`演算编写评估器。\n```haskell\nimport Prelude hiding (id)\n\nclass Expr rep where\n  lam :: (rep a -> rep b) -> rep (a -> b)\n  app :: rep (a -> b) -> (rep a -> rep b)\n  lit :: a -> rep a\n\nnewtype Interpret a = R { reify :: a }\n\ninstance Expr Interpret where\n  lam f   = R $ reify . f . R\n  app f a = R $ reify f $ reify a\n  lit     = R\n\neval :: Interpret a -> a\neval e = reify e\n\ne1 :: Expr rep => rep Int\ne1 = app (lam (\\x -> x)) (lit 3)\n\ne2 :: Expr rep => rep Int\ne2 = app (lam (\\x -> lit 4)) (lam $ \\x -> lam $ \\y -> y)\n\nexample1 :: Int\nexample1 = eval e1\n-- 3\n\nexample2 :: Int\nexample2 = eval e2\n-- 4\n```\n請看: [Typed Tagless Interpretations and Typed Compilation](http://okmij.org/ftp/tagless-final/)\n\n### Datatypes\n描述代数数据类型的常用方法是指出求和类型、乘积类型和多项式表达式之间的自然对应关系是如何产生的。\n```haskell\ndata Void                       -- 0\ndata Unit     = Unit            -- 1\ndata Sum a b  = Inl a | Inr b   -- a + b\ndata Prod a b = Prod a b        -- a * b\ntype (->) a b = a -> b          -- b ^ a\n```\n直觉上遵循这样的观念，即总是可以根据类型的`inhabitants`(類型的實例的統稱)数量来给出其类型的基数。\n`product`类型允许许多`inhabitants`，如`product`函數(即笛卡尔积的基数).\n`sum`类型則是它的`holes`(孔)數总和.\n`function`类型則是`domain`(域)和`codomain`(共域)的`span`(范围)的指数.\n```haskell\n-- domain/codomain/range概念\n\\x -> 2x + 1\ndomain:   A{1,2,3,4}\ncodomain: B{1,2,3,4,5,6,7,8,9,10}\nrange:    C{3,5,7,9}\n```\n```haskell\n-- 1 + A\ndata Maybe a = Nothing | Just a\n```\n递归类型对应于这些`terms`(項/術語)的无穷`series`(系列)。\n```haskell\n-- pseudocode\n\n-- μX. 1 + X\ndata Nat a = Z | S Nat\nNat a = μ a. 1 + a\n      = 1 + (1 + (1 + ...))\n\n-- μX. 1 + A * X\ndata List a = Nil | Cons a (List a)\nList a = μ a. 1 + a * (List a)\n       = 1 + a + a^2 + a^3 + a^4 ...\n\n-- μX. A + A*X*X\ndata Tree a f = Leaf a | Tree a f f\nTree a = μ a. 1 + a * (List a)\n       = 1 + a^2 + a^4 + a^6 + a^8 ...\n```\n請看: [Species and Functors and Types, Oh My!](http://dept.cs.williams.edu/~byorgey/pub/species-pearl.pdf)\n\n### F-Algebras\n`initial algebra`(初始代数)方法与`final interpreter`方法的不同之处在于，我们现在将`terms`表示为代数数据类型，并且解释器通过模式匹配实现递归和评估。\n```haskell\ntype Algebra f a = f a -> a\ntype Coalgebra f a = a -> f a\nnewtype Fix f = Fix { unFix :: f (Fix f) }\n\ncata :: Functor f => Algebra f a -> Fix f -> a\nana  :: Functor f => Coalgebra f a -> a -> Fix f\nhylo :: Functor f => Algebra f b -> Coalgebra f a -> a -> b\n```\n在`Haskell`中，`F-algebra`是一個與函数`f a-> a`在一起的函子`f a`。`Coalgebra`反轉這個函數，对于函子`f`，我们可以使用递归`Fix newtype`包装器来形成其递归展开。\n```haskell\nnewtype Fix f = Fix { unFix :: f (Fix f) }\n\nFix :: f (Fix f) -> Fix f\nunFix :: Fix f -> f (Fix f)\nFix f = f (f (f (f (f (f ( ... ))))))\n\nnewtype T b a = T (a -> b)\n\nFix (T a)\nFix T -> a\n(Fix T -> a) -> a\n(Fix T -> a) -> a -> a\n...\n```\n通过这种形式，我们可以写下通用的`fold/unfold`(折叠/展开)函数，该函数是通用的数据类型，并且纯粹是根据函子下的递归编写的。\n```haskell\ncata :: Functor f => Algebra f a -> Fix f -> a\ncata alg = alg . fmap (cata alg) . unFix\n\nana :: Functor f => Coalgebra f a -> a -> Fix f\nana coalg = Fix . fmap (ana coalg) . coalg\n```\n我们称这些函數为`catamorphisms`和`anamorphisms`。\n特别要注意的是，这两个函数的类型只是使箭头方向相反。\n用另一种方式解释，他们将定义`Fix f f`之间的保留平面结构映射的`algebra/coalgebra`转换为`rolls`(滚动)或`unrolls`(展开)固定点的函数。\n\n这种方法的特別之處在於，将递归抽象到函子定义中，并且我们可以自由地实现平面转换逻辑！\n\n例如，以下形式的自然数的构造:\n```haskell\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\ntype Algebra f a = f a -> a\ntype Coalgebra f a = a -> f a\n\nnewtype Fix f = Fix { unFix :: f (Fix f) }\n\n-- catamorphism\ncata :: Functor f => Algebra f a -> Fix f -> a\ncata alg = alg . fmap (cata alg) . unFix\n\n-- anamorphism\nana :: Functor f => Coalgebra f a -> a -> Fix f\nana coalg = Fix . fmap (ana coalg) . coalg\n\n-- hylomorphism\nhylo :: Functor f => Algebra f b -> Coalgebra f a -> a -> b\nhylo f g = cata f . ana g\n\ntype Nat = Fix NatF\ndata NatF a = S a | Z deriving (Eq,Show)\n\ninstance Functor NatF where\n  fmap f Z     = Z\n  fmap f (S x) = S (f x)\n\nplus :: Nat -> Nat -> Nat\nplus n = cata phi where\n  phi Z     = n\n  phi (S m) = s m\n\ntimes :: Nat -> Nat -> Nat\ntimes n = cata phi where\n  phi Z     = z\n  phi (S m) = plus n m\n\nint :: Nat -> Int\nint = cata phi where\n  phi  Z    = 0\n  phi (S f) = 1 + f\n\nnat :: Integer -> Nat\nnat = ana (psi Z S) where\n  psi f _ 0 = f\n  psi _ f n = f (n-1)\n\nz :: Nat\nz = Fix Z\n\ns :: Nat -> Nat\ns = Fix . S\n\n\ntype Str = Fix StrF\ndata StrF x = Cons Char x | Nil\n\ninstance Functor StrF where\n  fmap f (Cons a as) = Cons a (f as)\n  fmap f Nil = Nil\n\nnil :: Str\nnil = Fix Nil\n\ncons :: Char -> Str -> Str\ncons x xs = Fix (Cons x xs)\n\nstr :: Str -> String\nstr = cata phi where\n  phi Nil         = []\n  phi (Cons x xs) = x : xs\n\nstr' :: String -> Str\nstr' = ana (psi Nil Cons) where\n  psi f _ []     = f\n  psi _ f (a:as) = f a as\n\nmap' :: (Char -> Char) -> Str -> Str\nmap' f = hylo g unFix\n  where\n    g Nil        = Fix Nil\n    g (Cons a x) = Fix $ Cons (f a) x\n\n\ntype Tree a = Fix (TreeF a)\ndata TreeF a f = Leaf a | Tree a f f deriving (Show)\n\ninstance Functor (TreeF a) where\n  fmap f (Leaf a) = Leaf a\n  fmap f (Tree a b c) = Tree a (f b) (f c)\n\ndepth :: Tree a -> Int\ndepth = cata phi where\n  phi (Leaf _)     = 0\n  phi (Tree _ l r) = 1 + max l r\n\n\nexample1 :: Int\nexample1 = int (plus (nat 125) (nat 25))\n-- 150\n```\n或者，例如，一种依赖于范围词典的小的表达式语言的解释器：\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nimport Control.Applicative\nimport qualified Data.Map as M\n\ntype Algebra f a = f a -> a\ntype Coalgebra f a = a -> f a\n\nnewtype Fix f = Fix { unFix :: f (Fix f) }\n\ncata :: Functor f => Algebra f a -> Fix f -> a\ncata alg = alg . fmap (cata alg) . unFix\n\nana :: Functor f => Coalgebra f a -> a -> Fix f\nana coalg = Fix . fmap (ana coalg) . coalg\n\nhylo :: Functor f => Algebra f b -> Coalgebra f a -> a -> b\nhylo f g = cata f . ana g\n\ntype Id = String\ntype Env = M.Map Id Int\n\ntype Expr = Fix ExprF\ndata ExprF a\n  = Lit Int\n  | Var Id\n  | Add a a\n  | Mul a a\n  deriving (Show, Eq, Ord, Functor)\n\nderiving instance Eq (f (Fix f)) => Eq (Fix f)\nderiving instance Ord (f (Fix f)) => Ord (Fix f)\nderiving instance Show (f (Fix f)) => Show (Fix f)\n\neval :: M.Map Id Int -> Fix ExprF -> Maybe Int\neval env = cata phi where\n  phi ex = case ex of\n    Lit c   -> pure c\n    Var i   -> M.lookup i env\n    Add x y -> liftA2 (+) x y\n    Mul x y -> liftA2 (*) x y\n\nexpr :: Expr\nexpr = Fix (Mul n (Fix (Add x y)))\n  where\n    n = Fix (Lit 10)\n    x = Fix (Var \"x\")\n    y = Fix (Var \"y\")\n\nenv :: M.Map Id Int\nenv = M.fromList [(\"x\", 1), (\"y\", 2)]\n\ncompose :: (f (Fix f) -> c) -> (a -> Fix f) -> a -> c\ncompose x y = x . unFix . y\n\nexample :: Maybe Int\nexample = eval env expr\n-- Just 30\n```\n这种方法特別之處在於`catamorphisms`自然地构成了有效的复合转换。\n```haskell\ncompose :: Functor f => (f (Fix f) -> c) -> (a -> Fix f) -> a -> c\ncompose f g = f . unFix . g\n```\n請看: [Understanding F-Algebras](https://www.fpcomplete.com/user/bartosz/understanding-algebras)\n\n### recursion-schemes(递归方案)\n>这是高级部分，编写Haskell通常不需要。\n\n```haskell\nName\t\t\nCatamorphism\tfoldr :: (a -> b -> b) -> b -> [a] -> b\t    解构数据结构\nAnamorphism\t  unfoldr :: (b -> Maybe (a, b)) -> b -> [a]\t逐级构造结构\n```\n\n```haskell\n-- | A fix-point type.\nnewtype Fix f = Fix { unFix :: f (Fix f) }\n\n-- | Catamorphism or generic function fold.\ncata :: Functor f => (f a -> a) -> (Fix f -> a)\ncata f = f . fmap (cata f) . unFix\n\n-- | Anamorphism or generic function unfold.\nana :: Functor f => (a -> f a) -> (a -> Fix f)\nana f = Fix . fmap (ana f) . f\n```\n上面`F-algebra`示例的代码是在称为`recursion-schemes`的现成库中实现的。\n```haskell\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE DeriveFunctor #-}\n\nimport Data.Functor.Foldable\n\ntype Var = String\n\ndata Exp\n  = Var Var\n  | App Exp Exp\n  | Lam [Var] Exp\n  deriving Show\n\ndata ExpF a\n  = VarF Var\n  | AppF a a\n  | LamF [Var] a\n  deriving Functor\n\ntype instance Base Exp = ExpF\n\ninstance Foldable Exp where\n  project (Var a)     = VarF a\n  project (App a b)   = AppF a b\n  project (Lam a b)   = LamF a b\n\ninstance Unfoldable Exp where\n  embed (VarF a)      = Var a\n  embed (AppF a b)    = App a b\n  embed (LamF a b)    = Lam a b\n\nfvs :: Exp -> [Var]\nfvs = cata phi\n  where phi (VarF a)    = [a]\n        phi (AppF a b)  = a ++ b\n        phi (LamF a b) = foldr (filter . (/=)) a b\n```\n一個使用例子:\n```haskell\n{-# LANGUAGE DeriveFunctor #-}\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE TypeSynonymInstances #-}\n\nimport Data.Traversable\nimport Control.Monad hiding (forM_, mapM, sequence)\nimport Prelude hiding (mapM)\nimport qualified Data.Map as M\n\nnewtype Fix (f :: * -> *) = Fix { outF :: f (Fix f) }\n\n-- Catamorphism\ncata :: Functor f => (f a -> a) -> Fix f -> a\ncata f = f . fmap (cata f) . outF\n\n-- Monadic catamorphism\ncataM :: (Traversable f, Monad m) => (f a -> m a) -> Fix f -> m a\ncataM f = f <=< mapM (cataM f) . outF\n\ndata ExprF r\n  = EVar String\n  | EApp r r\n  | ELam r r\n  deriving (Show, Eq, Ord, Functor)\n\ntype Expr = Fix ExprF\n\ninstance Show (Fix ExprF) where\n  show (Fix f) = show f\n\ninstance Eq (Fix ExprF) where\n  Fix x == Fix y = x == y\n\ninstance Ord (Fix ExprF) where\n  compare (Fix x) (Fix y) = compare x y\n\n\nmkApp :: Fix ExprF -> Fix ExprF -> Fix ExprF\nmkApp x y = Fix (EApp x y)\n\nmkVar :: String -> Fix ExprF\nmkVar x = Fix (EVar x)\n\nmkLam :: Fix ExprF -> Fix ExprF -> Fix ExprF\nmkLam x y = Fix (ELam x y)\n\ni :: Fix ExprF\ni = mkLam (mkVar \"x\") (mkVar \"x\")\n\nk :: Fix ExprF\nk = mkLam (mkVar \"x\") $ mkLam (mkVar \"y\") $ (mkVar \"x\")\n\nsubst :: M.Map String (ExprF Expr) -> Expr -> Expr\nsubst env = cata alg where\n  alg (EVar x) | Just e <- M.lookup x env = Fix e\n  alg e = Fix e\n```\n請看: [recursion-schemes](http://hackage.haskell.org/package/recursion-schemes)\n\n### Data types à la carte\n>TODO\n\n### Hint and Mueval\n>这是高级部分，编写Haskell通常不需要。\n`GHC`本身实际上可以通过连接到`GHC`的字节码解释器(与`GHCi`相同)来即时解释任意`Haskell`源代碼。\n`hint`包允许我们将任意字符串解析，类型检查和评估，并将其评估为任意的`Haskell`程序。\n```haskell\nimport Language.Haskell.Interpreter\n\nfoo :: Interpreter String\nfoo = eval \"(\\\\x -> x) 1\"\n\nexample :: IO (Either InterpreterError String)\nexample = runInterpreter foo\n```\n除非程序本身的目的是评估任意的`Haskell`代码(例如在线`Haskell shell`等)，否则围绕它构建库通常不是明智的选择。\n`hint`和`mueval`都有效地完成了相同的任务，只是围绕`GHC API`的内部稍有不同而设计。\n\n請看:\n * [hint](http://hackage.haskell.org/package/mueval)\n * [mueval](http://hackage.haskell.org/package/mueval)","tags":["interpreters"]},{"title":"Haskell-GADTs","url":"/blog/2019/10/09/Haskell-GADTs/","content":"\n### GADTs\n通用代数数据类型(`GADT`)是对代数数据类型的扩展，它使我们可以将构造函数限定为具有类型相等约束的数据类型，\n从而允许使用普通`Vanilla ADT`无法表达的一类类型。\n\n`-XGADTs`隐式地为数据类型声明(`-XGADTSyntax`)启用替代语法，使得以下声明等效:\n```haskell\n-- Vanilla\ndata List a\n  = Empty\n  | Cons a (List a)\n\n-- GADTSyntax\ndata List a where\n  Empty :: List a\n  Cons :: a -> List a -> List a\n```\n\n例如，考慮如下數據類型`Term`，我们有一个`Succ term`，它接收一个由所有类型参数化的`Term`。\n当尝试编写求值程序时，冲突`(a ~ Bool)`或`(a ~ Int)`之间会出现问题。\n```haskell\ndata Term a\n  = Lit a\n  | Succ (Term a)\n  | IsZero (Term a)\n\n-- 不是一個好的類型 :(\neval (Lit i)      = i\neval (Succ t)     = 1 + eval t\neval (IsZero i)   = eval i == 0\n```\n而且我们接收无意义`terms`的构造会导致更多的错误处理案例。\n```haskell\n-- 這是一個有效的類型\nfailure = Succ (Lit True)\n```\n使用`GADT`，我们可以为我们的语言表示类型不变式(即,只有类型安全的表达式才可以表示)。\n然后，此`GADT`上的模式匹配会携带类型相等约束，而无需显式标签。\n```haskell\n{-# Language GADTs #-}\n\ndata Term a where\n  Lit    :: a -> Term a\n  Succ   :: Term Int -> Term Int\n  IsZero :: Term Int -> Term Bool\n  If     :: Term Bool -> Term a -> Term a -> Term a\n\neval :: Term a -> a\neval (Lit i)      = i                                   -- Term a\neval (Succ t)     = 1 + eval t                          -- Term (a ~ Int)\neval (IsZero i)   = eval i == 0                         -- Term (a ~ Int)\neval (If b e1 e2) = if eval b then eval e1 else eval e2 -- Term (a ~ Bool)\n\nexample :: Int\nexample = eval (Succ (Succ (Lit 3)))\n```\n這一次:\n```haskell\n-- 在编译时將被拒绝\nfailure = Succ (Lit True)\n```\n可以将显式相等约束`(a 〜 b)`添加到函数的上下文中。\n例如，以下内容扩展为相同的类型。\n```haskell\nf :: a -> a -> (a, a)\nf :: (a ~ b) => a -> b -> (a,b)\n(Int ~ Int)  => ...\n(a ~ Int)    => ...\n(Int ~ a)    => ...\n(a ~ b)      => ...\n(Int ~ Bool) => ... -- 將不会进行类型检查\n```\n这实际上是`GHC`在幕后为实现`GADT`(隐式传递和穿插相等`terms`)所做的工作的实现细节。\n如果我们愿意，我们可以使用`GHC`进行相同的设置，只是使用`equality constraints`(相等约束)和`existential quantification`(存在量化)。确实，`GADT`的内部表示形式是常规的代数数据类型，以强制性证据作为参数。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE ExistentialQuantification #-}\n\n-- Using Constraints(約束)\ndata Exp a\n  = (a ~ Int) => LitInt a\n  | (a ~ Bool) => LitBool a\n  | forall b. (b ~ Bool) => If (Exp b) (Exp a) (Exp a)\n\n-- Using GADTs\n-- data Exp a where\n--   LitInt  :: Int  -> Exp Int\n--   LitBool :: Bool -> Exp Bool\n--   If      :: Exp Bool -> Exp a -> Exp a -> Exp a\n\neval :: Exp a -> a\neval e = case e of\n  LitInt i   -> i\n  LitBool b  -> b\n  If b tr fl -> if eval b then eval tr else eval fl\n```\n在存在`GADT`的情况下,推论在许多情况下变得很棘手,通常需要明确的注释.\n例如,`f`可以具有`T a -> [a]`或`T a -> [Int]`,并且都不是主要的。\n```haskell\ndata T :: * -> * where\n  T1 :: Int -> T Int\n  T2 :: T a\n\nf (T1 n) = [n]\nf T2     = []\n```\n\n### Kind Signatures\n`Haskell`的`kind`系统(即:类型的类型)是由`single kind *`和一個`arrow kind ->`组成的系统。\n```Haskell\nκ : *\n  | κ -> κ\n\nInt :: *\nMaybe :: * -> *\nEither :: * -> * -> *\n```\n实际上，此系统有一些扩展将在以后介绍(请参阅后面的部分中的`PolyKinds`和`Unboxed`类型)，但是日常代码中的大多数类型只是星号`*`或箭头`->`。\n\n启用`KindSignatures`扩展后，我们现在可以使用其显式`kinds`(种类)对顶级类型签名进行注释，而无需执行普通的`kind`(种类)推断过程。\n\n```haskell\n{-# LANGUAGE KindSignatures #-}\n\nid :: forall (a :: *). a -> a\nid x = x\n```\n除了默认的`GADT`声明，我们还可以将`GADT`的参数限制为特定`kinds`(种类)。\n对于基本用法，`Haskell`的`kind`(种类)推断可以很好地推断出这一点，但是与其他一些扩展`kind`系统的类型扩展结合起来，这就变得至关重要了。\n```haskell\n{-# Language GADTs #-}\n{-# LANGUAGE KindSignatures #-}\n\ndata Term a :: * where\n  Lit    :: a -> Term a\n  Succ   :: Term Int -> Term Int\n  IsZero :: Term Int -> Term Bool\n  If     :: Term Bool -> Term a -> Term a -> Term a\n\ndata Vec :: * -> * -> * where\n  Nil :: Vec n a\n  Cons :: a -> Vec n a -> Vec n a\n\ndata Fix :: (* -> *) -> * where\n  In :: f (Fix f) -> Fix f\n```\n\n### Void\n`Void`类型是没有居民的类型。它仅与自身`unifies`(結合)。\n使用`newtype`包装器，我们可以创建一种类型，在其中递归使其无法构造`inhabitant`(類型的實例的統稱)。\n```haskell\n-- Void :: Void -> Void\nnewtype Void = Void Void\n```\n或者使用`-XEmptyDataDecls`扩展，我们也可以等效地将`uninhabited`(无人居住)类型构造为没有构造函数的`data`声明。\n```haskell\ndata Void\n```\n这两种类型的唯一`inhabitant`(類型的實例的統稱)是一个类似(`undefined`)的`diverging term`(发散项)。\n\n### Phantom Types(幻影類型)\n`Phantom`类型是出现在类型声明左侧的参数，但不受`inhabitants`(類型的實例的統稱)类型值的限制。\n它们实际上是我们用来在类型级别上编码其他信息的插槽。\n```haskell\nimport Data.Void\n\ndata Foo tag a = Foo a\n\ncombine :: Num a => Foo tag a -> Foo tag a -> Foo tag a\ncombine (Foo a) (Foo b) = Foo (a+b)\n\n-- All identical at the value level, but differ at the type level.\n-- 在值级别上全部相同，但在类型级别上不同。\na :: Foo () Int\na = Foo 1\n\nb :: Foo t Int\nb = Foo 1\n\nc :: Foo Void Int\nc = Foo 1\n\n-- () ~ ()\nexample1 :: Foo () Int\nexample1 = combine a a\n\n-- t ~ ()\nexample2 :: Foo () Int\nexample2 = combine a b\n\n-- t0 ~ t1\nexample3 :: Foo t Int\nexample3 = combine b b\n\n-- 无法将类型't'与'Void'匹配\nexample4 :: Foo t Int\nexample4 = combine b c\n```\n请注意，类型变量标记未出现在声明的右侧。使用此方法，我们可以在类型级别表达不需在值级别体现的不变量。\n我们正在通过在类型级别添加额外的信息来有效地进行编程。\n\n考虑使用`newtypes`静态区分纯文本和加密文本的情况:\n```Haskell\nnewtype Plaintext = Plaintext Text\nnewtype Crytpotext = Cryptotext Text\n\nencrypt :: Key -> Plaintext -> Cryptotext\ndecrypt :: Key -> Cryptotext -> Plaintext\n```\n使用幻像类型，我们使用一个额外的参数:\n```haskell\nimport Data.Text\n\ndata Cryptotext\ndata Plaintext\n\ndata Msg a = Msg Text\n\nencrypt :: Msg Plaintext -> Msg Cryptotext\nencrypt = undefined\n\ndecrypt :: Msg Cryptotext -> Msg Plaintext\ndecrypt = undefined\n```\n使用`-XEmptyDataDecls`可以与不包含任何值`inhabitants`(類型的實例的統稱)且为\"匿名类型\"的幻像类型进行有效组合。\n```haskell\n{-# LANGUAGE EmptyDataDecls #-}\n\ndata Token a\n```\n`tagged`库定义了类似的`Tagged`的`newtype`包装器。\n\n請看: [幻影类型的乐趣](http://www.researchgate.net/publication/228707929_Fun_with_phantom_types/file/9c960525654760c169.pdf)\n\n### Typelevel Operations\n>这是高级部分，编写Haskell通常不需要。\n\n使用更丰富的数据类型语言,我们可以表达见证构造函数中`terms`之间关系的`terms`，\n例如,我们现在可以表达一个表示两种类型的命题相等的`term`。\n\n`Eql a b`类型是`a`和`b`类型相等的证明，通过在单个`Refl`构造函数上进行模式匹配，我们将相等约束引入到模式匹配的主体中。\n```haskell\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE ExplicitForAll #-}\n\n-- a ≡ b\ndata Eql a b where\n  Refl :: Eql a a\n\n-- Congruence(一致性)\n-- (f : A → B) {x y} → x ≡ y → f x ≡ f y\ncong :: Eql a b -> Eql (f a) (f b)\ncong Refl = Refl\n\n-- Symmetry(對稱性)\n-- {a b : A} → a ≡ b → a ≡ b\nsym :: Eql a b -> Eql b a\nsym Refl = Refl\n\n-- Transitivity(傳遞性)\n-- {a b c : A} → a ≡ b → b ≡ c → a ≡ c\ntrans :: Eql a b -> Eql b c -> Eql a c\ntrans Refl Refl = Refl\n\n-- Coerce one type to another given a proof of their equality.\n-- 强迫一种类型到另一种，以证明他们的平等。\n-- {a b : A} → a ≡ b → a → b\ncastWith :: Eql a b -> a -> b\ncastWith Refl = id\n\n-- Trivial cases 簡單的情況\na :: forall n. Eql n n\na = Refl\n\nb :: forall. Eql () ()\nb = Refl\n```\n从`GHC 7.8`开始，这些构造函数和函数包含在`Data.Type.Equality`模块的`Prelude`中。\n\n","tags":["Haskell"]},{"title":"評估模型","url":"/blog/2019/10/08/評估模型/","content":">類型正確的程序不可以\"出錯\".    — Robin Milner\n>http://dev.stephendiehl.com/fun/005_evaluation.html\n\n### Evaluation(評估)\n尽管`lambda`演算极其简单，但评估和实现lambda表达式的约简的方式却多种多样。\n评估的不同模型是评估策略。\n\n设计空间中存在兩點分歧:严格和非严格评估。\n\n如果在约简`lambda`之前必须先评估`lambda`表达式的参数，则稱评估策略是严格的。\n在`lambda`约简之前不必对参数进行求值的语言是非严格的。\n\n换句话说，`diverging terms`(分歧项)由`bottom`值(表示为`⊥f`)表示相等。\n```haskell\nf ⊥ ≠ ⊥\n```\n\n### 評估模型\n有许多不同的模型及其各种混合形式。我们将考虑三种主要模型：\n\n* `Call-by-value`(按值调用): 在進入函数之前先评估参数\n* `Call-by-name`(按名称调用): 参数传递时未评估\n* `Call-by-need`(按需调用): 参数传递时未评估，但表达式只評估一次，并在后续引用时共享\n\n給定一個表達式: `fx`\n```haskell\n    Call-by-value:\n        1. 評估 xv\n        2. 評估 fλy.e\n        3. 評估 [y/v]e\n\n    Call-by-name:\n        1. 評估 fλy.e\n        2. 評估 [y/x]e\n\n    Call-by-need:\n        1. 分配一個thunk vx\n        2. 評估 fλy.e\n        3. 評估 [y/v]e\n```\n在一个模型中具有正常形式的`terms`(項)在另一个模型中可能具有或不具有正常形式。\n在`call-by-need`和`call-by-name`的评估中，不一定要在進入之前就评估不同的`terms`(項)，因此在这些模型中具有正常形式的某些`term`(項)可能会在`call-by-value`的情况下发生偏离。\n\n#### Call-by-value\n`Call-by-value`是一种非常普遍的评估模型。许多命令式和函数式编程语言都使用此评估策略。\n\n`Call-by-value`的本质是有两类表达式: `terms`(术语/項)和`values`(值)。\n\n`values`是`lambda`表达式和其他形式的普通项，不能进一步简化。函数的所有参数在被绑定到`lambda`内部之前都将被简化为正常形式，并且只有在参数被简化之后才会进行归纳。\n\n对于简单的算术表达式，归纳如下进行。请注意，子表达式`(2 + 2)`在绑定之前是如何评估为正常形式的。\n```haskell\n(\\x. \\y. y x) (2 + 2) (\\x. x + 1)\n=> (\\x. \\y. y x) 4 (\\x. x + 1)\n=> (\\y. y 4) (\\x. x + 1)\n=> (\\x. x + 1) 4\n=> 4 + 1\n=> 5\n```\n当然，对于应用程序有两个评估规则。\n\n![](img/img01.png)\n\n对于简单的小的`λ`演算，按值调用解释器非常简单。`lambda`演算的运行时评估的一部分涉及创建闭包，即将局部变量保存在作用域内的环境。\n用我们的小语言来说，`reduction`(規約)可能会收敛的两个可能的值是`VInt`和`VClosure`。\n```haskell\ndata Expr\n  = Var Int\n  | Lam Expr\n  | App Expr Expr\n  | Lit Int\n  | Prim PrimOp Expr Expr\n  deriving Show\n\ndata PrimOp = Add | Mul\n  deriving Show\n\ndata Value\n  = VInt Int\n  | VClosure Expr Env\n  deriving Show\n\ntype Env = [Value]\n\nemptyEnv :: Env\nemptyEnv = []\n```\n评估函数仅将本地作用域和一個`term`(术语)映射到最终值。每当引用变量时，都会在环境中查找该变量。\n每当输入`lambda`时，它将使用闭包的本地作用域扩展环境。\n```haskell\neval :: Env -> Expr -> Value\neval env term = case term of\n  Var n -> env !! n\n  Lam a -> VClosure a env\n  App a b ->\n    let VClosure c env' = eval env a in\n    let v = eval env b in\n    eval (v : env') c\n\n  Lit n -> VInt n\n  Prim p a b -> (evalPrim p) (eval env a) (eval env b)\n\nevalPrim :: PrimOp -> Value -> Value -> Value\nevalPrim Add (VInt a) (VInt b) = VInt (a + b)\nevalPrim Mul (VInt a) (VInt b) = VInt (a * b)\n```\n\n#### Call-by-name\n在`Call-by-name`评估中，將按原样替换`lambda`表达式的参数，评估仅从左向右进行替换最外面的`lambda`或归约值。如果不使用替换表达式，则永远不会求值。\n![](img/img02.png)\n\n例如，我们看过的`Call-by-value`的相同表达式具有相同的正常形式，但通过不同的归约顺序得出：\n```haskell\n(\\x. \\y. y x) (2 + 2) (\\x. x + 1)\n=> (\\y. y (2 + 2)) (\\x. x + 1)\n=> (\\x. x + 1) (2 + 2)\n=> (2 + 2) + 1\n=> 4 + 1\n=> 5\n```\n尽管很少有语言使用此模型，但`Call-by-name`不是严格的。\n\n#### Call-by-need\n`Call-by-need`是一种特殊类型的非严格评估，其中未评估的表达式由`suspensions`或`thunks`表示，将其传递到未评估的函数中，仅在需要或强制时才对其进行评估。\n\n当强制使用`thunk`时，`thunk`的表示将使用计算值进行更新，并且在进一步引用时不会重新计算。\n\n未评估的`lambda`表达式的`thunk`会在评估时分配，并将所得的计算值放在相同的引用中，以便后续计算共享结果。如果不再需要该参数，则永远不会对其进行计算，这将导致在空间和时间之间进行权衡。\n\n由于子表达式的评估不遵循任何预先定义的顺序，因此带有副作用的任何不纯函数的评估都将以不确定的顺序进行。因此，仅在纯函數设置中才能有效实现`Call-by-need`。\n\n```haskell\ntype Thunk = () -> IO Value\n\ndata Value\n  = VBool Bool\n  | VInt Integer\n  | VClosure (Thunk -> IO Value)\n\nupdate :: IORef Thunk -> Value -> IO ()\nupdate ref v = do\n  writeIORef ref (\\() -> return v)\n  return ()\n\nforce :: IORef Thunk -> IO Value\nforce ref = do\n  th <- readIORef ref\n  v <- th ()\n  update ref v\n  return v\n\nmkThunk :: Env -> String -> Expr -> (Thunk -> IO Value)\nmkThunk env x body = \\a -> do\n  a' <- newIORef a\n  eval ((x, a') : env) body\n\neval :: Env -> Expr -> IO Value\neval env ex = case ex of\n  EVar n -> do\n    th <- lookupEnv env n\n    v <- force th\n    return v\n\n  ELam x e -> return $ VClosure (mkThunk env x e)\n\n  EApp a b -> do\n    VClosure c <- eval env a\n    c (\\() -> eval env b)\n\n  EBool b -> return $ VBool b\n\n  EInt n  -> return $ VInt n\n\n  EFix e  -> eval env (EApp e (EFix e))\n```\n例如，在这个模型中，下面的程序不会`diverge`(发散)，因为传递给常量函数的`omega`组合子没有被使用，因此参数没有被求值。\n```haskell\nomega = (\\x -> x x) (\\x -> x x)\ntest1 = (\\y -> 42) omega\n\nomega :: Expr\nomega = EApp (ELam \"x\" (EApp (EVar \"x\") (EVar \"x\")))\n             (ELam \"x\" (EApp (EVar \"x\") (EVar \"x\")))\n\ntest1 :: IO Value\ntest1 = eval [] $ EApp (ELam \"y\" (EInt 42)) omega\n```\n### Higher Order Abstract Syntax (HOAS)\n`GHC Haskell`是一种丰富的语言，具有多种扩展功能，除其他外，这些功能使我们能够将定义语言中的`lambda`表达式直接映射到`Haskell`中的`lambda`表达式。\n在这种情况下，我们将使用`GADT`在我们的表达式类型中嵌入`Haskell`表达式。\n\n```haskell\n{-# LANGUAGE GADTs #-}\n\ndata Expr a where\n  Lift :: a                       -> Expr a\n  Tup  :: Expr a -> Expr b        -> Expr (a, b)\n  Lam  :: (Expr a -> Expr b)      -> Expr (a -> b)\n  App  :: Expr (a -> b) -> Expr a -> Expr b\n  Fix  :: Expr (a -> a)           -> Expr a\n```\n这种编码最显著的特点是，变量没有獨特的构造函数。相反，它们只是宿主语言中的值。一些示例表达式:\n```haskell\nid :: Expr (a -> a)\nid = Lam (\\x -> x)\n\ntr :: Expr (a -> b -> a)\ntr = Lam (\\x -> (Lam (\\y -> x)))\n\nfl :: Expr (a -> b -> b)\nfl = Lam (\\x -> (Lam (\\y -> y)))\n```\n然后，我们的`evaluator`只需使用`Haskell`进行评估。\n```haskell\neval :: Expr a -> a\neval (Lift v)    = v\neval (Tup e1 e2) = (eval e1, eval e2)\neval (Lam f)     = \\x -> eval (f (Lift x))\neval (App e1 e2) = (eval e1) (eval e2)\neval (Fix f)     = (eval f) (eval (Fix f))\n```\n一些使用的例子:\n```haskell\nfact :: Expr (Integer -> Integer)\nfact =\n  Fix (\n    Lam (\\f ->\n      Lam (\\y ->\n        Lift (\n          if eval y == 0\n          then 1\n          else eval y * (eval f) (eval y - 1)))))\n\ntest :: Integer\ntest = eval fact 10\n\nmain :: IO ()\nmain = print test\n```\n在使用`HOAS`时必须注意几点。首先，转换这种形式的表达式需要做更多的工作，因为为了处理表达式，我们需要到达`Haskell`函数本身的`lambda`绑定下。因为所有的机制都被封装在`Haskell`的实现中，即使是像漂亮的打印和编写转换传递这样的简单操作也会变得更加困难。这种形式是评估的好形式，但不是转换的好形式。\n\n### Parametric Higher Order Abstract Syntax (PHOAS)\n另一种稍微不同的`HOAS`形式称为`PHOAS`，它在存在类型下的绑定类型上使用参数化的`lambda`表示。\n```haskell\n{-# LANGUAGE RankNTypes #-}\n\ndata ExprP a\n  = VarP a\n  | AppP (ExprP a) (ExprP a)\n  | LamP (a -> ExprP a)\n  | LitP Integer\n\nnewtype Expr = Expr { unExpr :: forall a . ExprP a }\n```\n我们语言中的`lambda`只是`Haskell`中的`lambda`。例如，通常的`SK`组合器将编写如下:\n```haskell\n-- i x = x\ni :: ExprP a\ni = LamP (\\a -> VarP a)\n\n-- k x y = x\nk :: ExprP a\nk = LamP (\\x -> LamP (\\y -> VarP x))\n\n-- s f g x = f x (g x)\ns :: ExprP a\ns = \n  LamP (\\f -> \n    LamP (\\g -> \n      LamP (\\x -> \n        AppP \n          (AppP (VarP f) (VarP x))\n          (AppP (VarP g) (VarP x))\n        )))\n```\n评估将产生运行时`Value`类型，就像我们的外部解释器一样。\n我们将使用几个`extractor`函数，这些函数在後台使用不完整的模式。\n该模型本身并不能防止格式错误的程序在这里爆炸，因此有必要在评估之前确保程序是正确的。 通常，在达到这一点之前，`typechecker`(类型检查器)会在更高级别上保证这一点。\n```haskell\ndata Value\n  = VLit Integer\n  | VFun (Value -> Value)\n\nfromVFun :: Value -> (Value -> Value)\nfromVFun val = case val of\n  VFun f -> f\n  _      -> error \"not a function\"\n\nfromVLit :: Value -> Integer\nfromVLit val = case val of\n  VLit n -> n\n  _      -> error \"not an integer\"\n```\n评估只是利用了一个事实，即利用了我們存在类型下的`Haskell`函数，因此我们免费获得所有名称捕获，闭包和绑定机制。`PHOAS`模型的评估逻辑非常短。\n```haskell\neval :: Expr -> Value\neval e = ev (unExpr e) where\n  ev (LamP f)      = VFun(ev . f)\n  ev (VarP v)      = v\n  ev (AppP e1 e2)  = fromVFun (ev e1) (ev e2)\n  ev (LitP n)      = VLit n\n```\n再次考虑`S K K = I`示例，并检查结果:\n```haskell\nskk :: ExprP a\nskk = AppP (AppP s k) k\n\nexample :: Integer\nexample = fromVLit $ eval $ Expr (AppP skk (LitP 3))\n```\n我们将广泛地使用这种评估技术来为我们更大的语言编写翻译。这是在`Haskell`中编写解释器非常方便和有用的方法。\n\n### Embedding IO\n如前所述，`effects`是`Haskell`中的一流值。\n\n在`Haskell`中，我们不直接读取文件，而是创建一个表示读取文件的值。通过在我们的语言的基本操作与`Haskell`中标准操作的现有函数实现之间建立映射，并使用`monadic`操作建立纯有效的计算结果，我们可以在`Haskell`中为我们的语言的解释程序建立非常清晰的模型的解释。经过评估，我们最终将得到的`IO`值提升到`Haskell`中并执行结果。这与`PHOAS`模型非常吻合，并且使我们能够简单地利用`Haskell`的实现，以非常少的代码有效地为我们的语言实现完整的解释器。\n\n要将`IO`操作嵌入我们的解释器中，我们创建了一个独特的`VEffect`值，该值将在评估过程中建立顺序`IO`计算。该值将传递给`Haskell`，并具体化为现实世界的`effects`。\n```haskell\ndata ExprP a\n  = VarP a\n  | GlobalP Name\n  | AppP (ExprP a) (ExprP a)\n  | LamP (a -> ExprP a)\n  | LitP Char\n  | EffectP a\n\ndata Value\n  = VChar Char\n  | VFun (Value -> Value)\n  | VEffect (IO Value)\n  | VUnit\n\nfromVEff :: Value -> (IO Value)\nfromVEff val = case val of\n  VEffect f -> f\n  _         -> error \"not an effect\"\neval :: Expr -> Value\neval e = ev (unExpr e) where\n  ev (LamP f)      = VFun(ev . f)\n  ev (AppP e1 e2)  = fromVFun (ev e1) (ev e2)\n  ev (LitP n)      = VChar n\n  ev (EffectP v)   = v\n  ev (VarP v)      = v\n  ev (GlobalP op)  = prim op\n\n-- Lift an effect from our language into Haskell IO.\nrun :: Expr -> IO ()\nrun f = void (fromVEff (eval f))\n```\n`prim`函数将仅对一组内置操作执行查找，我们将使用一些语法糖来定义这些操作，以包装`Haskell`函数。\n```haskell\nunary :: (Value -> Value) -> Value\nunary f = lam $ \\a -> f a\n\nbinary :: (Value -> Value -> Value) -> Value\nbinary f = lam $ \\a ->\n           lam $ \\b -> f a b\n\nprim :: Name -> Value\nprim op = case op of\n \"putChar#\" -> unary $ \\x ->\n    VEffect $ do\n      putChar (fromVChar x)\n      return VUnit\n\n \"getChar#\" -> VEffect $ do\n      val <- getChar\n      return (VChar val)\n\n \"bindIO#\"   -> binary $ \\x y -> bindIO x y\n \"returnIO#\" -> unary  $ \\x   -> returnIO x\n \"thenIO#\"   -> binary $ \\x y -> thenIO x y\n```\n例如，我们语言中的`thenIO＃`序列`effects`(效果)将简单地将两个`VEffect`对象压缩为一个复合`effects`，从而建立一个新的`VEffect`值，该值在內部`IO`值上使用`Haskell`的`monadic`序列.\n```haskell\nbindIO :: Value -> Value -> Value\nbindIO (VEffect f) (VFun g) = VEffect (f >>= fromVEff . g)\n\nthenIO :: Value -> Value -> Value\nthenIO (VEffect f) (VEffect g) = VEffect (f >> g)\n\nreturnIO :: Value -> Value\nreturnIO a = VEffect $ return a\n```\n实际上，我们只是重新创建了与`Haskell IO`及其运行时相同的概念关系，但是，我们的宿主语言使用`Haskell`作为运行时.","tags":["Evaluation"]},{"title":"类型系統","url":"/blog/2019/09/29/类型系統/","content":"> [A type system is a] tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute.  — Benjamin Pierce\n> http://dev.stephendiehl.com/fun/004_type_systems.html\n\n类型系统是一种形式语言，我们可以在其中描述和限制编程语言的语义。该主题的研究是一个丰富而开放的研究领域，在设计空间中具有许多自由度。\n如引言中所述，这是一个非常大的主题，我们将仅涵盖足够多的主题以完成针对我们语言的类型检查器的编写，而不是针对该主题的全面性。\n每个人都阅读的经典文章是`Types and Programming Languages`或`TAPL`，并更深入地讨论了该主题。实际上，我们将以`Haskell`的风格非常紧密地遵循`TAPL`。\n\n\n### Rules\n在编程语言语义的研究中，逻辑语句是用特定的逻辑符号编写的。对于我们的目的，`property`(属性)是关于术语类型的事实。它的写法如下:\n```\n1:𝙽𝚊𝚝\n```\n这些事实存在于被称为类型系统的预设话语范围之内，类型系统具有定义，属性，约定以及关于类型和术语的逻辑推论规则。 在给定的系统中，我们将具有关于这些术语的几个属性。 例如:\n* **(A1)** `0`是一個自然數\n* **(A2)** 對於一個自然數`n`, `𝚜𝚞𝚌𝚌(n)`也是一個自然數.\n\n给定自然数的几个属性，我们将使用一种表示法，将其链接在一起以形成有关系统中任意项的证明。\n![](img/img01.png)\n\n在这种表示法中，该行上方的表达式称为先例，而该行下方的表达式称为结论。没有先例的规则是一个公理。\n\n变量`n`是代表任何自然数的元变量，规则实例是这些元变量的值替换。\n`derivation`(推导)是有限深度规则的树。我们写`⊢ C`表示存在一个推论，其结论为`C`，证明`C`是可证明的。\n\n例如`⊢ 2: 𝙽𝚊𝚝`的推导:\n\n![](img/img02.png)\n\n这些推导中还可能存在类型上下文或被寫作`Γ`的类型環境。\n上下文是一系列命名变量映射到关于命名变量的属性。\n上下文的逗号运算符通过在现有集合的右侧添加新`property`(属性)来扩展`Γ`。\n空上下文用`∅`表示，是该属性链中不包含任何信息的终端元素。\n因此，上下文定义为：\n![](img/img03.png)\n\n这是使用上下文进行加法的类型规则的示例:\n![](img/img04.png)\n\n在这种情况下，无论上下文如何，`property`(属性)总是隐含的，我们将缩短表达式。这只是一个词汇约定。\n![](img/img05.png)\n\n### Type Safety(类型安全)\n在使用这种逻辑符号对编程语言的语义进行建模的上下文中，我们经常提到语义规则的两个基本規則。\n* **Statics(静态)**: 从语言语法中派生出来的语义描述。\n* **Dynamics(动态)**: 描述由程序产生的值演化的语义描述。\n\n类型安全性定义为语言的静态和动态之间的等效性。这种等效性由两个与类型和评估语义相关的属性来建模:\n\n* **Progress**: 如果表达式的类型正确，则要么是一个值，要么可以通过可用的评估规则对其进行进一步评估。\n* **Preservation**: 如果表达式`e`的类型为`τ`，并且被评估为`e'`，则`e'`的类型为`τ`。\n\n### Types\n`type`(类型)一词在常见的编程词典中经常被重载。其他语言通常将在动态语言中出现的运行时标签称为类型。一些例子：\n```Haskell\n# Python\n>>> type(1)\n<type 'int'>\n\n# Javascript\n> typeof(1)\n'number'\n\n# Ruby\nirb(main):001:0> 1.class\n=> Fixnum\n\n# Julia\njulia> typeof(1)\nInt64\n\n# Clojure\nuser=> (type 1)\njava.lang.Long\n```\n虽然这是一个完全可以接受的替代定义，但我们不会走这条路线，而只会将自己纯粹局限于静态类型的讨论，换句话说，就是在运行时之前已知的类型。根据这组定义，许多所谓的动态类型语言通常仅具有单个静态类型。\n例如，在`Python`中，所有静态类型都包含在`PyObject`中，并且只有在运行时才区分出标签`PyTypeObject * ob_type`，以产生`type`的`Python`概念。\n同样，这不是我们将要讨论的类型。这些语言之间的权衡是，它们通常具有琐碎的静态语义，而语言的动态性却往往极其复杂。`Haskell`和`OCaml`之类的语言是此设计领域的对立面。\n类型通常会写成`τ`，并且可以包含许多不同的构造，以至于类型语言可能变得与`value`(值)级别语言一样丰富。\n\n现在，我们仅考虑三种简单类型，两种`ground`类型(`𝙽𝚊𝚝`和`𝙱𝚘𝚘𝚕`)和一种`arrow`(箭头)类型:\n\n![](img/img06.png)\n\n`arrow`(箭头0类型将是函数表达式的类型，左参数是输入类型，右参数是输出类型。按照惯例，`arrow`类型将关联到右侧:\n\n![](img/img07.png)\n\n在我们将实现的所有语言中，编译期间出现的类型都将被擦除。虽然类型可能出现在计算语义中，但是`runtime`运行时不能在运行时对值的类型进行分派。\n根据定义，类型仅在编译时存在于该语言的静态语义中。\n\n### Small-Step Semantics\n我们真正感兴趣的正式描述是编程语言中的表达式。编程语言语义由该语言的操作语义描述。操作语义可以看作是对抽象机器的描述，抽象机器按照编程语言的抽象术语进行操作，就像虚拟机按照指令进行操作一样。\n我们使用了一个名为\"小步骤语义\"的框架，在这个框架中，派生过程展示了如何重写组合以生成一个`term`(术语)，我们可以通过一系列状态更改将该术语计算为一个值。\n这是一个框架，通过描述可能的`transitions`(过渡)类型和`terms`可能占用的空间，在运行程序之前对程序运行时行为的各个方面进行建模。\n我们希望`term`能够过渡并终止为我们语言中的一個值，而不是像我们之前遇到的那样被\"卡住\"。\n在构造第一个解析器之前，请回顾一下我们的小计算器语言:\n```Haskell\ndata Expr\n  = Tr\n  | Fl\n  | IsZero Expr\n  | Succ Expr\n  | Pred Expr\n  | If Expr Expr Expr\n  | Zero\n```\n表达式语法如下:\n\n![](img/img08.png)\n\n这种小语言的小步评估语义由以下9条规则唯一定义。\n`They describe each step that an expression may take during evaluation which may or may not terminate and converge on a value.`(它们描述了表达式在评估过程中可能采取的可能终止或收敛于某个值的每个步骤。)\n\n![](img/img09.png)\n\n我们的解释器的评估逻辑只是通过预定义的评估规则来简化表达式，直到表达式达到标准形式(一個值)或陷入困境为止。\n```Haskell\nnf :: Expr -> Expr\nnf t = fromMaybe t (nf <$> eval1 t)\n\neval :: Expr -> Maybe Expr\neval t = case isVal (nf t) of\n  True  -> Just (nf t)\n  False -> Nothing -- term is \"stuck\"\n```\n我们语言中的值定义: 文字数或布尔值.\n```Haskell\nisVal :: Expr -> Bool\nisVal Tr = True\nisVal Fl = True\nisVal t | isNum t = True\nisVal _ = False\n```\n以`applicative`形式编写的评估规则与我们的评估逻辑之间存在明显的对应关系。\n```Haskell\n-- Evaluate a single step.\neval1 :: Expr -> Maybe Expr\neval1 expr = case expr of\n  Succ t                    -> Succ <$> (eval1 t)\n  Pred Zero                 -> Just Zero\n  Pred (Succ t) | isNum t   -> Just t\n  Pred t                    -> Pred <$> (eval1 t)\n  IsZero Zero               -> Just Tr\n  IsZero (Succ t) | isNum t -> Just Fl\n  IsZero t                  -> IsZero <$> (eval1 t)\n  If Tr  c _                -> Just c\n  If Fl _ a                 -> Just a\n  If t c a                  -> (\\t' -> If t' c a) <$> eval1 t\n  _                         -> Nothing\n```\n正如我们之前所注意到的，我们可以构造出各种病态的表达方式，这些表达方式会被卡住。\n查看计算规则，每一个受保护的模式匹配都提示我们，当布尔值用于数字的位置时，哪里可能\"出错\"，反之亦然。\n我们希望在编译时静态地强制执行这个不变量，因此我们将引入一个小型类型系统来处理现有术语的两种语法类别。除了箭头类型，我们还添加了自然数的抽象类型和布尔值的类型:\n![](img/img10.png)\n\n在Haskell中实现为以下数据类型:\n```Haskell\ndata Type\n  = TBool\n  | TNat\n  | TArr Type Type\n```\n現在的类型規則:\n![](img/img11.png)\n\n这些规则限制了所有可能程序的空间。\n\n这是一个更复杂的展示，但这一制度也有`progress`(进步)和`preservation`(保存)。如果一个`term`(术语)现在是类型良好的，那么它将始终计算为一个值，并且在计算时不会\"出错\"。\n为了检查表达式的格式是否良好，我们实现了一段称为类型检查器的逻辑，它确定`term`是否具有定义良好的类型(根据类型规则)，如果有，则返回该类型，如果没有，则返回失败(除非没有)。\n```Haskell\ntype Check a = Except TypeError a\n\ndata TypeError\n  = TypeMismatch Type Type\n\ncheck :: Expr -> Either TypeError Type\ncheck = runExcept . typeof\ntypeof :: Expr -> Check Type\ntypeof expr = case expr of\n  Succ a -> do\n    ta <- typeof a\n    case ta of\n      TNat -> return TNat\n      _    -> throwError $ TypeMismatch ta TNat\n\n  Pred a -> do\n    ta <- typeof a\n    case ta of\n      TNat -> return TNat\n      _    -> throwError $ TypeMismatch ta TNat\n\n  IsZero a -> do\n    ta <- typeof a\n    case ta of\n      TNat -> return TBool\n      _    -> throwError $ TypeMismatch ta TNat\n\n  If a b c -> do\n    ta <- typeof a\n    tb <- typeof b\n    tc <- typeof c\n    if ta /= TBool\n    then throwError $ TypeMismatch ta TBool\n    else\n      if tb /= tc\n      then throwError $ TypeMismatch ta tb\n      else return tc\n\n  Tr   -> return TBool\n  Fl   -> return TBool\n  Zero -> return TNat\n```\n\n\n### Observations\n我们以前在無類型语言中遇到的病态术语现在完全没有表达能力，并且在编译时被拒绝。\n```Haskell\nArith> succ 0\nsucc 0 : Nat\n\nArith> succ (succ 0)\nsucc (succ 0) : Nat\n\nArith> if false then true else false\nfalse : Bool\n\nArith> iszero (pred (succ (succ 0)))\nfalse : Bool\n\nArith> pred (succ 0)\n0 : Nat\n\nArith> iszero false\nType Mismatch: Bool is not Nat\n\nArith> if 0 then true else false\nType Mismatch: Nat is not Bool\n```\n很好，我们已经使整个非法程序类都无法表示。让我们做更多的事情！\n\n### Simply Typed Lambda Calculus\n\n`Church`和`Curry`的`simply typed lambda calculus(STLC)`是`lambda`演算的扩展，该演算用类型项注释每个`lambda`绑定器。`STLC`是明确类型化的，所有类型都直接出现在绑定器上，要确定范围内任何变量的类型，我们只需要遍历其`enclosing`包围范围即可。\n\n![](img/img12.png)\n\n最简单的`STLC`语言是这三个`terms`(术语)，但是，我们将添加数字和布尔文字项，以便我们编写有意义的示例。\n\n![](img/img13.png)\n\n我们可以為我們的語言考虑一种非常简单的类型系统，它由`Int`和`Bool`类型以及`function`类型组成。\n\n![](img/img14.png)\n\n\n### Type Checker\n类型规则非常简单，并且我们再次获得了不错的属性，即每个语法术语与类型规则之间存在一对一的映射。\n\n* **T-Var**: 变量只是从上下文中提取。\n* **T-Lam**: 在推断主体时`lambdas`将类型化变量引入到环境中。\n* **T-App**: 将类型为`t1 -> t2`的`lambda`应用于类型为`t1`的值将产生类型为`t2`的值。\n\n![](img/img15.png)\n\n评估规则描述了值在其他值之间转换的本质，并确定了程序的运行时行为。\n\n![](img/img16.png)\n\n由于我们现在有了`lambda`范围变量的概念，因此我们将在类型规则中实现一个以`Γ`形式表示的类型环境`Env`。\n```Haskell\ntype Env = [(Name, Type)]\n\nextend :: (Name, Type) -> Env -> Env\nextend xt env = xt : env\n\ninEnv :: (Name, Type) -> Check a -> Check a\ninEnv (x,t) = local (extend (x,t))\n\nlookupVar :: Name -> Check Type\nlookupVar x = do\n  env <- ask\n  case lookup x env of\n    Just e  -> return e\n    Nothing -> throwError $ NotInScope x\n```\n\n类型检查器将是`ExceptT + Reader monad`的转换器，其中读取器将保持类型环境。\n简单类型的`lambda`演算类型检查器有三种可能的故障模式:\n* 我们尝试`unify`(统一)两种不同类型。\n* 我们尝试对参数应用非函数。\n* 引用变量不在范围内。\n```Haskell\ndata TypeError\n  = Mismatch Type Type\n  | NotFunction Type\n  | NotInScope Name\n\ntype Check = ExceptT TypeError (Reader Env)\n```\n这里的语法模式与其等效的类型判断之间存在直接等价关系。通常，情况并非总是如此。类型检查器的实现如下：\n```Haskell\ncheck :: Expr -> Check Type\ncheck expr = case expr of\n\n  Lit (LInt{}) -> return TInt\n\n  Lit (LBool{}) -> return TBool\n\n  Lam x t e -> do\n    rhs <- inEnv (x,t) (check e)\n    return (TArr t rhs)\n\n  App e1 e2 -> do\n    t1 <- check e1\n    t2 <- check e2\n    case t1 of\n       (TArr a b) | a == t2 -> return b\n                  | otherwise -> throwError $ Mismatch t2 a\n       ty -> throwError $ NotFunction ty\n\n  Var x -> lookupVar x\n```\n\n### Evaluation(評估)\n从根本上说，类型化`lambda`演算的计算与非类型化`lambda`演算没有什么不同，也不可能有什么不同，因为类型的语法添加纯粹是一个静态构造，根据定义，在运行时不能有任何表现。\n唯一的區別是: 简单类型的`lambda`演算所接受的程序比非类型的`lambda`演算所允许的程序少得多(即类型化的更严格)。\n静态类型化语言的编译的基本思想是，可以通过擦除类型信息但保留类型化程序的评估语义，将类型化程序转换为未类型化程序。如果我们的程序具有类型安全性，则它永远不会在运行时\"出错\"。\n当然反过来是不正确的，没有\"出错\"的程序不一定是类型正确的，尽管我们是否可以证明一个不良类型的程序是否不会出错是一个正交的问题。我们作为静态类型语言实现者的游戏基本上是一种限制：我们會占据所有程序的空间，并在我们愿意考虑的程序讨论范围内划出一条大界限，因为這些是我们唯一可以证明其属性的程序。\n> 类型正确的程序不会出错，但是，并非每个不会出错的程序都类型正确。 展示不会出错但在任何可判定类型系统中类型错误的程序很容易。许多这样的程序很有用，这就是为什么像Erlang和Lisp这样的动态类型语言很受欢迎的原因。 -- Simon Peyton Jones\n\n权利总是有代价的。使用一个系统，您可以做更多的事情。在另一种方法中，您可以更多地谈论程序可以做的事情。语言设计学科的基础艺术是平衡两者，以找到正确的功率重量比。\n\n### Observations\n嘗試一些簡單的例子:\n```Haskell\nStlc> (\\x : Int . \\y : Int . y) 1 2\n2\n\nStlc> (\\x : (Int -> Int). x) (\\x : Int . 1) 2\n1\n\nStlc> (\\x : Int . x) False\nCouldn't match expected type 'Int' with actual type: 'Bool'\nStlc> 1 2\nTried to apply to non-function type: Int\n\nStlc> (\\x : Int . (\\y : Int . x))\n<<closure>>\n```\n\n### Notation Reference(符号參考)\n此处介绍的符号将在`Haskell`编译器的整个构建过程中使用。作为参考，这里列出了我们将使用的每种符号约定。其中一些术语尚未引入。\n![](img/img17.png)","tags":["类型系統"]},{"title":"Lambda演算","url":"/blog/2019/09/28/Lambda演算/","content":"> 語言是人類理性的工具，而不僅僅是表達思想的媒介，這是公認的真理。 — George Boole\n> http://dev.stephendiehl.com/fun/003_lambda_calculus.html\n\n## Lambda演算\n所有函數式語言的基礎都是原子的組合概念，即單個變量的函數抽象。`Lambda`演算非常簡單的由三個項及其所有有效的遞歸組合組成。\n![](img/img01.png)\n\n這個緊湊的符號看起來與您在`Haskell`中使用的符號略有不同，但實際上沒有: `λx.xa`等同於`\\x -> x a`。這意味著您在上圖中看到的內容將轉換為`(\\x -> x) (\\y -> y)`，這等同於`id id`（當然，其結果為`id`）。\n\n這三個術語通常在代碼中通過它們名稱的幾個縮寫來表示:\n* **Var** - 標識一個變量\n* **Lam** - 標識一個lambda抽象\n* **App** - 標識一個應用\n\n一個lambda項被稱為綁定它的變量。例如這裏的`lambda`綁定`x`，在數學中我們通常會這麼寫:\n```haskell\nf(x) = e\n```\n\n使用lambda演算符號，我們寫為:\n```haskell\nf = λx.e\n```\n換句話説，`λx.e`是一個接收變量`x`，返回`e`的函數.\n```haskell\ne := x      (Var)\n     λx.e   (Lam)\n     e e    (App)\n```\n`lambda`演算通常被稱為函數式編程的\"匯編語言\"，它的變體和擴展構成了許多函數編譯器中間形式的基礎，這些中間形式適用於`Haskell/Ocaml/StandardML`等語言。\n\n我們首先討論的變體稱為`無類型的Lambda演算`，相比之下，稍後我們將討論`類型化的Lambda演算`，它是其擴展。\n\n編寫`Lambda`表達式時，我們將採用機種語法約定。多個表達式的`App`執行左關聯:\n```haskell\nx1 x2 x3 ...Xn = (...((x1x2)x3)...Xn)\n```\n按照慣例，`App`在語法上盡可能向右擴展，括號用於消除歧異。\n\n在`Lambda`演算中，每個`Lambda`抽象綁定一個變量，而`lambda`抽象的主體可能是另一個`lambda`抽象，為了方便，我們經常在一個符號上寫多個`lambda`抽象及其變量。這只是一種語法約定，並不會改變其基本含義。\n```haskell\nλxy.z = λx.λy.z\n```\n`lambda`演算的實際實現允許在表示`lambda`抽象方面有幾個自由度。\n最值得注意的是為綁定變量選擇標識符。\n\n如果一個變量包含在同一個變量綁定的`lambda`表達式中，則稱該變量`bound`(範圍內的)。相反，如果變量沒有`bound`(不在範圍內)，則稱它是`free`(自由)的。\n有`free`變量的項稱為`open term`(開項)，而沒有`free`變量的項稱為`closed`(閉項)或`combinator`(組合子)。\n\n![](img/img02.png)\n\n`e0`是一個`combinator`，而`e1`不是。\n在`e1`中出現的兩次`x`，都是`bound`的，第一個`y`也是`bound`的，而第二個`y`是`free`的。`a`也是`free`的。\n\n多個`lambda`抽象可以綁定相同的變量名稱，然後，每次出現的變量都由最近的`enclosing binder`(封閉綁定器)來`bound`(限定它的範圍)。\n例如: 以下表達式中的`x`變量`bound`(限定)在內部的`lambda`上，而`y`變量`bound`(限定)在外部`lambda`上。這種現象稱為`name shadowing`(名稱陰影)。\n```haskell\nλxy.(λxz.x + y)\n```\n\n### SKI Combinators\n有三個基本的`closed`表達式，稱為`SKI`組合器。\n![](img/img03.png)\n\n在`Haskell`中，它們被寫做:\n```haskell\ns f g x = f x (g x)\nk x y = x\ni x = x\n```\n相當引人注目的`Moses Schonfinkel`表明: 所有的`closed lambda`表達式都可以僅用`S`和`K`組合子表示(甚至是`I`組合子)。\n例如，我們可以很容易的證明`SKK`可以簡化為`I`.\n![](img/img04.png)\n\n在测试`lambda`演算的实现时，这是一个有用的完整性检查。\n\n### Implementation(實現)\n具有命名綁定的`lambda`演算語法 最簡單的實現是使用以下定義:\n```haskell\ntype Name = String\n\ndata Expr\n  = Var Name\n  | App Expr Expr\n  | Lam Name Expr\n```\n\n`lambda`表達式有機種詞法語法選擇，我們將簡單的選擇`Haskell`約定, 它以反斜槓(`\\`)到具有(`->`)的主體表示`lambda`，并以空格表示`App`。命名變量只是字母數字字符序列。\n\n* ***Logical notation***: `𝚌𝚘𝚗𝚜𝚝 = λxy.x`\n* ***Haskell notation***: `const = \\x y -> x`\n\n此外，可以添加其他術語，如文字數字或布爾值，這使編寫說明性示例更加容易，對於這些，我們將添加一個`Lit`構造函數。\n\n```haskell\ndata Expr\n  = ...\n  | Lit Lit\n\ndata Lit\n  = LInt Int\n  | LBool Bool\n```\n\n### Substitution(替換)\n`lambda`項`(((xx.e)a))`的評估通過用參數`a`替換`e`中所有自由出現的變量`x`來進行。\n一個單個的替換步驟被稱為`reduction`(減少/約簡)。\n\n我們將替換`application`放在要應用的表達式之前的方括號中，\n`[x/a]e`将变量`x`映射到表达式`e`上的新替换`a`。\n```haskell\n(λx.e)a → [x/a]e\n```\n一個替換元變量被寫作`[s]`.\n詳細的替換定義如下:\n![](img/img05.png)\n\n`fv(e)`是`e`中的自由變量集.\n\n使用本地命名的綁定器的根本問題是名稱捕獲的問題，或者如何處理替換與自由變量的名稱衝突的情況。我們需要在最後一種情況下使用該條件，以避免將`y`重寫為`x`時會從根本上改變以下表達式含義的幼稚替換。\n```haskell\n[y/x](λx.xy) → λx.xx\n```\n按照慣例，我們總是使用`capture-avoiding`(避免捕獲)替換，只有當變量不在表達式的自由變量集合中時，替換才會繼續進行，如果變量不在表達式的自由變量集合中，則會在其位置上創建一個新的變量。\n```haskell\n(λx.e)a → [x/a]e   if x ∉ 𝚏𝚟(a)\n```\n有幾個綁定庫和`lambda`演算語法的替代實現可以避免這些問題，這是一個非常常見的問題，即使是專家也很容易執行錯誤。\n```haskell\n### free occurance demo\n(λx. x) y  =  y\n(λx. f x x) y  =  f y y\n(λx. f x x) (g y)  =  f (g y) (g y)\n\n(λx. λz. f x z) (g y)  =  λz. f (g y) z\n\n(λx. λz. f (λx. g x) z) (g y)  =  λz. f (λx. g x) z\n\n### 这是一个更棘手的示例\n### 在执行(避免捕获)替换之前，需要alpha转换(绑定变量的重命名)\n### 答案λz. f (λy. f (g y) y) (g y)是錯誤的\n### 因為λy. f ..y..中的y和g y中的y不是一個相同的的y)\n(λx. λz. f (λy. f x y) x) (g y)  =  (λx. λz. f (λt. f x t) x) (g y)  =  λz. f (λt. f (g y) t) (g y)\n```\n\n### Conversion and Equivalences(轉換和相等關係)\n\n#### Alpha(α)等價\n\n![](img/img06.png)\n\nAlpha等价是一种属性（当使用命名的活页夹时），更改活页夹上以及整个表达式主体中的变量不应更改整个表达式的基本含义。 因此，例如，以下是等效的字母。\n`Alpha`等價是一種屬性(當使用`named binders`命名綁定器時),更改綁定器上以及整個表達式主體中的變量不應該更個整個表達式的基本含義，因此，如下是`Alpha`等價:\n\n![](img/img07.png)\n\n##### Beta-reduction歸約(β)\n\n`Beta`歸約僅是一個簡單的替換步驟，即在整個表達式主體中用`lambda`的參數替換由`lambda`表達式綁定的變量。\n\n![](img/img08.png)\n\n\n#### Eta-reduction歸約(η)\n\n![](img/img09.png)\n\n這可以通過如下事實證明，如果我們把兩邊都應用到一個`term`(項)上,一個`Beta`歸約的步驟會把左邊變成右邊。\n\n![](img/img10.png)\n\n\n#### Eta-expansion(展開)\n\n與`Eta-reduction`相反的是`eta-expansion`,它採用一個不飽和的函數並使所有變量顯式綁定在`lambda`中，當我們討論翻譯成`STG`時，`Eta-expansion`將會很重要。\n\n### Reduction\n`λ`演算表達式的評估通過`Beta-reduction`進行。`lambda`中綁定的變量將在`lambda`的主體中替換。\n\n在設計空間中，關於如何做到這一點，以及表達式的計算順序，有幾個自由度。\n例如，我們可以在`lambda`下求值，然後將變量代入其中，或者取而代之的是對參數求值，然後替換並減少`lambda`表達式。\n有關更多信息，我們將在評估模型部分中進行討論。\n```haskell\nUntyped> (\\x.x) 1\n1\n\nUntyped> (\\x y . y) 1 2\n2\n\nUntyped> (\\x y z. x z (y z)) (\\x y . x) (\\x y . x)\n  => \\x y z . (x z (y z))\n  => \\y z . ((\\x y . x) z (y z))\n    => \\x y . x\n    => \\y . z\n   => z\n => \\z . z\n\\z . z\n```\n請注意，最後一次評估是我們先前遇到的`SKK`。\n\n在無類型的`lambda`演算中，我們可以自由的表示無限發散的表達式:\n```haskell\nUntyped> \\f . (f (\\x . (f x x)) (\\x . (f x x)))\n\\f . (f (\\x . (f x x)) (\\x . (f x x)))\n\nUntyped> (\\f . (\\x. (f x x)) (\\x. (f x x))) (\\f x . f f)\n...\n\nUntyped> (\\x. x x) (\\x. x x)\n...\n```\n### Let\n除了`App`以外，通常將稱為`Let`綁定的構造器添加到`lambda`演算語法中。在無類型的`lambda`演算中，`let`綁定在語義上等同於應用的`lambda`表達式。\n```haskell\n𝚕𝚎𝚝 a = e 𝚒𝚗 b   :=   (λa.b)e\n```\n在我們的語言中，我們將像在`Haskell`中一樣編寫`let`語句。\n`Toplevel`表達式將被編寫為`let`語句，沒有一個主體來表示它們被添加到全局範圍。\n`Haskell`語言不使用這個約定，但是`Ocaml`和`StandardML`使用這個約定。在`Haskell`中，对于`toplevel`声明，前面的`let`被简单地省略。\n```haskell\nlet S f g x = f x (g x);\nlet K x y = x;\nlet I x = x;\n\nlet skk = S K K;\n```\n目前，`let`的評估規則與所應用的`lambda`相同.\n![](img/img11.png)\n在後來的`lambda`演算變體中，表達式將具有不同的語義，並且將於應用的`lambda`表達式不同。關於這一點的更多信息將在`Hindley-Milner`推理部分中進行討論。\n\n### Everything Can Be a λ term(一切都可以成为λ项)\n**0**\n\n**1**\n\n**2**\n\n**succ**\n\n**pred**\n\n**not**\n\n**and**\n\n**or**\n\n**add**\n\n**mul**\n\n### Recursion(遞歸)\n可能最著名的組合器是`Curry`的`Y`組合器，在無類型的`λ`演算中，`Y`可用於允許表達式包含對自身的引用，以及`reduce`(歸約/減少)對自身的引用，從而允許遞歸和循環邏輯。\n`Y`組合器是許多所謂的定點組合器之一。\n![](img/img12.png)\n\n`Y`在給定`R`的情況下非常特殊，它返回`R`的固定點。\n\n![](img/img13.png)\n\n例如，階乘函數可以根據自身對定點的重複應用來遞歸定義，直到基本情況為0!。\n\n![](img/img14.png)\n\n處於樂趣，可以證明`Y`組合器可以用`S`和`K`組合器來表示。\n![](img/img15.png)\n\n在沒有顯式定點或遞歸`let`綁定的無類型`lambda`演算語言中，`Y`組合器可以僅使用`lambda`表達式創建這兩個結構。\n但是，更常見的是在術語語法中僅添加原子定點運算符或遞歸`let`作為基本構造。\n![](img/img16.png)\n\n`fix`具有評估規則:\n\n![](img/img17.png)\n\n與`fixpoint`(定點)(或`Y`組合器)一起，我們可以創建`let`綁定，這些綁定在綁定表達式的主體內包含對自身的引用。我們將這些遞歸`let`綁定稱為`ML`方言中的`let rec`.\n目前，我們將實現遞歸`let`作為簡單的語法糖，並通過以下等效性將定點包裹在`lambda`綁定周圍。\n```haskell\nlet rec x = e1 in e2    =    let x = fix (\\x. e1) in e2\n```\n因此，現在我們可以寫下每個函數式程序員最喜歡的兩個函數:`factorial`(階乘)和`fibonacci`(斐波那契)。\n\n為了顯示兩種風格樣式，一種使用`let rec`編寫，另一種使用顯式`fix`編寫。\n```haskell\nlet fact = fix (\\fact -> \\n ->\n  if (n == 0)\n    then 1\n    else (n * (fact (n-1))));\n\n\nlet rec fib n =\n  if (n == 0)\n  then 0\n  else if (n==1)\n  then 1\n  else ((fib (n-1)) + (fib (n-2)));\n```\n\n#### Omega Combinator\n我們將測試的一個重要的退化案例是`omega`組合器，該組合器對其自身應用了一個參數。\n```haskell\nω = λx.xx\n```\n當我們將`ω`組合器應用與自身時，我們發現這會導致無限長的重複`reductions`鏈.\n\n沒有正常形式的`reductions`序列被稱為`diverge`(發散)\n\n![](img/img18.png)\n\n我們將此表達式稱為`Ω`組合器。它是`λ`演算中的規範循環`term`(項)。\n相當多的靜態類型系統會拒絕使用這個術語，因此它是一個非常有用的測試工具。\n\n![](img/img19.png)\n\n### Pretty Printing\n`Hackage`提供了許多漂亮的打印庫，這些庫簡化了為我們的數據類型轉儲文本形式的過程。儘管庫之間存在一些差異，但大多數庫都使用同一組組合器。我們將使用`Hackage`上的`pretty`包中的`Text.PrettyPrint`模塊。我們大多數漂亮的打印都是不可避免的樣板，但是會使內部狀態的調適更加容易。\n\n```haskell\n\t    Combinators\n<>\t    Concatenation\n<+>\t    Spaced concatenation\nchar\tRenders a character as a Doc\ntext\tRenders a string as a Doc\nhsep\tHorizontally concatenates a list of Doc\nvcat\tVertically joins a list of Doc with newlines\n```\n漂亮打印的核心類型是`Doc`類型，即文檔的抽象類型。這種類型的組合器將操縱此文檔的內部結構，然後最終使用`render`函數將其內部化為物理字符串。由於我們打算在多種類型之間進行漂亮打印，因此我們將創建一個漂亮類型類。\n```haskell\nmodule Pretty where\n\nimport Text.PrettyPrint\n\nclass Pretty p where\n  ppr :: Int -> p -> Doc\n\n  pp :: p -> Doc\n  pp = ppr 0\n```\n首先，我們創建兩個輔助函數來折疊我們的`lambda`綁定，以便我們可以將它們打印為單個的`lambda`表達式。\n```haskell\nviewVars :: Expr -> [Name]\nviewVars (Lam n a) = n : viewVars a\nviewVars _ = []\n\nviewBody :: Expr -> Expr\nviewBody (Lam _ a) = viewBody a\nviewBody x = x\n```\n然後，我們創建一個用於對子表達式加括號的輔助函數。\n```haskell\nparensIf ::  Bool -> Doc -> Doc\nparensIf True = parens\nparensIf False = id\n```\n最後，我們定義`ppr`，變量`p`將指示我們在當前正在打印的結構中的深度。並允許我們進行不同的打印，以在必要時將其與周圍環境進行區分。\n```haskell\ninstance Pretty Expr where\n  ppr p e = case e of\n    Lit (LInt a)  -> text (show a)\n    Lit (LBool b) -> text (show b)\n    Var x   -> text x\n    App a b -> parensIf (p>0) $ (ppr (p+1) a) <+> (ppr p b)\n    Lam x a -> parensIf (p>0) $\n         char '\\\\'\n      <> hsep (fmap pp (viewVars e))\n      <+> \"->\"\n      <+> ppr (p+1) (viewBody e)\n\nppexpr :: Expr -> String\nppexpr = render . ppr 0\n```","tags":["Write-Haskell"]},{"title":"Hindley-Milner推论","url":"/blog/2019/09/18/Hindley-Milner推论/","content":"\n> [http://dev.stephendiehl.com/fun/006_hindley_milner.html]\n### HM类型系统\n辛德雷-米尔纳类型系统(也称为`Damas-Hindley-Milner`或`HM`)是一组类型系统,它们承认有一个可处理的算法可以从非类型化语法确定类型,这是一个偶然的特性。\n这是通过一个称为`unification`(统一)的过程来实现的,在这个过程中,一个结构良好的程序的类型会产生一组约束,当解决这些约束时,总是有一个惟一的主体类型。\n\n最简单的`Hindley Milner`类型系统由一组非常短的规则定义。\n前四个规则描述了我们可以如何判断将每个句法结构(`Lam`，`App`，`Var`，`Let`)映射到它们的预期类型,我们很快就会详细阐述这些规则。\n![](img/HM0.png)\n米尔纳的观察是,因为类型规则映射到唯一的语法,我们实际上可以向后运行类型规则,每当我们没有子表达式的已知类型时,我们通过在其位置放置一个新变量,\n收集关于其后续类型判断引起的使用限制来进行\"猜测\".\n这是ML族语言中类型推断的本质,通过生成和解决一种统一(`unification`)问题,我们可以从语法中唯一地重构类型,算法本身很大程度上只是统一求解器的结构化使用.\n然而,完整的类型推断使我们有点束缚,因为虽然推理问题在这种简单的语言和简单的扩展中是易处理的,但几乎所有对语言的重要补充都会破坏在没有注释的情况下推断类型的能力,\n或者使推理算法严重复杂化.然而,`Hindley-Milner`家族在设计领域代表了一个非常有用,富有成效的\"甜蜜点\".\n\n### 语法\n我们的第一种类型推断语言的语法实际上将是我们的无类型`lambda`演算的扩展,包括`fixpoint`运算符,`booleans`,`integers`,`let`和一些基本的算术运算.\n```haskell\ntype Name = String\n\ndata Expr\n  = Var Name\n  | App Expr Expr\n  | Lam Name Expr\n  | Let Name Expr Expr\n  | Lit Lit\n  | If Expr Expr Expr\n  | Fix Expr\n  | Op Binop Expr Expr\n  deriving (Show, Eq, Ord)\n\ndata Lit\n  = LInt Integer\n  | LBool Bool\n  deriving (Show, Eq, Ord)\n\ndata Binop = Add | Sub | Mul | Eql\n  deriving (Eq, Ord, Show)\n\ndata Program = Program [Decl] Expr deriving Eq\n\ntype Decl = (String, Expr)\n```\n`parser`是微不足道的,唯一的补充是`toplevel` `let`声明(`Decl`),它们被加入到全局程序中,\n所有顶级声明都必须以分号结束,尽管它们可以跨越多行并且忽略空格.例如:\n```haskell\n-- SKI combinators\nlet I x = x;\nlet K x y = x;\nlet S f g x = f x (g x);\n```\n和之前一样,`let rec`表达式将根据`fixpoint`运算符展开,只是语法糖.\n\n### 多态性\n我们将向我们的语言添加一个额外的构造,它将允许我们的语言具有一种新的多态性形式.\n多态性是一个术语的属性,它允许同一函数实现同时使用几种不同的类型.\n例如,`identity`函数的多态签名实例映射一个`α`类型的输入:\n\n![](img/HM01.png)\n现在不必为每种可能的类型重复函数(即实现`idInt`,`idBool`...)\n我们的类型系统允许包含在多态类型签名中的任何实例.\n![](img/HM02.png)\n普遍量化的一个相当显著的事实是,关于一类的`inhabitants`(類型的實例的統稱)的许多属性是由构造保证的,这些就是所谓的`free`定理.\n例如,任何`(a, b) -> a`类型的(`nonpathological`)实现必须等同于`fst`.\n一个稍微不那么简单的例子是`fmap`函数的类型`Functor f =>（a -> b）-> f a -> f b`\n第二个`functor`法律要求:\n```haskell\nforall f g. fmap f . fmap g = fmap (f . g)\n```\n但是,我们不可能为`fmap`编写一个(`nonpathological`)函数,该函数具有所需的类型,但没有此属性.我们得到`free`定理!\n\n### 类型\n我们将使用的类型语言从用于类型化`lambda`演算的简单类型系统开始.\n```haskell\nnewtype TVar = TV String\n  deriving (Show, Eq, Ord)\n\ndata Type\n  = TVar TVar\n  | TCon String\n  | TArr Type Type\n  deriving (Show, Eq, Ord)\n\ntypeInt, typeBool :: Type\ntypeInt  = TCon \"Int\"\ntypeBool = TCon \"Bool\"\n```\n`Type schemes``model polymorphic types`(样板多态类型)，它们表示量词中绑定的类型变量在封闭的类型中是多态的，可以用与签名一致的任何类型实例化。直观地说明了该函数的实现:\n```haskell\ndata Scheme = Forall [TVar] Type\n```\n`Type schemes`(类型模式)将在我们的输入规则中写为`σ`.\n![](img/HM03.png)\n例如:`id`和`const`函数将会有以下类型:\n![](img/HM04.png)\n我们现在将我们的类型划分为两个句法类别,单型和多型.\n在我们简单的初始语言中,`type schemes`(类型模式)将始终是`top level`(顶级)签名的表示,即使没有多态类型变量.\n在实现术语中,这意味着在推断后从我们的`Infer monad`中产生单型时,\n`we will immediately generalize it at the toplevel \"closing over\" all free type variables in a type scheme.`\n(我们将立即在类型模式的顶层\"关闭所有\"自由类型变量中归纳它)\n\n### 上下文\n```haskell\nnewtype TypeEnv = TypeEnv (Map.Map Var Scheme)\n```\n两个主要操作是扩展和限定,它从上下文中引入或删除命名数量.\n![](img/HM05.png)\n对上下文的操作只是对底层`map`上的常用`Set`操作.\n```haskell\nextend :: TypeEnv -> (Var, Scheme) -> TypeEnv\nextend (TypeEnv env) (x, s) = TypeEnv $ Map.insert x s env\n```\n### Inference Monad(推理)\n我们所有的类型推断逻辑都将存在于`Infer monad`中,它是`ExcpetT`+`State`的`monad`变换器堆栈.允许各种错误报告并有状态地保存新名称.\n```haskell\ntype Infer a = ExceptT TypeError (State Unique) a\n```\n在`monad`中运行逻辑会导致类型错误或结果类型模式.\n```haskell\nrunInfer :: Infer (Subst, Type) -> Either TypeError Scheme\nrunInfer m = case evalState (runExceptT m) initUnique of\n  Left err  -> Left err\n  Right res -> Right $ closeOver res\n```\n### Substitution(替换)\n查询表达式的自由变量和对表达式应用替换,这两个操作将执行相当多的操作.\n![](img/HM06.png)\n相同的模式适用于类型级别的类型变量.\n![](img/HM07.png)\n表达式上的替换将替换应用于局部变量，如果匹配，则替换指定的子表达式。在名称捕获的情况下，将引入一个新的变量。\n![](img/HM08.png)\n同样，替换也可以应用于类型环境之上的元素。\n![](img/HM09.png)\n我们在`Haskell`中的替换实现只是从类型变量到类型的`Map`.\n```haskell\ntype Subst = Map.Map TVar Type\n```\n替换的组合(`s1 ∘ s2`, `s1 compose s2`)可以简单地编码为基础`Map`上的操作,重要的是要注意,在我们的实现中,我们选择了替换为`left-biased`,取决于推理算法的实现,以确保在替换之间不发生冲突.\n```haskell\nnullSubst :: Subst\nnullSubst = Map.empty\n\ncompose :: Subst -> Subst -> Subst\ns1 `compose` s2 = Map.map (apply s1) s2 `Map.union` s1\n```\n\n`Haskell`中的实现是通过`Substitutable`类型类的一系列实现来公开一个`apply`函数,该函数应用在 指定类型变量的 类型结构上 给出的替换.\n```haskell\nclass Substitutable a where\n  apply :: Subst -> a -> a\n  ftv   :: a -> Set.Set TVar\n\ninstance Substitutable Type where\n  apply _ (TCon a)       = TCon a\n  apply s t@(TVar a)     = Map.findWithDefault t a s\n  apply s (t1 `TArr` t2) = apply s t1 `TArr` apply s t2\n\n  ftv TCon{}         = Set.empty\n  ftv (TVar a)       = Set.singleton a\n  ftv (t1 `TArr` t2) = ftv t1 `Set.union` ftv t2\n\ninstance Substitutable Scheme where\n  apply s (Forall as t)   = Forall as $ apply s' t\n                            where s' = foldr Map.delete s as\n  ftv (Forall as t) = ftv t `Set.difference` Set.fromList as\n\ninstance Substitutable a => Substitutable [a] where\n  apply = fmap . apply\n  ftv   = foldr (Set.union . ftv) Set.empty\n\ninstance Substitutable TypeEnv where\n  apply s (TypeEnv env) =  TypeEnv $ Map.map (apply s) env\n  ftv (TypeEnv env) = ftv $ Map.elems env\n```\n在整个类型规则和替换中,我们需要新的名称.在这个天真的版本中,我们将简单地使用无限的字符串列表,并按照我们在`状态monad`中保存的索引切入列表的第`n`个元素,这是最简单的实现,稍后我们将使这种名称生成技术更加健壮.\n```haskell\nletters :: [String]\nletters = [1..] >>= flip replicateM ['a'..'z']\n\nfresh :: Infer Type\nfresh = do\n  s <- get\n  put s{count = count s + 1}\n  return $ TVar $ TV (letters !! count s)\n```\n创建新变量对于实施推理规则至关重要。 每当我们在某个表达式中遇到第一次使用变量时，我们将创建一个新的类型变量。\n\n### Unification(统一)\n推理思想的核心是统一的概念,两个表达式`e1`和`e2`的统一符是替换`s`,使得:\n![](img/HM10.png)\n如果在它们之间存在统一的替换集合，则认为两个术语是统一的。 如果替换的应用与所应用的顺序无关，即如果我们总是以相同的正常形式到达而不管所选择的替换顺序如何，则称替换集是汇合的。\n我们将采用这种表示法:\n```haskell\nτ ∼ τ′:s\n```\n事实上`τ,τ'`这两种类型是可以通过一个替换`s`进行统一的,这样:\n```haskell\n[s]τ = [s]τ′\n```\n两个相同的项可以用空的统一器轻松地统一:\n```haskell\nc ∼ c : [ ]\n```\n我们的小HM语言的统一规则如下:\n![](img/HM11.png)\n如果我们想要将类型变量`α`与类型`τ`统一起来,我们通常可以用类型替换变量: `[α/τ]`.但是,我们的规则规定了一个前提条件,称为该统一的发生检查: 类型变量`α`不得在`τ`中自由出现.如果确实如此.则替换将不是统一.\n例如,统一`α`和`α → β`的问题.\n替换`s` = `[α/α → β]`不统一: 我们得到\n```haskell\n[s]α = α → β\n-- 和\n[s]α → β = (α → β) → β\n```\n实际上,无论我们尝试什么替代,`[s]α → β`总是比`[s]α`长,所以不存在统一者,唯一的机会是用无限类型替换: `[α/(...((α → β) → β)→ ⋯ → β) → β]`将是一个统一者，但我们的语言没有这样的类型。\n如果由于发生检查(`occurs check`)而统一失败,我们说统一将给出无限类型。\n请注意,如果我们尝试类型检查`omega`组合器`λx.xx`，那么统一`α → β`和`α`正是我们必须要做的,所以它被发生检查(`occurs check`)排除了，\n正如我们在覆盖无类型`lambda`演算时所讨论的其他`pathological`术语一样.\n```haskell\noccursCheck ::  Substitutable a => TVar -> a -> Bool\noccursCheck a t = a `Set.member` ftv t\n```\n`unify`函数存在于`Infer monad`中并产生替换:\n```haskell\nunify ::  Type -> Type -> Infer Subst\nunify (l `TArr` r) (l' `TArr` r')  = do\n    s1 <- unify l l'\n    s2 <- unify (apply s1 r) (apply s1 r')\n    return (s2 `compose` s1)\n\nunify (TVar a) t = bind a t\nunify t (TVar a) = bind a t\nunify (TCon a) (TCon b) | a == b = return nullSubst\nunify t1 t2 = throwError $ UnificationFail t1 t2\n\nbind ::  TVar -> Type -> Infer Subst\nbind a t | t == TVar a     = return nullSubst\n         | occursCheck a t = throwError $ InfiniteType a t\n         | otherwise       = return $ Map.singleton a t\n```\n\n### Generalization and Instantiation (泛化和实例化)\n`Hindley-Milner`的核心是两个基本操作:\n`Generalization`泛化: 通过关闭类型方案中的所有自由类型变量,将`τ`类型转换为`σ`类型。\n`Instantiation`实例化: 通过为当前类型环境中未出现的每个类型变量创建新名称,将`σ`类型转换为`τ`类型。\n![](img/HM12.png)\n(`T-Inst`)规则中的`⊑`运算符表示类型是类型模式(`type scheme`)的实例.\n![](img/HM13.png)\n`⊑`符号右边的类型`τ1`是左边类型模式(`σ = 左边`)的实例化,如果对于所有的`β ∈ 𝚏𝚝𝚟(σ)`存在一个替换`[s]β = β`,则` τ1 = [s]τ2`,看例子:\n\n```haskell\n∀a.a → a ⊑ 𝙸𝚗𝚝 → 𝙸𝚗𝚝\n∀a.a → a ⊑ b → b\n∀ab.a → b → a ⊑ 𝙸𝚗𝚝 → 𝙱𝚘𝚘𝚕 → 𝙸𝚗𝚝\n```\n这些映射非常直观地映射到简单地操作`Haskell Set`变量对象和新名称供应的代码:\n```haskell\ninstantiate ::  Scheme -> Infer Type\ninstantiate (Forall as t) = do\n  as' <- mapM (const fresh) as\n  let s = Map.fromList $ zip as as'\n  return $ apply s t\n\ngeneralize :: TypeEnv -> Type -> Scheme\ngeneralize env t  = Forall as t\n    where as = Set.toList $ ftv t `Set.difference` ftv env\n```\n按照约定,`let`绑定被尽可能地一般化(`generalized`).\n因此,在下面的定义中,`f`在绑定的主体上进行了一般化,以便在每次调用`f`时,都用新的类型变量实例化它.\n```haskell\nPoly> let f = (\\x -> x) in let g = (f True) in f 3\n3 : Int\n```\n在这个表达式中,`f`的类型在`let`定义中生成,并将使用两个不同的签名实例化.\n在f的调用位置,它将与`Int`相统一,另一个与`Bool`相统一。\n相反,在`lambda`中绑定`f`将导致类型错误.\n```haskell\nPoly> (\\f -> let g = (f True) in (f 3)) (\\x -> x)\nCannot unify types: \n    Bool\nwith \n    Int\n```\n这是`let generalization(一般化)`的本质.\n\n### Typing Rules (类型规则)\n最后,在所有类型机制到位后,我们可以写下我们简单的小多态`lambda`演算的类型规则.\n```haskell\ninfer :: TypeEnv -> Expr -> Infer (Subst, Type)\n```\n`infer`将局部类型环境和活动表达式映射到部分统一解决方案和中间类型的2元组.通过在每个部分推断的子表达式和局部环境中应用来自统一的部分替换,自下而上遍历`AST`并且在每个递归级别处求解约束,如果遇到错误,则会在`Infer monad`中调用`throwError`,并报告错误:\n```haskell\ninfer :: TypeEnv -> Expr -> Infer (Subst, Type)\ninfer env ex = case ex of\n\n  Var x -> lookupEnv env x\n\n  Lam x e -> do\n    tv <- fresh\n    let env' = env `extend` (x, Forall [] tv)\n    (s1, t1) <- infer env' e\n    return (s1, apply s1 tv `TArr` t1)\n\n  App e1 e2 -> do\n    tv <- fresh\n    (s1, t1) <- infer env e1\n    (s2, t2) <- infer (apply s1 env) e2\n    s3       <- unify (apply s2 t1) (TArr t2 tv)\n    return (s3 `compose` s2 `compose` s1, apply s3 tv)\n\n  Let x e1 e2 -> do\n    (s1, t1) <- infer env e1\n    let env' = apply s1 env\n        t'   = generalize env' t1\n    (s2, t2) <- infer (env' `extend` (x, t')) e2\n    return (s1 `compose` s2, t2)\n\n  If cond tr fl -> do\n    (s1, t1) <- infer env cond\n    (s2, t2) <- infer env tr\n    (s3, t3) <- infer env fl\n    s4 <- unify t1 typeBool\n    s5 <- unify t2 t3\n    return (s5 `compose` s4 `compose` s3 `compose` s2 `compose` s1, apply s5 t2)\n\n  Fix e1 -> do\n    (s1, t) <- infer env e1\n    tv <- fresh\n    s2 <- unify (TArr tv tv) t\n    return (s2, apply s1 tv)\n\n  Op op e1 e2 -> do\n    (s1, t1) <- infer env e1\n    (s2, t2) <- infer env e2\n    tv <- fresh\n    s3 <- unify (TArr t1 (TArr t2 tv)) (ops Map.! op)\n    return (s1 `compose` s2 `compose` s3, apply s3 tv)\n\n  Lit (LInt _)  -> return (nullSubst, typeInt)\n  Lit (LBool _) -> return (nullSubst, typeBool)\n```\n让我们浏览每个规则派生，看看它如何转换为代码:\n#### T-Var\nT-Var规则，只需从`typing`变换上下文中提取变量的类型即可.\n```haskell\nVar x -> lookupEnv env x\n```\n函数`lookupVar`在`typing`环境中查找局部变量引用,如果找到它,则实例化一个新副本.\n```haskell\nlookupEnv :: TypeEnv -> Var -> Infer (Subst, Type)\nlookupEnv (TypeEnv env) x = do\n  case Map.lookup x env of\n    Nothing -> throwError $ UnboundVariable (show x)\n    Just s  -> do t <- instantiate s\n                  return (nullSubst, t)\n```\n![](img/HM14.png)\n\t\n#### T-Lam\n对于`lambdas`,由`lambda`绑定的变量本地作用于`typing`环境,然后使用此作用域推断表达式的主体.\n输出类型是一个新类型变量,并与生成的推断类型统一.\n```haskell\nLam x e -> do\n    tv <- fresh\n    let env' = env `extend` (x, Forall [] tv)\n    (s1, t1) <- infer env' e\n    return (s1, apply s1 tv `TArr` t1)\n```\n![](img/HM15.png)\n\n\n#### T-App\n对于应用程序,第一个参数必须是`lambda`表达式或返回`lambda`表达式,因此要知道它必须是`t1 -> t2`的形式,但除了两个值的汇合外,不确定输出类型。\n我们推断两种类型,\n将第一个参数中的约束应用于第二推断类型的结果,然后使用整个应用程序表达式的例外形式(`excepted form`)统一这两个类型。\n```\nApp e1 e2 -> do\n    tv <- fresh\n    (s1, t1) <- infer env e1\n    (s2, t2) <- infer (apply s1 env) e2\n    s3       <- unify (apply s2 t1) (TArr t2 tv)\n    return (s3 `compose` s2 `compose` s1, apply s3 tv)\n```\n![](img/HM16.png)\n\n#### T-Let\n如前所述,`let`将会`generalized`(一般化),因此我们将为`let`表达式的主体创建一个本地`typing`类型化环境,并添加一般化推断类型的`let`绑定值到主体的`typing`环境中.\n```haskell\n Let x e1 e2 -> do\n    (s1, t1) <- infer env e1\n    let env' = apply s1 env\n        t'   = generalize env' t1\n    (s2, t2) <- infer (env' `extend` (x, t')) e2\n    return (s1 `compose` s2, t2)\n```\n![](img/HM17.png)\n\n#### T-BinOp\n有几个内建操作,我们到目前为止还没有提到,因为类型规则很简单,我们只需统一这个操作的预设置类型签名.\n```haskell\nOp op e1 e2 -> do\n    (s1, t1) <- infer env e1\n    (s2, t2) <- infer env e2\n    tv <- fresh\n    s3 <- unify (TArr t1 (TArr t2 tv)) (ops Map.! op)\n    return (s1 `compose` s2 `compose` s3, apply s3 tv)\n\nops :: Map.Map Binop Type\nops = Map.fromList [\n      (Add, (typeInt `TArr` (typeInt `TArr` typeInt)))\n    , (Mul, (typeInt `TArr` (typeInt `TArr` typeInt)))\n    , (Sub, (typeInt `TArr` (typeInt `TArr` typeInt)))\n    , (Eql, (typeInt `TArr` (typeInt `TArr` typeBool)))\n  ]\n```\n\n#### Literals\n`literal`整数和`boolean`类型的类型通常是它们各自的类型.\n```haskell\n(+) :: 𝙸𝚗𝚝 → 𝙸𝚗𝚝 → 𝙸𝚗𝚝\n(×) :: 𝙸𝚗𝚝 → 𝙸𝚗𝚝 → 𝙸𝚗𝚝\n(−) :: 𝙸𝚗𝚝 → 𝙸𝚗𝚝 → 𝙸𝚗𝚝\n(=) :: 𝙸𝚗𝚝 → 𝙸𝚗𝚝 → 𝙱𝚘𝚘𝚕\n```\n![](img/HM18.png)\n\n### Constraint Generation (约束生成)\n`Hindley Milner`的先前实现很简单,但具有混合两个独立过程的奇怪特性: `constraint solving`(约束求解器)和`traversal`(遍历).让我们讨论不执行此操作的推理算法的另一种实现.\n在约束生成方法中,约束是通过自下而上遍历生成的,添加到有序容器中,规范化,求解,然后可能在类型化AST上进行后置替换.这将是我们将从这里使用的方法,\n虽然与`on-line solver`之间存在等价,但使用单独的约束求解器变得更容易管理,因为我们的类型系统变得更复杂,我们开始构建语言.\n现在我们的推理`monad`变成了`RWST`(`Reader-Writer-State`转换器)+`Either`(处理类型错误).推理状态保持不变,只是提供新鲜的名称.\n```haskell\n-- | Inference monad\ntype Infer a = (RWST\n                  Env             -- Typing environment\n                  [Constraint]    -- Generated constraints\n                  InferState      -- Inference state\n                  (Except         -- Inference errors\n                    TypeError)\n                  a)              -- Result\n\n-- | Inference state\ndata InferState = InferState { count :: Int }\n```\n我们将只收集`Writer`中的`unifier`并使用`uni`函数发出它们,而不是在每个遍历级别统一类型变量.\n```haskell\n-- | Unify two types\nuni :: Type -> Type -> Infer ()\nuni t1 t2 = tell [(t1, t2)]\n```\n由于`typing`输入环境存储在`Reader monad`中,我们可以使用`local`来为`typing`环境创建一个本地范围的附加组件.这对于`typing`绑定器很方便.\n```haskell\n-- | Extend type environment\ninEnv :: (Name, Scheme) -> Infer a -> Infer a\ninEnv (x, sc) m = do\n  let scope e = (remove e x) `extend` (x, sc)\n  local scope m\n```\n\n### Typing\n这些类型规则是相同的,只是现在我们可以用一种不需要线程处理太多状态的更少噪音的方式来编写它们.\n所有的细节都被隐藏起来,并被编码在特定的组合器中,以一种让我们专注于领域逻辑的方式操纵我们的`Infer monad`的状态。\n```haskell\ninfer :: Expr -> Infer Type\ninfer expr = case expr of\n  Lit (LInt _)  -> return $ typeInt\n  Lit (LBool _) -> return $ typeBool\n\n  Var x -> lookupEnv x\n\n  Lam x e -> do\n    tv <- fresh\n    t <- inEnv (x, Forall [] tv) (infer e)\n    return (tv `TArr` t)\n\n  App e1 e2 -> do\n    t1 <- infer e1\n    t2 <- infer e2\n    tv <- fresh\n    uni t1 (t2 `TArr` tv)\n    return tv\n\n  Let x e1 e2 -> do\n    env <- ask\n    t1 <- infer e1\n    let sc = generalize env t1\n    t2 <- inEnv (x, sc) (infer e2)\n    return t2\n\n  Fix e1 -> do\n    t1 <- infer e1\n    tv <- fresh\n    uni (tv `TArr` tv) t1\n    return tv\n\n  Op op e1 e2 -> do\n    t1 <- infer e1\n    t2 <- infer e2\n    tv <- fresh\n    let u1 = t1 `TArr` (t2 `TArr` tv)\n        u2 = ops Map.! op\n    uni u1 u2\n    return tv\n\n  If cond tr fl -> do\n    t1 <- infer cond\n    t2 <- infer tr\n    t3 <- infer fl\n    uni t1 typeBool\n    uni t2 t3\n    return t2\n```\n\n### Constraint Solver (约束解决器)\n`Infer monad`的`Writer`层包含从推理传递发出的生成的约束集.\n一旦推断完成,我们就会得到一个结果类型签名,其中包含无意义的唯一新变量和一组约束,我们必须解决这些约束以将类型细化为其主要类型.\n约束由一个单独的`Solve monad`解决,该`monad`包含`Unifier`(最常见的统一)解决方案,当应用于生成的签名时,它将产生解决方案.\n```haskell\ntype Constraint = (Type, Type)\n\ntype Unifier = (Subst, [Constraint])\n\n-- | Constraint solver monad\ntype Solve a = StateT Unifier (ExceptT TypeError Identity) a\n```\n\n统一逻辑也与以前相同,除了它现在脱离推理独立编写,并将其部分状态存储在`Solve monad`的状态层内.\n```haskell\nunifies :: Type -> Type -> Solve Unifier\nunifies t1 t2 | t1 == t2 = return emptyUnifer\nunifies (TVar v) t = v `bind` t\nunifies t (TVar v) = v `bind` t\nunifies (TArr t1 t2) (TArr t3 t4) = unifyMany [t1, t2] [t3, t4]\nunifies t1 t2 = throwError $ UnificationFail t1 t2\n\nunifyMany :: [Type] -> [Type] -> Solve Unifier\nunifyMany [] [] = return emptyUnifer\nunifyMany (t1 : ts1) (t2 : ts2) =\n  do (su1,cs1) <- unifies t1 t2\n     (su2,cs2) <- unifyMany (apply su1 ts1) (apply su1 ts2)\n     return (su2 `compose` su1, cs1 ++ cs2)\nunifyMany t1 t2 = throwError $ UnificationMismatch t1 t2\n```\n```\nThe solver function simply iterates over the set of constraints, composing them and applying the resulting constraint solution over the intermediate solution eventually converting on the most general unifier which yields the final substitution which when applied over the inferred type signature, yields the principal type solution for the expression.\n```\n求解器函数简单地迭代约束集,组合它们并将结果约束解决方案应用于中间解决方案,最终转换为最通用的统一,产生最终替换,当应用于推断类型签名时,为表达式产生主要类型解决方案.\n\n```haskell\n-- Unification solver\nsolver :: Solve Subst\nsolver = do\n  (su, cs) <- get\n  case cs of\n    [] -> return su\n    ((t1, t2): cs0) -> do\n      (su1, cs1)  <- unifies t1 t2\n      put (su1 `compose` su, cs1 ++ (apply su1 cs0))\n      solver\n```\n这是一个更加优雅的解决方案，而不是在同一个传递中混合推理和求解，并且很好地适应了我们将在后面的章节中讨论的类型化核心形式的生成。\n\n\n\n### Worked Examples\n让我们来看两个推理如何适用于简单函数的例子.\n#### 例子1\n考虑:\n```haskell\n\\x y z -> x + y + z\n```\n`infer`函数生成的类型只包含每个参数和返回类型的新变量.\n```haskell\na -> b -> c -> e\n```\n当我们遍历两个加法运算时，发出由T-BinOp引起的约束.\n```haskell\n1. a -> b -> d ~ Int -> Int -> Int\n2. d -> c -> e ~ Int -> Int -> Int\n```\n这里`d`是中间项`x + y`的类型.通过应用`Uni-Arrow`,我们可以推导出以下一组替换.\n```haskell\n1. a ~ Int\n2. b ~ Int\n3. c ~ Int\n4. d ~ Int\n5. e ~ Int\n```\n将此解决方案替换回类型会产生推断类型:\n```haskell\nInt -> Int -> Int -> Int\n```\n\n#### 例子2\n```haskell\ncompose f g x = f (g x)\n```\n推断函数生成的类型仅包含唯一的新变量.\n```haskell\na -> b -> c -> e\n```\n由两个T-App规则引起的我们得到以下约束:\n```haskell\n1. b ~ c -> d\n2. a ~ d -> e\n```\n这里`d`是`(g x)`的类型,约束已经是规范形式,通过应用`Uni-VarLeft`两次,我们得到以下一组替换:\n```haskell\n1. b ~ c -> d\n2. a ~ d -> e\n```\n所以我们得到这种类型:\n```haskell\ncompose :: forall c d e. (d -> e) -> (c -> d) -> c -> e\n```\n如果需要，我们可以按字母顺序重命名变量以获得:\n```haskell\ncompose :: forall a b c. (a -> b) -> (c -> a) -> c -> b\n```\n\n### Interpreter\n我们的求值程序将直接在语法上运行，并将结果计算为`Value`类型.\n```haskell\ndata Value\n  = VInt Integer\n  | VBool Bool\n  | VClosure String Expr TermEnv\n```\n解释器设置为`Identity monad`,后面它将成为一个更复杂的`monad`,但现在它很简单.值(`value`)环境将显式地线程化,并且每当创建闭包时,我们只需在闭包中存储本地环境的副本.\n```haskell\ntype TermEnv = Map.Map String Value\ntype Interpreter t = Identity t\n```\n我们的计算逻辑是上一章实现的lambda演算求值器的扩展.\n然而，您可能会注意到在整个评估过程中使用了许多不完整的模式.\n不过不要害怕,我们的程序评估不会\"出错\".\n这些模式中的每一个都代表了我们的类型系统保证永远不会发生的一种状态.\n例如，如果我们的程序没有在作用域中引用每个变量,那么它将永远不会达到开始时的求值,并且将在类型检查器中被拒绝,我们在这里使用不完整的模式在道义上是正确的!\t\n```haskell\neval :: TermEnv -> Expr -> Interpreter Value\neval env expr = case expr of\n  Lit (LInt k)  -> return $ VInt k\n  Lit (LBool k) -> return $ VBool k\n\n  Var x -> do\n    let Just v = Map.lookup x env\n    return v\n\n  Op op a b -> do\n    VInt a' <- eval env a\n    VInt b' <- eval env b\n    return $ (binop op) a' b'\n\n  Lam x body -> \n    return (VClosure x body env)\n\n  App fun arg -> do\n    VClosure x body clo <- eval env fun\n    argv <- eval env arg\n    let nenv = Map.insert x argv clo\n    eval nenv body\n\n  Let x e body -> do\n    e' <- eval env e\n    let nenv = Map.insert x e' env\n    eval nenv body\n\n  If cond tr fl -> do\n    VBool br <- eval env cond\n    if br == True\n    then eval env tr\n    else eval env fl\n\n  Fix e -> do\n    eval env (App e (Fix e))\n\nbinop :: Binop -> Integer -> Integer -> Value\nbinop Add a b = VInt $ a + b\nbinop Mul a b = VInt $ a * b\nbinop Sub a b = VInt $ a - b\nbinop Eql a b = VBool $ a == b\n```\n\n\n### Interactive Shell\n我们的语言现在已经成长为我们之前使用过的小型`shell`,现在我们需要更强大的东西来保持我们的交互式解释器的逻辑.\n```haskell\ndata IState = IState\n  { tyctx :: TypeEnv  -- Type environment\n  , tmctx :: TermEnv  -- Value environment\n  }\n\ninitState :: IState\ninitState = IState emptyTyenv emptyTmenv\n\ntype Repl a = HaskelineT (StateT IState IO) a\n\nhoistErr :: Show e => Either e a -> Repl a\nhoistErr (Right val) = return val\nhoistErr (Left err) = do\n  liftIO $ print err\n  abort\n```\n我们的语言可以由`GHC`编译成独立的二进制文件:\n```haskell\n$ ghc --make Main.hs -o poly\n$ ./poly\nPoly>\n```\n在我们程序的顶部，我们将查看命令选项并允许三种命令变体:\n```haskell\n$ poly                # launch shell\n$ poly input.ml       # launch shell with 'input.ml' loaded\n$ poly test input.ml  # dump test for 'input.ml' to stdout\n```\n```haskell\nmain :: IO ()\nmain = do\n  args <- getArgs\n  case args of\n    []      -> shell (return ())\n    [fname] -> shell (load [fname])\n    [\"test\", fname] -> shell (load [fname] >> browse [] >> quit ())\n    _ -> putStrLn \"invalid arguments\"\n```\n`shell`命令需要一个`pre`动作,该动作在`shell`启动之前运行,逻辑简单地将我们的`Repl monad`评估为`IO`并从`main`函数运行它.\n```haskell\nshell :: Repl a -> IO ()\nshell pre\n  = flip evalStateT initState\n  $ evalRepl \"Poly> \" cmd options completer pre\n```\n`cmd`驱动程序是我们程序的主要入口点,每次用户输入一行输入时都会执行它,第一个参数是用户输入行.\n```haskell\ncmd :: String -> Repl ()\ncmd source = exec True (L.pack source)\n```\n然后，我们的语言的核心是`exec`函数，它导入所有编译器传递的信息，然后按顺序线程化输入和输出，最终生成一个结果类型环境和程序的评估结果。它们被`monoidally`连接到解释器的状态中，然后循环产生下一组输入.\n```haskell\nexec :: Bool -> L.Text -> Repl ()\nexec update source = do\n  -- Get the current interpreter state\n  st <- get\n\n  -- Parser ( returns AST )\n  mod <- hoistErr $ parseModule \"<stdin>\" source\n\n  -- Type Inference ( returns Typing Environment )\n  tyctx' <- hoistErr $ inferTop (tyctx st) mod\n\n  -- Create the new environment\n  let st' = st { tmctx = foldl' evalDef (tmctx st) mod\n               , tyctx = tyctx' <> (tyctx st)\n               }\n\n  -- Update the interpreter state\n  when update (put st')\n```\n`Repline`还支持添加特定的套接字输入集，以便将它们映射到编译器中的内置命令。我们将实现其中三个。\n```haskell\nCommand\tAction\n:browse\t\tBrowse the type signatures for a program\n:load <file>\tLoad a program from file\n:type\t\tShow the type of an expression\n:quit\t\tExit interpreter\n```\n它们的实现大多很简单。\n```haskell\noptions :: [(String, [String] -> Repl ())]\noptions = [\n    (\"load\"   , load)\n  , (\"browse\" , browse)\n  , (\"quit\"   , quit)\n  , (\"type\"   , Main.typeof)\n  ]\n\n-- :browse command\nbrowse :: [String] -> Repl ()\nbrowse _ = do\n  st <- get\n  liftIO $ mapM_ putStrLn $ ppenv (tyctx st)\n\n-- :load command\nload :: [String] -> Repl ()\nload args = do\n  contents <- liftIO $ L.readFile (unwords args)\n  exec True contents\n\n-- :type command\ntypeof :: [String] -> Repl ()\ntypeof args = do\n  st <- get\n  let arg = unwords args\n  case Infer.typeof (tyctx st) arg of\n    Just val -> liftIO $ putStrLn $ ppsignature (arg, val)\n    Nothing -> exec False (L.pack arg)\n\n-- :quit command\nquit :: a -> Repl ()\nquit _ = liftIO $ exitSuccess\n```\n最后，`shell`的`tab`补全将使用解释器的类型环境`key`在一组本地定义的变量上完成。`Repline`支持基于前缀的`tab`完成，其中将使用当前命令的前缀来确定要执行哪些`tab`完成。\n在我们以`command:load`开头的情况下，我们将直接在当前工作的文件名上`tab`完成。\n```haskell\ncompleter :: CompleterStyle (StateT IState IO)\ncompleter = Prefix (wordCompleter comp) defaultMatcher\n\n-- Prefix tab completer\ndefaultMatcher :: MonadIO m => [(String, CompletionFunc m)]\ndefaultMatcher = [\n    (\":load\"  , fileCompleter)\n  ]\n\n-- Default tab completer\ncomp :: (Monad m, MonadState IState m) => WordCompleter m\ncomp n = do\n  let cmds = [\":load\", \":browse\", \":quit\", \":type\"]\n  TypeEnv ctx <- gets tyctx\n  let defs = Map.keys ctx\n  return $ filter (isPrefixOf n) (cmds ++ defs)\n```\n\n### Observations (意见)\n我们有它，我们的第一个小型推断语言！\n通过运行`ghci Main.hs`加载`poly`解释器并调用`main`函数。\n```haskell\n$ ghci Main.hs\nλ: main\nPoly> :load test.ml\nPoly> :browse\n```\n通过在程序的`toplevel`声明一些函数来尝试一些简单的例子。我们可以使用`:type`命令以交互方式查询表达式的类型，该命令实际上只是在管道中途运行表达式并在类型检查后停止。\n```haskell\nPoly> let id x = x\nPoly> let const x y = x\nPoly> let twice x = x + x\n\nPoly> :type id\nid : forall a. a -> a\n\nPoly> :type const\nconst : forall a b. a -> b -> a\n\nPoly> :type twice\ntwice : Int -> Int\n```\n注意几个重要的事实。\n我们的类型检查器现在将在解释之前将我们的拒绝程序与范围错误相关联。\n```haskell\nPoly> \\x -> y\nNot in scope: \"y\"\n```\n此外，那些类型不太好的程序现在也会被直接拒绝.\n```haskell\nPoly> 1 + True\nCannot unify types: \n    Bool\nwith \n    Int\n```\n`omega`组合子将无法通过`occurs`检查:\n```haskell\nPoly> \\x -> x x\nCannot construct the the infinite type: a = a -> b\n```\n`test.ml`文件提供了对小解释器的各种测试. 例如,`fact`和`fib`函数都使用`fixpoint`来计算`Fibonacci`数或阶乘。\n```haskell\nlet fact = fix (\\fact -> \\n -> \n  if (n == 0) \n    then 1 \n    else (n * (fact (n-1))));\n\nlet rec fib n = \n  if (n == 0) \n    then 0\n    else if (n==1) \n      then 1\n      else ((fib (n-1)) + (fib (n-2)));\nPoly> :type fact\nfact : Int -> Int\n\nPoly> fact 5\n120\n\nPoly> fib 16\n610\n```\n\n\n\n","tags":["HM"]},{"title":"Haskell的自动化测试工具-QuickCheck","url":"/blog/2019/08/07/Haskell的自动化测试工具-QuickCheck/","content":"> [原文地址](http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html)\n### QuickCheck是什么\n`QuickCheck`是一种自动测试`Haskell`程序的工具。程序员以`函数应满足哪些属性`的形式提供程序的规范，然后，`QuickCheck`测试这些属性是否存在于大量随机生成的案例中。\n规范在`Haskell`中使用`QuickCheck`库中定义的组合器来表示。`QuickCheck`提供组合器来定义属性，观察测试数据的分布，并定义测试数据生成器。\n\n### 一个简单的例子\n一个简单的属性定义示例是：\n```haskell\nprop_RevRev xs = reverse (reverse xs) == xs\n  where types = xs::[Int]\n```\n要检查该属性，我们需要将此定义加载到`hugs`中，然后调用:\n```haskell\nMain> quickCheck prop_RevRev\nOK, passed 100 tests.\n```\n当属性失败时，`QuickCheck`会显示出一个反例。例如，如果我们定义:\n```haskell\nprop_RevId xs = reverse xs == xs\n  where types = xs::[Int]\n```\n然后检查它的结果:\n```haskell\nMain> quickCheck prop_RevId\nFalsifiable, after 1 tests:\n[-3,15]\n```\n\n### 使用QuickCheck\n要使用`QuickCheck`，您必须下载模块`QuickCheck.hs`，最好还是脚本`quickCheck`。将模块`QuickCheck`导入到包含规范或测试数据生成器的每个模块中。然后，您可以通过将定义的模块加载到`hugs`中并调用它来测试属性:\n```haskell\nquickCheck <property-name>\n```\n或者通过运行脚本:\n```haskell\n> quickCheck <options> <file names>\n```\n它检查给定模块中定义的每个属性。您可以使用与`hugs`相同的命令行选项。\n你不需要使用`hugs`来检查属性: 任何`Haskell 98`实现都应该足够了。但是, `quickCheck`脚本假定您的系统上安装了`hugs`。您可能需要编辑脚本以插入`runhugs`的位置。\n\n#### 如何判断正在测试哪个属性？\n某些版本的`hugs`在评估之前会显示要评估的表达式; 因此，您可以随时查看正在检查的属性，以及哪个属性失败。如果您的拥抱版本没有这样做，请给`quickCheck`提供`+names`标识:\n```haskell\n  > quickCheck + names <options> <file names>\n```\n这样它在检查之前将打印每个属性名称。\n\n#### 如果测试循环或遇到错误，我该怎么办？\n在这种情况下，我们知道该属性不成立，但是`quickCheck`没有显示反例。我们为这种情况提供了另一种测试功能。使用以下命令进行重复测试:\n```haskell\n  verboseCheck <property-name>\n```\n在运行测试之前显示每个测试用例：显示的最后一个测试用例是出现循环或错误的测试用例。\n\n### 属性\n属性表示为`Haskell`函数定义，名称以`prop_`开头。属性通过其参数进行普遍量化，因此:\n```haskell\nprop_RevRev xs = reverse (reverse xs) == xs\n  where types = xs :: [Int]\n```\n表示所有列表xs的等式成立(也就是说,所有有限的,总的列表)。\n属性必须具有单态类型。`多态`属性（例如上面的属性）必须限制为用于测试的特定类型。通过在陈述子句中声明一个或多个参数的类型是很方便的:\n```haskell\n  where types = (x1 :: t1, x2 :: t2, ...)\n```\n请注意，`types`不是关键字; 这只是一个本地声明，它提供了一个方便的地方来限制`x1,x2`等的类型。\n除非使用下面的其他组合器定义属性，否则属性的结果应为`Bool`类型。\n\n#### 条件属性\n属性可以采取如下形式:\n```haskell\n  <condition> ==> <property>\n```\n例如:\n```haskell\nordered xs = and (zipWith (<=) xs (drop 1 xs))\ninsert x xs = takeWhile (<x) xs++[x]++dropWhile (<x) xs\n\nprop_Insert x xs = ordered xs ==> ordered (insert x xs)\n  where types = x::Int\n```\n如果条件确实存在`==>`之后的属性，则此属性成立。\n测试丢弃不满足条件的测试用例。\n测试用例生成继续，直到找到满足条件的100个案例，或者直到达到测试用例数量的总体限制（如果条件永远不成立则避免循环）。\n在这种情况下，以下消息\n```haskell\nArguments exhausted after 97 tests.\n```\n表明满足该条件的97个测试用例被发现，并且该属性保留在这97个案例中。\n\n#### 量化属性\n属性可以采取如下形式:\n```haskell\nforAll <generator> $ \\<pattern> -> <property>\n```\n例如:\n```haskell\nprop_Insert2 x = forAll orderedList $ \\xs -> ordered (insert x xs)\n  where types = x::Int \n```\n`forAll`的第一个参数是测试数据生成器; 通过提供自定义生成器，而不是使用该类型的默认生成器，可以控制测试数据的分布。\n在示例中，通过为有序列表提供自定义生成器，而不是过滤掉未排序的测试用例，\n我们保证在不达到测试用例总体限制的情况下可以生成100个测试用例。\n下面的描述用于定义生成器的组合器。\n\n### 观察测试用例分布\n观察测试用例的分布是非常重要的：如果测试数据分布不均匀，那么从测试结果中得出的结论可能是无效的。特别是，`==>`运算符会严重扭曲测试数据的分布，因为只使用满足给定条件的测试数据。\n`QuickCheck`提供了几种观察测试数据分布的方法。制作观察的守则已纳入到属性声明中，\n每次实际测试该属性时，进行观察，然后在测试完成时汇总所收集的观察结果。\n\n#### 计算琐碎的案例\n属性可以采取如下形式:\n```haskell\n   <condition> `trivial` <property>\n```\n例如:\n```haskell\nprop_Insert x xs = ordered xs ==> null xs `trivial` ordered (insert x xs)\n  where types = x::Int\n```\n条件为True的测试用例被归类为琐碎的，并且报告了总数中的琐碎测试用例的比例。在这个例子中，测试产生\n```v\nMain> quickCheck prop_Insert\nOK, passed 100 tests (58% trivial).\n```\n#### 测试用例分类\n属性可以采取如下形式:\n```haskell\n  classify <condition> <string>$ <property>\n```\n例如:\n```haskell\nprop_Insert x xs = \n\tordered xs ==> \n\t\tclassify (ordered (x:xs)) \"at-head\"$\n \t\tclassify (ordered (xs++[x])) \"at-tail\"$\n\t\tordered (insert x xs)\n  where types = x::Int\n```\n满足条件的测试用例被赋予给定的分类，并且在测试之后报告分类的分布。 在这种情况下，结果是\n```haskell\nMain> quickCheck prop_Insert\nOK, passed 100 tests.\n58% at-head, at-tail.\n22% at-tail.\n4% at-head.\n```\n请注意，测试用例可能属于多个分类。\n\n#### 收集数据值\n属性可以采取如下形式:\n```haskell\ncollect <expression>$ <property>\n```\n例如:\n```haskell\nprop_Insert x xs = \n\tordered xs ==> collect (length xs)$\n\t\t       ordered (insert x xs)\n  where types = x::Int\n```\n在每个测试用例中评估`collect`的参数，并报告值的分布。此参数的类型必须位于`Show`类中。在上面的例子中，输出是:\n```haskell\nMain> quickCheck prop_Insert\nOK, passed 100 tests.\n58% 0.\n26% 1.\n13% 2.\n3% 3.\n```\n\n#### 合并观察\n这里描述的观察结果可以以任何方式组合。将每个测试用例的所有观察结合起来，并报告这些组合的分布。例如，测试属性:\n```haskell\nrop_Insert x xs = \n\tordered xs ==> \n\t\tcollect (length xs)$\n\t\tclassify (ordered (x:xs)) \"at-head\"$\n \t\tclassify (ordered (xs++[x])) \"at-tail\"$\n\t\tordered (insert x xs)\n  where types = x::Int\n```\n将会产生:\n```haskell\nMain> quickCheck prop_Insert\nOK, passed 100 tests.\n58% 0, at-head, at-tail.\n22% 1, at-tail.\n13% 2.\n4% 1, at-head.\n3% 3.\n```\n从中可以看出，列表头部或结尾的插入尚未针对长度多于一个元素的列表进行测试。\n\n### 测试数据生成器: 类型Gen\n测试数据由测试数据生成器生成。`QuickCheck`为大多数类型定义了默认生成器，但是你可以通过`forAll`使用自己的生成器，并且需要为你引入的任何新类型定义自己的生成器。\n生成器具有`Gen a`形式的类型; 这是`a`类型值的生成器。`Gen`类型是`monad`，因此`Haskell`的`do`语法和标准`monadic`函数可用于定义生成器。\n生成器建立在以下函数之上:\n```haskell\n   choose :: Random a => (a, a) -> Gen a\n```\n它可以从一个区间随机选择一个具有均匀分布的值。例如，要在列表的元素之间进行随机选择，请使用\n```haskell\ndo i<-choose (0,length xs-1)\n   return (xs!!i)\n```\n\n#### 在替代品之间选择\n生成器可以有如下形式:\n```haskell\n   oneof <list of generators>\n```\n在列表中的生成器之间以相同的概率选择。例如，\n```haskell\n   oneof [return True, return False]\n```\n生成一个随机布尔值，其值为`true`的概率为一半。\n我们可以使用以下控制结果分布的函数代替:\n```haskell\n   frequency :: [(Int, Gen a)] -> Gen a\n```\n`frequency`从列表中随机选择一个生成器，但是按给定因子加权选择每个备选方案的概率。例如，\n```haskell\n   frequency [(2,return True), (1,return False)]\n```\n将会有三分之二几率产生`True`.\n\n### 测试数据的大小\n测试数据生成器具有隐式大小参数; `quickCheck`从生成小测试用例开始，随着测试的进行逐渐增加大小。\n不同的测试数据生成器以不同的方式解释大小参数: 有些忽略它，而列表生成器，例如，将其解释为生成列表长度的上限。\n您可以随意使用它，因为您希望控制自己的测试数据生成器。\n您可以使用`size`参数获取它的值:\n```haskell\n  sized :: (Int -> Gen a) -> Gen a\n```\n`size g`调用`g`，将当前大小作为参数传递给它。例如，要生成`0`到`size`范围内的自然数，请使用\n```haskell\n  sized $ \\n -> choose (0, n)\n```\n大小控制的目的是确保测试用例足够大以显示错误，同时保持足够小以便快速测试。有时默认大小控件无法实现此目的。例如，在测试运行结束时，任意列表最多可包含50个元素，因此任意列表的列表最多可能有2500个，这对于高效测试来说太大了。在这种情况下，显式修改`size`参数会很有用。你可以用\n```haskell\n  resize :: Int -> Gen a -> Gen a\n```\n`resize n g`调用`size`参数为`n`的生成器`g`。`size`参数永远不应该是负数。例如，要生成随机矩阵，可能需要采用原始大小的平方根:\n```haskell\n  matrix = sized $ \\n -> resize (round (sqrt n)) arbitrary\n```\n#### 生成递归数据类型\n递归数据类型的生成器很容易使用`oneof`或`frequency`来表示构造函数和`Haskell`的标准`monadic`组合器，以便为每种情况形成生成器。\n例如，如果树的类型由以下类型定义:\n```haskell\ndata Tree = Leaf Int | Branch Tree Tre\n```\n那么一个树的生成器可能为如下这样:\n```haskell\ntree = oneof [liftM Leaf arbitrary,\n\t      liftM2 Branch tree tree]\n```\n但是，像这样的递归生成器可能无法终止或产生非常大的结果。为避免这种情况，递归生成器应始终使用大小控制机制。例如，\n```haskell\ntree = sized tree'\ntree' 0 = liftM Leaf arbitrary\ntree' n | n>0 = \n\toneof [liftM Leaf arbitrary,\n\t       liftM2 Branch subtree subtree]\n  where subtree = tree' (n `div` 2)\n```\n注意:\n* 我们通过在大小为零时强制结果为叶子来保证终止。\n* 我们在每次递归时将大小减半，以便大小给出树中节点数的上限。 我们可以自由地解释尺寸。\n* 我们在分支的两个分支之间共享子树生成器的事实当然不意味着我们在每种情况下生成相同的树。\n\n#### 有用的生成器组合器\n如果`g`是一个类型`t`的生成器,那么:\n* 两个`g`产生一对`tS`，\n* 3个`g`产生三倍的`tS`，\n* 4个`g`产生四倍的`tS`，\n* `vector n g`生成一个`n tS`列表。\n如果`xs`是列表，则元素`xs`生成`xs`的任意元素。\n\n### Arbitrary类\n`QuickCheck`使用`Haskell`的重载机制为每种类型定义默认测试数据生成器。这是使用该类完成的:\n```haskell\nclass Arbitrary a where\n  arbitrary   :: Gen a\n  coarbitrary :: a -> Gen b -> Gen b\n```\n`QuickCheck`为类型 `()`，`Bool`，`Int`，`Integer`，`Float`，`Double`，`pair`，`triples`，`quadruples`，`lists`和`functions`定义了实例。\n类方法`arbitrary`是类型`a`的默认生成器。\n你可以为任意其他类型声明一个默认生成器，通过声明一个`Arbitrary`类的实例，并实现`arbitrary`方法。\n\n类方法`coarbitrary`用于生成随机函数值：类型`a-> b`的`arbitrary`的实现对类型`a`使用`coarbitrary`。如果你只想生成`a`类型的随机值，你只需要为该类型定义方法`arbitrary`，而如果你想在类型上生成随机函数，那么你应该定义两个类方法。\n\n`coarbitrary`方法将类型`a`的值解释为生成器变换器。应对其进行定义，以便将不同的值解释为独立的生成器变压器。这些可以通过使用以下函数实现:\n```haskell\n  variant :: Int -> Gen a -> Gen a\n```\n对于不同的自然数`i`和`j`，`variant i g`和`variant j g`是独立的生成器变压器。\n`variant`的参数必须是非负的，为了提高效率，应该很小。\n`coarbitrary`的实例可以通过将由`variant`构造的生成器变换器组合在一起来定义。\n例如，如果`tree`的类型定义如下:\n```haskell\n  data Tree = Leaf Int | Branch Tree Tree\n```\n然后可以通过如下代码定义一个合适的`Arbitrary`实例:\n```haskell\ninstance Arbitrary Tree where\n  arbitrary = sized tree'\n    where tree' 0 = liftM Leaf arbitrary\n\t  tree' n | n>0 = \n\t\toneof [liftM Leaf arbitrary,\n\t          liftM2 Branch subtree subtree]\n  \t    where subtree = tree' (n `div` 2)\n  coarbitrary (Leaf n) = \n\tvariant 0 . coarbitrary n\n  coarbitrary (Branch t1 t2) = \n\tvariant 1 . coarbitrary t1 . coarbitrary t2\n```\n#### 函数的属性\n`QuickCheck`可以生成随机函数值，从而检查函数的属性。例如，我们可以检查函数组合的相关性如下:\n```haskell\nprop_ComposeAssoc f g h x =\n  ((f . g) . h) x == (f . (g . h)) x\n  where types = [f, g, h] :: [Int->Int]\n```\n但是，在我们测试这样的属性之前，我们必须确保可以打印函数值(如果找到了反例).也就是说，函数类型必须是`Show`类的实例。要实现这个，你必须将模块`ShowFunctions`导入到包含这种高阶属性的每个模块中。如果找到反例，则功能值将显示为`<function>`.\n\n### 提示: 使用newtype\n`QuickCheck`可以轻松地将测试数据生成器与每种类型相关联，但有时您需要不同的分发。例如，假设您正在测试一个操作语法树的程序，并使用变量的构造函数:\n```haskell\n data Expr = Var String | ...\n```\n尽管变量名称表示为字符串，但字符串的默认测试数据生成器不太可能为变量名称生成良好的分布。 例如，如果您正在生成随机表达式，您可能希望有时在测试数据中出现名称冲突，但是两个随机生成的字符串(例如`p}v(\\231\\156A`.)不太可能发生冲突。\n当然，您可以为变量名称编写自定义测试数据生成器，也可以从一个小集合中随机选择，并尝试记住在字符串扮演名称角色的任何地方使用它。但这很容易出错。更好的方法是定义一个名称的新类型，与`String`同构，并使您的自定义生成器成为它的默认值。例如:\n```haskell\nnewtype Name = Name String\n\ninstance Arbitrary Name where\n  arbitrary = oneof [\"a\", \"b\", \"c\", \"d\", \"e\"]\n```\n如果您小心使用`Name`类型，无论您的名字是什么，那么您的属性将更容易编写并且经常都是正确的！\n\n","tags":["QuickCheck"]},{"title":"英语语法学习笔记-名词短语与冠词","url":"/blog/2019/06/21/英语语法学习笔记-名词短语与冠词/","content":"\n### 名词短语结构\n\n### 什么时候不需要用限定词\n\n### 专有名词与补语位置\n\n\n\n","tags":["冠词"]},{"title":"英语语法学习笔记-补语","url":"/blog/2019/06/21/英语语法学习笔记-补语/","content":"### 5种单句基本句型\n```\n#主语 Subject\n#动词 Verb\n#宾语 Object\n#补语 Complemnt\n1. S + V\t\t(主语 + 动词)\n2. S + V + O\t\t(主语 + 动词 + 宾语)\n3. S + V + C\t\t(主语 + 动词 + 补语)\n4. S + V + O + O\t(主语 + 动词 + 宾语 + 宾语)\n5. S + V + O + C\t(主语 + 动词 + 宾语 + 补语)\n```\n\n### 及物动词/不及物动词\n一个完整的句子，必须能够表达完整的意思。这需要两部分来完成: 主语和动词。主语，是这个句子所描述的对象。动词，构成描述的主要内容。例如:\n```\n1. John Smith died in World War Two. (S + V)\n   (约翰史密斯死于第二次世界大战.)\n\n2. John Smith killed three enemy soldiers. (S + V + O)\n   (约翰史密斯杀死了三名敌军士兵.)\n```\n第1个例子中，主语为`John Smith`，表明这句话是要告诉你有关`John Smith`的事情，是什么事情呢？他死了(动词`died`表明叙述的主要内容)！至于他是死于第一次世界大战，还是第二次世界大战是可有可无的细节(以介词短语`in World War Two`来修饰)，因此，第1个例子写成`John Smith died`，也可以构造成完整，正确的句子。\n像`die`种动作，可以独立发生，不牵涉到别的人和物的动词，就称为`不及物`动词。而第2个例子中的`kill`动作，则必须发生在另一个对象身上，因为要做出`杀`的动作，就必须有一个`被杀`的东西，因此`kill`这种动词就是`及物`动词，它后面通常会有一个宾语来`接受`这个动作，在这个例子中，`three enemy soldiers`就是做为宾语。\n \n### be动词\n上一节例2中，如果省略掉宾语`three enemy soldiers`，主语+动词`John Smith killed`依旧可以表示为一个句子(虽然没有表达出完整的意思): 约翰史密斯杀了人，只不过没有具体表明杀了谁。\n而如果句子中省略了补语，就不能表达出完整的意思。\n在所有的英语动词中，不论是`及物`动词还是`不及物`动词，都要担任起`叙述全句最主要内容`的工作，只有解释为`是`的动词没有叙述能力(没有任何意义)，只能扮演`引导叙述/串联`的角色。例如: \n```\n3. John Smith was a soldier. (S + V + C)\n   (约翰史密斯是军人.)\n```\n在例3中，主语仍然是`John Smith`，但是动词`was`就和前面例子中的动词`die/kill`不一样了，因为`was`并没有告诉我们有关`John Smith`的任何事情，叙述主要内容的工作落在了后面的补语`a soldier`上，动词`was`在这里只是起到了`串联`的作用。\n\n### 不必翻译的动词: be动词\n```\n4. John Smith was courageous. (S + V + C)\n   (约翰史密斯很勇敢.)\n\n5. The soup is too hot. (S + V + C)\n   (汤太烫了.)\n```\n例4中的`was`和例5中的`is`更能说明: 解释为`是`的动词没有叙述能力，完全没有任何意义。\n因为在中文翻译中，`是`被完全去掉了，如果翻译成`汤是太汤了`就不像中文的说话口吻了。\n在英文中，`is`是动词不可以丢掉，但是它不像其他动词能叙述出主要内容，如果只说`John Smith was`，`The soup is`，那么这些句子通常都是错的，而且没有意义。因为动词`是`缺乏叙述能力。\n\n### 补语定义\n解释为`是`的动词，因为没有叙述能力，只能把主语和主语后面构成叙述的部分连接起来，所以它又称作`连缀动词(Linking Verb)`。跟在这种动词后面的部分，因为替代了动词所扮演的叙述角色，补足句子使之获得完整的意思，因此称作`补语(Complement)`。\n\n### 需要补语的动词有哪些?(S+V+C)\n`be动词`直接翻译为`是`，是最有代表性的`连缀动词`，在所有的英语动词中，凡是接补语的动词(`连缀动词`)都可以解释为各种各样的`是`:\n```\nlook\t看起来是\nseem\t似乎是\nappear\t显得是\nsound\t听起来是\nfeel\t摸起来是\ntaste\t尝起来是\nturn\t转变为\nprove\t证实为\nbecome\t成为\nmake\t做为\n```\n一个主语使用如上的任意动词，都不能构成一个有意义的完整句子，需要使用补语补足。例如:\n```\n1. That dress looks pretty. (S + V + C) \n   (那件裙子很好看)\n\n2. The dog seems friendly. \n   (那只狗看起来很友善)\n\n3. His demands appear reasonable. \n   (他的要求显得很合理)\n\n4. He became a teacher.\n   (他当了教师)\n\n5. A nurse makes a good wife. \n   (娶护士做太太真不错)\n```\n如果将以上例子中各式各样的`是`替换成纯粹的`是`(`be动词`)，句子的句型和语义都没有太大变化。这就是`S + V + C`的句型`(主语补语)`.\n\n### 宾语补语的句型(S+V+O+O)\n`主语+动词+补语(主语补语)`的句型是用补语告诉读者主语是什么，中间用表示为`是`的动词串联起来。\n`主语+动词+宾语+补语(宾语补语)`的句型则是用补语告诉读者宾语是什么，中间暗示有一个`是`的关系存在。例如:\n```\n1. I find the dress pretty. (S + V + O + C)\n   (我发现这衣服很漂亮)\n\n2. The meat made the dog friendly. \n   (肉让狗变得友善)\n\n3. They consider his demands reasonable. \n   (他们认为他的要求是合理的)\n   \n4. His college training made him a teacher. \n   (他的大学教育使他成为一名教师)\n\n5. Most people consider a nurse a good wife. \n   (大多数的人认为护士会是称职的太太)\n```\n例如第1个例子: 宾语`the dress`和补语`pretty`之间虽然没有`是`字，但是带有这种暗示存在。如果加个`be动词`进去就变成了上一节介绍的主语补语句子: `That dress is pretty`。\n其实这也是检验`S + V + O + C`句型最简便的方法: 把句子中的宾语和补语拿出来，中间加入`be动词`，看看能否变成`S + V + C`句型。\n\n### 补语的词类\n```\n1. John Smith was a soldier. (S + V + C)\n   (约翰史密斯是军人)\n2. The military academy made John Smith a soldier. (S + V + O + C) \n   (军校训练使约翰史密斯成为军人)\n\n3. John Smith was courageous. (S + V + C)\n   (约翰史密斯很勇敢)\n4. I consider John Smith courageous. (S + V + O + C)\n   (我认为约翰史密斯很勇敢)\n```\n补语的词类，应该是名称和形容词比较合理。\n因为主语或宾语都是名词，所以补语也可以为名词，然后经由动词`是`的连接来表达同等的关系。另外修饰名词的修饰语就是形容词，因此补语也可以为形容词。\n例1中`John Smith`为主语，`a soldier`为主语补语，词类都是名词。\n例2中`John Smith`为宾语，`a soldier`为宾语补语，但词类仍然为名词。\n例3中主语补语`courageus`为形容词，因而可以经由动词`是`的引导来修饰主语`John Smith`是怎样的人。\n例4中`courageus`为宾语补语，词类没有变化，仍然为形容词。\n\n### 没有补语的be动词(S+V)\n`be动词`是最纯粹的`连缀动词`，解释为`是`，后面应该要有补语句子才算完整。如果看到`be动词`后面没有补语，表示这个`be动词`并不是作为`连缀动词`来使用，此时，`be动词`并不解释为`是`，而是要解释为`存在`。用在最单纯的`主语+宾语`句型中。\n```\n1. I think;therefore I am. \n   (我思故我在)\n\n2. To be or not to be,that is the question. \n   (生存还是毁灭,这是个问题)\n```\n例1中，`I am`不可以翻译为`我是`，如果`am`作为`连缀动词`使用，后面必须有补语来说明`是什么`，在没有补语的情况下，`I am`就得翻译成`我存在`了。\n同理，例2中，`To be or not to be`应该翻译成`要存在还是不要存在`。\n\n### 有两个宾语的句型(S+V+O+O)\n有两个宾语的句型，即: `主语 + 动词 + 宾语 + 宾语`，需要和`主语 + 动词 + 宾语 + 补语`的句型区分开。后者的宾语和补语也可以都是名词，但宾语和补语之间存在`等于是`的关系。\n```\n1. John's father gave him a dog. (约翰的父亲给他一只狗)\n2. John's father called him a dog. (约翰的父亲骂他是狗)\n```\n例1中，`him`和`a dog`都是宾语，其中`him`是`gave`的对象，`a dog`是`gave`的东西，两个都是名词，且并不相等。\n例2中，`him`是宾语，`a dog`是补语，因为有`他是狗`的意思在，所以`a dog`是`him`的补语。\n\n### 练习\n请判断以下句子属于五种基本句型中的哪一种?\n```\n1. The magician moved his fingers quickly. (S + V + O)\n   (魔术师迅速移动他的手指.)\n\n2. The police found the letter missing. (S + V + O + C)\n   (警察发现那封信丢失了.)\n   \n3. The police found the missing letter. (S + V + O)\n   (警察找到了丢失的信.)\n\n4. He ordered himself a steak and a bottle of red wine. (S + V + O + O)\n   (他点了一份牛排和一瓶红酒.)\n\n5. Don't you like dancing? (S + V + O)\n   (你不喜欢跳舞么?)\n\n6. The President has gone abroad on a visit. (S + V)\n   (总统出国访问了.)(President/has gone)\n\n7. That sounds like a good idea. (S + V + C)\n   (听起来像是个好主意.)\n\n8. The box feels heavy. (S + V + C)\n   (盒子摸起来很重.)\n\n9. He told his guests a dirty joke at the party. (S + V + O + O)\n   (他在聚会上给客人讲了个下流的笑话.)\n\n10. The people elected Bill Clinton President. (S + V + O + C)\n    (人民选举比尔克林顿为总统.)\n\n11. The child asks her mother a million questions a day. (S + V + O + O)\n    (这个孩子每天问他妈妈一百万个问题.)\n\n12. Monkeys love bananas. (S + V + O)\n    (猴子喜欢香蕉.)\n\n13. You can leave the door open. (S + V + O + C)\n    (你可以把门开着.)\n\n14. The company has gone bankrupt. (S + V + C)\n    (这家公司已经破产了.)(company/has gone/bankrupt)\n\n15. Why don't you answer me? (S + V + O) \n    (为什么不回答我?)\n\n16. I consider you a member of the family. (S + V + O + C)\n    (我认为你是家庭的一员.)(I/consider/you/member)\n\n17. It never rains in California. (S + V)\n    (加利福尼亚从不下雨.)\n\n18. You'll look better with these designer glasses on. (S + V + C)\n    (你戴上这幅名牌眼睛会好看些.)\n\n19. I can see better without these reading glasses. (S + V)\n    (我不戴老花镜能看的更清楚些.)\n\n20. Do you call me liar? (S + V + O + C)\n    (你说我撒谎么?)\n```\n\n\n\n","tags":["补语"]},{"title":"深入理解Haskell-IO","url":"/blog/2019/05/29/深入理解Haskell-IO/","content":"> 本文翻译自[维基百科](https://wiki.haskell.org/IO_inside),想要看原文的可以去那里查看.\n\n### IO内部\nHaskell I/O一直是新Haskellers混乱和惊喜的根源。虽然Haskell中的简单I/O代码看起来非常类似于命令式语言中的等价物，但尝试编写更复杂的代码通常会导致完全混乱。这是因为Haskell I/O内部真的非常不同。Haskell是一种纯语言，甚至I/O系统也无法打破这种纯度。\n以下正文试图解释Haskell I/O实现的细节，这个解释应该可以帮助你最终掌握所有的智能I/O技巧。此外，我已经添加了您可能遇到的各种陷阱的详细说明。阅读本文后，您将获得\"Haskell I/O大师\"学位，该学位同等于计算机科学和数学学士学位。\n如果您是Haskell I/O新手，您可能更愿意从阅读[IO简介](https://wiki.haskell.org/Introduction_to_IO)开始\n\n#### Haskell是一门纯语言\nHaskell是一门纯语言，这意味着任何函数调用的结果完全由其参数决定，像C中的`rand()`或`getchar()`这样的伪函数在每次调用时都会返回不同的结果，这些函数根本不可能在Haskell中编写。而且，Haskell函数不能有副作用，这意味着这些函数不能对\"真实世界\"做任何更改，例如：更改文件/写入文件/打印/通过网络发送数据等。这两个限制一起意味着任何函数调用都可以被具有相同参数的先前调用的结果替换，并且语言保证所有这些重新排列不会改变程序结果!\n\n让我们将其与C语言进行比较: 优化C编译器尝试猜测哪些函数没有副作用，并且不依赖于可变全局变量。如果这个猜测错了，优化可以改变程序的语义！为了避免这种灾难，C优化器在猜测中是保守的，或者需要程序员提供有关函数纯度的提示。\n\n与优化的C编译器相比，Haskell编译器是一组纯数学转换。这导致更好的高级优化设施。此外，纯数学计算可以更容易地分成几个可以并行执行的线程，这在多核CPU的这些日子里越来越重要。最后，纯计算不易出错且更容易验证，这增加了Haskell的稳健性和使用Haskell的程序开发速度。Haskell纯度允许编译器只调用其结果确实需要计算高级函数的最终值的函数(例如: main) - 这称为惰性求值。纯粹的数学计算是件好事，但是I/O动作怎么样？函数如下:\n```haskell\nputStrLn \"Press any key to begin formatting\"\n```\n不能返回任何有意义的结果值，那么我们如何确保编译器不会省略或重新排序其执行？总的来说，我们如何使用完全惰性的语言处理有状态的算法和副作用？这个问题在18年的Haskell开发中提出了许多不同的解决方案(参见Haskell的历史)，尽管现在基于monads的解决方案已成为标准。\n\n#### monad是什么?\n什么是monad? 这是来自数学范畴理论的东西，我不知道了。为了理解monad如何用于解决I/O和副作用的问题，您不需要知道它。就像我一样，只知道小学数学就足够了。\n让我们想象一下，我们想在Haskell中实现众所周知的`getchar`函数。它应该有什么样的类型？我们试试吧：\n```haskell\ngetchar :: Char\n\nget2chars = [getchar,getchar]\n```\n只有`Char`类型的`getchar`函数会得到什么？您可以在`get2chars`的定义中看到所有可能出现的问题：\n* 因为Haskell编译器将所有函数视为纯函数(没有副作用)，所以它可以避免对`getchar`的\"过度\"调用, 并使用两次返回值.\n* 即使它确实进行了两次调用，也无法确定应首先执行哪个调用。你想按照阅读顺序或相反的顺序返回两个字符吗？`get2chars`定义中没有任何内容可以回答这个问题。\n\n从程序员的角度来看，如何解决这些问题呢？\n让我们为`getchar`函数增加一个\"伪装\"的参数，使每个调用与编译器的观点\"不同\":\n```haskell\ngetchar :: Int -> Char\n\nget2chars = [getchar 1, getchar 2]\n```\n马上，这解决了上面提到的第一个问题 - 现在编译器将进行两次调用，因为编译器将它们视为具有不同的参数。整个`get2chars`函数也应该有一个\"伪装\"参数，否则我们会遇到同样的问题：\n```haskell\ngetchar   :: Int -> Char\nget2chars :: Int -> String\n\nget2chars _ = [getchar 1, getchar 2]\n```\n现在我们需要给编译器一些线索来确定它应该首先调用哪个函数。Haskell语言没有提供任何表达评估顺序的方法......除了数据依赖性！如何添加一个人工数据依赖项，以防止在第一个`getchar`之前评估第二个`getchar`？为了实现这一目标，我们将从`getchar`函数返回一个额外的\"伪装\"结果，该\"伪装\"结果将用作下一个`getchar`函数调用的参数：\n```haskell\ngetchar :: Int -> (Char, Int)\n\nget2chars _ = [a,b]  where (a,i) = getchar 1\n                           (b,_) = getchar i\n```\n到目前为止还不错 - 现在我们可以保证在读`b`之前读取`a`，因为读`b`需要通过读`a`返回的值(`i`)!\n我们在`get2chars`中添加了一个\"伪装\"参数，但问题是Haskell编译器太聪明了! 它可以相信外部`getchar`函数真的依赖于它的参数，但是对于`get2chars`函数，它会看到我们是在作弊，因为我们扔掉了它(参数使用了_占位符)! 因此，编译器不会觉得有必要按照我们想要的顺序执行调用。我们该如何解决这个问题? 将这个\"虚假\"的参数传递给`getchar`函数怎么样?! 这样的话，编译器就无法猜测它是否真的未使用过。\n\n```haskell\nget2chars i0 = [a,b]  where (a,i1) = getchar i0\n                            (b,i2) = getchar i1\n```\n还有更多 - `get2chars`具有与`getchar`功能相同的纯度问题。\n如果需要调用`get2chars`两次，则需要一种方法来描述这些调用的顺序。看着：\n```Haskell\n-- order of 'get2chars' calls isn't defined 未定义'get2chars'调用的顺序\nget4chars = [get2chars 1, get2chars 2]  \n```\n我们已经知道如何处理这些问题 - `get2chars`函数也应该返回一些可以用来顺序调用的\"伪装\"值：\n```Haskell\nget2chars :: Int -> (String, Int)\n\nget4chars i0 = (a++b)  where (a,i1) = get2chars i0\n                             (b,i2) = get2chars i1\n```\n但是`get2chars`函数应该返回什么\"伪装\"值？如果我们使用一些整数常量，那么过于聪明的Haskell编译器会猜测我们想再次作弊。如何返回`getchar`函数返回的值？看：\n```Haskell\nget2chars :: Int -> (String, Int)\nget2chars i0 = ([a,b], i2)  where (a,i1) = getchar i0\n                                  (b,i2) = getchar i1\n```\n信不信由你，但我们刚刚已经构建了整个`monadic` Haskell I/O系统。\n\n#### 欢迎来到真实世界，宝贝\n警告：关于IO的以下故事是不正确的，因为它无法实际解释IO的一些重要方面（包括交互和并发）。但是，有些人发现开始理解是有用的。\nHaskell `main`函数具有以下类型:\n```Haskell\nmain :: RealWorld -> ((), RealWorld)\n```\n其中`RealWorld`是一种\"伪装\"的类型，用来替换我们的Int。\n这就像在接力赛中接过的接力棒。当`main`函数调用某些IO函数时，它将作为参数收到的\"RealWorld\"传递给了IO函数。所有IO函数都有类似的类型，涉及`RealWorld`作为参数和结果。确切地说，`IO`是以下列方式定义的类型同义词：\n```Haskell\ntype IO a  =  RealWorld -> (a, RealWorld)\n```\n因此，`main`函数只有类型`IO()`，`getChar`函数有类型`IO Char`,等等。您可以将`IO Char`类型视为\"获取当前的`RealWorld`，对其执行某些操作，并返回`Char`和（可能已更改的）`RealWorld`。让我们看`main`调用`getChar`两次：\n```Haskell\ngetChar :: RealWorld -> (Char, RealWorld)\n\nmain :: RealWorld -> ((), RealWorld)\nmain world0 = let (a, world1) = getChar world0\n                  (b, world2) = getChar world1\n              in ((), world2)\n```\n仔细看看：`main`函数将收到的`world0`传递给第一个`getChar`函数。 这个`getChar`函数返回一些`RealWorld`类型的新值，它将在下一次调用中使用。最后，`main`返回它从第二个`getChar`获得的`world2`。\n* 如果没有使用它读取的字符，这里是否可以省略任何`getChar`调用？不，因为我们需要返回第二个`getChar`结果的`world2`，这又需要从第一个`getChar`返回的`world1`。\n* 是否可以重新排序`getChar`调用？ 否：第二个`getChar`在第一个之前无法调用，因为它使用了第一次调用返回的`world1`.\n* 是否可以重复调用？ 在Haskell语义中 - 是的，但真正的编译器永远不会在这种简单的情况下重复工作（否则，生成的程序将没有任何速度保证）。\n\n正如我们已经说过的那样，RealWorld值被用作一个接力棒，它在严格的顺序中被`main`调用的所有例程之间传递。在每个例程中，RealWorld值以相同的方式使用。 总的来说，为了\"计算\"从`main`返回的`world`，我们应该直接或间接地执行从`main`调用的每个IO过程。这意味着插入链中的每个程序都将在我们打算调用它时执行(相对于其他IO操作)。让我们考虑以下程序：\n```Haskell\nmain = do a <- ask \"What is your name?\"\n          b <- ask \"How old are you?\"\n          return ()\n\nask s = do putStr s\n           readLn\n```\n现在你有足够的知识以低级别方式重写它，并检查每个应该执行的操作是否真的将使用它应该具有的参数并按照我们期望的顺序执行(练习)。\n但是条件执行呢？没问题。让我们定义众所周知的`when`操作：\n```Haskell\nwhen :: Bool -> IO () -> IO ()\nwhen condition action world =\n    if condition\n      then action world\n      else ((), world)\n```\n如您所见，我们可以根据数据值轻松地在执行链中包含或排除IO过程(操作)，如果在`when`的调用中`condition`为False，那么`action`将永远不会被调用，因为真实的Haskell编译器，从不调用其结果不用于最终结果的函数(例如: 这里main函数的`world`最终值)。循环和更复杂的控制结构可以以相同的方式实现。试试看吧！\n最后，你可能想要知道，在程序中传递这些RealWorld值需要花费的成本，它是免费的，这些\"伪装\"值仅在编译器分析和优化代码时存在，但是当它进入汇编代码生成时，它\"突然\"意识到这种类型就像`()`，因此所有的这些参数和结果值都可以从最终生成的代码中省略。这不漂亮吗？\n\n#### `>>=` 和 `do` 表示法\n所有初学者(包括我)都认为`do`是执行IO动作的魔术语句。那是错的,`do`只是语法糖，它简化了使用IO(以及其他monad的程序)的编写，但这超出了本教程的范围。`do`符号最终被转换为传递`world`值的语句，就像我们上面手动编写的那样，用于简化几个IO操作的粘合。您不需要只为一条语句使用`do`语句,例如:\n```Haskell\nmain = do putStr \"Hello!\"\n```\n脱糖后:\n```Haskell\nmain = putStr \"Hello!\"\n```\n让我们来看看如何在下面的例子中使用多个语句来解释`do`\n```Haskell\nmain = do putStr \"What is your name?\"\n          putStr \"How old are you?\"\n          putStr \"Nice day!\"\n```\n这里的`do`语句只是加入了应该按顺序执行的几个IO动作。它被翻译成一个所谓的\"绑定运算符\"的顺序应用程序，即`>>`：\n```Haskell\nmain = (putStr \"What is your name?\") >> ((putStr \"How old are you?\") >> (putStr \"Nice day!\"))\n```\n这个绑定操作符只是结合了两个IO动作，通过在它们之间传递`world`来顺序执行它们：\n```Haskell\n(>>) :: IO a -> IO b -> IO b\n(action1 >> action2) world0 =\n   let (a, world1) = action1 world0\n       (b, world2) = action2 world1\n   in (b, world2)\n```\n如果以这种方式定义运算符对您来说很奇怪，请按以下方式阅读此定义：\n```Haskell\naction1 >> action2 = action\n  where\n    action world0 = let (a, world1) = action1 world0\n                        (b, world2) = action2 world1\n                    in (b, world2)\n```\n现在，您可以在使用`>>`的位置替换其定义，并检查由`do`语法糖构造的程序实际上与我们通过手动操作`world`值编写的程序相同。\n\n更复杂的示例涉及使用`<-`绑定的变量：\n```Haskell\nmain = do \n   a <- readLn\n   print a\n```\n这段代码可以脱糖为:\n```Haskell\nmain = readLn >>= (\\a -> print a)\n```\n正如您应该记住的那样,`>>`绑定操作符默默地忽略其第一个`action`的值，仅将其第二个`action`的结果做为整体结果返回。\n另一方面,`>>=`绑定操作符(注意末尾的额外'=')允许我们使用其第一个`action`的结果, 并将其作为附加参数传递给第二个`action`,看看定义：\n```Haskell\n(>>=) :: IO a -> (a -> IO b) -> IO b\n(action1 >>= action2) world0 =\n   let (a, world1) = action1 world0\n       (b, world2) = action2 a world1\n   in (b, world2)\n```\n首先,第二个`action`的类型(更准确地说,是一个返回IO action的函数),即`a -> IO b`是什么意思? \n通过替换IO定义,我们得到`a -> RealWorld -> (b, RealWorld)`,这意味着第二个action实际上有两个参数: 实际在其中使用的类型`a`,以及用于IO action排序的`RealWorld`类型的值. \n情况总是如此,与您在其类型签名中看到的相比较,任何IO过程都另有一个参数,此参数隐藏在别名\"IO\"的定义中。\n其次,您可以使用`>>`和`>>=`这些操作来简化您的程序。例如,在上面的代码中我们不需要引入变量a,因为`readLn`的结果可以直接发送到`print`:\n```Haskell\nmain = readLn >>= print\n```\n第三,如你所见,符号：\n```Haskell\ndo x <- action1\n    action2\n```\n其中`action1`的类型为`IO a`,而`action2`的类型为`IO b`,转换为：\n```Haskell\naction1 >>= (\\x -> action2)\n```\n其中`>>=`的第二个参数的类型为`a -> IO b`,这就是处理`<-`绑定的方式: `<-`左侧的名称只是后续操作的一个参数,表示为一个大的IO action.\n另请注意,如果`action1`的类型为`IO a`,那么`x`将只有类型`a`; 您可以将`<-`的效果视为将`action1`的IO值\"解包\"为`x`.\n还要注意`<-`不是真正的运算符,它是纯语法,就像`do`本身一样,它的含义只取决于它被脱糖的方式.\n\n看下一个例子:\n```Haskell\nmain = do putStr \"What is your name?\"\n          a <- readLn\n          putStr \"How old are you?\"\n          b <- readLn\n          print (a,b)\n```\n这段代码可以脱糖为:\n```Haskell\nmain = putStr \"What is your name?\"\n       >> readLn\n       >>= \\a -> putStr \"How old are you?\"\n       >> readLn\n       >>= \\b -> print (a,b)\n```\n我在这里省略了括号,`>>`和`>>=`运算符都是左关联的,但是lambda绑定总是尽可能向右延伸,这意味着这里引入的`a`和`b`绑定对所有剩余的动作都有效.\n作为练习,自己添加括号并将此过程转换为显式传递`world`值的低级代码(练习),我认为这应该足以帮助您最终了解`do`转换和绑定操作符`>>=`的工作原理.\n\n不好,我忘记了第三个monadic运算符: `return`,它只是结合了它的两个参数: 传递的值和`world`:\n```Haskell\nreturn :: a -> IO a\nreturn a world0 = (a, world0)\n```\n转换一个简单的`return`用法示例怎么样？说，\n```Haskell\nmain = do a <- readLn\n          return (a*2)\n```\n具有命令式语言背景的程序员通常认为Haskell中的`return`与其他语言一样,会立即从IO过程返回.正如你在其定义中看到的那样(甚至只是从它的类型),这样的假设是完全错误的,\n使用`return`的唯一目的是将一些值(类型为'a')`lift`到整个动作的结果中(类型为`IO a`),因此它通常应该仅用作某个IO序列的最后执行语句,例如,尝试将以下过程转换为相应的低级代码(练习)：\n```Haskell\nmain = do a <- readLn\n          when (a>=0) $ do\n              return ()\n          print \"a is negative\"\n```\n并且您将意识到即使对于`a`的非负值,也会执行`print`语句. 如果需要从IO过程中间退出,可以使用`if`语句:\n```Haskell\nmain = do a <- readLn\n          if (a>=0)\n            then return ()\n            else print \"a is negative\"\n```\n而且，Haskell设计规则允许我们使用以下设计:\n```v\nmain = do a <- readLn\n          if (a>=0) then return ()\n            else do\n          print \"a is negative\"\n          ...\n```\n这可能有助于从冗长的`do`语句中逃脱。\n\n最后一个练习: 实现一个函数`liftM`.它将普通值的操作提升到monadic的操作,它的类型签名:\n```Haskell\nliftM :: (a -> b) -> (IO a -> IO b)\n```\n如果这对您来说太难了,请从以下高级定义开始并以低级方式重写它(练习):\n```Haskell\nliftM f action = do \n\t    x <- action\n            return (f x)\n```\n\n#### 可变数据(引用/数组/哈希表)\n正如您应该知道的,Haskell中的每个名称都绑定到一个固定(不可变)值,这大大简化了理解算法和代码优化,但在某些情况下这是不合适的,众所周知,有许多算法在可更新变量,数组等方面更容易实现.\n这意味着与变量关联的值(例如,在不同的执行点)可能不同,因此读取其值不能视为纯函数.想象一下,例如,以下代码:\n```Haskell\nmain = do let a0 = readVariable varA\n              _  = writeVariable varA 1\n              a1 = readVariable varA\n          print (a0, a1)\n```\n这看起来很奇怪吗? 首先,对`readVariable`的两次调用看起来是一样的,因此编译器可以只重用第一次调用返回的值. 其次,不使用`writeVariable`调用的结果,因此编译器可以(并且将会)完全省略此调用,为了完成描述,这三个调用可以按任何顺序重新排列,因为它们看起来彼此独立,这显然不是预期的. 解决方案是什么？你已经知道了, 使用IO actions, 使用IO actions可确保完成:\n* 按照书面形式的顺序执行\n* 每个action都必须执行\n* 相同action的结果将不会被重用(例如: `readVariable varA`)\n所以,上面的代码应该写成:\n```Haskell\nimport Data.IORef\nmain = do varA <- newIORef 0  -- Create and initialize a new variable\n          a0 <- readIORef varA\n          writeIORef varA 1\n          a1 <- readIORef varA\n          print (a0, a1)\n```\n这里,`varA`的类型为`IORef Int`,意思是\"IO monad中的一个变量(引用),持有一个类型为Int的值\",`newIORef`创建一个新变量(引用)并返回它,然后使用此引用进行读/写操作,`readIORef varA`操作返回的值不仅取决于所涉及的变量,还取决于执行此操作的时刻,因此它可以在每次调用时返回不同的值. 数组,散列表和任何其他_mutable_数据结构以相同的方式定义,对于每个数据结构,都有一个操作可以创建新的\"可变值\"并返回对它的引用,然后使用`IO monad`中的特殊读写操作,以下代码显示了使用可变数组的示例:\n```Haskell\nimport Data.Array.IO\nmain = do arr <- newArray (1,10) 37 :: IO (IOArray Int Int)\n          a <- readArray arr 1\n          writeArray arr 1 64\n          b <- readArray arr 1\n          print (a, b)\n```\n这里,创建了一个由10个元素组成的数组,其中37作为每个位置的初始值,接着将第一个元素(索引为1)的值读入变量`a`,然后将索引为1的元素的值设置为64,然后再次读入`b`,正如您通过执行此代码所看到的，`a`将设置为37,`b`将设置为64.\n\n其他依赖于状态的操作通常也实现为IO操作,例如,随机数生成器应在每次调用时返回不同的值。给它一个涉及IO的类型看起来很自然：\n```Haskell\nrand :: IO Int\n```\n另外,当你导入C例程时你应该小心,如果这个例程不纯,即它的结果取决于\"真实世界\"(文件系统，内存内容......),内部状态等等,你应该给它是一种IO类型,否则,编译器可以\"优化\"此程序(使用相同参数的程序)的重复调用.\n例如，我们可以为以下内容编写非IO类型：\n```\noreign import ccall\n   sin :: Double -> Double\n```\n因为`sin`的结果只取决于它的论点，但是:\n```Haskell\nforeign import ccall\n   tell :: Int -> IO Int\n```\n如果您将`tell`声明为纯函数(没有IO),那么您可以在每次调用时获得相同的位置.\n\n#### IO actions作为值\n到目前为止,您应该理解为什么在非IO(纯)程序中使用IO操作是不可能的,这样的程序只是没有得到\"接力棒\";他们不知道传递给IO action的任何`world`值,`RealWorld`类型是一种抽象数据类型,因此纯函数也不能自己构造`RealWorld`值,并且它是严格类型,因此也不能使用`undefined`,因此,禁止在纯过程中使用IO操作只是一种类型系统技巧(通常在Haskell中)。\n但是虽然纯代码不能_execute_ IO动作，\n它可以与任何其他功能值一起使用 - 它们可以存储在数据结构中,作为参数传递,作为结果返回,收集在列表中,并部分应用,但IO action仍然是一个功能值,因为我们不能将它应用于最后一个参数 - 类型为RealWorld。\n为了_execute_ IO动作,我们需要将它应用于一些RealWorld值,这只能在一些IO过程中,在其\"action链\"中完成。\n只有当这个过程被调用(作为\"为`main`函数计算world最终值\"过程的一部分时),才会真正执行此操作。\n看看这个例子:\n```Haskell\nmain world0 = let get2chars = getChar >> getChar\n                  ((), world1) = putStr \"Press two keys\" world0\n                  (answer, world2) = get2chars world1\n              in ((), world2)\n```\n这里我们首先将一个值绑定到`get2chars`,然后编写一个涉及`putStr`的绑定,但是执行顺序是什么？它不是由`let`绑定的顺序定义的,它是由处理`world`值的顺序定义的! \n您可以随意重新排序绑定语句,执行顺序将由关于传递的`world`值的数据依赖性定义,让我们看看`do`语法中的`main`是什么样的：\n```Haskell\nmain = do let get2chars = getChar >> getChar\n          putStr \"Press two keys\"\n          get2chars\n          return ()\n```\n正如您所看到的,我们已经消除了两个`let`绑定,只留下了一个定义`get2chars`的绑定,非`let`语句按照它们写入的确切顺序执行,因为如上所述它们将声明中的`world`值传递给声明(语句),因此,这个版本的函数更容易理解,因为我们不必在心理上弄清楚`world`值的数据依赖性.\n\n此外,像`get2chars`这样的IO action不能直接执行,因为它们是具有`RealWorld`参数的函数,要执行它们,我们需要提供`RealWorld`参数,即将它们插入到`main`链中,将它们放在从`main`执行的某些`do`序列中(直接在`main`函数中,或间接在从`main`调用的IO函数中).在完成之前,它们将保留(就像任何部分评估形式的函数),我们可以像使用任何其他函数一样使用IO操作 - 将它们绑定到名称(如上所述),将它们保存在数据结构中,将它们作为函数参数传递并将它们作为结果返回 - 直到你给他们魔法的`RealWorld`参数,他们才会被执行!\n\n##### 示例: IO actions列表\n让我们尝试定义IO actions列表:\n```Haskell\nioActions :: [IO ()]\nioActions = [\n              (print \"Hello!\"),\n              (putStr \"just kidding\"),\n              (getChar >> return ())\n            ]\n```\n我在每个action周围使用了额外的括号，尽管它们并不是真正需要的。如果您仍然无法相信这些操作不会立即执行，请回忆一下此列表的实际类型：\n```Haskell\nioActions :: [RealWorld -> ((), RealWorld)]\n```\n好吧，现在我们要执行其中一些操作。没问题，只需将它们插入`main`链：\n```Haskell\nmain = do head ioActions\n          ioActions !! 1\n          last ioActions\n```\n看起来很奇怪吧？实际上，您在`do`语句中编写的任何IO操作(或用作`>>` / `>>=`运算符的参数)都是一个表达式，为某些类型`a`返回类型`IO a`的结果。\n通常，您使用某些类型为`x -> y -> ... -> IO a`的函数,并提供所有`x,y`等参数。\n但是你并不局限于这个标准场景 - 不要忘记Haskell是一种函数式语言,你可以以任何可能的方式自由计算所需的函数值(回想一下`IO a`实际上是一种函数类型).\n\n这里我们刚从列表中提取了几个函数 - 没问题,正如我们在前面的例子中所做的那样,这个函数值也可以即时构建 - 这也没问题。\n想看到这个函数值作为参数传递？只要看看`when`的定义. 嘿,我们可以像任何其他函数值一样购买,出售和出租这些IO操作! 例如,让我们定义一个执行列表中所有IO actions的函数：\n```Haskell\nsequence_ :: [IO a] -> IO ()\nsequence_ [] = return ()\nsequence_ (x:xs) = do x\n               sequence_ xs\n```\n没有黑魔法 - 我们只是从列表中提取IO actions并将它们插入到一系列IO操作中，这些操作应该一个接一个地执行(按照它们在列表中的顺序)以\"计算整个`sequence_`调用的最终world值\"。\n在`sequence_`的帮助下，我们可以将最后一个`main`函数重写为：\n```Haskell\nmain = sequence_ ioActions\n```\n与任何其他（功能和非功能）值一样，Haskell使用IO操作的能力允许我们定义任意复杂度的控制结构。例如，尝试定义一个重复动作的控制结构，直到它返回`False`结果(练习)：\n```Haskell\nwhile :: IO Bool -> IO ()\nwhile action = ???\n```\n大多数编程语言根本不允许您定义控制结构，而那些允许的通常是需要您使用宏扩展系统的编程语言。在Haskell中，控制结构只是任何人都可以编写的简单函数。\n\n##### 例子: 返回一个IO actions作为结果\n如何通过函数返回IO操作? 好吧,我们每次定义IO过程时都会这样做 - 它们都返回需要执行RealWorld值的IO actions。虽然我们通常只是将它们作为更高级别IO过程的一部分来执行,但也可以在没有实际执行的情况下收集它们：\n```Haskell\nmain = do let a = sequence ioActions\n              b = when True getChar\n              c = getChar >> getChar\n          putStr \"These 'let' statements are not executed!\"\n```\n这些分配的IO过程可以用作其他过程的参数，或者写入全局变量，或者以其他方式处理，或者稍后执行，就像我们在`get2chars`示例中所做的那样。\n但是如何从IO过程返回参数化IO action呢？让我们定义一个过程，该过程从表示为句柄的文件返回第i个字节：\n```Haskell\nreadi h i = do hSeek h AbsoluteSeek i\n               hGetChar h\n```\n到现在为止还挺好。但是，如果一个程序返回具有给定名称的文件的第i个字节，而不是每次都重新打开它？\n```Haskell\nreadfilei :: String -> IO (Integer -> IO Char)\nreadfilei name = do h <- openFile name ReadMode\n                    return (readi h)\n```\n如您所见，这是一个IO过程，它打开一个文件并返回另一个将读取指定字节的IO过程。但我们可以更进一步，在`readfilei`中包含`readi`内容：\n```Haskell\nreadfilei name = do h <- openFile name ReadMode\n                    let readi h i = do hSeek h AbsoluteSeek i\n                                       hGetChar h\n                    return (readi h)\n```\n现在看起来更好了。但是，如果可以从当前定义`readi`的环境中获取作为`readi`参数的`h`，我们为什么要添加`h`? 更短的版本是这样的：\n```Haskell\nreadfilei name = do h <- openFile name ReadMode\n                    let readi i = do hSeek h AbsoluteSeek i\n                                     hGetChar h\n                    return readi\n```\n我们在这做了什么? 我们在`readfilei`中构建了一个涉及本地名称的参数化IO action，并将其作为结果返回。现在可以通过以下方式使用它：\n```Haskell\nmain = do myfile <- readfilei \"test\"\n          a <- myfile 0\n          b <- myfile 1\n          print (a,b)\n```\n这种使用IO操作的方式对于Haskell程序来说非常典型 - 您只需构造一个或多个所需的IO操作(带或不带参数),可能涉及\"构造函数\"接收的参数,并将它们返回给调用者。然后,这些IO操作可以在程序的其余部分中使用,而无需了解您的内部实现策略。可以使用的一件事是部分模拟OOP(或更确切地说ADT)编程范例。\n\n##### 示例：内存分配器生成器\n例如,我的一个程序有一个模块,它是一个内存子分配器。它接收大内存块的地址和大小,并返回两个过程 - 一个用于分配给定大小的子块,另一个用于释放分配的子块：\n```Haskell\nmemoryAllocator :: Ptr a -> Int -> IO (Int -> IO (Ptr b),\n                                       Ptr c -> IO ())\n\nmemoryAllocator buf size = do ......\n               let alloc size = do ...\n                                   ...\n                   free ptr = do ...\n                                 ...\n               return (alloc, free)\n```\n这是如何实现的？`alloc`和`free`函数使用在memoryAllocator过程中创建的引用。由于这些引用的创建是`memoryAllocator IO`操作链的一部分，因此将为每个调用memoryAllocator的内存块创建一组新的独立引用：\n```Haskell\nmemoryAllocator buf size = do start <- newIORef buf\n                 end <- newIORef (buf `plusPtr` size)\n                 ...\n```\n这两个引用是在`alloc`和`free`定义中读取和写入的(我们将为这个例子实现一个非常简单的内存分配器):\n```Haskell\n    let alloc size = do addr <- readIORef start\n                        writeIORef start (addr `plusPtr` size)\n                        return addr\n                        \n    let free ptr = do writeIORef start ptr\n```\n我们在这里定义的只是一对闭包,它们在定义时使用可用的状态。正如您所看到的,尽管Haskell缺乏对不纯函数的直接支持,但它与任何其他函数语言一样简单。\n以下示例使用memoryAllocator返回的过程在两个独立的内存缓冲区中同时分配/释放块：\n```Haskell\nmain = do buf1 <- mallocBytes (2^16)\n          buf2 <- mallocBytes (2^20)\n          (alloc1, free1) <- memoryAllocator buf1 (2^16)\n          (alloc2, free2) <- memoryAllocator buf2 (2^20)\n          ptr11 <- alloc1 100\n          ptr21 <- alloc2 1000\n          free1 ptr11\n          free2 ptr21\n          ptr12 <- alloc1 100\n          ptr22 <- alloc2 1000\n```\n##### 示例: 使用记录类型模拟OOP\n让我们实现经典的OOP示例：绘制图形。有不同类型的数字：圆形，矩形等。任务是创建一个异构的图列表。此列表中的所有图应支持相同的操作集：绘制`draw`，移动`move`等。我们将这些操作表示为IO过程。让我们定义一个包含所有所需过程的实现的结构，而不是`class`：\n```Haskell\ndata Figure = Figure { \n\tdraw :: IO (),\n        move :: Displacement -> IO ()\n}\n\ntype Displacement = (Int, Int)  -- horizontal and vertical displacement in points\n```\n每个图形类型的构造函数应该只返回一个Figure记录：\n```Haskell\ncircle    :: Point -> Radius -> IO Figure -- 圆 \nrectangle :: Point -> Point -> IO Figure  -- 矩形\n\ntype Point = (Int, Int)  -- 点坐标\ntype Radius = Int        -- 以圆为单位的圆半径\n```\n我们将通过打印当前参数来绘制`draw`图。让我们从`circle`和`rectangle`构造函数的简化实现开始，而不需要实际的`move`支持:\n```Haskell\ncircle center radius = do\n    let description = \"  Circle at \"++show center++\" with radius \"++show radius\n    return $ Figure { draw = putStrLn description }\n\nrectangle from to = do\n    let description = \"  Rectangle \"++show from++\"-\"++show to)\n    return $ Figure { draw = putStrLn description }\n```\n如您所见，每个构造函数只返回一个固定的绘图`draw`过程，该过程打印用于创建具体图形的参数。我们来测试一下：\n```Haskell\ndrawAll :: [Figure] -> IO ()\ndrawAll figures = do putStrLn \"Drawing figures:\"\n                     mapM_ draw figures\n\nmain = do figures <- sequence [circle (10,10) 5,\n                               circle (20,20) 3,\n                               rectangle (10,10) (20,20),\n                               rectangle (15,15) (40,40)]\n          drawAll figures\n```\n现在让我们定义可以实际移动的\"全功能full-featured\"图。为了实现这一点，我们应该为每个图形提供一个可变变量，用于保存每个图形的当前屏幕位置。该变量的类型为`IORef Point`。该变量应该在图构造函数中创建，并在图记录中包含的IO过程(闭包)中进行操作：\n```Haskell\ncircle center radius = do\n    centerVar <- newIORef center\n\n    let drawF = do center <- readIORef centerVar\n                   putStrLn (\"  Circle at \"++show center\n                             ++\" with radius \"++show radius)\n\n    let moveF (addX,addY) = do (x,y) <- readIORef centerVar\n                   writeIORef centerVar (x+addX, y+addY)\n\n    return $ Figure { draw=drawF, move=moveF }\n\nrectangle from to = do\n    fromVar <- newIORef from\n    toVar   <- newIORef to\n\n    let drawF = do from <- readIORef fromVar\n                   to   <- readIORef toVar\n                   putStrLn (\"  Rectangle \"++show from++\"-\"++show to)\n\n    let moveF (addX,addY) = do (fromX,fromY) <- readIORef fromVar\n                               (toX,toY)     <- readIORef toVar\n                               writeIORef fromVar (fromX+addX, fromY+addY)\n                               writeIORef toVar   (toX+addX, toY+addY)\n\n    return $ Figure { draw=drawF, move=moveF }\n```\n现在我们可以测试移动图的代码：\n```Haskell\nmain = do figures <- sequence [circle (10,10) 5,\n                               rectangle (10,10) (20,20)]\n          drawAll figures\n          mapM_ (\\fig -> move fig (10,10)) figures\n          drawAll figures\n```\n重要的是要意识到我们不仅限于在一个旨在模拟C++/Java风格接口的记录中仅包含IO action。记录还可以包括值，IORefs，纯函数 - 简而言之，任何类型的数据。例如，我们可以轻松地将area和origin字段添加到图形接口中：\n```Haskell\ndata Figure = Figure { draw :: IO (),\n                       move :: Displacement -> IO (),\n                       area :: Double,\n                       origin :: IORef Point\n                     }\n```\n\n#### 异常处理\n\n\n#### 与C/C++和外部库的接口\n\n#### IO monad的黑暗面\n\n##### unsafePerformIO\n来自命令式语言背景的程序员经常寻找在纯过程中执行IO操作的方法。但是，这是什么意思? 想象一下，您正在尝试编写一个读取具有给定名称的文件内容的过程，并尝试将其写为纯（非IO）函数：\n```Haskell\nreadContents :: Filename -> String\n```\n将readContents定义为纯函数肯定会简化使用它的代码。但它也会给编译器带来问题：\n* 此调用未插入\"world转换\"序列中,因此编译器不知道您希望何时执行此操作。例如,如果文件在程序开头有一种内容而另一种在结尾 - 你想看哪些内容？您不知道何时(或者甚至是)将要调用此函数,因为Haskell将此函数视为纯函数,并且可以根据需要重新排序任何或所有纯函数的执行。\n* 尽管可以在调用之间改变文件(或当前目录),但是可以考虑尝试读取具有相同名称的文件的内容(即,减少到单个调用)。同样,Haskell认为所有非IO函数都是纯粹的,并且可以随意省略具有相同参数的多个调用。\n因此,实现与真实世界交互的纯函数被认为是不良的行为,好男孩和女孩从来没有这样做;\n然而,有(半官方)方法在纯函数内部使用IO动作。你应该记住,通过要求一个RealWorld接力棒去调用一个IO action是禁止的。\n纯函数没有接力棒,但是有一个特殊的`magic`程序可以从不知名的地方产生这个\"接力棒\",使用它来调用IO action,然后抛出所产生的`world`!这是一个有点低级魔法。这个非常特殊(危险)的程序是：\n```Haskell\nunsafePerformIO :: IO a -> a\n```\n让我们来看看它的(可能的)定义:\n```Haskell\nunsafePerformIO :: (RealWorld -> (a, RealWorld)) -> a\nunsafePerformIO action = \n\tlet (a, world1) = action createNewWorld \n\tin a\n```\n其中`createNewWorld`是一个内部函数，产生RealWorld类型的新值。\n使用`unsafePerformIO`,您可以轻松编写内部执行I/O的纯函数。但是不要在没有真正需要的情况下这样做,并记住遵循这条规则: 编译器不知道你在作弊;它仍然认为每个非IO功能都是纯粹的。因此,所有通常的优化规则都可以(并且将会)应用于其执行。所以你必须确保:\n* 每次调用的结果仅取决于其参数\n* 您不依赖于此函数的副作用,如果不需要其结果,则该函数可能不会执行\n让我们更深入地研究这个问题。Haskell中的函数评估由值的必要性决定 - 语言仅计算计算最终结果所需的值。但这对于`main`函数意味着什么呢?为了计算\"最终world值\"，您需要执行`main`链中包含的所有中间IO操作,通过使用`unsafePerformIO`,我们在此链之外调用IO操作,我们有什么保证可以运行它们？没有。只有在需要运行它们来计算整个函数结果时才会运行它们(这反过来也应该被要求在`main`链中执行一些操作)，这是Haskell按需评估策略的一个例子。现在你应该清楚地看到差异:\n* IO过程中的IO操作保证只要(直接或间接)在`main`链内执行 - 即使未使用其结果(因为它返回的隐式`world`值将被使用)。您可以直接在IO过程中指定操作的执行顺序。通过从每个IO操作传递到下一个IO操作的隐式`world`值来模拟数据依赖性。\n* 只有在真正使用此操作的结果时,才会执行`unsafePerformIO`内的IO操作,评估顺序无法保证,您不应该依赖它(除非您确定可能存在任何数据依赖性)。\n我还应该说，在`unsafePerformIO`调用中你可以在相同的绑定操作符`and/or`我们上面看到的`do`语法糖的帮助下组织一个小的内部IO actions链。\n例如，这里有一个特别复杂的方法来计算0之后的整数:\n```Haskell\none :: Int\none = unsafePerformIO $ do var <- newIORef 0\n                           modifyIORef var (+1)\n                           readIORef var\n```\n在这种情况下,只要需要`unsafePerformIO`调用的结果,就会执行该链中的所有操作。为了确保这一点,实际的`unsafePerformIO`实现会评估`action`返回的`world`：\n```Haskell\nunsafePerformIO action = let (a,world1) = action createNewWorld\n                         in (world1 `seq` a)\n```\n(`seq`操作在返回第二个参数的值之前严格评估其第一个参数)\n\n##### inlinePerformIO\n`inlinePerformIO`与`unsafePerformIO`具有相同的定义,但添加了`INLINE`编译指示：\n```Haskell\n-- 就像unsafePerformIO一样,但我们内联它,大量的性能提升,因为它暴露了很多东西进一步内联\n{-# INLINE inlinePerformIO #-}\ninlinePerformIO action = let (a, world1) = action createNewWorld\n                         in (world1 `seq` a)\n#endif\n```\n语义上`inlinePerformIO = unsafePerformIO`，其中任何一个都有任何语义。\n当然,不同之处在于`inlinePerformIO`比`unsafePerformIO`更不安全。虽然`ghc`将尽量不重复或共同使用`unsafePerformIO`的不同用途,但我们积极地内联`inlinePerformIO`。因此,实际上您只能在IO内容非常纯正的地方使用它,例如从不可变的内存缓冲区读取(如`ByteStrings`的情况),然而,分配新缓冲区之类的事情不应该在`inlinePerformIO`内部完成,因为它可以很容易地在整个程序中浮动并只执行一次，所以最终会有许多东西共享同一个缓冲区，这很糟糕。\n```Haskell\nwrite :: Int -> (Ptr Word8 -> IO ()) -> Put ()\nwrite !n body = Put $ \\c buf@(Buffer fp o u l) ->\n  if n <= l\n    then write' c fp o u l\n    else write' (flushOld c n fp o u) (newBuffer c n) 0 0 0\n\n  where {-# NOINLINE write' #-}\n        write' c !fp !o !u !l =\n          -- warning: this is a tad hardcore\n          inlinePerformIO\n            (withForeignPtr fp\n              (\\p -> body $! (p `plusPtr` (o+u))))\n          `seq` c () (Buffer fp o (u+n) (l-n))\n```\n它的使用方式如下：\n```Haskell\nword8 w = write 1 (\\p -> poke p w)\n```\n这不符合我的经验法则,不要问我们为什么声称它是安全的(如果有人真的想知道,请问`Ross Paterson`谁先在`Builder monoid`中做过)\n\n##### unsafeInterleaveIO\n但是还有一个更奇怪的操作叫做`unsafeInterleaveIO`,它得到了\"官方接力棒\",制作了自己的翻印副本,然后与main接力棒同时进行一场\"非法\"的接力比赛!我无法在不引起悲痛和愤慨的情况下进一步讨论它的行为,因此,在俄罗斯和中国等软件盗版的温床国家,这种操作被广泛使用也就不足为奇了!)别问我 —— 我不会再提我经常用的这种卑鄙的伎俩了。\n可以使用`unsafePerformIO`(不是`unsafeInterleaveIO`)来执行I/O操作,而不是按预定义顺序执行I/O操作。例如,以下代码：\n```Haskell\ndo let c = unsafePerformIO getChar\n   do_proc c\n```\n只有当代码确实需要`c`的值时才会执行`getChar I/O`调用,即它将像任何通常的Haskell计算一样懒惰地执行.\n现在想象下面的代码：\n```Haskell\ndo let s = [unsafePerformIO getChar, unsafePerformIO getChar, unsafePerformIO getChar]\n   do_proc s\n```\n此列表中的三个字符也将按需计算,这意味着它们的值将取决于它们的消耗顺序。这通常不是我们需要的。\n`unsafeInterleaveIO`解决了这个问题 - 它只在需要时执行I/O,但允许为数据结构的各个部分定义精确的*内部*执行顺序。这就是为什么我写道`unsafeInterleaveIO`制作非法复制的接力棒。\n\n首先,`unsafeInterleaveIO`将`(IO a)`action 作为参数并返回类型为`a`的值：\n```Haskell\ndo str <- unsafeInterleaveIO myGetContents\n```\n其次,`unsafeInterleaveIO`不会立即执行任何操作,它只创建一个类型为`a`的盒子,在请求此值时将执行指定为参数的操作。\n第三,这个action本身可以立即计算整个值或者......再次使用`unsafeInterleaveIO`推迟计算一些子组件：\n```Haskell\nmyGetContents = do\n   c <- getChar\n   s <- unsafeInterleaveIO myGetContents\n   return (c:s)\n```\n此代码仅在确实需要`str`的值时执行,在这一刻,将执行`getChar`(结果分配给`c`),并且将创建一个更懒的IO盒子`s`。 此盒子再次包含指向`myGetContents`调用的链接\n然后,返回一个包含`char read`的list单元格,并链接到`myGetContents`调用(作为计算列表其余部分的方法)。\n仅当需要list中的下一个值时,才会再次执行此操作。\n作为最终结果,我们无法在读取第一个之前读取到列表中的第二个字符,而是读取整个列表的懒惰字符。答对了！\n\nPS:当然，实际代码应该包括EOF检查。请注意，你可以在每次通话中读取多个字符/记录:\n```Haskell\nmyGetContents = do\n   c <- replicateM 512 getChar\n   s <- unsafeInterleaveIO myGetContents\n   return (c++s)\n```\n\n#### 更安全的方法: ST monad\n我们之前说过，我们可以使用`unsafePerformIO`来执行完全纯粹但仍以某种方式与真实世界交互的计算。但是，还有更好的方法! 它保持了完全纯粹性，并且允许使用引用/数组等等 - 并且它已经完成了使用，你猜对了，类型魔法。这是`ST monad`。\n`ST monad`的`unsafePerformIO`版本称为`runST`,它有一种非常不寻常的类型。\n```Haskell\nrunST :: (forall s . ST s a) -> a\n```\n`ST monad中`的`s`变量是状态类型。此外,`ST monad`中可用的所有有趣的可变内容都是通过`s`来量化的：\n```Haskell\nnewSTRef :: a -> ST s (STRef s a)\nnewArray_ :: Ix i => (i, i) -> ST s (STArray s i e)\n```\n那么为什么`runST`有这么时髦的类型呢？让我们看看如果我们写下会发生什么\n```Haskell\nmakeSTRef :: a -> STRef s a\nmakeSTRef a = runST (newSTRef a)\n```\n这将失败,因为`newSTRef a`并不适用于所有状态类型`s` —— 它只适用于返回类型`STRef s a`的`s`。\n这有点古怪,但结果是,您只能运行一个`ST`计算,其中输出类型在功能上是纯的,并且不引用计算的内部可变状态,`ST monad`也不能访问I/O操作,比如写入控制台 —— 只有引用、数组之类的操作才能方便地进行纯计算。\n重要提示 - `state`类型实际上并不意味着什么。例如，我们从未拥有类型`s`的值。这只是让类型系统通过烟雾和镜子来确保我们的纯度工作的一种方式。\n它实际上只是一种类型系统魔法:在内部,`runST`像`unsafePerformIO`一样，用真实世界的接力棒运行计算。它们的内部实现几乎是相同的, 事实上,有一个函数:\n```Haskell\nstToIO :: ST RealWorld a -> IO a\n```\n不同之处在于`ST`使用类型系统魔法禁止不安全行为,例如从安全`ST`包装中提取可变对象,但是允许使用对可变引用和数组的所有方便访问来执行纯函数输出。\n下面是我们如何用上面的`unsafePerformIO`重写我们的函数:\n```Haskell\noneST :: ST s Int -- note that this works correctly for any s\noneST = do var <- newSTRef 0\n           modifySTRef var (+1)\n           readSTRef var\n\none :: Int\none = runST oneST\n```\n\n#### 欢迎来到机器: 实际的GHC实现\n一个小小的免责声明: 我应该说我并没有在这里详细描述monad是什么(我自己甚至都不完全理解它)而且我的解释只显示了在Haskell中实现`IO monad`的一种可能方式。例如,`hbc Haskell`编译器和`Hugs`解释器通过`continuation`实现`IO monad`。我还没有谈到异常处理,这是`monad`概念的一个自然部分。您可以阅读\"All About Monads\"指南,了解有关这些主题的更多信息。\n但有一些好消息:首先,你刚刚获得的`IO monad`理解将适用于任何许多其他`monad`的实现。您只是无法直接使用`RealWorld`值。\n其次,这里描述的`IO monad`实现实际上是在`GHC、yhc/nhc (jhc?)`编译器中使用的。下面是GHC来源的IO定义:\n```Haskell\nnewtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))\n```\n它使用`State# RealWorld`类型而不是我们的`RealWorld`,它使用`(# #)`严格的元组进行优化,并围绕该类型添加一个IO数据构造函数。然而,从我们的解释来看,并没有什么重大的变化。了解了通过`伪装world状态`值\"链接\"IO操作的原则,您现在可以轻松理解和编写`GHC I/O`操作的底层实现。\n\n##### Yhc/nhc98 实现\n```Haskell\ndata World = World\nnewtype IO a = IO (World -> Either IOError a)\n```\n这个实现使`World`在某种程度上消失,并返回类型为`a`的结果,或者如果出现错误,则返回`IOError`。只有当编译器知道IO类型的一些特殊信息,并且不会对其进行过度优化时,函数右边才会缺少`World`。\n\n#### 进一步阅读\n\n#### to-do列表\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["IO"]},{"title":"Dubbo源码阅读之服务器创建","url":"/blog/2019/02/20/Dubbo源码阅读之服务器创建/","content":">在《Dubbo源码阅读之服务暴露》一文中，我们知道在服务暴露时会创建服务器，这篇文章我们就详细看下服务器相关的源码。\n\n![](images/dubbo.jpeg)\n\n###\n\n\n\n","tags":["dubbo"]},{"title":"Haskell常用扩展","url":"/blog/2018/11/20/Haskell常用扩展/","content":"\n### BinaryLiterals\n\n### ExistentialQuantification\n\n### FlexibleInstances\n\n### LambdaCase\n一个句法扩展，允许你用\\case代替\\arg - > case arg of.\n请考虑以下函数定义：\n```haskell\ndayOfTheWeek :: Int -> String\ndayOfTheWeek 0 = \"Sunday\"\ndayOfTheWeek 1 = \"Monday\"\ndayOfTheWeek 2 = \"Tuesday\"\ndayOfTheWeek 3 = \"Wednesday\"\ndayOfTheWeek 4 = \"Thursday\"\ndayOfTheWeek 5 = \"Friday\"\ndayOfTheWeek 6 = \"Saturday\"\n```\n如果您想避免重复函数名称，可以这样编写：\n```haskell\ndayOfTheWeek :: Int -> String\ndayOfTheWeek i = case i of\n    0 -> \"Sunday\"\n    1 -> \"Monday\"\n    2 -> \"Tuesday\"\n    3 -> \"Wednesday\"\n    4 -> \"Thursday\"\n    5 -> \"Friday\"\n    6 -> \"Saturday\"\n```\n而使用LambdaCase扩展后，您可以将其编写为函数表达式，而无需为参数命名：\n```haskell\n{-# LANGUAGE LambdaCase #-}\n\ndayOfTheWeek :: Int -> String\ndayOfTheWeek = \\case\n    0 -> \"Sunday\"\n    1 -> \"Monday\"\n    2 -> \"Tuesday\"\n    3 -> \"Wednesday\"\n    4 -> \"Thursday\"\n    5 -> \"Friday\"\n    6 -> \"Saturday\"\n```\n\n### ScopedTypeVariables\nScopedTypeVariables允许您引用声明中的通用量化类型, 更明确一点：\n```haskell\nimport Data.Monoid\n\nfoo :: forall a b c. (Monoid b, Monoid c) => (a, b, c) -> (b, c) -> (a, b, c)\nfoo (a, b, c) (b', c') = (a :: a, b'', c'')\n    where (b'', c'') = (b <> b', c <> c') :: (b, c)\n```\n重要的是我们可以使用a,b和c来指示编译器在声明的子表达式中(where子句中的元组和最终结果中的第一个a),实际上,ScopedTypeVariables有助于将复杂函数编写为部分之和，允许程序员将类型签名添加到没有具体类型的中间值。\n\n\n### OverloadedStrings\n通常，Haskell中的字符串文字具有String类型（它是[Char]的类型别名）。虽然这对于较小的教育程序来说不是问题，但实际应用程序通常需要更高效的存储，例如Text或ByteString.\nOverloadedStrings只是将文字类型更改为:\n```haskell\n\"test\" :: Data.String.IsString a => a\n```\n允许它们直接传递给期望这种类型的函数。许多库为类似字符串的类型实现了这个接口，包括Data.Text和Data.ByteString ，它们都比[Char]提供了一定的时间和空间优势。\n\n还有一些像Postgresql简单库那样的OverloadedStrings独特用途，它允许用双引号编写SQL查询，就像普通字符串一样，但提供了对不正确连接的保护，这是一种臭名昭着的SQL注入攻击源。\n要创建IsString类的实例，您需要实现fromString函数。示例：\n```haskell\ndata Foo = A | B | Other String deriving Show\n\ninstance IsString Foo where\n  fromString \"A\" = A\n  fromString \"B\" = B\n  fromString xs  = Other xs\n\ntests :: [ Foo ]\ntests = [ \"A\", \"B\", \"Testing\" ]\n```\n\n\n\n### TupleSections\n一种语法扩展，允许以节的方式应用元组构造函数(它是一个运算符):\n```haskell\n(a,b) == (,) a b\n\n-- With TupleSections\n(a,b) == (,) a b == (a,) b == (,b) a\n```\n#### N-tuples\n它也适用于元素大于2的元组\n```haskell\n(,2,) 1 3 == (1,2,3)\n```\n#### Mapping\n这在使用部分的其他地方也很有用:\n```haskell\nmap (,\"tag\") [1,2,3] == [(1,\"tag\"), (2, \"tag\"), (3, \"tag\")]\n```\n没有此扩展的上述示例如下所示：\n```haskell\nmap (\\a -> (a, \"tag\")) [1,2,3]\n```\n\n\n\n","tags":["haskell"]},{"title":"Redis源码阅读-字符串","url":"/blog/2018/11/17/Redis源码阅读-字符串/","content":">Redis动态字符串数据结构的定义及实现在sds.h和sds.c文件中。\n\n* 字符串定义\n* 字符串实现\n* 方法实现\n\n### 字符串定义\n我们平时在使用Redis时，经常使用的数据结构就是字符串，例如：\n```shell\n127.0.0.1:6379> set name Redis\nOK\n127.0.0.1:6379> get name\n\"Redis\"\n127.0.0.1:6379> del name\n(integer) 1\n```\n那么字符串在Redis是如何定义的呢？我们可以在sds.h文件中找到答案。\n在该文件中，我们可以看到Redis字符串数据结构SDS由两部分组成，sds指针和sdshdr头部类型，\n其中sdshdr类型定义了5种(sdshdr5/sdshdr8/sdshdr16/sdshdr32/sdshdr64)，主要是为了针对不同长度的字符串，节省内存：\n```c\ntypedef char *sds;\n\nstruct __attribute__ ((__packed__)) sdshdr5 {\n    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr8 {\n    uint8_t len;\n    uint8_t alloc;\n    unsigned char flags;\n    char buf[];\n};\n\n/*flags值定义*/\n#define SDS_TYPE_5  0\n#define SDS_TYPE_8  1\n#define SDS_TYPE_16 2\n#define SDS_TYPE_32 3\n#define SDS_TYPE_64 4\n\n//掩码\n#define SDS_TYPE_MASK 7\n#define SDS_TYPE_BITS 3\n\n/*通过buf指针获取sds头指针，T为sds头类型值，s为buf指针\n *这里##会将两个字符串连接起来，如:T为8，则sdshdr##T为sdshrd8\n *sizeof(struct sdshdr##T)为结构体sdshdr8占用的字节数，这里为3字节\n */\n#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));\n\n#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))\n\n#define SDS_TYPE_5_LEN(f) ((f)>>SDS_TYPE_BITS)\n```\n![](img/sds.png)\nlen   标识当前字节数组的长度，不包含字符串结束标识。\nalloc 标识当前字节数组分配的内存大小，不包含字符串结束标识。\nflags 低3位标识当前使用的是哪个sdshdr类型。\nbuf   保存字符串值和结束标识。\n*sds  指向buf数组的起始地址\n为SDS增加一个头部类型可以提高一些操作的效率，例如用O(1)的复杂度就可以从头部中取到字符串长度。\nsdshdr头部类型是通过结构体定义的，默认情况下会进行内存对齐优化，即结构体分配的内存是内部最大元素的整数倍，例如sdshdr32将会分配12字节。\n这里使用__attribute__ ((__packed__))关闭内存对齐优化，从而按照实际占用字节数来对齐，即sdshdr32将会分配9字节，节省了3字节。内存紧凑，使用sds-1就可以得到flags字段，进而得到其头部类型。没有内存对齐，cpu寻址效率就会降低，Redis是在内存分配前做了一些操作，解决内存对齐的，后面会看到。\nbuf数组初始化时不占用内存空间，使得头部内存和存储字符串的内存地址连续，另外结尾隐含一个'\\0',而SDS是以len字段来判断是否是否到达字符串末尾的，因此在字符串中间可以出现'\\0'，即SDS字符串是二进制安全的。\n\n### 字符串实现\n创建新字符串使用的是sds.c中的sdsnewlen函数：\n```c\n// 使用init指针指向的内容和initlen创建一个新的字符串\nsds sdsnewlen(const void *init, size_t initlen) {\n    void *sh;\n    \n    // buf数组起始地址\n    sds s;\n    \n    // 根据长度选择合适的sds头部类型\n    char type = sdsReqType(initlen);\n\n    // 用type 8创建空字符串方便追加\n    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;\n    \n    // 根据sds头部类型获取头部大小\n    int hdrlen = sdsHdrSize(type);\n    \n    // flag指针\n    unsigned char *fp;\n\n    // 为sds分配内存（后面会分析s_malloc）\n    // 内存大小为：sds头部大小 + 存储字符串的长度initlen + 末尾空字符大小1字节\n    sh = s_malloc(hdrlen+initlen+1); \n\n    if (!init)\n        // 内存初始化为0（后面会分析memset）\n        memset(sh, 0, hdrlen+initlen+1);\n    // 内存分配失败\n    if (sh == NULL) return NULL;\n\n    // buf数组的起始地址\n    s = (char*)sh+hdrlen;\n    \n    // buf数组起始地址-1，即为flags字段\n    fp = ((unsigned char*)s)-1;\n\n    // 初始化sds头部的len,alloc,flags字段\n    switch(type) {\n        case SDS_TYPE_5: {\n            *fp = type | (initlen << SDS_TYPE_BITS);\n            break;\n        }\n        case SDS_TYPE_8: {\n            //根据buf起始地址获取指向sds头部的起始地址的指针\n            SDS_HDR_VAR(8,s);\n\t    // 设置len字段值为initlen\n            sh->len = initlen;\n\t    // 设置alloc字段值为initlen\n            sh->alloc = initlen;\n\t    // 设置flags字段类型为type\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n    }\n    // 初始化buf数组\n    if (initlen && init)\n        // 拷贝init到buf数组（后面会分析memcpy）\n        memcpy(s, init, initlen);\n\n    // 添加末尾空字符标识\n    s[initlen] = '\\0';\n    return s;\n}\n\n/**\n * 根据字符串长度获取合适的头部类型\n * @param string_size 字符串初始长度\n * @return\n */\nstatic inline char sdsReqType(size_t string_size) {\n    if (string_size < 1<<5) //32\n        return SDS_TYPE_5;\n    if (string_size < 1<<8) //256\n        return SDS_TYPE_8;\n    if (string_size < 1<<16) //65536\n        return SDS_TYPE_16;\n#if (LONG_MAX == LLONG_MAX) //等于有符号long最大值\n    if (string_size < 1ll<<32) //4gb\n        return SDS_TYPE_32;\n    return SDS_TYPE_64;\n#else\n    return SDS_TYPE_32;\n#endif\n}\n\n/**\n * 通过字符串头部类型获取其头大小\n * @param type 字符串类型 0-4\n * @return\n */\nstatic inline int sdsHdrSize(char type) {\n    // type & SDS_TYPE_MASK = type\n    // 例如：sdshdr8， 1 & 7 = 1\n    switch(type&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            return sizeof(struct sdshdr5);\n        case SDS_TYPE_8:\n            //sizeof计算结构体大小，取消了内存对齐\n            return sizeof(struct sdshdr8); // 3字节\n        case SDS_TYPE_16:\n            return sizeof(struct sdshdr16); // 5字节\n        case SDS_TYPE_32:\n            return sizeof(struct sdshdr32); // 9字节\n        case SDS_TYPE_64:\n            return sizeof(struct sdshdr64); // 17字节\n    }\n    return 0;\n}\n```\n关于内存操作的函数，将在内存操作小节介绍，这里就不在进行介绍了。\n### 方法实现\n","tags":["redis"]},{"title":"数据结构与算法-复杂度分析","url":"/blog/2018/10/13/数据结构与算法-复杂度分析/","content":">本小节总结时间、空间复杂度分析\n* 什么是复杂度分析？\n* 为什么要进行复杂度分析？\n* 如何进行时间、空间复杂度分析？(大O表示法)\n\n### 什么是复杂度分析\n1. 数据机构与算法是为了解决\"如何让计算机运行的更快同时更省存储空间\"的问题，因此，执行效率是评估一个算法好坏的重要指标。\n2. 我们需要从算法执行时间、占用空间两个纬度来评估数据结构和算法的性能。通常使用时间复杂度和空间复杂度来描述性能问题。\n3. 复杂度分析描述的是算法执行时间(占用空间)与数据规模的增长关系。\n\n### 为什么要进行复杂度分析\n平时我们会把代码运行一遍，然后通过统计、监控就可以得到算法执行的时间和占用的内存，此方法称为事后统计法，存在很大的局限性。\n1. 测试结果非常依赖测试环境\n2. 测试结果受数据规模的影响很大，我们需要一个不用具体的测试数据进行测试就可以粗略的评估算法执行效率的方法。\n3. 掌握复杂度分析，将会编写出性能更优的代码，有利于降低系统开发和维护的成本。\n\n### 如何进行复杂度分析\n#### 大O表示法的由来\n所有代码的执行时间T(n)与每行代码的执行次数n成正比。用大O表示法就是:\n```\n\tT(n) = O(f(n))\n其中:\n\tT(n) 表示代码执行时间。\n\tf(n) 表示每行代码执行的次数总和。\n\t大0 表示代码执行时间 T(n) 与 f(n) 表达式成正比。\n```\n大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势。因此也叫做渐进时间复杂度，简称时间复杂度。\n\n#### 大O表示法的特点\n以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模增长的变化趋势，所以常量阶、低阶、以及系数实际上对这种增长趋势不产生决定性影响，因此在进行时间复杂度分析时可以省略这些项。\n\n#### 时间复杂度分析法则\n1. 只关注循环次数最多的一段代码：比如循环操作\n2. 加法法则取量级最大代码复杂度：比如一段代码中有单循环和多重循环，则取多重循环的复杂度。\n3. 乘法法则嵌套代码复杂度取乘积: 比如递归、多重循环等，取嵌套内外代码复杂度的乘积。\n4. 多个规模求加法：比如方法有两个参数分别控制两个循环的次数，则将两者的复杂度进行相加，即：O(m+n)\n\n#### 常见的时间复杂度级别\n1. 多项式阶\n    随着数据规模的不断增长，算法的执行时间和空间占用，按照多项式的比例增长。从低阶到高阶常见的有(越高阶效率越低)：\n```perl    \n\tO(1): 常数阶\n\n\tO(logn): 对数阶\n\n\tO(n): 线性阶\n\n\tO(nlogn): 线性对数阶\n\n\tO(n^2): 平方阶\n\n\tO(n^3): 立方阶\n```\n2. 非多项式阶\n    我们把时间复杂度为非多项式量级的算法问题叫做NP(Non-Deterministic Ploynomial非确定多项式)问题，随着数据规模的不断增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括：\n```perl\n\tO(2^n): 指数阶\n\n\tO(n!): 阶乘阶\n```\n#### 空间复杂度\n空间复杂度和时间复杂度类似，全称为：渐进空间复杂度，表示算法的存储空间和数据规模之间的增长关系。\n常见的空间复杂度级别有：O(1)、O(n)、O(n^2)，而O(logn)、O(nlogn)这样的对数阶复杂度平时都用不到。\n\n\n\n### 例子\n#### 时间复杂度分析\n##### O(1)\n\n##### O(logn)、O(nlogn)\n\n##### O(m+n)、O(m*n)\n \n#### 空间复杂度分析\n\n\n","tags":["复杂度分析"]},{"title":"Dubbo源码阅读之Configurator动态配置","url":"/blog/2018/09/05/Dubbo源码阅读之Configurator动态配置/","content":">我们可以编写动态配置来配置服务提供者。这个操作通常在监控中心完成。\n\n### 官网文档\n我们先看下官网给的文档说明\n```java\nRegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();\n//获取注册中心\nRegistry registry = registryFactory.getRegistry(URL.valueOf(\"zookeeper://10.20.153.10:2181\"));\n//注册配置\nregistry.register(URL.valueOf(\"override://0.0.0.0/com.foo.BarService?category=configurators&dynamic=false&application=foo&timeout=1000\"));\n```\n在这个配置override url中：\n* override:// 表示数据将会被覆盖，当前dubbo支持override和absent，可以自行扩展，必填参数.\n* 0.0.0.0 表示该配置对所有IP地址都有效，如果只想覆盖指定的ip数据，则可以替换指定的ip地址，必填参数.\n* com.foo.BarService 表示对指定的服务有效，必填参数.\n* category=configurators 表示数据是动态配置的，必填参数.\n* dynamic=false 表示数据是持久化的，当注册方撤销时，数据仍存储在注册表中。\n* enabled=true 启用覆盖策略，可以不传，不传的话，默认值为启用\n* application=foo 表示对指定的application有效，可以不传，不传的话则对所有应用程序有效。\n* timeout=1000 表示满足上述条件的timeout参数的值将会被1000覆盖，如果想要覆盖其他参数，则直接添加到override URL参数上。\n\n#### 例子\n* 禁用服务提供者(通常用于临时踢掉提供者机器，类似于禁止消费者访问，请使用路由规则)\n```java\noverride://10.20.153.10/com.foo.BarService?category=configurators&dynamic=false&disbaled=true\n```\n\n* 调整权重:(通常用于容量评估，默认为100)\n```java\noverride://10.20.153.10/com.foo.BarService?category=configurators&dynamic=false&weight=200\n```\n\n* 调整负载均衡策略(默认策略为随机)\n```java\noverride://10.20.153.10/com.foo.BarService?category=configurators&dynamic=false&loadbalance=leastactive\n```\n\n* 服务降级:(通常用于暂时屏蔽非关键服务的错误）\n```java\noverride://0.0.0.0/com.foo.BarService?category=configurators&dynamic=false&application=foo&mock=force:return+null\n```\n\n现在我们开始看源码实现\n### Configurator接口\n```java\npublic interface Configurator extends Comparable<Configurator> {\n\n    /**\n     * 获取配置url\n     */\n    URL getUrl();\n\n    /**\n     * 配置服务提供者url\n     * 向url中添加新属性(absent) 或者 覆盖url中的属性(override).(新属性来源于配置url)\n     * @param url 旧的提供者url\n     * @return  新的提供者url\n     */\n    URL configure(URL url);\n}\n```\n\n#### AbstractConfigurator抽象类\n该抽象类实现了Configurator接口。并实现了configure方法，在该方法中，会判断当前url是否满足覆盖url的条件。如果满足的话，会调用抽象方法doConfigure执行相应的配置。doConfigure抽象方法由两个子类AbsentConfigurator(absent)和OverrideConfigurator(override)进行实现。\n```java\npublic abstract class AbstractConfigurator implements Configurator {\n\n    /**\n     * 配置url\n     */\n    private final URL configuratorUrl;\n\n    public AbstractConfigurator(URL url) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"configurator url == null\");\n        }\n        this.configuratorUrl = url;\n    }\n\n    @Override\n    public URL getUrl() {\n        return configuratorUrl;\n    }\n\n    /**\n     * @param url 旧的url\n     * @return\n     */\n    @Override\n    public URL configure(URL url) {\n        if (configuratorUrl == null || configuratorUrl.getHost() == null\n                || url == null || url.getHost() == null) {\n            return url;\n        }\n        //如果override url存在端口，则意味着它是服务提供者地址\n        //我们想要这个override url控制一个指定的服务提供者\n        //该覆盖url规则可能对特定的服务提供者实例生效，或者对持有这个服务提供者实例的消费者生效\n        if (configuratorUrl.getPort() != 0) {\n            if (url.getPort() == configuratorUrl.getPort()) {\n                //服务提供者\n                return configureIfMatch(url.getHost(), url);\n            }\n        } else {\n            //configuratorUrl没有端口，意味着这个url的ip指定的是一个消费者地址或者0.0.0.0\n            //如果它是一个消费者ip地址，目的是控制一个特定的消费者实例，\n            //它必须在消费者端生效，任何提供者都将会忽略该url\n            //如果ip是0.0.0.0，则该配置url对消费者、生产者都生效\n            if (url.getParameter(Constants.SIDE_KEY, Constants.PROVIDER).equals(Constants.CONSUMER)) {\n                //消费者\n                //NetUtils.getLocalHost is the ip address consumer registered to registry.\n                //NetUtils.getLocalHost是一个注册到注册中心的消费者ip地址\n                return configureIfMatch(NetUtils.getLocalHost(), url);\n            } else if (url.getParameter(Constants.SIDE_KEY, Constants.CONSUMER).equals(Constants.PROVIDER)) {\n                //生产者\n                // take effect on all providers, so address must be 0.0.0.0,\n                // otherwise it won't flow to this if branch\n                //对所有生产者生效，因此地址必须是0.0.0.0，否则，它将不会进入这个分支\n                return configureIfMatch(Constants.ANYHOST_VALUE, url);\n            }\n        }\n        return url;\n    }\n\n    /**\n     * @param host 受影响的主机地址\n     * @param url\n     * @return\n     */\n    private URL configureIfMatch(String host, URL url) {\n        if (Constants.ANYHOST_VALUE.equals(configuratorUrl.getHost())\n                || host.equals(configuratorUrl.getHost())) {\n            //配置url的host等于0.0.0.0，或者等于host\n            \n            //获取配置url的application参数值，如果为空，则获取username属性\n            String configApplication = configuratorUrl.getParameter(Constants.APPLICATION_KEY,configuratorUrl.getUsername());\n            //获取当前url的application参数值，如果为空，则获取username属性\n            String currentApplication = url.getParameter(Constants.APPLICATION_KEY, url.getUsername());\n\n            if (configApplication == null || Constants.ANY_VALUE.equals(configApplication)\n                    || configApplication.equals(currentApplication)) {\n                //配置url的configApplication = (null || * || currentApplication)\n                Set<String> condtionKeys = new HashSet<String>();\n                \n\t\t//添加category、check、dynamic、enabled参数\n                condtionKeys.add(Constants.CATEGORY_KEY);\n                condtionKeys.add(Constants.CHECK_KEY);\n                condtionKeys.add(Constants.DYNAMIC_KEY);\n                condtionKeys.add(Constants.ENABLED_KEY);\n                \n\t\t//遍历配置url的参数列表\n                for (Map.Entry<String, String> entry : configuratorUrl.getParameters().entrySet()) {\n                    //参数key\n                    String key = entry.getKey();\n                    //参数value\n                    String value = entry.getValue();\n                    \n\t\t    if (key.startsWith(\"~\") || Constants.APPLICATION_KEY.equals(key) || Constants.SIDE_KEY.equals(key)) {\n\t\t\t//参数key = (application || side || ^~ )\n                        \n\t\t\t//添加该key参数\n                        condtionKeys.add(key);\n                        \n\t\t\tif (value != null && !Constants.ANY_VALUE.equals(value)\n                                && !value.equals(url.getParameter(key.startsWith(\"~\") ? key.substring(1) : key))) {\n                            //如果 当前url的key参数的值 != * 并且 不等于 配置url的key参数的值，则直接返回当前url\n                            return url;\n                        }\n                    }\n                }\n                //从配置url中移除condtionKeys参数，然后执行配置\n                return doConfigure(url, configuratorUrl.removeParameters(condtionKeys));\n            }\n        }\n        return url;\n    }\n\n    /**\n     * 1、具有特定主机IP的URL比0.0.0.0的优先级高\n     * 2、如果两个url有相同的host，比较priority字段的值\n     */\n    @Override\n    public int compareTo(Configurator o) {\n        if (o == null) {\n            return -1;\n        }\n\n        int ipCompare = getUrl().getHost().compareTo(o.getUrl().getHost());\n        if (ipCompare == 0) {\n            int i = getUrl().getParameter(Constants.PRIORITY_KEY, 0),\n                    j = o.getUrl().getParameter(Constants.PRIORITY_KEY, 0);\n            if (i < j) {\n                return -1;\n            } else if (i > j) {\n                return 1;\n            } else {\n                return 0;\n            }\n        } else {\n            return ipCompare;\n        }\n    }\n    \n    //抽象方法，执行相应配置策略\n    protected abstract URL doConfigure(URL currentUrl, URL configUrl);\n\n}\n```\n#### AbsentConfigurator实现类\n```java\npublic class AbsentConfigurator extends AbstractConfigurator {\n\n    public AbsentConfigurator(URL url) {\n        super(url);\n    }\n    \n    /**\n     * @currentUrl 服务提供者url\n     * @configUrl  配置url\n     */\n    @Override\n    public URL doConfigure(URL currentUrl, URL configUrl) {\n        //将配置url中的参数添加到服务提供者url参数中(只会添加不存在的，不会覆盖已存在的参数)\n        return currentUrl.addParametersIfAbsent(configUrl.getParameters());\n    }\n}\n\n/**\n * 只有原服务提供者url中不包含该参数时，才会添加，不会覆盖\n */\npublic URL addParametersIfAbsent(Map<String, String> parameters) {\n        if (parameters == null || parameters.size() == 0) {\n            return this;\n        }\n        //A-1,B-2,C-2 覆盖url\n        //A-2,B-2     原服务提供者url参数\n        //A-2,B-2,C-2 新的服务提供者url参数\n        Map<String, String> map = new HashMap<String, String>(parameters);\n        map.putAll(getParameters());\n        return new URL(protocol, username, password, host, port, path, map);\n}\n```\n\n#### OverrideConfigurator实现类\n```java\npublic class OverrideConfigurator extends AbstractConfigurator {\n\n    public OverrideConfigurator(URL url) {\n        super(url);\n    }\n \n    /**\n     * @currentUrl 服务提供者url\n     * @configUrl  配置url\n     */\n    @Override\n    public URL doConfigure(URL currentUrl, URL configUrl) {\n        //将配置url中的参数添加到服务提供者url参数中\n        return currentUrl.addParameters(configUrl.getParameters());\n    }\n}\n\n/**\n * 将配置url中的参数添加到服务提供者url参数中(会覆盖)\n */\npublic URL addParameters(Map<String, String> parameters) {\n\tif (parameters == null || parameters.size() == 0) {\n\t    return this;\n\t}\n\t//参数值没有发生变化\n\tboolean hasAndEqual = true;\n\tfor (Map.Entry<String, String> entry : parameters.entrySet()) {\n\t    //获取当前服务提供者url的参数值\n\t    String value = getParameters().get(entry.getKey());\n\t    if (value == null) {\n\t\t//当前服务提供者url中的参数值为空，并且覆盖url中的参数值不为空\n\t\tif (entry.getValue() != null) {\n\t\t    hasAndEqual = false;\n\t\t    break;\n\t\t}\n\t    } else {\n\t\t//当前服务提供者url中的参数值不为空，并且和覆盖url中的参数值不相等\n\t\tif (!value.equals(entry.getValue())) {\n\t\t    hasAndEqual = false;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tif (hasAndEqual) {\n\t    //没有发生变化。立即返回\n\t    return this;\n\t}\n\tMap<String, String> map = new HashMap<String, String>(getParameters());\n\t//使用配置url中的参数值覆盖当前服务提供者url中的参数值\n\tmap.putAll(parameters);\n\treturn new URL(protocol, username, password, host, port, path, map);\n}\n```\n\n#### 配置工厂类\n工厂类用来创建相应的配置策略实现类\n```java\npublic class AbsentConfiguratorFactory implements ConfiguratorFactory {\n    @Override\n    public Configurator getConfigurator(URL url) {\n        return new AbsentConfigurator(url);\n    }\n}\n\npublic class OverrideConfiguratorFactory implements ConfiguratorFactory {\n    @Override\n    public Configurator getConfigurator(URL url) {\n        return new OverrideConfigurator(url);\n    }\n}\n```\n配置扩展\n```java\noverride=com.alibaba.dubbo.rpc.cluster.configurator.override.OverrideConfiguratorFactory\nabsent=com.alibaba.dubbo.rpc.cluster.configurator.absent.AbsentConfiguratorFactory\n```\n\n自定义的配置策略实现，可以自行参照AbsentConfigurator类进行实现，本小节就先介绍到这里了。","tags":["dubbo"]},{"title":"Netty4.1源码阅读之common包-001","url":"/blog/2018/09/04/Netty4-1源码阅读之common包-001/","tags":["netty"]},{"title":"Dubbo源码阅读之Router","url":"/blog/2018/08/30/Dubbo源码阅读之Router/","content":">Router负责从多个Invoker中按路由规则选出子集,比如读写分离,应用隔离,白名单等\n路由规则确定一个服务调用的目标服务器.它有两种路由规则：条件路由规则和脚本路由规则。同时也支持扩展。\n![](img/read-write.png)\n![](img/rule.png)\n\nRouter相关类图如下：\n![](img/router.jpg)\n\n在AbstractDirectory抽象类的list方法，以及RegistryDirectory类的route方法中将会调用Router类的route方法筛选invoker列表。\n```java\n//AbstractDirectory抽象类的list方法\n@Override\npublic List<Invoker<T>> list(Invocation invocation) throws RpcException {\n\tif (destroyed) {\n\t    throw new RpcException(\"Directory already destroyed .url: \" + getUrl());\n\t}\n\t//根据invocation获取invokers列表(根据方法名查询缓存methodInvokerMap)\n\tList<Invoker<T>> invokers = doList(invocation);\n\tList<Router> localRouters = this.routers;\n\tif (localRouters != null && !localRouters.isEmpty()) {\n\t    //遍历路由\n\t    for (Router router : localRouters) {\n\t\ttry {\n\t\t    if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) {\n\t\t\t//如果url的runtime配置为true,则每次都会进行route\n\t\t\t//执行路由，进行过滤\n\t\t\tinvokers = router.route(invokers, getConsumerUrl(), invocation);\n\t\t    }\n\t\t} catch (Throwable t) {\n\t\t    logger.error(\"Failed to execute router: \" + getUrl() + \", cause: \" + t.getMessage(), t);\n\t\t}\n\t    }\n\t}\n\treturn invokers;\n}\n\n//RegistryDirectory类的route方法中\nprivate List<Invoker<T>> route(List<Invoker<T>> invokers, String method) {\n\t//创建Invocation对象\n\tInvocation invocation = new RpcInvocation(method, new Class<?>[0], new Object[0]);\n\t//获取路由列表\n\tList<Router> routers = getRouters();\n\tif (routers != null) {\n\t    for (Router router : routers) {\n\t\tif (router.getUrl() != null) {\n\t\t    //执行路由\n\t\t    invokers = router.route(invokers, getConsumerUrl(), invocation);\n\t\t}\n\t    }\n\t}\n\treturn invokers;\n}\n```\n\n### Router接口\n```java\npublic interface Router extends Comparable<Router> {\n\n    /**\n     * 获取路由url\n     * @return url\n     */\n    URL getUrl();\n\n    /**\n     * 执行路由\n     * @param invokers\n     * @param url  refer url\n     * @param invocation\n     * @return routed invokers\n     */\n    <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException;\n}\n```\n#### ConditionRouter实现类\nConditionRouter：基于条件表达式的路由规则，它的条件规则如下：\n* => 之前的为消费者匹配条件，所有参数和消费者的 URL 进行对比，当消费者满足匹配条件时，对该消费者执行后面的过滤规则。\n* => 之后为提供者地址列表的过滤条件，所有参数和提供者的 URL 进行对比，消费者最终只拿到过滤后的地址列表。\n* 如果匹配条件为空，表示对所有消费方应用，如：=> host != 10.20.153.11\n* 如果过滤条件为空，表示禁止访问，如：host = 10.20.153.10 =>\n```java\npublic class ConditionRouter implements Router, Comparable<Router> {\n\n    private static final Logger logger = LoggerFactory.getLogger(ConditionRouter.class);\n\n    /**\n     * 路由正则\n     */\n    private static Pattern ROUTE_PATTERN = Pattern.compile(\"([&!=,]*)\\\\s*([^&!=,\\\\s]+)\");\n    /**\n     * 路由url\n     */\n    private final URL url;\n    /**\n     * 优先级 优先级越大排得越靠前，默认为0\n     */\n    private final int priority;\n    /**\n     * 是否强制执行路由\n     */\n    private final boolean force;\n    /**\n     * <method,[list*,get*]>\n     */\n    private final Map<String, MatchPair> whenCondition;\n    /**\n     * <host,[192.168.99.60]>\n     */\n    private final Map<String, MatchPair> thenCondition;\n\n    public ConditionRouter(URL url) {\n        this.url = url;\n        //从url中获取priority参数\n        this.priority = url.getParameter(Constants.PRIORITY_KEY, 0);\n        //从url中获取force参数\n        this.force = url.getParameter(Constants.FORCE_KEY, false);\n        try {\n            //从url中获取rule参数，并解码\n            String rule = url.getParameterAndDecoded(Constants.RULE_KEY);\n            if (rule == null || rule.trim().length() == 0) {\n                //无效的路由规则\n                throw new IllegalArgumentException(\"Illegal route rule!\");\n            }\n            //从路由规则中移除consumer.和provider.\n            rule = rule.replace(\"consumer.\", \"\").replace(\"provider.\", \"\");\n            //查看路由规则中是否存在\"=>\"符号，并获取出现的位置i\n            int i = rule.indexOf(\"=>\");\n            //如果路由规则中不存在=>符号，则when为null,否则=>符号的左侧部分为when\n            String whenRule = i < 0 ? null : rule.substring(0, i).trim();\n            //如果路由规则中不存在=>符号，则整个路由规则都是then，否则=>符号右侧部分为then\n            String thenRule = i < 0 ? rule.trim() : rule.substring(i + 2).trim();\n            //解析规则\n            Map<String, MatchPair> when = StringUtils.isBlank(whenRule) || \"true\".equals(whenRule) ? new HashMap<String, MatchPair>() : parseRule(whenRule);\n            Map<String, MatchPair> then = StringUtils.isBlank(thenRule) || \"false\".equals(thenRule) ? null : parseRule(thenRule);\n            // NOTE: It should be determined on the business level whether the `When condition` can be empty or not.\n            //提示：应该在业务层面搞定`When condition` 是否可以为empty 或者not empty\n            this.whenCondition = when;\n            this.thenCondition = then;\n        } catch (ParseException e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    /**\n     * 解析规则\n     * @param rule\n     * @return\n     * @throws ParseException\n     */\n    private static Map<String, MatchPair> parseRule(String rule) throws ParseException {\n        Map<String, MatchPair> condition = new HashMap<String, MatchPair>();\n        if (StringUtils.isBlank(rule)) {\n            //路由规则为空，则直接返回\n            return condition;\n        }\n        //kv对，存储匹配和不匹配的条件\n        MatchPair pair = null;\n        // 多个值 \n        Set<String> values = null;\n        //使用正则进行匹配 method = find*,list*,get*,is*\n        final Matcher matcher = ROUTE_PATTERN.matcher(rule);\n        //尝试逐一匹配\n        while (matcher.find()) {\n            String separator = matcher.group(1);\n            String content = matcher.group(2);\n            //条件表达式的开始部分\n            if (separator == null || separator.length() == 0) {\n                pair = new MatchPair();\n                condition.put(content, pair);\n            }\n            //条件表达式的KV部分\n            else if (\"&\".equals(separator)) {\n                if (condition.get(content) == null) {\n                    pair = new MatchPair();\n                    condition.put(content, pair);\n                } else {\n                    pair = condition.get(content);\n                }\n            }\n            //KV部分的值\n            else if (\"=\".equals(separator)) {\n                if (pair == null) {\n                    throw new ParseException(\"Illegal route rule \\\"\"\n                            + rule + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\", matcher.start());\n                }\n                values = pair.matches;\n                values.add(content);\n            }\n            else if (\"!=\".equals(separator)) {\n                if (pair == null) {\n                    throw new ParseException(\"Illegal route rule \\\"\"\n                            + rule + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\", matcher.start());\n                }\n                values = pair.mismatches;\n                values.add(content);\n            }\n            // kv的value部分，其中value有多个值，使用逗号分隔\n            else if (\",\".equals(separator)) { // Should be seperateed by ','\n                if (values == null || values.isEmpty()) {\n                    throw new ParseException(\"Illegal route rule \\\"\"\n                            + rule + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\", matcher.start());\n                }\n                values.add(content);\n            } else {\n                throw new ParseException(\"Illegal route rule \\\"\" + rule\n                        + \"\\\", The error char '\" + separator + \"' at index \"\n                        + matcher.start() + \" before \\\"\" + content + \"\\\".\", matcher.start());\n            }\n        }\n        return condition;\n    }\n\n    @Override\n    public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation)\n            throws RpcException {\n        if (invokers == null || invokers.isEmpty()) {\n            return invokers;\n        }\n        try {\n            if (!matchWhen(url, invocation)) {\n\t        //不匹配when规则，直接返回\n                return invokers;\n            }\n            List<Invoker<T>> result = new ArrayList<Invoker<T>>();\n            if (thenCondition == null) {\n\t        //当前消费者在服务黑名单里\n                logger.warn(\"The current consumer in the service blacklist. consumer: \" + NetUtils.getLocalHost() + \", service: \" + url.getServiceKey());\n                return result;\n            }\n            for (Invoker<T> invoker : invokers) {\n                if (matchThen(invoker.getUrl(), url)) {\n\t\t    //成功匹配then规则，添加到结果集\n                    result.add(invoker);\n                }\n            }\n            if (!result.isEmpty()) {\n                return result;\n            } else if (force) { \n\t        //强制执行 \n                logger.warn(\"The route result is empty and force execute. consumer: \" + NetUtils.getLocalHost() + \", service: \" + url.getServiceKey() + \", router: \" + url.getParameterAndDecoded(Constants.RULE_KEY));\n                return result;\n            }\n        } catch (Throwable t) {\n            logger.error(\"Failed to execute condition router rule: \" + getUrl() + \", invokers: \" + invokers + \", cause: \" + t.getMessage(), t);\n        }\n\t//没有一个符合规则的Provider,则直接返回。5\n        return invokers;\n    }\n\n    @Override\n    public URL getUrl() {\n        return url;\n    }\n\t\n    //是否匹配when规则\n    boolean matchWhen(URL url, Invocation invocation) {\n        return whenCondition == null || whenCondition.isEmpty() || matchCondition(whenCondition, url, null, invocation);\n    }\n    \n    //url参数为invoker的url属性\n    private boolean matchThen(URL url, URL param) {\n        //then规则不为空，且匹配then规则，则返回true\n        return !(thenCondition == null || thenCondition.isEmpty()) && matchCondition(thenCondition, url, param, null);\n    }\n\n    /**\n     * 匹配条件\n     * @param condition\n     * @param url\n     * @param param\n     * @param invocation\n     * @return\n     */\n    private boolean matchCondition(Map<String, MatchPair> condition, URL url, URL param, Invocation invocation) {\n        //获取url参数，即消费者的parameters的Map集合\n\tMap<String, String> sample = url.toMap();\n        boolean result = false;\n        for (Map.Entry<String, MatchPair> matchPair : condition.entrySet()) {\n            //例如：method，或者url中的某个参数\n\t    String key = matchPair.getKey();\n            String sampleValue;\n            if (invocation != null && (Constants.METHOD_KEY.equals(key) || Constants.METHODS_KEY.equals(key))) {\n                //key=method，则从invocation中获取真实方法名\n\t\tsampleValue = invocation.getMethodName();\n            } else {\n\t        //从url参数中获取key对应的值\n                sampleValue = sample.get(key);\n                if (sampleValue == null) {\n\t\t    //添加前缀default.进行获取\n                    sampleValue = sample.get(Constants.DEFAULT_KEY_PREFIX + key);\n                }\n            }\n            if (sampleValue != null) {\n\t        //调用MatchPair的isMatch方法进行匹配\n                if (!matchPair.getValue().isMatch(sampleValue, param)) {\n                    return false;\n                } else {\n                    result = true;\n                }\n            } else {\n                if (!matchPair.getValue().matches.isEmpty()) {\n                    return false;\n                } else {\n                    result = true;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * 内部类\n     */\n    private static final class MatchPair {\n        final Set<String> matches = new HashSet<String>();\n        final Set<String> mismatches = new HashSet<String>();\n    \n        //value为调用的方法名，或者为url自定义参数的值\n\t//param参数为route方法的url参数，即ref url\n        private boolean isMatch(String value, URL param) {\n            if (!matches.isEmpty() && mismatches.isEmpty()) {\n                //存在=，不存在!=\n                for (String match : matches) {\n                    //进行匹配\n                    if (UrlUtils.isMatchGlobPattern(match, value, param)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            if (!mismatches.isEmpty() && matches.isEmpty()) {\n                //存在!=,不存在=\n                for (String mismatch : mismatches) {\n                    if (UrlUtils.isMatchGlobPattern(mismatch, value, param)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            if (!matches.isEmpty() && !mismatches.isEmpty()) {\n                //存在=，也存在!=,优先使用!=\n                for (String mismatch : mismatches) {\n                    if (UrlUtils.isMatchGlobPattern(mismatch, value, param)) {\n                        return false;\n                    }\n                }\n                for (String match : matches) {\n                    if (UrlUtils.isMatchGlobPattern(match, value, param)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            return false;\n        }\n    }\n}\n\n//param参数为route方法的url参数\npublic static boolean isMatchGlobPattern(String pattern, String value, URL param) {\n\tif (param != null && pattern.startsWith(\"$\")) {\n\t    pattern = param.getRawParameter(pattern.substring(1));\n\t}\n\treturn isMatchGlobPattern(pattern, value);\n}\n\npublic static boolean isMatchGlobPattern(String pattern, String value) {\n\tif (\"*\".equals(pattern)) {\n\t    return true;\n\t}\n\tif ((pattern == null || pattern.length() == 0) && (value == null || value.length() == 0)) {\n\t    return true;\n\t}\n\tif ((pattern == null || pattern.length() == 0) || (value == null || value.length() == 0)) {\n\t    return false;\n\t}\n        //获取*号最后出现的位置\n\tint i = pattern.lastIndexOf('*');\n\t// 没有 \"*\"\n\tif (i == -1) {\n\t    return value.equals(pattern);\n\t}\n\t// \"*\" 为最后\n\telse if (i == pattern.length() - 1) {\n\t    return value.startsWith(pattern.substring(0, i));\n\t}\n\t// \"*\" 在开始处\n\telse if (i == 0) {\n\t    return value.endsWith(pattern.substring(i + 1));\n\t}\n\t// \"*\" 在中间\n\telse {\n\t    String prefix = pattern.substring(0, i);\n\t    String suffix = pattern.substring(i + 1);\n\t    return value.startsWith(prefix) && value.endsWith(suffix);\n\t}\n}\n```\n\n##### 调试parseRule方法\n我们使用一个例子来debug下parseRule方法\n```java\npublic static void main(String[] args) throws ParseException {\n        //我们定义一个规则：method = find*,list*,get*,is* => host = 192.168.99.60,192.168.99.61\n\tString rule = \"method = find*,list*,get*,is* => host = 192.168.99.60,192.168.99.61\";\n\t\n\trule = rule.replace(\"consumer.\", \"\").replace(\"provider.\", \"\");\n\t\n\t//查看路由规则中是否存在\"=>\"符号，并获取出现的位置i\n\tint i = rule.indexOf(\"=>\");\n\tString whenRule = i < 0 ? null : rule.substring(0, i).trim();\n\t\n\t//如果路由规则中不存在=>符号，则整个路由规则都是then，否则=>符号右侧部分为then\n\tString thenRule = i < 0 ? rule.trim() : rule.substring(i + 2).trim();\n\t\n\t//解析规则\n\tMap<String, MatchPair> when = StringUtils.isBlank(whenRule) || \"true\".equals(whenRule) ? new HashMap<String, MatchPair>() : parseRule(whenRule);\n\tMap<String, MatchPair> then = StringUtils.isBlank(thenRule) || \"false\".equals(thenRule) ? null : parseRule(thenRule);\n}\n\n//parseRule方法部分源码\nMap<String, MatchPair> condition = new HashMap<String, MatchPair>();\nfinal Matcher matcher = ROUTE_PATTERN.matcher(rule);\n//尝试逐一匹配\nwhile (matcher.find()) {\n    String separator = matcher.group(1);\n    String content = matcher.group(2);\n}\n```\n当解析when规则的时候，在while循环中将会依次解析出如下值(第二个分割线以下的内容是解析then时的结果)：\n```java\nseparator   content\n------------------------------------\n    \"\"      method(第一次遍历)\n    =\t    find*\n    ,       list*\n    ,       get*\n    ,       is*\n------------------------------------\n    \"\"\t    host\n    =       192.168.99.60\n    ,       192.168.99.61\n```\n其中第一次遍历时，separator为空，content为method，此时将会新建一个MatchPair对象，然后放入到condition哈希中，后面的遍历将会按照separator值的不同进入到不同的分支，然后把content值加入到MatchPair对象的matches集合中(separator为=号则放入matches集合,为!=则放入mismatches集合中)。\n```java\nif (separator == null || separator.length() == 0) {\n\tpair = new MatchPair();\n\tcondition.put(content, pair);\n}\n```\n解析then规则的过程类似，这里就不介绍了。\n\n\n#### ScriptRouter实现类\n![](img/ScriptRouter.png)\n```java\npublic class ScriptRouter implements Router {\n\n    /**\n     * <脚本类型，脚本引擎>\n     */\n    private static final Map<String, ScriptEngine> engines = new ConcurrentHashMap<String, ScriptEngine>();\n\n    /**\n     * 当前使用的脚本引擎\n     */\n    private final ScriptEngine engine;\n\n    /**\n     * 优先级\n     */\n    private final int priority;\n    /**\n     * 路由规则\n     */\n    private final String rule;\n\n    /**\n     * 路由url\n     */\n    private final URL url;\n\n    public ScriptRouter(URL url) {\n        this.url = url;\n        //获取url的type参数，标识脚本类型，如：js、groovy\n        String type = url.getParameter(Constants.TYPE_KEY);\n        //获取url的priority参数，标识优先级\n        this.priority = url.getParameter(Constants.PRIORITY_KEY, 0);\n        //获取url的rule参数，标识脚本规则\n        String rule = url.getParameterAndDecoded(Constants.RULE_KEY);\n        if (type == null || type.length() == 0) {\n            //默认脚本类型，javascript\n            type = Constants.DEFAULT_SCRIPT_TYPE_KEY;\n        }\n        if (rule == null || rule.length() == 0) {\n            //路由规则不可以为空\n            throw new IllegalStateException(new IllegalStateException(\"route rule can not be empty. rule:\" + rule));\n        }\n        //根据脚本类型,从缓存中获取脚本引擎\n        ScriptEngine engine = engines.get(type);\n        if (engine == null) {\n            //根据脚本类型type创建一个脚本引擎\n            engine = new ScriptEngineManager().getEngineByName(type);\n            if (engine == null) {\n                throw new IllegalStateException(new IllegalStateException(\"Unsupported route rule type: \" + type + \", rule: \" + rule));\n            }\n            //放入缓存\n            engines.put(type, engine);\n        }\n        this.engine = engine;\n        this.rule = rule;\n    }\n\n    @Override\n    public URL getUrl() {\n        return url;\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {\n        try {\n            List<Invoker<T>> invokersCopy = new ArrayList<Invoker<T>>(invokers);\n            Compilable compilable = (Compilable) engine;\n            //将参数传递到脚本引擎\n            Bindings bindings = engine.createBindings();\n            bindings.put(\"invokers\", invokersCopy);\n            bindings.put(\"invocation\", invocation);\n            bindings.put(\"context\", RpcContext.getContext());\n            //编译规则脚本\n            CompiledScript function = compilable.compile(rule);\n            //执行脚本，返回筛选后的invokers列表\n            Object obj = function.eval(bindings);\n            if (obj instanceof Invoker[]) {\n                invokersCopy = Arrays.asList((Invoker<T>[]) obj);\n            } else if (obj instanceof Object[]) {\n                invokersCopy = new ArrayList<Invoker<T>>();\n                for (Object inv : (Object[]) obj) {\n                    invokersCopy.add((Invoker<T>) inv);\n                }\n            } else {\n                invokersCopy = (List<Invoker<T>>) obj;\n            }\n            return invokersCopy;\n        } catch (ScriptException e) {\n            //fail then ignore rule .invokers.\n            logger.error(\"route error , rule has been ignored. rule: \" + rule + \", method:\" + invocation.getMethodName() + \", url: \" + RpcContext.getContext().getUrl(), e);\n            return invokers;\n        }\n    }\n}\n```\n\n#### MockInvokersSelector实现类\nMockInvokersSelector：其实就是用于路由 Mock 服务与非Mock服务。\nDubbo默认会在AbstractDirectory#setRouters方法中自动添加MockInvokersSelector路由规则。\n```java\npublic class MockInvokersSelector implements Router{\n\n    @Override\n    public <T> List<Invoker<T>> route(final List<Invoker<T>> invokers,URL url, final Invocation invocation) throws RpcException {\n        if (invocation.getAttachments() == null) {\n            //附加参数为空\n            //返回不支持mock协议的invoker\n            return getNormalInvokers(invokers);\n        } else {\n            //从附加参数中获取invocation.need.mock属性的值\n            String value = invocation.getAttachments().get(Constants.INVOCATION_NEED_MOCK);\n            if (value == null) {\n                //返回不支持mock协议的invoker\n                return getNormalInvokers(invokers);\n            } else if (Boolean.TRUE.toString().equalsIgnoreCase(value)) {\n                //如果invocation.need.mock = true,则返回mock-Invokers\n                return getMockedInvokers(invokers);\n            }\n        }\n        return invokers;\n    }\n    ....省略其他方法....\n}\n\npublic abstract class AbstractDirectory<T> implements Directory<T> {\n    \n    /**\n     * 设置路由\n     * 1、添加：收到notify通知的routers、当前url的router参数、new MockInvokersSelector()\n     * 2、将routers排序\n     * 3、缓存routers\n     * @param routers 收到notify通知的routers\n     */\n    protected void setRouters(List<Router> routers) {\n        routers = routers == null ? new ArrayList<Router>() : new ArrayList<Router>(routers);\n        //获取路由器工厂扩展名称，router参数\n        String routerkey = url.getParameter(Constants.ROUTER_KEY);\n        if (routerkey != null && routerkey.length() > 0) {\n            //根据路由器工厂扩展名获取扩展实例\n            RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getExtension(routerkey);\n            //根据url获取路由器实例，并放入routers\n            routers.add(routerFactory.getRouter(url));\n        }\n        //添加支持mock协议的invoker选择器\n        routers.add(new MockInvokersSelector());\n        //排序\n        Collections.sort(routers);\n        this.routers = routers;\n    }\n    ....省略其他方法....\n}\n \n```\n\n#### 自定义Router\n假如我们的服务提供者分为多个不同的组，我们想要根据某个调用参数调用不同的组。\n我们可以自定义一个CustomRouter类，然后实现route方法。\n\n```java\npublic class CustomRouter extends ConditionRouter{\n\n    @Override\n    public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation)throws RpcException {\n        if (invokers == null || invokers.isEmpty()) {\n            return invokers;\n        }\n\t//获取调用参数\n\tObject[] arguments = invocation.getArguments();\n        if(arguments == null || arguments.length == 0){\n            logger.error(\"方法: {} 缺少路由参数routeKey\",invocation.getMethodName());\n            return null;\n        }\n\t//获取路由key\n        Object routeKey = arguments[0];\n\tString consumerGroup = getGroup(routeKey);\n\t//String consumerGroup = url.getParameter(Constants.GROUP_KEY);\n\n        List<Invoker<T>> result = new ArrayList<Invoker<T>>();\n\tfor (Invoker<T> invoker : invokers) {\n\t    //获取服务提供者的group参数\n            String group = invoker.getUrl().getParameter(Constants.GROUP_KEY);\n            \n\t    //判断当前服务提供者的group是否和当前调用参数中的group是否匹配\n\t    if (consumerGroup.equals(group)) {\n\t        //匹配的话，则保存当前服务提供者\n                result.add(invoker);\n            }\n        }\n\tif(result.size() > 0){\n\t   //返回匹配的服务提供者组\n\t   return result;\n\t}\n        return invokers;\n    }\n    \n    /**\n     * 获取group\n     */\n    private String getGroup(String routeKey){\n\tif(routeKey.endsWith(\"1\")){\n\t   return \"v1\";\n\t}else{\n\t   return \"v2\";\n\t}\n    }\n}\n\n/**\n * 工厂\n */\npublic class CustomRouterFactory implements RouterFactory {\n\n    public static final String NAME = \"custom\";\n\n    @Override\n    public Router getRouter(URL url) {\n        return new CustomRouter(url);\n    }\n\n}\n```\n\n然后我们配置扩展，让dubbo可以自动发现。\n```java\ncustom=com.alibaba.dubbo.rpc.cluster.router.custom.CustomRouterFactory\n```\n\n然后配置路由规则，例如可以在RegistryProtocol类的register方法中加入添加路由规则进行断点测试。\n```java\npublic void register(URL registryUrl, URL registedProviderUrl) {\n        //获取注册中心\n\tRegistry registry = registryFactory.getRegistry(registryUrl);\n\t//注册服务提供者\n\tregistry.register(registedProviderUrl);\n\t\n\t//测试代码(添加路由规则),group=foo标识对指定的foo组生效\n\t#URL routerUrl = URL.valueOf(\"routers://0.0.0.0/com.alibaba.dubbo.demo.DemoService?name=test&category=routers&router=custom&dynamic=false&version=1.0&group=foo\");\n\tURL routerUrl = URL.valueOf(\"routers://0.0.0.0/com.alibaba.dubbo.demo.DemoService?name=test&category=routers&router=custom&dynamic=false\");\n\tregistry.register(routerUrl);\n}\n```\n\n最后模拟消费者调用进行测试即可。\n\n\n\n\n\n\n\n\n\n\n\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之服务引用","url":"/blog/2018/08/23/Dubbo源码阅读之服务引用/","content":">本小节讲解上小节遗留的ref = createProxy(map)方法，不了解的可以先看下上篇文章《Dubbo源码阅读之集成Spring-0202注解解析》\n\n该方法定义在ReferenceConfig类中，在调用init方法进行初始化时，会调用createProxy方法来生成代理对象。\n\n### createProxy创建代理\n```java\n/**\n * 创建代理\n */\nprivate T createProxy(Map<String, String> map) {\n\tURL tmpUrl = new URL(\"temp\", \"localhost\", 0, map);\n\tfinal boolean isJvmRefer;\n\t//是否引用本地服务，新版使用： scope=local来判断\n\tif (isInjvm() == null) {\n\t    if (url != null && url.length() > 0) {\n\t\t//如果配置中指定了url属性，则不使用本地引用\n\t\tisJvmRefer = false;\n\t    } else if (InjvmProtocol.getInjvmProtocol().isInjvmRefer(tmpUrl)) {\n\t\t//默认情况下，如果有本地服务，则引用本地服务\n\t\tisJvmRefer = true;\n\t    } else {\n\t\tisJvmRefer = false;\n\t    }\n\t} else {\n\t    isJvmRefer = isInjvm().booleanValue();\n\t}\n\tif (isJvmRefer) {\n\t    //构建本地协议\n\t    URL url = new URL(Constants.LOCAL_PROTOCOL, NetUtils.LOCALHOST, 0, interfaceClass.getName()).addParameters(map);\n\t    //引用本地服务(后面会分析该方法)\n\t    invoker = refprotocol.refer(interfaceClass, url);\n\t    if (logger.isInfoEnabled()) {\n\t\tlogger.info(\"Using injvm service \" + interfaceClass.getName());\n\t    }\n\t} else {\n\t    if (url != null && url.length() > 0) {\n\t\t//用户指定了URL属性，可以是p2p地址或者注册中心的地址，多个地址使用\";\"分隔\n\t\tString[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);\n\t\tif (us != null && us.length > 0) {\n\t\t    for (String u : us) {\n\t\t\tURL url = URL.valueOf(u);\n\t\t\tif (url.getPath() == null || url.getPath().length() == 0) {\n\t\t\t    //path为空时，使用服务接口名称作为path\n\t\t\t    url = url.setPath(interfaceName);\n\t\t\t}\n\t\t\tif (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n\t\t\t    //注册中心协议，添加引用标识refer参数\n\t\t\t    urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));\n\t\t\t} else {\n\t\t\t    //p2p地址(后面会分析该方法)\n\t\t\t    urls.add(ClusterUtils.mergeUrl(url, map));\n\t\t\t}\n\t\t    }\n\t\t}\n\t    } else {\n\t\t//从注册中心配置中组装URL(后面会分析该方法)\n\t\tList<URL> us = loadRegistries(false);\n\t\tif (us != null && !us.isEmpty()) {\n\t\t    //遍历注册中心us(后面会分析该方法)\n\t\t    for (URL u : us) {\n\t\t\t//加载监控url(后面会分析该方法)\n\t\t\tURL monitorUrl = loadMonitor(u);\n\t\t\tif (monitorUrl != null) {\n\t\t\t    //添加monitor参数\n\t\t\t    map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));\n\t\t\t}\n\t\t\t//添加refer参数\n\t\t\turls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));\n\t\t    }\n\t\t}\n\t\tif (urls == null || urls.isEmpty()) {\n\t\t    //在消费者端，没有配置注册中心，因此无法引用相应服务接口\n\t\t    throw new IllegalStateException(\"No such any registry to reference \" + interfaceName + \" on the consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion() + \", please config <dubbo:registry address=\\\"...\\\" /> to your spring config.\");\n\t\t}\n\t    }\n\t    if (urls.size() == 1) {\n\t\t//引用一个远程服务(后面会分析该方法)\n\t\t//registry://172.172.172.47:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&dubbo=2.0.0&pid=1172&qos.port=33333&refer=application%3Ddemo-consumer%26check%3Dfalse%26dubbo%3D2.0.0%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D1172%26qos.port%3D33333%26register.ip%3D192.168.99.60%26side%3Dconsumer%26timestamp%3D1535094943004&registry=zookeeper&timestamp=1535095022853\n\t\tinvoker = refprotocol.refer(interfaceClass, urls.get(0));\n\t    } else {\n\t\t//如果有多个url\n\t\tList<Invoker<?>> invokers = new ArrayList<Invoker<?>>();\n\t\tURL registryURL = null;\n\t\tfor (URL url : urls) {\n\t\t    //记录\"远程引用\"\n\t\t    invokers.add(refprotocol.refer(interfaceClass, url));\n\t\t    if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n\t\t\t//使用最后一个注册中心url\n\t\t\tregistryURL = url;\n\t\t    }\n\t\t}\n\t\tif (registryURL != null) {\n\t\t    //有注册中心协议的URL，使用AvailableCluster\n\t\t    URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);\n\t\t    invoker = cluster.join(new StaticDirectory(u, invokers));\n\t\t} else { \n\t\t    //不是注册中心的url\n\t\t    invoker = cluster.join(new StaticDirectory(invokers));\n\t\t}\n\t    }\n\t}\n\t//检测服务提供者是否存在\n\tBoolean c = check;\n\tif (c == null && consumer != null) {\n\t    c = consumer.isCheck();\n\t}\n\tif (c == null) {\n\t    //默认需要检测服务提供者是否存在\n\t    c = true;\n\t}\n\t//检测服务提供者是否存在\n\tif (c && !invoker.isAvailable()) {\n\t    throw new IllegalStateException(\"Failed to check the status of the service \" + interfaceName + \". No provider available for the service \" + (group == null ? \"\" : group + \"/\") + interfaceName + (version == null ? \"\" : \":\" + version) + \" from the url \" + invoker.getUrl() + \" to the consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion());\n\t}\n\tif (logger.isInfoEnabled()) {\n\t    logger.info(\"Refer dubbo service \" + interfaceClass.getName() + \" from url \" + invoker.getUrl());\n\t}\n\t//创建服务代理\n\treturn (T) proxyFactory.getProxy(invoker);\n}\n\n/**\n * 构造注册中心URL\n * @param provider\n * @return\n */\nprotected List<URL> loadRegistries(boolean provider) {\n\t//检测是否配置了RegistryConfig，并配置\n\tcheckRegistry();\n\tList<URL> registryList = new ArrayList<URL>();\n\tif (registries != null && !registries.isEmpty()) {\n\t    //遍历注册中心配置\n\t    for (RegistryConfig config : registries) {\n\t\t//获取当前注册中心地址，例如： zookeeper://172.172.172.47:2181\n\t\tString address = config.getAddress();\n\t\tif (address == null || address.length() == 0) {\n\t\t    //设置address = 0.0.0.0\n\t\t    address = Constants.ANYHOST_VALUE;\n\t\t}\n\t\t//从系统配置中获取注册中心地址\n\t\tString sysaddress = System.getProperty(\"dubbo.registry.address\");\n\t\tif (sysaddress != null && sysaddress.length() > 0) {\n\t\t    //如果系统配置的注册中心地址不为空，则优先使用系统配置\n\t\t    address = sysaddress;\n\t\t}\n\t\tif (address != null && address.length() > 0\n\t\t\t&& !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) {\n\t\t    //注册中心地址可用\n\t\t    Map<String, String> map = new HashMap<String, String>();\n\t\t    //附加参数，即找到application、config类中的属性，并添加进来\n\t\t    appendParameters(map, application);\n\t\t    appendParameters(map, config);\n\t\t    map.put(\"path\", RegistryService.class.getName());\n\t\t    map.put(\"dubbo\", Version.getVersion());\n\t\t    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n\t\t    if (ConfigUtils.getPid() > 0) {\n\t\t\tmap.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n\t\t    }\n\t\t    if (!map.containsKey(\"protocol\")) {\n\t\t\t//添加protocol参数\n\t\t\tif (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension(\"remote\")) {\n\t\t\t    map.put(\"protocol\", \"remote\");\n\t\t\t} else {\n\t\t\t    map.put(\"protocol\", \"dubbo\");\n\t\t\t}\n\t\t    }\n\t\t    //根据address和map生成注册中心url\n\t\t    List<URL> urls = UrlUtils.parseURLs(address, map);\n\t\t    \n\t\t    //遍历注册中心url，添加registry参数,并设置protocol属性，然后保存起来\n\t\t    for (URL url : urls) {\n\t\t\t//url = zookeeper://172.172.172.47:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&dubbo=2.0.0&pid=1172&qos.port=33333&timestamp=1535095022853\n\t\t\t//添加registry参数 = zookeeper\n\t\t\turl = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());\n\t\t\t\n\t\t\t//重新设置协议为registry\n\t\t\turl = url.setProtocol(Constants.REGISTRY_PROTOCOL);\n\t\t\tif ((provider && url.getParameter(Constants.REGISTER_KEY, true))\n\t\t\t\t|| (!provider && url.getParameter(Constants.SUBSCRIBE_KEY, true))) {\n\t\t\t    //registry://172.172.172.47:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&dubbo=2.0.0&pid=1172&qos.port=33333&registry=zookeeper&timestamp=1535095022853\n\t\t\t    registryList.add(url);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\treturn registryList;\n}\n\n/**\n * 检测RegistryConfig配置\n */\nprotected void checkRegistry() {\n\t//向后兼容\n\tif (registries == null || registries.isEmpty()) {\n\t    //获取到注册中心属性配置值\n\t    String address = ConfigUtils.getProperty(\"dubbo.registry.address\");\n\t    if (address != null && address.length() > 0) {\n\t\tregistries = new ArrayList<RegistryConfig>();\n\t\t//使用\"|\"分隔注册中心，然后构造RegistryConfig对象\n\t\tString[] as = address.split(\"\\\\s*[|]+\\\\s*\");\n\t\tfor (String a : as) {\n\t\t    RegistryConfig registryConfig = new RegistryConfig();\n\t\t    registryConfig.setAddress(a);\n\t\t    registries.add(registryConfig);\n\t\t}\n\t    }\n\t}\n\tif ((registries == null || registries.isEmpty())) {\n\t    throw new IllegalStateException((getClass().getSimpleName().startsWith(\"Reference\")\n\t\t    ? \"No such any registry to refer service in consumer \"\n\t\t    : \"No such any registry to export service in provider \")\n\t\t    + NetUtils.getLocalHost()\n\t\t    + \" use dubbo version \"\n\t\t    + Version.getVersion()\n\t\t    + \", Please add <dubbo:registry address=\\\"...\\\" /> to your spring config. If you want unregister, please set <dubbo:service registry=\\\"N/A\\\" />\");\n\t}\n\tfor (RegistryConfig registryConfig : registries) {\n\t    //添加属性\n\t    appendProperties(registryConfig);\n\t}\n}\n```\n\n接下来我们看下Protocol的refer方法，在《Dubbo源码阅读之服务暴露》小节我们介绍过，将会生成Protocol$Adaptive类：\n```java\npublic class Protocol$Adaptive implements com.alibaba.dubbo.rpc.Protocol {\n\t/**\n\t * @param arg0 服务接口类\n\t * @param arg1 注册中心url\n\t */\n\tpublic com.alibaba.dubbo.rpc.Invoker refer(java.lang.Class arg0, com.alibaba.dubbo.common.URL arg1) throws com.alibaba.dubbo.rpc.RpcException {\n\t\tif (arg1 == null){\n\t\t\t//url参数不可以为空\n\t\t\tthrow new IllegalArgumentException(\"url == null\");\n\t\t}\n\t\t\n\t\tcom.alibaba.dubbo.common.URL url = arg1;\n\t\t\n\t\t//使用url的protocol属性值(这里为registry)，作为扩展名称，如果为空，则默认使用\"dubbo\"\n\t\tString extName = url.getProtocol() == null ? \"dubbo\" : url.getProtocol();\n\t\t\n\t\tif(extName == null) {\n\t\t\tthrow new IllegalStateException(\"Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(\" + url.toString() + \") use keys([protocol])\");\n\t\t}\n\t\t\n\t\t//获取扩展名称为extName的Protocol扩展实例(这里可能是被包装过的类)\n\t\tcom.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);\n\t\t\n\t\t//调用该extension实例的refer方法\n\t\treturn extension.refer(arg0, arg1);\n\t}\n}\n```\n这里和服务暴露时的流程一样，将会调用两个包装类ProtocolFilterWrapper和ProtocolListenerWrapper的refer方法。\n```java\npublic class ProtocolFilterWrapper implements Protocol {\n\t@Override\n\tpublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n\t\tif (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n\t\t    //这里将会调用ProtocolListenerWrapper类的refer方法\n\t\t    return protocol.refer(type, url);\n\t\t}\n\t\treturn buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);\n\t}\n}\n\npublic class ProtocolListenerWrapper implements Protocol {\n\t/**\n\t * @param type interface com.alibaba.dubbo.demo.DemoService\n\t * @param url  registry://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&dubbo=2.0.0&pid=1512&qos.port=33333&refer=application%3Ddemo-consumer%26check%3Dfalse%26dubbo%3D2.0.0%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D1512%26qos.port%3D33333%26register.ip%3D192.168.99.60%26side%3Dconsumer%26timestamp%3D1528340394760&registry=multicast&timestamp=1528340417091\n\t * @param <T>\n\t * @return\n\t * @throws RpcException\n\t */\n\t@Override\n\tpublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n\t\tif (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n\t\t    //这里将会调用RegistryProtocol类的refer方法\n\t\t    return protocol.refer(type, url);\n\t\t}\n\t\treturn new ListenerInvokerWrapper<T>(protocol.refer(type, url),\n\t\t\tCollections.unmodifiableList(\n\t\t\t\tExtensionLoader.getExtensionLoader(InvokerListener.class)\n\t\t\t\t\t.getActivateExtension(url, Constants.INVOKER_LISTENER_KEY)));\n\t}\n}\n```\nRegistryProtocol的refer方法：\n```java\n/**\n * @param type远程服务接口类型\n * @param url 远程服务的URL地址\n * registry://172.172.172.47:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&dubbo=2.0.0&pid=1172&qos.port=33333&refer=application%3Ddemo-consumer%26check%3Dfalse%26dubbo%3D2.0.0%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D1172%26qos.port%3D33333%26register.ip%3D192.168.99.60%26side%3Dconsumer%26timestamp%3D1535094943004&registry=zookeeper&timestamp=1535095022853\n * @return\n * @throws RpcException\n */\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n\t//生成注册中心url\n\turl = url.setProtocol(\n\t\t//设置协议，从url中的registry参数中获取注册时的协议(zookeeper)，没有获取到的话，则默认为dubbo协议\n\t\turl.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_REGISTRY)\n\t\t//然后移除registry参数\n\t).removeParameter(Constants.REGISTRY_KEY);\n\n\t//根据url获取注册中心\n\t//zookeeper://172.172.172.47:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&dubbo=2.0.0&pid=1172&qos.port=33333&refer=application%3Ddemo-consumer%26check%3Dfalse%26dubbo%3D2.0.0%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D1172%26qos.port%3D33333%26register.ip%3D192.168.99.60%26side%3Dconsumer%26timestamp%3D1535094943004&timestamp=1535095022853\n\tRegistry registry = registryFactory.getRegistry(url);\n\tif (RegistryService.class.equals(type)) {\n\t    return proxyFactory.getInvoker((T) registry, type, url);\n\t}\n\n\t//获取url中的refer参数，并转换成map\n\tMap<String, String> qs = StringUtils.parseQueryString(\n\t\turl.getParameterAndDecoded(Constants.REFER_KEY)\n\t);\n\t//获取map中的group参数\n\tString group = qs.get(Constants.GROUP_KEY);\n\tif (group != null && group.length() > 0) {\n\t    if ((Constants.COMMA_SPLIT_PATTERN.split(group)).length > 1\n\t\t    || \"*\".equals(group)) {\n\t\t//group=\"a,b\" or group=\"*\"\n\t\treturn doRefer(getMergeableCluster(), registry, type, url);\n\t    }\n\t}\n\treturn doRefer(cluster, registry, type, url);\n}\n\n/**\n *\n * @param cluster\n * @param registry 注册中心\n * @param type 远程服务接口类型\n * @param url 注册中心url\n * @return\n */\nprivate <T> Invoker<T> doRefer(Cluster cluster, Registry registry, Class<T> type, URL url) {\n\t//根据服务接口type和注册中心url创建RegistryDirectory对象(后面会分析该方法)\n\t//Directory代表多个Invoker,可以把它看成List<Invoker>，\n        //但与List不同的是,它的值可能是动态变化的,比如注册中心推送变更\n\tRegistryDirectory<T> directory = new RegistryDirectory<T>(type, url);\n\t//设置注册中心实例\n\tdirectory.setRegistry(registry);\n\t//设置协议\n\tdirectory.setProtocol(protocol);\n\t\n\t//refer参数指定的url的所有属性\n\tMap<String, String> parameters = new HashMap<String, String>(directory.getUrl().getParameters());\n\t\n\t//生成消费者url\n\t//consumer://192.168.99.60/com.alibaba.dubbo.demo.DemoService?application=demo-consumer&check=false&dubbo=2.0.0&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=1172&qos.port=33333&side=consumer&timestamp=1535094943004\n\tURL subscribeUrl = new URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), 0, type.getName(), parameters);\n\t\n\tif (!Constants.ANY_VALUE.equals(url.getServiceInterface())\n\t\t&& url.getParameter(Constants.REGISTER_KEY, true)) {\n\t    //注册消费者，添加category=consumers,check=false参数\n\t    registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,\n\t\t    Constants.CHECK_KEY, String.valueOf(false)));\n\t}\n\t\n\t//订阅此url\n\tdirectory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,\n\t\t//提供者 /dubbo/interfaceClass/providers\n\t\t//配置  /dubbo/interfaceClass/configurators\n\t\t//路由  /dubbo/interfaceClass/routers\n\t\tConstants.PROVIDERS_CATEGORY\n\t\t\t+ \",\" + Constants.CONFIGURATORS_CATEGORY\n\t\t\t+ \",\" + Constants.ROUTERS_CATEGORY));\n\t\n\t//Cluster将Directory中的多个Invoker伪装成一个Invoker,对上层透明,伪装过程包含了容错逻辑,调用失败后,重试另一个(后面会分析该方法)\n\tInvoker invoker = cluster.join(directory);\n\t\n\t//注册消费者\n\tProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);\n\treturn invoker;\n}\n```\n这里首先注册了消费者，然后订阅了相关目录(providers、configurations、routers)，当有相应服务提供者提供服务时，注册中心会通过notify通知到消费者，接着消费者会通过RegistryDirectory类异步更新本地缓存。\n注册消费者时，首先会调用AbstractRegistry类的register方法，将注册url保存起来，然后会调用FailbackRegistry类的register方法，在该方法中会调用doRegister方法(该方法调用失败的话，会稍后进行重试),最后会调用ZookeeperRegistry的doRegister方法，进行最终的注册。\n```java\n//ZookeeperRegistry类的doRegister方法\n@Override\nprotected void doRegister(URL url) {\n\ttry {\n\t    //执行注册 dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=5312&side=provider&timestamp=1534994264738\n\t    //根据url确定节点路径；根据url的dynamic参数确定是否是临时节点 /dubbo/com.alibaba.dubbo.demo.DemoService/providers/dubbo%3A%2F%2F192.168.99.60%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26dubbo%3D2.0.0%26generic%3Dfalse%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D5312%26side%3Dprovider%26timestamp%3D1534994264738\n\t    zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true));\n\t} catch (Throwable e) {\n\t    throw new RpcException(\"Failed to register \" + url + \" to zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e);\n\t}\n}\n```\n订阅时，会调用RegistryDirectory类的subscribe方法\n```java\npublic class RegistryDirectory<T> extends AbstractDirectory<T> implements NotifyListener {\n\n       /**\n\t* 订阅url\n\t* @param url 消费者url \n\t* consumer://192.168.99.60/com.alibaba.dubbo.demo.DemoService?application=demo-consumer&category=providers,configurators,routers&check=false&dubbo=2.0.0&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=1880&qos.port=33333&side=consumer&timestamp=1535449640995\n\t*/\n\tpublic void subscribe(URL url) {\n\t\t//设置消费者url(将url保存到AbstractDirectory父类中)\n\t\tsetConsumerUrl(url);\n\t\t\n\t\t//订阅该消费者url(this即为当前RegistryDirectory对象,它实现了NotifyListener接口)\n\t\t//首先调用AbstractRegistry的subscribe方法(保存订阅信息)\n\t\t//接着调用FailbackRegistry的subscribe方法(调用ZookeeperRegistry的doSubscribe方法，如果发生异常了会捕获到，然后保存下来稍后重试)\n\t\t//然后调用ZookeeperRegistry的doSubscribe方法(获取待通知urls，最后调用notify方法进行通知)\n\t\tregistry.subscribe(url, this);\n\t}\n}\n```\n我们简单看下ZookeeperRegistry类的doSubscribe方法，其中省略掉了一些代码\n```java\n//此listener参数就是上文创建的RegistryDirectory类\nprotected void doSubscribe(final URL url, final NotifyListener listener) {\n\tList<URL> urls = new ArrayList<URL>();\n\t//根据toCategoriesPath(url)方法获取到类别列表，然后遍历该列表\n\t//如：/dubbo/com.alibaba.dubbo.demo.DemoService/providers\n\tfor (String path : toCategoriesPath(url)) {\n\t    ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);\n\t    if (listeners == null) {\n\t\tzkListeners.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, ChildListener>());\n\t\tlisteners = zkListeners.get(url);\n\t    }\n\t    //根据dubbo的监听获取zk的监听\n\t    ChildListener zkListener = listeners.get(listener);\n\t    if (zkListener == null) {\n\t        //创建节点监听\n\t\tlisteners.putIfAbsent(listener, new ChildListener() {\n\t\t    @Override\n\t\t    public void childChanged(String parentPath, List<String> currentChilds) {\n\t\t\t//执行通知\n\t\t\tZookeeperRegistry.this.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds));\n\t\t    }\n\t\t});\n\t\tzkListener = listeners.get(listener);\n\t    }\n\t    //创建path节点,\n\t    //即：/dubbo/com.xxx.demoService/providers\n\t    //即：/dubbo/consumers  /dubbo/com.alibaba.dubbo.demo.DemoService/configurators\n\t    zkClient.create(path, false);\n\t    //为path节点添加zkListener监听(children变量即为该path节点的子节点数据)\n\t    List<String> children = zkClient.addChildListener(path, zkListener);\n\t    if (children != null) {\n\t        //节点数据(待通知列表)\n\t\t//empty://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&category=configurators&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=6504&side=provider&timestamp=1534927826842\n\t\turls.addAll(toUrlsWithEmpty(url, path, children));\n\t    }\n\t}\n\t//执行通知(urls即为待通知的消息列表)\n\tnotify(url, listener, urls);\n}\n```\n调用notify方法进行通知时,会先调用FailbackRegistry类的notify方法,内部会调用doNotify方法(调用失败的话,会保存失败信息,稍后重试)\n```java\n//FailbackRegistry类的notify\n//省略了一些不重要的代码\n@Override\nprotected void notify(URL url, NotifyListener listener, List<URL> urls) {\n\ttry {\n\t    //执行通知(将会调用父类AbstractRegistry中的notify方法)\n\t    doNotify(url, listener, urls);\n\t} catch (Exception t) {\n\t    //通知失败，添加到失败列表，定期重试\n\t    Map<NotifyListener, List<URL>> listeners = failedNotified.get(url);\n\t    if (listeners == null) {\n\t\tfailedNotified.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, List<URL>>());\n\t\tlisteners = failedNotified.get(url);\n\t    }\n\t    listeners.put(listener, urls);\n\t    logger.error(\"Failed to notify for subscribe \" + url + \", waiting for retry, cause: \" + t.getMessage(), t);\n\t}\n}\n```\n而doNotify方法最终会调用AbstractRegistry类的notify方法,在AbstractRegistry类的notify方法中,会根据category将待通知urls进行分组,然后挨个处理每一个category,并按照<订阅url服务唯一标识,空格分隔的多个待通知url>的形式，保存到本地properties文件中，最后调用RegistryDirectory类的notify方法将待通知列表categoryList下发给消费者。\n```java\n//AbstractRegistry类的notify方法\n//省略了一些不重要的代码\nprotected void notify(URL url, NotifyListener listener, List<URL> urls) {\n\t//<category,List<URL>>\n\tMap<String, List<URL>> result = new HashMap<String, List<URL>>();\n\t//遍历待通知urls，根据url中的category参数进行分组，保存到result中\n\tfor (URL u : urls) {\n\t    //url和u是否匹配(url的范围是否比u大)\n\t    if (UrlUtils.isMatch(url, u)) {\n\t\t//获取待通知url的category，默认值是providers\n\t\tString category = u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);\n\t\tList<URL> categoryList = result.get(category);\n\t\tif (categoryList == null) {\n\t\t    categoryList = new ArrayList<URL>();\n\t\t    result.put(category, categoryList);\n\t\t}\n\t\tcategoryList.add(u);\n\t    }\n\t}\n\tif (result.size() == 0) {\n\t    //类别待通知url列表为空，直接返回\n\t    return;\n\t}\n\t//下面会将notified中的url及其values.values中的URL保存到缓存文件中\n\tMap<String, List<URL>> categoryNotified = notified.get(url);\n\tif (categoryNotified == null) {\n\t    notified.putIfAbsent(url, new ConcurrentHashMap<String, List<URL>>());\n\t    categoryNotified = notified.get(url);\n\t}\n\tfor (Map.Entry<String, List<URL>> entry : result.entrySet()) {\n\t    //类别\n\t    String category = entry.getKey();\n\t    //类别待通知url列表\n\t    List<URL> categoryList = entry.getValue();\n\t    //保存<类别,类别待通知url列表>\n\t    categoryNotified.put(category, categoryList);\n\t    //保存注册中心缓存文件(将订阅url、待通知url列表保存到缓存文件)\n\t    saveProperties(url);\n\t    //触发通知给消费者(类别待通知url列表)，此listener就是RegistryDirectory类\n\t    listener.notify(categoryList);\n\t}\n}\n```\n然后我们来看RegistryDirectory类的notify方法\n```java\npublic synchronized void notify(List<URL> urls) {\n\tList<URL> invokerUrls = new ArrayList<URL>();\n\tList<URL> routerUrls = new ArrayList<URL>();\n\tList<URL> configuratorUrls = new ArrayList<URL>();\n\t//遍历待通知列表，根据category进行分组，并分别保存到上面定义的list列表中\n\tfor (URL url : urls) {\n\t    //获取url协议\n\t    String protocol = url.getProtocol();\n\t    //获取url分类\n\t    String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);\n\t    if (Constants.ROUTERS_CATEGORY.equals(category)\n\t\t    || Constants.ROUTE_PROTOCOL.equals(protocol)) {\n\t\t//添加路由url\n\t\trouterUrls.add(url);\n\t    } else if (Constants.CONFIGURATORS_CATEGORY.equals(category)\n\t\t    || Constants.OVERRIDE_PROTOCOL.equals(protocol)) {\n\t\t//添加配置url\n\t\tconfiguratorUrls.add(url);\n\t    } else if (Constants.PROVIDERS_CATEGORY.equals(category)) {\n\t\t//添加服务提供者url\n\t\tinvokerUrls.add(url);\n\t    } else {\n\t\t//不支持的分类\n\t\tlogger.warn(\"Unsupported category \" + category + \" in notified url: \" + url + \" from registry \" + getUrl().getAddress() + \" to consumer \" + NetUtils.getLocalHost());\n\t    }\n\t}\n\tif (configuratorUrls != null && !configuratorUrls.isEmpty()) {\n\t    //将url转换成Configurator类并保存(后面会分析该方法)\n\t    this.configurators = toConfigurators(configuratorUrls);\n\t}\n\tif (routerUrls != null && !routerUrls.isEmpty()) {\n\t    //将路由url转换成路由对象(后面会分析该方法)\n\t    List<Router> routers = toRouters(routerUrls);\n\t    if (routers != null) {\n\t\t//保存路由(后面会分析该方法)\n\t\tsetRouters(routers);\n\t    }\n\t}\n\tList<Configurator> localConfigurators = this.configurators;\n\t//合并override参数\n\tthis.overrideDirectoryUrl = directoryUrl;\n\tif (localConfigurators != null && !localConfigurators.isEmpty()) {\n\t    for (Configurator configurator : localConfigurators) {\n\t\t//根据configurator覆盖overrideDirectoryUrl中的属性，\n\t\t//或者将configurator中的属性添加到overrideDirectoryUrl中\n\t\tthis.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl);\n\t    }\n\t}\n\t//刷新Invoker(后面会分析该方法)\n\trefreshInvoker(invokerUrls);\n}\n\n```\n接下来，我们来挨个看下上面用到的方法\n\n#### 更新Configurator\n```java\n//将待通知url转换成Configurator\npublic static List<Configurator> toConfigurators(List<URL> urls) {\n\tif (urls == null || urls.isEmpty()) {\n\t    return Collections.emptyList();\n\t}\n\tList<Configurator> configurators = new ArrayList<Configurator>(urls.size());\n\t//遍历待通知url列表\n\tfor (URL url : urls) {\n\t    if (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) {\n\t\t//协议为empty，则清空configurators，并跳出循环\n\t\tconfigurators.clear();\n\t\tbreak;\n\t    }\n\t    //获取url所有参数\n\t    Map<String, String> override = new HashMap<String, String>(url.getParameters());\n\t    \n\t    //override的anyhost参数可以被自动添加\n\t    //它不可以改变对变化中的url的判断，因此需要移除掉anyhost参数\n\t    override.remove(Constants.ANYHOST_KEY);\n\t    if (override.size() == 0) {\n\t\tconfigurators.clear();\n\t\tcontinue;\n\t    }\n\t    //添加配置\n\t    configurators.add(configuratorFactory.getConfigurator(url));\n\t}\n\t//排序\n\tCollections.sort(configurators);\n\treturn configurators;\n}\n```\n\n#### 更新Router\n```java\n//将待通知url转换成Router对象\nprivate List<Router> toRouters(List<URL> urls) {\n\tList<Router> routers = new ArrayList<Router>();\n\tif (urls == null || urls.isEmpty()) {\n\t    return routers;\n\t}\n\tif (urls != null && !urls.isEmpty()) {\n\t    //遍历待通知url列表\n\t    for (URL url : urls) {\n\t\tif (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) {\n\t\t    //协议为empty的话，直接返回\n\t\t    continue;\n\t\t}\n\t\t//获取url的router参数，该参数标识了路由协议\n\t\tString routerType = url.getParameter(Constants.ROUTER_KEY);\n\t\tif (routerType != null && routerType.length() > 0) {\n\t\t    //设置路由协议\n\t\t    url = url.setProtocol(routerType);\n\t\t}\n\t\ttry {\n\t\t    //根据url获取路由实例\n\t\t    Router router = routerFactory.getRouter(url);\n\t\t    if (!routers.contains(router)) {\n\t\t\t//添加路由\n\t\t\trouters.add(router);\n\t\t    }\n\t\t} catch (Throwable t) {\n\t\t    logger.error(\"convert router url to router error, url: \" + url, t);\n\t\t}\n\t    }\n\t}\n\treturn routers;\n}\n\nprotected void setRouters(List<Router> routers) {\n\t//复制routers列表\n\trouters = routers == null ? new ArrayList<Router>() : new ArrayList<Router>(routers);\n\t\n\t//获取路由工厂的扩展名称\n\tString routerkey = url.getParameter(Constants.ROUTER_KEY);\n\tif (routerkey != null && routerkey.length() > 0) {\n\t    //根据 路由工厂扩展名 获取 路由工厂扩展实例\n\t    RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getExtension(routerkey);\n\t    //根据url获取路由实例，并放入routers\n\t    routers.add(routerFactory.getRouter(url));\n\t}\n\t//添加支持mock协议的invoker选择器\n\trouters.add(new MockInvokersSelector());\n\t//排序\n\tCollections.sort(routers);\n\t//保存最新的路由信息\n\tthis.routers = routers;\n}\n```\n#### 更新Invoker\n然后我们来看refreshInvoker方法\n```java\n/**\n * 将待通知invoker url转换成invoker Map，转换规则如下：\n * 1、如果url已经转换成invoker，则不再重新引用并直接从缓存中获取，并注意url中的任何参数更改都将被重新引用。\n * 2、如果传入的invoker列表不为空，则意味着这是最新的调用者列表\n * 3、如果传入的invoker列表为空，则意味着该规则只是一个override规则或者route规则，需要重新对比以决定是否需要重新引用\n */\nprivate void refreshInvoker(List<URL> invokerUrls) {\n\tif (invokerUrls != null && invokerUrls.size() == 1 && invokerUrls.get(0) != null\n\t\t&& Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) {\n\t    //empty协议\n\t    //禁止访问\n\t    this.forbidden = true;\n\t    this.methodInvokerMap = null;\n\t    //销毁所有的invokers\n\t    destroyAllInvokers();\n\t} else {\n\t    //允许访问\n\t    this.forbidden = false;\n\t    //记录当前的 urlInvokerMap\n\t    Map<String, Invoker<T>> oldUrlInvokerMap = this.urlInvokerMap;\n\t    if (invokerUrls.isEmpty() && this.cachedInvokerUrls != null) {\n\t\t//收到的invokerUrls为空，但是缓存中的不为空，则使用当前缓存中的invoker\n\t\tinvokerUrls.addAll(this.cachedInvokerUrls);\n\t    } else {\n\t\tthis.cachedInvokerUrls = new HashSet<URL>();\n\t\t//缓存invokerUrls列表，方便比较\n\t\tthis.cachedInvokerUrls.addAll(invokerUrls);\n\t    }\n\t    if (invokerUrls.isEmpty()) {\n\t\t//invoker url列表为空，直接返回\n\t\treturn;\n\t    }\n\t    //将invoker-url转换成invoker-map(后面会分析该方法)\n\t    Map<String, Invoker<T>> newUrlInvokerMap = toInvokers(invokerUrls);\n\t    \n\t    //建立 方法名与invoker的映射(后面会分析该方法)\n\t    Map<String, List<Invoker<T>>> newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap);\n\t   \n\t    //状态改变\n\t    if (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) {\n\t\t//转换发生错误\n\t\tlogger.error(new IllegalStateException(\"urls to invokers error .invokerUrls.size :\" + invokerUrls.size() + \", invoker.size :0. urls :\" + invokerUrls.toString()));\n\t\treturn;\n\t    }\n\t    //保存最新的 methodInvokerMap(后面会分析该方法)\n\t    this.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;\n\t    //保存最新的 urlInvokerMap\n\t    this.urlInvokerMap = newUrlInvokerMap;\n\t    try {\n\t\t//关闭未使用的invoker(后面会分析该方法)\n\t\tdestroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap);\n\t    } catch (Exception e) {\n\t\tlogger.warn(\"destroyUnusedInvokers error. \", e);\n\t    }\n\t}\n}\n```\n\n##### toInvokers方法\n```java\n/**\n * 将invoker-url转换成invoker，如果url已经被引用，将不会重新引用\n * @param urls 服务提供者url\n * dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=6640&side=provider&timestamp=1535449604077\n * @return invokers\n */\nprivate Map<String, Invoker<T>> toInvokers(List<URL> urls) {\n\tMap<String, Invoker<T>> newUrlInvokerMap = new HashMap<String, Invoker<T>>();\n\tif (urls == null || urls.isEmpty()) {\n\t    return newUrlInvokerMap;\n\t}\n\tSet<String> keys = new HashSet<String>();\n\t//获取当前url支持的协议\n\tString queryProtocols = this.queryMap.get(Constants.PROTOCOL_KEY);\n\t//遍历urls，检测每一个providerUrl是否满足当前调用者url的协议要求(queryProtocols)\n\tfor (URL providerUrl : urls) {\n\t    //如果在reference端配置了协议protocol，则只选择匹配的协议\n\t    if (queryProtocols != null && queryProtocols.length() > 0) {\n\t\tboolean accept = false;\n\t\t//可接受的协议数组\n\t\tString[] acceptProtocols = queryProtocols.split(\",\");\n\t\tfor (String acceptProtocol : acceptProtocols) {\n\t\t    if (providerUrl.getProtocol().equals(acceptProtocol)) {\n\t\t\t//如果该提供者url的协议在可接受的协议范围内，则跳出循环\n\t\t\taccept = true;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (!accept) {\n\t\t    //没找到，则判断下一个服务提供者\n\t\t    continue;\n\t\t}\n\t    }\n\t    if (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) {\n\t        //服务提供者协议为empty，则进行下次循环\n\t\tcontinue;\n\t    }\n\t    if (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) {\n\t\t//不支持的协议\n\t\tlogger.error(new IllegalStateException(\"Unsupported protocol \" + providerUrl.getProtocol() + \" in notified url: \" + providerUrl + \" from registry \" + getUrl().getAddress() + \" to consumer \" + NetUtils.getLocalHost()\n\t\t\t+ \", supported protocol: \" + ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));\n\t\tcontinue;\n\t    }\n\t    //合并url参数(后面会分析该方法)\n\t    URL url = mergeUrl(providerUrl);\n\t    \n\t    //url的参数已经排过序\n\t    //dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-consumer&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=1880&qos.port=33333&register.ip=192.168.99.60&remote.timestamp=1535449604077&side=consumer&timestamp=1535449640995\n\t    String key = url.toFullString();\n\t    if (keys.contains(key)) {\n\t\t//重复的url\n\t\tcontinue;\n\t    }\n\t    keys.add(key);\n\t    //缓存key是url，不与消费者端的参数合并，无论消费者如何组合参数，\n            //如果服务器url发生改变，则重新进行引用\n\t    Map<String, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap;\n\t    //根据缓存key获取invoker\n\t    Invoker<T> invoker = localUrlInvokerMap == null ? null : localUrlInvokerMap.get(key);\n\t    if (invoker == null) {\n\t\t//不在缓存中，重新引用\n\t\ttry {\n\t\t    boolean enabled = true;\n\t\t    //获取disabled参数、enabled参数，来判断是否可用\n\t\t    if (url.hasParameter(Constants.DISABLED_KEY)) {\n\t\t\tenabled = !url.getParameter(Constants.DISABLED_KEY, false);\n\t\t    } else {\n\t\t\tenabled = url.getParameter(Constants.ENABLED_KEY, true);\n\t\t    }\n\t\t    if (enabled) {\n\t\t\t//可以引用，重新引用(后面会介绍)\n\t\t\tinvoker = new InvokerDelegate<T>(\n\t\t\t        //根据服务接口、远程服务url重新引用\n\t\t\t\tprotocol.refer(serviceType, url),\n\t\t\t\turl,\n\t\t\t\tproviderUrl\n\t\t\t);\n\t\t    }\n\t\t} catch (Throwable t) {\n\t\t    logger.error(\"Failed to refer invoker for interface:\" + serviceType + \",url:(\" + url + \")\" + t.getMessage(), t);\n\t\t}\n\t\tif (invoker != null) {\n\t\t    //保存新的invoker到缓存\n\t\t    newUrlInvokerMap.put(key, invoker);\n\t\t}\n\t    } else {\n\t\tnewUrlInvokerMap.put(key, invoker);\n\t    }\n\t}\n\tkeys.clear();\n\treturn newUrlInvokerMap;\n}\n\n```\n##### toMethodInvokers方法\n\n```java\n/**\n * 获取Invoker和method之间的映射关系\n * @param invokersMap Invoker Map\n * @return Mapping relation between Invoker and method\n */\nprivate Map<String, List<Invoker<T>>> toMethodInvokers(Map<String, Invoker<T>> invokersMap) {\n\t//method与invoker列表的映射\n\tMap<String, List<Invoker<T>>> newMethodInvokerMap = new HashMap<String, List<Invoker<T>>>();\n\t\n\t// According to the methods classification declared by the provider URL,\n\t// the methods is compatible with the registry to execute the filtered methods\n\tList<Invoker<T>> invokersList = new ArrayList<Invoker<T>>();\n\t\n\tif (invokersMap != null && invokersMap.size() > 0) {\n\t    //遍历invokers\n\t    for (Invoker<T> invoker : invokersMap.values()) {\n\t\t//获取服务提供者方法列表\n\t\tString parameter = invoker.getUrl().getParameter(Constants.METHODS_KEY);\n\t\tif (parameter != null && parameter.length() > 0) {\n\t\t    //逗号分隔方法\n\t\t    String[] methods = Constants.COMMA_SPLIT_PATTERN.split(parameter);\n\t\t    if (methods != null && methods.length > 0) {\n\t\t\tfor (String method : methods) {\n\t\t\t    if (method != null && method.length() > 0 && !Constants.ANY_VALUE.equals(method)) {\n\t\t\t\t//通过method获取invoker列表\n\t\t\t\tList<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);\n\t\t\t\tif (methodInvokers == null) {\n\t\t\t\t    methodInvokers = new ArrayList<Invoker<T>>();\n\t\t\t\t    //添加方法、invoker映射\n\t\t\t\t    newMethodInvokerMap.put(method, methodInvokers);\n\t\t\t\t}\n\t\t\t\tmethodInvokers.add(invoker);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\t//添加invoker\n\t\tinvokersList.add(invoker);\n\t    }\n\t}\n\t//根据路由筛选InvokersList(后面会分析该方法)\n\tList<Invoker<T>> newInvokersList = route(invokersList, null);\n\t\n\t//保存<*,newInvokersList>\n\tnewMethodInvokerMap.put(Constants.ANY_VALUE, newInvokersList);\n\t\n\tif (serviceMethods != null && serviceMethods.length > 0) {\n\t    //遍历服务method列表,并从newMethodInvokerMap中获取该method对应的Invoker列表\n\t    //如果没有获取到，则将该method映射到newInvokersList列表上\n\t    for (String method : serviceMethods) {\n\t\tList<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);\n\t\tif (methodInvokers == null || methodInvokers.isEmpty()) {\n\t\t    methodInvokers = newInvokersList;\n\t\t}\n\t\t//根据路由筛选invoker列表，然后保存method、invokerList映射\n\t\tnewMethodInvokerMap.put(method, route(methodInvokers, method));\n\t    }\n\t}\n\tfor (String method : new HashSet<String>(newMethodInvokerMap.keySet())) {\n\t    List<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);\n\t    //排序invoker\n\t    Collections.sort(methodInvokers, InvokerComparator.getComparator());\n\t    //不可变集合\n\t    newMethodInvokerMap.put(method, Collections.unmodifiableList(methodInvokers));\n\t}\n\treturn Collections.unmodifiableMap(newMethodInvokerMap);\n}\n```\n###### route方法\n```java\n/**\n * 根据路由筛选InvokersList\n * Router 负责从多个 Invoker 中按路由规则选出子集，比如读写分离，应用隔离等\n * @param invokers\n * @param method\n * @return\n */\nprivate List<Invoker<T>> route(List<Invoker<T>> invokers, String method) {\n\t//创建Invocation对象\n\tInvocation invocation = new RpcInvocation(method, new Class<?>[0], new Object[0]);\n\t//获取路由列表\n\tList<Router> routers = getRouters();\n\tif (routers != null) {\n\t    for (Router router : routers) {\n\t\tif (router.getUrl() != null) {\n\t\t    //执行路由\n\t\t    invokers = router.route(invokers, getConsumerUrl(), invocation);\n\t\t}\n\t    }\n\t}\n\treturn invokers;\n}\n```\n\n##### toMergeMethodInvokerMap方法\n```java\nprivate Map<String, List<Invoker<T>>> toMergeMethodInvokerMap(Map<String, List<Invoker<T>>> methodMap) {\n\tMap<String, List<Invoker<T>>> result = new HashMap<String, List<Invoker<T>>>();\n\tfor (Map.Entry<String, List<Invoker<T>>> entry : methodMap.entrySet()) {\n\t    //当前方法名\n\t    String method = entry.getKey();\n\t    //当前invokers\n\t    List<Invoker<T>> invokers = entry.getValue();\n\t    //将invokers按照group进行分组，放入到groupMap中(<group,List<invokers>>)\n\t    Map<String, List<Invoker<T>>> groupMap = new HashMap<String, List<Invoker<T>>>();\n\t    for (Invoker<T> invoker : invokers) {\n\t\t//当前url的group\n\t\tString group = invoker.getUrl().getParameter(Constants.GROUP_KEY, \"\");\n\t\tList<Invoker<T>> groupInvokers = groupMap.get(group);\n\t\tif (groupInvokers == null) {\n\t\t    groupInvokers = new ArrayList<Invoker<T>>();\n\t\t    groupMap.put(group, groupInvokers);\n\t\t}\n\t\tgroupInvokers.add(invoker);\n\t    }\n\t    if (groupMap.size() == 1) {\n\t\t//只有一个group\n\t\tresult.put(method, groupMap.values().iterator().next());\n\t    } else if (groupMap.size() > 1) {\n\t\t//多个group的情况\n\t\tList<Invoker<T>> groupInvokers = new ArrayList<Invoker<T>>();\n\t\tfor (List<Invoker<T>> groupList : groupMap.values()) {\n\t\t    //针对每一个groupList创建一个StaticDirectory，然后生成一个invoker并放入groupInvokers中\n\t\t    groupInvokers.add(cluster.join(new StaticDirectory<T>(groupList)));\n\t\t}\n\t\tresult.put(method, groupInvokers);\n\t    } else {\n\t\t//没有group\n\t\tresult.put(method, invokers);\n\t    }\n\t}\n\treturn result;\n}\n```\n![](img/toMergeMethodInvokerMap.png)\n\n##### 销毁无用的invoker\n```java\n/**\n * 检测缓存中的invoker是否需要被销毁\n * 如果设置url属性：refer.autodestroy=false\n * invokers将会在不减少的情况下增加，可能会有一个引用泄露\n * @param oldUrlInvokerMap\n * @param newUrlInvokerMap\n */\nprivate void destroyUnusedInvokers(Map<String, Invoker<T>> oldUrlInvokerMap,Map<String, Invoker<T>> newUrlInvokerMap) {\n\tif (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) {\n\t    //关闭所有的invoker\n\t    destroyAllInvokers();\n\t    return;\n\t}\n\tList<String> deleted = null;\n\tif (oldUrlInvokerMap != null) {\n\t    Collection<Invoker<T>> newInvokers = newUrlInvokerMap.values();\n\t    for (Map.Entry<String, Invoker<T>> entry : oldUrlInvokerMap.entrySet()) {\n\t\tif (!newInvokers.contains(entry.getValue())) {\n\t\t    //老的invoker在新的invoker列表中不存在\n\t\t    if (deleted == null) {\n\t\t\tdeleted = new ArrayList<String>();\n\t\t    }\n\t\t    //标记该老的url，后面会进行删除\n\t\t    deleted.add(entry.getKey());\n\t\t}\n\t    }\n\t}\n\tif (deleted != null) {\n\t    for (String url : deleted) {\n\t\tif (url != null) {\n\t\t    //从老的invoker-map中移除该url，并关闭该老的invoker\n\t\t    Invoker<T> invoker = oldUrlInvokerMap.remove(url);\n\t\t    if (invoker != null) {\n\t\t\ttry {\n\t\t\t    //销毁该invoker\n\t\t\t    invoker.destroy();\n\t\t\t} catch (Exception e) {\n\t\t\t    logger.warn(\"destory invoker[\" + invoker.getUrl() + \"] faild. \" + e.getMessage(), e);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n}\n```\n#### 重新引用invoker\n\n接下来，我们来看看上面的toInvokers方法中，重新引用invoker的逻辑，即\n```java\nif (enabled) {\n\t//可以引用，重新引用\n\tinvoker = new InvokerDelegate<T>(\n\t\tprotocol.refer(serviceType, url),\n\t\turl,\n\t\tproviderUrl\n\t);\n}\n```\n这里会先调用ProtocolListenerWrapper类的refer方法,然后在该方法内会在调用ProtocolFilterWrapper类的refer方法\n```java\npublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n\tif (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n\t    return protocol.refer(type, url);\n\t}\n\treturn new ListenerInvokerWrapper<T>(\n\t        //调用ProtocolFilterWrapper类的refer方法获取到invoker\n\t\tprotocol.refer(type, url),\n\t\tCollections.unmodifiableList(\n\t\t      ExtensionLoader.getExtensionLoader(InvokerListener.class)\n\t\t\t\t     .getActivateExtension(url, Constants.INVOKER_LISTENER_KEY)\n\t));\n}\n```\n我们看下ProtocolFilterWrapper类的refer方法，在该方法内部会去调用DubboProtocol类的refer方法\n```java\n@Override\npublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n\tif (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n\t\treturn protocol.refer(type, url);\n\t}\n\t//构建invoker链\n\treturn buildInvokerChain(\n\t\t//调用DubboProtocol类的refer方法\n\t\tprotocol.refer(type, url), \n\t\t//reference.filter\n\t\tConstants.REFERENCE_FILTER_KEY, \n\t\t//consumer\n\t\tConstants.CONSUMER\n\t);\n}\n\n/**\n * 构建Invoker链\n * @param invoker\n * @param key  \n * @param group \n */\nprivate static <T> Invoker<T> buildInvokerChain(final Invoker<T> invoker,String key, String group) {\n\tInvoker<T> last = invoker;\n\t//获取过滤器：ConsumerContextFilter、FutureFilter、MonitorFilter\n\tList<Filter> filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);\n\tif (!filters.isEmpty()) {\n\t    for (int i = filters.size() - 1; i >= 0; i--) {\n\t\t//MonitorFilter、FutureFilter、ConsumerContextFilter\n\t\tfinal Filter filter = filters.get(i);\n\t\tfinal Invoker<T> next = last;\n\t\tlast = new Invoker<T>() {\n\t\t    @Override\n\t\t    public Class<T> getInterface() {\n\t\t\treturn invoker.getInterface();\n\t\t    }\n\t\t    @Override\n\t\t    public URL getUrl() {\n\t\t\treturn invoker.getUrl();\n\t\t    }\n\t\t    @Override\n\t\t    public boolean isAvailable() {\n\t\t\treturn invoker.isAvailable();\n\t\t    }\n\t\t    @Override\n\t\t    public Result invoke(Invocation invocation) throws RpcException {\n\t\t        //调用filter的invoke方法\n\t\t\treturn filter.invoke(next, invocation);\n\t\t    }\n\t\t    @Override\n\t\t    public void destroy() {\n\t\t\tinvoker.destroy();\n\t\t    }\n\t\t    @Override\n\t\t    public String toString() {\n\t\t\treturn invoker.toString();\n\t\t    }\n\t\t};\n\t    }\n\t}\n\treturn last;\n}\n```\nDubboProtocol类的refer方法\n```java\n/**\n * @param serviceType com.alibaba.dubbo.demo.DemoService\n * @param url \n * dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-consumer&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=5624&qos.port=33333&register.ip=192.168.99.60&remote.timestamp=1535531661191&side=consumer&timestamp=1535531690333\n */\n@Override\npublic <T> Invoker<T> refer(Class<T> serviceType, URL url) throws RpcException {\n\t//加载优化序列化类\n\toptimizeSerialization(url);\n\t\n\t//创建DubboInvoker\n\tDubboInvoker<T> invoker = new DubboInvoker<T>(\n\t\tserviceType,\n\t\turl,\n\t\t//创建客户端(后面小节会分析该方法)\n\t\tgetClients(url),\n\t\t//当前对象已创建的invoker集合\n\t\tinvokers\n\t);\n\t//将invoker保存到invokers集合中\n\tinvokers.add(invoker);\n\treturn invoker;\n}\n```\n该invoker中持有一个client对象，默认是NettyClient，后面小节会介绍该过程，最终生成的Invoker如下图，：\n![](img/InvokerChain.png)\n\n#### registerConsumer注册消费者\n\n最后调用ProviderConsumerRegTable类的registerConsumer方法注册消费者\n```java\npublic static ConcurrentHashMap<String, Set<ConsumerInvokerWrapper>> consumerInvokers = new ConcurrentHashMap<String, Set<ConsumerInvokerWrapper>>();\n\n/**\n * 注册消费者\n * @param invoker\n * @param registryUrl 注册中心url\n * @param consumerUrl 消费者url\n * @param registryDirectory\n */\npublic static void registerConsumer(Invoker invoker, URL registryUrl, URL consumerUrl, RegistryDirectory registryDirectory) {\n\t//创建ConsumerInvokerWrapper\n\tConsumerInvokerWrapper wrapperInvoker = new ConsumerInvokerWrapper(invoker, registryUrl, consumerUrl, registryDirectory);\n\t//服务唯一标识\n\tString serviceUniqueName = consumerUrl.getServiceKey();\n\t//根据服务唯一标识获取invokers\n\tSet<ConsumerInvokerWrapper> invokers = consumerInvokers.get(serviceUniqueName);\n\tif (invokers == null) {\n\t    consumerInvokers.putIfAbsent(serviceUniqueName, new ConcurrentHashSet<ConsumerInvokerWrapper>());\n\t    invokers = consumerInvokers.get(serviceUniqueName);\n\t}\n\t//添加wrapperInvoker到缓存\n\tinvokers.add(wrapperInvoker);\n}\n```\n\n到此为止，整个流程就介绍完毕了。下面小节将会介绍一下注册中心Registry。\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之注册中心-Zookeeper注册中心","url":"/blog/2018/08/23/Dubbo源码阅读之注册中心-Zookeeper注册中心/","content":">本小节讲解Zookeeper注册中心的实现\n\n\n### ZookeeperRegistry注册中心\n先来看下后面会用到的接口：\n```java\n/**\n * 节点监听\n */\npublic interface ChildListener {\n    /**\n     * 节点发生改变\n     * @param path\n     * @param children\n     */\n    void childChanged(String path, List<String> children);\n}\n/**\n * 连接状态监听器\n */\npublic interface StateListener {\n    //断开连接\n    int DISCONNECTED = 0;\n    //已连接\n    int CONNECTED = 1;\n    //重新连接\n    int RECONNECTED = 2;\n\n    /**\n     * 连接状态改变\n     * @param connected 状态值\n     */\n    void stateChanged(int connected);\n}\n```\n然后我们来看ZookeeperRegistry的实现,该类继承自FailbackRegistry,因此具备了发生异常时自动重试的能力\n```java\npublic class ZookeeperRegistry extends FailbackRegistry {\n\n    private final static Logger logger = LoggerFactory.getLogger(ZookeeperRegistry.class);\n\n    /**\n     * 默认的zk端口\n     */\n    private final static int DEFAULT_ZOOKEEPER_PORT = 2181;\n\n    /**\n     * 默认的zk根节点\n     */\n    private final static String DEFAULT_ROOT = \"dubbo\";\n\n    /**\n     * zk根节点，如：/dubbo\n     */\n    private final String root;\n\n    private final Set<String> anyServices = new ConcurrentHashSet<String>();\n\n    /**\n     * URL：订阅url,<节点监听事件>\n     */\n    private final ConcurrentMap<URL, ConcurrentMap<NotifyListener, ChildListener>>\n            zkListeners = new ConcurrentHashMap<URL, ConcurrentMap<NotifyListener, ChildListener>>();\n\n    /**\n     * zk客户端接口(支持多种客户端实现)\n     */\n    private final ZookeeperClient zkClient;\n\n    public ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) {\n        //设置注册中心url\n        super(url);\n        if (url.isAnyHost()) {\n            //host = 0.0.0.0 || anyhost = true\n            throw new IllegalStateException(\"registry address == null\");\n        }\n        //获取url参数group,标识zk根节点名称,默认为dubbo\n        String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);\n        if (!group.startsWith(Constants.PATH_SEPARATOR)) {\n            //添加前缀，如：/dubbo\n            group = Constants.PATH_SEPARATOR + group;\n        }\n        this.root = group;\n\n        //调用zookeeperTransporter接口的connect方法连接到zk客户端(后面会分析该方法)\n        zkClient = zookeeperTransporter.connect(url);\n\n        //添加节点变更事件到AbstractZookeeperClient父类中的缓存集合变量中\n        zkClient.addStateListener(new StateListener() {\n            @Override\n            public void stateChanged(int state) {\n                if (state == RECONNECTED) {\n                    try {\n                        //重连事件，进行恢复\n                        recover();\n                    } catch (Exception e) {\n                        logger.error(e.getMessage(), e);\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * 给zk地址附加默认端口号\n     * @param address\n     * @return\n     */\n    static String appendDefaultPort(String address) {\n        if (address != null && address.length() > 0) {\n            int i = address.indexOf(':');\n            if (i < 0) {\n                //添加zk默认端口2181，即：address:2181\n                return address + \":\" + DEFAULT_ZOOKEEPER_PORT;\n            } else if (Integer.parseInt(address.substring(i + 1)) == 0) {\n                //端口为0的话，则使用默认端口\n                return address.substring(0, i + 1) + DEFAULT_ZOOKEEPER_PORT;\n            }\n        }\n        return address;\n    }\n\n    @Override\n    public boolean isAvailable() {\n        //连接是否可用\n        return zkClient.isConnected();\n    }\n\n    @Override\n    public void destroy() {\n        super.destroy();\n        try {\n            //销毁客户端\n            zkClient.close();\n        } catch (Exception e) {\n            logger.warn(\"Failed to close zookeeper client \" + getUrl() + \", cause: \" + e.getMessage(), e);\n        }\n    }\n\n    @Override\n    protected void doRegister(URL url) {\n        try {\n            //执行注册 dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=5312&side=provider&timestamp=1534994264738\n            //根据url确定节点路径；根据url的dynamic参数确定是否是临时节点\n\t    //如：/dubbo/com.alibaba.dubbo.demo.DemoService/providers/dubbo%3A%2F%2F192.168.99.60%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26dubbo%3D2.0.0%26generic%3Dfalse%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D5312%26side%3Dprovider%26timestamp%3D1534994264738\n            //在zk上创建节点\n\t    zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true));\n        } catch (Throwable e) {\n            throw new RpcException(\"Failed to register \" + url + \" to zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e);\n        }\n    }\n\n    @Override\n    protected void doUnregister(URL url) {\n        try {\n            //执行取消注册\n            //删除url节点路径\n            zkClient.delete(toUrlPath(url));\n        } catch (Throwable e) {\n            throw new RpcException(\"Failed to unregister \" + url + \" to zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e);\n        }\n    }\n\n    @Override\n    protected void doUnsubscribe(URL url, NotifyListener listener) {\n        //执行取消订阅\n        //根据订阅url获取监听\n        ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);\n        if (listeners != null) {\n            //根据NotifyListener获取zk监听\n            ChildListener zkListener = listeners.get(listener);\n            if (zkListener != null) {\n                //从zk上移除节点监听\n                zkClient.removeChildListener(toUrlPath(url), zkListener);\n            }\n        }\n    }\n\n    /**\n     * 执行订阅\n     * @param url\n     * 例如： provider://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&category=configurators&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=6504&side=provider&timestamp=1534927826842\n     *       consumer://192.168.99.60/com.alibaba.dubbo.demo.DemoService?application=demo-consumer&category=providers,configurators,routers&check=false&dubbo=2.0.0&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=1880&qos.port=33333&side=consumer&timestamp=1535449640995\n     * @param listener 例如：OverrideListener\n     */\n    @Override\n    protected void doSubscribe(final URL url, final NotifyListener listener) {\n        try {\n            //执行订阅\n            //查看订阅url的interface属性是否=*\n            if (Constants.ANY_VALUE.equals(url.getServiceInterface())) {\n                String root = toRootPath();\n                //获取订阅url的监听列表\n                ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);\n                if (listeners == null) {\n                    zkListeners.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, ChildListener>());\n                    listeners = zkListeners.get(url);\n                }\n                //获取listener对应的zk监听器\n                ChildListener zkListener = listeners.get(listener);\n                if (zkListener == null) {\n                    //如果zk监听器为空，则新建一个，并放入zkListeners集合中\n                    listeners.putIfAbsent(listener, new ChildListener() {\n                        @Override\n                        public void childChanged(String parentPath, List<String> currentChilds) {\n                            for (String child : currentChilds) {\n                                child = URL.decode(child);\n                                if (!anyServices.contains(child)) {\n                                    //记录节点child\n                                    anyServices.add(child);\n                                    //订阅child\n                                    //添加interface = child\n                                    //添加check = false\n                                    subscribe(url.setPath(child).addParameters(Constants.INTERFACE_KEY,child,\n                                            Constants.CHECK_KEY, String.valueOf(false)), listener);\n                                }\n                            }\n                        }\n                    });\n                    zkListener = listeners.get(listener);\n                }\n                //创建root持久化节点\n                zkClient.create(root, false);\n                //添加root节点监听，services为root节点的子节点列表\n                List<String> services = zkClient.addChildListener(root, zkListener);\n                if (services != null && !services.isEmpty()) {\n                    for (String service : services) {\n                        //子节点\n                        service = URL.decode(service);\n                        anyServices.add(service);\n                        //订阅子节点\n                        subscribe(url.setPath(service).addParameters(Constants.INTERFACE_KEY, service,\n                                Constants.CHECK_KEY, String.valueOf(false)), listener);\n                    }\n                }\n            } else {\n                List<URL> urls = new ArrayList<URL>();\n                //遍历url的类别列表 /dubbo/com.alibaba.dubbo.demo.DemoService/configurators\n                for (String path : toCategoriesPath(url)) {\n\t\t    //根据订阅url获取监听\n                    ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);\n                    if (listeners == null) {\n                        zkListeners.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, ChildListener>());\n                        listeners = zkListeners.get(url);\n                    }\n                    ChildListener zkListener = listeners.get(listener);\n                    if (zkListener == null) {\n\t\t        //添加为空，则新建一个节点监听\n                        listeners.putIfAbsent(listener, new ChildListener() {\n                            @Override\n                            public void childChanged(String parentPath, List<String> currentChilds) {\n                                //执行通知\n                                ZookeeperRegistry.this.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds));\n                            }\n                        });\n                        zkListener = listeners.get(listener);\n                    }\n                    //创建path节点,\n                    //即：/dubbo/com.xxx.demoService/providers\n                    //即：/dubbo/consumers  /dubbo/com.alibaba.dubbo.demo.DemoService/configurators\n                    zkClient.create(path, false);\n                    //添加path节点监听zkListener\n                    List<String> children = zkClient.addChildListener(path, zkListener);\n                    if (children != null) {\n\t\t\t//empty://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&category=configurators&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=6504&side=provider&timestamp=1534927826842\n                        urls.addAll(toUrlsWithEmpty(url, path, children));\n                    }\n                }\n                //通知消费者(urls即为待通知的消息)\n                notify(url, listener, urls);\n            }\n        } catch (Throwable e) {\n            throw new RpcException(\"Failed to subscribe \" + url + \" to zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public List<URL> lookup(URL url) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"lookup url == null\");\n        }\n        try {\n            //找到的所有的子节点\n            List<String> providers = new ArrayList<String>();\n            //遍历url类别数组 /dubbo/com.alibaba.dubbo.demo.DemoService/providers\n            for (String path : toCategoriesPath(url)) {\n                //获取path节点的子节点\n                List<String> children = zkClient.getChildren(path);\n                if (children != null) {\n                    providers.addAll(children);\n                }\n            }\n            return toUrlsWithoutEmpty(url, providers);\n        } catch (Throwable e) {\n            throw new RpcException(\"Failed to lookup \" + url + \" from zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * 如果root = /,则返回 / ,否则返回 /dubbo/\n     * @return\n     */\n    private String toRootDir() {\n        if (root.equals(Constants.PATH_SEPARATOR)) {\n            return root;\n        }\n        return root + Constants.PATH_SEPARATOR;\n    }\n\n    private String toRootPath() {\n        return root;\n    }\n\n    /**\n     * 获取服务地址\n     * @param url\n     * @return  /dubbo/  或者 /dubbo/编码后的interface\n     */\n    private String toServicePath(URL url) {\n        String name = url.getServiceInterface();\n        if (Constants.ANY_VALUE.equals(name)) {\n            //interface = *，则返回: /dubbo/\n            return toRootPath();\n        }\n        //返回： /dubbo/编码后的interface\n        return toRootDir() + URL.encode(name);\n    }\n\n    /**\n     * 根据url获取类别数组\n     * @param url\n     * @return\n     */\n    private String[] toCategoriesPath(URL url) {\n        String[] categories;\n        if (Constants.ANY_VALUE.equals(url.getParameter(Constants.CATEGORY_KEY))) {\n            //url的category参数=*，则取所有的类别，即 categories = providers、consumers、routers、configurators\n            categories = new String[]{\n\t\t\tConstants.PROVIDERS_CATEGORY, \n\t\t\tConstants.CONSUMERS_CATEGORY,\n\t\t\tConstants.ROUTERS_CATEGORY, \n\t\t\tConstants.CONFIGURATORS_CATEGORY\n\t    };\n        } else {\n            //如果category参数为空，则取默认类别：providers\n            categories = url.getParameter(Constants.CATEGORY_KEY, new String[]{Constants.DEFAULT_CATEGORY});\n        }\n        String[] paths = new String[categories.length];\n        for (int i = 0; i < categories.length; i++) {\n            //例如：/dubbo/com.xxx.demoService/providers (interface != *)\n            //例如：/dubbo/providers (interface = *)\n            paths[i] = toServicePath(url) + Constants.PATH_SEPARATOR + categories[i];\n        }\n        return paths;\n    }\n\n    /**\n     * 获取url对应的类别地址\n     * /dubbo/com.alibaba.dubbo.demo.demoService/providers\n     * @param url\n     * @return\n     */\n    private String toCategoryPath(URL url) {\n        return toServicePath(url) + Constants.PATH_SEPARATOR + url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);\n    }\n\n    /**\n     * 获取url对应的url地址(将会在zk上创建该地址)\n     * @param url\n     * @return /dubbo/com.alibaba.dubbo.demo.DemoService/providers/dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=7112&side=provider&timestamp=1534931882323\n     */\n    private String toUrlPath(URL url) {\n        return toCategoryPath(url) + Constants.PATH_SEPARATOR + URL.encode(url.toFullString());\n    }\n\n    /**\n     * 返回值为空的话，不会返回默认值\n     * @param consumer\n     * @param providers\n     * @return\n     */\n    private List<URL> toUrlsWithoutEmpty(URL consumer, List<String> providers) {\n        List<URL> urls = new ArrayList<URL>();\n        if (providers != null && !providers.isEmpty()) {\n            for (String provider : providers) {\n                //解码\n                provider = URL.decode(provider);\n                if (provider.contains(\"://\")) {\n                    URL url = URL.valueOf(provider);\n                    //是否匹配\n                    if (UrlUtils.isMatch(consumer, url)) {\n                        urls.add(url);\n                    }\n                }\n            }\n        }\n        return urls;\n    }\n\n    /**\n     * 如果为空的话，则返回一个默认值\n     * @param consumer provider://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&category=configurators&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=6504&side=provider&timestamp=1534927826842\n     * @param path /dubbo/com.alibaba.dubbo.demo.DemoService/configurators\n     * @param providers\n     * @return\n     */\n    private List<URL> toUrlsWithEmpty(URL consumer, String path, List<String> providers) {\n        List<URL> urls = toUrlsWithoutEmpty(consumer, providers);\n        if (urls == null || urls.isEmpty()) {\n            int i = path.lastIndexOf('/');\n            //获取类别\n            String category = i < 0 ? path : path.substring(i + 1);\n            //设置empty协议，并设置category属性\n            URL empty = consumer.setProtocol(Constants.EMPTY_PROTOCOL).addParameter(Constants.CATEGORY_KEY, category);\n            urls.add(empty);\n        }\n        return urls;\n    }\n}\n```\n可以看到zk注册中心根据NotifyListener接口与RegistryDirectory类进行通信，通过notify方法通知消费者有更新。通过ZookeeperClient与Zookeeper进行交互。\n接下来，我们来看下是dubbo是如何通过工厂创建ZookeeperRegistry实例的。\n\n### Zookeeper注册中心工厂\n先来看下ZookeeperRegistryFactory类，该类继承自AbstractRegistryFactory，用来创建具体的ZookeeperRegistry实例\n```java\npublic class ZookeeperRegistryFactory extends AbstractRegistryFactory {\n\n    private ZookeeperTransporter zookeeperTransporter;\n\n    public void setZookeeperTransporter(ZookeeperTransporter zookeeperTransporter) {\n        this.zookeeperTransporter = zookeeperTransporter;\n    }\n   \n    /**\n     * @param url 注册中心url\n     */\n    @Override\n    public Registry createRegistry(URL url) {\n        //创建zk注册中心\n        return new ZookeeperRegistry(url, zookeeperTransporter);\n    }\n}\n```\nZookeeperTransporter是一个接口，dubbo支持多个zk客户端实现，例如Curator、ZkClient，该接口就是用来创建具体的客户端实现的，可以看到默认是使用curator客户端。\n```java\n@SPI(\"curator\")\npublic interface ZookeeperTransporter {\n    @Adaptive({Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY})\n    ZookeeperClient connect(URL url);\n}\n\npublic class CuratorZookeeperTransporter implements ZookeeperTransporter {\n    @Override\n    public ZookeeperClient connect(URL url) {\n        //返回Curator实现\n        return new CuratorZookeeperClient(url);\n    }\n}\n\npublic class ZkclientZookeeperTransporter implements ZookeeperTransporter {\n    @Override\n    public ZookeeperClient connect(URL url) {\n        //返回Zkclient实现\n        return new ZkclientZookeeperClient(url);\n    }\n}\n```\n下面我们就来看看各个ZookeeperClient的实现。\n\n#### ZookeeperClient接口\n该接口定义了一些针对zk的基本操作\n```java\npublic interface ZookeeperClient {\n    /**\n     * 创建一个节点\n     * @param path 节点路径\n     * @param ephemeral 是否临时节点\n     */\n    void create(String path, boolean ephemeral);\n\n    /**\n     * 删除一个节点\n     * @param path\n     */\n    void delete(String path);\n\n    /**\n     * 获取某个节点的子节点路径\n     * @param path\n     * @return\n     */\n    List<String> getChildren(String path);\n\n    /**\n     * 添加节点监听器\n     * @param path 节点路径\n     * @param listener 监听器\n     * @return\n     */\n    List<String> addChildListener(String path, ChildListener listener);\n\n    /**\n     * 移除节点监听器\n     * @param path\n     * @param listener\n     */\n    void removeChildListener(String path, ChildListener listener);\n\n    /**\n     * 添加变更事件监听\n     * @param listener\n     */\n    void addStateListener(StateListener listener);\n    /**\n     * 移除变更事件监听\n     */\n    void removeStateListener(StateListener listener);\n    /**\n     * 是否已连接\n     * @return\n     */\n    boolean isConnected();\n    /**\n     * 关闭\n     */\n    void close();\n    /**\n     * 获取注册中心url\n     */\n    URL getUrl();\n}\n```\n##### AbstractZookeeperClient抽象类\n```java\npublic abstract class AbstractZookeeperClient<TargetChildListener> implements ZookeeperClient {\n\n    protected static final Logger logger = LoggerFactory.getLogger(AbstractZookeeperClient.class);\n\n    /**\n     * 注册中心url\n     */\n    private final URL url;\n\n    /**\n     * 缓存监听\n     */\n    private final Set<StateListener> stateListeners = new CopyOnWriteArraySet<StateListener>();\n\n    /**\n     * 节点监听缓存\n     */\n    private final ConcurrentMap<String, ConcurrentMap<ChildListener, TargetChildListener>>\n            childListeners = new ConcurrentHashMap<String, ConcurrentMap<ChildListener, TargetChildListener>>();\n\n    /**\n     * 客户端是否已停止\n     */\n    private volatile boolean closed = false;\n\n    public AbstractZookeeperClient(URL url) {\n        this.url = url;\n    }\n\n    @Override\n    public URL getUrl() {\n        return url;\n    }\n\n    @Override\n    public void create(String path, boolean ephemeral) {\n        int i = path.lastIndexOf('/');\n        if (i > 0) {\n            //获取到父路径\n            String parentPath = path.substring(0, i);\n            if (!checkExists(parentPath)) {\n                //父路径不存在的话，进行递归创建\n                create(parentPath, false);\n            }\n        }\n        if (ephemeral) {\n            //创建临时节点\n            createEphemeral(path);\n        } else {\n            //创建持久节点\n            createPersistent(path);\n        }\n    }\n\n    @Override\n    public void addStateListener(StateListener listener) {\n        stateListeners.add(listener);\n    }\n    @Override\n    public void removeStateListener(StateListener listener) {\n        stateListeners.remove(listener);\n    }\n    public Set<StateListener> getSessionListeners() {\n        return stateListeners;\n    }\n    @Override\n    public List<String> addChildListener(String path, final ChildListener listener) {\n        //从缓存中获取path节点的监听\n        ConcurrentMap<ChildListener, TargetChildListener> listeners = childListeners.get(path);\n        if (listeners == null) {\n            childListeners.putIfAbsent(path, new ConcurrentHashMap<ChildListener, TargetChildListener>());\n            listeners = childListeners.get(path);\n        }\n        TargetChildListener targetListener = listeners.get(listener);\n        if (targetListener == null) {\n            //为节点path新创建一个监听，并放入listeners中\n            listeners.putIfAbsent(listener, createTargetChildListener(path, listener));\n            targetListener = listeners.get(listener);\n        }\n        //添加目标节点监听\n        return addTargetChildListener(path, targetListener);\n    }\n\n    @Override\n    public void removeChildListener(String path, ChildListener listener) {\n        //从缓存中获取path节点的监听\n        ConcurrentMap<ChildListener, TargetChildListener> listeners = childListeners.get(path);\n        if (listeners != null) {\n            //从缓存中移除监听listener\n            TargetChildListener targetListener = listeners.remove(listener);\n            if (targetListener != null) {\n                //移除目标节点的监听targetListener\n                removeTargetChildListener(path, targetListener);\n            }\n        }\n    }\n\n    /**\n     * 状态变更事件\n     * @param state\n     */\n    protected void stateChanged(int state) {\n        //遍历所有的监听器\n        for (StateListener sessionListener : getSessionListeners()) {\n\t    //执行变更事件\n            sessionListener.stateChanged(state);\n        }\n    }\n\n    @Override\n    public void close() {\n        if (closed) {\n\t    //已关闭\n            return;\n        }\n        closed = true;\n        try {\n            doClose();\n        } catch (Throwable t) {\n            logger.warn(t.getMessage(), t);\n        }\n    }\n    //************模板方法************\n    //关闭\n    protected abstract void doClose();\n    //创建持久节点\n    protected abstract void createPersistent(String path);\n    //创建临时节点\n    protected abstract void createEphemeral(String path);\n    //检测节点是否存在\n    protected abstract boolean checkExists(String path);\n    //创建目标节点监听\n    protected abstract TargetChildListener createTargetChildListener(String path, ChildListener listener);\n    //添加目标节点监听\n    protected abstract List<String> addTargetChildListener(String path, TargetChildListener listener);\n    //移除目标节点监听\n    protected abstract void removeTargetChildListener(String path, TargetChildListener listener);\n}\n```\n##### CuratorZookeeperClient实现\n```java\npublic class CuratorZookeeperClient extends AbstractZookeeperClient<CuratorWatcher> {\n    \n    //Curator客户端，对zk的操作都是由它来完成\n    private final CuratorFramework client;\n\n    public CuratorZookeeperClient(URL url) {\n        //设置注册中心url\n        super(url);\n        try {\n            CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()\n                    //指定注册中心url地址,多个地址使用逗号分隔\n                    .connectString(url.getBackupAddress())\n                    //设置重试策略，最大重试1次，重试间隔1000毫秒\n                    .retryPolicy(new RetryNTimes(1, 1000))\n                    //设置连接超时,单位ms,默认1500ms,这里设置5秒\n                    .connectionTimeoutMs(5000);\n            //获取url的username:password\n            String authority = url.getAuthority();\n            if (authority != null && authority.length() > 0) {\n                //添加授权\n                builder = builder.authorization(\"digest\", authority.getBytes());\n            }\n            //生成curator客户端\n            client = builder.build();\n            //监听客户端链接状态\n            client.getConnectionStateListenable().addListener(new ConnectionStateListener() {\n                @Override\n                public void stateChanged(CuratorFramework client, ConnectionState state) {\n                    if (state == ConnectionState.LOST) {\n                        //断开状态，则触发链接断开事件\n                        CuratorZookeeperClient.this.stateChanged(StateListener.DISCONNECTED);\n                    } else if (state == ConnectionState.CONNECTED) {\n                        //已连接状态，则触发链接事件\n                        CuratorZookeeperClient.this.stateChanged(StateListener.CONNECTED);\n                    } else if (state == ConnectionState.RECONNECTED) {\n                        //重连状态，则触发重连事件\n                        CuratorZookeeperClient.this.stateChanged(StateListener.RECONNECTED);\n                    }\n                }\n            });\n            //启动客户端\n            client.start();\n        } catch (Exception e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public void createPersistent(String path) {\n        try {\n            //创建持久化节点path\n            client.create().forPath(path);\n        } catch (NodeExistsException e) {\n        } catch (Exception e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public void createEphemeral(String path) {\n        try {\n            //创建临时节点path\n            client.create().withMode(CreateMode.EPHEMERAL).forPath(path);\n        } catch (NodeExistsException e) {\n        } catch (Exception e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public void delete(String path) {\n        try {\n            //删除节点path\n            client.delete().forPath(path);\n        } catch (NoNodeException e) {\n        } catch (Exception e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public List<String> getChildren(String path) {\n        try {\n            //获取path节点的子节点列表\n            return client.getChildren().forPath(path);\n        } catch (NoNodeException e) {\n            return null;\n        } catch (Exception e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public boolean checkExists(String path) {\n        try {\n            //检测path节点是否已存在\n            if (client.checkExists().forPath(path) != null) {\n                return true;\n            }\n        } catch (Exception e) {\n        }\n        return false;\n    }\n    @Override\n    public boolean isConnected() {\n        //是否已连接状态\n        return client.getZookeeperClient().isConnected();\n    }\n\n    @Override\n    public void doClose() {\n        //关闭客户端\n        client.close();\n    }\n\n    @Override\n    public CuratorWatcher createTargetChildListener(String path, ChildListener listener) {\n        //新创建一个目标节点监听\n        return new CuratorWatcherImpl(listener);\n    }\n\n    @Override\n    public List<String> addTargetChildListener(String path, CuratorWatcher listener) {\n        try {\n            //获取path子节点，并添加监听\n            return client.getChildren().usingWatcher(listener).forPath(path);\n        } catch (NoNodeException e) {\n            return null;\n        } catch (Exception e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public void removeTargetChildListener(String path, CuratorWatcher listener) {\n        //移除监听\n        ((CuratorWatcherImpl) listener).unwatch();\n    }\n   \n    /**\n     * 该内部类实现了CuratorWatcher接口\n     */\n    private class CuratorWatcherImpl implements CuratorWatcher {\n        //监听\n        private volatile ChildListener listener;\n        public CuratorWatcherImpl(ChildListener listener) {\n            this.listener = listener;\n        }\n        /**\n         * 取消监听\n         */\n        public void unwatch() {\n            this.listener = null;\n        }\n        @Override\n        public void process(WatchedEvent event) throws Exception {\n            if (listener != null) {\n                //变更节点\n                String path = event.getPath() == null ? \"\" : event.getPath();\n                //触发变更事件\n                listener.childChanged(path,\n                        //如果path为空，curator使用watcher将会抛出异常\n                        //如果客户端连接、断开连接服务器，zookeeper将会排队watched event事件\n                        StringUtils.isNotEmpty(path)\n                                //为path的子节点增加监听(当前CuratorWatcherImpl,只能使用1次)\n                                ? client.getChildren().usingWatcher(this).forPath(path)\n                                : Collections.<String>emptyList());\n            }\n        }\n    }\n}\n```\n##### ZkclientZookeeperClient实现\n```java\npublic class ZkclientZookeeperClient extends AbstractZookeeperClient<IZkChildListener> {\n    /**\n     * ZkClient包装类，下面的操作都会交给它来执行\n     */\n    private final ZkClientWrapper client;\n\n    private volatile KeeperState state = KeeperState.SyncConnected;\n\n    public ZkclientZookeeperClient(URL url) {\n        //设置注册中心地址\n        super(url);\n        //创建zkClient客户端\n        client = new ZkClientWrapper(url.getBackupAddress(), 30000);\n        //添加监听\n        client.addListener(new IZkStateListener() {\n            @Override\n            public void handleStateChanged(KeeperState state) throws Exception {\n\t\t//设置当前状态\n\t\tZkclientZookeeperClient.this.state = state;\n                if (state == KeeperState.Disconnected) {\n                    //触发断开连接事件\n                    stateChanged(StateListener.DISCONNECTED);\n                } else if (state == KeeperState.SyncConnected) {\n                    //触发连接成功事件\n                    stateChanged(StateListener.CONNECTED);\n                }\n            }\n            @Override\n            public void handleNewSession() throws Exception {\n                //触发重新连接事件\n                stateChanged(StateListener.RECONNECTED);\n            }\n        });\n        client.start();\n    }\n    @Override\n    public void createPersistent(String path) {\n        try {\n            client.createPersistent(path);\n        } catch (ZkNodeExistsException e) {\n        }\n    }\n    @Override\n    public void createEphemeral(String path) {\n        try {\n            client.createEphemeral(path);\n        } catch (ZkNodeExistsException e) {\n        }\n    }\n    @Override\n    public void delete(String path) {\n        try {\n            client.delete(path);\n        } catch (ZkNoNodeException e) {\n        }\n    }\n    @Override\n    public List<String> getChildren(String path) {\n        try {\n            return client.getChildren(path);\n        } catch (ZkNoNodeException e) {\n            return null;\n        }\n    }\n    @Override\n    public boolean checkExists(String path) {\n        try {\n            return client.exists(path);\n        } catch (Throwable t) {\n        }\n        return false;\n    }\n    @Override\n    public boolean isConnected() {\n        return state == KeeperState.SyncConnected;\n    }\n    @Override\n    public void doClose() {\n        client.close();\n    }\n    @Override\n    public IZkChildListener createTargetChildListener(String path, final ChildListener listener) {\n        return new IZkChildListener() {\n            @Override\n            public void handleChildChange(String parentPath, List<String> currentChilds) throws Exception {\n                //触发节点变更事件\n                listener.childChanged(parentPath, currentChilds);\n            }\n        };\n    }\n    @Override\n    public List<String> addTargetChildListener(String path, final IZkChildListener listener) {\n        return client.subscribeChildChanges(path, listener);\n    }\n    @Override\n    public void removeTargetChildListener(String path, IZkChildListener listener) {\n        client.unsubscribeChildChanges(path, listener);\n    }\n}\n```\n###### ZkClientWrapper包装类\nZkclient包装类可以在连接失效后自动监控连接的状态，使用方式与curator一致\n```java\npublic class ZkClientWrapper {\n\n    /**\n     * 获取客户端超时时间\n     */\n    private long timeout;\n    /**\n     * ZkClient客户端\n     */\n    private ZkClient client;\n    /**\n     * 当前状态\n     */\n    private volatile KeeperState state;\n\n    /**\n     * 可监听的FutureTask\n     */\n    private ListenableFutureTask<ZkClient> listenableFutureTask;\n    /**\n     * 客户端是否已启动\n     */\n    private volatile boolean started = false;\n\n    /**\n     * @param serverAddr 注册中心url\n     */\n    public ZkClientWrapper(final String serverAddr, long timeout) {\n        //设置超时\n        this.timeout = timeout;\n\n        //创建一个FutureTask，用来创建zkClient客户端\n        listenableFutureTask = ListenableFutureTask.create(new Callable<ZkClient>() {\n            @Override\n            public ZkClient call() throws Exception {\n\t        //创建ZkClient客户端\n                return new ZkClient(serverAddr, Integer.MAX_VALUE);\n            }\n        });\n    }\n   \n    /**\n     * 启动zkclient\n     */\n    public void start() {\n        if (!started) {\n            //新建守护线程，创建zkClient客户端\n            Thread connectThread = new Thread(listenableFutureTask);\n            connectThread.setName(\"DubboZkclientConnector\");\n            connectThread.setDaemon(true);\n            connectThread.start();\n            try {\n                //获取新创建的客户端\n                client = listenableFutureTask.get(timeout, TimeUnit.MILLISECONDS);\n            } catch (Throwable t) {\n\t        //获取client超时\n                logger.error(\"Timeout! zookeeper server can not be connected in : \" + timeout + \"ms!\", t);\n            }\n            started = true;\n        } else {\n            logger.warn(\"Zkclient has already been started!\");\n        }\n    }\n  \n    /**\n     * 添加监听listener\n     */\n    public void addListener(final IZkStateListener listener) {\n        //使用listenableFutureTask监听client的创建，client创建成功后在订阅该listener\n        listenableFutureTask.addListener(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    client = listenableFutureTask.get();\n                    //获取到客户端后，订阅listener\n                    client.subscribeStateChanges(listener);\n                } catch (InterruptedException e) {\n                    logger.warn(Thread.currentThread().getName() + \" was interrupted unexpectedly, which may cause unpredictable exception!\");\n                } catch (ExecutionException e) {\n                    logger.error(\"Got an exception when trying to create zkclient instance, can not connect to zookeeper server, please check!\", e);\n                }\n            }\n        });\n    }\n\n    public boolean isConnected() {\n        //是否已连接\n        return client != null && state == KeeperState.SyncConnected;\n    }\n\n    public void createPersistent(String path) {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        //创建持久化节点\n        client.createPersistent(path, true);\n    }\n\n    public void createEphemeral(String path) {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        //创建临时节点\n        client.createEphemeral(path);\n    }\n\n    public void delete(String path) {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        //删除节点\n        client.delete(path);\n    }\n\n    public List<String> getChildren(String path) {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        //获取path节点的子节点\n        return client.getChildren(path);\n    }\n\n    public boolean exists(String path) {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        //判断path节点是否存在\n        return client.exists(path);\n    }\n\n    public void close() {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        client.close();\n    }\n\n    public List<String> subscribeChildChanges(String path, final IZkChildListener listener) {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        //订阅path节点变更事件\n        return client.subscribeChildChanges(path, listener);\n    }\n\n    public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n        Assert.notNull(client, new IllegalStateException(\"Zookeeper is not connected yet!\"));\n        //取消订阅path节点变更事件\n        client.unsubscribeChildChanges(path, listener);\n    }\n}\n```\n\n关于zk注册中心的内容就介绍到这里，下一小节介绍其他注册中心的实现。\n\n","tags":["dubbo"]},{"title":"《k8s权威指南》- 笔记","url":"/blog/2018/08/19/k8s权威指南-笔记/","content":"Kubernetes是基于容器技术，目的是实现资源动态管理，以及跨多个数据中心的资源利用率的最大化的分布式架构方案。如果我们的系统设计遵循k8s的设计思想，那么传统系统架构中那些和业务没有多大关系的底层代码和功能模块，都可以统统不用考虑，我们不必在头疼于服务监控、故障处理等模块的开发，使用k8s提供的解决方案，我们可以节省大量的开发成本，降低系统运维的难度。\nk8s具有完备的集群管理能力，支持多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务发现和注册机制、内建的负载均衡器、故障发现和自我修复、服务滚动升级和在线自动扩容、可扩展的资源自动调度机制、以及多粒度的资源配额管理能力。\n\n在介绍k8s基础知识前，我们先来看下k8s基础组件图，然后我们参考着图一起来讲解。\n![](img/k8s.png)\n\n### Master\nMaster是整个k8s集群的控制节点，负责整个集群的管理和控制，基本上所有的控制命令都需要发给它，由它来负责具体的执行过程，因此Master节点非常重要，建议使用独立的服务器来部署，高可用部署建议用3台服务器。\nMaster节点上运行着3个重要的进程：\n* kube-apiserver：提供Http Rest接口的服务进程，是k8s里所有资源增、删、改、查等操作的唯一入口，也是集群控制的入口进程。\n* kube-controller-manager：k8s里面所有资源对象的自动化控制中心。\n* kube-schedule：负责资源调度(Pod调度)的进程。\n另外，Master节点上还需要启动一个etcd服务，因为k8s里所有资源对象的数据全部都是保存在etcd里面的。\n\n### Node\n除了Master节点以外，k8s集群里的其他机器被称为Node节点，每个Node节点都会被Master节点分配一些工作负载(docker容器),当某个Node节点宕机时，其上的工作负载会被Master自动转移到其他Node节点上去。\n每个Node节点上同样运行着一组重要进程：\n* kubelet：负责Pod对应的容器的创建、启停等任务，同时与Master节点密切协作，实现集群管理的基本功能。\n* kube-proxy：实现k8s Service的通信与负载均衡机制的重要组件。\n* Docker Engine：docker引擎，负责本机docker容器的创建和管理工作。\nNode节点可以在运行期间动态添加到k8s集群中，前提是该节点正确启动了上述进程。默认情况下，kubelet会向Master节点注册自己，然后kubelet会定时的向Master节点汇报自身的情报信息，例如：操作系统版本、docker版本、机器CPU内存情况、以及当前有哪些Pod在运行。这样Master便会知道每个Node节点的资源使用情况，并实现高效均衡的资源调度策略。如果某个Node节点超过指定时间没有上报信息，会被Master节点判定为\"失联\"，该Node节点状态将会被标记为不可用(Not Ready),随后，Master会触发相应的自动流程，将不可用的Node节点上的工作负载转移到其他Node节点上。\n### Service\nService是k8s的核心，它其实就是微服务架构中的一个\"微服务\"，每个Service对象都有如下特征：\n* 拥有一个唯一指定的名称(比如mysql-server)\n* 拥有一个虚拟IP(Cluster IP、Service IP 或 VIP，由k8s分配)和端口号(服务的访问入口地址)\n* 能够提供某种远程服务能力\n* 被映射到了提供这种服务能力的一组容器应用上\nService的服务进程目前都基于Socket通信方式对外提供服务，比如Redis、Mysql、Tomcat，或者是实现了某个具体业务的一个特定的Tcp Server进程，虽然一个Service通常由多个相关的服务进程来提供服务，每个服务进程都有一个独立的Endpoint(IP + Port)访问点(例如Tomcat有服务端口和管理端口)，但k8s能够让我们通过Service(Cluster IP + Service Port)连接到指定的Service上，通过k8s内建的透明负载均衡和故障恢复机制，不管后端有多少服务进程，也不管某个服务进程是否会由于发生故障而重新部署到其他机器上，都不会影响到我们对服务的正常调用，更重要的是这个Service一旦创建成功，就不会在发生变化，这意味着，在k8s集群中，我们再也不用为了服务的IP地址变来变去的问题而头疼了。\n通过上图，我们可以看到，前端应用Pod通过Service的入口地址，访问到了该Service背后一组由Pod副本组成的集群实例。Service是通过Label Select标签选择器机制与其后端Pod副本集群关联起来的，而ReplicationController的作用实际上是保证Service的服务能力和服务质量始终处于预期的标准(根据ReplicationController的副本数量配置，k8s会保证启动相应副本数的容器)\n\n\n### Pod\n容器提供了强大隔离功能，k8s为了实现Service服务隔离设计了Pod对象，将每个服务进程包装到相应的Pod中，使其成为Pod中运行的一个容器，为了建立Service和Pod的关联关系，k8s首先给每个Pod贴上一个标签(Label),例如给运行Mysql的Pod贴上name=mysql标签，给运行redis的Pod贴上name=redis的标签，然后给相应的Service定义标签选择器(Label Selector)，比如Redis集群Service的标签选择器的选择条件为name=redis，那么该Redis集群Service将会作用于所有包含name=redis标签的Pod上,这样一来，就解决了Service和Pod的关联问题。\n通过上图，我们可以看到Pod运行在Node节点上，通常每个Node节点上可以运行几百个Pod，而且运行一个被称为\"根容器\"的Pause容器。因为在一组容器作为一个单元的情况下，我们很难对一个\"整体\"进行简单的判断，例如，一个容器挂掉了，那么此时算是整体死亡吗？是N/M的死亡率吗？引入业务无关且不易挂掉的Pause容器作为Pod的根容器，以它的状态代表整个容器组的状态，就简单的解决了这个问题。另外，Pod里的多个业务容器共享Pause容器的IP，共享Pause容器挂接的Volume，这样即简化了密切关联的业务容器之间的通信问题，也很好的解决了它们之间的文件共享问题。\nk8s为每个Pod都分配了一个唯一的Pod IP，一个Pod里的多个容器共享该Pod IP地址，k8s要求底层网络支持集群内任意两个Pod之间的TCP/IP直接通信，这通常采用\"虚拟二层网络\"技术来实现，例如：Flannel、Open vSwitch等，因此，我们需要牢记一点：在k8s里，一个Pod里的容器与另外主机上的Pod容器能够直接通信。\nPod分为两种类型：普通的Pod和静态的Pod，静态Pod比较特殊，它并不在k8s的etcd中存储，而是存在在某个具体的Node上的一个具体文件中，并且只在此Node上运行，而普通的Pod一旦创建，就会被放入etcd中存储，随后会被k8s的Master调度到某个具体的Node上进行绑定，随后该Pod被对应的Node上的kubelet进程实例化为一组相关的Docker容器并启动起来。在默认情况下，当Pod里的某个容器停止时，k8s会自动检测到这个问题并且重启该Pod(重启Pod里的所有容器)，如果Pod所在的Node宕机，则会将这个Node上的所有Pod重新调度到其他节点上运行。\n\n\nPod IP 加上容器的Port，就组成了Endpoint，它代表着此Pod里的一个服务进程的对外通信地址，一个Pod也存在着具有多个Endpoint的情况，比如当我们把Tomcat定义为一个Pod时，可以对外暴露管理端口和服务端口这两个Endpoint.\n\nk8s的Event是一个事件的记录，记录了事件的最早产生时间、最后重现事件、重复次数、发起者、类型，以及导致此事件的原因等众多信息，Event通常会关联到某个具体的资源对象上，是排查故障的重要参考信息。\n\n#### Service 和 Pod\n既然每个Pod都会被分配唯一的Pod IP，而且每个Pod都提供了一个独立的Endpoint(Pod IP + 容器Port)以被客户端访问，现在多个Pod副本就组成了一个集群来提供服务，那么客户端该如何来访问它们呢？\n一般的做法是部署一个负载均衡器，为这组Pod开启一个对外的服务端口如8000端口，并且将这些Pod的Endpoint列表加入8000端口的转发列表中，客户端就可以通过负载均衡器的对外IP地址+服务端口来访问此服务了，而客户端的请求最后会被转发到哪个Pod，则由负载均衡器的算法来决定。\nk8s也遵循了上述常规做法，运行在每个Node上的kube-proxy进程其实就是一个智能的软件负载均衡器，它负责把对Service的请求转发到后端的某个Pod实例上，并在内部实现服务的负载均衡和回话保持机制。但k8s发明了一种很巧妙的设计：Service不是共用一个负载均衡器的IP地址，而是每个Service被分配了一个全局唯一的虚拟的Cluster IP，这样一来，每个服务就变成了具备唯一IP地址的\"通信节点\"，服务调用就变成了最基础的TCP网络通信问题。\n我们知道Pod的Endpoint地址会随着Pod的销毁和重新创建而发生改变，因此新Pod的IP地址和旧Pod的IP地址不同。而Service的一旦被创建，k8s就会自动为它分配一个可用的Cluster IP，而且在Service的整个生命周期内，它的Cluster IP都不会发生改变，于是服务发现这个问题在k8s的架构里就得以轻松解决：只需要用Service的Name和Service的Cluster IP做一个DNS域名映射就可以完美解决问题。\n那么如何实现通过Service的Name来查找对应的Cluster IP呢？\n最早以前，k8s采用了Linux环境变量的方式，为每个Service生成一些对应的环境变量，并在每个Pod的容器启动时，自动注入这些环境变量，但是这样使用起来仍然不够直观。后来k8s通过Add-On增值包的方式引入了DNS系统，把Service的Name作为DNS的域名，这样一来，程序就可以直接使用Service的Name来建立通信了。\n\n#### 外部系统访问Service的问题\n我们再来看下k8s里面的三种IP：\n\n* Node IP\nNode节点的IP，是每个Node节点的物理网卡的IP，这是一个真实存在的物理网络，所有属于这个网络的服务器之间都能通过这个网络直接通信，不管它们中是否有不属于该k8s集群的节点。这也表明，k8s集群之外的节点想要访问k8s集群内的某个节点或者TCP/IP服务时，必须要通过Node IP进行通信。\n* Pod IP\nPod IP是每个Pod的IP地址，它是Docker Engine根据docker0网桥的IP地址段进行分配的，通常是一个虚拟的二层网络，前面我们说过，k8s要求位于不同Node上的Pod能够彼此直接通信，所以一个Pod里的容器访问另一个Pod里的容器，就是通过Pod IP所在的虚拟二层网络进行通信的，而真实的TCP/IP流量则是通过Node IP所在的物理网卡流出的。\n* Cluster IP\n它也是一个虚拟IP，仅作用于k8s的Service对象，并由k8s管理和分配IP地址(来源于Cluster IP地址池)。Cluster IP只能结合Service Port组成一个具体的通信端口，单独的Cluster IP不具备TCP/IP通信基础。\n\n通过上面的说明，我们明白了，Service的Cluster IP属于k8s集群内部的地址，无法在集群外部直接使用这个地址。那么用户该如何访问我们的tomcat-service呢？使用NodePort是解决上述问题最有效的方法。\nNodePort的实现方式是：在k8s集群里的每个Node上为需要外部访问的Service开启一个对应的TCP监听端口，外部系统只需要用任意一个Node的IP地址+具体的NodePort端口就可以访问该服务。假如我们配置了NodePort=31002，然后在任意的Node上运行netstat命令，就可以看到有NodePort端口被监听。\n\n\n### Label\n一个Label就是一个key=value的键值对，其中key和value由用户自己定义，Label可以附加到各种资源对象上，例如：Node、Pod、Servoce、Replication Controller等，一个资源对象可以定义任意数量的Label，同一个Label也可以添加到任意数量的资源对象上，Label可以在资源对象定义时确定，也可以在资源对象创建后动态添加或者删除。\n我们可以通过给指定的资源对象附加多个不同的Label来实现多维度的资源分组管理功能，以便于灵活方便的进行资源分配、调度、配置、部署等管理工作。例如：部署不同版本的应用到不同的环境中。\n一些常用的Label标签示例如下：\n* 版本标签：\"release\":\"stable\",\"release\":\"canary\"\n* 环境标签：\"env\":\"test\",\"env\":\"uat\",\"env\":\"pro\"\n给某个资源对象附加一些标签，随后我们可以通过Label Selector(标签选择器)查询和筛选拥有某些Label标签的资源对象。\n当前有两种Lavel Selector的表达式：基于等式的和基于集合的，例如：\n* name = redis-slave ，匹配所有拥有name = redis-slave标签的资源对象\n* env != pro，匹配所有不具有env = pro标签的资源对象\n* name in (redis-master,redis-slave)，匹配所有拥有name = redis-master 或者 name = redis-slave标签的资源对象\n* name not in (php)，匹配所有不具有name = php标签的资源对象\n可以通过使用多个Label Selector进行组合来实现复杂的条件选择，多个Label Selector使用逗号进行分割，几个条件之间是\"AND\"的关系，例如：\nname = redis-slave,env != pro\n\nLabel Selector在k8s中的有如下重要场景：\n* kube-contoller进程通过资源对象RC上定义的Label Selector来筛选要监控的Pod副本的数量，从而实现Pod副本的数量始终符合预期设定的全自动控制流程。\n* kube-proxy进程通过Service的Label Selector来选择对应的Pod，自动建立起每个Service到对应Pod的请求转发路由表，从而实现Service的智能路由负载均衡机制。\n* 通过对某些Node定义特定的Label，并且在Pod定义文件中使用NodeSelector这种标签调度策略，kube-schedule进程可以实现Pod\"定向调度\"的特性。\n总结：使用Label可以给资源对象创建多组标签，Label和Label Selector共同构成了k8s系统中最核心的应用模型，使得被管理对象能够被精细的分组管理，同时实现了整个集群的高可用性。\n\n\n### Replication Controller\n\nRC定义了一个期望的场景，即声明某种Pod的副本数量在任意时刻都符合某个预期值。所以RC的定义包括如下几个部分：\n* Pod期待的副本数\n* 用于筛选目标Pod的Label Selector\n* 当Pod的副本数量小于预期数量时，用户创建新Pod的Pod模板\n\n当我们定义了一个RC，并提交到k8s集群以后，Master节点上的Controller Manager组件就会得到通知，定期巡检系统中当前存活的目标Pod，并确保目标Pod的实例的数量刚好等于此Pod的期望值，如果有过多的Pod副本在运行，系统就会停掉一些Pod，否则系统会在创建一些Pod，通过RC，k8s实现了用户应用集群的高可用性，也大大减少了运维的手工操作。\n此外，在运行时，我们可以通过修改RC的副本数量，来实现Pod的动态缩放功能。\n需要注意的是，删除RC定义并不会影响通过该RC已创建好的Pod，为了删除所有的Pod，可以设置副本数为0，然后更新该RC，或者使用kubectl工具命令来一次性删除RC及其管理的Pod。\n当我们的应用升级时，通常会build一个新的Docker镜像，并用新的镜像版本来替换旧的版本的方式来达到目的。如果我们想要平滑的升级，即停止一台旧的，启动一台新的，在整个升级过程中，此消彼长，而运行中的Pod数量始终是10个，几分钟过后，当所有的Pod都已经是新版本时，升级过程完成。通过RC的机制，k8s可以很容易的实现\"滚动升级\"。\n在新版本中k8s新增加了一个Replica Set资源对象，它和RC唯一的区别是：Replica Set是基于集合的Label Selector，而RC是基于等式的Label Selector.当前我们很少单独使用Replica Set，它主要被Deployment这个更高层次的资源对象所使用，从而形成一整套Pod创建、删除、更新的编排机制，当我们使用Deployment时，无需关心它是如何创建和维护Replica Set的，这一切都是自动发生的.\n\n最后，我们总结下关于RC的一些特性和作用：\n* 在大多数情况下，我们通过定义一个RC实现Pod的创建过程及副本数量的自动控制\n* RC里包括完成的Pod定义模板\n* RC通过Label Selector机制实现对Pod副本的自动控制\n* 通过改变RC里的Pod副本数量，可以实现Pod的扩容和缩容功能\n* 通过改变RC里Pod模板中的镜像版本，可以实现Pod的滚动升级功能\n\n\n### Deployment\nDeployment是加强版的RC，它是为了更好的解决Pod的编排问题，在内部使用了Replica Set来实现相应的目的。Deployment的典型使用场景如下：\n* 创建一个Deployment对象来生成对应的Replica Set并完成Pod副本的创建过程。\n* 检查Deployment的状态来查看部署动作是否完成(Pod副本的数量是否达到预期的值)\n* 更新Deployment以创建新的Pod(比如镜像升级)\n* 如果当前Deployment不稳定，则回滚到一个早先的Deployment版本\n* 暂停Deployment以便于一次性修改多个Pod模板的配置项，之后在恢复Deployment，进行新的发布\n* 扩展Deployment以应对高负载\n* 查看Deployment的状态，以此作为发布是否成功的指标\n* 清理不再需要的旧版本的ReplicaSets\n其中Replica Set的名称以Deployment的名称为前缀，Pod的命名以Deployment对应的Replica Set的名字作为前缀，这种命名很清晰的表明了一个Replica Set创建了哪些Pod，对于Pod滚动升级这种复杂的过程来说，很容易进行排查错误。\n\n### Horizontal Pod Autoscaler\n前面我们提到，通过手工执行kubectl scale命令，可以实现Pod的扩容和缩容，但是这并不符合Google对k8s的定位目标————自动化、智能化，分布式系统应该可以根据当前负载的变化情况自动触发水平扩展或缩容的行为，因为这一过程可能是频繁发生的、不可预料的，所以手动来控制的方式不现实。\nHPA与RC、Deployment一样，也属于一种资源对象，通过追踪分析RC控制的所有目标Pod的负载变化情况，来确定是否需要针对性的调整目标Pod的副本数，这是HPA的实现原理，当前，HPA可以有如下两种方式作为Pod负载的度量指标：\n* CPUUtilizationPercentage\n* 应用程序自定义的度量指标，比如服务在每秒内的相应请求数(TPS或QPS)\nCPUUtilizationPercentage是一个算术平均值，即目标Pod所有副本自身的CPU利用率的平均值，一个Pod自身的CPU利用率是该Pod当前CPU的使用量(通常是一分钟内的平均值)除以它的Pod Request的值。比如：我们定义一个Pod的Pod Request为0.4，而当前Pod的CPU使用量为0.2，则它的CPU使用率为50%，如此一来，我们便可以算出来一个RC控制的所有Pod副本的CPU利用率的算术平均值了，如果某一时刻CPUUtilizationPercentage的值超过了80%，则意味着当前Pod的副本数很可能不足以支撑接下来更多的请求，需要进行动态扩容，而当请求高峰时段过去后，Pod的CPU利用率又会降下来，此时对应的Pod的副本数应该自动减少到一个合理的水平。\n\n### StatefulSet\n在k8s系统中，Pod的管理对象RC、Deployment、DaemonSet和Job都是无状态的服务。但现实中有很多服务是有状态的，比如Mysql集群、MongoDB集群、Akka集群、Zookeeper集群等，这些集群有如下共同点：\n* 每个节点都有一个固定的身份ID，通过这个ID，集群中的成员可以互相发现并进行通信\n* 集群的规模比较固定，不能随意变动\n* 即群里的每个节点都是有状态的，通常会持久化数据到永久存储中\n* 如果磁盘损坏，则集群里的某个节点无法正常运行，集群功能受损\n如果用RC/Deployment控制的Pod副本数的方式来实现上述有状态的集群，则我们会发现第一点是无法满足的，因为Pod的名称是随机产生的，Pod的IP地址也是在运行期才确定且可能有变动的，我们事先无法为每个Pod确定唯一不变的ID，另外，为了能够在其他节点上恢复某个失败的节点，这种集群中的Pod需要挂接某种共享存储，为了解决这个问题，k8s引入了StatefulSet这个新的资源对象，它有如下特性：\n* StatefulSet里的每个Pod都有稳定、唯一的网络标识，可以用来发现集群内的其他成员。假设StatefulSet的名字叫kafka，那么它的第一个Pod叫kakfa-0，第二个叫kafka-1，以此类推\n* StatefulSet控制的Pod副本的启停顺序是受控的，操作第n个Pod时，前n-1个Pod已经是运行且准备好的状态\n* StatefulSet里的Pod采用稳定的持久化存储卷，通过PV/PVC来实现，为了保护数据的安全，删除Pod时默认不会删除与StatefulSet相关的存储卷\nStatefulSet除了要与PV卷捆绑使用以存储Pod的状态数据，还要与Headless Service配合使用，即在每个StatefulSet的定义中要声明它属于哪个Headless Service。Headless Service与Service的区别在于，它没有Cluster IP，如果解析Headless Service的DNS域名，则返回的是该Service对应的全部Pod的Endpoint列表，StatefulSet在Headless Service的基础上又为StatefulSet控制的每一个Pod实例创建了一个DNS域名，域名格式如下：\n```shell\n$(podname).$(headless Service name)\n```\n比如一个3节点的Kafka的StatefulSet集群，对应的Headless Service的名称为kafka，StatefulSet的名称为kafka，则StatefulSet里面的3个Pod的DNS名称分别为：kafka-0.kafka、kafka-1.kafka、kafka-2.kafka，这些DNS名称可以直接在集群的配置文件中固定下来。\n\n### Volume\nVolume是Pod中能够被多个容器访问的共享目录，它与Docker中的Volume比较类似，但两者不能等价。首先，k8s中的Volume定义在Pod上，然后被一个Pod里面的多个容器挂载到具体的文件目录下；其次，k8s中的Volume与Pod的生命周期相同，但与容器的生命周期无关，当容器终止或者重启时，Volume中的数据也不会丢失。最后，k8s的Volume支持多种类型的Volume，例如：GlusterFS、Ceph等先进的分布式文件系统。\nVolume的使用比较简单，在大多少情况下，我们只需要先在Pod上声明一个Volume，然后在容器里引用该Volume，并挂载到容器里的某个目录上。\n除了可以让一个Pod里的多个容器共享文件、让容器的数据写到宿主机的磁盘上或者写文件到网络存储中，k8s的Volume还扩展出了一种非常有实用价值的功能，即容器配置文件集中化定义和管理，这是通过ConfigMap资源对象来实现的。\n### Persistent Volume\n之前我们提到的Volume是定义在Pod上的，属于计算资源的一部分，而网络存储是相对独立于计算资源而存在的一种实体资源，比如在使用虚拟机的情况下，我们通常会先定义一个网络存储，然后从中划出一个网盘并挂接到虚拟机上。PV(Persistent Volume)和与之相关联的PVC(Persistent Volume Claim)也起到了类似的作用.\nPV可以理解成k8s集群中某个网络存储中对应的一块存储，它与Volume类似，但是有如下区别：\n* PV只能是网络存储，不属于任何Node，但可以在每个Node上使用\n* PV并不是定义在Pod上的，而是独立于Pod之外定义\n* PV目前支持的类型包括：NFS、gcePersistentDisk、AWSElasticBlockStore、GlusterFS等\n如果某个Pod想要申请某种类型的PV，则需要先定义一个PVC对象，然后在Pod的Volume定义中引用上述PVC即可。\n另外PV是有状态的对象：\n* Available：空闲状态\n* Bound: 已经绑定到某个PVC上\n* Released：对应的PVC已经删除，但资源还没有被集群回收\n* Failed：PV自动回收失败\n\n### Namespace\nNamespace在很多情况下用于实现多租户的资源隔离，Namespace通过将集群内部的资源对象\"分配\"到不同的Namespace中，形成逻辑上分组的不同项目、小组或用户组，便于不同的分组在共享使用整个集群的资源的同时还能被分别管理。\n\nk8s集群在启动后，会创建一个名为\"default\"的Namespace，如果不特别指明Namespace，则用户创建的Pod、RC、Service都将被系统创建到这个默认的default名下。\n当我们为每个租户创建一个Namespace来实现多租户的资源隔离时，还能结合k8s的资源配额管理，限定不同租户能占用的资源，例如CPU使用量、内存使用量等。\n\n### Annotation\nAnnotation和Label类似，也是使用kv对定义，不同的是，Label有严格的命名规则，它定义的是k8s对象的元数据，并且用户Label Selector。而Annotation则是用户任意定义的附加信息，以便于外部工具进行查找。很多时候，k8s的模块自身会通过Annotation的方式标记资源对象的一些特殊信息。通常来说，用Annotation来记录如下信息：\n* build信息、release信息、Docker镜像信息等，例如时间戳、release id号、PR号、镜像hash值、docker registry地址等\n* 日志库、监控库、分析库等资源库的地址信息\n* 程序调试工具信息，例如工具名称、版本号等\n* 团队的联系信息，例如：手机号、负责人名称、网址等\n\n","tags":["k8s"]},{"title":"《Haskell趣学指南》- 笔记","url":"/blog/2018/08/19/Haskell趣学指南-笔记/","content":"\n### 模式匹配与递归\n\n### 类型\n\n### 类型类\n\n### 常用函数\n\n### Functor\n\n#### Functor定律\n\n### Applicative\n\n#### Applicative定律\n\n### Monoid\n\n#### Monoid定律\n\n### Monad\n\n#### Monad定律\n\n#### IO Monad\n\n#### Writer Monad\n\n#### Reader Monad\n\n#### State Monad\n\n#### Error Monad\n\n#### 自定义Monad\n\n\n","tags":["haskell"]},{"title":"Dubbo源码阅读之注册中心","url":"/blog/2018/08/17/Dubbo源码阅读之注册中心/","content":">注册中心是Dubbo实现服务化管理的核心组件,类似于目录服务的作用,主要用来存储Dubbo发布的服务信息(譬如提供者url串、路由信息等),Dubbo框架支持zookeeper、redis、multicast等注册中心,下面我们就详细看下Dubbo的注册中心是如何实现的。\n\n先来看下注册中心相关的类图\n![](img/registry.png)\n\n### Registry接口\n```java\npublic interface Registry extends Node, RegistryService {\n}\n```\n#### Node接口\n```java\npublic interface Node {\n    /**\n     * 获取url\n     * @return url.\n     */\n    URL getUrl();\n\n    /**\n     * 是否可用\n     * @return available.\n     */\n    boolean isAvailable();\n\n    /**\n     * 销毁\n     */\n    void destroy();\n}\n```\n\n#### RegistryService接口\n```java\npublic interface RegistryService {\n    /**\n     * 注册数据，例如：提供者服务，消费者服务，路由规则，覆盖规则和其他数据\n     * 注册时需要满足以下邀约：\n     * 1、当Url设置check = false参数时，注册失败时，异常不会抛出，并且会在后台重试，否则，异常将会抛出\n     * 2、当url设置dynamic=false参数时，它需要被永久存储，否则，当注册有异常退出时，它应该被自动删除掉\n     * 3、当url设置category=routers参数时，这意味着分类存储，默认的分类是提供者，并且数据可以通过分类部分得到通知\n     * 4、当注册中心重启，网络抖动，数据不可以丢失，包括自动从虚线中删除数据\n     * 5、允许具有相同URL但是参数不同的URL共存，他们不可以互相覆盖\n     *\n     * @param url 注册信息，不允许为空\n     * 例如：dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&application=kylin\n     */\n    void register(URL url);\n\n    /**\n     * 取消注册\n     * 1、如果它是dynamic=false的持久化存储数据，注册信息不可以发现时，会抛出IllegalStateException异常，\n     *    否则它是忽略的。\n     * 2、根据完整的url匹配进行取消注册\n     * @param url 注册信息,不可以为空 \n     * 例如： dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&application=kylin\n     */\n    void unregister(URL url);\n\n    /**\n     * 订阅符合条件的注册数据，并在注册数据发生改变时自动推送\n     *\n     * 1、当URL设置check=false参数时，当注册失败时，异常不会抛出，并在后台重试。\n     * 2、当url设置category=routers时，它只会通知指定的分类数据，多个分类用逗号分隔，\n     *      并允许使用*号匹配，这表明所有分类数据都已经订阅。\n     * 3、允许interface, group, version,classifier作为一个条件查询，\n     *      例如：interface=com.alibaba.foo.BarService&version=1.0.0\n     * 4、查询条件允许*号匹配，订阅所有接口的所有数据包的所有版本,\n     *      例如：interface=*&group=*&version=*&classifier=*\n     * 5、当注册中心重启、网络抖动时，有必要自动恢复订阅请求。\n     * 6、允许具有相同的url但是参数不同的URL共存,它们不可以互相覆盖\n     * 7、订阅的进程必须是阻塞的，当第一条通知完成后返回。\n     * @param url 订阅条件，不允许为空\n     * 例如: consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&application=kylin\n     * @param listener 变更事件的监听者，不可以为空\n     */\n    void subscribe(URL url, NotifyListener listener);\n\n    /**\n     * 取消订阅\n     *  1、如果没有订阅，直接忽略\n     *  2、取消订阅，需要URL全匹配\n     * @param url  订阅条件，不可以为空\n     * 例如： consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&application=kylin\n     * @param listener 变更事件的监听者,不允许为空\n     */\n    void unsubscribe(URL url, NotifyListener listener);\n\n    /**\n     * 查询符合条件的注册数据，对应于订阅的push模式，这是pull模式并只返回一个结果\n     * @param url 查询条件，不允许为空\n     *   e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&application=kylin\n     * @return 已注册的信息列表, 可能为空, 意义与{NotifyListener#notify(List<URL>)}的参数相同.\n     */\n    List<URL> lookup(URL url);\n}\n```\n\n### NotifyListener接口\n监听器，监听服务的变更\n```java\npublic interface NotifyListener {\n    /**\n     * 当收到服务更改的通知时触发该方法\n     * 1、始终是在服务接口和数据类型的纬度上通知。也就是说，不会通知属于一个服务的部分相同类型的数据，用户无需比较先前通知的结果\n     * 2、订阅时的第一个通知必须是服务所有类型的完整通知\n     * 3、在变更时，允许单独通知不同类型的数据，例如：providers, consumers, routers, overrides,它只允许通知其中一种类型，\n     *    但此类型的数据必须是完整的，而不是增量的\n     * 4、如果数据类型为空，则需要通过url数据的类别参数标识空协议\n     * 5、notifications保证通知的顺序(即registry的实现),例如：单线程推送、队列序列化、版本比较\n     * @param urls 已注册的信息列表,非空,这意味着，它和RegistryService#lookup(URL)方法的返回值相同.\n     */\n    void notify(List<URL> urls);\n}\n```\n\n### AbstractRegistry抽象类\n```java\npublic abstract class AbstractRegistry implements Registry {\n\n    /**\n     * URL地址分隔符，用来文件缓存，服务提供者URL分隔\n     * URL address separator, used in file cache, service provider URL separation\n     */\n    private static final char URL_SEPARATOR = ' ';\n    /**\n     * URL地址正则表达式分隔器，用来解析文件缓存中的服务提供者的URL列表\n     * 这里是空格分隔\n     * URL address separated regular expression for parsing the service provider URL list in the file cache\n     */\n    private static final String URL_SPLIT = \"\\\\s+\";\n    /**\n     * 日志输出\n     * Log output\n     */\n    protected final Logger logger = LoggerFactory.getLogger(getClass());\n    /**\n     * 本地磁盘缓存，其中key“value.registies”用来记录注册中心的列表。\n     * 其他的是通知服务提供者的列表\n     * Local disk cache, where the special key value.registies records the list of registry centers,\n     * and the others are the list of notified service providers\n     */\n    private final Properties properties = new Properties();\n    /**\n     * 文件缓存定时写线程\n     * File cache timing writing\n     */\n    private final ExecutorService registryCacheExecutor = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"DubboSaveRegistryCache\", true));\n    /**\n     * 是否同步保存文件\n     * Is it synchronized to save the file\n     */\n    private final boolean syncSaveFile;\n    /**\n     * 每次更新缓存文件时，都会自增，作为版本号\n     */\n    private final AtomicLong lastCacheChanged = new AtomicLong();\n    /**\n     * 已注册的地址\n     * 暴露的服务的URL集合，即export参数指定的URL\n     */\n    private final Set<URL> registered = new ConcurrentHashSet<URL>();\n    /**\n     * 已订阅的记录\n     * URL变化时，触发NotifyListener\n     * 例如：<服务提供者URL，OverrideListener>\n     */\n    private final ConcurrentMap<URL, Set<NotifyListener>> subscribed = new ConcurrentHashMap<URL, Set<NotifyListener>>();\n    /**\n     * 已通知的url\n     * 会将 <订阅url的服务唯一名称,待通知类别Url列表>写入注册中心缓存文件\n     * <订阅url,<待通知类别, 待通知类别Url列表>>\n     */\n    private final ConcurrentMap<URL, Map<String, List<URL>>> notified = new ConcurrentHashMap<URL, Map<String, List<URL>>>();\n\n    /**\n     * 注册中心URL\n     */\n    private URL registryUrl;\n    /**\n     * 本地磁盘缓存文件(dubbo注册中心缓存)\n     * Local disk cache file\n     */\n    private File file;\n\n    /**\n     *\n     * @param url multicast://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&dubbo=2.0.0&interface=com.alibaba.dubbo.registry.RegistryService&pid=3000&qos.port=22222&timestamp=1528800181027\n     */\n    public AbstractRegistry(URL url) {\n        //校验url不为空，并设置registryUrl = url\n        setUrl(url);\n        // Start file save timer\n        //是否同步保存文件，默认是异步\n        syncSaveFile = url.getParameter(Constants.REGISTRY_FILESAVE_SYNC_KEY, false);\n        //文件名，默认值是：C:\\Users\\Administrator/.dubbo/dubbo-registry-demo-provider-224.5.6.7:1234.cache\n        String filename = url.getParameter(Constants.FILE_KEY, System.getProperty(\"user.home\") + \"/.dubbo/dubbo-registry-\" + url.getParameter(Constants.APPLICATION_KEY) + \"-\" + url.getAddress() + \".cache\");\n        File file = null;\n        if (ConfigUtils.isNotEmpty(filename)) {\n            //创建文件目录\n            file = new File(filename);\n            if (!file.exists() && file.getParentFile() != null && !file.getParentFile().exists()) {\n                if (!file.getParentFile().mkdirs()) {\n                    throw new IllegalArgumentException(\"Invalid registry store file \" + file + \", cause: Failed to create directory \" + file.getParentFile() + \"!\");\n                }\n            }\n        }\n        this.file = file;\n        //加载注册中心缓存file\n        loadProperties();\n        //使用所有的url，进行通知\n        notify(url.getBackupUrls());\n    }\n\n\n    /**\n     * urls 为空的话，会根据url生成一个protocol = empty的URL放入urls并返回（即NotifyListener接口的第4条邀约）\n     * @param url 订阅url\n     * @param urls 注册中心url列表\n     * @return\n     */\n    protected static List<URL> filterEmpty(URL url, List<URL> urls) {\n        if (urls == null || urls.isEmpty()) {\n            //urls为空的话，则设置url的protocol = empty\n            List<URL> result = new ArrayList<URL>(1);\n            //设置protocol = empty\n            result.add(url.setProtocol(Constants.EMPTY_PROTOCOL));\n            return result;\n        }\n        return urls;\n    }\n\n    @Override\n    public URL getUrl() {\n        return registryUrl;\n    }\n\n    protected void setUrl(URL url) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"registry url == null\");\n        }\n\t//设置注册中心url\n        this.registryUrl = url;\n    }\n\n    public Set<URL> getRegistered() {\n        return registered;\n    }\n\n    public Map<URL, Set<NotifyListener>> getSubscribed() {\n        return subscribed;\n    }\n\n    public Map<URL, Map<String, List<URL>>> getNotified() {\n        return notified;\n    }\n\n    public File getCacheFile() {\n        return file;\n    }\n\n    public Properties getCacheProperties() {\n        return properties;\n    }\n\n    public AtomicLong getLastCacheChanged() {\n        return lastCacheChanged;\n    }\n\n    /**\n     * 保存注册中心缓存文件\n     * @param version 版本\n     */\n    public void doSaveProperties(long version) {\n        //如果version小与当前的版本号，说明在执行该方法时，lastCacheChanged又被更新了\n        //因此这里只需要直接返回,等待下一次执行\n        if (version < lastCacheChanged.get()) {\n            return;\n        }\n        if (file == null) {\n            return;\n        }\n        // Save\n        try {\n            //创建一个文件锁\n            File lockfile = new File(file.getAbsolutePath() + \".lock\");\n            if (!lockfile.exists()) {\n                lockfile.createNewFile();\n            }\n            RandomAccessFile raf = new RandomAccessFile(lockfile, \"rw\");\n            try {\n                FileChannel channel = raf.getChannel();\n                try {\n                    //获取排它锁\n                    FileLock lock = channel.tryLock();\n                    if (lock == null) {\n                        //不可以锁定注册中心缓存文件,忽略并稍后重试\n                        //可能多个java进程使用该文件，请配置：dubbo.registry.file=xxx.properties\n                        throw new IOException(\"Can not lock the registry cache file \" + file.getAbsolutePath() + \", ignore and retry later, maybe multi java process use the file, please config: dubbo.registry.file=xxx.properties\");\n                    }\n                    // Save\n                    try {\n                        //缓存文件不存在的话，新创建\n                        if (!file.exists()) {\n                            file.createNewFile();\n                        }\n                        FileOutputStream outputFile = new FileOutputStream(file);\n                        try {\n                            //保存properties文件\n                            properties.store(outputFile, \"Dubbo Registry Cache\");\n                        } finally {\n                            outputFile.close();\n                        }\n                    } finally {\n                        //释放锁\n                        lock.release();\n                    }\n                } finally {\n                    channel.close();\n                }\n            } finally {\n                raf.close();\n            }\n        } catch (Throwable e) {\n            if (version < lastCacheChanged.get()) {\n                return;\n            } else {\n                //如果version >= 当前版本的话，则执行异步保存properties文件\n                registryCacheExecutor.execute(new SaveProperties(lastCacheChanged.incrementAndGet()));\n            }\n            logger.warn(\"Failed to save registry store file, cause: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * 加载注册中心缓存文件\n     */\n    private void loadProperties() {\n        if (file != null && file.exists()) {\n            InputStream in = null;\n            try {\n                in = new FileInputStream(file);\n                properties.load(in);\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"Load registry store file \" + file + \", data: \" + properties);\n                }\n            } catch (Throwable e) {\n                logger.warn(\"Failed to load registry store file \" + file, e);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e) {\n                        logger.warn(e.getMessage(), e);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * 根据订阅url获取已缓存的待通知url列表\n     * 即从配置文件中找到属性key等于url.getServiceKey()的属性值\n     * @param url\n     * @return\n     */\n    public List<URL> getCacheUrls(URL url) {\n        for (Map.Entry<Object, Object> entry : properties.entrySet()) {\n            //订阅url的服务唯一名称\n            String key = (String) entry.getKey();\n            //类别待通知url列表，空格分隔\n            String value = (String) entry.getValue();\n\n            if (key != null && key.length() > 0 && key.equals(url.getServiceKey())\n                    //key的第一个字节是字母或者是下划线\n                    && (Character.isLetter(key.charAt(0)) || key.charAt(0) == '_')\n                    && value != null && value.length() > 0) {\n                //使用空格分隔value，拿到每一个url并放到List中\n                String[] arr = value.trim().split(URL_SPLIT);\n                List<URL> urls = new ArrayList<URL>();\n                for (String u : arr) {\n                    urls.add(URL.valueOf(u));\n                }\n                return urls;\n            }\n        }\n        return null;\n    }\n\n\n    @Override\n    public List<URL> lookup(URL url) {\n        List<URL> result = new ArrayList<URL>();\n        //根据订阅url获取已通知的url列表\n        Map<String, List<URL>> notifiedUrls = getNotified().get(url);\n        if (notifiedUrls != null && notifiedUrls.size() > 0) {\n            //notifiedUrls不为空\n            for (List<URL> urls : notifiedUrls.values()) {\n                for (URL u : urls) {\n                    //过滤掉protocol = empty的url\n                    if (!Constants.EMPTY_PROTOCOL.equals(u.getProtocol())) {\n                        result.add(u);\n                    }\n                }\n            }\n        } else {\n            final AtomicReference<List<URL>> reference = new AtomicReference<List<URL>>();\n            NotifyListener listener = new NotifyListener() {\n                @Override\n                public void notify(List<URL> urls) {\n                    reference.set(urls);\n                }\n            };\n            // 订阅逻辑保证第一次notify后再返回\n            subscribe(url, listener);\n            List<URL> urls = reference.get();\n            if (urls != null && !urls.isEmpty()) {\n                for (URL u : urls) {\n                    if (!Constants.EMPTY_PROTOCOL.equals(u.getProtocol())) {\n                        result.add(u);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public void register(URL url) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"register url == null\");\n        }\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Register: \" + url);\n        }\n        //保存注册url\n        registered.add(url);\n    }\n\n    @Override\n    public void unregister(URL url) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"unregister url == null\");\n        }\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Unregister: \" + url);\n        }\n        //取消注册url\n        registered.remove(url);\n    }\n\n    @Override\n    public void subscribe(URL url, NotifyListener listener) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"subscribe url == null\");\n        }\n        if (listener == null) {\n            throw new IllegalArgumentException(\"subscribe listener == null\");\n        }\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Subscribe: \" + url);\n        }\n        //保存订阅url\n        Set<NotifyListener> listeners = subscribed.get(url);\n        if (listeners == null) {\n            subscribed.putIfAbsent(url, new ConcurrentHashSet<NotifyListener>());\n            listeners = subscribed.get(url);\n        }\n        listeners.add(listener);\n    }\n\n    @Override\n    public void unsubscribe(URL url, NotifyListener listener) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"unsubscribe url == null\");\n        }\n        if (listener == null) {\n            throw new IllegalArgumentException(\"unsubscribe listener == null\");\n        }\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Unsubscribe: \" + url);\n        }\n        //取消订阅url的listener\n        Set<NotifyListener> listeners = subscribed.get(url);\n        if (listeners != null) {\n            listeners.remove(listener);\n        }\n    }\n\n    /**\n     * 恢复注册和订阅\n     * @throws Exception\n     */\n    protected void recover() throws Exception {\n        //获取已注册的地址\n        Set<URL> recoverRegistered = new HashSet<URL>(getRegistered());\n        if (!recoverRegistered.isEmpty()) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Recover register url \" + recoverRegistered);\n            }\n            for (URL url : recoverRegistered) {\n                //重新注册url\n                register(url);\n            }\n        }\n        //获取已订阅的记录\n        Map<URL, Set<NotifyListener>> recoverSubscribed = new HashMap<URL, Set<NotifyListener>>(getSubscribed());\n        if (!recoverSubscribed.isEmpty()) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Recover subscribe url \" + recoverSubscribed.keySet());\n            }\n            for (Map.Entry<URL, Set<NotifyListener>> entry : recoverSubscribed.entrySet()) {\n                URL url = entry.getKey();\n                for (NotifyListener listener : entry.getValue()) {\n                    //重新订阅\n                    subscribe(url, listener);\n                }\n            }\n        }\n    }\n\n    /**\n     * 通知\n     * @param urls 注册中心url\n     */\n    protected void notify(List<URL> urls) {\n        if (urls == null || urls.isEmpty()) {\n            return;\n        }\n        //遍历已订阅的记录（例如服务暴露时那里会订阅事件）\n        for (Map.Entry<URL, Set<NotifyListener>> entry : getSubscribed().entrySet()) {\n            //订阅url\n            URL url = entry.getKey();\n            //检测是否匹配\n            if (!UrlUtils.isMatch(url, urls.get(0))) {\n                continue;\n            }\n            Set<NotifyListener> listeners = entry.getValue();\n            if (listeners != null) {\n                for (NotifyListener listener : listeners) {\n                    try {\n                        //通知注册中心\n                        notify(url, listener, filterEmpty(url, urls));\n                    } catch (Throwable t) {\n                        logger.error(\"Failed to notify registry event, urls: \" + urls + \", cause: \" + t.getMessage(), t);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param url 订阅url\n     * provider://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&category=configurators&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=7444&side=provider&timestamp=1528870218728\n     * @param listener\n     * @param urls 待通知的urls\n     */\n    protected void notify(URL url, NotifyListener listener, List<URL> urls) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"notify url == null\");\n        }\n        if (listener == null) {\n            throw new IllegalArgumentException(\"notify listener == null\");\n        }\n        if ((urls == null || urls.isEmpty()) && !Constants.ANY_VALUE.equals(url.getServiceInterface())) {\n            logger.warn(\"Ignore empty notify urls for subscribe url \" + url);\n            return;\n        }\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Notify urls for subscribe url \" + url + \", urls: \" + urls);\n        }\n        //<category,List<URL>>\n        Map<String, List<URL>> result = new HashMap<String, List<URL>>();\n        //遍历待通知urls，根据url中的category参数进行分组，保存到result中\n        for (URL u : urls) {\n            //url和u是否匹配(url的范围是否比u大)\n            if (UrlUtils.isMatch(url, u)) {\n                //获取待通知url的category，默认值是providers\n                String category = u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);\n                List<URL> categoryList = result.get(category);\n                if (categoryList == null) {\n                    categoryList = new ArrayList<URL>();\n                    result.put(category, categoryList);\n                }\n                categoryList.add(u);\n            }\n        }\n        if (result.size() == 0) {\n            //类别待通知url列表为空，直接返回\n            return;\n        }\n        //下面会将notified中的url及其values.values中的URL保存到缓存文件中\n        Map<String, List<URL>> categoryNotified = notified.get(url);\n        if (categoryNotified == null) {\n            notified.putIfAbsent(url, new ConcurrentHashMap<String, List<URL>>());\n            categoryNotified = notified.get(url);\n        }\n        for (Map.Entry<String, List<URL>> entry : result.entrySet()) {\n            //类别\n            String category = entry.getKey();\n            //类别待通知url列表\n            List<URL> categoryList = entry.getValue();\n            //保存<类别,类别待通知url列表>\n            categoryNotified.put(category, categoryList);\n            //保存注册中心缓存文件(将订阅url、待通知url列表保存到缓存文件)\n            saveProperties(url);\n            //触发通知(类别待通知url列表)\n            listener.notify(categoryList);\n        }\n    }\n\n    /**\n     * 保存注册中心缓存文件\n     * @param url 订阅url\n     */\n    private void saveProperties(URL url) {\n        if (file == null) {\n            return;\n        }\n        try {\n            //保存待通知url\n            StringBuilder buf = new StringBuilder();\n            //根据订阅url获取类别map\n            Map<String, List<URL>> categoryNotified = notified.get(url);\n            if (categoryNotified != null) {\n                //遍历类别待通知url列表\n                for (List<URL> us : categoryNotified.values()) {\n                    for (URL u : us) {\n                        //将待通知url添加到buf中，多个地址使用空格分隔\n                        if (buf.length() > 0) {\n                            buf.append(URL_SEPARATOR);\n                        }\n                        buf.append(u.toFullString());\n                    }\n                }\n            }\n            //保存配置到properties文件<订阅url的服务唯一名称标识,类别待通知url列表>\n            properties.setProperty(url.getServiceKey(), buf.toString());\n            //获取版本号\n            long version = lastCacheChanged.incrementAndGet();\n            if (syncSaveFile) {\n                //同步保存缓存文件\n                doSaveProperties(version);\n            } else {\n                //异步保存缓存文件\n                registryCacheExecutor.execute(new SaveProperties(version));\n            }\n        } catch (Throwable t) {\n            logger.warn(t.getMessage(), t);\n        }\n    }\n\n    @Override\n    public void destroy() {\n        if (logger.isInfoEnabled()) {\n            //销毁注册中心\n            logger.info(\"Destroy registry:\" + getUrl());\n        }\n        Set<URL> destroyRegistered = new HashSet<URL>(getRegistered());\n        if (!destroyRegistered.isEmpty()) {\n            //遍历已注册的url\n            for (URL url : new HashSet<URL>(getRegistered())) {\n                if (url.getParameter(Constants.DYNAMIC_KEY, true)) {\n                    try {\n                        //url的dynamic = true，取消注册url\n                        unregister(url);\n                        if (logger.isInfoEnabled()) {\n                            logger.info(\"Destroy unregister url \" + url);\n                        }\n                    } catch (Throwable t) {\n                        logger.warn(\"Failed to unregister url \" + url + \" to registry \" + getUrl() + \" on destroy, cause: \" + t.getMessage(), t);\n                    }\n                }\n            }\n        }\n        Map<URL, Set<NotifyListener>> destroySubscribed = new HashMap<URL, Set<NotifyListener>>(getSubscribed());\n        if (!destroySubscribed.isEmpty()) {\n            //遍历已订阅的，挨个取消订阅\n            for (Map.Entry<URL, Set<NotifyListener>> entry : destroySubscribed.entrySet()) {\n                //订阅的url\n                URL url = entry.getKey();\n                for (NotifyListener listener : entry.getValue()) {\n                    try {\n                        //取消订阅url\n                        unsubscribe(url, listener);\n                        if (logger.isInfoEnabled()) {\n                            logger.info(\"Destroy unsubscribe url \" + url);\n                        }\n                    } catch (Throwable t) {\n                        logger.warn(\"Failed to unsubscribe url \" + url + \" to registry \" + getUrl() + \" on destroy, cause: \" + t.getMessage(), t);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getUrl().toString();\n    }\n\n    /**\n     * 异步保存缓存文件的线程\n     */\n    private class SaveProperties implements Runnable {\n        private long version;\n        private SaveProperties(long version) {\n            this.version = version;\n        }\n        @Override\n        public void run() {\n            doSaveProperties(version);\n        }\n    }\n}\n```\n\n### FailbackRegistry抽象类\nFailbackRegistry抽象类增加了失败重试功能，MulticastRegistry、ZookeeperRegistry等都继承自它.\n```java\npublic abstract class FailbackRegistry extends AbstractRegistry {\n\n    /**\n     * 注册中心失败重试线程\n     */\n    private final ScheduledExecutorService retryExecutor =\n            Executors.newScheduledThreadPool(1,\n                    new NamedThreadFactory(\"DubboRegistryFailedRetryTimer\", true));\n\n    /**\n     * 用于失败重试的定时器，定期检查是有失败的请求，如果有，则无限重试\n     */\n    private final ScheduledFuture<?> retryFuture;\n\n    /**\n     * 注册失败的URL列表\n     */\n    private final Set<URL> failedRegistered = new ConcurrentHashSet<URL>();\n\n    /**\n     * 取消注册失败的URL列表\n     */\n    private final Set<URL> failedUnregistered = new ConcurrentHashSet<URL>();\n\n    /**\n     * 订阅失败的记录\n     * <订阅url，监听>\n     */\n    private final ConcurrentMap<URL, Set<NotifyListener>> failedSubscribed = new ConcurrentHashMap<URL, Set<NotifyListener>>();\n\n    /**\n     * 取消订阅失败的记录\n     * <订阅url，监听>\n     */\n    private final ConcurrentMap<URL, Set<NotifyListener>> failedUnsubscribed = new ConcurrentHashMap<URL, Set<NotifyListener>>();\n\n    /**\n     * 通知失败的URL\n     */\n    private final ConcurrentMap<URL, Map<NotifyListener, List<URL>>> failedNotified = new ConcurrentHashMap<URL, Map<NotifyListener, List<URL>>>();\n\n    public FailbackRegistry(URL url) {\n        //设置注册中心url\n        super(url);\n        //获取url对应的重试间隔时间，默认值是5秒\n        int retryPeriod = url.getParameter(Constants.REGISTRY_RETRY_PERIOD_KEY, Constants.DEFAULT_REGISTRY_RETRY_PERIOD);\n        this.retryFuture = retryExecutor.scheduleWithFixedDelay(new Runnable() {\n            @Override\n            public void run() {\n                //检测并连接到注册中心\n                try {\n\t\t    //执行重试\n                    retry();\n                } catch (Throwable t) {\n                    logger.error(\"Unexpected error occur at failed retry, cause: \" + t.getMessage(), t);\n                }\n            }\n        }, retryPeriod, retryPeriod, TimeUnit.MILLISECONDS);\n    }\n\n    public Future<?> getRetryFuture() {\n        return retryFuture;\n    }\n\n    public Set<URL> getFailedRegistered() {\n        return failedRegistered;\n    }\n\n    public Set<URL> getFailedUnregistered() {\n        return failedUnregistered;\n    }\n\n    public Map<URL, Set<NotifyListener>> getFailedSubscribed() {\n        return failedSubscribed;\n    }\n\n    public Map<URL, Set<NotifyListener>> getFailedUnsubscribed() {\n        return failedUnsubscribed;\n    }\n\n    public Map<URL, Map<NotifyListener, List<URL>>> getFailedNotified() {\n        return failedNotified;\n    }\n\n    /**\n     * 添加订阅失败的记录\n     * @param url 订阅url\n     * @param listener\n     */\n    private void addFailedSubscribed(URL url, NotifyListener listener) {\n        Set<NotifyListener> listeners = failedSubscribed.get(url);\n        if (listeners == null) {\n            failedSubscribed.putIfAbsent(url, new ConcurrentHashSet<NotifyListener>());\n            listeners = failedSubscribed.get(url);\n        }\n        listeners.add(listener);\n    }\n\n    /**\n     * 移除订阅失败的记录（从三个列表中都移除）\n     * @param url 订阅url\n     * @param listener\n     */\n    private void removeFailedSubscribed(URL url, NotifyListener listener) {\n        //订阅失败的记录\n        Set<NotifyListener> listeners = failedSubscribed.get(url);\n        if (listeners != null) {\n            listeners.remove(listener);\n        }\n        //取消订阅失败的记录\n        listeners = failedUnsubscribed.get(url);\n        if (listeners != null) {\n            listeners.remove(listener);\n        }\n        //通知失败的记录\n        Map<NotifyListener, List<URL>> notified = failedNotified.get(url);\n        if (notified != null) {\n            notified.remove(listener);\n        }\n    }\n\n    @Override\n    public void register(URL url) {\n        //保存url到集合缓存中\n        super.register(url);\n        //从已失败的记录中移除该url\n        failedRegistered.remove(url);\n        failedUnregistered.remove(url);\n        try {\n            //向服务端发送注册请求\n            doRegister(url);\n        } catch (Exception e) {\n            Throwable t = e;\n\n            //注册中心url以及服务提供者url中的check = true且url不是消费端\n            boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)\n                    && url.getParameter(Constants.CHECK_KEY, true)\n                    && !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());\n            //判断是否需要跳过故障恢复(SkipFailbackWrapperException异常只是作为标记)\n            boolean skipFailback = t instanceof SkipFailbackWrapperException;\n            if (check || skipFailback) {\n                //如果启动检测或者跳过故障恢复的话，则直接抛出异常\n                if (skipFailback) {\n                    t = t.getCause();\n                }\n                //注册url到注册中心发生失败\n                throw new IllegalStateException(\"Failed to register \" + url + \" to registry \" + getUrl().getAddress() + \", cause: \" + t.getMessage(), t);\n            } else {\n                logger.error(\"Failed to register \" + url + \", waiting for retry, cause: \" + t.getMessage(), t);\n            }\n            //注册失败的话，将url保存到注册失败列表中，定期重试\n            failedRegistered.add(url);\n        }\n    }\n\n    @Override\n    public void unregister(URL url) {\n        //从缓存集合中移除该url\n        super.unregister(url);\n        //从失败列表中移除该url\n        failedRegistered.remove(url);\n        failedUnregistered.remove(url);\n        try {\n            //向服务端发送取消注册请求\n            doUnregister(url);\n        } catch (Exception e) {\n            Throwable t = e;\n            //判断是否启动检测\n            boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)\n                    && url.getParameter(Constants.CHECK_KEY, true)\n                    //非消费者\n                    && !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());\n            //是否跳过故障恢复\n            boolean skipFailback = t instanceof SkipFailbackWrapperException;\n            if (check || skipFailback) {\n                if (skipFailback) {\n                    t = t.getCause();\n                }\n                //直接抛出异常\n                throw new IllegalStateException(\"Failed to unregister \" + url + \" to registry \" + getUrl().getAddress() + \", cause: \" + t.getMessage(), t);\n            } else {\n                //取消注册url执行失败，等待重试\n                logger.error(\"Failed to unregister \" + url + \", waiting for retry, cause: \" + t.getMessage(), t);\n            }\n            //将失败的url保存到失败列表，等待定期重试\n            failedUnregistered.add(url);\n        }\n    }\n\n    @Override\n    public void subscribe(URL url, NotifyListener listener) {\n        //将订阅保存到集合缓存\n        super.subscribe(url, listener);\n        //从失败列表中移除该订阅记录\n        removeFailedSubscribed(url, listener);\n        try {\n            //向服务端发送订阅请求\n            doSubscribe(url, listener);\n        } catch (Exception e) {\n            Throwable t = e;\n            //订阅失败的话，则从缓存文件中获取该订阅url对应的注册中心url列表(即类别待通知url列表)\n            List<URL> urls = getCacheUrls(url);\n            if (urls != null && !urls.isEmpty()) {\n                //触发通知\n                notify(url, listener, urls);\n                //订阅失败，将使用缓存列表\n                logger.error(\"Failed to subscribe \" + url + \", Using cached list: \" + urls + \" from cache file: \" + getUrl().getParameter(Constants.FILE_KEY, System.getProperty(\"user.home\") + \"/dubbo-registry-\" + url.getHost() + \".cache\") + \", cause: \" + t.getMessage(), t);\n            } else {\n                //是否启动检测\n                boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)\n                        && url.getParameter(Constants.CHECK_KEY, true);\n                //是否跳过故障恢复\n                boolean skipFailback = t instanceof SkipFailbackWrapperException;\n                if (check || skipFailback) {\n                    if (skipFailback) {\n                        t = t.getCause();\n                    }\n                    throw new IllegalStateException(\"Failed to subscribe \" + url + \", cause: \" + t.getMessage(), t);\n                } else {\n                    //订阅失败，等待重试\n                    logger.error(\"Failed to subscribe \" + url + \", waiting for retry, cause: \" + t.getMessage(), t);\n                }\n            }\n            //添加到订阅失败列表，请求重试\n            addFailedSubscribed(url, listener);\n        }\n    }\n\n    @Override\n    public void unsubscribe(URL url, NotifyListener listener) {\n        //将订阅从集合缓存中移除\n        super.unsubscribe(url, listener);\n        //从失败列表中移除订阅\n        removeFailedSubscribed(url, listener);\n        try {\n            //向服务端发送取消订阅请求\n            doUnsubscribe(url, listener);\n        } catch (Exception e) {\n            Throwable t = e;\n            //是否启动检测\n            boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)\n                    && url.getParameter(Constants.CHECK_KEY, true);\n            //是否跳过故障恢复\n            boolean skipFailback = t instanceof SkipFailbackWrapperException;\n            if (check || skipFailback) {\n                if (skipFailback) {\n                    t = t.getCause();\n                }\n                throw new IllegalStateException(\"Failed to unsubscribe \" + url + \" to registry \" + getUrl().getAddress() + \", cause: \" + t.getMessage(), t);\n            } else {\n                //取消订阅失败，等待重试\n                logger.error(\"Failed to unsubscribe \" + url + \", waiting for retry, cause: \" + t.getMessage(), t);\n            }\n            //添加到失败列表中，定期重试\n            Set<NotifyListener> listeners = failedUnsubscribed.get(url);\n            if (listeners == null) {\n                failedUnsubscribed.putIfAbsent(url, new ConcurrentHashSet<NotifyListener>());\n                listeners = failedUnsubscribed.get(url);\n            }\n            listeners.add(listener);\n        }\n    }\n\n    @Override\n    protected void notify(URL url, NotifyListener listener, List<URL> urls) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"notify url == null\");\n        }\n        if (listener == null) {\n            throw new IllegalArgumentException(\"notify listener == null\");\n        }\n        try {\n            //执行通知(调用父类中的notify方法)\n            doNotify(url, listener, urls);\n        } catch (Exception t) {\n            //通知失败，添加到失败列表，定期重试\n            Map<NotifyListener, List<URL>> listeners = failedNotified.get(url);\n            if (listeners == null) {\n                failedNotified.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, List<URL>>());\n                listeners = failedNotified.get(url);\n            }\n            listeners.put(listener, urls);\n            logger.error(\"Failed to notify for subscribe \" + url + \", waiting for retry, cause: \" + t.getMessage(), t);\n        }\n    }\n\n    protected void doNotify(URL url, NotifyListener listener, List<URL> urls) {\n        super.notify(url, listener, urls);\n    }\n\n    @Override\n    protected void recover() throws Exception {\n        //获取已注册列表\n        Set<URL> recoverRegistered = new HashSet<URL>(getRegistered());\n        if (!recoverRegistered.isEmpty()) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Recover register url \" + recoverRegistered);\n            }\n            //将已注册的添加到失败列表中，等待恢复\n            for (URL url : recoverRegistered) {\n                failedRegistered.add(url);\n            }\n        }\n        //获取已订阅的列表\n        Map<URL, Set<NotifyListener>> recoverSubscribed = new HashMap<URL, Set<NotifyListener>>(getSubscribed());\n        if (!recoverSubscribed.isEmpty()) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Recover subscribe url \" + recoverSubscribed.keySet());\n            }\n            for (Map.Entry<URL, Set<NotifyListener>> entry : recoverSubscribed.entrySet()) {\n                URL url = entry.getKey();\n                for (NotifyListener listener : entry.getValue()) {\n                    //将已订阅的添加到失败列表中，等待恢复\n                    addFailedSubscribed(url, listener);\n                }\n            }\n        }\n    }\n\n    /**\n     * 重试 之前操作失败的 记录\n     */\n    protected void retry() {\n        if (!failedRegistered.isEmpty()) {\n            //处理注册失败的数据(重新注册)\n            Set<URL> failed = new HashSet<URL>(failedRegistered);\n            if (failed.size() > 0) {\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"Retry register \" + failed);\n                }\n                try {\n                    for (URL url : failed) {\n                        try {\n                            //重试注册\n                            doRegister(url);\n                            //重新注册成功，则将其从失败列表中移除\n                            failedRegistered.remove(url);\n                        } catch (Throwable t) {\n                            // Ignore all the exceptions and wait for the next retry\n                            //忽略所有的异常，等待下次重试\n                            logger.warn(\"Failed to retry register \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                        }\n                    }\n                } catch (Throwable t) {\n                    logger.warn(\"Failed to retry register \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n        if (!failedUnregistered.isEmpty()) {\n            //处理取消注册失败的数据(重新执行取消注册)\n            Set<URL> failed = new HashSet<URL>(failedUnregistered);\n            if (!failed.isEmpty()) {\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"Retry unregister \" + failed);\n                }\n                try {\n                    for (URL url : failed) {\n                        try {\n                            //重试取消注册\n                            doUnregister(url);\n                            //重试成功，则从失败列表中移除出去\n                            failedUnregistered.remove(url);\n                        } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\n                            logger.warn(\"Failed to retry unregister  \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                        }\n                    }\n                } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\n                    logger.warn(\"Failed to retry unregister  \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n        if (!failedSubscribed.isEmpty()) {\n            //处理订阅失败的数据\n            Map<URL, Set<NotifyListener>> failed = new HashMap<URL, Set<NotifyListener>>(failedSubscribed);\n            for (Map.Entry<URL, Set<NotifyListener>> entry : new HashMap<URL, Set<NotifyListener>>(failed).entrySet()) {\n                if (entry.getValue() == null || entry.getValue().size() == 0) {\n                    //将待通知url列表为空的数据移除出去\n                    failed.remove(entry.getKey());\n                }\n            }\n            if (failed.size() > 0) {\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"Retry subscribe \" + failed);\n                }\n                try {\n                    for (Map.Entry<URL, Set<NotifyListener>> entry : failed.entrySet()) {\n                        URL url = entry.getKey();\n                        Set<NotifyListener> listeners = entry.getValue();\n                        for (NotifyListener listener : listeners) {\n                            try {\n                                //重试订阅\n                                doSubscribe(url, listener);\n                                //订阅成功，从失败列表中移除出去\n                                listeners.remove(listener);\n                            } catch (Throwable t) {\n                                logger.warn(\"Failed to retry subscribe \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                            }\n                        }\n                    }\n                } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\n                    logger.warn(\"Failed to retry subscribe \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n        if (!failedUnsubscribed.isEmpty()) {\n            //处理取消订阅失败的数据\n            Map<URL, Set<NotifyListener>> failed = new HashMap<URL, Set<NotifyListener>>(failedUnsubscribed);\n            for (Map.Entry<URL, Set<NotifyListener>> entry : new HashMap<URL, Set<NotifyListener>>(failed).entrySet()) {\n                if (entry.getValue() == null || entry.getValue().isEmpty()) {\n                    //将待通知url列表为空的数据移除出去\n                    failed.remove(entry.getKey());\n                }\n            }\n            if (failed.size() > 0) {\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"Retry unsubscribe \" + failed);\n                }\n                try {\n                    for (Map.Entry<URL, Set<NotifyListener>> entry : failed.entrySet()) {\n                        URL url = entry.getKey();\n                        Set<NotifyListener> listeners = entry.getValue();\n                        for (NotifyListener listener : listeners) {\n                            try {\n                                //重试取消订阅\n                                doUnsubscribe(url, listener);\n                                //重试成功，从失败列表中移除\n                                listeners.remove(listener);\n                            } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\n                                logger.warn(\"Failed to retry unsubscribe \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                            }\n                        }\n                    }\n                } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\n                    logger.warn(\"Failed to retry unsubscribe \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n        if (!failedNotified.isEmpty()) {\n            //处理通知失败的数据\n            Map<URL, Map<NotifyListener, List<URL>>> failed = new HashMap<URL, Map<NotifyListener, List<URL>>>(failedNotified);\n            for (Map.Entry<URL, Map<NotifyListener, List<URL>>> entry : new HashMap<URL, Map<NotifyListener, List<URL>>>(failed).entrySet()) {\n                if (entry.getValue() == null || entry.getValue().size() == 0) {\n                    failed.remove(entry.getKey());\n                }\n            }\n            if (failed.size() > 0) {\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"Retry notify \" + failed);\n                }\n                try {\n                    for (Map<NotifyListener, List<URL>> values : failed.values()) {\n                        for (Map.Entry<NotifyListener, List<URL>> entry : values.entrySet()) {\n                            try {\n                                NotifyListener listener = entry.getKey();\n                                List<URL> urls = entry.getValue();\n                                //重试通知\n                                listener.notify(urls);\n                                //重试成功，从失败列表中移除\n                                values.remove(listener);\n                            } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\n                                logger.warn(\"Failed to retry notify \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                            }\n                        }\n                    }\n                } catch (Throwable t) { // Ignore all the exceptions and wait for the next retry\n                    logger.warn(\"Failed to retry notify \" + failed + \", waiting for again, cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void destroy() {\n        //调用父类的销毁逻辑,取消注册等\n        super.destroy();\n        try {\n            //停止定时重试线程\n            retryFuture.cancel(true);\n        } catch (Throwable t) {\n            logger.warn(t.getMessage(), t);\n        }\n    }\n\n    // ==== Template method ====\n\n    /**\n     * 注册\n     * @param url\n     */\n    protected abstract void doRegister(URL url);\n\n    /**\n     * 取消注册\n     * @param url\n     */\n    protected abstract void doUnregister(URL url);\n\n    /**\n     * 订阅\n     * @param url\n     * @param listener\n     */\n    protected abstract void doSubscribe(URL url, NotifyListener listener);\n\n    /**\n     * 取消订阅\n     * @param url\n     * @param listener\n     */\n    protected abstract void doUnsubscribe(URL url, NotifyListener listener);\n}\n```\n\n#### DubboRegistry类\n```java\npublic class DubboRegistry extends FailbackRegistry {\n\n    private final static Logger logger = LoggerFactory.getLogger(DubboRegistry.class);\n\n    /**\n     * 重新连接检测周期：3秒\n     */\n    private static final int RECONNECT_PERIOD_DEFAULT = 3 * 1000;\n\n    /**\n     * 重新连接定时线程\n     */\n    private final ScheduledExecutorService scheduledExecutorService =\n            Executors.newScheduledThreadPool(1, new NamedThreadFactory(\"DubboRegistryReconnectTimer\", true));\n\n    /**\n     * 重新连接定时器，定期检查连接是否可用，如果不可用，无限重连\n     */\n    private final ScheduledFuture<?> reconnectFuture;\n\n    /**\n     * 客户端获取处理的锁\n     * 锁定客户端实例的创建过程，防止重复客户端\n     */\n    private final ReentrantLock clientLock = new ReentrantLock();\n\n    private final Invoker<RegistryService> registryInvoker;\n    \n    /**\n     * 注册中心\n     */\n    private final RegistryService registryService;\n\n    public DubboRegistry(Invoker<RegistryService> registryInvoker, RegistryService registryService) {\n        //设置注册中心url（registryInvoker.getUrl()）\n        super(registryInvoker.getUrl());\n        this.registryInvoker = registryInvoker;\n        this.registryService = registryService;\n        // 启动重连线程\n        int reconnectPeriod = registryInvoker.getUrl()\n                .getParameter(Constants.REGISTRY_RECONNECT_PERIOD_KEY, RECONNECT_PERIOD_DEFAULT);\n        reconnectFuture = scheduledExecutorService.scheduleWithFixedDelay(new Runnable() {\n            @Override\n            public void run() {\n                //检测并连接到注册中心\n                try {\n                    connect();\n                } catch (Throwable t) { \n                    logger.error(\"Unexpected error occur at reconnect, cause: \" + t.getMessage(), t);\n                }\n            }\n        }, reconnectPeriod, reconnectPeriod, TimeUnit.MILLISECONDS);\n    }\n    \n    /**\n     * 连接到注册中心\n     */\n    protected final void connect() {\n        try {\n            //检测是否是已连接的\n            if (isAvailable()) {\n                return;\n            }\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Reconnect to registry \" + getUrl());\n            }\n            //连接前先上锁\n            clientLock.lock();\n            try {\n                // Double check whether or not it is connected\n                //再次检测是否已连接\n                if (isAvailable()) {\n                    return;\n                }\n                //执行恢复\n                recover();\n            } finally {\n                //释放锁\n                clientLock.unlock();\n            }\n        } catch (Throwable t) {\n            // 如果设置了check = true，则直接抛异常，否则忽略异常，等待下次重试\n            if (getUrl().getParameter(Constants.CHECK_KEY, true)) {\n                if (t instanceof RuntimeException) {\n                    throw (RuntimeException) t;\n                }\n                throw new RuntimeException(t.getMessage(), t);\n            }\n            logger.error(\"Failed to connect to registry \" + getUrl().getAddress() + \" from provider/consumer \" + NetUtils.getLocalHost() + \" use dubbo \" + Version.getVersion() + \", cause: \" + t.getMessage(), t);\n        }\n    }\n\n    @Override\n    public boolean isAvailable() {\n        //registryInvoker为空的话说明不可用，直接返回\n        if (registryInvoker == null) {\n            return false;\n        }\n        return registryInvoker.isAvailable();\n    }\n\n    @Override\n    public void destroy() {\n        super.destroy();\n        try {\n            if (!reconnectFuture.isCancelled()) {\n                //取消重连定时器\n                reconnectFuture.cancel(true);\n            }\n        } catch (Throwable t) {\n            logger.warn(\"Failed to cancel reconnect timer\", t);\n        }\n        //销毁registryInvoker\n        registryInvoker.destroy();\n    }\n\n    @Override\n    protected void doRegister(URL url) {\n        //交由registryService来完成\n        registryService.register(url);\n    }\n\n    @Override\n    protected void doUnregister(URL url) {\n        registryService.unregister(url);\n    }\n\n    @Override\n    protected void doSubscribe(URL url, NotifyListener listener) {\n        registryService.subscribe(url, listener);\n    }\n\n    @Override\n    protected void doUnsubscribe(URL url, NotifyListener listener) {\n        registryService.unsubscribe(url, listener);\n    }\n\n    @Override\n    public List<URL> lookup(URL url) {\n        return registryService.lookup(url);\n    }\n}\n```\nFailbackRegistry的注册中心实现类，如ZookeeperRegistry类等，将会在单独的小节进行详细讲解，这里就先不介绍了。\n\n### RegistryFactory接口\n```java\n@SPI(\"dubbo\")\npublic interface RegistryFactory {\n    /**\n     * 根据url获取注册中心实例\n     *\n     * 1、当设置check=false时，链接不会检测，除此之外当断开连接时将会抛异常\n     * 2、支持URL上的username:password授权认证\n     * 3、支持backup=10.20.153.10配置候选注册中心集群地址\n     * 4、支持file=registry.cache本地磁盘文件缓存\n     * 5、支持timeout=1000请求超时配置\n     * 6、支持session=60000配置session超时或者到期设置\n     * @param url 注册中心地址，不允许为空\n     * @return 注册中心引用，永不返回空值\n     */\n    @Adaptive({\"protocol\"})\n    Registry getRegistry(URL url);\n}\n```\n#### AbstractRegistryFactory抽象类\n```java\npublic abstract class AbstractRegistryFactory implements RegistryFactory {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractRegistryFactory.class);\n\n    /**\n     * 用来锁定获取注册中心实例时的过程\n     */\n    private static final ReentrantLock LOCK = new ReentrantLock();\n\n    /**\n     * 注册中心集合\n     * Map<RegistryAddress, Registry>\n     * key = multicast://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService\n     */\n    private static final Map<String, Registry> REGISTRIES = new ConcurrentHashMap<String, Registry>();\n\n    /**\n     * 获取所有注册中心\n     * @return all registries\n     */\n    public static Collection<Registry> getRegistries() {\n        return Collections.unmodifiableCollection(REGISTRIES.values());\n    }\n\n    /**\n     * 关闭所有创建的注册中心\n     */\n    public static void destroyAll() {\n        //锁定注册中心关闭过程\n        LOCK.lock();\n        try {\n            for (Registry registry : getRegistries()) {\n                try {\n                    //调用destroy()方法进行销毁\n                    registry.destroy();\n                } catch (Throwable e) {\n                    LOGGER.error(e.getMessage(), e);\n                }\n            }\n            //清理缓存\n            REGISTRIES.clear();\n        } finally {\n            //释放锁\n            LOCK.unlock();\n        }\n    }\n\n    @Override\n    public Registry getRegistry(URL url) {\n        //设置path属性\n        url = url.setPath(RegistryService.class.getName())\n                //添加interface = com.alibaba.dubbo.registry.RegistryService\n                .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName())\n                //移除export、refer参数\n                .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY);\n        //key = multicast://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService\n        String key = url.toServiceString();\n        // Lock the registry access process to ensure a single instance of the registry\n        //加锁,确保该key对应的注册中心为单例\n        LOCK.lock();\n        try {\n            Registry registry = REGISTRIES.get(key);\n            if (registry != null) {\n                //缓存中存在，直接返回\n                return registry;\n            }\n            //根据url创建注册中心实例，这里由子类来实现\n            registry = createRegistry(url);\n            if (registry == null) {\n\t        //创建失败\n                throw new IllegalStateException(\"Can not create registry \" + url);\n            }\n            //放入缓存，并返回\n            REGISTRIES.put(key, registry);\n            return registry;\n        } finally {\n            // 释放锁\n            LOCK.unlock();\n        }\n    }\n\n    /**\n     * 创建注册中心实例\n     * @param url 注册中心url\n     * @return\n     */\n    protected abstract Registry createRegistry(URL url);\n}\n```\nAbstractRegistryFactory的实现类，如ZookeeperRegistryFactory等类，将在相关的小节单独介绍，这里就不多介绍了。\n\n### Directory接口\n接下来我们看看那Directory接口相关的内容\n```java\npublic interface Directory<T> extends Node {\n\n    /**\n     * 获取服务类型\n     */\n    Class<T> getInterface();\n\n    /**\n     * 获取invokers列表\n     */\n    List<Invoker<T>> list(Invocation invocation) throws RpcException;\n}\n```\n\n#### AbstractDirectory抽象类\n```java\npublic abstract class AbstractDirectory<T> implements Directory<T> {\n    \n    /**\n     * 注册中心url\n     */\n    private final URL url;\n\n    /**\n     * Directory是否已销毁\n     */\n    private volatile boolean destroyed = false;\n\n    /**\n     * 消费者url\n     */\n    private volatile URL consumerUrl;\n\n    /**\n     * 路由列表\n     */\n    private volatile List<Router> routers;\n\n    public AbstractDirectory(URL url, URL consumerUrl, List<Router> routers) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"url == null\");\n        }\n        this.url = url;\n        this.consumerUrl = consumerUrl;\n        //设置路由\n        setRouters(routers);\n    }\n\t\n    /**\n     * 从此list方法返回的InvokerList，已经被Routers过滤\n     */\n    @Override\n    public List<Invoker<T>> list(Invocation invocation) throws RpcException {\n        if (destroyed) {\n            throw new RpcException(\"Directory already destroyed .url: \" + getUrl());\n        }\n        //根据invocation获取invokers列表(根据方法名查询缓存methodInvokerMap)\n        List<Invoker<T>> invokers = doList(invocation);\n        List<Router> localRouters = this.routers;\n        if (localRouters != null && !localRouters.isEmpty()) {\n\t    //遍历路由\n            for (Router router : localRouters) {\n                try {\n                    if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) {\n\t\t\t//如果url的runtime配置为true,则每次都会进行route\n\t\t\t//执行路由，进行过滤\n                        invokers = router.route(invokers, getConsumerUrl(), invocation);\n                    }\n                } catch (Throwable t) {\n                    logger.error(\"Failed to execute router: \" + getUrl() + \", cause: \" + t.getMessage(), t);\n                }\n            }\n        }\n        return invokers;\n    }\n\n    /**\n     * 设置路由\n     * 1、添加：收到notify通知的routers、当前url的router参数、new MockInvokersSelector()\n     * 2、将routers排序\n     * 3、缓存routers\n     * @param routers 收到notify通知的routers\n     */\n    protected void setRouters(List<Router> routers) {\n        routers = routers == null ? new ArrayList<Router>() : new ArrayList<Router>(routers);\n        //获取路由工厂扩展名称\n        String routerkey = url.getParameter(Constants.ROUTER_KEY);\n        if (routerkey != null && routerkey.length() > 0) {\n            //根据路由工厂扩展名获取扩展实例\n            RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getExtension(routerkey);\n            //根据url获取路由实例，并放入routers\n            routers.add(routerFactory.getRouter(url));\n        }\n        //添加支持mock协议的invoker选择器\n        routers.add(new MockInvokersSelector());\n        //排序\n        Collections.sort(routers);\n        this.routers = routers;\n    }\n    /**\n     * 根据invocation获取invokers列表\n     * @param invocation\n     * @return\n     * @throws RpcException\n     */\n    protected abstract List<Invoker<T>> doList(Invocation invocation) throws RpcException;\n}\n```\n#### RegistryDirectory实现类\n该实现类，我们在上一小节《Dubbo源码阅读之服务引用》中已经详细介绍过，这里只简单看下剩余的方法\n```java\npublic class RegistryDirectory<T> extends AbstractDirectory<T> implements NotifyListener {\n\n    //缓存 <服务url, Invoker>\n    private volatile Map<String, Invoker<T>> urlInvokerMap;\n\n    //缓存 <服务方法名称,List<Invoker>>\n    private volatile Map<String, List<Invoker<T>>> methodInvokerMap;\n\n    /**\n     * 通过调用方法名从本地缓存中找到invokers\n     * @param invocation\n     * @return\n     */\n    @Override\n    public List<Invoker<T>> doList(Invocation invocation) {\n        if (forbidden) {\n            //1、没有服务提供者。 2、服务提供者被禁用\n            throw new RpcException(RpcException.FORBIDDEN_EXCEPTION,\n                \"No provider available from registry \" + getUrl().getAddress() + \" for service \" + getConsumerUrl().getServiceKey() + \" on consumer \" +  NetUtils.getLocalHost()\n                        + \" use dubbo version \" + Version.getVersion() + \", please check status of providers(disabled, not registered or in blacklist).\");\n        }\n        List<Invoker<T>> invokers = null;\n        Map<String, List<Invoker<T>>> localMethodInvokerMap = this.methodInvokerMap;\n        if (localMethodInvokerMap != null && localMethodInvokerMap.size() > 0) {\n            //获取调用的方法名称\n            String methodName = RpcUtils.getMethodName(invocation);\n            //获取调用的方法参数\n            Object[] args = RpcUtils.getArguments(invocation);\n            if (args != null && args.length > 0 && args[0] != null \n\t\t\t&& (args[0] instanceof String || args[0].getClass().isEnum())) {\n                //第一个参数是字符串类型或者枚举类型\n                //可以根据第一个参数枚举路由\n                invokers = localMethodInvokerMap.get(methodName + \".\" + args[0]);\n            }\n            if (invokers == null) {\n                //通过方法名称查询\n                invokers = localMethodInvokerMap.get(methodName);\n            }\n            if (invokers == null) {\n                //通过*查询\n                invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);\n            }\n            if (invokers == null) {\n                //遍历本地缓存，找到最后一个invokers\n                Iterator<List<Invoker<T>>> iterator = localMethodInvokerMap.values().iterator();\n                if (iterator.hasNext()) {\n                    invokers = iterator.next();\n                }\n            }\n        }\n        return invokers == null ? new ArrayList<Invoker<T>>(0) : invokers;\n    }\n\n    @Override\n    public boolean isAvailable() {\n        if (isDestroyed()) {\n            return false;\n        }\n        Map<String, Invoker<T>> localUrlInvokerMap = urlInvokerMap;\n        if (localUrlInvokerMap != null && localUrlInvokerMap.size() > 0) {\n            for (Invoker<T> invoker : new ArrayList<Invoker<T>>(localUrlInvokerMap.values())) {\n                if (invoker.isAvailable()) {\n                    //本地缓存中的invoker，如果有一个可用，就返回可用\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * 关闭所有的invokers\n     */\n    private void destroyAllInvokers() {\n        Map<String, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap;\n        if (localUrlInvokerMap != null) {\n            for (Invoker<T> invoker : new ArrayList<Invoker<T>>(localUrlInvokerMap.values())) {\n                try {\n\t\t    //销毁invoker\n                    invoker.destroy();\n                } catch (Throwable t) {\n                    logger.warn(\"Failed to destroy service \" + serviceKey + \" to provider \" + invoker.getUrl(), t);\n                }\n            }\n            //清空缓存\n            localUrlInvokerMap.clear();\n        }\n        methodInvokerMap = null;\n    }\n}\n\n````\n#### StaticDirectory实现类\n静态目录服务,它的所有Invoker通过构造函数传入,在服务消费方引用服务的时候,服务对多注册中心进行引用时,将Invokers集合直接传入StaticDirectory构造器,再由Cluster伪装成一个Invoker\n```java\npublic class ReferenceConfig<T> extends AbstractReferenceConfig {\n\n\tprivate T createProxy(Map<String, String> map) {\n\t\t// 省略其他代码.....\n\t\tfor (URL url : urls) {\n\t\t    //记录\"远程引用\"\n\t\t    invokers.add(refprotocol.refer(interfaceClass, url));\n\t\t    if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n\t\t\t// use last registry url\n\t\t\t//使用最后注册的url\n\t\t\tregistryURL = url;\n\t\t    }\n\t\t}\n\t\tif (registryURL != null) {\n\t\t    //有注册中心协议的URL\n\t\t    //使用AvailableCluster\n\t\t    URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);\n\t\t    invoker = cluster.join(new StaticDirectory(u, invokers));\n\t\t} else { \n\t\t    //不是注册中心的url\n\t\t    invoker = cluster.join(new StaticDirectory(invokers));\n\t\t}\n\t}\n}\n```\n来看看实现\n```java\npublic class StaticDirectory<T> extends AbstractDirectory<T> {\n\n    private final List<Invoker<T>> invokers;\n\n    public StaticDirectory(URL url, List<Invoker<T>> invokers, List<Router> routers) {\n        \n\tsuper(url == null && invokers != null && !invokers.isEmpty() ? invokers.get(0).getUrl() : url, routers);\n        \n\tif (invokers == null || invokers.isEmpty()) {\n            throw new IllegalArgumentException(\"invokers == null\");\n        }\n        \n\tthis.invokers = invokers;\n    }\n\n    @Override\n    public Class<T> getInterface() {\n        return invokers.get(0).getInterface();\n    }\n\n    @Override\n    public boolean isAvailable() {\n        if (isDestroyed()) {\n            return false;\n        }\n        for (Invoker<T> invoker : invokers) {\n            //是否可用\n            if (invoker.isAvailable()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public void destroy() {\n        if (isDestroyed()) {\n\t    //已经销毁，直接返回\n            return;\n        }\n        super.destroy();\n        for (Invoker<T> invoker : invokers) {\n            //销毁\n            invoker.destroy();\n        }\n        invokers.clear();\n    }\n\n    @Override\n    protected List<Invoker<T>> doList(Invocation invocation) throws RpcException {\n        //返回构造方法传入的invokers集合\n        return invokers;\n    }\n\n}\n```\n这一小节就先介绍到这里，后面我们详细介绍各个注册中心实现。\n\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之服务暴露","url":"/blog/2018/08/16/Dubbo源码阅读之服务暴露/","content":">本小节详细介绍dubbo服务的暴露，可以先看下之前的文章《Dubbo源码阅读之集成Spring(0201)》\n\n### ServiceConfig类变量\n在ServiceConfig类中定义了如下变量，下文中会用到，我们先简单看下：\n```java\n//代理工厂\nprivate static final ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();\n\n//Protocol实例\nprivate static final Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();\n\n/**\n * dubbo协议服务URL\n * 记录暴露的服务URL\n * dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=192.168.99.60&bind.port=20880&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=4328&qos.port=22222&side=provider&timestamp=1528278313225\n */\nprivate final List<URL> urls = new ArrayList<URL>();\n\n/**\n * 记录暴露的服务端点\n * subscribeUrl = provider://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&category=configurators&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=4328&side=provider&timestamp=1528278313225\n * registerUrl = dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=192.168.99.60&bind.port=20880&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=4328&qos.port=22222&side=provider&timestamp=1528278313225\n */\nprivate final List<Exporter<?>> exporters = new ArrayList<Exporter<?>>();\n```\n\n\n首先我们先来了解下ProxyFactory接口\n\n### ProxyFactory接口\n\n#### getInvoker方法\n\ngetInvoker方法是在ProxyFactory接口中定义的。ProxyFactory接口相关类图如下：\n![](img/ProxyFactory.png)\n\n```java\n/**\n * 代理工厂\n */\n@SPI(\"javassist\")\npublic interface ProxyFactory {\n    /**\n     * 创建代理\n     * @param invoker\n     * @return proxy\n     */\n    @Adaptive({Constants.PROXY_KEY})\n    <T> T getProxy(Invoker<T> invoker) throws RpcException;\n\n    /**\n     * 创建invoker\n     * @param <T>\n     * @param proxy 接口实现类或者代理类\n     * @param type 接口类型\n     * @param url 注册中心url，本地为injvm\n     * @return invoker\n     */\n    @Adaptive({Constants.PROXY_KEY})\n    <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException;\n}\n\n/**\n * 抽象ProxyFactory\n */\npublic abstract class AbstractProxyFactory implements ProxyFactory {\n    @Override\n    public <T> T getProxy(Invoker<T> invoker) throws RpcException {\n        //接口数组\n        Class<?>[] interfaces = null;\n        //获取url的interfaces参数的值\n        String config = invoker.getUrl().getParameter(\"interfaces\");\n        if (config != null && config.length() > 0) {\n            //使用逗号\",\"分隔interfaces参数值\n            String[] types = Constants.COMMA_SPLIT_PATTERN.split(config);\n            if (types != null && types.length > 0) {\n                //这里会将\"远程服务接口类、EchoService类\"放入到接口数组中\n                interfaces = new Class<?>[types.length + 2];\n                interfaces[0] = invoker.getInterface();\n                interfaces[1] = EchoService.class;\n                //然后将\"interfaces参数的值\"放入到接口数组\n                for (int i = 0; i < types.length; i++) {\n                    interfaces[i + 1] = ReflectUtils.forName(types[i]);\n                }\n            }\n        }\n        if (interfaces == null) {\n            //interfaces数组为空的话，则将远程服务接口类、EchoService类放入到接口数组中\n            interfaces = new Class<?>[]{invoker.getInterface(), EchoService.class};\n        }\n        //然后调用子类体实现来获取代理类\n        return getProxy(invoker, interfaces);\n    }\n\n    /**\n     * 获取代理类\n     * @param invoker\n     * @param types  远程服务接口类数组：\n     *               invoker.getInterface()、\n     *               EchoService.class、\n     *               invoker.getUrl().getParameter(\"interfaces\")\n     * @param <T>\n     * @return\n     */\n    public abstract <T> T getProxy(Invoker<T> invoker, Class<?>[] types);\n}\n\n/**\n * jdk动态代理\n */\npublic class JdkProxyFactory extends AbstractProxyFactory {\n\n    @Override\n    public <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {\n        //为interfaces这些接口生成代理类\n        return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),\n                interfaces, new InvokerInvocationHandler(invoker));\n    }\n\n    @Override\n    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {\n\t//返回AbstractProxyInvoker抽象类（该类后面的小节会详细介绍）\n        return new AbstractProxyInvoker<T>(proxy, type, url) {\n\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class<?>[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n\n                //根据方法名称methodName和参数类型parameterTypes获取到指定方法\n                Method method = proxy.getClass().getMethod(methodName, parameterTypes);\n\n                //使用参数arguments调用该代理类的method方法\n                return method.invoke(proxy, arguments);\n            }\n        };\n    }\n}\n\n/**\n * 使用Javassist\n */\npublic class JavassistProxyFactory extends AbstractProxyFactory {\n\n    @Override\n    public <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {\n        //为interfaces这些接口生成代理类(后面会分析Proxy类，这是dubbo自己定义的类)\n        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));\n    }\n\n    @Override\n    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {\n        \n\t// TODO Wrapper类不能正确处理带$的类名\n        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);\n        \n\t//返回AbstractProxyInvoker抽象类（该类后面的小节会详细介绍）\n        return new AbstractProxyInvoker<T>(proxy, type, url) {\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class<?>[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n\n                //使用Wrapper包装类类调用远程服务方法\n                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);\n            }\n        };\n    }\n}\n```\n在JavassistProxyFactory类的getInvoker方法实现中，会为相应的接口类(例如：com.alibaba.dubbo.demo.DemoService)生成包装类，生成的逻辑会在单独的小节介绍，这里只简单看下大概生成的类。\n#### Wrapper包装类\n```java\npublic class com.alibaba.dubbo.common.bytecode.Wrapper0 extends Wrapper{\n\tpublic Wrapper0(){}\n\t//属性名称数组\n\tpublic static String[] pns;\n\n\t//<属性名称，属性类型>\n\tpublic static java.util.Map pts;\n\t\n\t//所有方法名称数组\n\tpublic static String[] mns;\n\t\n\t//已声明的方法名称数组\n\tpublic static String[] dmns;\n\t\n\t//针对每个方法都会定义一个mts数组变量\n\tpublic static Class[] mts0;\n\n\tpublic String[] getPropertyNames(){ \n\t\treturn pns; \n\t}\n\tpublic boolean hasProperty(String n){\n\t\treturn pts.containsKey($1); \n\t}\n\tpublic Class getPropertyType(String n){ \n\t\treturn (Class)pts.get($1); \n\t}\n\tpublic String[] getMethodNames(){ \n\t\treturn mns; \n\t}\n\tpublic String[] getDeclaredMethodNames(){ \n\t\treturn dmns; \n\t}\n\tpublic void setPropertyValue(Object o, String n, Object v){ \n\t\tcom.alibaba.dubbo.demo.DemoService w; \n\t\ttry{ \n\t\t\tw = ((com.alibaba.dubbo.demo.DemoService)$1); \n\t\t}catch(Throwable e){ \n\t\t\tthrow new IllegalArgumentException(e); \n\t\t} \n\t\tthrow new com.alibaba.dubbo.common.bytecode.NoSuchPropertyException(\"Not found property \\\"\"+$2+\"\\\" filed or setter method in class com.alibaba.dubbo.demo.DemoService.\"); \n\t}\n\tpublic Object getPropertyValue(Object o, String n){ \n\t\tcom.alibaba.dubbo.demo.DemoService w; \n\t\ttry{ \n\t\t\tw = ((com.alibaba.dubbo.demo.DemoService)$1); \n\t\t}catch(Throwable e){ \n\t\t\tthrow new IllegalArgumentException(e); \n\t\t} \n\t\tthrow new com.alibaba.dubbo.common.bytecode.NoSuchPropertyException(\"Not found property \\\"\"+$2+\"\\\" filed or setter method in class com.alibaba.dubbo.demo.DemoService.\"); \n\t}\n\t/**\n\t * 执行服务接口的方法\n\t * $1/$2/$3/$4分别对应相应下标的参数\n\t * @param o 服务接口实例\n\t * @param n 服务接口方法名\n\t * @param p 服务接口方法参数\n\t * @param v 服务接口方法参数值\n\t * @return 服务接口调用返回值\n\t */\n\tpublic Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws java.lang.reflect.InvocationTargetException{\n\t\tcom.alibaba.dubbo.demo.DemoService w; \n\t\ttry{ \n\t\t\tw = ((com.alibaba.dubbo.demo.DemoService)$1); \n\t\t}catch(Throwable e){ \n\t\t\tthrow new IllegalArgumentException(e); \n\t\t} \n\t\ttry{ \n\t\t\t//方法名称为sayHello 并且 只有一个参数\n\t\t\tif(\"sayHello\".equals($2) && $3.length == 1){  \n\t\t\t\t//调用接口方法sayHello\n\t\t\t\treturn ($w)w.sayHello((java.lang.String)$4[0]);\n\t\t\t} \n\t\t} catch(Throwable e) {      \n\t\t\tthrow new java.lang.reflect.InvocationTargetException(e);  \n\t\t} \n\t\tthrow new com.alibaba.dubbo.common.bytecode.NoSuchMethodException(\"Not found method \\\"\"+$2+\"\\\" in class com.alibaba.dubbo.demo.DemoService.\"); \n\t}\n}\n```\n\n### 暴露到注册中心\n\n我们先看下DelegateProviderMetaDataInvoker类。\n```java\n/**\n * DelegateProviderMetaDataInvoker类实现了invoker接口\n * 并且持有一个Invoker变量，操作都会委托给该变量\n */\npublic class DelegateProviderMetaDataInvoker<T> implements Invoker {\n    protected final Invoker<T> invoker;\n    private ServiceConfig metadata;\n\n    public DelegateProviderMetaDataInvoker(Invoker<T> invoker,ServiceConfig metadata) {\n        this.invoker = invoker;\n        this.metadata = metadata;\n    }\n\n    @Override\n    public Class<T> getInterface() {\n        return invoker.getInterface();\n    }\n\n    @Override\n    public URL getUrl() {\n        return invoker.getUrl();\n    }\n\n    @Override\n    public boolean isAvailable() {\n        return invoker.isAvailable();\n    }\n\n    @Override\n    public Result invoke(Invocation invocation) throws RpcException {\n        return invoker.invoke(invocation);\n    }\n\n    @Override\n    public void destroy() {\n        invoker.destroy();\n    }\n\n    public ServiceConfig getMetadata() {\n        return metadata;\n    }\n}\n```\n#### Protocol接口的export方法\n\n先来看下Protocol接口的定义，其export方法和refer方法存在@Adaptive注解。\n```java\n/**\n * 协议\n * Protocol. (API/SPI, Singleton, ThreadSafe)\n */\n@SPI(\"dubbo\")\npublic interface Protocol {\n\n    /**\n     * 当用户没有配置端口时，获取默认端口\n     * @return default port\n     */\n    int getDefaultPort();\n\n    /**\n     * 为远程调用暴露服务\n     * 1、接收到请求后协议应该记录请求源地址，通过: RpcContext.getContext().setRemoteAddress()\n     * 2、export()方法必须是幂等的，也就是说，暴露同一个URL的invoker两次时，调用1次和2次没有什么不同\n     * 3、传入的Invoker实例由框架实现并传入，协议不需要关心\n     *\n     * @param <T>     服务类型\n     * @param invoker 服务invoker\n     * @return 暴露服务的exporter引用，用来以后取消暴露服务\n     * @throws RpcException 当暴露服务出错时抛出，比如端口已占用\n     */\n    @Adaptive\n    <T> Exporter<T> export(Invoker<T> invoker) throws RpcException;\n\n    /**\n     * 引用一个远程服务\n     * 1、当用户调用 refer()所返回的 Invoker对象的invoke()时，协议需相应执行同URL远端export()传入的Invoker对象的invoke()方法.\n     * 2、refer()返回的Invoker由协议实现，一般来说，协议需要在此Invoker中发送远程请求。\n     * 3、当URL中设置了check=false时，这个实现不可以抛出异常，而是尝试着从连接失败中恢复\n     * @param T 远程服务类型\n     * @param type 远程服务接口类型\n     * @param url 远程服务的URL地址\n     * @return 执行服务的本地代理\n     * @throws RpcException when there's any error while connecting to the service provider\n     */\n    @Adaptive\n    <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException;\n\n    /**\n     * 销毁协议\n     * 1、取消该协议所有已经暴露和引用的服务\n     * 2、释放协议所有占用的资源，如：链接、端口等\n     * 3、协议在释放后，依然能暴露和引用新的服务\n     */\n    void destroy();\n}\n\n可以看到export方法是定义在Protocol接口中的，我们是通过ExtensionLoader类获取到Protocol的自适应扩展实例的，因此我们在调用export方法进行服务暴露时，实际上调用的是自适应扩展实例的export方法：\n```java\n//自适应扩展实现类\nProtocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();\n\n//获取invoker对象\nInvoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));\n//将invoker和当前对象(ServiceBean)包装成DelegateProviderMetaDataInvoker对象\nDelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\n//调用自适应扩展实现类的export方法\nExporter<?> exporter = protocol.export(wrapperInvoker);\n```\n那么，在获取自适应扩展实例时都进行了哪些操作呢？我们在《Dubbo源码阅读之SPI扩展机制》文章中介绍过Dubbo的SPI机制，这里就不再详细介绍了，只简单说明下是如何获取到Protocol实例的。\n首先我们我们通过ExtensionLoader.getExtensionLoader(Protocol.class)调用，获取到了Protocol的扩展加载器，然后调用它的getAdaptiveExtension()方法拿到自适应扩展实例(Dubbo为它自动生成的一个类，后面介绍)，在此过程中，会先去扫描3个相关路径找到所有的Protocol扩展实现类定义，\n最终会找到如下定义：\n```java\n#扩展名称=扩展实现类\nregistry=com.alibaba.dubbo.registry.integration.RegistryProtocol\nmock=com.alibaba.dubbo.rpc.support.MockProtocol\ninjvm=com.alibaba.dubbo.rpc.protocol.injvm.InjvmProtocol\ndubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol\n#Protocol包装类\nfilter=com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper\nlistener=com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper\n```\n\n然后检查每个扩展实现类，如果没有找到存在@Adaptive注解的扩展类，则Dubbo会为其生成一个自适应扩展类，生成的实现类如下：\n```java\n/**\n * 生成的实现类名为：Protocol$Adaptive，实现了Protocol接口\n * 只有接口方法上标有@Adaptive注解，才会为其生成实现，\n * 例如，Protocol接口的destroy()方法没有@Adaptive注解，因此下面的方法实现中直接抛了异常\n */\npublic class Protocol$Adaptive implements com.alibaba.dubbo.rpc.Protocol {\n\t\n\tpublic void destroy() {\n\t\t//提示 Protocol接口的destroy()方法没有@Adaptive注解，因此不支持\n\t\tthrow new UnsupportedOperationException(\"method public abstract void com.alibaba.dubbo.rpc.Protocol.destroy() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!\");\n\t}\n\t\n\tpublic int getDefaultPort() {\n\t\t//提示 Protocol接口的getDefaultPort()方法没有@Adaptive注解，因此不支持\n\t\tthrow new UnsupportedOperationException(\"method public abstract int com.alibaba.dubbo.rpc.Protocol.getDefaultPort() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!\");\n\t}\n\t\n\t/**\n\t * @param arg0 服务接口类\n\t * @param arg1 注册中心url\n\t */\n\tpublic com.alibaba.dubbo.rpc.Invoker refer(java.lang.Class arg0, com.alibaba.dubbo.common.URL arg1) throws com.alibaba.dubbo.rpc.RpcException {\n\t\tif (arg1 == null){\n\t\t\t//url参数不可以为空\n\t\t\tthrow new IllegalArgumentException(\"url == null\");\n\t\t}\n\t\t\n\t\tcom.alibaba.dubbo.common.URL url = arg1;\n\t\t\n\t\t//使用url的protocol属性值(这里为registry)，作为扩展名称，如果为空，则默认使用\"dubbo\"\n\t\tString extName = url.getProtocol() == null ? \"dubbo\" : url.getProtocol();\n\t\t\n\t\tif(extName == null) {\n\t\t\tthrow new IllegalStateException(\"Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(\" + url.toString() + \") use keys([protocol])\");\n\t\t}\n\t\t\n\t\t//获取扩展名称为extName的Protocol扩展实例\n\t\tcom.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);\n\t\t\n\t\t//调用该extension实例的refer方法\n\t\treturn extension.refer(arg0, arg1);\n\t}\n\t\t\n\tpublic com.alibaba.dubbo.rpc.Exporter export(com.alibaba.dubbo.rpc.Invoker arg0) throws com.alibaba.dubbo.rpc.RpcException {\n\t\tif (arg0 == null){\n\t\t    throw new IllegalArgumentException(\"com.alibaba.dubbo.rpc.Invoker argument == null\");\n\t\t} \n\t\t\n\t\tif (arg0.getUrl() == null) {\n\t\t    throw new IllegalArgumentException(\"com.alibaba.dubbo.rpc.Invoker argument getUrl() == null\");\n\t\t}\n\t\t\n\t\tcom.alibaba.dubbo.common.URL url = arg0.getUrl();\n\t\t\n\t\t//使用url的protocol属性值(这里为registry)，作为扩展名称，如果为空，则默认使用\"dubbo\"\n\t\tString extName = ( url.getProtocol() == null ? \"dubbo\" : url.getProtocol() );\n\t\t\n\t\tif(extName == null) {\n\t\t\tthrow new IllegalStateException(\"Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(\" + url.toString() + \") use keys([protocol])\");\n\t\t}\n\t\t\n\t\t//获取扩展名称为extName的Protocol扩展实例（此扩展实例已经被包装类包装过）\n\t\tcom.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);\n\t\t\n\t\t//调用该extension实例的export方法(包装类的export方法)\n\t\treturn extension.export(arg0);\n\t}\n}\n```\n在上面我们说到，调用export方法实际上是调用自适应扩展实现类的export方法，我们来看下其实现。\n首先校验invoker参数不可以为空，然后校验invoker对象的getUrl()方法返回的URL对象不可以为空，然后我们使用URL对象的protocol属性作为扩展名称extName(提示：在上一节的loadRegistries(boolean provider)加载注册中心url列表方法中，我们设置了注册中心url的protocol属性值为\"registry\")，然后根据扩展名称extName获取到真正的Protocol扩展实例(RegistryProtocol,然后RegistryProtocol会被包装)，最后调用该Protocol扩展实例的export方法。\n通过生成的自适应扩展实现类，我们可以根据不同的扩展名称调用不同的扩展实例。\n在getExtension(extName)方法中，获取到相应的扩展实例后(RegistryProtocol)，Dubbo会再去查看下该扩展是否存在相应的包装类，在上面我们扫描出来Protocol接口存在2个包装类，ProtocolFilterWrapper和ProtocolListenerWrapper，接着Dubbo会创建包装类的实例，并将刚才生成RegistryProtocol扩展实例通过构造函数参数传递到包装类中，通过包装类，Dubbo就实现了功能增强。\n因此，现在我们再回过头来看下export方法的调用：首先是调用自适应扩展实现类的export方法，在export方法内部，根据扩展名称获取到真实的扩展实例RegistryProtocol，然后又通过两个包装类将真实的扩展实例进行了包装，最后调用的是包装类的export方法。\n具体的调用链我们已经分析完了，现在我们来看下对应的代码。\n```java\n/**\n * 根据扩展名称创建扩展实例后，会获取包装类，将扩展实例进行包装\n */\nprivate T createExtension(String name) {\n\t//根据扩展名称name获取扩展实现类clazz\n\tClass<?> clazz = getExtensionClasses().get(name);\n\tif (clazz == null) {\n\t    //扩展实现类为空，则抛出异常\n\t    throw findException(name);\n\t}\n\ttry {\n\t    //先从缓存中获取扩展实现类的实例，如果没有获取到，则新建一个并放入缓存。\n\t    T instance = (T) EXTENSION_INSTANCES.get(clazz);\n\t    if (instance == null) {\n\t\tEXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());\n\t\tinstance = (T) EXTENSION_INSTANCES.get(clazz);\n\t    }\n\t    //处理扩展实现类实例的依赖注入\n\t    injectExtension(instance);\n\n\t    //获取到type接口的所有包装类\n\t    Set<Class<?>> wrapperClasses = cachedWrapperClasses;\n\t    if (wrapperClasses != null && !wrapperClasses.isEmpty()) {\n\t\t//遍历包装类\n\t\tfor (Class<?> wrapperClass : wrapperClasses) {\n\t\t    //包装类通过构造方法创建实例，然后进行依赖注入\n\t\t    instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));\n\t\t}\n\t    }\n\t    return instance;\n\t} catch (Throwable t) {\n\t    throw new IllegalStateException(\"Extension instance(name: \" + name + \", class: \" +\n\t\t    type + \")  could not be instantiated: \" + t.getMessage(), t);\n\t}\n}\n\npublic class ProtocolFilterWrapper implements Protocol {\n\t\n    //根据上面的分析，这里的protocol是ProtocolListenerWrapper\n    private final Protocol protocol;\n\n    public ProtocolFilterWrapper(Protocol protocol) {\n        if (protocol == null) {\n            throw new IllegalArgumentException(\"protocol == null\");\n        }\n        this.protocol = protocol;\n    }\n    \n    @Override\n    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n        \n        if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) {\n\t    //如果url的protocol属性为registry，则调用protocol的export方法\n            return protocol.export(invoker);\n        }\n        return protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));\n    }\n    //.....省略其他方法....\n}\n\n\npublic class ProtocolListenerWrapper implements Protocol{\n\t\n    //根据上面的分析，这里的protocol是RegistryProtocol\n    private final Protocol protocol;\n\n    public ProtocolListenerWrapper(Protocol protocol) {\n        if (protocol == null) {\n            throw new IllegalArgumentException(\"protocol == null\");\n        }\n        this.protocol = protocol;\n    }\n    \n     @Override\n    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n        if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) {\n\t    //如果url的protocol属性为registry，则调用protocol的export方法\n            return protocol.export(invoker);\n        }\n        return new ListenerExporterWrapper<T>(protocol.export(invoker),\n                Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener.class)\n                        .getActivateExtension(invoker.getUrl(), Constants.EXPORTER_LISTENER_KEY)));\n    }\n}\n```\n经过我们的分析，最终会调用RegistryProtocol的export方法进行服务暴露，接下来，我们就来分析下该方法。\n```java\n\n//获取invoker对象\nInvoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));\n\n//将invoker和当前对象(ServiceBean)包装成DelegateProviderMetaDataInvoker对象\nDelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\n\n\n/**\n * 通过invoker的url(即注册中心url)获取providerUrl的地址（即服务暴露的url）\n * @param origininvoker\n * @return\n */\nprivate URL getProviderUrl(final Invoker<?> origininvoker) {\n\t//获取参数export指定的服务地址\n\tString export = origininvoker.getUrl().getParameterAndDecoded(Constants.EXPORT_KEY);\n\tif (export == null || export.length() == 0) {\n\t    //注册中心服务暴露url为空\n\t    throw new IllegalArgumentException(\"The registry export url is null! registry: \" + origininvoker.getUrl());\n\t}\n\t//根据url字符串生成URL对象\n\tURL providerUrl = URL.valueOf(export);\n\treturn providerUrl;\n}\n\n/**\n * 获取originInvoker对象对应的缓存key（移除了dynamic、enabled属性的服务提供者url）\n */\nprivate String getCacheKey(final Invoker<?> originInvoker) {\n\t//获取服务暴露的url，即export参数对应的url\n\tURL providerUrl = getProviderUrl(originInvoker);\n\t//移除dynamic、enabled参数，剩下的url作为缓存key\n\tString key = providerUrl.removeParameters(\"dynamic\", \"enabled\").toFullString();\n\treturn key;\n}\n\n/**\n * 获取注册中心url(如果是注册中心协议，则修改了protocol属性值，属性值为url的registry参数值，并移除url的registry参数)\n * @param originInvoker\n * @return\n */\nprivate URL getRegistryUrl(Invoker<?> originInvoker) {\n\t//注册中心url\n\tURL registryUrl = originInvoker.getUrl();\n\t\n\tif (Constants.REGISTRY_PROTOCOL.equals(registryUrl.getProtocol())) {\n\t    //如果registryUrl的protocol属性为\"registry\"，则获取registryUrl的registry参数值，如果没有获取到，则默认protocol = dubbo\n\t    //这里获取到protocol = multicast\n\t    String protocol = registryUrl.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_DIRECTORY);\n\t    //设置registryUrl的protocol属性值，并移除registry参数\n\t    registryUrl = registryUrl.setProtocol(protocol).removeParameter(Constants.REGISTRY_KEY);\n\t}\n\treturn registryUrl;\n}\n\n/**\n *\n * 基于invoker的地址获取一个注册中心的实例\n * @param originInvoker\n * @return\n */\nprivate Registry getRegistry(final Invoker<?> originInvoker) {\n\tURL registryUrl = getRegistryUrl(originInvoker);\n\t//获取实例\n\treturn registryFactory.getRegistry(registryUrl);\n}\n\n/**\n * 返回注册到注册中心的地址并过滤一次url参数(即服务提供者url)\n * @param originInvoker\n * @return\n */\nprivate URL getRegistedProviderUrl(final Invoker<?> originInvoker) {\n\t//服务暴露的url，即export参数指定的url\n\tURL providerUrl = getProviderUrl(originInvoker);\n\n\t//在注册中心中看到的服务地址\n\tfinal URL registedProviderUrl = providerUrl.removeParameters(\n\t\t\t//删除不需要输出的参数key\n\t\t\tgetFilteredKeys(providerUrl)\n\t\t)\n\t\t//移除监控\n\t\t.removeParameter(Constants.MONITOR_KEY)\n\t\t//移除绑定ip、port\n\t\t.removeParameter(Constants.BIND_IP_KEY)\n\t\t.removeParameter(Constants.BIND_PORT_KEY)\n\t\t//移除qos\n\t\t.removeParameter(QOS_ENABLE)\n\t\t.removeParameter(QOS_PORT)\n\t\t.removeParameter(ACCEPT_FOREIGN_IP);\n\t\n\treturn registedProviderUrl;\n}\n\n/**\n * 服务暴露\n * originInvoker参数就是上面我们创建的wrapperInvoker\n */\n@Override\npublic <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcException {\n\t//暴露invoker(后面会分析该方法)\n\tfinal ExporterChangeableWrapper<T> exporter = doLocalExport(originInvoker);\n\t\n\t//获取注册中心地址,如：multicast://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&dubbo=2.0.0&export=dubbo%3A%2F%2F192.168.99.60%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26bind.ip%3D192.168.99.60%26bind.port%3D20880%26dubbo%3D2.0.0%26generic%3Dfalse%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D7520%26qos.port%3D22222%26side%3Dprovider%26timestamp%3D1528784828723&pid=7520&qos.port=22222&timestamp=1528784779675\n\tURL registryUrl = getRegistryUrl(originInvoker);\n\n\t//获取注册中心实例\n\tfinal Registry registry = getRegistry(originInvoker);\n\t\n\t//注册中心url的export参数指定的url(服务提供者url)，去掉了一些key\n\tfinal URL registedProviderUrl = getRegistedProviderUrl(originInvoker);\n\t\n\t//判断是否延迟发布，默认是true\n\tboolean register = registedProviderUrl.getParameter(\"register\", true);\n\t\n\t//注册服务提供者(保存到map缓存中)\n\tProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registedProviderUrl);\n\n\tif (register) {\n\t    //registryUrl注册中心url，registedProviderUrl服务提供者url\n\t    //获取注册中心，并将服务提供者注册到注册中心\n\t    register(registryUrl, registedProviderUrl);\n\t    \n\t    //根据originInvoker获取到ProviderInvokerWrapper并标识isReg = true\n\t    ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true);\n\t}\n\n\t// 当提供者订阅时，会影响一个场景，即同一JVM即暴露服务，又引用同一服务。\n\t// 因为subscribed使用服务的名称作为缓存key，它会导致订阅信息被覆盖\n\t//如：provider://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&category=configurators&check=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=5452&side=provider&timestamp=1528789631708\n\tfinal URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);\n\t\n\t//创建OverrideListener对象(后面小节会介绍)\n\tfinal OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);\n\t\n\t//保存overrideSubscribeUrl和overrideSubscribeListener\n\toverrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);\n\t\n\t//订阅服务(后面注册中心小节会介绍)\n\tregistry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);\n\t\n\t//确保每次发布时都返回一个新的exporter实例\n\treturn new DestroyableExporter<T>(exporter, originInvoker, overrideSubscribeUrl, registedProviderUrl);\n}\n\n/**\n * subscribedOverrideUrl\n * @param registedProviderUrl 服务提供者url\n * @return\n */\nprivate URL getSubscribedOverrideUrl(URL registedProviderUrl) {\n\t//设置protocol = provider,修改前 protocol = dubbo\n\t//设置category = configurators\n\t//设置check = false\n\treturn registedProviderUrl.setProtocol(Constants.PROVIDER_PROTOCOL)\n\t\t.addParameters(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY,\n\t\t\tConstants.CHECK_KEY, String.valueOf(false));\n}\n\n/**\n * 通过registryUrl获取注册中心，然后将服务提供者url注册到注册中心\n * @param registryUrl 注册中心url\n * @param registedProviderUrl 服务提供者url\n */\npublic void register(URL registryUrl, URL registedProviderUrl) {\n\t//根据注册中心url 获取注册中心实例\n\tRegistry registry = registryFactory.getRegistry(registryUrl);\n\t//注册 服务提供者 到注册中心\n\tregistry.register(registedProviderUrl);\n}\n\n/**\n * 为了解决RMI反复暴露端口冲突的问题，已经暴露的服务不需要再次暴露\n * <providerurl,exporter>\n */\nprivate final Map<String, ExporterChangeableWrapper<?>> bounds = new ConcurrentHashMap<String, ExporterChangeableWrapper<?>>();\n\n/**\n * <服务提供者url,NotifyListener>\n */\nprivate final Map<URL, NotifyListener> overrideListeners = new ConcurrentHashMap<URL, NotifyListener>();\n\n/**\n * 暴露originInvoker\n */\nprivate <T> ExporterChangeableWrapper<T> doLocalExport(final Invoker<T> originInvoker) {\n\t//获取缓存key\n\tString key = getCacheKey(originInvoker);\n\t\n\t//先检查是否暴露过，没有暴露过的话，则进行暴露\n\tExporterChangeableWrapper<T> exporter = (ExporterChangeableWrapper<T>) bounds.get(key);\n\tif (exporter == null) {\n\t    synchronized (bounds) {\n\t\texporter = (ExporterChangeableWrapper<T>) bounds.get(key);\n\t\tif (exporter == null) {\n\t\t    //根据originInvoker，及其服务提供者url，创建InvokerDelegete对象\n\t\t    final Invoker<?> invokerDelegete = new InvokerDelegete<T>(originInvoker, getProviderUrl(originInvoker));\n\t\t   \n\t\t    //1、因为invokerDelegete对象的getUrl方法将会返回服务提供者url，其protocol属性将会返回扩展名称dubbo，因此这里会调用DubboProtocol的export方法进行暴露\n\t\t    //2、创建ExporterChangeableWrapper对象\n\t\t    exporter = new ExporterChangeableWrapper<T>((Exporter<T>) protocol.export(invokerDelegete), originInvoker);\n\t\t    \n\t\t    //dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=192.168.99.60&bind.port=20880&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=6440&qos.port=22222&side=provider&timestamp=1528789363848\n\t\t    //URL url = exporter.getInvoker().getUrl();\n\t\t    //放入缓存\n\t\t    bounds.put(key, exporter);\n\t\t}\n\t    }\n\t}\n\treturn exporter;\n}\n\n/**\n * Invoker委托类\n */\npublic static class InvokerDelegete<T> extends InvokerWrapper<T> {\n\n\tprivate final Invoker<T> invoker;\n\n\t/**\n\t * @param invoker\n\t * @param url   服务提供者url\n\t */\n\tpublic InvokerDelegete(Invoker<T> invoker, URL url) {\n\t    super(invoker, url);\n\t    this.invoker = invoker;\n\t}\n\n\tpublic Invoker<T> getInvoker() {\n\t    if (invoker instanceof InvokerDelegete) {\n\t\treturn ((InvokerDelegete<T>) invoker).getInvoker();\n\t    } else {\n\t\treturn invoker;\n\t    }\n\t}\n}\n\n/**\n * exporter代理\n * 建立通过protocol已暴露的exporter和已返回的exporter的对应关系\n * 并且可以在覆盖时修改关系\n */\nprivate class ExporterChangeableWrapper<T> implements Exporter<T> {\n\n\tprivate final Invoker<T> originInvoker;\n\n\t//protocol.export(invokerDelegete)返回的Exporter\n\tprivate Exporter<T> exporter;\n\n\tpublic ExporterChangeableWrapper(Exporter<T> exporter, Invoker<T> originInvoker) {\n\t    this.exporter = exporter;\n\t    this.originInvoker = originInvoker;\n\t}\n\n\tpublic Invoker<T> getOriginInvoker() {\n\t    return originInvoker;\n\t}\n\n\t@Override\n\tpublic Invoker<T> getInvoker() {\n\t    return exporter.getInvoker();\n\t}\n\n\tpublic void setExporter(Exporter<T> exporter) {\n\t    this.exporter = exporter;\n\t}\n\n\t@Override\n\tpublic void unexport() {\n\t    String key = getCacheKey(this.originInvoker);\n\t    bounds.remove(key);\n\t    exporter.unexport();\n\t}\n}\n\n/**\n * 可销毁的Exporter\n */\nstatic private class DestroyableExporter<T> implements Exporter<T> {\n\t\n\tpublic static final ExecutorService executor = Executors.newSingleThreadExecutor(new NamedThreadFactory(\"Exporter-Unexport\", true));\n\n\tprivate Exporter<T> exporter;\n\tprivate Invoker<T> originInvoker;\n\n\t//overrideSubscribeUrl 订阅的url\n\tprivate URL subscribeUrl; \n\t\n\t//registedProviderUrl 注册的服务提供者url\n\tprivate URL registerUrl;\n\n\tpublic DestroyableExporter(Exporter<T> exporter, Invoker<T> originInvoker, URL subscribeUrl, URL registerUrl) {\n\t    this.exporter = exporter;\n\t    this.originInvoker = originInvoker;\n\t    this.subscribeUrl = subscribeUrl;\n\t    this.registerUrl = registerUrl;\n\t}\n\n\t@Override\n\tpublic Invoker<T> getInvoker() {\n\t    return exporter.getInvoker();\n\t}\n\n\t@Override\n\tpublic void unexport() {\n\t    //获取注册中心实例\n\t    Registry registry = RegistryProtocol.INSTANCE.getRegistry(originInvoker);\n\t    try {\n\t        //取消注册registerUrl\n\t\tregistry.unregister(registerUrl);\n\t    } catch (Throwable t) {\n\t\tlogger.warn(t.getMessage(), t);\n\t    }\n\t    try {\n\t        //移除监听\n\t\tNotifyListener listener = RegistryProtocol.INSTANCE.overrideListeners.remove(subscribeUrl);\n\t\t//取消订阅subscribeUrl\n\t\tregistry.unsubscribe(subscribeUrl, listener);\n\t    } catch (Throwable t) {\n\t\tlogger.warn(t.getMessage(), t);\n\t    }\n\t    //提交线程，取消暴露服务\n\t    executor.submit(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t    try {\n\t\t        //取消暴露服务时，等待注册中心通知所有的消费者的超时时间\n\t\t\tint timeout = ConfigUtils.getServerShutdownTimeout();\n\t\t\tif (timeout > 0) {\n\t\t\t    logger.info(\"Waiting \" + timeout + \"ms for registry to notify all consumers before unexport. Usually, this is called when you use dubbo API\");\n\t\t\t    Thread.sleep(timeout);\n\t\t\t}\n\t\t\t//取消暴露服务\n\t\t\texporter.unexport();\n\t\t    } catch (Throwable t) {\n\t\t\tlogger.warn(t.getMessage(), t);\n\t\t    }\n\t\t}\n\t    });\n\t}\n}\n```\n\nProviderConsumerRegTable类用来保存注册的服务提供者和消费者\n```java\npublic class ProviderConsumerRegTable {\n    /**\n     * <服务唯一名称,Set<服务提供者执行器>>\n     */\n    public static ConcurrentHashMap<String, Set<ProviderInvokerWrapper>> providerInvokers = new ConcurrentHashMap<String, Set<ProviderInvokerWrapper>>();\n    public static ConcurrentHashMap<String, Set<ConsumerInvokerWrapper>> consumerInvokers = new ConcurrentHashMap<String, Set<ConsumerInvokerWrapper>>();\n\n    /**\n     * 注册服务提供者\n     * @param invoker\n     * @param registryUrl 注册中心地址\n     * @param providerUrl 服务提供者url\n     */\n    public static void registerProvider(Invoker invoker, URL registryUrl, URL providerUrl) {\n\t//创建ProviderInvokerWrapper实例\n        ProviderInvokerWrapper wrapperInvoker = new ProviderInvokerWrapper(invoker, registryUrl, providerUrl);\n        \n\t//获取服务唯一名称标识\n        String serviceUniqueName = providerUrl.getServiceKey();\n\t\n\t//根据serviceUniqueName从缓存中获取\n\tSet<ProviderInvokerWrapper> invokers = providerInvokers.get(serviceUniqueName);\n        \n\tif (invokers == null) {\n            providerInvokers.putIfAbsent(serviceUniqueName, new ConcurrentHashSet<ProviderInvokerWrapper>());\n            invokers = providerInvokers.get(serviceUniqueName);\n        }\n        invokers.add(wrapperInvoker);\n    }\n}\n\n/**\n * 通过invoker 获取相应的ProviderInvokerWrapper\n * @param invoker\n * @return\n */\npublic static ProviderInvokerWrapper getProviderWrapper(Invoker invoker) {\n\t//获取服务提供者url\n\tURL providerUrl = invoker.getUrl();\n\tif (Constants.REGISTRY_PROTOCOL.equals(providerUrl.getProtocol())) {\n\t    //获取export参数的值，即(服务提供者url)\n\t    providerUrl = URL.valueOf(providerUrl.getParameterAndDecoded(Constants.EXPORT_KEY));\n\t}\n\t//获取服务唯一标识\n\tString serviceUniqueName = providerUrl.getServiceKey();\n\t//根据服务唯一标识获取invokers\n\tSet<ProviderInvokerWrapper> invokers = providerInvokers.get(serviceUniqueName);\n\tif (invokers == null) {\n\t    return null;\n\t}\n\tfor (ProviderInvokerWrapper providerWrapper : invokers) {\n\t    Invoker providerInvoker = providerWrapper.getInvoker();\n\t    //通过invoker获取providerWrapper\n\t    if (providerInvoker == invoker) {\n\t\treturn providerWrapper;\n\t    }\n\t}\n\treturn null;\n}\n\n\n/**\n * 重新暴露修改了url的invoker\n * @param originInvoker\n * @param newInvokerUrl\n */\n@SuppressWarnings(\"unchecked\")\nprivate <T> void doChangeLocalExport(final Invoker<T> originInvoker, URL newInvokerUrl) {\n        //获取originInvoker对应的缓存key\n\tString key = getCacheKey(originInvoker);\n\n\t//从缓存中获取该exporter\n\tfinal ExporterChangeableWrapper<T> exporter = (ExporterChangeableWrapper<T>) bounds.get(key);\n\t\n\tif (exporter == null) {\n\t    logger.warn(new IllegalStateException(\"error state, exporter should not be null\"));\n\t} else {\n\t    //重新生成invokerDelegete\n\t    final Invoker<T> invokerDelegete = new InvokerDelegete<T>(originInvoker, newInvokerUrl);\n\t    //重新暴露服务\n\t    exporter.setExporter(protocol.export(invokerDelegete));\n\t}\n}\n```\n\n接下来我们看下OverrideListener类\n```java\n/**\n * 1、确保由registryProtocol返回的exporter可以被正常销毁\n * 2、通知后，无需重新注册到注册中心\n * 3、通过暴露方法传递invoker，最好是exporter的invoker\n */\nprivate class OverrideListener implements NotifyListener {\n\t/**\n\t * 已订阅的url\n\t * protocol = provider\n\t */\n\tprivate final URL subscribeUrl;\n\n\tprivate final Invoker originInvoker;\n\n\tpublic OverrideListener(URL subscribeUrl, Invoker originalInvoker) {\n\t    this.subscribeUrl = subscribeUrl;\n\t    this.originInvoker = originalInvoker;\n\t}\n\n\t/**\n\t * 通知\n\t * @param urls 已注册的信息列表，它总是非空。这意味着与RegistryService#lookup(URL)有相同的返回值\n\t */\n\t@Override\n\tpublic synchronized void notify(List<URL> urls) {\n\t    logger.debug(\"original override urls: \" + urls);\n\t    \n\t    //获取匹配到的url\n\t    List<URL> matchedUrls = getMatchedUrls(urls, subscribeUrl);\n\t    logger.debug(\"subscribe url: \" + subscribeUrl + \", override urls: \" + matchedUrls);\n\n\t    //没有匹配到结果，直接返回\n\t    if (matchedUrls.isEmpty()) {\n\t\treturn;\n\t    }\n\t\t\n\t    //根据匹配的url生成configurators列表(后面小节会分析该方法)\n\t    List<Configurator> configurators = RegistryDirectory.toConfigurators(matchedUrls);\n\n\t    final Invoker<?> invoker;\n\t    if (originInvoker instanceof InvokerDelegete) {\n\t        //委托类，调用getInvoker()方法获取invoker\n\t\tinvoker = ((InvokerDelegete<?>) originInvoker).getInvoker();\n\t    } else {\n\t\tinvoker = originInvoker;\n\t    }\n\n\t    //originUrl即export参数对应的url(原始服务提供者url)\n\t    URL originUrl = RegistryProtocol.this.getProviderUrl(invoker);\n\t    \n\t    //这里的exporter就是在上步的doLocalExport()方法中生成的\n\t    String key = getCacheKey(originInvoker);\n\n\t    //根据缓存key从缓存中获取exporter\n\t    ExporterChangeableWrapper<?> exporter = bounds.get(key);\n\t    if (exporter == null) {\n\t\tlogger.warn(new IllegalStateException(\"error state, exporter should not be null\"));\n\t\treturn;\n\t    }\n\t    \n\t    //当前的url(旧的服务暴露的url)，可能已经合并了很多次\n\t    URL currentUrl = exporter.getInvoker().getUrl();\n\t   \n\t    //合并配置，生成新的服务暴露url\n\t    URL newUrl = getConfigedInvokerUrl(configurators, originUrl);\n\t    \n\t    if (!currentUrl.equals(newUrl)) {\n\t\t//已暴露的服务提供者url已经发生改变，重新暴露\n\t\tRegistryProtocol.this.doChangeLocalExport(originInvoker, newUrl);\n\n\t\tlogger.info(\"exported provider url changed, origin url: \" + originUrl + \", old export url: \" + currentUrl + \", new export url: \" + newUrl);\n\t    }\n\t}\n\t\n\t/**\n\t * 获取匹配的url\n\t * @param configuratorUrls\n\t * @param currentSubscribe 当前已订阅的url\n\t */\n\tprivate List<URL> getMatchedUrls(List<URL> configuratorUrls, URL currentSubscribe) {\n\t    List<URL> result = new ArrayList<URL>();\n\t    \n\t    for (URL url : configuratorUrls) {\n\t\tURL overrideUrl = url;\n\t\t//与旧版本兼容\n\t\tif (url.getParameter(Constants.CATEGORY_KEY) == null && Constants.OVERRIDE_PROTOCOL.equals(url.getProtocol())) {\n\t\t    //url的category参数为空，并且url协议为override时，则新增url的category参数 = configurators\n\t\t    overrideUrl = url.addParameter(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY);\n\t\t}\n\n\t\t//检测url是否可以应用到当前服务\n\t\t//consumerUrl,providerUrl\n\t\tif (UrlUtils.isMatch(currentSubscribe, overrideUrl)) {\n\t\t    //匹配，则将该url保存\n\t\t    result.add(url);\n\t\t}\n\t    }\n\t    return result;\n\t}\n\n\t/**\n\t * 合并configurators的url，返回新的url\n\t * @param configurators\n\t * @param url 原始服务提供者url\n\t * @return\n\t */\n\tprivate URL getConfigedInvokerUrl(List<Configurator> configurators, URL url) {\n\t    for (Configurator configurator : configurators) {\n\t        //配置url\n\t\turl = configurator.configure(url);\n\t    }\n\t    return url;\n\t}\n}\n```\n\n最后我们来看下DubboProtocol的export方法\n\n```java\n/**\n * 保存发布的服务\n * <URL的serviceKey,Exporter>\n * 通过key可以获取到服务发布对象DubboExporter，\n * 然后通过DubboExporter的getInvoker方法得到服务调用对象Invoker,从而调用服务\n */\nprotected final Map<String, Exporter<?>> exporterMap = new ConcurrentHashMap<String, Exporter<?>>();\n\n/**\n * 消费者端为调度事件暴露一个存根服务\n * <servicekey,stubmethods>\n */\nprivate final ConcurrentMap<String, String> stubServiceMethodsMap = new ConcurrentHashMap<String, String>();\n\n\n/**\n *\n * @param invoker 即新创建的InvokerDelegete对象\n */\n@Override\npublic <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n\t\n\t//服务提供者url\n\t//dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=192.168.99.60&bind.port=20880&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=7520&qos.port=22222&side=provider&timestamp=1528784828723\n\tURL url = invoker.getUrl();\n\n\t// 获取服务名称，格式为：group/ServiceName:version:port\n\t// 这里group和version没有设置，因此key = com.alibaba.dubbo.demo.DemoService:20880\n\tString key = serviceKey(url);\n\t\n\t//生成key值之后，结合Invoker和exportMap生成服务暴露对象exporter，\n\t//然后将生成的服务暴露对象exporter作为value值放入map中，从而实现服务发布\n\tDubboExporter<T> exporter = new DubboExporter<T>(invoker, key, exporterMap);\n\texporterMap.put(key, exporter);\n\n\t//为调度事件暴露一个存根服务，默认false\n\tBoolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);\n\t\n\t//是否是回调服务\n\tBoolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, false);\n\tif (isStubSupportEvent && !isCallbackservice) {\n\t    //存根服务方法\n\t    String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);\n\t    if (stubServiceMethods == null || stubServiceMethods.length() == 0) {\n\t\tif (logger.isWarnEnabled()) {\n\t\t    //设置了存根代理支持事件，但是没有发现存根方法\n\t\t    logger.warn(new IllegalStateException(\"consumer [\" + url.getParameter(Constants.INTERFACE_KEY) +\n\t\t\t    \"], has set stubproxy support event ,but no stub methods founded.\"));\n\t\t}\n\t    } else {\n\t\t//保存存根方法\n\t\tstubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);\n\t    }\n\t}\n\t//开启服务\n\topenServer(url);\n\t//优化序列化(加载优化序列化类,后面小节会详细介绍)\n\toptimizeSerialization(url);\n\t//返回exporter\n\treturn exporter;\n}\n\n/**\n * 保存已创建的服务器\n * <地址address，ExchangeServer>\n */\nprivate final Map<String, ExchangeServer> serverMap = new ConcurrentHashMap<String, ExchangeServer>();\n\n/**\n * 开启服务(后面会小节会详解讲解)\n * @param url\n */\nprivate void openServer(URL url) {\n\t//获取服务地址\n\tString key = url.getAddress();\n\t\n\t//客户端可以暴露一个只能服务端调用的服务\n\tboolean isServer = url.getParameter(Constants.IS_SERVER_KEY, true);\n\t\n\tif (isServer) {\n\t    //先从缓存中获取下该服务地址key对应的服务器\n\t    ExchangeServer server = serverMap.get(key);\n\t    if (server == null) {\n\t\t//创建服务器，并放入缓存\n\t\tserverMap.put(key, createServer(url));\n\t    } else {\n\t\t//服务器支持重置，与override一起使用\n\t\t//重置服务器\n\t\tserver.reset(url);\n\t    }\n\t}\n}\n\n\n/**\n * 创建服务器\n * @param url 服务提供者url\n * @return\n */\nprivate ExchangeServer createServer(URL url) {\n\t//当服务器关闭时，发送readonly事件，默认情况下，是启用的。\n\turl = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString());\n\t\n\t//默认情况下，启用心跳\n\turl = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));\n\t\n\t//获取Transporter扩展，默认使用netty\n\tString str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);\n\n\tif (str != null && str.length() > 0 && !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) {\n\t    //不支持的服务器类型\n\t    throw new RpcException(\"Unsupported server type: \" + str + \", url: \" + url);\n\t}\n\t//在url中添加codec=dubbo\n\turl = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);\n\t\n\tExchangeServer server;\n\ttry {\n\t    //Exchangers门面 绑定到服务器\n\t    server = Exchangers.bind(url, requestHandler);\n\t} catch (RemotingException e) {\n\t    throw new RpcException(\"Fail to start server(url: \" + url + \") \" + e.getMessage(), e);\n\t}\n\t\n\t//获取客户端扩展名称\n\tstr = url.getParameter(Constants.CLIENT_KEY);\n\t\n\tif (str != null && str.length() > 0) {\n\t    //获取支持的Transporter扩展名称列表\n\t    Set<String> supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();\n\t    if (!supportedTypes.contains(str)) {\n\t\t//不支持的客户端类型\n\t\tthrow new RpcException(\"Unsupported client type: \" + str);\n\t    }\n\t}\n\treturn server;\n}\n```\n\n\n### 暴露到本地\n\n主要的方法调用protocol.export上文我们已经介绍过了，这里就不再介绍了。\n\n```java\n/**\n * 暴露服务到本地注册中心\n * @param url 服务暴露的url\n */\nprivate void exportLocal(URL url) {\n\tif (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) {\n\t    //例如：injvm://127.0.0.1/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=192.168.99.60&bind.port=20880&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=4328&qos.port=22222&side=provider&timestamp=1528278313225\n\t    URL local = URL.valueOf(url.toFullString())\n\t\t    //设置injvm协议\n\t\t    .setProtocol(Constants.LOCAL_PROTOCOL)\n\t\t    //设置本地地址\n\t\t    .setHost(LOCALHOST)\n\t\t    //设置端口\n\t\t    .setPort(0);\n\n\t    //获取到实现类ref的Class对象，然后将它放入到ThreadLocal中\n\t    ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref));\n\n\t    //暴露服务(后面会分析export方法)\n\t    Exporter<?> exporter = protocol.export(\n\t\t    proxyFactory.getInvoker(ref, (Class) interfaceClass, local)\n\t    );\n\n\t    //保存暴露的服务到本地变量中\n\t    exporters.add(exporter);\n\t    logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to local registry\");\n\t}\n}\n```\n\n到此，关于服务暴露的内容，我们就介绍完毕了，下一小节，介绍如果引用服务.\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之集成Spring外部化配置(03)","url":"/blog/2018/08/08/Dubbo源码阅读之集成Spring-03外部化配置/","content":">这一小节，我们来看下支持外部化配置的相关类，因为本系列文章主要关注源码，具体的映射规则就不在介绍了，可以参考: https://zhuanlan.zhihu.com/p/32557951\n\n### 支持的注解\n\n#### DubboComponentScan注解\n@Import是Spring提供的注解，可以通过导入的方式将实例添加到BeanFactory中，不了解的童鞋可以去我的博客里面找一下，有单独的文章介绍。\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Import(DubboComponentScanRegistrar.class)\npublic @interface DubboComponentScan {\n\n    /**\n     * basePackages() 别名，例如，可以使用 @DubboComponentScan(\"org.my.pkg\") 替代 @DubboComponentScan(basePackages=\"org.my.pkg\")\n     * Alias for the {@link #basePackages()} attribute. Allows for more concise annotation\n     * declarations e.g.: {@code @DubboComponentScan(\"org.my.pkg\")} instead of\n     * {@code @DubboComponentScan(basePackages=\"org.my.pkg\")}.\n     *\n     * @return the base packages to scan\n     */\n    String[] value() default {};\n\n    /**\n     * 被标注@Service注解的类所在基础包路径\n     * @return the base packages to scan\n     */\n    String[] basePackages() default {};\n\n    /**\n     * 类型安全，用来替代 basePackages()\n     * @return the base packages to scan\n     */\n    Class<?>[] basePackageClasses() default {};\n}\n```\n然后我们看下DubboComponentScanRegistrar类，该类负责注册ServiceAnnotationBeanPostProcessor和ReferenceAnnotationBeanPostProcessor到BeanFactory\n```java\n/**\n * 实现了ImportBeanDefinitionRegistrar接口，允许我们注册特定的bean到Spring中\n * Dubbo {@link DubboComponentScan} Bean Registrar\n *\n * @see Service\n * @see DubboComponentScan\n * @see ImportBeanDefinitionRegistrar\n * @see ServiceAnnotationBeanPostProcessor\n * @see ReferenceAnnotationBeanPostProcessor\n * @since 2.5.7\n */\npublic class DubboComponentScanRegistrar implements ImportBeanDefinitionRegistrar {\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n\n        //获取待扫描的基础包路径\n        Set<String> packagesToScan = getPackagesToScan(importingClassMetadata);\n\n        //注册ServiceAnnotationBeanPostProcessor\n        registerServiceAnnotationBeanPostProcessor(packagesToScan, registry);\n        //注册ReferenceAnnotationBeanPostProcessor\n        registerReferenceAnnotationBeanPostProcessor(registry);\n\n    }\n\n    /**\n     * 注册ServiceAnnotationBeanPostProcessor类\n     *\n     * @param packagesToScan 待扫描的包路径，没有处理placeholders\n     * @param registry       {@link BeanDefinitionRegistry}\n     * @since 2.5.8\n     */\n    private void registerServiceAnnotationBeanPostProcessor(Set<String> packagesToScan,\n                                                            BeanDefinitionRegistry registry) {\n\n        BeanDefinitionBuilder builder = rootBeanDefinition(ServiceAnnotationBeanPostProcessor.class);\n        builder.addConstructorArgValue(packagesToScan);\n        builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();\n        //生成beanName并执行注册\n        BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry);\n\n    }\n\n    /**\n     * 注册ReferenceAnnotationBeanPostProcessor类\n     * @param registry {@link BeanDefinitionRegistry}\n     */\n    private void registerReferenceAnnotationBeanPostProcessor(BeanDefinitionRegistry registry) {\n\n        // Register @Reference Annotation Bean Processor\n        BeanRegistrar.registerInfrastructureBean(registry,\n                ReferenceAnnotationBeanPostProcessor.BEAN_NAME,\n                ReferenceAnnotationBeanPostProcessor.class);\n\n    }\n\n    /**\n     * 获取待扫描的基础包路径\n     * @param metadata\n     * @return\n     */\n    private Set<String> getPackagesToScan(AnnotationMetadata metadata) {\n        //获取@DubboComponentScan注解属性\n        AnnotationAttributes attributes = AnnotationAttributes.fromMap(\n                metadata.getAnnotationAttributes(DubboComponentScan.class.getName())\n        );\n        String[] basePackages = attributes.getStringArray(\"basePackages\");\n        Class<?>[] basePackageClasses = attributes.getClassArray(\"basePackageClasses\");\n        String[] value = attributes.getStringArray(\"value\");\n        //将basePackages、basePackageClasses、value属性指定的值合并起来\n        Set<String> packagesToScan = new LinkedHashSet<String>(Arrays.asList(value));\n        packagesToScan.addAll(Arrays.asList(basePackages));\n        for (Class<?> basePackageClass : basePackageClasses) {\n            //通过basePackageClass获取包名\n            packagesToScan.add(ClassUtils.getPackageName(basePackageClass));\n        }\n        if (packagesToScan.isEmpty()) {\n            //如果没有配置基础包路径的话，则取包名作为基础包路径\n            return Collections.singleton(ClassUtils.getPackageName(metadata.getClassName()));\n        }\n        return packagesToScan;\n    }\n}\n```\n\n#### EnableDubboConfig注解\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\n@Import(DubboConfigConfigurationSelector.class)\npublic @interface EnableDubboConfig {\n    /**\n     * 表明是否绑定到多个Spring-Bean,默认是false\n     */\n    boolean multiple() default false;\n}\n\n/**\n * 该类实现了ImportSelector接口，此接口是Spring中导入外部配置的核心接口，有兴趣的读者可以去了解下，这里就不多做介绍了。\n * Dubbo {@link AbstractConfig Config} Registrar\n * @see EnableDubboConfig\n * @see DubboConfigConfiguration\n * @since 2.5.8\n */\npublic class DubboConfigConfigurationSelector implements ImportSelector, Ordered {\n\n    /**\n     * 要导入到Spring容器中的组件全类名\n     * @param importingClassMetadata\n     * @return\n     */\n    @Override\n    public String[] selectImports(AnnotationMetadata importingClassMetadata) {\n\n        AnnotationAttributes attributes = AnnotationAttributes.fromMap(\n                importingClassMetadata\n                        .getAnnotationAttributes(EnableDubboConfig.class.getName())\n        );\n\n        //是否绑定到多个Spring-Bean\n        boolean multiple = attributes.getBoolean(\"multiple\");\n\n        if (multiple) {\n            //返回多dubbo配置bean绑定\n            return of(DubboConfigConfiguration.Multiple.class.getName());\n        } else {\n            return of(DubboConfigConfiguration.Single.class.getName());\n        }\n    }\n\n    private static <T> T[] of(T... values) {\n        return values;\n    }\n\n    @Override\n    public int getOrder() {\n        return HIGHEST_PRECEDENCE;\n    }\n}\n\n\npublic class DubboConfigConfiguration {\n\n    /**\n     * 单Dubbo配置Bean绑定\n     * Single Dubbo {@link AbstractConfig Config} Bean Binding\n     */\n    @EnableDubboConfigBindings({\n            @EnableDubboConfigBinding(prefix = \"dubbo.application\", type = ApplicationConfig.class),\n            @EnableDubboConfigBinding(prefix = \"dubbo.module\", type = ModuleConfig.class),\n            @EnableDubboConfigBinding(prefix = \"dubbo.registry\", type = RegistryConfig.class),\n            @EnableDubboConfigBinding(prefix = \"dubbo.protocol\", type = ProtocolConfig.class),\n            @EnableDubboConfigBinding(prefix = \"dubbo.monitor\", type = MonitorConfig.class),\n            @EnableDubboConfigBinding(prefix = \"dubbo.provider\", type = ProviderConfig.class),\n            @EnableDubboConfigBinding(prefix = \"dubbo.consumer\", type = ConsumerConfig.class)\n    })\n    public static class Single {\n\n    }\n\n    /**\n     * 多Dubbo配置Bean绑定\n     * Multiple Dubbo {@link AbstractConfig Config} Bean Binding\n     */\n    @EnableDubboConfigBindings({\n            @EnableDubboConfigBinding(prefix = \"dubbo.applications\", type = ApplicationConfig.class, multiple = true),\n            @EnableDubboConfigBinding(prefix = \"dubbo.modules\", type = ModuleConfig.class, multiple = true),\n            @EnableDubboConfigBinding(prefix = \"dubbo.registries\", type = RegistryConfig.class, multiple = true),\n            @EnableDubboConfigBinding(prefix = \"dubbo.protocols\", type = ProtocolConfig.class, multiple = true),\n            @EnableDubboConfigBinding(prefix = \"dubbo.monitors\", type = MonitorConfig.class, multiple = true),\n            @EnableDubboConfigBinding(prefix = \"dubbo.providers\", type = ProviderConfig.class, multiple = true),\n            @EnableDubboConfigBinding(prefix = \"dubbo.consumers\", type = ConsumerConfig.class, multiple = true)\n    })\n    public static class Multiple {\n\n    }\n}\n```\n使用方式:\n```java\n//将以下内容的外部化配置文件物理路径为：classpath:/META-INF/multiple-config.properties:\n#多Dubbo配置Bean绑定\n## dubbo.applications\ndubbo.applications.applicationBean.name = dubbo-demo-application\ndubbo.applications.applicationBean2.name = dubbo-demo-application2\ndubbo.applications.applicationBean3.name = dubbo-demo-application3\n\n//新建配置类DubboMultipleConfiguration\n@EnableDubboConfig(multiple = true)\n@PropertySource(\"META-INF/multiple-config.properties\")\nprivate static class DubboMultipleConfiguration {\n\n} \n\n\n//测试类\npublic class DubboConfigurationBootstrap {\n\tpublic static void main(String[] args) {\n\t\t//创建配置上下文\n\t\tAnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\n\t\t//注册当前配置 Bean\n       \t\tcontext.register(DubboMultipleConfiguration.class);\n       \t\tcontext.refresh();\n\n\t\t//获取ApplicationConfig Bean：\"applicationBean\"、\"applicationBean2\" 和 \"applicationBean3\"\n\t\tApplicationConfig applicationBean = context.getBean(\"applicationBean\", ApplicationConfig.class);\n\t\tApplicationConfig applicationBean2 = context.getBean(\"applicationBean2\", ApplicationConfig.class);\n\t\tApplicationConfig applicationBean3 = context.getBean(\"applicationBean3\", ApplicationConfig.class);\n\n\t\tSystem.out.printf(\"applicationBean.name = %s \\n\", applicationBean.getName());\n\t\tSystem.out.printf(\"applicationBean2.name = %s \\n\", applicationBean2.getName());\n\t\tSystem.out.printf(\"applicationBean3.name = %s \\n\", applicationBean3.getName());\n\t}\n}\n```\n\n#### @EnableDubboConfigBinding/@EnableDubboConfigBindings注解\n@EnableDubboConfig适合绝大多数外部化配置场景,然而无论是单Bean绑定,还是多Bean绑定,其外部化配置属性前缀是固化的,如dubbo.application以及dubbo.applications.\n当应用需要自定义外部化配置属性前缀,@EnableDubboConfigBinding能提供更大的弹性，支持单个外部化配置属性前缀(prefix)与Dubbo配置Bean类型(AbstractConfig子类)绑定,如果需要多次绑定时,可使用@EnableDubboConfigBindings.\n@EnableDubboConfigBinding在支持外部化配置属性与Dubbo配置类绑定时,与Dubbo过去的映射行为不同,被绑定的Dubbo配置类将会提升为Spring Bean,无需提前装配Dubbo配置类.同时,支持多Dubbo配置Bean装配.其Bean的绑定规则与@EnableDubboConfig一致.\n\n##### @EnableDubboConfigBinding注解\n\n```java\n@Target({ElementType.TYPE, ElementType.ANNOTATION_TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Import(DubboConfigBindingRegistrar.class)\npublic @interface EnableDubboConfigBinding {\n\n    /**\n     * 指定待绑定Dubbo配置类的外部化配置属性的前缀,比如dubbo.application为 ApplicationConfig的外部化配置属性的前缀.\n     * prefix()支持占位符(Placeholder),\n     * 并且其关联前缀值是否以\".\"作为结尾字符是可选的,即\"dubbo.application\"与\"dubbo.application.\"效果相同\n     * 例如：\"dubbo.application.\" 或 \"dubbo.application\"\n     * The name prefix of the properties that are valid to bind to {@link AbstractConfig Dubbo Config}.\n     *\n     * @return the name prefix of the properties to bind\n     */\n    String prefix();\n\n    /**\n     * 绑定的Dubbo配置类型,即Dubbo配置类,所有AbstractConfig的子类都可以\n     * @return The binding type of {@link AbstractConfig Dubbo Config}.\n     * @see AbstractConfig\n     * @see ApplicationConfig\n     * @see ModuleConfig\n     * @see RegistryConfig\n     */\n    Class<? extends AbstractConfig> type();\n\n    /**\n     * 是否需要将prefix()作为多个type()类型的Spring Bean外部化配置属性,默认值为false\n     * It indicates whether {@link #prefix()} binding to multiple Spring Beans.\n     *\n     * @return the default value is <code>false</code>\n     */\n    boolean multiple() default false;\n}\n\n\n/**\n * 实现了ImportBeanDefinitionRegistrar接口，允许我们注册特定的bean到Spring中\n * {@link AbstractConfig Dubbo Config} binding Bean registrar\n *\n * @see EnableDubboConfigBinding\n * @see DubboConfigBindingBeanPostProcessor\n * @since 2.5.8\n */\npublic class DubboConfigBindingRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware {\n\n    private final Log log = LogFactory.getLog(getClass());\n\n    private ConfigurableEnvironment environment;\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n\n        //获取@EnableDubboConfigBinding注解\n        AnnotationAttributes attributes = AnnotationAttributes.fromMap(\n                importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBinding.class.getName()));\n        //处理@EnableDubboConfigBinding注解属性并注册bean\n        registerBeanDefinitions(attributes, registry);\n    }\n\n    /**\n     * 读取@EnableDubboConfigBinding注解属性值，然后注册bean\n     * @param attributes\n     * @param registry\n     */\n    protected void registerBeanDefinitions(AnnotationAttributes attributes, BeanDefinitionRegistry registry) {\n\n        //获取@EnableDubboConfigBinding注解的prefix属性，并处理占位符\n        String prefix = environment.resolvePlaceholders(attributes.getString(\"prefix\"));\n        //获取@EnableDubboConfigBinding注解的type属性\n        Class<? extends AbstractConfig> configClass = attributes.getClass(\"type\");\n        //获取@EnableDubboConfigBinding注解的multiple属性\n        boolean multiple = attributes.getBoolean(\"multiple\");\n        //注册Dubbo配置bean\n        registerDubboConfigBeans(prefix, configClass, multiple, registry);\n    }\n\n    /**\n     * 注册bean\n     * @param prefix 属性前缀\n     * @param configClass 待配置的config类\n     * @param multiple\n     * @param registry\n     */\n    private void registerDubboConfigBeans(String prefix,\n                                          Class<? extends AbstractConfig> configClass,\n                                          boolean multiple,\n                                          BeanDefinitionRegistry registry) {\n\n        /**\n         * @Configuration\n           @PropertySource(value = \"classpath:resources.properties\", ignoreResourceNotFound = false)\n           public class AppConfig { }\n         */\n        //根据prefix从配置文件中找到相关的属性值\n        //多bean绑定：\n        //prefix:\n        //  applications.prefix = dubbo.apps.\n        //properties:\n        //  applicationBean.name = dubbo-demo-application\n        //  applicationBean2.name = dubbo-demo-application2\n        //单bean绑定：prefix = dubbo.module.\n        //  dubbo.module.id = moduleBean  =>  id = moduleBean\n        //  dubbo.module.name = dubbo-demo-module => name = dubbo-demo-module\n        Map<String, String> properties = getSubProperties(environment.getPropertySources(), prefix);\n\n        //如果没有配置属性的话，则直接返回\n        if (CollectionUtils.isEmpty(properties)) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"There is no property for binding to dubbo config class [\" + configClass.getName()\n                        + \"] within prefix [\" + prefix + \"]\");\n            }\n            return;\n        }\n\n        //获取bean名称列表(即外部配置文件中配置的)\n        Set<String> beanNames = multiple ? resolveMultipleBeanNames(properties) :\n                Collections.singleton(resolveSingleBeanName(properties, configClass, registry));\n        //遍历bean名称列表\n        for (String beanName : beanNames) {\n            //最终注册bean的地方\n            registerDubboConfigBean(beanName, configClass, registry);\n            //注册DubboConfigBindingBeanPostProcessor类\n            registerDubboConfigBindingBeanPostProcessor(prefix, beanName, multiple, registry);\n        }\n    }\n\n    /**\n     * 使用beanName注册bean：configClass\n     * @param beanName\n     * @param configClass 配置类\n     * @param registry\n     */\n    private void registerDubboConfigBean(String beanName, Class<? extends AbstractConfig> configClass,\n                                         BeanDefinitionRegistry registry) {\n\n        BeanDefinitionBuilder builder = rootBeanDefinition(configClass);\n        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();\n        //使用beanName注册bean：configClass\n        registry.registerBeanDefinition(beanName, beanDefinition);\n        if (log.isInfoEnabled()) {\n            log.info(\"The dubbo config bean definition [name : \" + beanName + \", class : \" + configClass.getName() +\n                    \"] has been registered.\");\n        }\n    }\n\n    /**\n     * 注册DubboConfigBindingBeanPostProcessor类\n     * 用来处理dubbo config bean\n     * @param prefix  属性前缀\n     * @param beanName 已注册的config配置类的beanName\n     * @param multiple \n     * @param registry\n     */\n    private void registerDubboConfigBindingBeanPostProcessor(String prefix, String beanName, boolean multiple,\n                                                             BeanDefinitionRegistry registry) {\n\n        Class<?> processorClass = DubboConfigBindingBeanPostProcessor.class;\n        \n        BeanDefinitionBuilder builder = rootBeanDefinition(processorClass);\n        \n        //如果是multiple的话，则最终前缀：prefix+\".\"+beanName\n        //否则的话，最终前缀：prefix\n        String actualPrefix = multiple ? normalizePrefix(prefix) + beanName : prefix;\n        \n        //通过构造函数注入属性：prefix、beanName\n        builder.addConstructorArgValue(actualPrefix).addConstructorArgValue(beanName);\n        //获取beanDefinition\n        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();\n        //设置不可代理\n        beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n        //注册DubboConfigBindingBeanPostProcessor\n        registerWithGeneratedName(beanDefinition, registry);\n\n        if (log.isInfoEnabled()) {\n            log.info(\"The BeanPostProcessor bean definition [\" + processorClass.getName()\n                    + \"] for dubbo config bean [name : \" + beanName + \"] has been registered.\");\n        }\n    }\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        Assert.isInstanceOf(ConfigurableEnvironment.class, environment);\n        this.environment = (ConfigurableEnvironment) environment;\n    }\n\n    /**\n     * 处理多个bean名称\n     * @param properties 如：\n     *          applicationBean.name = dubbo-demo-application\n     *          applicationBean2.name = dubbo-demo-application2\n     * @return applicationBean、applicationBean2\n     */\n    private Set<String> resolveMultipleBeanNames(Map<String, String> properties) {\n        //保存已解决的beanNames\n        Set<String> beanNames = new LinkedHashSet<String>();\n        //遍历所有的属性名：applicationBean.name、applicationBean2.name\n        for (String propertyName : properties.keySet()) {\n            //获取\".\"符号在属性名中第一次出现的位置\n            //即判断是否存在\".\"\n            int index = propertyName.indexOf(\".\");\n            if (index > 0) {\n                //获取bean名称：applicationBean、applicationBean2\n                String beanName = propertyName.substring(0, index);\n                //保存bean名称\n                beanNames.add(beanName);\n            }\n        }\n        return beanNames;\n    }\n\n    /**\n     * 处理单个bean名称\n     * @param properties 如：\n     *      dubbo.module.id = moduleBean  =>  id = moduleBean\n     *      dubbo.module.name = dubbo-demo-module => name = dubbo-demo-module\n     * @param configClass dubbo配置类\n     * @param registry\n     * @return\n     */\n    private String resolveSingleBeanName(Map<String, String> properties,\n                                         Class<? extends AbstractConfig> configClass,\n                                         BeanDefinitionRegistry registry) {\n        //获取id属性作为bean的名称\n        String beanName = properties.get(\"id\");\n        if (!StringUtils.hasText(beanName)) {\n            //id属性为空的话\n            BeanDefinitionBuilder builder = rootBeanDefinition(configClass);\n            //则使用工具类生成bean名称\n            beanName = BeanDefinitionReaderUtils.generateBeanName(\n                    builder.getRawBeanDefinition(), registry\n            );\n        }\n        return beanName;\n    }\n}\n```\n可以看到，为每个注册的Config-bean都注册了一个DubboConfigBindingBeanPostProcessor类，现在我们看下DubboConfigBindingBeanPostProcessor类，该类实现了BeanPostProcessor接口,\n实现该接口，可以在bean实例化前后，增加一些自己的逻辑处理，同时也实现了InitializingBean接口.\n```java\n/**\n * Dubbo Config Binding {@link BeanPostProcessor}\n *\n * @see EnableDubboConfigBinding\n * @see DubboConfigBindingRegistrar\n * @since 2.5.8\n */\npublic class DubboConfigBindingBeanPostProcessor implements BeanPostProcessor, ApplicationContextAware, InitializingBean {\n\n    /**\n     * 配置属性的前缀\n     */\n    private final String prefix;\n\n    /**\n     * 绑定的Config配置类的beanName\n     */\n    private final String beanName;\n\n    private DubboConfigBinder dubboConfigBinder;\n\n    private ApplicationContext applicationContext;\n\n    /**\n     * 是否忽略未知字段\n     */\n    private boolean ignoreUnknownFields = true;\n\n    /**\n     * 是否忽略无效字段\n     */\n    private boolean ignoreInvalidFields = true;\n\n    /**\n     * @param prefix   配置属性的前缀\n     * @param beanName 绑定的Config配置类的beanName\n     */\n    public DubboConfigBindingBeanPostProcessor(String prefix, String beanName) {\n        Assert.notNull(prefix, \"The prefix of Configuration Properties must not be null\");\n        Assert.notNull(beanName, \"The name of bean must not be null\");\n        this.prefix = prefix;\n        this.beanName = beanName;\n    }\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        //如果当前实例化的bean的beanName和该处理器保存的beanName相同的话,说明是该实例化bean对应的处理器\n        //这个在之前介绍DubboConfigBindingRegistrar类时有介绍\n        if (beanName.equals(this.beanName) && bean instanceof AbstractConfig) {\n            AbstractConfig dubboConfig = (AbstractConfig) bean;\n            //通过prefix绑定beanName的属性\n            dubboConfigBinder.bind(prefix, dubboConfig);\n            if (log.isInfoEnabled()) {\n                log.info(\"The properties of bean [name : \" + beanName + \"] have been binding by prefix of \" +\n                        \"configuration properties : \" + prefix);\n            }\n        }\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        return bean;\n    }\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        if (dubboConfigBinder == null) {\n            try {\n                //先从BeanFactory中获取DubboConfigBinder实例\n                dubboConfigBinder = applicationContext.getBean(DubboConfigBinder.class);\n            } catch (BeansException ignored) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"DubboConfigBinder Bean can't be found in ApplicationContext.\");\n                }\n                //使用默认实现\n                dubboConfigBinder = createDubboConfigBinder(applicationContext.getEnvironment());\n            }\n        }\n        //设置是否忽略未知字段、无效字段\n        dubboConfigBinder.setIgnoreUnknownFields(ignoreUnknownFields);\n        dubboConfigBinder.setIgnoreInvalidFields(ignoreInvalidFields);\n    }\n\n    /**\n     * 创建DubboConfigBinder实例(默认实现)\n     * @param environment\n     * @return {@link DefaultDubboConfigBinder}\n     */\n    protected DubboConfigBinder createDubboConfigBinder(Environment environment) {\n        DefaultDubboConfigBinder defaultDubboConfigBinder = new DefaultDubboConfigBinder();\n        defaultDubboConfigBinder.setEnvironment(environment);\n        return defaultDubboConfigBinder;\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        this.applicationContext = applicationContext;\n    }\n}\n```\n然后我们看下使用到的DubboConfigBinder接口\n```java\npublic interface DubboConfigBinder extends EnvironmentAware {\n    /**\n     * 设置是否忽略未知字段，即是否忽略在目标对象中没有相应字段的绑定参数。默认值是“true”\n     * 设置为false，可以强制所有的绑定的参数在目标对象中必须有一个相应的字段\n     *\n     * Set whether to ignore unknown fields, that is, whether to ignore bind\n     * parameters that do not have corresponding fields in the target object.\n     * <p>Default is \"true\". Turn this off to enforce that all bind parameters\n     * must have a matching field in the target object.\n     * @see #bind\n     */\n    void setIgnoreUnknownFields(boolean ignoreUnknownFields);\n\n    /**\n     * 是否忽略无效字段，即是否忽略在目标对象中存在相应字段，但是不可访问的绑定参数\n     * 默认为“false”\n     * Set whether to ignore invalid fields, that is, whether to ignore bind\n     * parameters that have corresponding fields in the target object which are\n     * not accessible (for example because of null values in the nested path).\n     * <p>Default is \"false\".\n     *\n     * @see #bind\n     */\n    void setIgnoreInvalidFields(boolean ignoreInvalidFields);\n\n    /**\n     * 以指定的前缀绑定相关属性到Dubbo配置对象中\n     * Bind the properties to Dubbo Config Object under specified prefix.\n     *\n     * @param prefix 属性前缀\n     * @param dubboConfig dubboConfig配置类实例\n     */\n    <C extends AbstractConfig> void bind(String prefix, C dubboConfig);\n}\n\n//抽象类\npublic abstract class AbstractDubboConfigBinder implements DubboConfigBinder {\n\n    /**\n     * 属性配置\n     */\n    private Iterable<PropertySource<?>> propertySources;\n\n    private boolean ignoreUnknownFields = true;\n\n    private boolean ignoreInvalidFields = false;\n\n    /**\n     * 获取多个PropertySource\n     */\n    protected Iterable<PropertySource<?>> getPropertySources() {\n        return propertySources;\n    }\n\n    public boolean isIgnoreUnknownFields() {\n        return ignoreUnknownFields;\n    }\n\n    @Override\n    public void setIgnoreUnknownFields(boolean ignoreUnknownFields) {\n        this.ignoreUnknownFields = ignoreUnknownFields;\n    }\n\n    public boolean isIgnoreInvalidFields() {\n        return ignoreInvalidFields;\n    }\n\n    @Override\n    public void setIgnoreInvalidFields(boolean ignoreInvalidFields) {\n        this.ignoreInvalidFields = ignoreInvalidFields;\n    }\n\n    @Override\n    public final void setEnvironment(Environment environment) {\n        if (environment instanceof ConfigurableEnvironment) {\n            //从environment中获取propertySources\n            this.propertySources = ((ConfigurableEnvironment) environment).getPropertySources();\n        }\n    }\n}\n\n\n/**\n * 默认实现 基于Spring的DataBinder\n */\npublic class DefaultDubboConfigBinder extends AbstractDubboConfigBinder {\n\n    @Override\n    public <C extends AbstractConfig> void bind(String prefix, C dubboConfig) {\n        //创建DataBinder实例，绑定dubboConfig配置类\n        DataBinder dataBinder = new DataBinder(dubboConfig);\n        // Set ignored*\n        //设置是否忽略无效字段、未知字段\n        dataBinder.setIgnoreInvalidFields(isIgnoreInvalidFields());\n        dataBinder.setIgnoreUnknownFields(isIgnoreUnknownFields());\n        //从PropertySources中获取指定前缀的属性\n        Map<String, String> properties = getSubProperties(getPropertySources(), prefix);\n        //将Map转换成MutablePropertyValues对象\n        MutablePropertyValues propertyValues = new MutablePropertyValues(properties);\n        // 进行绑定\n        dataBinder.bind(propertyValues);\n    }\n}\n```\n然后看下工具类PropertySourcesUtils中的getSubProperties方法：\n```java\n/**\n * 根据属性前缀，获取所有相关的属性和属性值\n * Get Sub {@link Properties}\n * @param propertySources {@link PropertySource} Iterable\n * @param prefix          the prefix of property name\n * @return Map<String,String>\n * @see Properties\n*/\npublic static Map<String, String> getSubProperties(Iterable<PropertySource<?>> propertySources, String prefix) {\n\tMap<String, String> subProperties = new LinkedHashMap<String, String>();\n\t//规范化前缀,即前缀结尾处补上\".\"符号\n\tString normalizedPrefix = normalizePrefix(prefix);\n\t//遍历每一个PropertySource\n\tfor (PropertySource<?> source : propertySources) {\n\t    if (source instanceof EnumerablePropertySource) {\n\t\t//遍历属性名称列表，找到以normalizedPrefix开头的属性名称\n\t\t//applications.prefix = dubbo.apps.\n\t\t//dubbo.apps.applicationBean.name = dubbo-demo-application\n\t\t//dubbo.apps.applicationBean2.name = dubbo-demo-application2\n\n\t\tfor (String name : ((EnumerablePropertySource<?>) source).getPropertyNames()) {\n\t\t    if (name.startsWith(normalizedPrefix)) {\n\t\t\t//截取子名称，如：subName = applicationBean.name/applicationBean2.name\n\t\t\tString subName = name.substring(normalizedPrefix.length());\n\t\t\t//更加属性名称name获取属性值value\n\t\t\tObject value = source.getProperty(name);\n\t\t\t//保存applicationBean.name = dubbo-demo-application\n\t\t\t//保存applicationBean2.name = dubbo-demo-application2\n\t\t\tsubProperties.put(subName, String.valueOf(value));\n\t\t    }\n\t\t}\n\t    }\n\t}\n\treturn subProperties;\n}\n```\n\n##### @EnableDubboConfigBindings注解\n该注解支持配置多个@EnableDubboConfigBinding注解\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Import(DubboConfigBindingsRegistrar.class)\npublic @interface EnableDubboConfigBindings {\n    /**\n     * The value of {@link EnableDubboConfigBindings}\n     * @return non-null\n     */\n    EnableDubboConfigBinding[] value();\n}\n\n\npublic class DubboConfigBindingsRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware {\n\n    private ConfigurableEnvironment environment;\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n\n        //获取@EnableDubboConfigBindings注解的属性值\n        AnnotationAttributes attributes = AnnotationAttributes.fromMap(\n                importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBindings.class.getName()));\n\n        AnnotationAttributes[] annotationAttributes = attributes.getAnnotationArray(\"value\");\n\n        //构造DubboConfigBindingRegistrar对象\n        DubboConfigBindingRegistrar registrar = new DubboConfigBindingRegistrar();\n        registrar.setEnvironment(environment);\n        //遍历@EnableDubboConfigBinding列表,处理每一个@EnableDubboConfigBinding注解\n        for (AnnotationAttributes element : annotationAttributes) {\n            //注册DubboConfigBindingRegistrar类\n            registrar.registerBeanDefinitions(element, registry);\n        }\n    }\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        Assert.isInstanceOf(ConfigurableEnvironment.class, environment);\n        this.environment = (ConfigurableEnvironment) environment;\n    }\n}\n```\n简单看下使用:\n```java\n//将以下内容的外部化配置文件物理路径为：classpath:/META-INF/bindings.properties\n# classpath:/META-INF/bindings.properties\n## 占位符值 : ApplicationConfig 外部配置属性前缀\napplications.prefix = dubbo.apps.\n\n## 多 ApplicationConfig Bean 绑定\ndubbo.apps.applicationBean.name = dubbo-demo-application\ndubbo.apps.applicationBean2.name = dubbo-demo-application2\ndubbo.apps.applicationBean3.name = dubbo-demo-application3\n\n## 单 ModuleConfig Bean 绑定\ndubbo.module.id = moduleBean\ndubbo.module.name = dubbo-demo-module\n\n## 单 RegistryConfig Bean 绑定\ndubbo.registry.address = zookeeper://192.168.99.100:32770\n\n\n/**\n * 新建一个DubboConfiguration类作为Dubbo配置Bean，添加@EnableDubboConfigBinding注解进行绑定\n * 然后配置@PropertySource注解指定外部配置文件\n */\n@EnableDubboConfigBindings({\n@EnableDubboConfigBinding(prefix = \"${applications.prefix}\",\n               type = ApplicationConfig.class, multiple = true), //多ApplicationConfig Bean绑定\n@EnableDubboConfigBinding(prefix = \"dubbo.module\", //不带\".\"后缀\n               type = ModuleConfig.class), //单ModuleConfig Bean绑定\n@EnableDubboConfigBinding(prefix = \"dubbo.registry.\", //带\".\"后缀\n               type = RegistryConfig.class) //单RegistryConfig Bean绑定\n})\n@PropertySource(\"META-INF/bindings.properties\")\n@Configuration\npublic class DubboConfiguration {\n\n}\n\n//新建测试类\npublic class DubboConfigurationBootstrap {\n\n\tpublic static void main(String[] args) {\n\t\t//创建配置上下文\n\t\tAnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\n\t\t//注册当前配置 Bean\n\t\tcontext.register(DubboConfiguration.class);\n\t\tcontext.refresh();\n\n\t\t//获取ApplicationConfig Bean：\"applicationBean\"、\"applicationBean2\" 和 \"applicationBean3\"\n\t\tApplicationConfig applicationBean = context.getBean(\"applicationBean\", ApplicationConfig.class);\n\t\tApplicationConfig applicationBean2 = context.getBean(\"applicationBean2\", ApplicationConfig.class);\n\t\tApplicationConfig applicationBean3 = context.getBean(\"applicationBean3\", ApplicationConfig.class);\n\t\t\n\t\t//applicationBean.name = dubbo-demo-application \n\t\t//applicationBean2.name = dubbo-demo-application2 \n\t\tcapplicationBean3.name = dubbo-demo-application3 \n\t\tSystem.out.printf(\"applicationBean.name = %s \\n\", applicationBean.getName());\n\t\tSystem.out.printf(\"applicationBean2.name = %s \\n\", applicationBean2.getName());\n\t\tSystem.out.printf(\"applicationBean3.name = %s \\n\", applicationBean3.getName());\n\n\t\t//获取ModuleConfig Bean：\"moduleBean\"\n\t\tModuleConfig moduleBean = context.getBean(\"moduleBean\", ModuleConfig.class);\n\t\t//moduleBean.name = dubbo-demo-module \n\t\tSystem.out.printf(\"moduleBean.name = %s \\n\", moduleBean.getName()); \n\n\t\t//获取RegistryConfig Bean\n\t\tRegistryConfig registry = context.getBean(RegistryConfig.class);\n\t\t//registry.address = zookeeper://192.168.99.100:32770 \n\t\tSystem.out.printf(\"registry.address = %s \\n\", registry.getAddress());\n\t}\n}\n```\n\n#### @EnableDubbo注解\n该注解等同于组合使用@DubboComponentScan和@EnableDubboConfig，上文已经介绍过，这里就不多介绍了。\n```java\n/**\n * 启用Dubbo组件作为SpringBean\n * 等同于组合使用@DubboComponentScan和@EnableDubboConfig\n */\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\n@EnableDubboConfig\n@DubboComponentScan\npublic @interface EnableDubbo {\n\n    /**\n     * 扫描@Service基础包路径\n     * Base packages to scan for annotated @Service classes.\n     * <p>\n     * Use {@link #scanBasePackageClasses()} for a type-safe alternative to String-based\n     * package names.\n     *\n     * @return the base packages to scan\n     * @see DubboComponentScan#basePackages()\n     */\n    @AliasFor(annotation = DubboComponentScan.class, attribute = \"basePackages\")\n    String[] scanBasePackages() default {};\n\n    /**\n     * Type-safe alternative to {@link #scanBasePackages()} for specifying the packages to\n     * scan for annotated @Service classes. The package of each class specified will be\n     * scanned.\n     *\n     * @return classes from the base packages to scan\n     * @see DubboComponentScan#basePackageClasses\n     */\n    @AliasFor(annotation = DubboComponentScan.class, attribute = \"basePackageClasses\")\n    Class<?>[] scanBasePackageClasses() default {};\n\n\n    /**\n     *\n     * It indicates whether {@link AbstractConfig} binding to multiple Spring Beans.\n     *\n     * @return the default value is <code>false</code>\n     * @see EnableDubboConfig#multiple()\n     */\n    @AliasFor(annotation = EnableDubboConfig.class, attribute = \"multiple\")\n    boolean multipleConfig() default false;\n}\n```\n\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之集成Spring注解解析(0202)","url":"/blog/2018/08/07/Dubbo源码阅读之集成Spring-0202注解解析/","content":">本小节将会介绍ReferenceAnnotationBeanPostProcessor类的实现\n\n### ReferenceAnnotationBeanPostProcessor类\n该类用来处理@Reference注解，它实现了BeanPostProcessor接口,实现postProcessPropertyValues方法可以处理每一个属性\n```java\npublic class ReferenceAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter\n        implements MergedBeanDefinitionPostProcessor, PriorityOrdered, ApplicationContextAware,BeanClassLoaderAware, DisposableBean {\n\n    /**\n     * ReferenceAnnotationBeanPostProcessor的bean-name\n     */\n    public static final String BEAN_NAME = \"referenceAnnotationBeanPostProcessor\";\n\n    private ApplicationContext applicationContext;\n\n    private ClassLoader classLoader;\n\n    /**\n     * beanName/className,ReferenceInjectionMetadata\n     */\n    private final ConcurrentMap<String, ReferenceInjectionMetadata> injectionMetadataCache =\n            new ConcurrentHashMap<String, ReferenceInjectionMetadata>(256);\n\n    /**\n     * cacheKey,referenceBean\n     */\n    private final ConcurrentMap<String, ReferenceBean<?>> referenceBeansCache =\n            new ConcurrentHashMap<String, ReferenceBean<?>>();\n\n    /**\n     * 设置某个属性时调用\n     * @param pvs\n     * @param pds\n     * @param bean\n     * @param beanName\n     * @return\n     * @throws BeanCreationException\n     */\n    @Override\n    public PropertyValues postProcessPropertyValues(\n            PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeanCreationException {\n        //获取bean的@Reference元数据信息\n        InjectionMetadata metadata = findReferenceMetadata(beanName, bean.getClass(), pvs);\n        try {\n            //对Bean的属性进行自动注入\n            //最终会调用内部类ReferenceFieldElement和ReferenceMethodElement的inject方法(后面会介绍)\n            metadata.inject(bean, beanName, pvs);\n        } catch (BeanCreationException ex) {\n            throw ex;\n        } catch (Throwable ex) {\n            throw new BeanCreationException(beanName, \"Injection of @Reference dependencies failed\", ex);\n        }\n        return pvs;\n    }\n\n    /**\n     * 获取clazz的@Reference元数据信息\n     * @param beanName 当前bean的名称\n     * @param clazz    当前bean的class\n     * @param pvs      当前bean的属性\n     * @return\n     */\n    private InjectionMetadata findReferenceMetadata(String beanName, Class<?> clazz, PropertyValues pvs) {\n        // Fall back to class name as cache key, for backwards compatibility with custom callers.\n        //使用beanName或者当前bean的类名称作为cacheKey\n        String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());\n        // 先从缓存中查询该cacheKey\n        ReferenceInjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);\n        //是否需要刷新(metadata == null || metadata.targetClass != clazz;则需要刷新)\n        if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n            synchronized (this.injectionMetadataCache) {\n                metadata = this.injectionMetadataCache.get(cacheKey);\n                if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n                    if (metadata != null) {\n                        metadata.clear(pvs);\n                    }\n                    try {\n                        //获取clazz中被@Reference注解标注的元数据信息(字段、方法)\n                        metadata = buildReferenceMetadata(clazz);\n                        //放入缓存\n                        this.injectionMetadataCache.put(cacheKey, metadata);\n                    } catch (NoClassDefFoundError err) {\n                        throw new IllegalStateException(\"Failed to introspect bean class [\" + clazz.getName() +\n                                \"] for reference metadata: could not find class that it depends on\", err);\n                    }\n                }\n            }\n        }\n        return metadata;\n    }\n\n    /**\n     * 获取beanClass类中被@Reference注解标注的方法和字段\n     * @param beanClass\n     * @return\n     */\n    private ReferenceInjectionMetadata buildReferenceMetadata(final Class<?> beanClass) {\n        //查到beanClass中存在@Reference注解的字段\n        Collection<ReferenceFieldElement> fieldElements = findFieldReferenceMetadata(beanClass);\n        //查到beanClass中存在@Reference注解的方法\n        Collection<ReferenceMethodElement> methodElements = findMethodReferenceMetadata(beanClass);\n        //创建新的元数据信息\n        return new ReferenceInjectionMetadata(beanClass, fieldElements, methodElements);\n    }\n\n\n    /**\n     * 从给定的类中查询到所有标注@Reference注解的字段\n     * 然后根据该字段和@Reference注解\n     * 创建ReferenceFieldElement类(InjectionMetadata.InjectedElement的子类)\n     * @param beanClass 当前bean的class\n     * @return non-null\n     */\n    private List<ReferenceFieldElement> findFieldReferenceMetadata(final Class<?> beanClass) {\n\n        final List<ReferenceFieldElement> elements = new LinkedList<ReferenceFieldElement>();\n        //操作字段时执行的回调\n        ReflectionUtils.doWithFields(beanClass, new ReflectionUtils.FieldCallback() {\n            @Override\n            public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException {\n                //获取字段上的@Reference注解\n                Reference reference = getAnnotation(field, Reference.class);\n                //是否存在@Reference注解\n                if (reference != null) {\n                    if (Modifier.isStatic(field.getModifiers())) {\n                        if (logger.isWarnEnabled()) {\n                            //@Reference不支持静态字段字段\n                            logger.warn(\"@Reference annotation is not supported on static fields: \" + field);\n                        }\n                        return;\n                    }\n                    //根据字段和@Reference注解创建ReferenceFieldElement对象,并保存\n                    elements.add(new ReferenceFieldElement(field, reference));\n                }\n            }\n        });\n        return elements;\n    }\n\n    /**\n     * 从标注@Reference注解的方法上找到（InjectionMetadata.InjectedElement）元数据\n     * @param beanClass 目标bean的class\n     * @return non-null {@link List}\n     */\n    private List<ReferenceMethodElement> findMethodReferenceMetadata(final Class<?> beanClass) {\n\n        final List<ReferenceMethodElement> elements = new LinkedList<ReferenceMethodElement>();\n\n        //操作方法时调用\n        ReflectionUtils.doWithMethods(beanClass, new ReflectionUtils.MethodCallback() {\n            @Override\n            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {\n\n                //获取桥接方法(https://blog.csdn.net/mhmyqn/article/details/47342577)\n                Method bridgedMethod = findBridgedMethod(method);\n\n                //参数和返回类型签名相同返回true\n                if (!isVisibilityBridgeMethodPair(method, bridgedMethod)) {\n                    return;\n                }\n                //从桥接方法上找到@Reference注解\n                Reference reference = findAnnotation(bridgedMethod, Reference.class);\n\n                //ClassUtils.getMostSpecificMethod\n                //通过给定的方法(可能来自接口)和当前反射调用中使用的目标类,找到相应的目标方法\n                if (reference != null && method.equals(ClassUtils.getMostSpecificMethod(method, beanClass))) {\n                    if (Modifier.isStatic(method.getModifiers())) {\n                        if (logger.isWarnEnabled()) {\n                            //@Reference不支持static方法\n                            logger.warn(\"@Reference annotation is not supported on static methods: \" + method);\n                        }\n                        return;\n                    }\n                    if (method.getParameterTypes().length == 0) {\n                        //@Reference注解只能用于带参数的方法\n                        if (logger.isWarnEnabled()) {\n                            logger.warn(\"@Reference  annotation should only be used on methods with parameters: \" +\n                                    method);\n                        }\n                    }\n                    //获取bridgedMethod方法的属性描述\n                    PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, beanClass);\n                    //创建ReferenceMethodElement对象，并保存\n                    elements.add(new ReferenceMethodElement(method, pd, reference));\n                }\n            }\n        });\n        return elements;\n    }\n\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        this.applicationContext = applicationContext;\n    }\n\n    @Override\n    public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {\n        if (beanType != null) {\n            InjectionMetadata metadata = findReferenceMetadata(beanName, beanType, null);\n            metadata.checkConfigMembers(beanDefinition);\n        }\n    }\n\n    @Override\n    public int getOrder() {\n        return LOWEST_PRECEDENCE;\n    }\n\n    @Override\n    public void destroy() throws Exception {\n\n        for (ReferenceBean referenceBean : referenceBeansCache.values()) {\n            if (logger.isInfoEnabled()) {\n                logger.info(referenceBean + \" was destroying!\");\n            }\n            //销毁referenceBean\n            referenceBean.destroy();\n        }\n        //清空injectionMetadataCache/referenceBeansCache\n        injectionMetadataCache.clear();\n        referenceBeansCache.clear();\n\n        if (logger.isInfoEnabled()) {\n            logger.info(getClass() + \" was destroying!\");\n        }\n    }\n\n    @Override\n    public void setBeanClassLoader(ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    /**\n     * 获取所有的ReferenceBean\n     * @return non-null {@link Collection}\n     * @since 2.5.9\n     */\n    public Collection<ReferenceBean<?>> getReferenceBeans() {\n        return this.referenceBeansCache.values();\n    }\n```\n##### ReferenceInjectionMetadata内部类\n```java\n    /**\n     * {@link Reference} {@link InjectionMetadata} implementation\n     *\n     * @since 2.5.11\n     */\n    private static class ReferenceInjectionMetadata extends InjectionMetadata {\n\n        private final Collection<ReferenceFieldElement> fieldElements;\n\n        private final Collection<ReferenceMethodElement> methodElements;\n\n        /**\n         * @param targetClass 目标类\n         * @param fieldElements 存在@Reference注解的字段\n         * @param methodElements 存在@Reference注解的方法\n         */\n        public ReferenceInjectionMetadata(Class<?> targetClass, Collection<ReferenceFieldElement> fieldElements,\n                                          Collection<ReferenceMethodElement> methodElements) {\n            super(targetClass, combine(fieldElements, methodElements));\n            this.fieldElements = fieldElements;\n            this.methodElements = methodElements;\n        }\n\n        /**\n         * 将fieldElements和methodElements进行合并\n         * @param elements\n         * @param <T>\n         * @return\n         */\n        private static <T> Collection<T> combine(Collection<? extends T>... elements) {\n            List<T> allElements = new ArrayList<T>();\n            for (Collection<? extends T> e : elements) {\n                allElements.addAll(e);\n            }\n            return allElements;\n        }\n\n        public Collection<ReferenceFieldElement> getFieldElements() {\n            return fieldElements;\n        }\n\n        public Collection<ReferenceMethodElement> getMethodElements() {\n            return methodElements;\n        }\n    }\n```\n\n##### ReferenceMethodElement内部类\n```java\n   /**\n     * 内部类，方法元数据，最终会调用该类的inject方法进行注入\n     */\n    private class ReferenceMethodElement extends InjectionMetadata.InjectedElement {\n\n        /**\n         * 标注@Reference注解的方法\n         */\n        private final Method method;\n\n        private final Reference reference;\n\t\n\t/**\n\t * 新生成的referenceBean\n\t */\n        private volatile ReferenceBean<?> referenceBean;\n\n        /**\n         * @param method\n         * @param pd 方法属性描述符\n         * @param reference\n         */\n        protected ReferenceMethodElement(Method method, PropertyDescriptor pd, Reference reference) {\n            super(method, pd);\n            this.method = method;\n            this.reference = reference;\n        }\n\n        @Override\n        protected void inject(Object bean, String beanName, PropertyValues pvs) throws Throwable {\n            //获取referenceClass\n            Class<?> referenceClass = pd.getPropertyType();\n            //获取referenceClass对应的referenceBean\n            referenceBean = buildReferenceBean(reference, referenceClass);\n\n            ReflectionUtils.makeAccessible(method);\n            //调用bean的method，注入依赖\n            method.invoke(bean, referenceBean.getObject());\n        }\n    }\n```\n##### ReferenceFieldElement内部类\n```java\n    /**\n     * 内部类，字段元数据，最终会调用该类的inject方法进行注入\n     */\n    private class ReferenceFieldElement extends InjectionMetadata.InjectedElement {\n        /**\n         * 标注@Reference注解的字段\n         */\n        private final Field field;\n\n        private final Reference reference;\n\n        private volatile ReferenceBean<?> referenceBean;\n\n        protected ReferenceFieldElement(Field field, Reference reference) {\n            super(field, null);\n            this.field = field;\n            this.reference = reference;\n        }\n\n        /**\n         * 注入\n         * @param bean  目标bean\n         * @param beanName 目标bean-name\n         * @param pvs\n         * @throws Throwable\n         */\n        @Override\n        protected void inject(Object bean, String beanName, PropertyValues pvs) throws Throwable {\n\n            //被@Reference注解标识的字段的类型\n            Class<?> referenceClass = field.getType();\n            //获取referenceClass对应的referenceBean\n            referenceBean = buildReferenceBean(reference, referenceClass);\n\n            ReflectionUtils.makeAccessible(field);\n            //注入依赖到目标bean中\n            field.set(bean, referenceBean.getObject());\n        }\n    }\n```\n##### buildReferenceBean方法\n```java\n    /**\n     * 根据@Reference注解和referenceClass生成ReferenceBean\n     * @param reference\n     * @param referenceClass 被@Reference注解标注的字段类型\n     * @return\n     * @throws Exception\n     */\n    private ReferenceBean<?> buildReferenceBean(Reference reference, Class<?> referenceClass) throws Exception {\n\n        //根据@Reference注解和referenceClass 生成缓存key\n        String referenceBeanCacheKey = generateReferenceBeanCacheKey(reference, referenceClass);\n\n        //先从缓存中获取ReferenceBean\n        ReferenceBean<?> referenceBean = referenceBeansCache.get(referenceBeanCacheKey);\n\n        if (referenceBean == null) {\n            //生成一个referenceBean并放入缓存(后面会分析该方法)\n            ReferenceBeanBuilder beanBuilder = ReferenceBeanBuilder\n                    .create(reference, classLoader, applicationContext)\n                    .interfaceClass(referenceClass);\n            referenceBean = beanBuilder.build();\n            referenceBeansCache.putIfAbsent(referenceBeanCacheKey, referenceBean);\n        }\n        return referenceBean;\n\n    }\n```\n```java\n    /**\n     * 为ReferenceBean创建一个缓存key\n     * @param reference {@link Reference}\n     * @param beanClass {@link Class}\n     * @return\n     */\n    private String generateReferenceBeanCacheKey(Reference reference, Class<?> beanClass) {\n        //获取接口名称(后面会分析该方法)\n        String interfaceName = resolveInterfaceName(reference, beanClass);\n        //生成缓存key\n        String key = reference.url() + \"/\" + interfaceName +\n                \"/\" + reference.version() +\n                \"/\" + reference.group();\n\n        Environment environment = applicationContext.getEnvironment();\n        //处理占位符\n        key = environment.resolvePlaceholders(key);\n        return key;\n    }\n\n    /**\n     * 获取接口名称interfaceName\n     * 先从@Reference注解属性找，找不到则取被注解的接口变量名称\n     * @param reference @Reference注解\n     * @param beanClass 被@Reference注解标注的类\n     * @return\n     * @throws IllegalStateException\n     */\n    private static String resolveInterfaceName(Reference reference, Class<?> beanClass)\n            throws IllegalStateException {\n\n        String interfaceName;\n        if (!\"\".equals(reference.interfaceName())) {\n            // @Reference注解的interfaceName属性不为空\n            interfaceName = reference.interfaceName();\n        } else if (!void.class.equals(reference.interfaceClass())) {\n            // @Reference注解的interfaceClass属性不为void\n            interfaceName = reference.interfaceClass().getName();\n        } else if (beanClass.isInterface()) {\n            // 被@Reference注解标注的类是接口类型\n            interfaceName = beanClass.getName();\n        } else {\n            //@Reference没有定义interfaceClass/interfaceName属性，beanClass不是一个接口\n            throw new IllegalStateException(\n                    \"The @Reference undefined interfaceClass or interfaceName, and the property type \"\n                            + beanClass.getName() + \" is not a interface.\");\n        }\n        return interfaceName;\n    }\n\n\n    /**\n     * 获取<field,ReferenceBean>\n     *\n     * @return non-null {@link Map}\n     * @since 2.5.11\n     */\n    public Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> getInjectedFieldReferenceBeanMap() {\n\n        Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> injectedElementReferenceBeanMap =\n                new LinkedHashMap<InjectionMetadata.InjectedElement, ReferenceBean<?>>();\n        for (ReferenceInjectionMetadata metadata : injectionMetadataCache.values()) {\n            Collection<ReferenceFieldElement> fieldElements = metadata.getFieldElements();\n            for (ReferenceFieldElement fieldElement : fieldElements) {\n                injectedElementReferenceBeanMap.put(fieldElement, fieldElement.referenceBean);\n            }\n        }\n        return injectedElementReferenceBeanMap;\n    }\n\n    /**\n     * 获取<方法，ReferenceBean>\n     * @return non-null {@link Map}\n     * @since 2.5.11\n     */\n    public Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> getInjectedMethodReferenceBeanMap() {\n\n        Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> injectedElementReferenceBeanMap =\n                new LinkedHashMap<InjectionMetadata.InjectedElement, ReferenceBean<?>>();\n\n        for (ReferenceInjectionMetadata metadata : injectionMetadataCache.values()) {\n            Collection<ReferenceMethodElement> methodElements = metadata.getMethodElements();\n            for (ReferenceMethodElement methodElement : methodElements) {\n                injectedElementReferenceBeanMap.put(methodElement, methodElement.referenceBean);\n            }\n        }\n        return injectedElementReferenceBeanMap;\n    }\n}\n```\n\n##### AbstractAnnotationConfigBeanBuilder类\n接下来我们看下ReferenceBean的创建\n\n```java\n//创建ReferenceBean\nReferenceBeanBuilder beanBuilder = ReferenceBeanBuilder\n          //create方法创建了ReferenceBeanBuilder实例\n\t  .create(reference, classLoader, applicationContext)\n\t  //设置referenceClass\n          .interfaceClass(referenceClass);\n//build方法创建ReferenceBean类\nReferenceBean<?> referenceBean = beanBuilder.build();\n```\n\n我们是通过ReferenceBeanBuilder类创建ReferenceBean的，而ReferenceBeanBuilder继承自AbstractAnnotationConfigBeanBuilder,\nAbstractAnnotationConfigBeanBuilder定义了创建配置bean的算法骨架(即build模板方法)，其他步骤都由子类ReferenceBeanBuilder负责实现。\n```java\n/**\n * Annotation bean配置构造器\n * Abstract Configurable {@link Annotation} Bean Builder\n * @since 2.5.7\n */\nabstract class AbstractAnnotationConfigBeanBuilder<A extends Annotation, B extends AbstractInterfaceConfig> {\n\n    protected final Log logger = LogFactory.getLog(getClass());\n\n    /**\n     * 注解\n     */\n    protected final A annotation;\n\n    protected final ApplicationContext applicationContext;\n\n    protected final ClassLoader classLoader;\n\n    protected Object bean;\n\n    /**\n     * 接口类\n     */\n    protected Class<?> interfaceClass;\n\n    protected AbstractAnnotationConfigBeanBuilder(A annotation, ClassLoader classLoader,\n                                                  ApplicationContext applicationContext) {\n        Assert.notNull(annotation, \"The Annotation must not be null!\");\n        Assert.notNull(classLoader, \"The ClassLoader must not be null!\");\n        Assert.notNull(applicationContext, \"The ApplicationContext must not be null!\");\n        this.annotation = annotation;\n        this.applicationContext = applicationContext;\n        this.classLoader = classLoader;\n    }\n\n    /**\n     * Build {@link B}\n     * @return non-null\n     * @throws Exception\n     */\n    public final B build() throws Exception {\n        //检测依赖\n        checkDependencies();\n        //构建B（子类实现）\n        B bean = doBuild();\n        //配置B\n        configureBean(bean);\n\n        if (logger.isInfoEnabled()) {\n            logger.info(bean + \" has been built.\");\n        }\n        return bean;\n\n    }\n\n    private void checkDependencies() {\n\n    }\n\n    /**\n     * Builds {@link B Bean}\n     *\n     * @return {@link B Bean}\n     */\n    protected abstract B doBuild();\n\n\n    protected void configureBean(B bean) throws Exception {\n\n        //子类实现\n        preConfigureBean(annotation, bean);\n\n        //配置RegistryConfig(即将RegistryConfig实例注入到B对象中)\n        configureRegistryConfigs(bean);\n\n        //配置MonitorConfig\n        configureMonitorConfig(bean);\n\n        //配置ApplicationConfig\n        configureApplicationConfig(bean);\n\n        //配置ModuleConfig\n        configureModuleConfig(bean);\n\n        //子类实现\n        postConfigureBean(annotation, bean);\n    }\n\n    protected abstract void preConfigureBean(A annotation, B bean) throws Exception;\n\n\n    /**\n     * 配置RegistryConfig\n     * @param bean\n     */\n    private void configureRegistryConfigs(B bean) {\n        //获取RegistryConfig的bean-names\n        String[] registryConfigBeanIds = resolveRegistryConfigBeanNames(annotation);\n        //根据bean-names从工厂中获取RegistryConfig实例\n        List<RegistryConfig> registryConfigs = getBeans(applicationContext, registryConfigBeanIds, RegistryConfig.class);\n        //将registryConfigs注入到B中\n        bean.setRegistries(registryConfigs);\n    }\n\n    /**\n     * 配置MonitorConfig\n     * @param bean\n     */\n    private void configureMonitorConfig(B bean) {\n        //获取MonitorConfig的bean-names\n        String monitorBeanName = resolveMonitorConfigBeanName(annotation);\n        //获取monitorConfig实例\n        MonitorConfig monitorConfig = getOptionalBean(applicationContext, monitorBeanName, MonitorConfig.class);\n        //将registryConfigs注入到B中\n        bean.setMonitor(monitorConfig);\n\n    }\n\n    /**\n     * 配置ApplicationConfig\n     * @param bean\n     */\n    private void configureApplicationConfig(B bean) {\n        //获取ApplicationConfig的bean-names\n        String applicationConfigBeanName = resolveApplicationConfigBeanName(annotation);\n\n        ApplicationConfig applicationConfig =\n                getOptionalBean(applicationContext, applicationConfigBeanName, ApplicationConfig.class);\n\n        bean.setApplication(applicationConfig);\n    }\n\n    /**\n     * 配置ModuleConfig\n     * @param bean\n     */\n    private void configureModuleConfig(B bean) {\n        //获取ModuleConfig的bean-names\n        String moduleConfigBeanName = resolveModuleConfigBeanName(annotation);\n\n        ModuleConfig moduleConfig =\n                getOptionalBean(applicationContext, moduleConfigBeanName, ModuleConfig.class);\n\n        bean.setModule(moduleConfig);\n\n    }\n\n    /**\n     * Resolves the bean name of {@link ModuleConfig}\n     *\n     * @param annotation {@link A}\n     * @return\n     */\n    protected abstract String resolveModuleConfigBeanName(A annotation);\n\n    /**\n     * Resolves the bean name of {@link ApplicationConfig}\n     *\n     * @param annotation {@link A}\n     * @return\n     */\n    protected abstract String resolveApplicationConfigBeanName(A annotation);\n\n\n    /**\n     * Resolves the bean ids of {@link com.alibaba.dubbo.config.RegistryConfig}\n     *\n     * @param annotation {@link A}\n     * @return non-empty array\n     */\n    protected abstract String[] resolveRegistryConfigBeanNames(A annotation);\n\n    /**\n     * Resolves the bean name of {@link MonitorConfig}\n     *\n     * @param annotation {@link A}\n     * @return\n     */\n    protected abstract String resolveMonitorConfigBeanName(A annotation);\n\n    /**\n     * Configures Bean\n     *\n     * @param annotation\n     * @param bean\n     */\n    protected abstract void postConfigureBean(A annotation, B bean) throws Exception;\n\n\n    public <T extends AbstractAnnotationConfigBeanBuilder<A, B>> T bean(Object bean) {\n        this.bean = bean;\n        return (T) this;\n    }\n\n    public <T extends AbstractAnnotationConfigBeanBuilder<A, B>> T interfaceClass(Class<?> interfaceClass) {\n        this.interfaceClass = interfaceClass;\n        return (T) this;\n    }\n}\n```\n##### ReferenceBeanBuilder实现类\n\n我们接下来看ReferenceBeanBuilder实现类\n```java\n/**\n * ReferenceBean 构造器\n */\nclass ReferenceBeanBuilder extends AbstractAnnotationConfigBeanBuilder<Reference, ReferenceBean> {\n\t\n    private ReferenceBeanBuilder(Reference annotation, ClassLoader classLoader, ApplicationContext applicationContext) {\n        super(annotation, classLoader, applicationContext);\n    }\n\n    /**\n     * 设置referenceBean实例的interfaceClass属性\n     * @param reference\n     * @param referenceBean\n     */\n    private void configureInterface(Reference reference, ReferenceBean referenceBean) {\n\n        //获取@Reference注解的interfaceClass属性\n        Class<?> interfaceClass = reference.interfaceClass();\n\n        if (void.class.equals(interfaceClass)) {\n            interfaceClass = null;\n            //interfaceClass属性没有配置,则取interfaceName属性\n            String interfaceClassName = reference.interfaceName();\n            if (StringUtils.hasText(interfaceClassName)) {\n                if (ClassUtils.isPresent(interfaceClassName, classLoader)) {\n                    //加载interfaceClassName类，作为interfaceClass\n                    interfaceClass = ClassUtils.resolveClassName(interfaceClassName, classLoader);\n                }\n            }\n        }\n        if (interfaceClass == null) {\n            //如果@Reference注解没有配置interfaceClass属性和interfaceName属性\n            //则使用创建对象时使用的interfaceClass\n            interfaceClass = this.interfaceClass;\n        }\n        //校验interfaceClass是接口类型\n        Assert.isTrue(interfaceClass.isInterface(),\n                \"The class of field or method that was annotated @Reference is not an interface!\");\n        //设置referenceBean对象的interfaceClass\n        referenceBean.setInterface(interfaceClass);\n    }\n\n\n    /**\n     * 设置referenceBean实例的consumer属性\n     * @param reference\n     * @param referenceBean\n     */\n    private void configureConsumerConfig(Reference reference, ReferenceBean<?> referenceBean) {\n        //获取@Reference注解的consumer属性\n        String consumerBeanName = reference.consumer();\n        //从工厂中获取ConsumerConfig实例\n        ConsumerConfig consumerConfig = getOptionalBean(applicationContext, consumerBeanName, ConsumerConfig.class);\n        //设置referenceBean实例的consumer属性\n        referenceBean.setConsumer(consumerConfig);\n    }\n\n    @Override\n    protected ReferenceBean doBuild() {\n        //创建ReferenceBean对象\n        return new ReferenceBean<Object>();\n    }\n\n    @Override\n    protected void preConfigureBean(Reference reference, ReferenceBean referenceBean) {\n        Assert.notNull(interfaceClass, \"The interface class must set first!\");\n\n        //根据referenceBean创建数据绑定对象\n        DataBinder dataBinder = new DataBinder(referenceBean);\n        //设置转换器\n        dataBinder.setConversionService(getConversionService());\n        //忽略的属性名称\n        String[] ignoreAttributeNames = of(\"application\", \"module\", \"consumer\", \"monitor\", \"registry\");\n        //dataBinder.setDisallowedFields(ignoreAttributeNames)\n        //绑定注解属性\n        dataBinder.bind(new AnnotationPropertyValuesAdapter(reference, applicationContext.getEnvironment(), ignoreAttributeNames));\n    }\n\n    /**\n     * 获取ConversionService\n     * @return\n     */\n    private ConversionService getConversionService() {\n        //创建默认转换器\n        DefaultConversionService conversionService = new DefaultConversionService();\n        //添加StringArray到String的转换\n        conversionService.addConverter(new StringArrayToStringConverter());\n        //添加StringArray到Map的转换\n        conversionService.addConverter(new StringArrayToMapConverter());\n        return conversionService;\n    }\n\n\n    @Override\n    protected String resolveModuleConfigBeanName(Reference annotation) {\n        //获取@Reference注解的module属性\n        return annotation.module();\n    }\n\n    @Override\n    protected String resolveApplicationConfigBeanName(Reference annotation) {\n        //获取@Reference注解的application属性\n        return annotation.application();\n    }\n\n    @Override\n    protected String[] resolveRegistryConfigBeanNames(Reference annotation) {\n        //获取@Reference注解的registry属性\n        return annotation.registry();\n    }\n\n    @Override\n    protected String resolveMonitorConfigBeanName(Reference annotation) {\n        //获取@Reference注解的monitor属性\n        return annotation.monitor();\n    }\n\n    @Override\n    protected void postConfigureBean(Reference annotation, ReferenceBean bean) throws Exception {\n\n        //设置applicationContext属性\n        bean.setApplicationContext(applicationContext);\n        //设置interfaceClass属性\n        configureInterface(annotation, bean);\n        //设置consumer属性\n        configureConsumerConfig(annotation, bean);\n        //属性都设置完了，开始调用bean的afterPropertiesSet方法(可见ReferenceBean实现了InitializingBean接口)\n        //在afterPropertiesSet()方法中会校验consumer/application/module/registry/monitor等属性是否为空，\n\t//为空的话,会从Spring容器中再次获取下,并重新赋值,然后会根据配置是否立即初始化该bean\n\tbean.afterPropertiesSet();\n    }\n\n    /**\n     * 创建ReferenceBeanBuilder实例\n     * @param annotation\n     * @param classLoader\n     * @param applicationContext\n     * @return\n     */\n    public static ReferenceBeanBuilder create(Reference annotation, ClassLoader classLoader,\n                                              ApplicationContext applicationContext) {\n        return new ReferenceBeanBuilder(annotation, classLoader, applicationContext);\n    }\n}\n```\n\n##### ReferenceBean类\n\n接下来来看ReferenceBean类,该类继承自ReferenceConfig类,并实现了FactoryBean接口。\n```java\n/**\n * ReferenceFactoryBean\n * @export\n */\npublic class ReferenceBean<T> extends ReferenceConfig<T> implements FactoryBean,\n        ApplicationContextAware, InitializingBean, DisposableBean {\n\n    private transient ApplicationContext applicationContext;\n\n    public ReferenceBean() {\n        super();\n    }\n\n    public ReferenceBean(Reference reference) {\n        //调用父类构造方法，在父类构造方法中会调用appendAnnotation方法处理@Reference注解的属性\n        super(reference);\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) {\n        this.applicationContext = applicationContext;\n        //将applicationContext添加到SpringExtensionFactory中\n        //SPI那一章节，我们介绍过SpringExtensionFactory类\n        SpringExtensionFactory.addApplicationContext(applicationContext);\n    }\n\n    @Override\n    public Object getObject() throws Exception {\n        //获取对象实例，调用父类中的get方法进行初始化\n        return get();\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        //调用父类中的getInterfaceClass方法获取对象类型(后面会分析该方法)\n        return getInterfaceClass();\n    }\n\n    @Override\n    @Parameter(excluded = true)\n    public boolean isSingleton() {\n        return true;\n    }\n\n    @Override\n    @SuppressWarnings({\"unchecked\"})\n    public void afterPropertiesSet() throws Exception {\n        //如果没有配置Consumer\n        if (getConsumer() == null) {\n            //获取IOC容器中的ConsumerConfig（只获取单例类型的）\n            Map<String, ConsumerConfig> consumerConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ConsumerConfig.class, false, false);\n            if (consumerConfigMap != null && consumerConfigMap.size() > 0) {\n                ConsumerConfig consumerConfig = null;\n                for (ConsumerConfig config : consumerConfigMap.values()) {\n                    //检查是否有重复的consumer配置(default属性)\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        if (consumerConfig != null) {\n                            throw new IllegalStateException(\"Duplicate consumer configs: \" + consumerConfig + \" and \" + config);\n                        }\n                        consumerConfig = config;\n                    }\n                }\n                if (consumerConfig != null) {\n                    //配置bean的consumer属性\n                    setConsumer(consumerConfig);\n                }\n            }\n        }\n        if (getApplication() == null\n                && (getConsumer() == null || getConsumer().getApplication() == null)) {\n            //从IOC容器中获取ApplicationConfig\n            Map<String, ApplicationConfig> applicationConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, false, false);\n            if (applicationConfigMap != null && applicationConfigMap.size() > 0) {\n                ApplicationConfig applicationConfig = null;\n                for (ApplicationConfig config : applicationConfigMap.values()) {\n                    //检测是否有重复的配置(default属性)\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        if (applicationConfig != null) {\n                            throw new IllegalStateException(\"Duplicate application configs: \" + applicationConfig + \" and \" + config);\n                        }\n                        applicationConfig = config;\n                    }\n                }\n                if (applicationConfig != null) {\n                    //设置bean的ApplicationConfig属性\n                    setApplication(applicationConfig);\n                }\n            }\n        }\n        if (getModule() == null\n                && (getConsumer() == null || getConsumer().getModule() == null)) {\n            //从IOC容器中获取ModuleConfig\n            Map<String, ModuleConfig> moduleConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, false, false);\n            if (moduleConfigMap != null && moduleConfigMap.size() > 0) {\n                ModuleConfig moduleConfig = null;\n                for (ModuleConfig config : moduleConfigMap.values()) {\n                    //检测是否有重复的moduleConfig\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        if (moduleConfig != null) {\n                            throw new IllegalStateException(\"Duplicate module configs: \" + moduleConfig + \" and \" + config);\n                        }\n                        moduleConfig = config;\n                    }\n                }\n                if (moduleConfig != null) {\n                    //设置module属性\n                    setModule(moduleConfig);\n                }\n            }\n        }\n        if ((getRegistries() == null || getRegistries().isEmpty())\n                && (getConsumer() == null || getConsumer().getRegistries() == null || getConsumer().getRegistries().isEmpty())\n                && (getApplication() == null || getApplication().getRegistries() == null || getApplication().getRegistries().isEmpty())) {\n            //从IOC容器中获取RegistryConfig\n            Map<String, RegistryConfig> registryConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, false, false);\n            if (registryConfigMap != null && registryConfigMap.size() > 0) {\n                List<RegistryConfig> registryConfigs = new ArrayList<RegistryConfig>();\n                        registryConfigs.add(config);\n                    }\n                }\n                if (registryConfigs != null && !registryConfigs.isEmpty()) {\n                    //设置registries属性\n                    super.setRegistries(registryConfigs);\n                }\n            }\n        }\n        if (getMonitor() == null\n                && (getConsumer() == null || getConsumer().getMonitor() == null)\n                && (getApplication() == null || getApplication().getMonitor() == null)) {\n            //从IOC容器中获取MonitorConfig\n            Map<String, MonitorConfig> monitorConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig.class, false, false);\n            if (monitorConfigMap != null && monitorConfigMap.size() > 0) {\n                MonitorConfig monitorConfig = null;\n                for (MonitorConfig config : monitorConfigMap.values()) {\n                    //检测是否有重复的MonitorConfig\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        if (monitorConfig != null) {\n                            throw new IllegalStateException(\"Duplicate monitor configs: \" + monitorConfig + \" and \" + config);\n                        }\n                        monitorConfig = config;\n                    }\n                }\n                if (monitorConfig != null) {\n                    //设置MonitorConfig属性\n                    setMonitor(monitorConfig);\n                }\n            }\n        }\n        //获取是否 立即初始化 属性init\n        Boolean b = isInit();\n        if (b == null && getConsumer() != null) {\n            //从ConsumerConfig属性中获取init\n            b = getConsumer().isInit();\n        }\n        if (b != null && b.booleanValue()) {\n            //执行初始化\n            getObject();\n        }\n    }\n\n    @Override\n    public void destroy() {\n        // do nothing\n    }\n}\n```\n接下来，我们来看下父类ReferenceConfig中的方法\n```java\n/**\n* 获取服务接口类\n* interfaceClass > GenericService.class > interfaceName\n* @return\n*/\npublic Class<?> getInterfaceClass() {\n\t//interfaceClass属性不为空，直接返回\n\tif (interfaceClass != null) {\n\t    return interfaceClass;\n\t}\n\t//Reference或者Consumer的generic属性为true，则使用GenericService类\n\tif (isGeneric()\n\t\t|| (getConsumer() != null && getConsumer().isGeneric())) {\n\t    return GenericService.class;\n\t}\n\ttry {\n\t    if (interfaceName != null && interfaceName.length() > 0) {\n\t\t//interfaceName属性不为空，加载该类\n\t\tthis.interfaceClass = Class.forName(interfaceName, true, Thread.currentThread()\n\t\t\t.getContextClassLoader());\n\t    }\n\t} catch (ClassNotFoundException t) {\n\t    throw new IllegalStateException(t.getMessage(), t);\n\t}\n\treturn interfaceClass;\n}\n\n\n/**\n * 是否已销毁\n */\nprivate transient volatile boolean destroyed;\n\n/**\n * 接口代理引用\n * interface proxy reference\n */\nprivate transient volatile T ref;\n\n\n/**\n * 获取接口代理引用\n */\npublic synchronized T get() {\n        //判断是否已经销毁\n        if (destroyed) {\n            throw new IllegalStateException(\"Already destroyed!\");\n        }\n        if (ref == null) {\n            //初始化\n            init();\n        }\n        return ref;\n}\n```\n\n#### init方法\n该init方法会生成接口代理引用ref。\n```java\npublic synchronized T get() {\n        //判断是否已经销毁\n        if (destroyed) {\n            throw new IllegalStateException(\"Already destroyed!\");\n        }\n        if (ref == null) {\n            //初始化\n            init();\n        }\n        return ref;\n}\n\nprivate void init() {\n\t//已经初始化过的话，则返回\n\tif (initialized) {\n\t    return;\n\t}\n\tinitialized = true;\n\t//检测是否配置了interface属性\n\tif (interfaceName == null || interfaceName.length() == 0) {\n\t    throw new IllegalStateException(\"<dubbo:reference interface=\\\"\\\" /> interface not allow null!\");\n\t}\n\t//获取Consumer的全局配置(设置ConsumerConfig对象的属性)(后面会分析该方法)\n\tcheckDefault();\n\t//加载当前ReferenceConfig对象(即ReferenceBean)的属性信息(后面会分析该方法)\n\tappendProperties(this);\n\t//当前ReferenceConfig没有配置generic属性的话，则使用Consumer的generic属性配置\n\tif (getGeneric() == null && getConsumer() != null) {\n\t    //设置generic属性\n\t    setGeneric(getConsumer().getGeneric());\n\t}\n\t//(generic ！= null) && (generic = “true” || \"nativejava\" || \"bean\") ProtocolUtils.isGeneric返回true\n\tif (ProtocolUtils.isGeneric(getGeneric())) {\n\t    //如果配置了使用通用接口，则设置服务接口类为GenericService类\n\t    interfaceClass = GenericService.class;\n\t} else {\n\t    //否则根据interfaceName加载服务接口类\n\t    try {\n\t\tinterfaceClass = Class.forName(interfaceName, true, Thread.currentThread()\n\t\t\t.getContextClassLoader());\n\t    } catch (ClassNotFoundException e) {\n\t\tthrow new IllegalStateException(e.getMessage(), e);\n\t    }\n\t    //检测methods方法是否都存在于接口服务类interfaceClass中(后面会分析该方法)\n\t    checkInterfaceAndMethods(interfaceClass, methods);\n\t}\n\t//1、根据服务接口名称从系统配置中查找resolve：即通过-DinterfaceName=resolve配置\n\t//2、resolve为空，则加载dubbo.resolve.file文件,从resolveFile中加载resolve\n\t//   a、从系统配置文件中加载resolve文件：即-Ddubbo.resolve.file=xxx配置\n\t//   b、使用dubbo的默认resolve文件：${user.home}/dubbo-resolve.properties\n\tString resolve = System.getProperty(interfaceName);\n\tString resolveFile = null;\n\tif (resolve == null || resolve.length() == 0) {\n\t    resolveFile = System.getProperty(\"dubbo.resolve.file\");\n\t    if (resolveFile == null || resolveFile.length() == 0) {\n\t\t//没有配置resolveFile的话，则使用dubbo默认的resolve文件\n\t\t//如：System.getProperty(\"user.home\") = C:\\Users\\Administrator\n\t\t//resolveFile = userResolveFile = C:\\Users\\Administrator\\dubbo-resolve.properties\n\t\tFile userResolveFile = new File(new File(System.getProperty(\"user.home\")), \"dubbo-resolve.properties\");\n\t\tif (userResolveFile.exists()) {\n\t\t    resolveFile = userResolveFile.getAbsolutePath();\n\t\t}\n\t    }\n\t    //加载resolveFile文件\n\t    if (resolveFile != null && resolveFile.length() > 0) {\n\t\tProperties properties = new Properties();\n\t\tFileInputStream fis = null;\n\t\ttry {\n\t\t    fis = new FileInputStream(new File(resolveFile));\n\t\t    properties.load(fis);\n\t\t} catch (IOException e) {\n\t\t    throw new IllegalStateException(\"Unload \" + resolveFile + \", cause: \" + e.getMessage(), e);\n\t\t} finally {\n\t\t    try {\n\t\t\tif (null != fis) {\n\t\t\t    fis.close();\n\t\t\t}\n\t\t    } catch (IOException e) {\n\t\t\tlogger.warn(e.getMessage(), e);\n\t\t    }\n\t\t}\n\t\t//从resolveFile配置文件中加载resolve\n\t\tresolve = properties.getProperty(interfaceName);\n\t    }\n\t}\n\tif (resolve != null && resolve.length() > 0) {\n\t    url = resolve;\n\t    if (logger.isWarnEnabled()) {\n\t\tif (resolveFile != null && resolveFile.length() > 0) {\n\t\t    //使用默认dubbo resolve file\n\t\t    logger.warn(\"Using default dubbo resolve file \" + resolveFile + \" replace \" + interfaceName + \"\" + resolve + \" to p2p invoke remote service.\");\n\t\t} else {\n\t\t    //可以使用-DinterfaceName=resolve配置p2p\n\t\t    logger.warn(\"Using -D\" + interfaceName + \"=\" + resolve + \" to p2p invoke remote service.\");\n\t\t}\n\t    }\n\t}\n\t//加载注册中心、监控中心优先级\n\t//consumer > module > application\n\tif (consumer != null) {\n\t    if (application == null) {\n\t\tapplication = consumer.getApplication();\n\t    }\n\t    if (module == null) {\n\t\tmodule = consumer.getModule();\n\t    }\n\t    if (registries == null) {\n\t\tregistries = consumer.getRegistries();\n\t    }\n\t    if (monitor == null) {\n\t\tmonitor = consumer.getMonitor();\n\t    }\n\t}\n\tif (module != null) {\n\t    if (registries == null) {\n\t\tregistries = module.getRegistries();\n\t    }\n\t    if (monitor == null) {\n\t\tmonitor = module.getMonitor();\n\t    }\n\t}\n\tif (application != null) {\n\t    //<dubbo:application name=\"demo-consumer\" qosPort=\"33333\" id=\"demo-consumer\" />\n\t    if (registries == null) {\n\t\tregistries = application.getRegistries();\n\t    }\n\t    if (monitor == null) {\n\t\tmonitor = application.getMonitor();\n\t    }\n\t}\n\t//检测Application配置(后面会分析该方法)\n\tcheckApplication();\n\t//检测Stub和Mock(后面会分析该方法)\n\tcheckStubAndMock(interfaceClass);\n\n\t//记录Consumer端的服务接口相关信息\n\tMap<String, String> map = new HashMap<String, String>();\n\t//保存方法属性的attributes\n\tMap<Object, Object> attributes = new HashMap<Object, Object>();\n\t//设置消费者端\n\tmap.put(Constants.SIDE_KEY, Constants.CONSUMER_SIDE);\n\t//设置dubbo版本\n\tmap.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());\n\t//设置时间戳\n\tmap.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n\tif (ConfigUtils.getPid() > 0) {\n\t    //设置父进程id\n\t    map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n\t}\n\tif (!isGeneric()) {\n\t    //不是通用泛型接口，则获取revision属性,默认等于version属性\n\t    String revision = Version.getVersion(interfaceClass, version);\n\t    if (revision != null && revision.length() > 0) {\n\t\tmap.put(\"revision\", revision);\n\t    }\n\t    //获取包装类，然后获取服务接口中的方法名称数组(后面会分析该方法)\n\t    String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();\n\t    if (methods.length == 0) {\n\t\t//在服务接口中，没有找到方法，则设置属性：methods = *\n\t\tlogger.warn(\"NO method found in service interface \" + interfaceClass.getName());\n\t\tmap.put(\"methods\", Constants.ANY_VALUE);\n\t    } else {\n\t\t//设置methods=逗号分隔的方法name\n\t\tmap.put(\"methods\", StringUtils.join(new HashSet<String>(Arrays.asList(methods)), \",\"));\n\t    }\n\t}\n\t//设置interface属性\n\tmap.put(Constants.INTERFACE_KEY, interfaceName);\n\t//添加附加参数(后面会分析该方法)\n\tappendParameters(map, application);\n\tappendParameters(map, module);\n\tappendParameters(map, consumer, Constants.DEFAULT_KEY);\n\tappendParameters(map, this);\n\t//获取服务前缀：group/interface:version\n\tString prefix = StringUtils.getServiceKey(map);\n\t//处理引用的方法列表\n\tif (methods != null && !methods.isEmpty()) {\n\t    for (MethodConfig method : methods) {\n\t\t//附加参数(后面会分析该方法)\n\t\tappendParameters(map, method, method.getName());\n\t\t//处理方法重试\n\t\tString retryKey = method.getName() + \".retry\";\n\t\tif (map.containsKey(retryKey)) {\n\t\t    //将属性retryKey从map中移除\n\t\t    String retryValue = map.remove(retryKey);\n\t\t    if (\"false\".equals(retryValue)) {\n\t\t\t//属性retryKey的值为false,则添加新的属性到map中(即禁用方法重试)\n\t\t\tmap.put(method.getName() + \".retries\", \"0\");\n\t\t    }\n\t\t}\n\t\t//附加属性(后面会分析该方法)\n\t\tappendAttributes(attributes, method, prefix + \".\" + method.getName());\n\t\t//attributes保存的是方法名，调用checkAndConvertImplicitConfig方法后将会保存Method实例\n\t\tcheckAndConvertImplicitConfig(method, map, attributes);\n\t    }\n\t}\n\t//从系统配置属性中获取：注册到注册中心的ip\n\tString hostToRegistry = ConfigUtils.getSystemProperty(Constants.DUBBO_IP_TO_REGISTRY);\n\tif (hostToRegistry == null || hostToRegistry.length() == 0) {\n\t    //获取本地地址,如：192.168.99.60\n\t    hostToRegistry = NetUtils.getLocalHost();\n\t} else if (isInvalidLocalHost(hostToRegistry)) {\n\t    //无效的地址\n\t    throw new IllegalArgumentException(\"Specified invalid registry ip from property:\" + Constants.DUBBO_IP_TO_REGISTRY + \", value:\" + hostToRegistry);\n\t}\n\t//设置属性：注册到注册中心的ip\n\tmap.put(Constants.REGISTER_IP_KEY, hostToRegistry);\n\n\t//保存方法属性到系统上下文中\n\tStaticContext.getSystemContext().putAll(attributes);\n\t\n\t//根据服务接口及其属性创建代理(后面会分析该方法)\n\tref = createProxy(map);\n\t\n\t//构造ConsumerModel对象,getUniqueServiceName()生成唯一服务名称\n\tConsumerModel consumerModel = new ConsumerModel(getUniqueServiceName(), this, ref, interfaceClass.getMethods());\n\t\n\t//根据服务名称注册消费者(后面会分析该方法)\n\tApplicationModel.initConsumerModel(getUniqueServiceName(), consumerModel);\n}\n```\n接下来，我们看上面使用到的方法\n\n##### checkDefault方法\n获取Consumer的全局配置\n```java\nprivate void checkDefault() {\n        if (consumer == null) {\n\t    //consumer为空，会新创建一个ConsumerConfig对象\n            consumer = new ConsumerConfig();\n        }\n\t//调用appendProperties方法\n        appendProperties(consumer);\n}\n```\n##### appendProperties方法\n该方法在init方法中大量出现，我们先看下它的实现，它是定义在AbstractConfig抽象类中的静态方法，参数是AbstractConfig类型。\n```java\n/**\n * 附加属性\n * 找到config的所有的setXXX方法，然后切割出属性XXX，然后从系统配置/dubbo配置文件中获取到属性的值，\n * 然后执行setXXX方法把属性值设置到config对象中\n * @param config\n */\nprotected static void appendProperties(AbstractConfig config) {\n\tif (config == null) {\n\t   //config为空，直接返回\n\t   return;\n\t}\n\t//生成前缀，如： dubbo.monitor.\n\tString prefix = \"dubbo.\" + getTagName(config.getClass()) + \".\";\n\t//获取config类的所有方法\n\tMethod[] methods = config.getClass().getMethods();\n\t//遍历方法列表\n\tfor (Method method : methods) {\n\t    try {\n\t\tString name = method.getName();\n\t\t//方法名长度>3，以set开头，修饰符是public，参数个数=1，参数类型是原始类型\n\t\tif (name.length() > 3 && name.startsWith(\"set\") && Modifier.isPublic(method.getModifiers())\n\t\t\t&& method.getParameterTypes().length == 1 && isPrimitive(method.getParameterTypes()[0])) {\n\t\t    //转换方法名称为属性名称，如：setFirstName将会转换成first.name\n\t\t    //例如：property = default\n\t\t    String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), \".\");\n\n\t\t    //1、从系统配置中获取：prefix + id + property\n\t\t    //2、从系统配置中获取：prefix + property\n\t\t    //3、从config类中找到属性get方法或者is方法，然后执行该方法\n\t\t\t//3.1、从config配置中获取 prefix + id + property属性\n\t\t\t//3.2、从config配置中获取 prefix + property属性\n\t\t\t//3.3、根据prefix + property获取旧版属性legacyKey,然后根据legacyKey从config配置中获取\n\t\t    //ConfigUtils.getProperty(后面会分析该方法)\n\t\t    //如果属性值value不为空的话，则调用该set方法，将属性设置到config对象中，整个方法流程执行结束\n\t\t\t\n\t\t    String value = null;\n\t\t    if (config.getId() != null && config.getId().length() > 0) {\n\t\t\t//如果id属性不为空，则属性名称为：prefix + id + property\n\t\t\t//例如：pn = dubbo.monitor.\"id\".default\n\t\t\tString pn = prefix + config.getId() + \".\" + property;\n\t\t\t//从系统配置中获取属性pn的值value\n\t\t\tvalue = System.getProperty(pn);\n\t\t\tif (!StringUtils.isBlank(value)) {\n\t\t\t    //如果系统中设置了pn属性，则使用该属性值\n\t\t\t    logger.info(\"Use System Property \" + pn + \" to config dubbo\");\n\t\t\t}\n\t\t    }\n\t\t    if (value == null || value.length() == 0) {\n\t\t\t//属性名称为：prefix + property\n\t\t\t//例如：dubbo.monitor.default\n\t\t\tString pn = prefix + property;\n\t\t\t//获取属性pn的系统属性值value\n\t\t\tvalue = System.getProperty(pn);\n\t\t\tif (!StringUtils.isBlank(value)) {\n\t\t\t    logger.info(\"Use System Property \" + pn + \" to config dubbo\");\n\t\t\t}\n\t\t    }\n\t\t    if (value == null || value.length() == 0) {\n\t\t\tMethod getter;\n\t\t\ttry {\n\t\t\t    //获取当前属性的get方法\n\t\t\t    getter = config.getClass().getMethod(\"get\" + name.substring(3), new Class<?>[0]);\n\t\t\t} catch (NoSuchMethodException e) {\n\t\t\t    try {\n\t\t\t\t//get方法不存在的话，则获取下is方法\n\t\t\t\tgetter = config.getClass().getMethod(\"is\" + name.substring(3), new Class<?>[0]);\n\t\t\t    } catch (NoSuchMethodException e2) {\n\t\t\t\tgetter = null;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (getter != null) {\n\t\t\t    //执行config对象的属性的getter方法，结果为空的话\n\t\t\t    if (getter.invoke(config, new Object[0]) == null) {\n\t\t\t\tif (config.getId() != null && config.getId().length() > 0) {\n\t\t\t\t    //id属性不为空\n\t\t\t\t    //如：dubbo.monitor.\"id\".default\n\t\t\t\t    value = ConfigUtils.getProperty(prefix + config.getId() + \".\" + property);\n\t\t\t\t}\n\t\t\t\tif (value == null || value.length() == 0) {\n\t\t\t\t    //如：dubbo.monitor.default\n\t\t\t\t    value = ConfigUtils.getProperty(prefix + property);\n\t\t\t\t}\n\t\t\t\tif (value == null || value.length() == 0) {\n\t\t\t\t    //从旧版属性中获取(如：dubbo.monitor.default)\n\t\t\t\t    String legacyKey = legacyProperties.get(prefix + property);\n\t\t\t\t    if (legacyKey != null && legacyKey.length() > 0) {\n\t\t\t\t\t//转换旧版属性值\n\t\t\t\t\tvalue = convertLegacyValue(legacyKey, ConfigUtils.getProperty(legacyKey));\n\t\t\t\t    }\n\t\t\t\t}\n\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (value != null && value.length() > 0) {\n\t\t\t//如果属性值不为空的话，则使用属性值作为参数执行config类的method方法\n\t\t\tmethod.invoke(\n\t\t\t\tconfig,\n\t\t\t\tnew Object[]{\n\t\t\t\t\t//转换原始类型\n\t\t\t\t\tconvertPrimitive(method.getParameterTypes()[0], value)\n\t\t\t\t}\n\n\t\t\t);\n\t\t    }\n\t\t}\n\t    } catch (Exception e) {\n\t\tlogger.error(e.getMessage(), e);\n\t    }\n\t}\n}\n```\n\n##### checkInterfaceAndMethods方法\n```java\n/**\n* 判断方法methods是否都在服务接口类中存在\n* @param interfaceClass 服务接口类\n* @param methods 引用的服务接口方法\n*/\nprotected void checkInterfaceAndMethods(Class<?> interfaceClass, List<MethodConfig> methods) {\n\tif (interfaceClass == null) {\n\t    //服务接口不可以为空\n\t    throw new IllegalStateException(\"interface not allow null!\");\n\t}\n\tif (!interfaceClass.isInterface()) {\n\t    // interfaceClass必须为接口类型\n\t    throw new IllegalStateException(\"The interface class \" + interfaceClass + \" is not a interface!\");\n\t}\n\t// 检查methods方法是否存在于interfaceClass接口中\n\tif (methods != null && !methods.isEmpty()) {\n\t    //遍历引用的方法\n\t    for (MethodConfig methodBean : methods) {\n\t\t//方法名\n\t\tString methodName = methodBean.getName();\n\t\tif (methodName == null || methodName.length() == 0) {\n\t\t    //<dubbo:method>标签的name属性必须设置\n\t\t    throw new IllegalStateException(\"<dubbo:method> name attribute is required! Please check: <dubbo:service interface=\\\"\" + interfaceClass.getName() + \"\\\" ... ><dubbo:method name=\\\"\\\" ... /></<dubbo:reference>\");\n\t\t}\n\t\tboolean hasMethod = false;\n\t\tfor (java.lang.reflect.Method method : interfaceClass.getMethods()) {\n\t\t    //方法名一样，则认为存在该方法\n\t\t    if (method.getName().equals(methodName)) {\n\t\t\thasMethod = true;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (!hasMethod) {\n\t\t    //引用的方法在服务接口中不存在\n\t\t    throw new IllegalStateException(\"The interface \" + interfaceClass.getName()\n\t\t\t    + \" not found method \" + methodName);\n\t\t}\n\t    }\n\t}\n}\n```\n##### checkApplication方法\n该方法用来验证application,application为空的话，会新建ApplicationConfig对象\n```java\nprotected void checkApplication() {\n\t// 处理兼容\n\tif (application == null) {\n\t    //从配置文件中加载application.name属性\n\t    String applicationName = ConfigUtils.getProperty(\"dubbo.application.name\");\n\t    if (applicationName != null && applicationName.length() > 0) {\n\t\t//新创建一个ApplicationConfig对象\n\t\tapplication = new ApplicationConfig();\n\t    }\n\t}\n\tif (application == null) {\n\t    //需要配置 <dubbo:application name=\\\"...\\\" />\n\t    throw new IllegalStateException(\n\t\t    \"No such application config! Please add <dubbo:application name=\\\"...\\\" /> to your spring config.\");\n\t}\n\t//添加application的属性\n\tappendProperties(application);\n\t//获取配置: 服务停止时的等待时间(优先获取SHUTDOWN_WAIT_KEY属性，在获取SHUTDOWN_WAIT_SECONDS_KEY(废弃))\n\tString wait = ConfigUtils.getProperty(Constants.SHUTDOWN_WAIT_KEY);\n\tif (wait != null && wait.trim().length() > 0) {\n\t    //设置到系统配置中\n\t    System.setProperty(Constants.SHUTDOWN_WAIT_KEY, wait.trim());\n\t} else {\n\t    wait = ConfigUtils.getProperty(Constants.SHUTDOWN_WAIT_SECONDS_KEY);\n\t    if (wait != null && wait.trim().length() > 0) {\n\t\tSystem.setProperty(Constants.SHUTDOWN_WAIT_SECONDS_KEY, wait.trim());\n\t    }\n\t}\n}\n```\n\n##### checkStubAndMock方法\n该方法用来检测: 服务接口本地实现类、服务接口本地存根类、mock\n```java\n/**\n* 检测local/stub/mock的配置是否正确\n* local/stub/mock(mock 可配置为\"return \")应该为interfaceClass或者为interfaceClass子类\n* @param interfaceClass 服务接口类\n*/\nprotected void checkStubAndMock(Class<?> interfaceClass) {\n\t//处理服务接口本地实现类\n\tif (ConfigUtils.isNotEmpty(local)) {\n\t    //如果local = true或者local = default(即local属性配置),则本地实现类名为：接口名称+Local,否则本地实现类名为：local属性\n\t    //加载本地实现类\n\t    Class<?> localClass = ConfigUtils.isDefault(local) ? ReflectUtils.forName(interfaceClass.getName() + \"Local\") : ReflectUtils.forName(local);\n\t    //检查本地实现类是否实现了服务接口\n\t    if (!interfaceClass.isAssignableFrom(localClass)) {\n\t\tthrow new IllegalStateException(\"The local implementation class \" + localClass.getName() + \" not implement interface \" + interfaceClass.getName());\n\t    }\n\t    try {\n\t\t//检测本地实现类中是否存在相应的构造方法，即：public 本地实现类名 (服务接口名){}\n\t\tReflectUtils.findConstructor(localClass, interfaceClass);\n\t    } catch (NoSuchMethodException e) {\n\t\tthrow new IllegalStateException(\"No such constructor \\\"public \" + localClass.getSimpleName() + \"(\" + interfaceClass.getName() + \")\\\" in local implementation class \" + localClass.getName());\n\t    }\n\t}\n\t//处理服务接口本地存根类\n\tif (ConfigUtils.isNotEmpty(stub)) {\n\t    //如果stub = true或者stub = default(即stub属性)，则本地存根类名为：接口名称+Stub,否则本地存根类名为：stub属性\n\t    //加载本地存根类\n\t    Class<?> localClass = ConfigUtils.isDefault(stub) ? ReflectUtils.forName(interfaceClass.getName() + \"Stub\") : ReflectUtils.forName(stub);\n\t    //检测本地存根类是否实现了服务接口\n\t    if (!interfaceClass.isAssignableFrom(localClass)) {\n\t\tthrow new IllegalStateException(\"The local implementation class \" + localClass.getName() + \" not implement interface \" + interfaceClass.getName());\n\t    }\n\t    try {\n\t\t//检测本地存根类是否存在相应的构造方法, 即：public 本地存根类名 (服务接口名){}\n\t\tReflectUtils.findConstructor(localClass, interfaceClass);\n\t    } catch (NoSuchMethodException e) {\n\t\tthrow new IllegalStateException(\"No such constructor \\\"public \" + localClass.getSimpleName() + \"(\" + interfaceClass.getName() + \")\\\" in local implementation class \" + localClass.getName());\n\t    }\n\t}\n\t//处理mock\n\tif (ConfigUtils.isNotEmpty(mock)) {\n\t    //判断mock属性是否以\"return \"开头\n\t    if (mock.startsWith(Constants.RETURN_PREFIX)) {\n\t\t//获取到\"return \"之后的值\n\t\tString value = mock.substring(Constants.RETURN_PREFIX.length());\n\t\ttry {\n\t\t    //解析mock值\n\t\t    MockInvoker.parseMockValue(value);\n\t\t} catch (Exception e) {\n\t\t    throw new IllegalStateException(\"Illegal mock json value in <dubbo:service ... mock=\\\"\" + mock + \"\\\" />\");\n\t\t}\n\t    } else {\n\t\t//获取mock类\n\t\t//如果mock = true或者mock = default(即mock属性)，则本地存根类名为：接口名称+Mock,否则本地存根类名为：mock属性\n\t\tClass<?> mockClass = ConfigUtils.isDefault(mock) ? ReflectUtils.forName(interfaceClass.getName() + \"Mock\") : ReflectUtils.forName(mock);\n\t\t//检测mock类是否实现了服务接口\n\t\tif (!interfaceClass.isAssignableFrom(mockClass)) {\n\t\t    throw new IllegalStateException(\"The mock implementation class \" + mockClass.getName() + \" not implement interface \" + interfaceClass.getName());\n\t\t}\n\t\ttry {\n\t\t    //检测默认构造方法，即：pulic mock类名 () {}\n\t\t    mockClass.getConstructor(new Class<?>[0]);\n\t\t} catch (NoSuchMethodException e) {\n\t\t    throw new IllegalStateException(\"No such empty constructor \\\"public \" + mockClass.getSimpleName() + \"()\\\" in mock implementation class \" + mockClass.getName());\n\t\t}\n\t    }\n\t}\n}\n```\n##### appendParameters方法\n```java\n/**\n* 附加参数\n* 1、获取config对象的方法列表，\n* 2、找到getXXX或者isXXX方法或者getParameters方法(会通过方法上的@Parameter注解判断是否需要过滤该属性)\n* 3、然后执行该方法，拿到方法返回值(会通过方法上的@Parameter注解判断是否需要编码及追加)。\n* 然后将属性(@Parameter注解配置或者通过getXXX获取，如果配置了prefix，则属性为: prefix.属性)\n* 以及值保存到parameters中\n*\n* @param parameters 当前参数Map\n* @param config  目标配置对象\n* @param prefix 属性配置前缀\n*/\nprotected static void appendParameters(Map<String, String> parameters, Object config, String prefix) {\n\tif (config == null) {\n\t    return;\n\t}\n\t//获取配置类config的所有方法\n\tMethod[] methods = config.getClass().getMethods();\n\tfor (Method method : methods) {\n\t    try {\n\t\tString name = method.getName();\n\t\t//方法名以get或者is开头，并且方法名不为getClass，并且存在public修饰符\n\t\t//并且不存在参数，并且方法返回类型为原始类型\n\t\tif ((name.startsWith(\"get\") || name.startsWith(\"is\"))\n\t\t\t&& !\"getClass\".equals(name)\n\t\t\t&& Modifier.isPublic(method.getModifiers())\n\t\t\t&& method.getParameterTypes().length == 0\n\t\t\t&& isPrimitive(method.getReturnType())) {\n\t\t    //获取方法上的@Parameter注解\n\t\t    Parameter parameter = method.getAnnotation(Parameter.class);\n\t\t    if (method.getReturnType() == Object.class || parameter != null && parameter.excluded()) {\n\t\t\t//如果当前方法的返回类型为Object，或者该方法存在@Parameter注解且excluded属性值为true\n\t\t\t//则跳过该方法，即忽略该属性\n\t\t\tcontinue;\n\t\t    }\n\t\t    int i = name.startsWith(\"get\") ? 3 : 2;\n\t\t    //根据方法名获取到属性名，如：getFirstName被转换成：first.name\n\t\t    String prop = StringUtils.camelToSplitName(name.substring(i, i + 1).toLowerCase() + name.substring(i + 1), \".\");\n\t\t    //key为@Parameter注解的key属性或者为根据当前方法名截取到的属性名\n\t\t    String key;\n\t\t    if (parameter != null && parameter.key() != null && parameter.key().length() > 0) {\n\t\t\t//如果@Parameter注解的key属性不为空，则使用key属性\n\t\t\tkey = parameter.key();\n\t\t    } else {\n\t\t\t//否则使用prop作为key\n\t\t\tkey = prop;\n\t\t    }\n\t\t    //执行config对象的method方法，获取到方法返回值\n\t\t    Object value = method.invoke(config, new Object[0]);\n\t\t    //将方法返回值转换成字符串，并去掉空格\n\t\t    String str = String.valueOf(value).trim();\n\t\t    if (value != null && str.length() > 0) {\n\t\t\t//方法返回值不为空\n\t\t\tif (parameter != null && parameter.escaped()) {\n\t\t\t    //根据@Parameter注解的escaped属性来决定是否需要对属性值进行编码\n\t\t\t    str = URL.encode(str);\n\t\t\t}\n\t\t\tif (parameter != null && parameter.append()) {\n\t\t\t    //如果配置了@Parameter注解的append属性为true\n\t\t\t    //则从参数Map中获取key对应的值pre\n\t\t\t    String pre = parameters.get(Constants.DEFAULT_KEY + \".\" + key);\n\t\t\t    if (pre != null && pre.length() > 0) {\n\t\t\t\t//追加方法返回值\n\t\t\t\tstr = pre + \",\" + str;\n\t\t\t    }\n\t\t\t    pre = parameters.get(key);\n\t\t\t    if (pre != null && pre.length() > 0) {\n\t\t\t\t//追加方法返回值\n\t\t\t\tstr = pre + \",\" + str;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (prefix != null && prefix.length() > 0) {\n\t\t\t    //如果前缀不为空，则拼接key\n\t\t\t    key = prefix + \".\" + key;\n\t\t\t}\n\t\t\t//将key、value保存到参数Map中\n\t\t\tparameters.put(key, str);\n\t\t    } else if (parameter != null && parameter.required()) {\n\t\t\t//如果方法返回值为空，且@Parameter注解的required属性为true\n\t\t\t//则抛出异常，提示config类的key属性的值为空\n\t\t\tthrow new IllegalStateException(config.getClass().getSimpleName() + \".\" + key + \" == null\");\n\t\t    }\n\t\t} else if (\"getParameters\".equals(name)\n\t\t\t&& Modifier.isPublic(method.getModifiers())\n\t\t\t&& method.getParameterTypes().length == 0\n\t\t\t&& method.getReturnType() == Map.class) {\n\t\t    //方法名称为getParameters，且方法有public修饰符，且参数为空，且方法返回值为Map\n\t\t    //则执行config对象的getParameters方法，获取到返回值Map\n\t\t    Map<String, String> map = (Map<String, String>) method.invoke(config, new Object[0]);\n\t\t    if (map != null && map.size() > 0) {\n\t\t\t//格式化前缀，前缀以“.”结尾\n\t\t\tString pre = (prefix != null && prefix.length() > 0 ? prefix + \".\" : \"\");\n\t\t\t//遍历getParameters方法返回值\n\t\t\tfor (Map.Entry<String, String> entry : map.entrySet()) {\n\t\t\t    //将属性以及属性值保存到parameters中\n\t\t\t    parameters.put(pre + entry.getKey().replace('-', '.'), entry.getValue());\n\t\t\t}\n\t\t    }\n\t\t}\n\t    } catch (Exception e) {\n\t\tthrow new IllegalStateException(e.getMessage(), e);\n\t    }\n\t}\n}\n```\n\n##### appendAttributes方法\n```java\n/**\n* 附加属性\n* 1、获取config对象的getXXX或者isXXX方法(会通过方法上的@Parameter注解判断是否需要过滤该属性)，\n* 然后调用该方法获取返回值value。\n* 2、然后根据@Parameter注解的key属性或者当前方法名称(取消get/is前缀)作为key（prefix+\".\"+key），\n* 3、最终将key和value保存到parameters中\n* @param parameters 保存方法属性\n* @param config MethodConfig等对象\n* @param prefix\n*/\nprotected static void appendAttributes(Map<Object, Object> parameters, Object config, String prefix) {\n\tif (config == null) {\n\t    return;\n\t}\n\tMethod[] methods = config.getClass().getMethods();\n\t//遍历config对象的方法\n\tfor (Method method : methods) {\n\t    try {\n\t\t//方法名\n\t\tString name = method.getName();\n\t\t//找到get方法或者is方法\n\t\tif ((name.startsWith(\"get\") || name.startsWith(\"is\"))\n\t\t\t&& !\"getClass\".equals(name)\n\t\t\t&& Modifier.isPublic(method.getModifiers())\n\t\t\t&& method.getParameterTypes().length == 0\n\t\t\t&& isPrimitive(method.getReturnType())) {\n\t\t    //获取方法上的@Parameter注解\n\t\t    Parameter parameter = method.getAnnotation(Parameter.class);\n\t\t    if (parameter == null || !parameter.attribute()) {\n\t\t\t//如果该方法没有@Parameter注解，或者@Parameter注解的attribute属性为false\n\t\t\t//则跳过该方法\n\t\t\tcontinue;\n\t\t    }\n\t\t    //优先获取@Parameter注解的key属性，否则获取当前方法名(去掉get或者is前缀)\n\t\t    String key;\n\t\t    if (parameter.key() != null && parameter.key().length() > 0) {\n\t\t\tkey = parameter.key();\n\t\t    } else {\n\t\t\tint i = name.startsWith(\"get\") ? 3 : 2;\n\t\t\tkey = name.substring(i, i + 1).toLowerCase() + name.substring(i + 1);\n\t\t    }\n\t\t    //执行config对象的当前方法，获取方法返回值\n\t\t    Object value = method.invoke(config, new Object[0]);\n\t\t    if (value != null) {\n\t\t\tif (prefix != null && prefix.length() > 0) {\n\t\t\t    //前缀不为空的话，拼接上前缀\n\t\t\t    key = prefix + \".\" + key;\n\t\t\t}\n\t\t\t//将属性和属性值放到parameters中\n\t\t\tparameters.put(key, value);\n\t\t    }\n\t\t}\n\t    } catch (Exception e) {\n\t\tthrow new IllegalStateException(e.getMessage(), e);\n\t    }\n\t}\n}\n```\n##### checkAndConvertImplicitConfig方法\n```java\n/**\n* 处理onreturn、onthrow、oninvoke属性，将attributes中的value，从\"方法名称\"转换成\"方法对象\"\n* 如：将<onReturnMethodKey,onReturnMethod方法名>转换为<onReturnMethodKey,onReturnMethod方法对象>\n* @param method 当前方法配置\n* @param map 当前所有属性map\n* @param attributes 当前方法的属性map\n*/\nprivate static void checkAndConvertImplicitConfig(MethodConfig method, Map<String, String> map, Map<Object, Object> attributes) {\n\t//检测配置冲突\n\tif (Boolean.FALSE.equals(method.isReturn()) && (method.getOnreturn() != null || method.getOnthrow() != null)) {\n\t    //当设置了onreturn或者onthrow时，必须同时设置isReturn为true\n\t    throw new IllegalStateException(\"method config error : return attribute must be set true when onreturn or onthrow has been setted.\");\n\t}\n\n\t//attributes存的是<onReturnMethodKey,onReturnMethod方法名>\n\t//经过转换后存的是<onReturnMethodKey,onReturnMethod方法类>\n\n\t//onReturnMethodKey是属性key\n\tString onReturnMethodKey = StaticContext.getKey(map, method.getName(), Constants.ON_RETURN_METHOD_KEY);\n\t//从attributes中获取属性onReturnMethodKey对应的值(方法名)\n\tObject onReturnMethod = attributes.get(onReturnMethodKey);\n\tif (onReturnMethod != null && onReturnMethod instanceof String) {\n\t    //getMethodByName方法根据方法名onReturnMethod从类method.getOnreturn().getClass()中找到相应的方法\n\t    attributes.put(onReturnMethodKey, getMethodByName(method.getOnreturn().getClass(), onReturnMethod.toString()));\n\t}\n\t//下面的类似\n\t//convert onthrow methodName to Method\n\tString onThrowMethodKey = StaticContext.getKey(map, method.getName(), Constants.ON_THROW_METHOD_KEY);\n\tObject onThrowMethod = attributes.get(onThrowMethodKey);\n\tif (onThrowMethod != null && onThrowMethod instanceof String) {\n\t    attributes.put(onThrowMethodKey, getMethodByName(method.getOnthrow().getClass(), onThrowMethod.toString()));\n\t}\n\t//convert oninvoke methodName to Method\n\tString onInvokeMethodKey = StaticContext.getKey(map, method.getName(), Constants.ON_INVOKE_METHOD_KEY);\n\tObject onInvokeMethod = attributes.get(onInvokeMethodKey);\n\tif (onInvokeMethod != null && onInvokeMethod instanceof String) {\n\t    attributes.put(onInvokeMethodKey, getMethodByName(method.getOninvoke().getClass(), onInvokeMethod.toString()));\n\t}\n}\n```\n\n##### StaticContext类\ninit方法中，最终会将方法的属性添加到StaticContext中\n```java\nStaticContext.getSystemContext().putAll(attributes);\n\n\n/**\n * 系统上下文，只是框架内部使用\n * System context, for internal use only\n */\npublic class StaticContext extends ConcurrentHashMap<Object, Object> {\n    private static final long serialVersionUID = 1L;\n    private static final String SYSTEMNAME = \"system\";\n    private static final ConcurrentMap<String, StaticContext> context_map = new ConcurrentHashMap<String, StaticContext>();\n    private String name;\n\n    private StaticContext(String name) {\n        super();\n        this.name = name;\n    }\n\n    /**\n     * 获取系统上下文,即key为system\n     * @return\n     */\n    public static StaticContext getSystemContext() {\n        return getContext(SYSTEMNAME);\n    }\n\n    /**\n     * 根据name获取上下文\n     * @param name\n     * @return\n     */\n    public static StaticContext getContext(String name) {\n        //通过name从context_map中获取StaticContext\n        StaticContext appContext = context_map.get(name);\n        if (appContext == null) {\n            //没有获取到StaticContext，则为name新建一个StaticContext，然后放入context_map中\n            appContext = context_map.putIfAbsent(name, new StaticContext(name));\n            if (appContext == null) {\n                appContext = context_map.get(name);\n            }\n        }\n        return appContext;\n    }\n\n    /**\n     * 从context_map中移除name对应的上下文\n     * @param name\n     * @return\n     */\n    public static StaticContext remove(String name) {\n        return context_map.remove(name);\n    }\n\n    public static String getKey(URL url, String methodName, String suffix) {\n        return getKey(url.getServiceKey(), methodName, suffix);\n    }\n\n    public static String getKey(Map<String, String> paras, String methodName, String suffix) {\n        return getKey(StringUtils.getServiceKey(paras), methodName, suffix);\n    }\n\n    /**\n     * 获取唯一标识\n     * @param servicekey 服务唯一标识\n     * @param methodName 方法名\n     * @param suffix  前缀\n     * @return\n     */\n    private static String getKey(String servicekey, String methodName, String suffix) {\n        StringBuffer sb = new StringBuffer().append(servicekey).append(\".\").append(methodName).append(\".\").append(suffix);\n        return sb.toString();\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n```\n\n##### getUniqueServiceName方法\n```java\n/**\n* 获取唯一服务名称（group和version可以为空）\n* group/interfaceName:version\n* @return\n*/\n@Parameter(excluded = true)\npublic String getUniqueServiceName() {\n\tStringBuilder buf = new StringBuilder();\n\tif (group != null && group.length() > 0) {\n\t    buf.append(group).append(\"/\");\n\t}\n\tbuf.append(interfaceName);\n\tif (version != null && version.length() > 0) {\n\t    buf.append(\":\").append(version);\n\t}\n\treturn buf.toString();\n}\n```\n##### ConsumerModel类\n```java\npublic class ConsumerModel {\n    /**\n     * 元数据(即ReferenceBean实例)\n     */\n    private ReferenceConfig metadata;\n    /**\n     * 代理对象\n     */\n    private Object proxyObject;\n    /**\n     * 唯一的服务接口名称\n     */\n    private String serviceName;\n\n    private final Map<Method, ConsumerMethodModel> methodModels = new IdentityHashMap<Method, ConsumerMethodModel>();\n\n    public ConsumerModel(String serviceName,ReferenceConfig metadata, Object proxyObject, Method[] methods) {\n        this.serviceName = serviceName;\n        this.metadata = metadata;\n        this.proxyObject = proxyObject;\n\n        if (proxyObject != null) {\n            //代理对象不为空,遍历服务接口方法列表，创建ConsumerMethodModel类\n            for (Method method : methods) {\n                //<服务接口方法，ConsumerMethodModel<服务接口方法,metadata实例>>\n                methodModels.put(method, new ConsumerMethodModel(method, metadata));\n            }\n        }\n    }\n\n    /**\n     * Return service metadata for consumer\n     * @return service metadata\n     */\n    public ReferenceConfig getMetadata() {\n        return metadata;\n    }\n\n    public Object getProxyObject() {\n        return proxyObject;\n    }\n\n    /**\n     * 获取消费者端的给定方法的MethodModel\n     * Return method model for the given method on consumer side\n     *\n     * @param method method object\n     * @return method model\n     */\n    public ConsumerMethodModel getMethodModel(Method method) {\n        return methodModels.get(method);\n    }\n\n    /**\n     * 获取当前服务的所有方法MethodModel\n     * Return all method models for the current service\n     *\n     * @return method model list\n     */\n    public List<ConsumerMethodModel> getAllMethods() {\n        return new ArrayList<ConsumerMethodModel>(methodModels.values());\n    }\n\n    public String getServiceName() {\n        return serviceName;\n    }\n}\n```\n\n##### ApplicationModel类\n接下来我们简单看下ApplicationModel.initConsumerModel(getUniqueServiceName(), consumerModel);\n```java\n/**\n* 将服务的ConsumerModel方法保存到本地Map中\n* @param serviceName\n* @param consumerModel\n* @return\n*/\npublic static boolean initConsumerModel(String serviceName, ConsumerModel consumerModel) {\n\tif (consumedServices.putIfAbsent(serviceName, consumerModel) != null) {\n\t    logger.warn(\"Already register the same consumer:\" + serviceName);\n\t    return false;\n\t}\n\treturn true;\n}\n```\n\ninit方法我们还剩下两个方法没有讲解：\n1、 ref = createProxy(map); 即创建代理对象\n2、String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames(); 即包装类\n\n计划这两个方法留着后面的章节(讲完注册中心等章节后)在讲解。\n\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之集成Spring注解解析(0201)","url":"/blog/2018/08/05/Dubbo源码阅读之集成Spring-0201注解解析/","content":">本小节介绍Annotation的解析\n\n### AnnotationBeanDefinitionParser解析类\n\n```java\n该类继承自AbstractSingleBeanDefinitionParser抽象类，该抽象类规范了注册bean的骨架(即模板方法)，我们只需要实现getBeanClass方法指定待注册的bean，以及实现doParse方法表明如何解析类。\npublic class AnnotationBeanDefinitionParser extends AbstractSingleBeanDefinitionParser {\n\n    /**\n     * 解析：<dubbo:annotation package=\"\"/>\n     * @param element\n     * @param parserContext\n     * @param builder\n     */\n    @Override\n    protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {\n        //获取配置的package属性\n        String packageToScan = element.getAttribute(\"package\");\n        //逗号分隔package\n        String[] packagesToScan = trimArrayElements(commaDelimitedListToStringArray(packageToScan));\n\n        //通过构造函数设置ServiceAnnotationBeanPostProcessor类的packagesToScan属性\n        builder.addConstructorArgValue(packagesToScan);\n        //标识为基础设施类，防止该bean被代理\n        builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\n        //注册@ReferenceAnnotationBeanPostProcessor\n        registerReferenceAnnotationBeanPostProcessor(parserContext.getRegistry());\n\n    }\n\n    @Override\n    protected boolean shouldGenerateIdAsFallback() {\n        return true;\n    }\n\n    /**\n     * 注册ReferenceAnnotationBeanPostProcessor类\n     * 该类用来处理@Reference\n     * Registers {@link ReferenceAnnotationBeanPostProcessor} into {@link BeanFactory}\n     * @param registry {@link BeanDefinitionRegistry}\n     */\n    private void registerReferenceAnnotationBeanPostProcessor(BeanDefinitionRegistry registry) {\n        // Register @Reference Annotation Bean Processor\n        BeanRegistrar.registerInfrastructureBean(registry,\n                ReferenceAnnotationBeanPostProcessor.BEAN_NAME,\n                ReferenceAnnotationBeanPostProcessor.class);\n    }\n\n    @Override\n    protected Class<?> getBeanClass(Element element) {\n        //解析注册ServiceAnnotationBeanPostProcessor类\n        return ServiceAnnotationBeanPostProcessor.class;\n    }\n}\n```\n我们将ServiceAnnotationBeanPostProcessor类和ReferenceAnnotationBeanPostProcessor类注册到了Bean工厂中了，接下来我们将用两小节(0201/0202)来介绍这两个类的实现，先来看ServiceAnnotationBeanPostProcessor类的实现(0201)，ReferenceAnnotationBeanPostProcessor类放到(0202)小节介绍\n\n\n#### ServiceAnnotationBeanPostProcessor类实现\n接下来我们来分析下ServiceAnnotationBeanPostProcessor类,该类用来处理@Service注解，它实现了BeanDefinitionRegistryPostProcessor接口,实现它的postProcessBeanDefinitionRegistry方法允许我们实现自定义的注册bean定义的逻辑。同时也实现了几个以Aware为结尾的接口，例如BeanClassLoaderAware，实现了这些接口后，则ServiceAnnotationBeanPostProcessor类被实例化后将会获取相对应的资源。\n```java\npublic class ServiceAnnotationBeanPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware,\n        ResourceLoaderAware, BeanClassLoaderAware {\n\n    //分隔符\t\n    private static final String SEPARATOR = \":\";\n\n    //扫描的包路径(上面的小节介绍过，注册该bean时，会扫描包路径)\n    private final Set<String> packagesToScan;\n    \n    //实现EnvironmentAware接口，实例化后会自动注入\n    private Environment environment;\n\n    private ResourceLoader resourceLoader;\n\n    private ClassLoader classLoader;\n \n    //构造方法，参数是需要扫描的包路径\n    public ServiceAnnotationBeanPostProcessor(String... packagesToScan) {\n        this(Arrays.asList(packagesToScan));\n    }\n\n    public ServiceAnnotationBeanPostProcessor(Collection<String> packagesToScan) {\n        this(new LinkedHashSet<String>(packagesToScan));\n    }\n\n    public ServiceAnnotationBeanPostProcessor(Set<String> packagesToScan) {\n        //保存包路径\n\tthis.packagesToScan = packagesToScan;\n    }\n\t\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n\t//处理待扫描包里面的占位符(后面会分析该方法)\n        Set<String> resolvedPackagesToScan = resolvePackagesToScan(packagesToScan);\n        \n        if (!CollectionUtils.isEmpty(resolvedPackagesToScan)) {\n            //扫描包，找到存在@Service注解的类，然后注册它(后面会分析该方法)\n\t    registerServiceBeans(resolvedPackagesToScan, registry);\n        } else {\n            if (logger.isWarnEnabled()) {\n                //没有配置带扫描的包路径，将会忽略ServiceBean的注册\n                logger.warn(\"packagesToScan is empty , ServiceBean registry will be ignored!\");\n            }\n        }\n    }\n   \n    /**\n     * 处理带扫描包里面的占位符\n     * @param packagesToScan\n     * @return\n     */\n    private Set<String> resolvePackagesToScan(Set<String> packagesToScan) {\n        Set<String> resolvedPackagesToScan = new LinkedHashSet<String>(packagesToScan.size());\n        //遍历带扫描的包\n        for (String packageToScan : packagesToScan) {\n            if (StringUtils.hasText(packageToScan)) {\n                //通过environment解决占位符\n                String resolvedPackageToScan = environment.resolvePlaceholders(packageToScan.trim());\n                resolvedPackagesToScan.add(resolvedPackageToScan);\n            }\n        }\n        return resolvedPackagesToScan;\n    }\n   \n    /**\n     * 注册存在@Service注解的类\n     * @param packagesToScan 待扫描的基础包路径\n     * @param registry       {@link BeanDefinitionRegistry}\n     */\n    private void registerServiceBeans(Set<String> packagesToScan, BeanDefinitionRegistry registry) {\n\n\t//创建扫描器，用来扫描指定的包路径(后面会介绍该类)\n        DubboClassPathBeanDefinitionScanner scanner =\n                new DubboClassPathBeanDefinitionScanner(registry, environment, resourceLoader);\n\n\t//获取BeanNameGenerator实例用来生成bean name(后面会介绍该方法)\n        BeanNameGenerator beanNameGenerator = resolveBeanNameGenerator(registry);\n        \n\t//将BeanNameGenerator设置到扫描器\n        scanner.setBeanNameGenerator(beanNameGenerator);\n        \n        //设置过滤器，只扫描存在@Service注解的\n        scanner.addIncludeFilter(new AnnotationTypeFilter(Service.class));\n\n\t//遍历基础包\n        for (String packageToScan : packagesToScan) {\n\n            // 首先注册@Service bean\n            scanner.scan(packageToScan);\n\n            // 找到该包下所有存在@Service的BeanDefinition(不论是否是@ComponentScan扫描的)，\n\t    //然后为该bean生成beanName，并将该beanName和BeanDefinition包装成BeanDefinitionHolder（后面会分析该方法）\n            Set<BeanDefinitionHolder> beanDefinitionHolders =\n                    findServiceBeanDefinitionHolders(scanner, packageToScan, registry, beanNameGenerator);\n\n            if (!CollectionUtils.isEmpty(beanDefinitionHolders)) {\n                \n\t\t//遍历beanDefinitionHolders\n                for (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) {\n\t\t    //根据@Service注解 和 beanDefinition  注册ServiceBean类(后面会分析该方法)\n                    registerServiceBean(beanDefinitionHolder, registry, scanner);\n                }\n\n                if (logger.isInfoEnabled()) {\n\t\t    //输出扫描出来的@Service bean的数量，以及扫描的包路径\n                    logger.info(beanDefinitionHolders.size() + \" annotated Dubbo's @Service Components { \" +\n                            beanDefinitionHolders +\n                            \" } were scanned under package[\" + packageToScan + \"]\");\n                }\n            } else {\n                //没有扫描到\n                if (logger.isWarnEnabled()) {\n                    logger.warn(\"No Spring Bean annotating Dubbo's @Service was found under package[\"\n                            + packageToScan + \"]\");\n                }\n            }\n        }\n    }\n\n    /**\n     * 获取BeanNameGenerator\n     * @since 2.5.8\n     */\n    private BeanNameGenerator resolveBeanNameGenerator(BeanDefinitionRegistry registry) {\n\n        BeanNameGenerator beanNameGenerator = null;\n\n        if (registry instanceof SingletonBeanRegistry) {\n\t    //单例bean\n            SingletonBeanRegistry singletonBeanRegistry = SingletonBeanRegistry.class.cast(registry);\n\t    //获取beanName生成器\n            beanNameGenerator = (BeanNameGenerator) singletonBeanRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n        }\n        if (beanNameGenerator == null) {\n            if (logger.isInfoEnabled()) {\n\n                logger.info(\"BeanNameGenerator bean can't be found in BeanFactory with name [\"\n                        + CONFIGURATION_BEAN_NAME_GENERATOR + \"]\");\n                logger.info(\"BeanNameGenerator will be a instance of \" +\n                        AnnotationBeanNameGenerator.class.getName() +\n                        \" , it maybe a potential problem on bean name generation.\");\n            }\n\t    //使用AnnotationBeanNameGenerator\n            beanNameGenerator = new AnnotationBeanNameGenerator();\n        }\n        return beanNameGenerator;\n    }\n\n    /**\n     * 扫描包路径，通过过滤器找到存在@Service注解的bean，然后为该bean生成beanName，\n     * 然后将该beanName和beanDefinition封装成BeanDefinitionHolder对象，返回BeanDefinitionHolder列表\n     */\n    private Set<BeanDefinitionHolder> findServiceBeanDefinitionHolders(\n            ClassPathBeanDefinitionScanner scanner, String packageToScan, BeanDefinitionRegistry registry,\n            BeanNameGenerator beanNameGenerator) {\n \t\n\t//扫描基础包，查询候选组件（通过过滤器过滤出来的，即存在@Service注解的bean）\n        Set<BeanDefinition> beanDefinitions = scanner.findCandidateComponents(packageToScan);\n\n        Set<BeanDefinitionHolder> beanDefinitionHolders = new LinkedHashSet<BeanDefinitionHolder>(beanDefinitions.size());\n\n        for (BeanDefinition beanDefinition : beanDefinitions) {\n\t    //根据beanDefinition生成bean名称\n            String beanName = beanNameGenerator.generateBeanName(beanDefinition, registry);\n           \n\t    //根据beanName和beanDefinition创建BeanDefinitionHolder对象\n\t    BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(beanDefinition, beanName);\n           \n\t    //保存到列表\t\n\t    beanDefinitionHolders.add(beanDefinitionHolder);\n        }\n        return beanDefinitionHolders;\n    }\n\n    /**\n     * 根据@Service注解 和 beanDefinition  注册ServiceBean类\n     * Registers {@link ServiceBean} from new annotated {@link Service} {@link BeanDefinition}\n     */\n    private void registerServiceBean(BeanDefinitionHolder beanDefinitionHolder, BeanDefinitionRegistry registry,\n                                     DubboClassPathBeanDefinitionScanner scanner) {\n\t\n\t//从beanDefinitionHolder中获取beanName，然后加载该类(后面会分析该方法)\n        Class<?> beanClass = resolveClass(beanDefinitionHolder);\n\n\t//查询该bean的@Service注解(后面会分析该方法)\n        Service service = findAnnotation(beanClass, Service.class);\n\t\t\n\t//获取interfaceClass接口(后面会分析该方法)\n        Class<?> interfaceClass = resolveServiceInterfaceClass(beanClass, service);\n\t\n\t//获取bean的名称\n        String annotatedServiceBeanName = beanDefinitionHolder.getBeanName();\n\t\n\t//构建ServiceBean定义(后面会分析该方法)\n        AbstractBeanDefinition serviceBeanDefinition =\n                buildServiceBeanDefinition(service, interfaceClass, annotatedServiceBeanName);\n\t\n        //生成ServiceBean的beanName(后面会分析该方法)\n        String beanName = generateServiceBeanName(service, interfaceClass, annotatedServiceBeanName);\n\n\t//检测重复的候选bean\n        if (scanner.checkCandidate(beanName, serviceBeanDefinition)) {\n\t    //注解ServiceBean\n            registry.registerBeanDefinition(beanName, serviceBeanDefinition);\n\n            if (logger.isInfoEnabled()) {\n                logger.warn(\"The BeanDefinition[\" + serviceBeanDefinition +\n                        \"] of ServiceBean has been registered with name : \" + beanName);\n            }\n        } else {\n\t    //发现重复的bean定义，@DubboComponentScan多次扫描到同一个包？\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"The Duplicated BeanDefinition[\" + serviceBeanDefinition +\n                        \"] of ServiceBean[ bean name : \" + beanName +\n                        \"] was be found , Did @DubboComponentScan scan to same package in many times?\");\n            }\n        }\n    }\n\n    /**\n     * 生成ServiceBean的bean name\n     *\n     * @param service  @Service注解\n     * @param interfaceClass 存在@Service注解的类的接口\n     * @param annotatedServiceBeanName 存在@Service注解的Bean name\n     * @return ServiceBean@interfaceClassName#annotatedServiceBeanName\n     * @since 2.5.9\n     */\n    private String generateServiceBeanName(Service service, Class<?> interfaceClass, String annotatedServiceBeanName) {\n\t//添加\"ServiceBean\"\n        StringBuilder beanNameBuilder = new StringBuilder(ServiceBean.class.getSimpleName());\n\n\t//添加分隔符\":\" 和 annotatedServiceBeanName \n        beanNameBuilder.append(SEPARATOR).append(annotatedServiceBeanName);\n\n        //获取接口的全限定名\n        String interfaceClassName = interfaceClass.getName();\n  \n        //添加分隔符\":\" 和 interfaceClassName\n        beanNameBuilder.append(SEPARATOR).append(interfaceClassName);\n       \n  \t//获取@Service注解的version属性\n        String version = service.version();\n\t\n        if (StringUtils.hasText(version)) {\n            //添加分隔符\":\" 和 version\n\t    beanNameBuilder.append(SEPARATOR).append(version);\n        }\n\t\n\t//获取Service的group属性\n        String group = service.group();\n        if (StringUtils.hasText(group)) {\n\t    //添加分隔符\":\" 和 group\n            beanNameBuilder.append(SEPARATOR).append(group);\n        }\n\t//返回生成的bean名称\n        return beanNameBuilder.toString();\n    }\n\n    /**\n     * 处理@Service注解里的interfaceClass()，该interfaceClass不可以为空，并且必须是接口类型\n     * 1、获取@Service注解中的interfaceClass()\n     * 2、获取@Service注解中的interfaceName()，并加载\n     * 3、获取@Service注解类的第1个接口\n     * @param annotatedServiceBeanClass 存在@Service注解的类\n     * @param service @Service注解\n     * @return\n     */\n    private Class<?> resolveServiceInterfaceClass(Class<?> annotatedServiceBeanClass, Service service) {\n        \n\t//interfaceClass默认为@Service注解的interfaceClass属性\n        Class<?> interfaceClass = service.interfaceClass();\n\t\n\t\n        if (void.class.equals(interfaceClass)) {\n\t    //@Service注解的interfaceClass属性为空\n            interfaceClass = null;\n\t\t\n\t    //获取@Service注解的interfaceName属性\n            String interfaceClassName = service.interfaceName();\n            if (StringUtils.hasText(interfaceClassName)) {\n\t\t//判断是否存在interfaceClassName类\n                if (ClassUtils.isPresent(interfaceClassName, classLoader)) {\n\t\t    //加载interfaceClassName类，并赋值给interfaceClass\n                    interfaceClass = resolveClassName(interfaceClassName, classLoader);\n                }\n            }\n        }\n\n        if (interfaceClass == null) {\n\t    //获取该类的所有接口\n            Class<?>[] allInterfaces = annotatedServiceBeanClass.getInterfaces();\n            if (allInterfaces.length > 0) {\n\t\t//取第一个接口，赋值给interfaceClass\n                interfaceClass = allInterfaces[0];\n            }\n\n        }\n\t//验证不为空，且interfaceClass为接口\n        Assert.notNull(interfaceClass,\n                \"@Service interfaceClass() or interfaceName() or interface class must be present!\");\n\n        Assert.isTrue(interfaceClass.isInterface(),\n                \"The type that was annotated @Service is not an interface!\");\n\n        return interfaceClass;\n    }\n\t\n    private Class<?> resolveClass(BeanDefinitionHolder beanDefinitionHolder) {\n\t//获取bean定义\n        BeanDefinition beanDefinition = beanDefinitionHolder.getBeanDefinition();\n        return resolveClass(beanDefinition);\n\n    }\n\t\n    /**\n     * 加载类\n     */\n    private Class<?> resolveClass(BeanDefinition beanDefinition) {\n\t//获取bean的类名\n        String beanClassName = beanDefinition.getBeanClassName();\n \t//加载该类\t\n        return resolveClassName(beanClassName, classLoader);\n    }\n\n    /**\n     * 构建ServiceBean定义\n     * @param service  @Service注解\n     * @param interfaceClass 接口类\n     * @param annotatedServiceBeanName 存在@Service注解的类的bean name\n     */\n    private AbstractBeanDefinition buildServiceBeanDefinition(Service service, Class<?> interfaceClass,\n                                                              String annotatedServiceBeanName) {\n\t\n\t//获取ServiceBean的BeanDefinition构造器\n        BeanDefinitionBuilder builder = rootBeanDefinition(ServiceBean.class);\n\t\n\t//获取BeanDefinition\n        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();\n\t\n\t//获取ServiceBean的属性\n        MutablePropertyValues propertyValues = beanDefinition.getPropertyValues();\n\n\t//忽略的属性名称,这些属性的值后面会设置，从@Service注解中获取\n        String[] ignoreAttributeNames = of(\"provider\", \"monitor\", \"application\", \"module\", \"registry\", \"protocol\", \"interface\");\n\t\n\t//添加属性值(后面会介绍该类)\n        propertyValues.addPropertyValues(new AnnotationPropertyValuesAdapter(service, environment, ignoreAttributeNames));\n\n        //为ServiceBean添加ref属性，属性值为annotatedServiceBeanName(即存在@Service注解的bean name)(后面会分析该方法)\t\n        addPropertyReference(builder, \"ref\", annotatedServiceBeanName);\n        //为ServiceBean添加interface属性，属性值为interfaceClass接口的名称\n        builder.addPropertyValue(\"interface\", interfaceClass.getName());\n\n\t//获取@Service注解的provider属性(即com.alibaba.dubbo.config.ProviderConfig)\n        String providerConfigBeanName = service.provider();\n        if (StringUtils.hasText(providerConfigBeanName)) {\n\t    //为ServiceBean添加provider属性，属性值为providerConfigBeanName\n            addPropertyReference(builder, \"provider\", providerConfigBeanName);\n        }\n\n        //获取@Service注解的monitor属性(即com.alibaba.dubbo.config.MonitorConfig)\n\tString monitorConfigBeanName = service.monitor();\n        if (StringUtils.hasText(monitorConfigBeanName)) {\n\t    //为ServiceBean添加monitor属性，属性值为monitorConfigBeanName\n            addPropertyReference(builder, \"monitor\", monitorConfigBeanName);\n        }\n\n\t//获取@Service注解的application属性(即com.alibaba.dubbo.config.ApplicationConfig)\n        String applicationConfigBeanName = service.application();\n        if (StringUtils.hasText(applicationConfigBeanName)) {\n\t    //为ServiceBean添加application属性，属性值为applicationConfigBeanName\n            addPropertyReference(builder, \"application\", applicationConfigBeanName);\n        }\n\n\t//获取@Service注解的module属性(即com.alibaba.dubbo.config.ModuleConfig)\n\tString moduleConfigBeanName = service.module();\n        if (StringUtils.hasText(moduleConfigBeanName)) {\n\t    //为ServiceBean添加module属性，属性值为moduleConfigBeanName\n            addPropertyReference(builder, \"module\", moduleConfigBeanName);\n        }\n\n\n\t//获取@Service注解的registry属性(即com.alibaba.dubbo.config.RegistryConfig)\n        String[] registryConfigBeanNames = service.registry();\n\t//遍历registryConfigBeanNames，处理占位符，然后包装成RuntimeBeanReference并返回(后面会分析该方法)\n        List<RuntimeBeanReference> registryRuntimeBeanReferences = toRuntimeBeanReferences(registryConfigBeanNames);\n\n        if (!registryRuntimeBeanReferences.isEmpty()) {\n            //为ServiceBean添加registries属性\n\t    builder.addPropertyValue(\"registries\", registryRuntimeBeanReferences);\n        }\n\n        //获取@Service的protocol属性(即com.alibaba.dubbo.config.ProtocolConfig)\n\tString[] protocolConfigBeanNames = service.protocol();\n\t//处理占位符\n        List<RuntimeBeanReference> protocolRuntimeBeanReferences = toRuntimeBeanReferences(protocolConfigBeanNames);\n\n        if (!protocolRuntimeBeanReferences.isEmpty()) {\n            //为ServiceBean添加protocols属性\n\t    builder.addPropertyValue(\"protocols\", protocolRuntimeBeanReferences);\n        }\n\t//返回@ServiceBean定义\n        return builder.getBeanDefinition();\n    }\n\n\t\n    /**\n     * 处理占位符，并包装成包装成RuntimeBeanReference对象\n     * @param beanNames\n     * @return\n     */\n    private ManagedList<RuntimeBeanReference> toRuntimeBeanReferences(String... beanNames) {\n        ManagedList<RuntimeBeanReference> runtimeBeanReferences = new ManagedList<RuntimeBeanReference>();\n        if (!ObjectUtils.isEmpty(beanNames)) {\n            //遍历bean names\n            for (String beanName : beanNames) {\n\t\t//解决占位符\n                String resolvedBeanName = environment.resolvePlaceholders(beanName);\n\t\t//将beanName包装成RuntimeBeanReference对象\n                runtimeBeanReferences.add(new RuntimeBeanReference(resolvedBeanName));\n            }\n        }\n        return runtimeBeanReferences;\n    }\n    \n    /**\n     * 为ServiceBean添加propertyName属性，属性值为beanName\n     * @param builder ServiceBean定义构造器\n     * @param propertyName 属性名称\n     * @param beanName 存在@Service直接的bean name\n     */\n    private void addPropertyReference(BeanDefinitionBuilder builder, String propertyName, String beanName) {\n        //处理占位符\n\tString resolvedBeanName = environment.resolvePlaceholders(beanName);\n        //为ServiceBean添加propertyName属性，属性值为resolvedBeanName\n\tbuilder.addPropertyReference(propertyName, resolvedBeanName);\n    }\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        this.environment = environment;\n    }\n\n    @Override\n    public void setResourceLoader(ResourceLoader resourceLoader) {\n        this.resourceLoader = resourceLoader;\n    }\n\n    @Override\n    public void setBeanClassLoader(ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n}\n```\n我们再看下用到的其他类\n##### DubboClassPathBeanDefinitionScanner\n该类继承自ClassPathBeanDefinitionScanner,它提供自动扫描功能,根据提供的基础包路径,扫描classpath下该基础包路径,找到符合条件的类并注册为Spring的一个Bean,\n默认情况下,ClassPathBeanDefinitionScanner将会扫描所有用Spring指定了的注解标识的类,包括@Component、@Service、@Repository、@Controller,\n也可以对扫描的机制进行配置,设置一些Filter,只有满足Filter的类才能被注册为Bean.\n```java\npublic class DubboClassPathBeanDefinitionScanner extends ClassPathBeanDefinitionScanner {\n\n    public DubboClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry,\n                                               boolean useDefaultFilters,\n                                               Environment environment,\n                                               ResourceLoader resourceLoader) {\n        super(registry, useDefaultFilters);\n        \n\tsetEnvironment(environment);\n\n        setResourceLoader(resourceLoader);\n\n\t//会调用AnnotationConfigUtils类的registerAnnotationConfigProcessors方法\n        registerAnnotationConfigProcessors(registry);\n    }\n    public DubboClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry,\n                                               Environment environment,\n                                               ResourceLoader resourceLoader) {\n        this(registry, false, environment, resourceLoader);\n    }\n\n    @Override\n    public Set<BeanDefinitionHolder> doScan(String... basePackages) {\n        return super.doScan(basePackages);\n    }\n\n    @Override\n    public boolean checkCandidate(String beanName, BeanDefinition beanDefinition) throws IllegalStateException {\n        //检测beanName是否已经存在\n        return super.checkCandidate(beanName, beanDefinition);\n    }\n}\n```\n接下来我们看下AnnotationConfigUtils类的registerAnnotationConfigProcessors方法\n```java\npublic static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(\n\t\t\tBeanDefinitionRegistry registry, Object source) {\n\n\t//···省略···\n\tSet<BeanDefinitionHolder> beanDefs = new LinkedHashSet(4);\n\tRootBeanDefinition def;\n\n\t//注册ConfigurationClassPostProcessor\n\tif (!registry.containsBeanDefinition(\"org.springframework.context.annotation.internalConfigurationAnnotationProcessor\")) {\n\t    //1.在spring使用AnnotationConfigBeanDefinitionParser解析xml文件的时候  也就是配置annotation-config的时候\n            //2.启动在AnnotationConfigApplicationContext容器的时候\n\t    def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);\n\t    def.setSource(source);\n\t    beanDefs.add(registerPostProcessor(registry, def, \"org.springframework.context.annotation.internalConfigurationAnnotationProcessor\"));\n\t}\n\t\n\t//注册AutowiredAnnotationBeanPostProcessor \n\tif (!registry.containsBeanDefinition(\"org.springframework.context.annotation.internalAutowiredAnnotationProcessor\")) {\n\t    def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);\n\t    def.setSource(source);\n\t    beanDefs.add(registerPostProcessor(registry, def, \"org.springframework.context.annotation.internalAutowiredAnnotationProcessor\"));\n\t}\n\n\t//···省略···\n\treturn beanDefs;\n}\n```\n##### AnnotationPropertyValuesAdapter\n该类实现了Spring的PropertyValues接口，此接口是PropertyValue的集合管理类,用来储存键值对.MutablePropertyValues是其常用实现类\n在该适配器内部就是用了MutablePropertyValues实现类来进行操作。\n```java\n//我们在上文构建ServiceBean定义的时候会创建AnnotationPropertyValuesAdapter类，相关代码如下：\n//String[] ignoreAttributeNames = of(\"provider\", \"monitor\", \"application\", \"module\", \"registry\", \"protocol\", \"interface\");\n//propertyValues.addPropertyValues(new AnnotationPropertyValuesAdapter(service, environment, ignoreAttributeNames));\n//其中service参数是@Service注解，而environment参数类实现了PropertyResolver接口\n\n\nclass AnnotationPropertyValuesAdapter implements PropertyValues {\n     \n    //传过来的注解\n    private final Annotation annotation;\n    \n    //属性解决器,规范了解析底层任意property资源的接口\n    private final PropertyResolver propertyResolver;\n\n    //是否忽略默认值\n    private final boolean ignoreDefaultValue;\n\t\n    //委托类,即MutablePropertyValues\n    private final PropertyValues delegate;\n\n    public AnnotationPropertyValuesAdapter(Annotation annotation, PropertyResolver propertyResolver, boolean ignoreDefaultValue, String... ignoreAttributeNames) {\n        this.annotation = annotation;\n        this.propertyResolver = propertyResolver;\n        this.ignoreDefaultValue = ignoreDefaultValue;\n        //生成MutablePropertyValues\n        this.delegate = adapt(annotation, ignoreDefaultValue, ignoreAttributeNames);\n    }\n\n    public AnnotationPropertyValuesAdapter(Annotation annotation, PropertyResolver propertyResolver, String... ignoreAttributeNames) {\n        this(annotation, propertyResolver, true, ignoreAttributeNames);\n    }\n\n    private PropertyValues adapt(Annotation annotation, boolean ignoreDefaultValue, String... ignoreAttributeNames) {\n        //创建MutablePropertyValues类(后面会分析该方法getAttributes()\n\treturn new MutablePropertyValues(getAttributes(annotation, propertyResolver, ignoreDefaultValue, ignoreAttributeNames));\n    }\n\n    public Annotation getAnnotation() {\n        return annotation;\n    }\n\n    public boolean isIgnoreDefaultValue() {\n        return ignoreDefaultValue;\n    }\n\n    @Override\n    public PropertyValue[] getPropertyValues() {\n\t//调用委托类的方法\n        return delegate.getPropertyValues();\n    }\n\n    @Override\n    public PropertyValue getPropertyValue(String propertyName) {\n        //调用委托类的方法获取属性值\n        return delegate.getPropertyValue(propertyName);\n    }\n\n    @Override\n    public PropertyValues changesSince(PropertyValues old) {\n        return delegate.changesSince(old);\n    }\n\n    @Override\n    public boolean contains(String propertyName) {\n        return delegate.contains(propertyName);\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return delegate.isEmpty();\n    }\n}\n```\n下面我们看下AnnotationUtils.getAttributes方法\n```java\n/**\n * 获取注解的属性集合\n * @param annotation   注解\n * @param propertyResolver 属性解决器\n *    1、根据属性名称获取属性值（替换后的）\n *    2、替换${propertyName:defaultValue}格式的占位符为实际值\n * @param ignoreDefaultValue 是否忽略默认值\n * @param ignoreAttributeNames 需要忽略的属性名\n * @return <属性名，属性值>\n */\npublic static Map<String, Object> getAttributes(Annotation annotation,\n\t\t\t\t\t    PropertyResolver propertyResolver,\n\t\t\t\t\t    boolean ignoreDefaultValue,\n\t\t\t\t\t    String... ignoreAttributeNames) {\n\t\n\t//需要忽略的属性名\n\tSet<String> ignoreAttributeNamesSet = new HashSet<String>(arrayToList(ignoreAttributeNames));\n\n\t//获取annotation注解的属性map(调用的Spring的AnnotationUtils.getAnnotationAttributes方法)\n\tMap<String, Object> attributes = getAnnotationAttributes(annotation);\n\t//属性名,真实属性值\n\tMap<String, Object> actualAttributes = new LinkedHashMap<String, Object>();\n\t\n\t//是否需要处理占位符\n\tboolean requiredResolve = propertyResolver != null;\n\n\tfor (Map.Entry<String, Object> entry : attributes.entrySet()) {\n\t    //属性名称\n\t    String attributeName = entry.getKey();\n\t    //属性值\n\t    Object attributeValue = entry.getValue();\n\n\t    //忽略默认属性值\n\t    if (ignoreDefaultValue && nullSafeEquals(attributeValue, getDefaultValue(annotation, attributeName))) {\n\t\t//属性值和默认值相等，则跳过该属性\n\t\tcontinue;\n\t    }\n\n\t    //忽略属性名\n\t    if (ignoreAttributeNamesSet.contains(attributeName)) {\n\t\t//如果待忽略的属性名列表包含该属性名，则跳过该属性\n\t\tcontinue;\n\t    }\n\n\t    // 处理占位符,属性值为字符串类型\n\t    if (requiredResolve && attributeValue instanceof String) {\n\t\t//获取真实属性值\n\t\tString resolvedValue = propertyResolver.resolvePlaceholders(valueOf(attributeValue));\n\t\t//格式化真实属性值\n\t\tattributeValue = trimAllWhitespace(resolvedValue);\n\t    }\n\t    //保存属性名和真实属性值\n\t    actualAttributes.put(attributeName, attributeValue);\n\t}\n\treturn actualAttributes;\n}\n```\n\n##### ServiceBean类\n在上面的内容中，我们完成了ServiceBean类的注册，现在我们详细看看ServiceBean类.该类继承自ServiceConfig类，并且实现了众多Spring接口\n```java\n/**\n * ServiceFactoryBean\n * InitializingBean接口在bean实例化完成后将会自动调用afterPropertiesSet方法\n * DisposableBean接口在bean销毁之前调用destroy方法\n * ApplicationContextAware接口在bean实例化完成后将会注入ApplicationContext属性\n * ApplicationListener接口Spring容器初始化完成后会回调onApplicationEvent方法\n * BeanNameAware接口注入bean名称\n *\n * @export\n */\npublic class ServiceBean<T> extends ServiceConfig<T> implements InitializingBean, DisposableBean, ApplicationContextAware, ApplicationListener<ContextRefreshedEvent>, BeanNameAware {\n\n    private static final long serialVersionUID = 213195494150089726L;\n\n\n    private static transient ApplicationContext SPRING_CONTEXT;\n\n    /**\n     * @Service注解\n     */\n    private final transient Service service;\n\n    private transient ApplicationContext applicationContext;\n\n    private transient String beanName;\n\n    /**\n     * 是否支持ApplicationListener\n     */\n    private transient boolean supportedApplicationListener;\n\n    public ServiceBean() {\n        super();\n        this.service = null;\n    }\n\n    public ServiceBean(Service service) {\n        super(service);\n        this.service = service;\n    }\n\n    /**\n     * 获取Spring ApplicationContext\n     * @return\n     */\n    public static ApplicationContext getSpringContext() {\n        return SPRING_CONTEXT;\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) {\n        //设置ApplicationContext\n        this.applicationContext = applicationContext;\n        SpringExtensionFactory.addApplicationContext(applicationContext);\n        if (applicationContext != null) {\n            SPRING_CONTEXT = applicationContext;\n            try {\n                //backward compatibility to spring 2.0.1\n                //从applicationContext中获取到addApplicationListener方法\n                Method method = applicationContext.getClass().getMethod(\"addApplicationListener\", new Class<?>[]{ApplicationListener.class});\n                //调用applicationContext的addApplicationListener方法，将当前对象添加进去\n                method.invoke(applicationContext, new Object[]{this});\n                //设置支持ApplicationListener\n                supportedApplicationListener = true;\n            } catch (Throwable t) {\n                if (applicationContext instanceof AbstractApplicationContext) {\n                    try {\n                        // 向后兼容\n                        // backward compatibility to spring 2.0.1\n                        Method method = AbstractApplicationContext.class.getDeclaredMethod(\"addListener\", new Class<?>[]{ApplicationListener.class});\n                        if (!method.isAccessible()) {\n                            method.setAccessible(true);\n                        }\n                        method.invoke(applicationContext, new Object[]{this});\n                        supportedApplicationListener = true;\n                    } catch (Throwable t2) {\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void setBeanName(String name) {\n        this.beanName = name;\n    }\n\n    public Service getService() {\n        return service;\n    }\n\n    @Override\n    public void onApplicationEvent(ContextRefreshedEvent event) {\n\t//没有配置delay，或者delay = -1\n        if (isDelay() && !isExported() && !isUnexported()) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"The service ready on spring started. service: \" + getInterface());\n            }\n            //暴露服务(后面会分析该方法)\n            export();\n        }\n    }\n\n    /**\n     * 两种情况：\n     * 1、设置了延迟暴露(delay != null && delay != -1)，dubbo在Spring实例化bean的时候会对实现了InitializingBean的类进行回调，\n     * 回调方法是afterPropertySet()，如果设置了延迟暴露，dubbo在这个方法中进行服务的发布。\n     * 2、没有设置延迟或者延迟为-1，dubbo会在Spring实例化完bean之后，\n     * 在刷新容器最后一步发布ContextRefreshEvent事件的时候，\n     * 通知实现了ApplicationListener的类进行回调onApplicationEvent，dubbo会在这个方法中发布服务\n     * @return\n     */\n    private boolean isDelay() {\n        //获取delay属性\n        Integer delay = getDelay();\n        //获取服务提供者\n        ProviderConfig provider = getProvider();\n        if (delay == null && provider != null) {\n            //delay属性为空，则取服务提供者的delay属性\n            delay = provider.getDelay();\n        }\n        //(支持spring监听事件 && 没有设置延迟或者延迟为-1) 则返回true\n        return supportedApplicationListener && (delay == null || delay == -1);\n    }\n\n\t\n    /**\n     * 1、会判断ServiceBean的ProviderConfig、ApplicationConfig、ModuleConfig、List<RegistryConfig>、MonitorConfig、List<ProtocolConfig>属性是否为空，为空的话，从Spring容器中获取，然后进行赋值，其中还会检测是否存在重复的配置(default属性)\n     * 2、接着会判断并设置path属性(使用beanName)\n     * 3、根据delay属性判断是否需要暴露服务\n     */\n    @Override\n    @SuppressWarnings({\"unchecked\", \"deprecation\"})\n    public void afterPropertiesSet() throws Exception {\n        //没有配置Provider\n        if (getProvider() == null) {\n            //从IOC容器中获取到所有的Provider\n            Map<String, ProviderConfig> providerConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProviderConfig.class, false, false);\n            if (providerConfigMap != null && providerConfigMap.size() > 0) {\n                //从IOC容器中获取到所有的Protocol\n                Map<String, ProtocolConfig> protocolConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, false, false);\n                if ((protocolConfigMap == null || protocolConfigMap.size() == 0)\n                        && providerConfigMap.size() > 1) {\n                    // backward compatibility\n                    //如果没有配置Protocol，但是存在Provider的话，遍历Provider列表\n                    //从Provider列表中找到isDefault属性为true的Provider，并保存起来\n                    List<ProviderConfig> providerConfigs = new ArrayList<ProviderConfig>();\n                    for (ProviderConfig config : providerConfigMap.values()) {\n                        if (config.isDefault() != null && config.isDefault().booleanValue()) {\n                            //找到default为true的Provider\n                            providerConfigs.add(config);\n                        }\n                    }\n                    if (!providerConfigs.isEmpty()) {\n                        //根据Provider构造Protocol(废弃方法)\n                        setProviders(providerConfigs);\n                    }\n                } else {\n                    ProviderConfig providerConfig = null;\n                    //从provider列表中找到default属性为null或者为true的provider，如果找到多个则抛异常\n                    for (ProviderConfig config : providerConfigMap.values()) {\n                        //没有配置isDefault属性或者isDefault = true\n                        //检测是否存在重复的Provider配置\n                        if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                            if (providerConfig != null) {\n                                throw new IllegalStateException(\"Duplicate provider configs: \" + providerConfig + \" and \" + config);\n                            }\n                            providerConfig = config;\n                        }\n                    }\n                    if (providerConfig != null) {\n                        //设置Provider\n                        setProvider(providerConfig);\n                    }\n                }\n            }\n        }\n        if (getApplication() == null\n                && (getProvider() == null || getProvider().getApplication() == null)) {\n            //从IOC容器中找到所有的ApplicationConfig\n            Map<String, ApplicationConfig> applicationConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, false, false);\n            if (applicationConfigMap != null && applicationConfigMap.size() > 0) {\n                ApplicationConfig applicationConfig = null;\n                //检测是否存在重复的Application配置(default属性为null或者为true)\n                for (ApplicationConfig config : applicationConfigMap.values()) {\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        if (applicationConfig != null) {\n                            throw new IllegalStateException(\"Duplicate application configs: \" + applicationConfig + \" and \" + config);\n                        }\n                        applicationConfig = config;\n                    }\n                }\n                if (applicationConfig != null) {\n                    setApplication(applicationConfig);\n                }\n            }\n        }\n        if (getModule() == null\n                && (getProvider() == null || getProvider().getModule() == null)) {\n            //从IOC容器中找到所有的ModuleConfig\n            Map<String, ModuleConfig> moduleConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, false, false);\n            if (moduleConfigMap != null && moduleConfigMap.size() > 0) {\n                ModuleConfig moduleConfig = null;\n                //检测是否存在重复的Module配置(default属性为null或者为true)\n                for (ModuleConfig config : moduleConfigMap.values()) {\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        if (moduleConfig != null) {\n                            throw new IllegalStateException(\"Duplicate module configs: \" + moduleConfig + \" and \" + config);\n                        }\n                        moduleConfig = config;\n                    }\n                }\n                if (moduleConfig != null) {\n                    setModule(moduleConfig);\n                }\n            }\n        }\n        //register为空或者Provider中的register为空或者Application中的register为空\n        if ((getRegistries() == null || getRegistries().isEmpty())\n                && (getProvider() == null || getProvider().getRegistries() == null || getProvider().getRegistries().isEmpty())\n                && (getApplication() == null || getApplication().getRegistries() == null || getApplication().getRegistries().isEmpty())) {\n            //从IOC容器中获取RegistryConfig\n            Map<String, RegistryConfig> registryConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, false, false);\n            if (registryConfigMap != null && registryConfigMap.size() > 0) {\n                List<RegistryConfig> registryConfigs = new ArrayList<RegistryConfig>();\n                //遍历registry列表，从中找到default属性为null或者为true的registry，并保存起来\n                for (RegistryConfig config : registryConfigMap.values()) {\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        registryConfigs.add(config);\n                    }\n                }\n                if (registryConfigs != null && !registryConfigs.isEmpty()) {\n                    super.setRegistries(registryConfigs);\n                }\n            }\n        }\n        if (getMonitor() == null\n                && (getProvider() == null || getProvider().getMonitor() == null)\n                && (getApplication() == null || getApplication().getMonitor() == null)) {\n            Map<String, MonitorConfig> monitorConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig.class, false, false);\n            if (monitorConfigMap != null && monitorConfigMap.size() > 0) {\n                MonitorConfig monitorConfig = null;\n                //检测是否存在重复的monitor配置(default属性为空或者为true)\n                for (MonitorConfig config : monitorConfigMap.values()) {\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        if (monitorConfig != null) {\n                            throw new IllegalStateException(\"Duplicate monitor configs: \" + monitorConfig + \" and \" + config);\n                        }\n                        monitorConfig = config;\n                    }\n                }\n                if (monitorConfig != null) {\n\t\t    //设置monitor\n                    setMonitor(monitorConfig);\n                }\n            }\n        }\n        if ((getProtocols() == null || getProtocols().isEmpty())\n                && (getProvider() == null || getProvider().getProtocols() == null || getProvider().getProtocols().isEmpty())) {\n            //从IOC容器中获取ProtocolConfig\n            Map<String, ProtocolConfig> protocolConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, false, false);\n            if (protocolConfigMap != null && protocolConfigMap.size() > 0) {\n                List<ProtocolConfig> protocolConfigs = new ArrayList<ProtocolConfig>();\n                //遍历Protocol列表，从中找到default属性为空，或者为true的Protocol，并保存起来\n                for (ProtocolConfig config : protocolConfigMap.values()) {\n                    if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                        protocolConfigs.add(config);\n                    }\n                }\n                if (protocolConfigs != null && !protocolConfigs.isEmpty()) {\n                    super.setProtocols(protocolConfigs);\n                }\n            }\n        }\n        if (getPath() == null || getPath().length() == 0) {\n            //path服务名称为空的话\n            if (beanName != null && beanName.length() > 0\n                    && getInterface() != null && getInterface().length() > 0\n                    && beanName.startsWith(getInterface())) {\n                //使用beanName作为服务名称\n                setPath(beanName);\n            }\n        }\n        if (!isDelay()) {\n            //配置了delay属性，暴露服务(后面会分析该方法)\n            export();\n        }\n    }\n\n    @Override\n    public void destroy() throws Exception {\n        // This will only be called for singleton scope bean, and expected to be called by spring shutdown hook when BeanFactory/ApplicationContext destroys.\n        // We will guarantee dubbo related resources being released with dubbo shutdown hook.\n        //unexport();\n    }\n\n    // merged from dubbox\n    @Override\n    protected Class getServiceClass(T ref) {\n        if (AopUtils.isAopProxy(ref)) {\n            //从Aop代理类中获取到目标对象\n            return AopUtils.getTargetClass(ref);\n        }\n        return super.getServiceClass(ref);\n    }\n}\n```\n###### export方法\nexport方法是定义在ServiceBean的父类ServiceConfig中的\n```java\npublic synchronized void export() {\n\tif (provider != null) {\n\t    if (export == null) {\n\t\t//export属性为空的话，则获取provider中的export属性\n\t\texport = provider.getExport();\n\t    }\n\t    if (delay == null) {\n\t\t//delay属性为空的话，则获取provider中的delay属性\n\t\tdelay = provider.getDelay();\n\t    }\n\t}\n\tif (export != null && !export) {\n\t    //如果不暴露服务，直接返回\n\t    return;\n\t}\n\n\tif (delay != null && delay > 0) {\n\t    //delay大于0的话，会启动线程，延迟暴露服务\n\t    delayExportExecutor.schedule(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t    doExport();\n\t\t}\n\t    }, delay, TimeUnit.MILLISECONDS);\n\t} else {\n\t    //直接暴露服务\n\t    doExport();\n\t}\n}\n```\n可以看到最终会调用doExport方法进行服务暴露\n```java\nprotected synchronized void doExport() {\n\tif (unexported) {\n\t    //检测是否已经取消服务暴露\n\t    throw new IllegalStateException(\"Already unexported!\");\n\t}\n\tif (exported) {\n\t    //已经暴露过服务，直接返回\n\t    return;\n\t}\n\texported = true;\n\t//检查服务接口interface属性是否配置\n\tif (interfaceName == null || interfaceName.length() == 0) {\n\t    throw new IllegalStateException(\"<dubbo:service interface=\\\"\\\" /> interface not allow null!\");\n\t}\n\t//检测ProviderConfig是否已配置，没有配置则进行配置(此方法在\"Dubbo源码阅读之集成Spring(03)\"中介绍过)\n\tcheckDefault();\n\tif (provider != null) {\n\t    //从provider中获取缺失的配置\n\t    if (application == null) {\n\t\tapplication = provider.getApplication();\n\t    }\n\t    if (module == null) {\n\t\tmodule = provider.getModule();\n\t    }\n\t    if (registries == null) {\n\t\tregistries = provider.getRegistries();\n\t    }\n\t    if (monitor == null) {\n\t\tmonitor = provider.getMonitor();\n\t    }\n\t    if (protocols == null) {\n\t\tprotocols = provider.getProtocols();\n\t    }\n\t}\n\tif (module != null) {\n\t    //从module中获取注册中心和监控中心\n\t    if (registries == null) {\n\t\tregistries = module.getRegistries();\n\t    }\n\t    if (monitor == null) {\n\t\tmonitor = module.getMonitor();\n\t    }\n\t}\n\tif (application != null) {\n\t    //从application中获取注册中心和监控中心\n\t    if (registries == null) {\n\t\tregistries = application.getRegistries();\n\t    }\n\t    if (monitor == null) {\n\t\tmonitor = application.getMonitor();\n\t    }\n\t}\n\t//获取服务接口类interfaceClass\n\tif (ref instanceof GenericService) {\n\t    //服务接口为GenericService类型\n\t    interfaceClass = GenericService.class;\n\t    if (StringUtils.isEmpty(generic)) {\n\t\t//generic属性为空的话，则设置为true\n\t\tgeneric = Boolean.TRUE.toString();\n\t    }\n\t} else {\n\t    try {\n\t\t//加载interfaceName类\n\t\tinterfaceClass = Class.forName(interfaceName, true, Thread.currentThread()\n\t\t\t.getContextClassLoader());\n\t    } catch (ClassNotFoundException e) {\n\t\tthrow new IllegalStateException(e.getMessage(), e);\n\t    }\n\t    //检测方法列表methods是否都在接口interfaceClass中存在\n\t    checkInterfaceAndMethods(interfaceClass, methods);\n\t    //校验ref类(ref不可以为空，并且实现了interfaceClass接口)\n\t    checkRef();\n\t    //将generic属性设置成false\n\t    generic = Boolean.FALSE.toString();\n\t}\n\t//处理服务接口本地实现类\n\tif (local != null) {\n\t    if (\"true\".equals(local)) {\n\t\t//默认情况下，实现类名称为：interfaceName + \"Local\"\n\t\tlocal = interfaceName + \"Local\";\n\t    }\n\t    Class<?> localClass;\n\t    try {\n\t\t//加载实现类\n\t\tlocalClass = ClassHelper.forNameWithThreadContextClassLoader(local);\n\t    } catch (ClassNotFoundException e) {\t\n\t\t//没有找到该实现类\n\t\tthrow new IllegalStateException(e.getMessage(), e);\n\t    }\n\t    //校验服务接口本地实现类是否实现了interfaceClass接口\n\t    if (!interfaceClass.isAssignableFrom(localClass)) {\n\t\tthrow new IllegalStateException(\"The local implementation class \" + localClass.getName() + \" not implement interface \" + interfaceName);\n\t    }\n\t}\n\t//处理服务接口本地存根实现类\n\tif (stub != null) {\n\t    if (\"true\".equals(stub)) {\n\t\t//默认情况下，实现类名称为：interfaceName + \"Stub\"\n\t\tstub = interfaceName + \"Stub\";\n\t    }\n\t    Class<?> stubClass;\n\t    try {\n\t\t//加载实现类\n\t\tstubClass = ClassHelper.forNameWithThreadContextClassLoader(stub);\n\t    } catch (ClassNotFoundException e) {\n\t\tthrow new IllegalStateException(e.getMessage(), e);\n\t    }\n\t    //校验该存根类是否实现了interfaceClass接口\n\t    if (!interfaceClass.isAssignableFrom(stubClass)) {\n\t\tthrow new IllegalStateException(\"The stub implementation class \" + stubClass.getName() + \" not implement interface \" + interfaceName);\n\t    }\n\t}\n\t//检测ApplicationConfig是否为空(会调用appendProperties方法添加属性，该方法在之前博文介绍过)\n\tcheckApplication();\n\t//检测注册中心list是否为空(从配置文件中获取dubbo.registry.address属性，然后创建RegistryConfig对象，添加属性，放入到list中)\n\tcheckRegistry();\n\t//检测协议protocols是否为空，如果为空且provider不为空，则先从provider对象中获取\n\t//然后遍历protocols，处理name(name为空，则设置为dubbo)并添加属性。\n\tcheckProtocol();\n\t//为ServiceBean对象添加属性\n\tappendProperties(this);\n\t//检测local/stub/mock配置是否正确\n\t//local/stub/mock(mock 可配置为\"return \")应该为interfaceClass或者为interfaceClass子类\n\tcheckStubAndMock(interfaceClass);\n\t//服务名称path为空的话，则设置为interfaceName\n\tif (path == null || path.length() == 0) {\n\t    path = interfaceName;\n\t}\n\t//暴露url(后面会分析该方法)\n\tdoExportUrls();\n\t//根据服务唯一名称、当前ServiceBean实例、ref 创建ProviderModel实例(后面会分析)\n\tProviderModel providerModel = new ProviderModel(getUniqueServiceName(), this, ref);\n\t//根据服务唯一名称，注册提供者服务，即放到类ApplicationModel中的变量名为providedServices的map中\n\tApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);\n}\n```\n\n###### doExportUrls方法\n该方法内部会调用loadRegistries方法构造注册中心url地址，然后调用doExportUrlsFor1Protocol方法进行服务url的暴露。\n```java\n/**\n * 暴露url\n *\nprivate void doExportUrls() {\n\t//构造注册中心地址(后面会分析该方法)\n\t//例如：registry://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&dubbo=2.0.0&pid=6384&qos.port=22222&registry=multicast&timestamp=1528347455956\n\tList<URL> registryURLs = loadRegistries(true);\n\t\n\t//例如：<dubbo:protocol name=\"dubbo\" port=\"20880\" id=\"dubbo\" />\n\tfor (ProtocolConfig protocolConfig : protocols) {\n\t    //暴露服务url\t\n\t    doExportUrlsFor1Protocol(protocolConfig, registryURLs);\n\t}\n}\n\n/**\n * 构造注册中心URL\n * 优先使用系统配置中的注册中心列表，如果没有配置，则使用RegistryConfig中配置的\n * @param provider 是否是提供者\n * @return\n */\nprotected List<URL> loadRegistries(boolean provider) {\n\t//检测registries变量(即ArrayList<RegistryConfig>。<dubbo:registry address=\"...\" />）\n\tcheckRegistry();\n\tList<URL> registryList = new ArrayList<URL>();\n\t//遍历registries\n\tif (registries != null && !registries.isEmpty()) {\n\t    for (RegistryConfig config : registries) {\n\t\t//获取当前注册中心地址\n\t\tString address = config.getAddress();\n\t\tif (address == null || address.length() == 0) {\n\t\t    //将address设置为*\n\t\t    address = Constants.ANYHOST_VALUE;\n\t\t}\n\t\t//从系统属性中获取注册中心地址\n\t\tString sysaddress = System.getProperty(\"dubbo.registry.address\");\n\t\tif (sysaddress != null && sysaddress.length() > 0) {\n\t\t    //如果系统注册中心地址不为空，则优先使用系统注册中心地址\n\t\t    address = sysaddress;\n\t\t}\n\t\tif (address != null && address.length() > 0\n\t\t\t&& !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) {\n\t\t    //地址可用\n\n\t\t    Map<String, String> map = new HashMap<String, String>();\n\t\t    //附加参数，即找到application、config类中的属性，并添加到map中\n\t\t    appendParameters(map, application);\n\t\t    appendParameters(map, config);\n\t\t    //添加服务名称\n\t\t    map.put(\"path\", RegistryService.class.getName());\n\t\t    //添加dubbo版本\n\t\t    map.put(\"dubbo\", Version.getVersion());\n\t\t    //添加时间戳\n\t\t    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n\t\t    if (ConfigUtils.getPid() > 0) {\n\t\t\t//添加pid\n\t\t\tmap.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n\t\t    }\n\t\t    //添加protocol\n\t\t    if (!map.containsKey(\"protocol\")) {\n\t\t\t//存在扩展名称为remote的RegistryFactory，则设置protocol属性为remote，否则设置为dubbo\n\t\t\tif (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension(\"remote\")) {\n\t\t\t    map.put(\"protocol\", \"remote\");\n\t\t\t} else {\n\t\t\t    map.put(\"protocol\", \"dubbo\");\n\t\t\t}\n\t\t    }\n\t\t    //根据当前注册中心地址和map生产url列表（后面会分析该方法）\n\t\t    List<URL> urls = UrlUtils.parseURLs(address, map);\n\t\t    for (URL url : urls) {\n\t\t\t//向url中添加registry参数，参数值为url的protocol属性(例如：registry=multicast)\n\t\t\turl = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());\n\t\t\t//重新设置url的protocol属性值为“registry”(后面暴露服务时，将会使用该protocol属性值作为扩展名称，获取对应的Protocol实例，因此将会使用RegistryProtocol实例，下一节会详细分析)\n\t\t\turl = url.setProtocol(Constants.REGISTRY_PROTOCOL);\n\t\t\tif ((provider && url.getParameter(Constants.REGISTER_KEY, true))\n\t\t\t\t|| (!provider && url.getParameter(Constants.SUBSCRIBE_KEY, true))) {\n\t\t\t    //提供者 && url中的register参数值为true\n\t\t\t    //不是提供者 && url中的subscribe参数值为true\n\t\t\t    //则将该url添加到registryList列表中\n\t\t\t    registryList.add(url);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\treturn registryList;\n}\n\n/**\n * @param address 注册中心地址列表(\"|\"或者\";\"分隔)\n * @param defaults map参数\n * @return\n */\npublic static List<URL> parseURLs(String address, Map<String, String> defaults) {\n        if (address == null || address.length() == 0) {\n\t    //注册中心地址为空，返回null\n            return null;\n        }\n        //通过“|”或者“;”分隔注册中心地址\n        String[] addresses = Constants.REGISTRY_SPLIT_PATTERN.split(address);\n        if (addresses == null || addresses.length == 0) {\n            return null;\n        }\n        List<URL> registries = new ArrayList<URL>();\n\t//遍历每一个注册中心地址\n        for (String addr : addresses) {\n            //通过注册中心地址addr和map参数构造注册中心URL对象（后面会分析方法）\n            registries.add(parseURL(addr, defaults));\n        }\n\t//返回注册中心地址url列表\n        return registries;\n}\n\n/**\n * 生成注册中心URL\n * 1、根据注册中心地址address生成url字符串(处理备用地址)\n * 2、从defaults集合中获取属性(protocol、username、password、port、path)默认值\n * 3、根据defaults新生成集合defaultParameters，并移除(protocol、username、password、port、path)属性\n * 4、根据url字符串生成URL对象，并获取该URL对象的属性值(protocol、username、password、port、path、parameters),\n *    其中parameters属性值是新生成的一个map。\n * 5、判断URL对象的这些属性值(protocol、username、password、port、path、parameters)是否为空，如果为空，则使用属性默认值，并标识发生了改变。\n * 6、如果发生了改变。则根据新的属性值重新生成一个URL对象并返回。\n * @param address 注册中心地址(可能是多个，使用\",\"分隔)\n * @param defaults map参数\n * @return\n */\npublic static URL parseURL(String address, Map<String, String> defaults) {\n\tif (address == null || address.length() == 0) {\n\t    return null;\n\t}\n\t//该url最终会被解析成URL对象\n\tString url;\n\tif (address.indexOf(\"://\") >= 0) {\n\t    //该注册中心地址包含\"://\"\n\t    url = address;\n\t} else {\n\t    //使用逗号\",\"分隔address地址\n\t    String[] addresses = Constants.COMMA_SPLIT_PATTERN.split(address);\n\t    //将addresses数组第1个元素赋值给url\n\t    url = addresses[0];\n\t    if (addresses.length > 1) {\n\t\t//遍历addresses数组后面的元素(即查看是否存在备用的注册中心地址)\n\t\t//backup记录注册中心备用地址\n\t\tStringBuilder backup = new StringBuilder();\n\t\tfor (int i = 1; i < addresses.length; i++) {\n\t\t    if (i > 1) {\n\t\t\tbackup.append(\",\");\n\t\t    }\n\t\t    backup.append(addresses[i]);\n\t\t}\n\t\t//将注册中心备用地址添加到url的backup参数中\n\t\turl += \"?\" + Constants.BACKUP_KEY + \"=\" + backup.toString();\n\t    }\n\t}\n\t//从defaults中获取protocol属性\n\tString defaultProtocol = defaults == null ? null : defaults.get(\"protocol\");\n\tif (defaultProtocol == null || defaultProtocol.length() == 0) {\n\t    //如果protocol属性值为空，则设置为dubbo\n\t    defaultProtocol = \"dubbo\";\n\t}\n\t//从defaults中获取username属性和password属性\n\tString defaultUsername = defaults == null ? null : defaults.get(\"username\");\n\tString defaultPassword = defaults == null ? null : defaults.get(\"password\");\n\t//从defaults中获取port属性\n\tint defaultPort = StringUtils.parseInteger(defaults == null ? null : defaults.get(\"port\"));\n\t//从defaults中获取path属性\n\tString defaultPath = defaults == null ? null : defaults.get(\"path\");\n\t//根据defaults新生成一个map集合defaultParameters\n\tMap<String, String> defaultParameters = defaults == null ? null : new HashMap<String, String>(defaults);\n\tif (defaultParameters != null) {\n\t    //移除defaultParameters集合中的以下属性\n\t    defaultParameters.remove(\"protocol\");\n\t    defaultParameters.remove(\"username\");\n\t    defaultParameters.remove(\"password\");\n\t    defaultParameters.remove(\"host\");\n\t    defaultParameters.remove(\"port\");\n\t    defaultParameters.remove(\"path\");\n\t}\n\t//根据url字符串生成URL对象\n\tURL u = URL.valueOf(url);\n\t//如果新生成的URL中的某属性值为空，且该属性的默认值不为空，则意味着发生了改变，changed会被设置为true\n\tboolean changed = false;\n\t\n\t//获取URL对象中的protocol、username、password、host、port、path属性\n\tString protocol = u.getProtocol();\n\tString username = u.getUsername();\n\tString password = u.getPassword();\n\tString host = u.getHost();\n\tint port = u.getPort();\n\tString path = u.getPath();\n\t\n\t//获取URL对象的参数map\n\tMap<String, String> parameters = new HashMap<String, String>(u.getParameters());\n\tif ((protocol == null || protocol.length() == 0) && defaultProtocol != null && defaultProtocol.length() > 0) {\n\t    changed = true;\n\t    //使用protocol默认值设置URL的protocol属性\n\t    protocol = defaultProtocol;\n\t}\n\tif ((username == null || username.length() == 0) && defaultUsername != null && defaultUsername.length() > 0) {\n\t    changed = true;\n\t    //使用username默认值设置URL的username属性\n\t    username = defaultUsername;\n\t}\n\tif ((password == null || password.length() == 0) && defaultPassword != null && defaultPassword.length() > 0) {\n\t    changed = true;\n\t    //使用password默认值设置URL的password属性\n\t    password = defaultPassword;\n\t}\n\t/*if (u.isAnyHost() || u.isLocalHost()) {\n\t    changed = true;\n\t    host = NetUtils.getLocalHost();\n\t}*/\n\tif (port <= 0) {\n\t    //URL的port属性值小于0，且默认的port值大于0，则使用defaultPort设置URL的port属性\n\t    if (defaultPort > 0) {\n\t\tchanged = true;\n\t\tport = defaultPort;\n\t    } else {\n\t\t//默认port如果也小于0的话，则设置URL的port属性为9090\n\t\tchanged = true;\n\t\tport = 9090;\n\t    }\n\t}\n\tif (path == null || path.length() == 0) {\n\t    //使用默认服务名称设置URL的path属性\n\t    if (defaultPath != null && defaultPath.length() > 0) {\n\t\tchanged = true;\n\t\tpath = defaultPath;\n\t    }\n\t}\n\t//遍历默认参数集合\n\tif (defaultParameters != null && defaultParameters.size() > 0) {\n\t    for (Map.Entry<String, String> entry : defaultParameters.entrySet()) {\n\t\t//默认参数key\n\t\tString key = entry.getKey();\n\t\t//默认参数值defaultValue\n\t\tString defaultValue = entry.getValue();\n\t\tif (defaultValue != null && defaultValue.length() > 0) {\n\t\t    //查看URL参数集合中该参数key对应的值\n\t\t    String value = parameters.get(key);\n\t\t    if (value == null || value.length() == 0) {\n\t\t\t//如果URL中的参数值为空，则使用该参数key的默认值defaultValue\n\t\t\tchanged = true;\n\t\t\tparameters.put(key, defaultValue);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (changed) {\n\t    //当前URL的属性值发送改变了，则重新生成一个URL对象\n\t    u = new URL(protocol, username, password, host, port, path, parameters);\n\t}\n\treturn u;\n}\n```\n加载注册中心URL地址的方法分析完了，我们再来看doExportUrlsFor1Protocol方法\n```java\n/**\n * 暴露服务Url到各个注册中心\n * 1、map装配参数\n * 2、利用map中的参数构建URL，为暴露服务做准备\n * 3、根据范围选择是暴露本地服务，还是暴露远程服务\n * 4、根据代理工厂生成服务代理对象invoker\n * 5、根据配置的协议，暴露服务代理\n * @param protocolConfig 例如: <dubbo:protocol name=\"dubbo\" port=\"20880\" id=\"dubbo\" />\n * @param registryURLs 例如: registry://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&dubbo=2.0.0&pid=4328&qos.port=22222&registry=multicast&timestamp=1528278313174\n */\nprivate void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> registryURLs) {\n\t//获取协议名称\n\tString name = protocolConfig.getName();\n\tif (name == null || name.length() == 0) {\n\t    name = \"dubbo\";\n\t}\n\tMap<String, String> map = new HashMap<String, String>();\n\t//添加side参数，值为provider，标识服务提供端\n\tmap.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);\n\t//添加dubbo版本\n\tmap.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());\n\t//添加时间戳\n\tmap.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n\tif (ConfigUtils.getPid() > 0) {\n\t    //添加pid\n\t    map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n\t}\n\t//添加参数到map\n\tappendParameters(map, application);\n\tappendParameters(map, module);\n\tappendParameters(map, provider, Constants.DEFAULT_KEY);\n\tappendParameters(map, protocolConfig);\n\t//当前ServiceConfig(ServiceBean)\n\tappendParameters(map, this);\n\n\tif (methods != null && !methods.isEmpty()) {\n\t    //遍历服务方法\n\t    for (MethodConfig method : methods) {\n\t\t//将method的属性添加到map中\n\t\tappendParameters(map, method, method.getName());\n\t\t//设置方法重试次数(retryKey是map的key)\n\t\tString retryKey = method.getName() + \".retry\";\n\t\tif (map.containsKey(retryKey)) {\n\t\t    String retryValue = map.remove(retryKey);\n\t\t    if (\"false\".equals(retryValue)) {\n\t\t        //retryValue值为false的话，说明不启用重试\n\t\t\tmap.put(method.getName() + \".retries\", \"0\");\n\t\t    }\n\t\t}\n\t\t//获取当前服务方法的参数\n\t\tList<ArgumentConfig> arguments = method.getArguments();\n\t\tif (arguments != null && !arguments.isEmpty()) {\n\t\t    //遍历当前服务方法的参数配置\n\t\t    for (ArgumentConfig argument : arguments) {\n\t\t\tif (argument.getType() != null && argument.getType().length() > 0) {\n\t\t\t    //遍历服务接口的方法列表\n\t\t\t    Method[] methods = interfaceClass.getMethods();\n\t\t\t    if (methods != null && methods.length > 0) {\n\t\t\t\tfor (int i = 0; i < methods.length; i++) {\n\t\t\t\t    //方法名\n\t\t\t\t    String methodName = methods[i].getName();\n\t\t\t\t    if (methodName.equals(method.getName())) {\n\t\t\t\t\t//方法名称一样,获取方法参数类型数组\n\t\t\t\t\tClass<?>[] argtypes = methods[i].getParameterTypes();\n\t\t\t\t\t// one callback in the method\n\t\t\t\t\tif (argument.getIndex() != -1) {\n\t\t\t\t\t    //校验参数的类型是否匹配\n\t\t\t\t\t    if (argtypes[argument.getIndex()].getName().equals(argument.getType())) {\n\t\t\t\t\t\t//将方法的参数的属性添加到map，前缀为：方法名.参数索引\n\t\t\t\t\t\tappendParameters(map, argument, method.getName() + \".\" + argument.getIndex());\n\t\t\t\t\t    } else {\n\t\t\t\t\t\t//参数配置错误，索引和类型不匹配\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"argument config error : the index attribute and type attribute not match :index :\" + argument.getIndex() + \", type:\" + argument.getType());\n\t\t\t\t\t    }\n\t\t\t\t\t} else {\n\t\t\t\t\t    // multiple callbacks in the method\n\t\t\t\t\t    for (int j = 0; j < argtypes.length; j++) {\n\t\t\t\t\t\t//当前参数类型\n\t\t\t\t\t\tClass<?> argclazz = argtypes[j];\n\t\t\t\t\t\t//参数类型名称匹配\n\t\t\t\t\t\tif (argclazz.getName().equals(argument.getType())) {\n\t\t\t\t\t\t    appendParameters(map, argument, method.getName() + \".\" + j);\n\t\t\t\t\t\t    if (argument.getIndex() != -1 && argument.getIndex() != j) {\n\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"argument config error : the index attribute and type attribute not match :index :\" + argument.getIndex() + \", type:\" + argument.getType());\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t}\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t} else if (argument.getIndex() != -1) {\n\t\t\t    appendParameters(map, argument, method.getName() + \".\" + argument.getIndex());\n\t\t\t} else {\n\t\t\t    //<dubbo:argument index='0' .../> or <dubbo:argument type=xxx .../>\n\t\t\t    throw new IllegalArgumentException(\"argument config must set index or type attribute.eg: <dubbo:argument index='0' .../> or <dubbo:argument type=xxx .../>\");\n\t\t\t}\n\n\t\t    }\n\t\t}\n\t    } // end of methods for\n\t}\n\t//(generic ！= null) && (generic = “true” || \"nativejava\" || \"bean\") 返回 true\n\tif (ProtocolUtils.isGeneric(generic)) {\n\t    //添加generic参数\n\t    map.put(Constants.GENERIC_KEY, generic);\n\t    //添加methods参数，值为\"*\"\n\t    map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);\n\t} else {\n\t    String revision = Version.getVersion(interfaceClass, version);\n\t    if (revision != null && revision.length() > 0) {\n\t        //添加版本\n\t\tmap.put(\"revision\", revision);\n\t    }\n\t    //生成interfaceClass类的包装类，获取方法名称\n\t    String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();\n\t    if (methods.length == 0) {\n\t\t//服务接口中没有发现方法定义\n\t\tlogger.warn(\"NO method found in service interface \" + interfaceClass.getName());\n\t\t//添加methods参数，值为\"*\"\n\t\tmap.put(Constants.METHODS_KEY, Constants.ANY_VALUE);\n\t    } else {\n\t\t//添加methods参数，值为逗号分隔的方法名称\n\t\tmap.put(Constants.METHODS_KEY, StringUtils.join(new HashSet<String>(Arrays.asList(methods)), \",\"));\n\t    }\n\t}\n\tif (!ConfigUtils.isEmpty(token)) {\n\t    //token为true或者token为default，则isDefault方法返回true\n\t    if (ConfigUtils.isDefault(token)) {\n\t\t//添加token参数，值为uuid\n\t\tmap.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());\n\t    } else {\n\t\t//添加token参数\n\t\tmap.put(Constants.TOKEN_KEY, token);\n\t    }\n\t}\n\t//判断协议名称是否为\"injvm\"\n\tif (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) {\n\t    //本地协议，不注册\n\t    protocolConfig.setRegister(false);\n\t    //添加notify参数，值为false\n\t    map.put(\"notify\", \"false\");\n\t}\n\t//暴露服务\n\t//获取上下文地址\n\tString contextPath = protocolConfig.getContextpath();\n\tif ((contextPath == null || contextPath.length() == 0) && provider != null) {\n\t    //获取provider对象配置的上下文地址\n\t    contextPath = provider.getContextpath();\n\t}\n\t//获取注册ip(后面会分析该方法)\n\tString host = this.findConfigedHosts(protocolConfig, registryURLs, map);\n\t//获取注册端口(后面会分析该方法)\n\tInteger port = this.findConfigedPorts(protocolConfig, name, map);\n\t//根据协议名称name、主机host、端口port、上下文、map参数构建URL对象(服务暴露的url地址)\n\t//例如url：dubbo://192.168.99.60:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=192.168.99.60&bind.port=20880&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello&pid=7184&qos.port=22222&side=provider&timestamp=1528347825839\n\tURL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? \"\" : contextPath + \"/\") + path, map);\n\t//查看ConfiguratorFactory(override/absent)是否存在url.getProtocol()扩展，存在的话，则配置该url对象\n\t//override会覆盖参数配置，absent只有参数不存在时才会添加(后面的章节会介绍该扩展)\n\tif (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class).hasExtension(url.getProtocol())) {\n\t    url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)\n\t\t    .getExtension(url.getProtocol()).getConfigurator(url).configure(url);\n\t}\n\t//获取url的scope参数\n\tString scope = url.getParameter(Constants.SCOPE_KEY);\n\t\n\t//只有scope != none 时才会暴露服务，scope = null时会同时暴露本地服务和远程服务\n\tif (!Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) {\n\t    //scope != remote 暴露本地服务\n\t    if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) {\n\t\t//本地暴露(后面小节会分析该方法)\n\t\texportLocal(url);\n\t    }\n\t    if (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) {\n\t         //scope != local 暴露到远程\n\t\tif (logger.isInfoEnabled()) {\n\t\t    //暴露dubbo服务interfaceClass到url\n\t\t    logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to url \" + url);\n\t\t}\n\t\tif (registryURLs != null && !registryURLs.isEmpty()) {\n\t\t    //注册中心地址registryURLs不为空，则遍历注册中心地址，将服务暴露到各个注册中心\n\t\t    for (URL registryURL : registryURLs) {\n\t\t\t\n\t\t\t//添加dynamic参数到url中，参数值从当前注册中心的参数中获取\n\t\t\turl = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));\n\t\t\t\n\t\t\t//构造监控url(后面会分析该方法)\n\t\t\tURL monitorUrl = loadMonitor(registryURL);\n\t\t\tif (monitorUrl != null) {\n\t\t\t    //添加monitor参数(编码)到url中\n\t\t\t    url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());\n\t\t\t}\n\t\t\t\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t    //注册dubbo服务 interfaceClass的url 到注册中心registryURL上\n\t\t\t    logger.info(\"Register dubbo service \" + interfaceClass.getName() + \" url \" + url + \" to registry \" + registryURL);\n\t\t\t}\n\t\t\t\n\t\t\t//registryURL地址上添加export参数，参数值为服务暴露的url(即interfaceClass的url)\n\t\t\t//根据ref、interfaceClass、registryURL创建服务代理对象Invoker(后面小节会分析该方法)\n\t\t\tInvoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));\n\t\t\t\n\t\t\t//将invoker和当前对象this包装成DelegateProviderMetaDataInvoker对象(后面小节会分析该方法)\n\t\t\tDelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\t\t\t\n\t\t\t//在此处开始暴露服务\n\t\t\t//调用export方法暴露服务，得到exporter对象(后面小节会分析该方法)\n\t\t\tExporter<?> exporter = protocol.export(wrapperInvoker);\n\t\t\t//保存暴露的服务到本地变量exporters中\n\t\t\texporters.add(exporter);\n\t\t    }\n\t\t} else {\n\t\t    //注册中心地址registryURLs为空\n\t\t    Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);\n\t\t    DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\t\t    Exporter<?> exporter = protocol.export(wrapperInvoker);\n\t\t    exporters.add(exporter);\n\t\t}\n\t    }\n\t}\n\t//保存暴露的服务url\n\tthis.urls.add(url);\n}\n```\n我们依次看下上面用到的方法: findConfigedHosts、findConfigedPorts、loadMonitor\nexportLocal、getInvoker、export方法将在后面的章节(Dubbo源码阅读之服务暴露)进行详细介绍。\n```java\n/**\n * 为服务提供者 获取注册ip和绑定ip，可以单独配置\n * Register & bind IP address for service provider, can be configured separately.\n * Configuration priority:\n * environment variables -> java system properties -> host property in config file ->\n * /etc/hosts -> default network address -> first available network address\n * @param protocolConfig\n * @param registryURLs\n * @param map\n * @return 注册ip\n */\nprivate String findConfigedHosts(ProtocolConfig protocolConfig, List<URL> registryURLs, Map<String, String> map) {\n\tboolean anyhost = false;\n\t//从系统配置中获取获取绑定ip\n\tString hostToBind = getValueFromConfig(protocolConfig, Constants.DUBBO_IP_TO_BIND);\n\tif (hostToBind != null && hostToBind.length() > 0 && isInvalidLocalHost(hostToBind)) {\n\t    //无效的ip\n\t    throw new IllegalArgumentException(\"Specified invalid bind ip from property:\" + Constants.DUBBO_IP_TO_BIND + \", value:\" + hostToBind);\n\t}\n\tif (hostToBind == null || hostToBind.length() == 0) {\n\t    //从协议配置中获取服务ip地址\n\t    hostToBind = protocolConfig.getHost();\n\t    if (provider != null && (hostToBind == null || hostToBind.length() == 0)) {\n\t\t//从服务提供者中获取服务ip地址\n\t\thostToBind = provider.getHost();\n\t    }\n\t    if (isInvalidLocalHost(hostToBind)) {\n\t\t//仍然是无效的地址，则设置anyhost=true\n\t\tanyhost = true;\n\t\ttry {\n\t\t    //获取本地地址\n\t\t    hostToBind = InetAddress.getLocalHost().getHostAddress();\n\t\t} catch (UnknownHostException e) {\n\t\t    logger.warn(e.getMessage(), e);\n\t\t}\n\t\tif (isInvalidLocalHost(hostToBind)) {\n\t\t    //仍然是无效的地址，遍历注册中心url列表\n\t\t    if (registryURLs != null && !registryURLs.isEmpty()) {\n\t\t\tfor (URL registryURL : registryURLs) {\n\t\t\t    if (Constants.MULTICAST.equalsIgnoreCase(registryURL.getParameter(\"registry\"))) {\n\t\t\t\t// 跳过组播registry，因为我们不可以通过Socket连接到它\n\t\t\t\tcontinue;\n\t\t\t    }\n\t\t\t    try {\n\t\t\t\tSocket socket = new Socket();\n\t\t\t\ttry {\n\t\t\t\t    //根据注册中心host和port构建SocketAddress\n\t\t\t\t    SocketAddress addr = new InetSocketAddress(registryURL.getHost(), registryURL.getPort());\n\t\t\t\t    //连接到该地址\n\t\t\t\t    socket.connect(addr, 1000);\n\t\t\t\t    //连接成功的话，则获取到绑定地址，并跳出循环\n\t\t\t\t    hostToBind = socket.getLocalAddress().getHostAddress();\n\t\t\t\t    break;\n\t\t\t\t} finally {\n\t\t\t\t    try {\n\t\t\t\t\tsocket.close();\n\t\t\t\t    } catch (Throwable e) {\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    } catch (Exception e) {\n\t\t\t\tlogger.warn(e.getMessage(), e);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (isInvalidLocalHost(hostToBind)) {\n\t\t\t//仍然为无效本地地址的话，则使用本地地址\n\t\t\thostToBind = getLocalHost();\n\t\t    }\n\t\t}\n\t    }\n\t}\n\t//添加bind.ip参数\n\tmap.put(Constants.BIND_IP_KEY, hostToBind);\n\t// 默认情况下，注册ip不用于绑定ip\n\t// 获取注册ip\n\tString hostToRegistry = getValueFromConfig(protocolConfig, Constants.DUBBO_IP_TO_REGISTRY);\n\tif (hostToRegistry != null && hostToRegistry.length() > 0 && isInvalidLocalHost(hostToRegistry)) {\n\t    throw new IllegalArgumentException(\"Specified invalid registry ip from property:\" + Constants.DUBBO_IP_TO_REGISTRY + \", value:\" + hostToRegistry);\n\t} else if (hostToRegistry == null || hostToRegistry.length() == 0) {\n\t    //默认情况下，绑定ip用于注册ip\n\t    hostToRegistry = hostToBind;\n\t}\n\t//添加anyhost参数\n\tmap.put(Constants.ANYHOST_KEY, String.valueOf(anyhost));\n\treturn hostToRegistry;\n}\n\n/**\n * 为服务提供者 获取注册端口和绑定端口\n * Register port and bind port for the provider, can be configured separately\n * Configuration priority:\n * environment variable -> java system properties -> port property in protocol config file\n * -> protocol default port\n * @param protocolConfig\n * @param name\n * @return 注册端口\n */\nprivate Integer findConfigedPorts(ProtocolConfig protocolConfig, String name, Map<String, String> map) {\n\tInteger portToBind = null;\n\n\t//从系统配置中获取绑定端口\n\tString port = getValueFromConfig(protocolConfig, Constants.DUBBO_PORT_TO_BIND);\n\tportToBind = parsePort(port);\n\n\tif (portToBind == null) {\n\t    //从协议配置中获取绑定端口\n\t    portToBind = protocolConfig.getPort();\n\t    if (provider != null && (portToBind == null || portToBind == 0)) {\n\t\t//从服务提供者中获取绑定端口\n\t\tportToBind = provider.getPort();\n\t    }\n\t    //根据协议名称获取默认绑定端口\n\t    final int defaultPort = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(name).getDefaultPort();\n\t    if (portToBind == null || portToBind == 0) {\n\t\tportToBind = defaultPort;\n\t    }\n\t    if (portToBind == null || portToBind <= 0) {\n\t\t//获取随机端口\n\t\tportToBind = getRandomPort(name);\n\t\tif (portToBind == null || portToBind < 0) {\n\t\t    //获取可用端口\n\t\t    portToBind = getAvailablePort(defaultPort);\n\t\t    //设置随机端口(放入map缓存)\n\t\t    putRandomPort(name, portToBind);\n\t\t}\n\t\tlogger.warn(\"Use random available port(\" + portToBind + \") for protocol \" + name);\n\t    }\n\t}\n\t//保存绑定端口，稍后用作url的key\n\tmap.put(Constants.BIND_PORT_KEY, String.valueOf(portToBind));\n\t// registry port, not used as bind port by default\n\tString portToRegistryStr = getValueFromConfig(protocolConfig, Constants.DUBBO_PORT_TO_REGISTRY);\n\tInteger portToRegistry = parsePort(portToRegistryStr);\n\tif (portToRegistry == null) {\n\t    //注册端口使用绑定端口\n\t    portToRegistry = portToBind;\n\t}\n\treturn portToRegistry;\n}\n\n/**\n * 构造监控URL\n * @param registryURL 注册中心URL\n * @return\n */\nprotected URL loadMonitor(URL registryURL) {\n\tif (monitor == null) {\n\t    //获取监控地址、监控协议配置\n\t    String monitorAddress = ConfigUtils.getProperty(\"dubbo.monitor.address\");\n\t    String monitorProtocol = ConfigUtils.getProperty(\"dubbo.monitor.protocol\");\n\t    if ((monitorAddress == null || monitorAddress.length() == 0) && (monitorProtocol == null || monitorProtocol.length() == 0)) {\n\t\t//如果监控地址和监控协议为空，则返回Null\n\t\treturn null;\n\t    }\n\t    //构造监控配置对象(地址、协议)\n\t    monitor = new MonitorConfig();\n\t    if (monitorAddress != null && monitorAddress.length() > 0) {\n\t\tmonitor.setAddress(monitorAddress);\n\t    }\n\t    if (monitorProtocol != null && monitorProtocol.length() > 0) {\n\t\tmonitor.setProtocol(monitorProtocol);\n\t    }\n\t}\n\t//添加属性\n\tappendProperties(monitor);\n\t//参数\n\tMap<String, String> map = new HashMap<String, String>();\n\t//添加interface参数\n\tmap.put(Constants.INTERFACE_KEY, MonitorService.class.getName());\n\t//添加dubbo版本\n\tmap.put(\"dubbo\", Version.getVersion());\n\t//添加时间戳\n\tmap.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n\tif (ConfigUtils.getPid() > 0) {\n\t    //添加pid\n\t    map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n\t}\n\t//添加monitor属性\n\tappendParameters(map, monitor);\n\t//获取monitor地址，优先使用系统配置值\n\tString address = monitor.getAddress();\n\tString sysaddress = System.getProperty(\"dubbo.monitor.address\");\n\tif (sysaddress != null && sysaddress.length() > 0) {\n\t    address = sysaddress;\n\t}\n\tif (ConfigUtils.isNotEmpty(address)) {\n\t    if (!map.containsKey(Constants.PROTOCOL_KEY)) {\n\t\t//协议地址不为空，且map中不包含protocol属性时，则设置protocol\n\t\tif (ExtensionLoader.getExtensionLoader(MonitorFactory.class).hasExtension(\"logstat\")) {\n\t\t    //包含logstat扩展\n\t\t    map.put(Constants.PROTOCOL_KEY, \"logstat\");\n\t\t} else {\n\t\t    //添加protocol属性\n\t\t    map.put(Constants.PROTOCOL_KEY, \"dubbo\");\n\t\t}\n\t    }\n\t    //生成URL对象\n\t    return UrlUtils.parseURL(address, map);\n\t} else if (Constants.REGISTRY_PROTOCOL.equals(monitor.getProtocol()) && registryURL != null) {\n\t    //监控address为空\n\t    //registryURL不为空，且monitor的协议为registry注册中心协议\n\t    return registryURL.setProtocol(\"dubbo\")\n\t\t    //添加protocol属性为registry\n\t\t    .addParameter(Constants.PROTOCOL_KEY, \"registry\")\n\t\t    //添加refer属性，属性值为map参数\n\t\t    .addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map));\n\t}\n\treturn null;\n}\n```\n\n由于本小节主要是讲ServiceAnnotationBeanPostProcessor类实现，关于服务暴露的内容将会放到下一小节介绍。\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之集成Spring-标签解析(02)","url":"/blog/2018/08/04/Dubbo源码阅读之集成Spring-02标签解析/","content":">本小节将会介绍dubbo标签的解析.\n\n上节讲到Dubbo解析标签的类是DubboBeanDefinitionParser,现在我们就来分析下该类,该类实现了Spring的BeanDefinitionParser接口，我们需要实现它的parse方法:\n\n### DubboBeanDefinitionParser解析类\n```java\npublic class DubboBeanDefinitionParser implements BeanDefinitionParser{\n \n    private static final Pattern GROUP_AND_VERION = Pattern.compile(\"^[\\\\-.0-9_a-zA-Z]+(\\\\:[\\\\-.0-9_a-zA-Z]+)?$\");\n    \n    //带解析实例化的bean类\n    private final Class<?> beanClass;\n    \n    //是否必填\n    private final boolean required;\n\n    public DubboBeanDefinitionParser(Class<?> beanClass, boolean required) {\n        this.beanClass = beanClass;\n        this.required = required;\n    }\n\n    @Override\n    public BeanDefinition parse(Element element, ParserContext parserContext) {\n        //调用了内部的parse方法\n        return parse(element, parserContext, beanClass, required);\n    }\n   \n    private static BeanDefinition parse(Element element, ParserContext parserContext,\n                                        Class<?> beanClass, boolean required) {\n        //创建RootBeanDefinition实例\n        RootBeanDefinition beanDefinition = new RootBeanDefinition();\n        //设置要实例化的类\n        beanDefinition.setBeanClass(beanClass);\n        //是否延迟初始化\n        beanDefinition.setLazyInit(false);\n        \n        //获取元素的id属性作为bean的id\n        String id = element.getAttribute(\"id\");\n        if ((id == null || id.length() == 0) && required) {\n            //如果id属性为空，并且是必填的，则取元素的name属性\n            String generatedBeanName = element.getAttribute(\"name\");\n            if (generatedBeanName == null || generatedBeanName.length() == 0) {\n                //如果name属性为空，则生成一个bean名称\n                //判断当前要实例化的bean类是否是ProtocolConfig类（即当前是否为<dubbo:protocol>标签）\n                if (ProtocolConfig.class.equals(beanClass)) {\n                    //当前是ProtocolConfig类，则设置bean名称为dubbo\n                    generatedBeanName = \"dubbo\";\n                } else {\n                    //不是ProtocolConfig类,则使用interface属性做为bean的名称\n                    generatedBeanName = element.getAttribute(\"interface\");\n                }\n            }\n            //如果bean名称为空，则使用当前实例化的类的名称\n            if (generatedBeanName == null || generatedBeanName.length() == 0) {\n                generatedBeanName = beanClass.getName();\n            }\n            //同时将bean的id属性设置为bean的名称\n            id = generatedBeanName;\n            int counter = 2;\n            //如果上下文中已经存在该id，则对该bean的id做防重处理\n            while (parserContext.getRegistry().containsBeanDefinition(id)) {\n                id = generatedBeanName + (counter++);\n            }\n        }\n        if (id != null && id.length() > 0) {\n            //如果id属性不为空，则校验Spring中是否已存在该id\n            if (parserContext.getRegistry().containsBeanDefinition(id)) {\n                throw new IllegalStateException(\"Duplicate spring bean id \" + id);\n            }\n            //通过id注册该bean\n            parserContext.getRegistry().registerBeanDefinition(id, beanDefinition);\n            //设置bean的id属性值\n            beanDefinition.getPropertyValues().addPropertyValue(\"id\", id);\n        }\n        //进一步解析<dubbo:protocol/>标签\n        //如：<dubbo:protocol name=\"dubbo\" port=\"20880\"/>\n        if (ProtocolConfig.class.equals(beanClass)) {\n            //如果当前要实例化的bean是ProtocolConfig类，则遍历Spring所有已经注册的bean的名称\n            for (String name : parserContext.getRegistry().getBeanDefinitionNames()) {\n                //根据bean名称获取已注册的bean定义\n                BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name);\n                //查看已注册的bean定义中是否存在protocol属性\n                PropertyValue property = definition.getPropertyValues().getPropertyValue(\"protocol\");\n                if (property != null) {\n                    //存在protocol属性，则获取protocol属性值\n                    Object value = property.getValue();\n                    //如果protocol属性值为ProtocolConfig类型，并且当前实例化的bean的id等于protocol属性值的name属性值的话，\n                    //则将当前实例化的bean包装成RuntimeBeanReference类型\n                    //然后将已注册的bean的protocol属性的值设为刚才新创建的RuntimeBeanReference\n                    //也就是说将当前解析的bean（ProtocolConfig）设置到其他已注册的bean的protocol属性中\n                    if (value instanceof ProtocolConfig && id.equals(((ProtocolConfig) value).getName())) {\n                        definition.getPropertyValues().addPropertyValue(\"protocol\", new RuntimeBeanReference(id));\n                    }\n                }\n            }\n        } else if (ServiceBean.class.equals(beanClass)) {\n            //进一步解析<dubbo:service/>标签，这里的逻辑就是处理下面的第二种配置\n            //如：<dubbo:service protocol=\"dubbo\" ref=\"userService\" interface=\"org.dubbo.service.UserInterface\" retries=\"0\" />\n            //   <bean id=\"userService\" class=\"org.dubbo.service.impl.UserServiceImpl\" />\n            //和如下配置相同\n            //<dubbo:service interface=\"org.dubbo.service.UserInterface\" class=\"org.dubbo.service.impl.UserServiceImpl\" protocol=\"dubbo\" retries=\"0\">\n            //   <property name=\"name\" value=\"dubbo\" ref=\"\"/>\n            //   <property name=\"age\" value=\"5\" ref=\"\"/>\n            //</dubbo:service>\n\n            //如果当前要实例化的bean是ServiceBean类,则获取class属性并解析\n            String className = element.getAttribute(\"class\");\n            if (className != null && className.length() > 0) {\n                //如果class属性不为空，则实例化该class属性指定的类\n                RootBeanDefinition classDefinition = new RootBeanDefinition();\n                classDefinition.setBeanClass(ReflectUtils.forName(className));\n                classDefinition.setLazyInit(false);\n                //解析子标签元素(即上面例子中的property属性)(后面会介绍parseProperties方法)\n                parseProperties(element.getChildNodes(), classDefinition);\n                //为当前待实例化的bean定义增加ref属性值（即class属性对应的bean，id为 beanId + impl）\n                beanDefinition.getPropertyValues().addPropertyValue(\"ref\", new BeanDefinitionHolder(classDefinition, id + \"Impl\"));\n            }\n        } else if (ProviderConfig.class.equals(beanClass)) {\n            //进一步处理<dubbo:provider/>标签(后面会分析parseNested方法)\n            parseNested(element, parserContext, ServiceBean.class, true, \"service\", \"provider\", id, beanDefinition);\n        } else if (ConsumerConfig.class.equals(beanClass)) {\n            //进一步处理<dubbo:consumer/>标签的子标签<dubbo:reference/>\n            parseNested(element, parserContext, ReferenceBean.class, false, \"reference\", \"consumer\", id, beanDefinition);\n        }\n        \n\t//当前待实例化的bean的所有的属性(通过set方法获取到)\n        Set<String> props = new HashSet<String>();\n        ManagedMap parameters = null;\n        //遍历待实例化类的所有方法,找到set方法\n        for (Method setter : beanClass.getMethods()) {\n            \n            String name = setter.getName();\n            \n            //找到set方法，条件如下：方法名长度大于3，以set开头，是public修饰符，参数类型长度为1\n            if (name.length() > 3 && name.startsWith(\"set\")\n                    && Modifier.isPublic(setter.getModifiers())\n                    && setter.getParameterTypes().length == 1) {\n               \n                 //获取参数类型\n                Class<?> type = setter.getParameterTypes()[0];\n\n                //如setFirstName(String firstName)方法\n                //将会得到property=first-name\n                String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), \"-\");\n          \n\t        //将属性名称添加到props集合中\n                props.add(property);\n               \n                //获取到属性的get方法\n                Method getter = null;\n               \n                try {\n                    getter = beanClass.getMethod(\"get\" + name.substring(3), new Class<?>[0]);\n                } catch (NoSuchMethodException e) {\n                    try {\n                        //如果没有找到get方法，则尝试找到isXXX方法\n                        getter = beanClass.getMethod(\"is\" + name.substring(3), new Class<?>[0]);\n                    } catch (NoSuchMethodException e2) {\n                    }\n                }\n                if (getter == null\n                        || !Modifier.isPublic(getter.getModifiers())\n                        || !type.equals(getter.getReturnType())) {\n                    //如果get方法为空、不是public限定符、或者get方法返回值和set方法参数类型不一致的话，\n                    //则跳过该property的处理，进行下一个property的处理\n                    continue;\n                }\n                if (\"parameters\".equals(property)) {\n                    //如果当前property为parameters，则解析当前元素的子元素(<dubbo:parameter>标签)(后面会分析parseParameters方法)\n                    parameters = parseParameters(element.getChildNodes(), beanDefinition);\n                } else if (\"methods\".equals(property)) {\n                    //如果当前property为methods，则解析当前元素的子元素(<dubbo:method>标签)(后面会分析parseMethods方法)\n                    parseMethods(id, element.getChildNodes(), beanDefinition, parserContext);\n                } else if (\"arguments\".equals(property)) {\n                    //如果当前property为arguments，则解析当前元素的子元素(<dubbo:argument>标签)(后面会分析parseArguments方法)\n                    parseArguments(id, element.getChildNodes(), beanDefinition, parserContext);\n                } else {\n                    //从xml定义中获取property属性值\n                    String value = element.getAttribute(property);\n                    if (value != null) {\n                        value = value.trim();\n                        if (value.length() > 0) {\n                            if (\"registry\".equals(property) && RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(value)) {\n                                //如果当前属性为registry，并且属性值为N/A\n                                //则为当前bean定义添加属性registry，并且属性值为RegistryConfig对象(该对象的address属性值为不可用)\n                                RegistryConfig registryConfig = new RegistryConfig();\n                                registryConfig.setAddress(RegistryConfig.NO_AVAILABLE);\n                                beanDefinition.getPropertyValues().addPropertyValue(property, registryConfig);\n                            } else if (\"registry\".equals(property) && value.indexOf(',') != -1) {\n                                //如果当前属性为registry，并且属性值包含逗号\",\",即有多个值，则进一步解析(后面会分析parseMultiRef方法)\n                                parseMultiRef(\"registries\", value, beanDefinition, parserContext);\n                            } else if (\"provider\".equals(property) && value.indexOf(',') != -1) {\n                                //如果当前属性为providers，并且属性值包含逗号\",\",即有多个值，则进一步解析\n                                parseMultiRef(\"providers\", value, beanDefinition, parserContext);\n                            } else if (\"protocol\".equals(property) && value.indexOf(',') != -1) {\n                                //如果当前属性为protocol，并且属性值包含逗号\",\",即有多个值，则进一步解析\n                                parseMultiRef(\"protocols\", value, beanDefinition, parserContext);\n                            } else {\n                                Object reference;\n                                //判断set方法的参数类型是否是原始类型\n                                if (isPrimitive(type)) {\n                                     if (\"async\".equals(property) && \"false\".equals(value)\n                                            || \"timeout\".equals(property) && \"0\".equals(value)\n                                            || \"delay\".equals(property) && \"0\".equals(value)\n                                            || \"version\".equals(property) && \"0.0.0\".equals(value)\n                                            || \"stat\".equals(property) && \"-1\".equals(value)\n                                            || \"reliable\".equals(property) && \"false\".equals(value)) {\n                                        // backward compatibility for the default value in old version's xsd\n                                        //兼容老版本\n\t\t\t\t\tvalue = null;\n                                    }\n\t\t\t\t    //原始类型，直接只用xml中配置的属性值\n                                    reference = value;\n                                } else if (\"protocol\".equals(property)\n                                        //属性名为protocol，并且当前存在该属性值对应的扩展\n                                        && ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(value)\n                                        //当前上下文不包含扩展的bean定义\n                                        //该扩展bean的类名称不等于ProtocolConfig类名称\n                                        && (!parserContext.getRegistry().containsBeanDefinition(value)\n                                        || !ProtocolConfig.class.getName().equals(parserContext.getRegistry().getBeanDefinition(value).getBeanClassName()))) {\n                                    //如果元素标签名称为dubbo:provider，则提示使用dubbo:protocol进行替换\n                                    if (\"dubbo:provider\".equals(element.getTagName())) {\n                                        logger.warn(\"Recommended replace <dubbo:provider protocol=\\\"\" + value + \"\\\" ... /> to <dubbo:protocol name=\\\"\" + value + \"\\\" ... />\");\n                                    }\n                                    // backward compatibility 向后兼容\n                                    // 设置协议名称为value\n                                    ProtocolConfig protocol = new ProtocolConfig();\n                                    protocol.setName(value);\n                                    //设置reference值为protocol\n                                    reference = protocol;\n                                } else if (\"onreturn\".equals(property)) {\n                                    //获取\".\"在属性值中最后出现的位置\n                                    int index = value.lastIndexOf(\".\");\n                                    \n \t\t\t\t     //截取value从首字符到index字符\n                                    String returnRef = value.substring(0, index);\n                                    \n\t\t\t\t    //从index+1字符开始进行截取\n                                    String returnMethod = value.substring(index + 1);\n\t\t\t\t\t\n\t\t\t\t    //包装成RuntimeBeanReference\n                                    reference = new RuntimeBeanReference(returnRef);\n                                    \n \t\t\t\t    //为当前bean定义增加属性onreturnMethod\n                                    beanDefinition.getPropertyValues().addPropertyValue(\"onreturnMethod\", returnMethod);\n                                } else if (\"onthrow\".equals(property)) {\n                                   //处理onthrow属性 \n\t\t\t\t   int index = value.lastIndexOf(\".\");\n                                   String throwRef = value.substring(0, index);\n                                   String throwMethod = value.substring(index + 1);\n                                    \n\t\t\t\t   reference = new RuntimeBeanReference(throwRef);\n                                   \n\t\t\t\t    //为当前bean定义增加属性onthrowMethod\n                                    beanDefinition.getPropertyValues().addPropertyValue(\"onthrowMethod\", throwMethod);\n                                } else if (\"oninvoke\".equals(property)) {\n                                    int index = value.lastIndexOf(\".\");\n                                    String invokeRef = value.substring(0, index);\n                                    String invokeRefMethod = value.substring(index + 1);\n                                    \n\t\t\t\t    reference = new RuntimeBeanReference(invokeRef);\n                                    //为当前bean定义增加属性oninvokeMethod\n                                    beanDefinition.getPropertyValues().addPropertyValue(\"oninvokeMethod\", invokeRefMethod);\n                                }else {\n                                    //如果当前属性为ref，并且当前上下文中包含属性值value对应的bean定义\n                                    if (\"ref\".equals(property) && parserContext.getRegistry().containsBeanDefinition(value)) {\n                                        //获取属性值value对应的bean定义\n                                        BeanDefinition refBean = parserContext.getRegistry().getBeanDefinition(value);\n                                        //检测是否是单例\n                                        if (!refBean.isSingleton()) {\n                                            //暴露的服务ref值必须是单例\n                                            throw new IllegalStateException(\"The exported service ref \" + value + \" must be singleton! Please set the \" + value + \" bean scope to singleton, eg: <bean id=\\\"\" + value + \"\\\" scope=\\\"singleton\\\" ...>\");\n                                        }\n                                    }\n                                    reference = new RuntimeBeanReference(value);\n                                }\n                                //为当前bean定义添加属性property，属性值为reference\n                                beanDefinition.getPropertyValues().addPropertyValue(property, reference);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        //获取元素的所有属性\n        NamedNodeMap attributes = element.getAttributes();\n\t//属性数量\n        int len = attributes.getLength();\n        //遍历所有属性，看看是否有不再set属性集合中的元素，如果有，则将他们添加到自定义参数map中，然后设置当前待实例化bean的parameters参数\n        for (int i = 0; i < len; i++) {\n            Node node = attributes.item(i);\n            String name = node.getLocalName();\n            //如果当前set属性集合中不包含该属性，则将该属性以及属性值添加到自定义parameters中\n            if (!props.contains(name)) {\n                if (parameters == null) {\n                    parameters = new ManagedMap();\n                }\n                //获取该节点属性值\n                String value = node.getNodeValue();\n                //将值包装成TypedStringValue类型，并放入自定义参数map中\n                parameters.put(name, new TypedStringValue(value, String.class));\n            }\n        }\n        if (parameters != null) {\n            //为当前bean定义添加属性parameters\n            beanDefinition.getPropertyValues().addPropertyValue(\"parameters\", parameters);\n        }\n\t//返回bean定义\n        return beanDefinition;\n    }\n\n}\n```\n#### parseProperties方法\n\n```java\n/**\n* 解析子标签元素\n* @param nodeList\n* @param beanDefinition 待实例化的bean\n*/\nprivate static void parseProperties(NodeList nodeList, RootBeanDefinition beanDefinition) {\n\t\n\t//<dubbo:service interface=\"org.dubbo.service.UserInterface\" class=\"org.dubbo.service.impl.UserService\" protocol=\"dubbo\" retries=\"0\">\n   \t//\t<property name=\"name\" value=\"dubbo\" ref=\"\"/>\n   \t//\t<property name=\"age\" value=\"5\" ref=\"\"/>\n\t//</dubbo:service>\n\tif (nodeList != null && nodeList.getLength() > 0) {\n\t   //遍历所有property节点 \n\t   for (int i = 0; i < nodeList.getLength(); i++) {\n\t\t//当前节点\n\t\tNode node = nodeList.item(i);\n\t\tif (node instanceof Element) {\n\t\t    //如果节点名称为property或者节点限定名称为property\n\t\t    if (\"property\".equals(node.getNodeName())\n\t\t\t    || \"property\".equals(node.getLocalName())) {\n\t\t\t\n\t\t\t//获取property节点的name属性\n\t\t\tString name = ((Element) node).getAttribute(\"name\");\n\t\t\tif (name != null && name.length() > 0) {\n\t\t\t    //获取property节点的value属性\n\t\t\t    String value = ((Element) node).getAttribute(\"value\");\n\t\t\t   \n\t\t\t    //获取property节点的ref属性\n\t\t\t    String ref = ((Element) node).getAttribute(\"ref\");\n\t\t\t    \n\t\t\t    if (value != null && value.length() > 0) {\n\t\t\t\t//为bean定义设置属性以及属性值\n\t\t\t\tbeanDefinition.getPropertyValues().addPropertyValue(name, value);\n\t\t\t    } else if (ref != null && ref.length() > 0) {\n\t\t\t\t//为bean定义设置属性以及属性值（引用）\n\t\t\t\tbeanDefinition.getPropertyValues().addPropertyValue(name, new RuntimeBeanReference(ref));\n\t\t\t    } else {\n\t\t\t\t//不支持的子标签\n\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported <property name=\\\"\" + name + \"\\\"> sub tag, Only supported <property name=\\\"\" + name + \"\\\" ref=\\\"...\\\" /> or <property name=\\\"\" + name + \"\\\" value=\\\"...\\\" />\");\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n}\n```\n\n#### parseNested方法\n\n```java\nparseNested(element, parserContext, ServiceBean.class, true, \"service\", \"provider\", id, beanDefinition);\nparseNested(element, parserContext, ReferenceBean.class, false, \"reference\", \"consumer\", id, beanDefinition);\n\n\n\n/**\n* 解析嵌套标签\n* 即：\n*   <dubbo:provider>\n*        <dubbo:service interface=\"\">\n*            <dubbo:method name=\"\"></dubbo:method>\n*        </dubbo:service>\n*        <dubbo:service interface=\"\">\n*            <dubbo:method name=\"\"></dubbo:method>\n*        </dubbo:service>\n*   </dubbo:provider>\n* @param element  当前元素：<dubbo:provider>\n* @param parserContext 上下文\n* @param beanClass  ServiceBean.class/ReferenceBean.class\n* @param required   true/false\n* @param tag   标签      service/reference\n* @param property 属性   provider/consumer\n* @param ref   待实例化bean的Id\n* @param beanDefinition 待实例化bean定义\n*/\nprivate static void parseNested(Element element, ParserContext parserContext, Class<?> beanClass,\n\t\t\t    boolean required, String tag, String property, \n\t\t\t    String ref,BeanDefinition beanDefinition) {\n        //获取当前元素的子节点\n\tNodeList nodeList = element.getChildNodes();\n\tif (nodeList != null && nodeList.getLength() > 0) {\n\t    boolean first = true;\n\t    //遍历子节点\n\t    for (int i = 0; i < nodeList.getLength(); i++) {\n\t\t//当前子节点\n\t\tNode node = nodeList.item(i);\n\t\tif (node instanceof Element) {\n\t\t    //如果当前子节点的名称等于tag\n\t\t    if (tag.equals(node.getNodeName())\n\t\t\t    || tag.equals(node.getLocalName())) {\n\t\t\t//是否第一个子节点\n\t\t\tif (first) {\n\t\t\t    first = false;\n\t\t\t    //获取当前元素default属性\n\t\t\t    String isDefault = element.getAttribute(\"default\");\n\t\t\t    if (isDefault == null || isDefault.length() == 0) {\n\t\t\t\t//如果default属性为空，则为bean定义增加default属性，并将属性值设置成false\n\t\t\t\tbeanDefinition.getPropertyValues().addPropertyValue(\"default\", \"false\");\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t        //调用parse方法递归解析beanClass（即ServiceBean.class/ReferenceBean.class）\n\t\t\tBeanDefinition subDefinition = parse((Element) node, parserContext, beanClass, required);\n\t\t\t\n\t\t\t//如果子bean不为空，且ref不为空，则为子bean增加property属性(provider/consumer)(即将父bean设置进去,ref参数)\n\t\t\tif (subDefinition != null && ref != null && ref.length() > 0) {\n\t\t\t    subDefinition.getPropertyValues().addPropertyValue(property, new RuntimeBeanReference(ref));\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n}\n```\n#### parseParameters方法\n```java\n/**\n* 当前property为parameters，解析参数标签 <dubbo:parameter>\n* @param nodeList 所有子节点列表\n* @param beanDefinition 当前待实例化的bean\n* @return 自定义参数集合\n*/\nprivate static ManagedMap parseParameters(NodeList nodeList, RootBeanDefinition beanDefinition) {\n\tif (nodeList != null && nodeList.getLength() > 0) {\n\t    \n\t    ManagedMap parameters = null;\n            \n\t    //遍历子节点\n\t    for (int i = 0; i < nodeList.getLength(); i++) {\n\t\t\n\t\tNode node = nodeList.item(i);\n\t\t\n\t\tif (node instanceof Element) {\n\t\t    \n\t\t    //如果子节点名称是parameter\n\t\t    if (\"parameter\".equals(node.getNodeName())\n\t\t\t    || \"parameter\".equals(node.getLocalName())) {\n\t\t\t\n\t\t\tif (parameters == null) {\n\t\t\t    parameters = new ManagedMap();\n\t\t\t}\n\t\t\t\n\t\t\t//获取子节点的key属性、value属性、hide属性\n\t\t\tString key = ((Element) node).getAttribute(\"key\");\n\t\t\tString value = ((Element) node).getAttribute(\"value\");\n\t\t\tboolean hide = \"true\".equals(((Element) node).getAttribute(\"hide\"));\n\t\t\t\n\t\t\tif (hide) {\n\t\t\t    //如果需要隐藏的话，则修改key属性的值\n\t\t\t    key = Constants.HIDE_KEY_PREFIX + key;\n\t\t\t}\n\t\t\t\n\t\t\t//保存参数信息\n\t\t\tparameters.put(key, new TypedStringValue(value, String.class));\n\t\t    }\n\t\t}\n\t    }\n\t    return parameters;\n\t}\n\treturn null;\n}\n```\n\n#### parseMethods方法\n```java\n\n/**\n *\n * 当前property为methods，解析<dubbo:method>标签\n * @param id 当前待实例化的bean-id\n * @param nodeList 所有子节点列表\n * @param beanDefinition 待实例化bean\n * @param parserContext\n */\nprivate static void parseMethods(String id, NodeList nodeList, \n\t\t\t\tRootBeanDefinition beanDefinition,\n\t\t\t\tParserContext parserContext) {\n\n\tif (nodeList != null && nodeList.getLength() > 0) {\n\t    ManagedList methods = null;\n\t    \n\t    //遍历子节点列表\n\t    for (int i = 0; i < nodeList.getLength(); i++) {\n\t\t\n\t\tNode node = nodeList.item(i);\n\t\t\n\t\tif (node instanceof Element) {\n        if (ProtocolConfig.class.equals(beanClass)) {\n            //如果当前要实例化的bean是ProtocolConfig类，则遍历Spring所有已经注册的bean的名称\n            for (String name : parserContext.getRegistry().getBeanDefinitionNames()) {\n                //根据bean名称获取已注册的bean定义\n                BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name);\n                //查看已注册的bean定义中是否存在protocol属性\n                PropertyValue property = definition.getPropertyValues().getPropertyValue(\"protocol\");\n                if (property != null) {\n                    //存在protocol属性，则获取protocol属性值\n                    Object value = property.getValue();\n                    //如果protocol属性值为ProtocolConfig类型，并且当前实例化的bean的id等于protocol属性值的name属性值的话，\n                    //则将当前实例化的bean包装成RuntimeBeanReference类型\n                    //然后将已注册的bean的protocol属性的值设为刚才新创建的RuntimeBeanReference\n                    //也就是说将当前解析的bean（ProtocolConfig）设置到其他已注册的bean的protocol属性中\n                    if (value instanceof ProtocolConfig && id.equals(((ProtocolConfig) value).getName())) {\n                        definition.getPropertyValues().addPropertyValue(\"protocol\", new RuntimeBeanReference(id));\n                    }\n                }\n            }\n        } else if (ServiceBean.class.equals(beanClass)) {\n            //进一步解析<dubbo:service/>标签，这里的逻辑就是处理下面的第二种配置\n            //如：<dubbo:service protocol=\"dubbo\" ref=\"userService\" interface=\"org.dubbo.service.UserInterface\" retries=\"0\" />\n            //   <bean id=\"userService\" class=\"org.dubbo.service.impl.UserServiceImpl\" />\n            //和如下配置相同\n            //<dubbo:service interface=\"org.dubbo.service.UserInterface\" class=\"org.dubbo.service.impl.UserServiceImpl\" protocol=\"dubbo\" retries=\"0\">\n            //   <property name=\"name\" value=\"dubbo\" ref=\"\"/>\n            //   <property name=\"age\" value=\"5\" ref=\"\"/>\n            //</dubbo:service>\n\n            //如果当前要实例化的bean是ServiceBean类,则获取class属性并解析\n            String className = element.getAttribute(\"class\");\n            if (className != null && className.length() > 0) {\n                //如果class属性不为空，则实例化该class属性指定的类\n                RootBeanDefinition classDefinition = new RootBeanDefinition();\n                classDefinition.setBeanClass(ReflectUtils.forName(className));\n                classDefinition.setLazyInit(false);\n                //解析子标签元素(即上面例子中的property属性)(后面会介绍parseProperties方法)\n                parseProperties(element.getChildNodes(), classDefinition);\n                //为当前待实例化的bean定义增加ref属性值（即class属性对应的bean，id为 beanId + impl）\n                beanDefinition.getPropertyValues().addPropertyValue(\"ref\", new BeanDefinitionHolder(classDefinition, id + \"Impl\"));\n            }\n        } else if (ProviderConfig.class.equals(beanClass)) {\n            //进一步处理<dubbo:provider/>标签(后面会分析parseNested方法)\n            parseNested(element, parserContext, ServiceBean.class, true, \"service\", \"provider\", id, beanDefinition);\n        } else if (ConsumerConfig.class.equals(beanClass)) {\n            //进一步处理<dubbo:consumer/>标签的子标签<dubbo:reference/>\n            parseNested(element, parserContext, ReferenceBean.class, false, \"reference\", \"consumer\", id, beanDefinition);\n        }\n        \n\t//当前待实例化的bean的所有的属性(通过set方法获取到)\n        Set<String> props = new HashSet<String>();\n        ManagedMap parameters = null;\n        //遍历待实例化类的所有方法,找到set方法\n        for (Method setter : beanClass.getMethods()) {\n            \n            String name = setter.getName();\n            \n            //找到set方法，条件如下：方法名长度大于3，以set开头，是public修饰符，参数类型长度为1\n            if (name.length() > 3 && name.startsWith(\"set\")\n                    && Modifier.isPublic(setter.getModifiers())\n                    && setter.getParameterTypes().length == 1) {\n               \n                 //获取参数类型\n                Class<?> type = setter.getParameterTypes()[0];\n\n                //如setFirstName(String firstName)方法\n                //将会得到property=first-name\n                String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), \"-\");\n          \n\t        //将属性名称添加到props集合中\n                props.add(property);\n               \n                //获取到属性的get方法\n                Method getter = null;\n               \n                try {\n                    getter = beanClass.getMethod(\"get\" + name.substring(3), new Class<?>[0]);\n                } catch (NoSuchMethodException e) {\n                    try {\n                        //如果没有找到get方法，则尝试找到isXXX方法\n                        getter = beanClass.getMethod(\"is\" + name.substring(3), new Class<?>[0]);\n                    } catch (NoSuchMethodException e2) {\n                    }\n                }\n                if (getter == null\n                        || !Modifier.isPublic(getter.getModifiers())\n                        || !type.equals(getter.getReturnType())) {\n                    //如果get方法为空、不是public限定符、或者get方法返回值和set方法参数类型不一致的话，\n                    //则跳过该property的处理，进行下一个property的处理\n                    continue;\n                }\n                if (\"parameters\".equals(property)) {\n                    //如果当前property为parameters，则解析当前元素的子元素(<dubbo:parameter>标签)(后面会分析parseParameters方法)\n                    parameters = parseParameters(element.getChildNodes(), beanDefinition);\n                } else if (\"methods\".equals(property)) {\n                    //如果当前property为methods，则解析当前元素的子元素(<dubbo:method>标签)(后面会分析parseMethods方法)\n                    parseMethods(id, element.getChildNodes(), beanDefinition, parserContext);\n                } else if (\"arguments\".equals(property)) {\n                    //如果当前property为arguments，则解析当前元素的子元素(<dubbo:argument>标签)(后面会分析parseArguments方法)\n                    parseArguments(id, element.getChildNodes(), beanDefinition, parserContext);\n                } else {\n                    //从xml定义中获取property属性值\n                    String value = element.getAttribute(property);\n                    if (value != null) {\n                        value = value.trim();\n                        if (value.length() > 0) {\n                            if (\"registry\".equals(property) && RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(value)) {\n                                //如果当前属性为registry，并且属性值为N/A\n                                //则为当前bean定义添加属性registry，并且属性值为RegistryConfig对象(该对象的address属性值为不可用)\n                                RegistryConfig registryConfig = new RegistryConfig();\n                                registryConfig.setAddress(RegistryConfig.NO_AVAILABLE);\n                                beanDefinition.getPropertyValues().addPropertyValue(property, registryConfig);\n                            } else if (\"registry\".equals(property) && value.indexOf(',') != -1) {\n                                //如果当前属性为registry，并且属性值包含逗号\",\",即有多个值，则进一步解析(后面会分析parseMultiRef方法)\n                                parseMultiRef(\"registries\", value, beanDefinition, parserContext);\n                            } else if (\"provider\".equals(property) && value.indexOf(',') != -1) {\n                                //如果当前属性为providers，并且属性值包含逗号\",\",即有多个值，则进一步解析\n                                parseMultiRef(\"providers\", value, beanDefinition, parserContext);\n                            } else if (\"protocol\".equals(property) && value.indexOf(',') != -1) {\n                                //如果当前属性为protocol，并且属性值包含逗号\",\",即有多个值，则进一步解析\n                                parseMultiRef(\"protocols\", value, beanDefinition, parserContext);\n                            } else {\n                                Object reference;\n                                //判断set方法的参数类型是否是原始类型\n                                if (isPrimitive(type)) {\n                                     if (\"async\".equals(property) && \"false\".equals(value)\n                                            || \"timeout\".equals(property) && \"0\".equals(value)\n\t\t\t    \n\t\t    //当前节点的名称为\"method\"\n\t\t    if (\"method\".equals(node.getNodeName()) || \"method\".equals(node.getLocalName())) {\n\t\t\t\n\t\t\t//获取当前节点的name属性\n\t\t\tString methodName = element.getAttribute(\"name\");\n\t\t\t\n\t\t\tif (methodName == null || methodName.length() == 0) {\n\t\t\t    //name属性不可以为空\n\t\t\t    throw new IllegalStateException(\"<dubbo:method> name attribute == null\");\n\t\t\t}\n\t\t\t\n\t\t\tif (methods == null) {\n\t\t\t    methods = new ManagedList();\n\t\t\t}\n\t\t\t\n\t\t\t//调用parse方法递归解析MethodConfig.class\n\t\t\tBeanDefinition methodBeanDefinition = parse(((Element) node),\n\t\t\t\tparserContext, \n\t\t\t\tMethodConfig.class, \n\t\t\t\tfalse\n\t\t\t);\n\t\t\t\n\t\t\t//新生成的bean的名称\n\t\t\tString name = id + \".\" + methodName;\n\t\t\t\n\t\t\t//将bean名称和bean定义关联起来\n\t\t\tBeanDefinitionHolder methodBeanDefinitionHolder = new BeanDefinitionHolder(\n\t\t\t\tmethodBeanDefinition, name);\n\t\t\t//保存新生成的bean\n\t\t\tmethods.add(methodBeanDefinitionHolder);\n\t\t    }\n\t\t}\n\t    }\n\t    if (methods != null) {\n\t\t//为待实例化的bean添加methods属性\n\t\tbeanDefinition.getPropertyValues().addPropertyValue(\"methods\", methods);\n\t    }\n\t}\n}\n\n```\n\n#### parseArguments方法\n```java\n/**\n* 当前property为arguments，解析<dubbo:argument>标签\n* @param id  当前待实例化的bean-id\n* @param nodeList 子节点列表\n* @param beanDefinition 当前待实例化的bean\n* @param parserContext\n*/\nprivate static void parseArguments(String id, NodeList nodeList, RootBeanDefinition beanDefinition,\n\t\t\t       ParserContext parserContext) {\n\n\tif (nodeList != null && nodeList.getLength() > 0) {\n\t    \n\t    ManagedList arguments = null;\n\n\t    //遍历子节点\n\t    for (int i = 0; i < nodeList.getLength(); i++) {\n\t\t\n\t\tNode node = nodeList.item(i);\n\n\t\tif (node instanceof Element) {\n\t\t    \n\t\t    Element element = (Element) node;\n\n\t\t    //当前子节点名称为argument\n\t\t    if (\"argument\".equals(node.getNodeName()) || \"argument\".equals(node.getLocalName())) {\n\t\t\t\n\t\t\t//获取当前子节点的index属性\n\t\t\tString argumentIndex = element.getAttribute(\"index\");\n\t\t\t\n\t\t\tif (arguments == null) {\n\t\t\t    arguments = new ManagedList();\n\t\t\t}\n\n\t\t\t//调用parse方法递归解析ArgumentConfig.class\n\t\t\tBeanDefinition argumentBeanDefinition = parse(((Element) node),\n\t\t\t\tparserContext, \n\t\t\t\tArgumentConfig.class, \n\t\t\t\tfalse\n\t\t\t);\n\n\t\t\t//新生成的bean的名称\n\t\t\tString name = id + \".\" + argumentIndex;\n\n\t\t\t//将新生成的bean名称和bean定义关联起来\n\t\t\tBeanDefinitionHolder argumentBeanDefinitionHolder = new BeanDefinitionHolder(\n\t\t\t\targumentBeanDefinition, name);\n        if (!beanDefinitionRegistry.containsBeanDefinition(beanName)) {\n            //该bean还没有注册的话，则进行注册\n\t    RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType);\n            \n\t    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n            \n\t    beanDefinitionRegistry.registerBeanDefinition(beanName, beanDefinition);\n        }\n    }\n}\n```\n\nDubboBeanDefinitionParser解析类就介绍完毕了，最后给一个的parse方法的处理流程图.\n![](img/DubboBeanDefinitionParser.png)\n\n\n\n\n\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之集成Spring标签配置类(01)","url":"/blog/2018/08/04/Dubbo源码阅读之集成Spring-01标签配置类/","content":"\n>本小节将会介绍下如何在Spring环境中使用Dubbo，以及Dubbo标签实体类\n\n* Spring中使用Dubbo的Demo\n* Dubbo标签解析\n\n\n### Spring中使用Dubbo的Demo\n我们先来看下Dubbo源码中dubbo-demo包中的例子。\n\n#### dubbo-demo-api\n首先在dubbo-demo-api模块中定义了一个接口：\n```java\npublic interface DemoService {\n    String sayHello(String name);\n}\n```\n\n然后在dubbo-demo-provider模块和dubbo-demo-consumer模块中分别引入dubbo-demo-api模块。\n\n#### dubbo-demo-provider\n我们先来看下dubbo-demo-provider服务提供端,新建一个DemoService接口的实现类DemoServiceImpl：\n```java\npublic class DemoServiceImpl implements DemoService {\n    @Override\n    public String sayHello(String name) {\n        System.out.println(\"[\" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()) + \"] Hello \" + name + \", request from consumer: \" + RpcContext.getContext().getRemoteAddress());\n        return \"Hello \" + name + \", response from provider: \" + RpcContext.getContext().getLocalAddress();\n    }\n}\n```\n然后在Spring配置文件中进行配置：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\"\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd\n       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\">\n    \n    <dubbo:application name=\"demo-provider\"/>\n    \n    <dubbo:registry address=\"multicast://224.5.6.7:1234\"/>\n    \n    <dubbo:protocol name=\"dubbo\" port=\"20880\"/>\n    \n    <bean id=\"demoService\" class=\"com.alibaba.dubbo.demo.provider.DemoServiceImpl\"/>\n    \n    <!--暴露服务-->\n    <dubbo:service interface=\"com.alibaba.dubbo.demo.DemoService\" ref=\"demoService\"/>\n</beans>\n```\n可以看到我们首先在配置文件中引入了dubbo自定义的schema文件，然后我们就可以在配置文件中使用dubbo自定义的标签了。这些标签我们后面会讲解。\n接下来我们新建一个Provider类，该类用来加载Spring配置文件，同时也启动了我们的服务器：\n```java\npublic class Provider {\n\n    public static void main(String[] args) throws Exception {\n        System.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n        //加载Spring配置\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{\"META-INF/spring/dubbo-demo-provider.xml\"});\n        context.start();\n        System.in.read(); // press any key to exit\n    }\n}\n```\n\n#### dubbo-demo-consumer\n\n我们在消费者端同样需要配置Spring配置文件：\n```xml\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\"\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd\n       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\">\n\n    <dubbo:application name=\"demo-consumer\"/>\n\n    <dubbo:registry address=\"multicast://224.5.6.7:1234\"/>\n    \n    <!--引用DemoService服务-->\n    <dubbo:reference id=\"demoService\" check=\"false\" interface=\"com.alibaba.dubbo.demo.DemoService\"/>\n\n</beans>\n```\n接着我们新建一个Consumer类：\n```java\npublic class Consumer {\n\n    public static void main(String[] args) {\n        System.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{\"META-INF/spring/dubbo-demo-consumer.xml\"});\n        context.start();\n\n        //获取远程服务代理\n        DemoService demoService = (DemoService) context.getBean(\"demoService\");\n       \n        while (true) {\n            try {\n                Thread.sleep(1000);\n                //调用远程服务方法\n                String hello = demoService.sayHello(\"world\");\n                //输出调用结果\n                System.out.println(hello);\n            } catch (Throwable throwable) {\n                throwable.printStackTrace();\n            }\n        }\n    }\n}\n```\n启动起来服务器和客户端，我们就可以看到输出结果了。经过上面的例子，我们可以看到使用Dubbo调用远程服务就像调用本地的服务一样简单。后面我们将详细介绍Dubbo是如何做到这些的。\n\n\n### Dubbo标签解析\n\n总体上Dubbo是通过自定义Spring标签，然后解析这些标签，将这些标签属性映射成一个个配置类，接着将这些类配置到Spring工厂，交给Spring容器来管理的方式来和Spring整合到一起的。\n这部分源码主要在dubbo-config包中，我们先看下Spring自定义标签的机制以及Dubbo标签对应的实体类，下一小节在具体分析如何解析标签。\n\n#### Spring自定义标签\n在dubbo-config-spring模块的resources目录下有三个文件，分别为：dubbo.xsd、spring.handlers、spring.schemas。\ndubbo.xsd文件中定义了所有支持的dubbo标签，spring.schemas文件中则指定了dubbo.xsd文件：\n```java\nhttp\\://dubbo.apache.org/schema/dubbo/dubbo.xsd=META-INF/dubbo.xsd\n```\n因此，我们需要分别在服务器、客户端的spring配置文件中引入该xsd文件，才可以使用dubbo标签。\n而spring.handlers文件中则指定了解析dubbo标签的类:\n```java\nhttp\\://dubbo.apache.org/schema/dubbo=com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler\n```\n我们就以com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler类作为入口，看看dubbo是如何解析标签的。\n\n我们来看下DubboNamespaceHandler类，该类继承自Spring的NamespaceHandlerSupport类，通过实现init方法来将dubbo标签节点和解析类进行关联：\n```java\npublic class DubboNamespaceHandler extends NamespaceHandlerSupport {\n    static {\n        //检测是否有重复的DubboNamespaceHandler类，这里不会抛异常，只会打印错误日志\n        Version.checkDuplicate(DubboNamespaceHandler.class);\n    }\n\n    /**\n     * 将节点名和解析类关联起来，NamespaceHandler通过节点名会找到相应的解析类\n     */\n    @Override\n    public void init() {\n        registerBeanDefinitionParser(\"application\", new DubboBeanDefinitionParser(ApplicationConfig.class, true));\n        registerBeanDefinitionParser(\"module\", new DubboBeanDefinitionParser(ModuleConfig.class, true));\n        registerBeanDefinitionParser(\"registry\", new DubboBeanDefinitionParser(RegistryConfig.class, true));\n        registerBeanDefinitionParser(\"monitor\", new DubboBeanDefinitionParser(MonitorConfig.class, true));\n        registerBeanDefinitionParser(\"provider\", new DubboBeanDefinitionParser(ProviderConfig.class, true));\n        registerBeanDefinitionParser(\"consumer\", new DubboBeanDefinitionParser(ConsumerConfig.class, true));\n        registerBeanDefinitionParser(\"protocol\", new DubboBeanDefinitionParser(ProtocolConfig.class, true));\n        registerBeanDefinitionParser(\"service\", new DubboBeanDefinitionParser(ServiceBean.class, true));\n        registerBeanDefinitionParser(\"reference\", new DubboBeanDefinitionParser(ReferenceBean.class, false));\n        registerBeanDefinitionParser(\"annotation\", new AnnotationBeanDefinitionParser());\n    }\n}\n```\n可以看到这里定义了dubbo标签的解析类DubboBeanDefinitionParser，同时也定义了该标签对应的bean(即xxxConfig类、xxxBean类)，这些bean最终交由Spring容器来管理。在介绍它们之前，我们先看一些通用的注解类,这些注解可以添加在bean类中的方法上，在解析标签的时候会用上这些注解。\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD})\npublic @interface Parameter {\n\n    String key() default \"\";\n\n    boolean required() default false;\n\n    /**\n     * 是否排除该方法\n     * @return\n     */\n    boolean excluded() default false;\n\n    /**\n     * 是否编码\n     * @return\n     */\n    boolean escaped() default false;\n\n    /**\n     * 属性为false的话，则不执行附加属性方法\n     * @return\n     */\n    boolean attribute() default false;\n\n    boolean append() default false;\n}\n```\n\n#### Dubbo标签对应的实体类\n在dubbo-config-api模块下的com.alibaba.dubbo.config包中定义了dubbo标签对应的实体类，我们先了解下这些实体类，然后再看如何解析它们。\n\n##### ApplicationConfig\n我们对照着使用方法一起看下：\n```xml\n <!--dubbo:application中可配置的属性都定义在ApplicationConfig实体类中-->\n <dubbo:application name=\"demo-provider\"/>\n```\nApplicationConfig类继承自AbstractConfig抽象类，该抽象类提供了一些解析配置的公共方法。\n```java\npublic class ApplicationConfig extends AbstractConfig {\n\n    private static final long serialVersionUID = 5508512956753757169L;\n\n    /**\n     * 服务治理（必填）\n     * 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样，\n     * 此参数不是匹配条件，你当前项目叫什么名字就填什么，和提供者消费者角色无关\n     * application\n     */\n    private String name;\n\n    /**\n     * 服务治理\n     * 当前应用模块版本\n     * application.version\n     */\n    private String version;\n\n    /**\n     * 服务治理\n     * 应用负责人，用于服务治理，请填写负责人公司邮箱前缀\n     * owner\n     */\n    private String owner;\n\n    /**\n     * 服务治理\n     * 组织名称(BU或部门)，用于注册中心区分服务来源，此配置项建议不要使用autoconfig，直接写死在配 置中，比如 china,intl,itu,crm,asc,dw,aliexpress 等\n     * organization\n     */\n    private String organization;\n\n    /**\n     * 服务治理\n     * 用于服务分层对应的架构。如，intl、china。不同的架构使用不同的分层\n     * architecture\n     */\n    private String architecture;\n\n    /**\n     * 服务治理\n     * 环境，例如：dev、test、production\n     * environment\n     */\n    private String environment;\n\n    /**\n     * 性能优化（javassist）\n     * Java字节码编译器，用于动态类的生成，可选：jdk或javassist\n     * compiler \n     */\n    private String compiler;\n\n    /**\n     * 性能优化（slf4j）\n     * 日志输出方式，可选： slf4j,jcl,log4j,jdk\n     * logger\n     */\n    private String logger;\n\n    /**\n     * 注册中心列表\n     */\n    private List<RegistryConfig> registries;\n\n    /**\n     * 监控中心\n     */\n    private MonitorConfig monitor;\n\n    /**\n     * 是否是默认的\n     */\n    private Boolean isDefault;\n\n    /**\n     * 保存线程转储的目录\n     */\n    private String dumpDirectory;\n\n    /**\n     * 是否启用qos\n     */\n    private Boolean qosEnable;\n\n    /**\n     * qos端口\n     */\n    private Integer qosPort;\n    /**\n     * 是否可以接受国外ip\n     */\n    private Boolean qosAcceptForeignIp;\n\n    /**\n     *  自定义参数\n     */\n    private Map<String, String> parameters;\n\n    public ApplicationConfig() {\n    }\n\n    public ApplicationConfig(String name) {\n        setName(name);\n    }\n\n    @Parameter(key = Constants.APPLICATION_KEY, required = true)\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        checkName(\"name\", name);\n        this.name = name;\n        if (id == null || id.length() == 0) {\n            id = name;\n        }\n    }\n\n    @Parameter(key = \"application.version\")\n    public String getVersion() {\n        return version;\n    }\n    public void setCompiler(String compiler) {\n        this.compiler = compiler;\n        AdaptiveCompiler.setDefaultCompiler(compiler);\n    }\n    public void setLogger(String logger) {\n        this.logger = logger;\n        LoggerFactory.setLoggerAdapter(logger);\n    }\n    // ...省略其他相似方法\n}\n```\n##### ModuleConfig\n```java\npublic class ModuleConfig extends AbstractConfig {\n\n    private static final long serialVersionUID = 5508512956753757169L;\n\n    /**\n     * 服务治理（必填）\n     * 当前模块名称，用于注册中心计算模块间依赖关系\n     * module\n     */\n    private String name;\n\n    /**\n     * 服务治理\n     * 当前模块的版本\n     * module.version\n     */\n    private String version;\n\n    /**\n     * 服务治理\n     * 模块负责人，用于服务治理，请填 写负责人公司邮箱前缀\n     * owner\n     */\n    private String owner;\n\n    /**\n     * 服务治理\n     * 组织名称(BU或部门)，用于注册中心区分服务来源，此配置项建议不要使用autoconfig，直接写死在配 置中，比如 china,intl,itu,crm,asc,dw,aliexpress 等\n     * organization\n     */\n    private String organization;\n\n    /**\n     * 注册中心列表\n     * registry centers\n     */\n    private List<RegistryConfig> registries;\n\n    /**\n     * 监控中心\n     * monitor center\n     */\n    private MonitorConfig monitor;\n\n    /**\n     * 是否是默认\n     */\n    private Boolean isDefault;\n\n    public ModuleConfig(String name) {\n        setName(name);\n    }\n\n    @Parameter(key = \"module\", required = true)\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        checkName(\"name\", name);\n        this.name = name;\n        //id为空的话，使用name的值\n        if (id == null || id.length() == 0) {\n            id = name;\n        }\n    }\n\n    @Parameter(key = \"module.version\")\n    public String getVersion() {\n        return version;\n    }\n    \n    public void setOwner(String owner) {\n        checkName(\"owner\", owner);\n        this.owner = owner;\n    }\n    \n    public void setOrganization(String organization) {\n        checkName(\"organization\", organization);\n        this.organization = organization;\n    }\n\n    public RegistryConfig getRegistry() {\n        return registries == null || registries.isEmpty() ? null : registries.get(0);\n    }\n\n    public void setRegistry(RegistryConfig registry) {\n        List<RegistryConfig> registries = new ArrayList<RegistryConfig>(1);\n        registries.add(registry);\n        this.registries = registries;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public void setRegistries(List<? extends RegistryConfig> registries) {\n        this.registries = (List<RegistryConfig>) registries;\n    }\n    // ...省略其他类似get、set方法\n}\n```\n\n##### RegistryConfig\n注册中心配置，如果有多个不同的注册中心，可以声明多个 <dubbo:registry> 标签，并在 <dubbo:service> 或 <dubbo:reference> 的 registry 属性指定使用的注册中心.\n```java\npublic class RegistryConfig extends AbstractConfig {\n\n    /**\n     * 不可用标识\n     */\n    public static final String NO_AVAILABLE = \"N/A\";\n\n    /**\n     * 服务发现（必填）\n     * 注册中心服务器地址，如果地址没有端口缺省为9090，同一集群内的多个地址用逗号分隔，如：ip:port,ip:port\n     * 不同集群的注册中心，请配置多个 <dubbo:registry> 标签\n     * <host:port>\n     */\n    private String address;\n\n    /**\n     * 服务治理\n     * 登录注册中心用户名，如果注册中心不需要验证可不填\n     * <username>\n     */\n    private String username;\n\n    /**\n     * 服务治理\n     * 登录注册中心密码，如果注册中心不需要验证可不填\n     * <password>\n     */\n    private String password;\n\n    /**\n     * 服务发现\n     * 注册中心默认端口,当address没有带端口时使用此端口做为缺省值\n     * <port>\n     */\n    private Integer port;\n\n    /**\n     * 服务发现(dubbo)\n     * 注册中心地址协议,支持dubbo,http,local三种协议,分别表示: dubbo地址,http地址,本地注册中心\n     * <protocol>\n     */\n    private String protocol;\n\n    /**\n     * 性能调优(netty)\n     * 网络传输方式，可选mina,netty\n     * registry.transporter\n     */\n    private String transporter;\n\n    private String server;\n\n    private String client;\n    \n    private String cluster;\n\n    private String group;\n\n    private String version;\n\n    /**\n     * 性能调优(5000)\n     * 注册中心请求超时时间(毫秒)\n     * registry.timeout\t\n     */\n    private Integer timeout;\n\n    /** \n     * 性能调优(60000)\n     * 注册中心会话超时时间(毫秒)，用于检测提供者非正常断线后的脏数据，比如用心跳检测的实现，此时间就是心跳间隔，不同注册中心实现不一样\n     * registry.session\n     */\n    private Integer session;\n\n    /**\n     * 服务治理\n     * 使用文件缓存注 册中心地址列表及服务提供者列表，应用重启时将基于此文件恢复，注意：两个注册中心不能使用同一文件存储\n     * registry.file\n     */\n    private String file;\n\n    /**\n     * 性能调优(0)\n     * 停止时等待通知完成时间(毫秒)\n     * registry.wait\n     */\n    private Integer wait;\n\n    /**\n     * 服务治理(true)\n     * 在启动时，是否检测注册中心是否可用\n     * check\n     */\n    private Boolean check;\n\n    /**\n     * 服务治理(true)\n     * 服务是否动态注册，如果设为 false，注册后将显示后disable状态，需人工启用，并且服务提供者停止时，也不会自动取消册，需人工禁用\n     * dynamic\n     */\n    private Boolean dynamic;\n\n    /**\n     * 服务治理（true）\n     * 是否向此注册中心注册服务，如果设为false，将只订阅，不注册\n     * register\n     */\n    private Boolean register;\n\n    /**\n     * 服务治理（true）\n     * 是否向此注册中心订阅服务，如果设为false，将只注册，不订阅\n     * subscribe \n     */\n    private Boolean subscribe;\n\n    /**\n     * 自定义参数\n     */\n    private Map<String, String> parameters;\n\n    /**\n     * 是否是默认\n     */\n    private Boolean isDefault;\n\n    public RegistryConfig() {\n    }\n\n    public static void destroyAll() {\n        AbstractRegistryFactory.destroyAll();\n    }\n\n    public void setProtocol(String protocol) {\n        checkName(\"protocol\", protocol);\n        this.protocol = protocol;\n    }\n\n    @Parameter(excluded = true)\n    public String getAddress() {\n        return address;\n    }\n\n    public void setUsername(String username) {\n        checkName(\"username\", username);\n        this.username = username;\n    }\n\n    public void setFile(String file) {\n        checkPathLength(\"file\", file);\n        this.file = file;\n    }\n\n    public void setTransporter(String transporter) { \n        checkName(\"transporter\", transporter);\n        this.transporter = transporter;\n    }\n\n    public void setServer(String server) {\n        checkName(\"server\", server);\n        this.server = server;\n    }\n\n    public void setClient(String client) {\n        checkName(\"client\", client);\n        this.client = client;\n    }\n\n}\n```\n##### MonitorConfig\n```java\npublic class MonitorConfig extends AbstractConfig {\n\n    /**\n     * 服务治理(dubbo)\n     * 监控中心协议，如果为protocol=”registry”，表示从注册中心发现监控中心地址，否则直连监控中心\n     * protocol\n     */\n    private String protocol;\n    \n    /**\n     * 服务治理(N/A)\n     * 直连监控中心服务器地址，address=”10.20.130.230:12080”\n     * <url>\n     */\n    private String address;\n\n    private String username;\n\n    private String password;\n\n    private String group;\n\n    private String version;\n\n    private String interval;\n\n    private Map<String, String> parameters;\n\n    private Boolean isDefault;\n\n    public MonitorConfig(String address) {\n        this.address = address;\n    }\n\n    @Parameter(excluded = true)\n    public String getAddress() {\n        return address;\n    }\n\n    @Parameter(excluded = true)\n    public String getProtocol() {\n        return protocol;\n    }\n\n    @Parameter(excluded = true)\n    public String getUsername() {\n        return username;\n    }\n    @Parameter(excluded = true)\n    public String getPassword() {\n        return password;\n    }\n\n    public void setParameters(Map<String, String> parameters) {\n        checkParameterName(parameters);\n        this.parameters = parameters;\n    }\n\n}\n```\n##### ProviderConfig\n该类继承自AbstractServiceConfig类\n```java\npublic class ProviderConfig extends AbstractServiceConfig {\n\n    //如果没有设置协议的属性值，那么默认值将会生效\n    /**\n     * 服务ip地址（当有多个网卡可用时使用）(自动查找本机IP)\n     * <host>\n     */\n    private String host;\n\n    /**\n     * 服务端口\n     * port\n     */\n    private Integer port;\n\n    /**\n     * 上下文路径\n     * contextpath\n     */\n    private String contextpath;\n\n    /**\n     * 线程池(fixed)\n     * threadpool\n     */\n    private String threadpool;\n\n    /**\n     * 线程池大小（固定大小）\n     */\n    private Integer threads;\n\n    /**\n     * IO线程池大小（CPU数+1）\n     * iothreads\n     */\n    private Integer iothreads;\n\n    /**\n     * 线程池队列长度(0)\n     * queues\n     */\n    private Integer queues;\n\n    /**\n     * 最大可接受的连接(0)\n     * accepts\n     */\n    private Integer accepts;\n\n    /**\n     * 协议编解码器（dubbo）\n     * codec\n     */\n    private String codec;\n\n    /**\n     * 编码（UTF-8）\n     * charset\n     */\n    private String charset;\n\n    /**\n     * payload最大长度(88388608(=8M))\n     * payload\n     */\n    private Integer payload;\n\n    /**\n     * buffer大小(8192)\n     * buffer\n     */\n    private Integer buffer;\n\n    /**\n     * transporter\n     */\n    private String transporter;\n\n    /**\n     * how information gets exchanged\n     */\n    private String exchanger;\n\n    /**\n     * 性能调优\n     * 线程调度模式\n     * 协议的消息派发方式，用于指定线程模型，比如：dubbo协议的all,direct,message,execution,connection等\n     */\n    private String dispatcher;\n\n    /**\n     * networker\n     */\n    private String networker;\n\n    /**\n     * 服务器实现\n     * dubbo协议缺省 为netty，http协议缺省为servlet\n     * server\n     */\n    private String server;\n\n    /**\n     * 客户端实现\n     * dubbo协议缺省 为netty\n     * client\n     */\n    private String client;\n\n    /**\n     * 支持telnet命令,逗号分割\n     */\n    private String telnet;\n\n    /**\n     * 命令行提示符\n     */\n    private String prompt;\n\n    /**\n     * 状态检测\n     */\n    private String status;\n\n    /**\n     * 停止的时候等待多久\n     */\n    private Integer wait;\n\n    private Boolean isDefault;\n\n    @Parameter(excluded = true)\n    public Boolean isDefault() {\n        return isDefault;\n    }\n\n    @Parameter(excluded = true)\n    public String getHost() {\n        return host;\n    }\n\n    @Parameter(excluded = true)\n    public Integer getPort() {\n        return port;\n    }\n\n    @Parameter(excluded = true)\n    public String getContextpath() {\n        return contextpath;\n    }\n\n    public void setContextpath(String contextpath) {\n        checkPathName(\"contextpath\", contextpath);\n        this.contextpath = contextpath;\n    }\n\n    public void setThreadpool(String threadpool) {\n        checkExtension(ThreadPool.class, \"threadpool\", threadpool);\n        this.threadpool = threadpool;\n    }\n\n    public void setTelnet(String telnet) {\n        checkMultiExtension(TelnetHandler.class, \"telnet\", telnet);\n        this.telnet = telnet;\n    }\n\n    @Parameter(escaped = true)\n    public String getPrompt() {\n        return prompt;\n    }\n    public void setStatus(String status) {\n        checkMultiExtension(StatusChecker.class, \"status\", status);\n        this.status = status;\n    }\n\n    @Override\n    public String getCluster() {\n        return super.getCluster();\n    }\n\n    @Override\n    public Integer getConnections() {\n        return super.getConnections();\n    }\n\n    @Override\n    public Integer getTimeout() {\n        return super.getTimeout();\n    }\n\n    @Override\n    public Integer getRetries() {\n        return super.getRetries();\n    }\n\n    @Override\n    public String getLoadbalance() {\n        return super.getLoadbalance();\n    }\n\n    @Override\n    public Boolean isAsync() {\n        return super.isAsync();\n    }\n\n    @Override\n    public Integer getActives() {\n        return super.getActives();\n    }\n\n    public void setTransporter(String transporter) {\n        checkExtension(Transporter.class, \"transporter\", transporter);\n        this.transporter = transporter;\n    }\n\n    public void setExchanger(String exchanger) {\n        checkExtension(Exchanger.class, \"exchanger\", exchanger);\n        this.exchanger = exchanger;\n    }\n\n    public void setDispatcher(String dispatcher) {\n        checkExtension(Dispatcher.class, Constants.DISPATCHER_KEY, exchanger);\n        checkExtension(Dispatcher.class, \"dispather\", exchanger);\n        this.dispatcher = dispatcher;\n    }\n}\n```\n##### AbstractMethodConfig\n该抽象类继承自AbstractConfig\n```java\npublic abstract class AbstractMethodConfig extends AbstractConfig {\n\n    /**\n     * 远程调用超时(1000毫秒)\n     * timeout for remote invocation in milliseconds\n     */\n    protected Integer timeout;\n\n    /**\n     * 重试次数（2）\n     */\n    protected Integer retries;\n\n    /**\n     * 最大并发调用(0)\n     * max concurrent invocations\n     */\n    protected Integer actives;\n\n    /**\n     * 负载均衡（random）\n     */\n    protected String loadbalance;\n\n    /**\n     * 是否异步\n     */\n    protected Boolean async;\n\n    /**\n     * 是否确认异步发送\n     */\n    protected Boolean sent;\n\n    /**\n     * 当服务调用失败时，被调用的mack类的名字\n     * mock\n     */\n    protected String mock;\n\n    /**\n     * 合并\n     */\n    protected String merger;\n\n    /**\n     * 缓存\n     */\n    protected String cache;\n\n    /**\n     * 验证\n     */\n    protected String validation;\n\n    /**\n     * 自定义参数\n     */\n    protected Map<String, String> parameters;\n\n    public void setLoadbalance(String loadbalance) {\n        checkExtension(LoadBalance.class, \"loadbalance\", loadbalance);\n        this.loadbalance = loadbalance;\n    }\n\n    @Parameter(escaped = true)\n    public String getMock() {\n        return mock;\n    }\n\n    public void setMock(Boolean mock) {\n        if (mock == null) {\n            setMock((String) null);\n        } else {\n            setMock(String.valueOf(mock));\n        }\n    }\n\n    public void setMock(String mock) {\n        if (mock != null && mock.startsWith(Constants.RETURN_PREFIX)) {\n            checkLength(\"mock\", mock);\n        } else {\n            checkName(\"mock\", mock);\n        }\n        this.mock = mock;\n    }\n}\n```\n\n##### AbstractInterfaceConfig\n该类继承自AbstractMethodConfig\n```java\npublic abstract class AbstractInterfaceConfig extends AbstractMethodConfig {\n\n    /**\n     * 服务接口的本地实现类名称\n     */\n    protected String local;\n\n    /**\n     * 服务接口的本地存根类名称\n     */\n    protected String stub;\n\n    /**\n     * 服务监控\n     */\n    protected MonitorConfig monitor;\n\n    /**\n     * 代理类型\n     */\n    protected String proxy;\n\n    /**\n     * 性能调优（failover）\n     * 集群方式，可选：failover/failfast/failsafe/failback/forking\n     * default.cluster\n     */\n    protected String cluster;\n\n    /**\n     * 过滤器\n     */\n    protected String filter;\n\n    /**\n     * 监听器\n     */\n    protected String listener;\n\n    /**\n     * 所有者\n     */\n    protected String owner;\n\n    /**\n     * 连接限制，0标识共享连接（0）\n     * 否则它定义委托给当前服务的连接\n     * default.connections\t\n     */\n    protected Integer connections;\n\n    protected String layer;\n\n    /**\n     * application配置\n     */\n    protected ApplicationConfig application;\n\n    /**\n     *  module配置\n     */\n    protected ModuleConfig module;\n\n    /**\n     * 注册中心内地址\n     * <dubbo:registry address=\"multicast://224.5.6.7:1234\" id=\"com.alibaba.dubbo.config.RegistryConfig\" />\n     */\n    protected List<RegistryConfig> registries;\n\n    /**\n     * 连接事件\n     * connection events\n     */\n    protected String onconnect;\n\n    /**\n     * 断开连接事件\n     * disconnection events\n     */\n    protected String ondisconnect;\n\n    /**\n     * 回调限制\n     * callback limits\n     */\n    private Integer callbacks;\n\n    /**\n     * 引用/暴露服务的作用域\n     * 如果它是local，则意味着只在当前虚拟机中进行搜索\n     */\n    private String scope;\n\n    public void setStub(Boolean stub) {\n        if (stub == null) {\n            setStub((String) null);\n        } else {\n            setStub(String.valueOf(stub));\n        }\n    }\n\n    public void setStub(String stub) {\n        checkName(\"stub\", stub);\n        this.stub = stub;\n    }\n\n    public void setCluster(String cluster) {\n        checkExtension(Cluster.class, \"cluster\", cluster);\n        this.cluster = cluster;\n    }\n\n    public void setProxy(String proxy) {\n        checkExtension(ProxyFactory.class, \"proxy\", proxy);\n        this.proxy = proxy;\n    }\n\n    @Parameter(key = Constants.REFERENCE_FILTER_KEY, append = true)\n    public String getFilter() {\n        return filter;\n    }\n\n    public void setFilter(String filter) {\n        checkMultiExtension(Filter.class, \"filter\", filter);\n        this.filter = filter;\n    }\n\n    @Parameter(key = Constants.INVOKER_LISTENER_KEY, append = true)\n    public String getListener() {\n        return listener;\n    }\n\n    public void setListener(String listener) {\n        checkMultiExtension(InvokerListener.class, \"listener\", listener);\n        this.listener = listener;\n    }\n    public void setLayer(String layer) {\n        checkNameHasSymbol(\"layer\", layer);\n        this.layer = layer;\n    }\n\n    public RegistryConfig getRegistry() {\n        return registries == null || registries.isEmpty() ? null : registries.get(0);\n    }\n\n    public void setRegistry(RegistryConfig registry) {\n        List<RegistryConfig> registries = new ArrayList<RegistryConfig>(1);\n        registries.add(registry);\n        this.registries = registries;\n    }\n    //省略其他方法...后面会介绍\n}\n```\n##### AbstractServiceConfig\n该抽象类继承自AbstractInterfaceConfig\n```java\npublic abstract class AbstractServiceConfig extends AbstractInterfaceConfig {\n\n\n    /**\n     * 版本(0.0.0)\n     */\n    protected String version;\n\n    /**\n     * 组\n     */\n    protected String group;\n\n    /**\n     * 服务是否被弃用\n     */\n    protected Boolean deprecated;\n\n    /**\n     * 延迟暴露\n     */\n    protected Integer delay;\n\n    /**\n     * 是否暴露服务\n     */\n    protected Boolean export;\n\n    /**\n     * 权重\n     */\n    protected Integer weight;\n\n    /**\n     * 文档中心\n     */\n    protected String document;\n\n    /**\n     * 是否在注册中心注册为动态服务(true)\n     */\n    protected Boolean dynamic;\n\n    /**\n     * 是否使用token\n     */\n    protected String token;\n\n    /**\n     * 访问日志\n     * access log\n     */\n    protected String accesslog;\n    protected List<ProtocolConfig> protocols;\n    /**\n     * 允许最大执行时间\n     * max allowed execute times\n     */\n    private Integer executes;\n    /**\n     * 是否注册\n     * whether to register\n     */\n    private Boolean register;\n\n    /**\n     * 根据指定的稳定吞吐率和预热期来创建RateLimiter\n     * warm up period\n     */\n    private Integer warmup;\n\n    /**\n     * dubbo协议缺省为hessian2， rmi协议缺省为java，http协议缺省为json\n     * serialization\n     */\n    private String serialization;\n\n\n    public void setVersion(String version) {\n        checkKey(\"version\", version);\n        this.version = version;\n    }\n\n    public void setGroup(String group) {\n        checkKey(\"group\", group);\n        this.group = group;\n    }\n\n    @Parameter(escaped = true)\n    public String getDocument() {\n        return document;\n    }\n\n    public void setToken(String token) {\n        checkName(\"token\", token);\n        this.token = token;\n    }\n\n    public void setToken(Boolean token) {\n        if (token == null) {\n            setToken((String) null);\n        } else {\n            setToken(String.valueOf(token));\n        }\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public void setProtocols(List<? extends ProtocolConfig> protocols) {\n        this.protocols = (List<ProtocolConfig>) protocols;\n    }\n\n    public ProtocolConfig getProtocol() {\n        return protocols == null || protocols.isEmpty() ? null : protocols.get(0);\n    }\n\n    public void setProtocol(ProtocolConfig protocol) {\n        this.protocols = Arrays.asList(new ProtocolConfig[]{protocol});\n    }\n\n    public void setAccesslog(Boolean accesslog) {\n        if (accesslog == null) {\n            setAccesslog((String) null);\n        } else {\n            setAccesslog(String.valueOf(accesslog));\n        }\n    }\n\n    @Override\n    @Parameter(key = Constants.SERVICE_FILTER_KEY, append = true)\n    public String getFilter() {\n        return super.getFilter();\n    }\n\n    @Override\n    @Parameter(key = Constants.EXPORTER_LISTENER_KEY, append = true)\n    public String getListener() {\n        return super.getListener();\n    }\n\n    @Override\n    public void setListener(String listener) {\n        checkMultiExtension(ExporterListener.class, \"listener\", listener);\n        super.setListener(listener);\n    }\n}\n\n```\n##### ConsumerConfig\n```java\npublic class ConsumerConfig extends AbstractReferenceConfig {\n\n    private Boolean isDefault;\n\n    /**\n     * 使用的网络框架客户端：netty, mina, etc\n     */\n    private String client;\n\n    @Override\n    public void setTimeout(Integer timeout) {\n        super.setTimeout(timeout);\n        //设置rmi超时时间\n        String rmiTimeout = System.getProperty(\"sun.rmi.transport.tcp.responseTimeout\");\n        if (timeout != null && timeout > 0\n                && (rmiTimeout == null || rmiTimeout.length() == 0)) {\n            System.setProperty(\"sun.rmi.transport.tcp.responseTimeout\", String.valueOf(timeout));\n        }\n    }\n}\n```\n##### AbstractReferenceConfig\n```java\npublic abstract class AbstractReferenceConfig extends AbstractInterfaceConfig {\n\n    //如果Reference的属性没有配置，则默认值将会生效\n\n    /**\n     * 检测服务提供者是否存在\n     */\n    protected Boolean check;\n\n    /**\n     * 1、是否立即初始化，如果为true,bean加载时会立即调用消费者初始化\n     * 2、消费者bean被使用者调用时，调用getObject->get->init\n     */\n    protected Boolean init;\n\n    /**\n     * 是否使用缺省泛化接口\n     */\n    protected String generic;\n\n    /**\n     * scope = local\n     * 是否从当前虚拟机中查找reference的实例\n     * whether to find reference's instance from the current JVM\n     */\n    protected Boolean injvm;\n\n    /**\n     * 惰性创建连接\n     * lazy create connection\n     */\n    protected Boolean lazy;\n\n    /**\n     * 重连\n     */\n    protected String reconnect;\n\t\n    protected Boolean sticky;\n\n    /**\n     * stub中是否支持事件\n     * Constants.DEFAULT_STUB_EVENT\n     */\n    protected Boolean stubevent;\n\n    /**\n     * 默认版本\n     */\n    protected String version;\n\n    protected String group;\n\n    @Parameter(excluded = true)\n    public Boolean isGeneric() {\n        return ProtocolUtils.isGeneric(generic);\n    }\n\n    public void setGeneric(Boolean generic) {\n        if (generic != null) {\n            this.generic = generic.toString();\n        }\n    }\n\n    @Override\n    @Parameter(key = Constants.REFERENCE_FILTER_KEY, append = true)\n    public String getFilter() {\n        return super.getFilter();\n    }\n\n    @Override\n    @Parameter(key = Constants.INVOKER_LISTENER_KEY, append = true)\n    public String getListener() {\n        return super.getListener();\n    }\n\n    @Override\n    public void setListener(String listener) {\n        checkMultiExtension(InvokerListener.class, \"listener\", listener);\n        super.setListener(listener);\n    }\n\n    @Parameter(key = Constants.LAZY_CONNECT_KEY)\n    public Boolean getLazy() {\n        return lazy;\n    }\n\n    @Override\n    public void setOnconnect(String onconnect) {\n        if (onconnect != null && onconnect.length() > 0) {\n            this.stubevent = true;\n        }\n        super.setOnconnect(onconnect);\n    }\n\n    @Override\n    public void setOndisconnect(String ondisconnect) {\n        if (ondisconnect != null && ondisconnect.length() > 0) {\n            this.stubevent = true;\n        }\n        super.setOndisconnect(ondisconnect);\n    }\n\n    @Parameter(key = Constants.STUB_EVENT_KEY)\n    public Boolean getStubevent() {\n        return stubevent;\n    }\n\n    @Parameter(key = Constants.RECONNECT_KEY)\n    public String getReconnect() {\n        return reconnect;\n    }\n\n    @Parameter(key = Constants.CLUSTER_STICKY_KEY)\n    public Boolean getSticky() {\n        return sticky;\n    }\n}\n```\n\n##### ProtocolConfig\n```java\npublic class ProtocolConfig extends AbstractConfig {\n\n    private static final long serialVersionUID = 6913423882496634749L;\n\n    /**\n     * 性能调优(必填dubbo)\n     * 协议名称\n     * \t<protocol>\n     */\n    private String name;\n\n    /**\n     * 服务发现(自动查找本机IP)\n     * 服务主机名，多网卡选择或指定VIP及域名时使用，为空则自动查找本机IP，-建议不要配置，让Dubbo自动获取本机IP\n     * host\n     */\n    private String host;\n\n    /**\n     * 服务端口\n     * dubbo协议缺省端口为20880,rmi协议缺省端口为1099,http 和hessian协议缺省端口为80\n     * 如果配置为-1 或者没有配置port，则会分配一个没有被占用的端口\n     * Dubbo 2.4.0+，分配的端口在协议缺省端口的基础上增长，确保端口段可控\n     * <port>\n     */\n    private Integer port;\n\n    /**\n     * 服务发现\n     * 提供者上下文路径，为服务path的前缀\n     * <path>\n     */\n    private String contextpath;\n\n    /**\n     * 性能调优（fixed）\n     * 线程池类型，可选：fixed/cached\n     * threadpool\n     */\n    private String threadpool;\n\n    /**\n     * 性能调优(100)\n     * 服务线程池大小(固定大小)\n     * threads\n     */\n    private Integer threads;\n\n    /**\n     * 性能调优(cpu个数+1)\n     * IO线程池大小（固定大小）\n     */\n    private Integer iothreads;\n\n    /**\n     * 性能调优(0)\n     * 线程池队列大小，当线程池满时，排队等待执行的队列大小，\n     * 建议不要设置，当线程程池时应立即失败，重试其它服务提供机器，而不是排队，除非有特殊需求\n     * queues\n     */\n    private Integer queues;\n\n    /**\n     * 性能调优(0)\n     * 服务提供方最大可接受连接数\n     * accepts \n     */\n    private Integer accepts;\n\n    /**\n     * 性能调优(dubbo)\n     * 协议编码方式\n     * codec\n     */\n    private String codec;\n\n    /**\n     * 性能调优(dubbo协议缺省为hessian2，rmi协议缺省为java，http协议 缺省为json)\n     * 协议序列化方式，当协议支持多种序列化方式时使用，比如：dubbo协议的dubbo,hessian2,java,compactedjava，以及http协议的json等\n     * serialization\n     */\n    private String serialization;\n\n    /**\n     * 序列化编码(UTF-8)\n     * charset\n     */\n    private String charset;\n\n    /**\n     * 性能调优(88388608(=8M))\n     * 请求及响应数据包大小限制，单位：字节\n     * payload\n     */\n    private Integer payload;\n\n    /**\n     * 性能调优(8192)\n     * 网络读写缓冲区大小\n     * buffer\n     */\n    private Integer buffer;\n\n    /**\n     * 性能调优（0）\n     * 心跳间隔，对于长连接，当物理层断开时，比如拔网线，TCP的FIN消息来不及发送，\n     * 对方收不到断开事件，此时需要心跳来帮助检查连接是否已断开\n     * heartbeat\n     */\n    private Integer heartbeat;\n\n    /**\n     * 服务治理\n     * 设为true，将向logger中输出访问日志，也可填写访问日志文件路径，直接把访问日志输出到指定文件\n     * accesslog\n     */\n    private String accesslog;\n\t\n    /**\n     * 性能调优(dubbo协议缺省为netty)\n     * 协议的服务端和客户端实现类型，比如：dubbo协议的mina,netty等，可以分拆为server和client配置\n     * transporter\n     */\n    private String transporter;\n\n    private String exchanger;\n\n    /**\n     * 性能(dubbo协议缺省为all)\n     * 协议的消息派发方式，用于指定线程模型，比如：dubbo协议的all,direct,message,execution,connection等\n     * dispatcher\n     */\n    private String dispatcher;\n\n    /**\n     * networker\n     */\n    private String networker;\n\n    /**\n     * 性能调优(dubbo协议缺省为netty，http协议缺省为servlet)\n     * 协议的服务器端实现类型，比如：dubbo协议的mina,netty等，http协议的jetty,servlet等\n     * server\n     */\n    private String server;\n\n    /**\n     * 性能调优(协议缺省为netty)\n     * 客户端实现\n     * client\n     */\n    private String client;\n\n    /**\n     * 服务治理\n     * 支持的telnet命令，逗号分隔\n     * telnet\n     */\n    private String telnet;\n\n    /**\n     * 命令行提示\n     */\n    private String prompt;\n\n    /**\n     * 状态检测\n     */\n    private String status;\n\n    /**\n     * 服务治理（true）\n     * 该协议的服务是否注册到注册中心\n     */\n    private Boolean register;\n\n    /**\n     * 是否长连接\n     * TODO add this to provider config\n     */\n    private Boolean keepAlive;\n\n    /**\n     * TODO add this to provider config\n     */\n    private String optimizer;\n\n    private String extension;\n\n    private Map<String, String> parameters;\n\n    private Boolean isDefault;\n  \n    /**\n     * 是否已经销毁\n     */\n    private static final AtomicBoolean destroyed = new AtomicBoolean(false);\n\n    public ProtocolConfig() {\n    }\n\n    public ProtocolConfig(String name) {\n        setName(name);\n    }\n\n    public ProtocolConfig(String name, int port) {\n        setName(name);\n        setPort(port);\n    }\n\n    @Parameter(excluded = true)\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        checkName(\"name\", name);\n        this.name = name;\n        if (id == null || id.length() == 0) {\n            id = name;\n        }\n    }\n\n    @Parameter(excluded = true)\n    public String getHost() {\n        return host;\n    }\n\n    @Parameter(excluded = true)\n    public Integer getPort() {\n        return port;\n    }\n\n    @Parameter(excluded = true)\n    public String getContextpath() {\n        return contextpath;\n    }\n\n    public void setContextpath(String contextpath) {\n        checkPathName(\"contextpath\", contextpath);\n        this.contextpath = contextpath;\n    }\n\n    public void setThreadpool(String threadpool) {\n        checkExtension(ThreadPool.class, \"threadpool\", threadpool);\n        this.threadpool = threadpool;\n    }\n\n    public void setCodec(String codec) {\n        if (\"dubbo\".equals(name)) {\n            checkMultiExtension(Codec.class, \"codec\", codec);\n        }\n        this.codec = codec;\n    }\n\n    public void setSerialization(String serialization) {\n        if (\"dubbo\".equals(name)) {\n            checkMultiExtension(Serialization.class, \"serialization\", serialization);\n        }\n        this.serialization = serialization;\n    }\n\n    public void setServer(String server) {\n        if (\"dubbo\".equals(name)) {\n            checkMultiExtension(Transporter.class, \"server\", server);\n        }\n        this.server = server;\n    }\n\n    public void setClient(String client) {\n        if (\"dubbo\".equals(name)) {\n            checkMultiExtension(Transporter.class, \"client\", client);\n        }\n        this.client = client;\n    }\n\n    public void setTelnet(String telnet) {\n        checkMultiExtension(TelnetHandler.class, \"telnet\", telnet);\n        this.telnet = telnet;\n    }\n\n    @Parameter(escaped = true)\n    public String getPrompt() {\n        return prompt;\n    }\n\n    public void setStatus(String status) {\n        checkMultiExtension(StatusChecker.class, \"status\", status);\n        this.status = status;\n    }\n\n    public void setTransporter(String transporter) {\n        checkExtension(Transporter.class, \"transporter\", transporter);\n        this.transporter = transporter;\n    }\n\n    public void setExchanger(String exchanger) {\n        checkExtension(Exchanger.class, \"exchanger\", exchanger);\n        this.exchanger = exchanger;\n    }\n\n    public void setDispatcher(String dispatcher) {\n        checkExtension(Dispatcher.class, \"dispacther\", dispatcher);\n        this.dispatcher = dispatcher;\n    }\n\n    public void destory() {\n        if (name != null) {\n\t    //获取Protocol扩展实例，然后调用destroy方法\n            ExtensionLoader.getExtensionLoader(Protocol.class)\n                    .getExtension(name)\n                    .destroy();\n        }\n    }\n}\n```\n##### ServiceConfig\n```java\npublic class ServiceConfig<T> extends AbstractServiceConfig {\n\n    /**\n     * 服务发现\n     * 服务接口名称\n     */\n    private String interfaceName;\n   \n    /**\n     * 服务接口类\n     */\n    private Class<?> interfaceClass;\n   \n    /**\n     * 服务发现(必填)\n     * 服务对象实现引用\n     */\n    private T ref;\n    \n    /**\n     * 服务发现(缺省为接口名)\n     * 服务路径(注意：1.0不支持自定义路径，总是使用接口名，如果有1.0调 2.0，配置服务路径可能不兼容\n     * <path>\n     */\n    private String path;\n    \n    /**\n     * 服务方法配置\n     */\n    private List<MethodConfig> methods;\n   \n    /**\n     * 提供者\n     */\n    private ProviderConfig provider;\n\n\n    /**\n     * 泛化接口\n     */\n    private volatile String generic;\n}\n\n```\n##### ReferenceConfig\n```java\npublic class ReferenceConfig<T> extends AbstractReferenceConfig {\n\n    /**\n     * 引用的接口名称\n     */\n    private String interfaceName;\n\n    /**\n     * 引用的接口类\n     */\n    private Class<?> interfaceClass;\n    \n    /**\n     * 客户端类型\n     */\n    private String client;\n    \n    /**\n     * 点对点调用url\n     */\n    private String url;\n    \n    /**\n     * 引用接口方法配置\n     */\n    private List<MethodConfig> methods;\n    \n    /**\n     * 默认配置\n     */\n    private ConsumerConfig consumer;\n    \n    /**\n     * 协议\n     */\n    private String protocol;\n\n    /**\n     * 接口代理引用\n     * interface proxy reference\n     */\n    private transient volatile T ref;\n\n    private transient volatile Invoker<?> invoker;\n\n    /**\n     * 是否已初始化\n     */\n    private transient volatile boolean initialized;\n\n    /**\n     * 是否已销毁\n     */\n    private transient volatile boolean destroyed;\n}\n```\n\n### 覆盖和优先级\n以timeout为例，这里按照优先级从高到低排列(retries,loadbalance, actives也应用相同的规则)：\n* 方法级别，接口级别，默认/全局级别\n* 相同的级别下，消费者比提供者有更高的优先级\n![](img/level.jpg)\n\n这一小节我们就先介绍到这里，下一小节开始介绍具体的解析逻辑。\n\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之Logger模块","url":"/blog/2018/07/31/Dubbo源码阅读之Logger模块/","content":">本文主要分析Dubbo是如何封装常用的日志框架的，以及在Dubbo中如何使用日志。\n\n在com.alibaba.dubbo.common.logger包中定义了如下几个和日志相关的类和接口：\n\n* Level枚举类\n* Logger接口\n* LoggerAdapter接口\n* LoggerFactory类\n\n### Level枚举类\n该枚举类从低到高定义了如下几个日志级别：\n```java\nALL,TRACE,DEBUG,INFO,WARN,ERROR,OFF\n```\n### Logger接口\n该接口定义了一些输出相应级别日志的方法，如：\n```JAVA\npublic interface Logger {\n\t//输出debug级别日志\n\tpublic void debug(Throwable e);\n\tpublic void debug(String msg, Throwable e);\n\tpublic boolean isDebugEnabled();\n\n\t//省略其他类似方法\n\t...\n}\n```\n### LoggerAdapter接口\n该接口为Logger提供者，定义了获取Logger、设置level级别、设置logger文件等方法,SPI注解我们后面的章节会详细介绍:\n```JAVA\n@SPI\npublic interface LoggerAdapter{\n    //获取Logger\n    Logger getLogger(Class<?> key);\n    //获取Logger\n    Logger getLogger(String key);\n    //获取当前logger日志级别\n    Level getLevel();\n    //设置当前logger级别\n    void setLevel(Level level);\n    //获取当前logger文件\n    File getFile();\n    //设置当前logger文件\n    void setFile(File file);\n}\n```\n### JdkLogger/JdkLoggerAdapter例子\n如果需要将日志框架集成到Dubbo中，需要实现上面定义的Logger接口和LoggerAdapter接口。\nDubbo默认已经集成了commons-logging、java.util.logging.Logger、org.apache.log4j.Logger、org.slf4j.Logger。\n作为例子，我们看下jdkLogger，其他的都类似。\n```JAVA\n//JdkLogger实现了Dubbo框架定义的Logger接口\npublic class JdkLogger implements Logger {\n\n    //持有java.util.logging.Logger实例\t\n    private final java.util.logging.Logger logger;\n\n    public JdkLogger(java.util.logging.Logger logger) {\n\t//构造方法，设置logger实例\n        this.logger = logger;\n    }\n\n    //实现了Logger接口中定义的方法\n    //都是委托给了java.util.logging.Logger实例来打印相应级别的日志\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.log(Level.INFO, msg, e);\n    }\n    \n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    } \n     \n    //省略其他类似方法\n    ...\n}\n\n//JdkLoggerAdapter实现了Dubbo框架定义的LoggerAdapter接口\npublic class JdkLoggerAdapter implements LoggerAdapter {\n\t\n\t//全局日志名称\n\tprivate static final String GLOBAL_LOGGER_NAME = \"global\";\n\t\n\t//存放日志的文件\n\tprivate File file;\n\t\t\n\t//该构造方法读取jdk日志配置文件logging.properties，设置日志文件file\n\tpublic JdkLoggerAdapter() {\n\t\ttry {\n\t\t    //获取jdk日志配置文件logging.properties\n\t\t    InputStream in = Thread.currentThread()\n\t\t\t    .getContextClassLoader()\n\t\t\t    .getResourceAsStream(\"logging.properties\");\n\t\t    if (in != null) {\n\t\t\t//读取配置\n\t\t\tLogManager.getLogManager().readConfiguration(in);\n\t\t    } else {\n\t\t\t//在classpath中没找到jdk日志配置文件logging.properties\n\t\t\tSystem.err.println(\"No such logging.properties in classpath for jdk logging config!\");\n\t\t    }\n\t\t} catch (Throwable t) {\n\t\t    System.err.println(\"Failed to load logging.properties in classpath for jdk logging config, cause: \" + t.getMessage());\n\t\t}\n\t\ttry {\n\t\t    //获取与此Logger关联的Handlers\n\t\t    Handler[] handlers =\n\t\t\t    java.util.logging.Logger.getLogger(GLOBAL_LOGGER_NAME)\n\t\t\t\t    .getHandlers();\n\t\t    for (Handler handler : handlers) {\n\t\t\tif (handler instanceof FileHandler) {\n\t\t\t    FileHandler fileHandler = (FileHandler) handler;\n\t\t\t    //通过反射找到files字段\n\t\t\t    Field field = fileHandler.getClass().getField(\"files\");\n\t\t\t    //获取fileHandler对象的field字段的值\n\t\t\t    File[] files = (File[]) field.get(fileHandler);\n\t\t\t    if (files != null && files.length > 0) {\n\t\t\t\t//设置file，即日志文件\n\t\t\t\tfile = files[0];\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t} catch (Throwable t) {\n\t\t}\n\t }\n\t\t\n\t //getLogger方法，返回一个JdkLogger对象，构造JdkLogger对象时传入了java.util.logging.Logger的Logger\n\t @Override\n\t public Logger getLogger(Class<?> key) {\n\t        //将最终使用的日志框架包装成了Dubbo的Logger对象\n\t\treturn new JdkLogger(java.util.logging.Logger.getLogger(key == null ? \"\" : key.getName()));\n\t }\n\n\t //返回日志文件\n\t @Override\n\t public File getFile() {\n\t\treturn file;\n\t }\n\n\t //获取日志级别\n\t @Override\n\t public Level getLevel() {\n\t        //这里通过fromJdkLevel方法将jdk的logger级别转换成了dubbo定义的level级别\n\t\treturn fromJdkLevel(java.util.logging.Logger.getLogger(GLOBAL_LOGGER_NAME).getLevel());\n\t }\n\n         //设置日志级别\n         @Override\n\t public void setLevel(Level level) {\n\t         //这里通过toJdkLevel方法将dubbo定义的level级别转换成了jdk的logger级别\n\t\tjava.util.logging.Logger.getLogger(GLOBAL_LOGGER_NAME).setLevel(toJdkLevel(level));\n\t }\n\n\t //fromJdkLevel和toJdkLevel方法比较简单，这里就不列出来了\n}\n```\n\n### LoggerFactory类\n该类是Logger工厂，定义了获取Logger的静态方法，需要使用日志时都是直接操作该类拿到Logger。\nLOGGERS和LOGGER_ADAPTER静态变量后面会介绍。\n```\npublic class LoggerFactory {\n\n    //缓存已创建Logger的类<类名称，该类对应的Logger>\n    private static final ConcurrentMap<String, FailsafeLogger> LOGGERS =\n            new ConcurrentHashMap<String, FailsafeLogger>();\n    \n    //当前使用的日志框架\n    private static volatile LoggerAdapter LOGGER_ADAPTER;\n}\n```\n例如在ScriptRouter类中，可以这样使用:\n```\npublic class ScriptRouter{\n\tprivate static final Logger logger = LoggerFactory.getLogger(ScriptRouter.class);\n\tpublic void error(){\n\t\tlogger.debug(\"route error , rule has been ignored\");\n\t}\n}\n```\n接下来，我们看下LoggerFactory中的getLogger方法定义：\n```java\npublic static Logger getLogger(Class<?> key) {\n        //根据name从LOGGERS缓存中获取FailsafeLogger\n        FailsafeLogger logger = LOGGERS.get(key.getName());\n        if (logger == null) {\n            //如果logger为空，则为类key创建一个FailsafeLogger，并放入缓存LOGGERS\n            LOGGERS.putIfAbsent(key.getName(), new FailsafeLogger(LOGGER_ADAPTER.getLogger(key)));\n            logger = LOGGERS.get(key.getName());\n        }\n        return logger;\n}\n```\n获取Logger时，我们是从LOGGERS变量中获取的，可见LOGGERS是用来缓存我们已创建的Logger对象的。\n而创建FailsafeLogger对象时，我们是根据key从LOGGER_ADAPTER变量中获取的Logger。\n由此可知，我们是通过LOGGER_ADAPTER变量(即LoggerAdapter接口)的getLogger(key)方法获取到了最终使用的日志框架，然后包装成了FailsafeLogger变量缓存起来。\n我们先来大概看下FailsafeLogger类的定义，然后在看下LOGGER_ADAPTER变量是在何时被赋值的。\n```java\npublic class FailsafeLogger implements Logger{\n\t\n     //包含了最终日志框架的logger\n     private Logger logger;\n\n     public FailsafeLogger(Logger logger) {\n        this.logger = logger;\n     }\n     \n     //在日志信息上附加dubbo上下文信息，如：dubbo版本、主机地址\n     private String appendContextMessage(String msg) {\n        return \" [DUBBO] \" + msg + \", dubbo version: \" + Version.getVersion() + \", current host: \" + NetUtils.getLocalHost();\n     }\n\n     @Override\n     public void info(String msg) {\n        try {\n\t    //输出附加了上下文信息的日志\n            logger.info(appendContextMessage(msg));\n        } catch (Throwable t) {\n        }\n     }\n\n     @Override\n     public boolean isInfoEnabled() {\n        try {\n            return logger.isInfoEnabled();\n        } catch (Throwable t) {\n            return false;\n        }\n     }\n     \n     //省略其他类似方法\n     ...\n}\n```\n我们在来看下LOGGER_ADAPTER变量是如何被赋值的，实际上，在LoggerFactory类初始化时，便会试着设置当前使用的日志框架：\n```java\nstatic {\n        //从JVM系统属性中获取配置的日志框架，即通过：java -Ddubbo.application.logger=slf4j配置\n        String logger = System.getProperty(\"dubbo.application.logger\");\n        if (\"slf4j\".equals(logger)) {\n            //如果是slf4j，则设置当前使用的日志框架为Slf4jLoggerAdapter\n            setLoggerAdapter(new Slf4jLoggerAdapter());\n        } else if (\"jcl\".equals(logger)) {\n            setLoggerAdapter(new JclLoggerAdapter());\n        } else if (\"log4j\".equals(logger)) {\n            setLoggerAdapter(new Log4jLoggerAdapter());\n        } else if (\"jdk\".equals(logger)) {\n            setLoggerAdapter(new JdkLoggerAdapter());\n        } else {\n            //如果没有匹配到，则挨个尝试可用的日志框架\n            try {\n                setLoggerAdapter(new Log4jLoggerAdapter());\n            } catch (Throwable e1) {\n                try {\n                    setLoggerAdapter(new Slf4jLoggerAdapter());\n                } catch (Throwable e2) {\n                    try {\n                        setLoggerAdapter(new JclLoggerAdapter());\n                    } catch (Throwable e3) {\n                        setLoggerAdapter(new JdkLoggerAdapter());\n                    }\n                }\n            }\n        }\n}\n\n//设置并修改当前使用的LoggerAdapter\npublic static void setLoggerAdapter(LoggerAdapter loggerAdapter) {\n        if (loggerAdapter != null) {\n            //首先获取LoggerFactory类的Logger\n            Logger logger = loggerAdapter.getLogger(LoggerFactory.class.getName());\n            //然后输出即将使用的logger：loggerAdapter\n            logger.info(\"using logger: \" + loggerAdapter.getClass().getName());\n            //设置LOGGER_ADAPTER变量为loggerAdapter\n            LoggerFactory.LOGGER_ADAPTER = loggerAdapter;\n            //遍历已创建logger的类列表，然后修改logger为新设置的loggerAdapter\n            for (Map.Entry<String, FailsafeLogger> entry : LOGGERS.entrySet()) {\n                //设置FailsafeLogger的logger为loggerAdapter创建的logger\n                entry.getValue().setLogger(LOGGER_ADAPTER.getLogger(entry.getKey()));\n            }\n        }\n}\n\n//获取当前日志级别\npublic static Level getLevel() {\n       //返回LOGGER_ADAPTER的日志级别\n       return LOGGER_ADAPTER.getLevel();\n}\n\n//设置当前日志级别\npublic static void setLevel(Level level) {\n       LOGGER_ADAPTER.setLevel(level);\n}\n\n//获取当前日志文件\npublic static File getFile() {\n        return LOGGER_ADAPTER.getFile();\n}\n```\n\n到此，我们就介绍完Dubbo-Logger相关的内容了，Dubbo作为常用的中间件，集成了可选的日志框架，是非常值得我们学习，最后，给一个类图加深下理解。\n\n![](img/log.png)\n\n\n","tags":["dubbo"]},{"title":"Dubbo源码阅读之SPI扩展机制","url":"/blog/2018/07/31/Dubbo源码阅读之SPI扩展机制/","content":">本文主要分析Dubbo的SPI扩展机制。\n\n* [Java的SPI机制](https://docs.oracle.com/javase/1.5.0/docs/guide/jar/jar.html#Service%20Provider)\n* Dubbo的SPI机制\n\n### Java的SPI机制\nSPI全称为(Service Provider Interface)，是JDK内置的一种服务提供发现机制。通过SPI服务加载机制进行服务的注册和发现，可以实现基于接口的编程，避免在Java代码中写死服务的提供者，实现多个模块的解耦。\n根据Java的SPI规范，我们可以定义一个服务接口，具体的实现由对应的实现者（Service Provider服务提供者）提供，然后在使用的时候只要根据SPI的规范去获取对应的服务提供者的服务实现即可。我们看一个简单的例子：\n```java\npackage java.spi;\npublic interface Developer {\n    public String getPrograme();\n}\n\npackage java.spi;\npublic class JavaDeveloper implements Developer {\n    @Override\n    public String getPrograme() {\n        return \"Java\";\n    }\n}\n\npackage java.spi;\npublic class PerlDeveloper implements Developer {\n    @Override\n    public String getPrograme() {\n        return \"Perl\";\n    }\n}\n```\n然后在META-INF\\services目录下创建名为java.spi.Developer的文件，文件内容是接口实现类的全限定名：\n```java\njava.spi.JavaDeveloper\njava.spi.PerlDeveloper\n```\n将文件导出为jar包，新建一个项目，在项目中导入该jar,然后新建一个测试类：\n```java\nimport java.util.ServiceLoader;\nimport cn.edu.knowledge.spi.Developer;\npublic class Test {\n    public static void main(String[] arg) {\n         ServiceLoader<Developer> serviceLoader = ServiceLoader.load(Developer.class);\n\t for (Developer developer : Developer) {\n\t        //将会输出: I use Java; I use Perl;\n\t\tSystem.out.println(\"I use \"+developer.getPrograme());\n\t }\n    }\n}\n```\n\n### Dubbo的SPI机制\nDubbo的扩展点加载是对JDK内置的SPI机制的一种加强。继续使用上面的例子介绍，\nMETA-INF\\services\\java.spi.Developer文件中的内容将会变为key=value形式：\n```java\njava=java.spi.JavaDeveloper\nperl=java.spi.PerlDeveloper\n```\n其中，key为扩展名称，value为扩展实例。扩展配置文件修改为这样子是因为，如果扩展实现中的方法或者静态字段引用了第三方库，而第三方库不存在时，那么这个类将会初始化失败，在这种情况下，如果使用以前的格式，Dubbo不可以弄清楚扩展的id，因此不可以映射这个扩展的异常信息。\n例如：\n无法加载扩展(\"mina\"),当用户配置使用mina，Dubbo将会抱怨无法加载扩展，而不是报告提取哪一个扩展实现失败及原因。\n\n与Java标准SPI相比，Dubbo SPI又增加了如下功能：\n* Dubbo可以通过getExtension（String key）只加载某一个想要的扩展，Java的SPI机制则需要加载全部的实现类。\n* 对于扩展实现IOC依赖注入功能，如果扩展实现A含有setB()方法，而接口B有B1和B2两个具体的实现，此时Dubbo并不会具体注入B1或者B2，而是会注入一个自动生成的接口B实现：B$Adpative，该实现者能够根据参数的不同，自动引用B1或者B2来完成相应的功能。\n* 对扩展采用装饰器模式进行功能增强。\n\n### Dubbo SPI相关接口\n#### SPI接口\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE})\npublic @interface SPI {\n    //默认扩展名称\n    String value() default \"\";\n}\n```\n当接口上表明了@SPI注解时，Dubbo将会依次从如下目录中读取相应的扩展点：\nMETA-INF/dubbo/internal/\nMETA-INF/dubbo/\nMETA-INF/services/\n\n#### Adaptive接口\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD})\npublic @interface Adaptive {\n    String[] value() default {};\n}\n```\nExtensionLoader注入依赖扩展实例时，该接口为其提供了有用的信息。\nvalue方法决定要注入哪个目标扩展。目标扩展由URL中传递的参数决定，value方法提供了url上的参数名称。如果在URL中没有找到指定的参数名称，则将使用默认的扩展（在其接口上的@SPI注解中进行指定）。\n例如,给定字符串：value={\"key1\", \"key2\"}，如果在URL中发现参数key1，则使用参数key1的值作为扩展名称，如果在URL中没有发现参数key1或者参数key1的值为空，则尝试使用参数key2的值作为扩展名称，如果key2也不存在，则使用默认的扩展，否则抛异常。\n如果默认的扩展名称在@SPI注解中没有提供，则使用规则生成一个name，这个name将用作URL中的搜索参数。规则为：将接口类名从大写字符开始分成几个部分, 并将各部分用点 \".\" 分开。\n例如：com.alibaba.dubbo.xxx.YyyInvokerWrapper，则生成的name为yyy.invoker.wrapper，将会使用该name从url中进行搜索。\n\n#### Activate接口\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD})\npublic @interface Activate {\n    /**\n     * 当group数组中有一个group匹配时，就激活当前扩展。\n     * 将使用传递给ExtensionLoader#getActivateExtension(URL, String, String)方法的group(第三个参数)来和该注解的group进行匹配\n     */\n    String[] group() default {};\n\n    /**\n     * 当指定的key出现在URL的参数中时，则激活当前扩展 \n     * 例如：给定@Activate(\"cache, validation\")时，只有url中出现cache或者validation参数时，才会激活当前扩展\n     */\n    String[] value() default {};\n    \n    //相对顺序 扩展列表中的哪些扩展将要放到当前扩展前面\n    String[] before() default {};\n\n    //相对顺序 扩展列表中的哪些扩展将要放到当前扩展后面\n    String[] after() default {};\n    \n    //绝对顺序\n    int order() default 0;\n}\n```\n用于激活扩展。此注解对于使用给定条件自动激活某些扩展是非常有用的，比如：如果有多个Filter实现，@Activate可以用来加载某些Filter。\nSPI提供者可以调用ExtensionLoader#getActivateExtension(URL, String, String)方法找到所有符合条件的activated扩展。\n\n#### ExtensionFactory接口\n```\n@SPI\npublic interface ExtensionFactory {\n    /**\n     * 获取扩展实现类实例\n     * Get extension.\n     * @param type object type. 扩展接口类型\n     * @param name object name. 扩展名称\n     * @return object instance. 返回扩展实例\n     */\n    <T> T getExtension(Class<T> type, String name);\n}\n```\n该接口根据扩展类型和扩展名称获取扩展实例。可以看到该接口声明上也加上了@SPI注解，说明存在多种实现，Dubbo提供了三种实现，分别为AdaptiveExtensionFactory、SpiExtensionFactory、SpringExtensionFactory，后面会详细介绍具体实现。\n\n\n### ExtensionLoader类\nExtensionLoader类用来处理Dubbo扩展,里面定义了大量的实用方法，该类支持以下主要功能：\n\n* 自动注入依赖扩展\n* 在wrapper中，自动包装扩展\n* 默认扩展是一个adaptive实例\n\nExtensionLoader类代码量比较多，我们先来看下ExtensionLoader类的getExtensionLoader方法，通过该方法可以得到指定扩展类型接口的扩展加载器，\n例如我们想要得到ProxyFactory类型的ExtensionLoader，可以这样做：\n```java\nExtensionLoader<ProxyFactory> loader = ExtensionLoader.getExtensionLoader(ProxyFactory.class);\n```\n#### getExtensionLoader方法\n我们来看getExtensionLoader方法:\n```java\n/**\n * 获取扩展类型接口的扩展加载器\n * 1、校验扩展类型\n * 2、从缓存中获取扩展类型对应的扩展加载器\n * 3、缓存中不存在，则新建一个并放入缓存\n */\npublic static <T> ExtensionLoader<T> getExtensionLoader(Class<T> type) {\n        //扩展类型不可以为空\n        if (type == null) {\n            throw new IllegalArgumentException(\"Extension type == null\");\n        }\n\t//扩展类型必须为接口\n        if (!type.isInterface()) {\n            throw new IllegalArgumentException(\"Extension type(\" + type + \") is not interface!\");\n        }\n\t//检测扩展类型接口是否是一个扩展点，判断依据是：接口必须有@SPI注解\n        if (!withExtensionAnnotation(type)) {\n            throw new IllegalArgumentException(\"Extension type(\" + type +\n                    \") is not extension, because WITHOUT @\" + SPI.class.getSimpleName() + \" Annotation!\");\n        }\n        //首先从缓存中获取该扩展类型的ExtensionLoader\n        ExtensionLoader<T> loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);\n        if (loader == null) {\n            //缓存中不存在，则为扩展类型type新建一个ExtensionLoader，并放入缓存\n            EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader<T>(type));\n            loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);\n        }\n\t//返回扩展类型的ExtensionLoader\n        return loader;\n}\n\n/**\n * 私有构造方法\n */\nprivate ExtensionLoader(Class<?> type) {\n        //保存扩展类型接口\n        this.type = type;\n        //ExtensionFactory接口的扩展实现类不需要进行注入依赖，因此这里将objectFactory设置成null\n\t//其他扩展接口可能依赖其他扩展接口，因此需要进行依赖注入，通过objectFactory可以获取到某个扩展类型的扩展实例\n        objectFactory = (type == ExtensionFactory.class ? null :\n                    ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()\n        );\n}\n```\n其中type和objectFactory是ExtensionLoader类中定义的实例变量,EXTENSION_LOADERS缓存是静态常量：\n```java\n/**\n * 扩展接口的类型\n */\nprivate final Class<?> type;\n\n/**\n * 扩展工厂，通过扩展工厂可以获取到某个扩展类型的扩展实例\n */\nprivate final ExtensionFactory objectFactory;\n\n/**\n * 每个扩展类型接口(即带有@SPI注解的接口)，都有一个相对应的ExtensionLoader实例\n * <扩展类型接口，ExtensionLoader实例>\n */\nprivate static final ConcurrentMap<Class<?>, ExtensionLoader<?>> EXTENSION_LOADERS =\n\t\tnew ConcurrentHashMap<Class<?>, ExtensionLoader<?>>();\n```\n#### getExtension方法\n有了ExtensionLoader实例后，就可以通过该实例的getExtension(String name)方法加载扩展类型的指定实例：\n```java\n/**\n * 通过扩展名称name获取扩展实例\n */\npublic T getExtension(String name) {\n\t//扩展名称不可以为空\n        if (name == null || name.length() == 0) {\n            throw new IllegalArgumentException(\"Extension name == null\");\n        }\n        if (\"true\".equals(name)) {\n            //name = true 返回默认扩展实例（后面会分析该方法）\n            return getDefaultExtension();\n        }\n\t//根据扩展名称从cachedInstances实例变量中获取扩展实例\n\t//扩展实例被放入到Holder对象中，Holder类是一个持有值的助手类，提供了get/set方法\n        Holder<Object> holder = cachedInstances.get(name);\n        if (holder == null) {\n            //缓存中不存在的话，则为扩展名称name新建一个Holder实例。\n            cachedInstances.putIfAbsent(name, new Holder<Object>());\n            holder = cachedInstances.get(name);\n        }\n\t//从holder对象中获取到扩展名称name对应的扩展实例\n        Object instance = holder.get();\n        if (instance == null) {\n\t    //扩展实例为空，则为扩展名称name新建一个扩展实例并放入Holder对象中。\n\t    //这里可能会存在多个线程同时访问，因此需要同步创建扩展实例\n            synchronized (holder) {\n\t        //再次判断holder对象中的扩展实例是否为空\n                instance = holder.get();\n                if (instance == null) {\n                    //根据扩展名称name创建扩展实例（后面会分析该方法）\n                    instance = createExtension(name);\n\t\t    //放入缓存\n                    holder.set(instance);\n                }\n            }\n        }\n\t//返回扩展实例\n        return (T) instance;\n}\n```\n在看getDefaultExtension方法和createExtension方法之前，我们先看下上面getExtension方法中出现的变量定义：\n```java\n/**\n * 缓存 <扩展名称，扩展实例>\n */\nprivate final ConcurrentMap<String, Holder<Object>> cachedInstances =\n    new ConcurrentHashMap<String, Holder<Object>>();\n\n/**\n * 持有一个值的助手类\n */\npublic class Holder<T> {\n\n    private volatile T value;\n\n    public void set(T value) {\n        this.value = value;\n    }\n    public T get() {\n        return value;\n    }\n}\n```\n#### getDefaultExtension方法\n接下来我们来看getDefaultExtension方法，该方法用来获取默认扩展实例。在该方法内部又调用了多个方法，我们一步步来分析，分析完整个流程后，我们在看createExtension方法.\n```java\n/**\n * 返回默认扩展实例，如果没有配置默认扩展名称(@SPI注解上配置的)，则返回null\n */\npublic T getDefaultExtension() {\n        //获取扩展接口type对应的扩展实现类集合(后面会分析该方法)\n\tgetExtensionClasses();\n\t//判断cachedDefaultName变量是否为空\n\t//cachedDefaultName变量是在getExtensionClasses()方法中进行赋值的，我们稍后去看\n\tif (null == cachedDefaultName || cachedDefaultName.length() == 0 || \"true\".equals(cachedDefaultName)) {\n\t\treturn null;\n\t}\n\t//获取默认扩展名称对应的扩展实例\n\treturn getExtension(cachedDefaultName);\n}\n```\n#### getExtensionClasses方法(加载扩展实现类)\n```java\n/**\n * 获取扩展接口type对应的扩展实现类集合，先从缓存获取，缓存没有的话，再去重新加载\n * @return\n */\nprivate Map<String, Class<?>> getExtensionClasses() {\n\t//先从cachedClasses缓存中获取\n\tMap<String, Class<?>> classes = cachedClasses.get();\n\tif (classes == null) {\n\t\t//缓存中为空，同步加载\n\t\tsynchronized (cachedClasses) {\n\t\t\t//再次判断\n\t\t\tclasses = cachedClasses.get();\n\t\t\tif (classes == null) {\n\t\t\t\t//重新加载扩展实现类（后面会分析该方法）\n\t\t\t\tclasses = loadExtensionClasses();\n\t\t\t\t//放入缓存\n\t\t\t\tcachedClasses.set(classes);\n\t\t\t}\n\t\t}\n\t}\n\treturn classes;\n}\n\n/**\n * 默认扩展名称,@SPI注解上配置的值\n */\nprivate String cachedDefaultName;\n\n/**\n * 用来缓存扩展接口type对应的所有扩展实现类\n * <扩展名称，扩展实现类>\n */\nprivate final Holder<Map<String, Class<?>>> cachedClasses = new Holder<Map<String, Class<?>>>();\n\n\n/**\n * 加载扩展接口type对应的所有扩展实现类\n * 在getExtensionClasses中会进行同步\n * synchronized in getExtensionClasses\n * @return\n */\nprivate Map<String, Class<?>> loadExtensionClasses() {\n\t//获取扩展接口type上的@SPI注解\n\tfinal SPI defaultAnnotation = type.getAnnotation(SPI.class);\n\tif (defaultAnnotation != null) {\n\t\t//存在@SPI注解，则获取注解值(即默认扩展名称)\n\t\tString value = defaultAnnotation.value();\n\t\tif ((value = value.trim()).length() > 0) {\n\t\t\t//使用逗号分隔扩展名称\n\t\t\tString[] names = NAME_SEPARATOR.split(value);\n\t\t\tif (names.length > 1) {\n\t\t\t    //存在多个默认扩展名称，则抛异常\n\t\t\t    throw new IllegalStateException(\"more than 1 default extension name on extension \" + type.getName()\n\t\t\t\t    + \": \" + Arrays.toString(names));\n\t\t\t}\n\t\t\tif (names.length == 1) {\n\t\t\t    //保存默认扩展名称到cachedDefaultName\n\t\t\t    cachedDefaultName = names[0];\n\t\t\t}\n\t\t}\n\t}\n\t//开始加载扩展类，依次从3个目录进行加载,保存到extensionClasses中\n\tMap<String, Class<?>> extensionClasses = new HashMap<String, Class<?>>();\n\t//目录看下面的常量定义(后面会分析该方法)\n\tloadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY);\n\tloadDirectory(extensionClasses, DUBBO_DIRECTORY);\n\tloadDirectory(extensionClasses, SERVICES_DIRECTORY);\n\treturn extensionClasses;\n}\n\n/**\n * 扩展所在目录\n */\nprivate static final String SERVICES_DIRECTORY = \"META-INF/services/\";\n\nprivate static final String DUBBO_DIRECTORY = \"META-INF/dubbo/\";\n\nprivate static final String DUBBO_INTERNAL_DIRECTORY = DUBBO_DIRECTORY + \"internal/\";\n\n/**\n * 获取ExtensionLoader的类加载器\n * @return\n */\nprivate static ClassLoader findClassLoader() {\n\treturn ExtensionLoader.class.getClassLoader();\n}\n\n/**\n * 扫描相应目录，加载扩展并保存到extensionClasses集合\n * @param extensionClasses 保存扩展类的Map集合\n * @param dir  扫描目录\n */\nprivate void loadDirectory(Map<String, Class<?>> extensionClasses, String dir) {\n\t//待加载的文件名，如：fileName = META-INF/dubbo/internal/com.alibaba.dubbo.rpc.ProxyFactory\n\tString fileName = dir + type.getName();\n\ttry {\n\t    Enumeration<java.net.URL> urls;\n\t    //获取ExtensionLoader类加载器(后面会分析该方法)\n\t    ClassLoader classLoader = findClassLoader();\n\t    if (classLoader != null) {\n\t\t//当前类加载器不为空，加载该文件\n\t\turls = classLoader.getResources(fileName);\n\t    } else {\n\t\t//当前类加载器为空，则从用来加载类的搜索路径中查找改文件\n\t\turls = ClassLoader.getSystemResources(fileName);\n\t    }\n\t    if (urls != null) {\n\t\twhile (urls.hasMoreElements()) {\n\t\t    //获取到资源定位符\n\t\t    java.net.URL resourceURL = urls.nextElement();\n\t\t    //加载资源,即读取并解析配置文件，然后加载类(后面会分析该方法)\n\t\t    loadResource(extensionClasses, classLoader, resourceURL);\n\t\t}\n\t    }\n\t} catch (Throwable t) {\n\t    logger.error(\"Exception when load extension class(interface: \" +\n\t\t    type + \", description file: \" + fileName + \").\", t);\n\t}\n}\n\n/**\n * 解析配置文件，然后加载扩展类\n * @param extensionClasses 保存扩展类的集合\n * @param classLoader  类加载器\n * @param resourceURL  资源定位符\n */\nprivate void loadResource(Map<String, Class<?>> extensionClasses, ClassLoader classLoader, java.net.URL resourceURL) {\n\ttry {\n\t    BufferedReader reader = new BufferedReader(new InputStreamReader(resourceURL.openStream(), \"utf-8\"));\n\t    try {\n\t\tString line;\n\t\t//读取配置文件每一行\n\t\twhile ((line = reader.readLine()) != null) {\n\t\t    //判断当前行是否包含#号，#号后面的内容都是注释，需要去掉\n\t\t    final int ci = line.indexOf('#');\n\t\t    if (ci >= 0) {\n\t\t\t//截取#号之前的内容，并重新设置line\n\t\t\tline = line.substring(0, ci);\n\t\t    }\n\t\t    line = line.trim();\n\t\t    if (line.length() > 0) {\n\t\t\ttry {\n\t\t\t    String name = null;\n\t\t\t    //当前行是否包含=号\n\t\t\t    int i = line.indexOf('=');\n\t\t\t    if (i > 0) {\n\t\t\t\t//当前行存在=号，则使用=号分隔line，获取到key-value(line)\n\t\t\t\t//name就是key，即定义的扩展名称\n\t\t\t\t//line就是value，即定义的扩展实现类全限定名\n\t\t\t\tname = line.substring(0, i).trim();\n\t\t\t\tline = line.substring(i + 1).trim();\n\t\t\t    }\n\t\t\t    //如果line不等于空，则需要加载该扩展实现类\n\t\t\t    if (line.length() > 0) {\n\t\t\t\t//加载扩展实现类(后面会分析该方法)\n\t\t\t\tloadClass(\n\t\t\t\t\textensionClasses,\n\t\t\t\t\tresourceURL,\n\t\t\t\t\t//加载扩展实现类\n\t\t\t\t\tClass.forName(line, true, classLoader),\n\t\t\t\t\tname\n\t\t\t\t);\n\t\t\t    }\n\t\t\t} catch (Throwable t) {\n\t\t\t    IllegalStateException e = new IllegalStateException(\"Failed to load extension class(interface: \" + type + \", class line: \" + line + \") in \" + resourceURL + \", cause: \" + t.getMessage(), t);\n\t\t\t    //解析行出错，记录错误行到exceptions实例变量中\n\t\t\t    exceptions.put(line, e);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    } finally {\n\t\treader.close();\n\t    }\n\t} catch (Throwable t) {\n\t    logger.error(\"Exception when load extension class(interface: \" +\n\t\t    type + \", class file: \" + resourceURL + \") in \" + resourceURL, t);\n\t}\n}\n\n/**\n * 保存解析配置文件发生的异常信息\n * <当前key-value行，异常信息>\n */\nprivate Map<String, IllegalStateException> exceptions = new ConcurrentHashMap<String, IllegalStateException>();\n\n/**\n * 当前扩展类型接口type对应的扩展自适应类\n * 即存在@Adaptive注解的扩展实现类\n * 每个扩展类型接口type只能有一个实现类有@Adaptive注解，如果多个扩展实现类都有@Adaptive，则会抛异常\n */\nprivate volatile Class<?> cachedAdaptiveClass = null;\n\n/**\n * 如果扩展实现类是一个包装类，\n * 则会将该该实现类添加到cachedWrapperClasses集合中\n */\nprivate Set<Class<?>> cachedWrapperClasses;\n\n/**\n * 扩展名称正则表达式，将会使用该正则表达式切割扩展名称name，即使用逗号分隔\n */\nprivate static final Pattern NAME_SEPARATOR = Pattern.compile(\"\\\\s*[,]+\\\\s*\");\n\n/**\n * 缓存<扩展名称，Activate注解>\n * 如果是逗号分隔的多个name，则取第1个扩展名称name\n * Activate为当前扩展实现类上的@Activate注解\n */\nprivate final Map<String, Activate> cachedActivates = new ConcurrentHashMap<String, Activate>();\n\n/**\n * 缓存<扩展实现类，扩展名称>\n */\nprivate final ConcurrentMap<Class<?>, String> cachedNames = new ConcurrentHashMap<Class<?>, String>();\n\n\n/**\n * 加载扩展实现类\n * @param extensionClasses 保存扩展实现类的map\n * @param resourceURL 资源文件定位符\n * @param clazz 扩展实现类，即实现了type接口的类\n * @param name  扩展名称，即配置文件中的key\n * @throws NoSuchMethodException\n */\nprivate void loadClass(Map<String, Class<?>> extensionClasses,\n\t\t   java.net.URL resourceURL,\n\t\t   Class<?> clazz,\n\t\t   String name) throws NoSuchMethodException {\n\t//检测实现类clazz是否是type的子类型，即clazz是否实现了接口type\n\tif (!type.isAssignableFrom(clazz)) {\n\t    throw new IllegalStateException(\"Error when load extension class(interface: \" +\n\t\t    type + \", class line: \" + clazz.getName() + \"), class \"\n\t\t    + clazz.getName() + \"is not subtype of interface.\");\n\t}\n\t//检测实现类clazz是否有@Adaptive注解\n\tif (clazz.isAnnotationPresent(Adaptive.class)) {\n\t    if (cachedAdaptiveClass == null) {\n\t        //cachedAdaptiveClass变量为空，则将cachedAdaptiveClass赋值为clazz\n\t\tcachedAdaptiveClass = clazz;\n\t    } else if (!cachedAdaptiveClass.equals(clazz)) {\n\t        //cachedAdaptiveClass变量不为空，则判断cachedAdaptiveClass是否和当前实现类class是否是同一个\n\t\t//如果不是同一个，则抛异常：每个扩展类型type不可以存在多个自适应扩展类\n\t\tthrow new IllegalStateException(\"More than 1 adaptive class found: \"\n\t\t\t+ cachedAdaptiveClass.getClass().getName()\n\t\t\t+ \", \" + clazz.getClass().getName());\n\t    }\n\t} else if (isWrapperClass(clazz)) {\n\t    //实现类clazz是包装类(后面会分析该方法)\n\t    Set<Class<?>> wrappers = cachedWrapperClasses;\n\t    if (wrappers == null) {\n\t\tcachedWrapperClasses = new ConcurrentHashSet<Class<?>>();\n\t\twrappers = cachedWrapperClasses;\n\t    }\n\t    //将该扩展实现类添加到包装类集合中\n\t    wrappers.add(clazz);\n\t} else {\n\t    //检测该实现类是否有默认构造方法\n\t    clazz.getConstructor();\n\t    if (name == null || name.length() == 0) {\n\t\t//扩展名称name为空时，则根据规则重新设置name(后面会分析该方法)\n\t\tname = findAnnotationName(clazz);\n\t\tif (name == null || name.length() == 0) {\n\t\t    //name仍然为空\n\t\t    if (clazz.getSimpleName().length() > type.getSimpleName().length()\n\t\t\t    && clazz.getSimpleName().endsWith(type.getSimpleName())) {\n\t\t\t//如果当前扩展实现类的类名以扩展接口type的名称结尾，则截取接口类名称之前的部分作为name，并转换成小写\n\t\t\t//例如：当clazz = JavassistProxyFactory，type = ProxyFactory时，则name = javassist\n\t\t\tname = clazz.getSimpleName().substring(0, clazz.getSimpleName().length() - type.getSimpleName().length()).toLowerCase();\n\t\t    } else {\n\t\t\t//扩展实现类class没有对应的扩展名称，抛异常\n\t\t\tthrow new IllegalStateException(\"No such extension name for the class \" + clazz.getName() + \" in the config \" + resourceURL);\n\t\t    }\n\t\t}\n\t    }\n\t    //使用逗号分隔扩展名称name\n\t    String[] names = NAME_SEPARATOR.split(name);\n\t    if (names != null && names.length > 0) {\n\t        //获取扩展实现类上的@Activate注解\n\t\tActivate activate = clazz.getAnnotation(Activate.class);\n\t\tif (activate != null) {\n\t\t    //存在@Activate注解\n\t\t    //则将第1个扩展名称和@Activate注解缓存起来\n\t\t    cachedActivates.put(names[0], activate);\n\t\t}\n\t\t//遍历扩展名称\n\t\tfor (String n : names) {\n\t\t    if (!cachedNames.containsKey(clazz)) {\n\t\t\t//如果<扩展实现类,name>缓存中不包含该扩展实现类,则保存到缓存\n\t\t\tcachedNames.put(clazz, n);\n\t\t    }\n\t\t    //通过扩展名称n从扩展实现类集合中获取扩展实现类c\n\t\t    Class<?> c = extensionClasses.get(n);\n\t\t    if (c == null) {\n\t\t\t//扩展实现类c不存在，则保存<扩展名称n，扩展实现类clazz>到缓存\n\t\t\textensionClasses.put(n, clazz);\n\t\t    } else if (c != clazz) {\n\t\t\t//一个扩展名称对应多个扩展实现类，则抛异常\n\t\t\tthrow new IllegalStateException(\"Duplicate extension \" + type.getName() + \" name \" + n + \" on \" + c.getName() + \" and \" + clazz.getName());\n\t\t    }\n\t\t}\n\t    }\n\t}\n}\n\n/**\n * 检测扩展实例类clazz是否是包装类。\n * 判断依据是：扩展实现类clazz中有一个接收扩展接口(type接口)作为参数的构造方法\n * @param clazz 扩展实现类\n * @return\n */\nprivate boolean isWrapperClass(Class<?> clazz) {\n\ttry {\n\t    clazz.getConstructor(type);\n\t    return true;\n\t} catch (NoSuchMethodException e) {\n\t    return false;\n\t}\n}\n```\n加载扩展类型接口type对应的扩展实现类流程到此就全部结束了(即上文中介绍的getExtensionClasses()方法流程)。\n\n#### createExtension方法(创建扩展实现类实例)\n我们回到上文中遗留的createExtension(name)方法，看看是如何根据扩展名称name创建扩展实现类实例的。\n```java\n/**\n * 根据扩展名称name创建扩展实现类实例\n * @param name 扩展名称\n * @return 扩展实现类实例\n */\n@SuppressWarnings(\"unchecked\")\nprivate T createExtension(String name) {\n\t//根据扩展名称name获取扩展实现类clazz\n\t//getExtensionClasses()方法我们上文已经介绍过了，拿到扩展类型接口type对应的所有扩展实现类\n\tClass<?> clazz = getExtensionClasses().get(name);\n\tif (clazz == null) {\n\t    //根据扩展名称没有获取到扩展实现类，则抛出异常\n\t    throw findException(name);\n\t}\n\ttry {\n\t    //先从缓存中获取扩展实现类的实例\n\t    T instance = (T) EXTENSION_INSTANCES.get(clazz);\n\t    if (instance == null) {\n\t        //如果没有获取到实例，则新建一个实现类clazz的实例并放入缓存。\n\t\tEXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());\n\t\tinstance = (T) EXTENSION_INSTANCES.get(clazz);\n\t    }\n\t    //处理实现类实例的依赖注入(后面会分析该方法)\n\t    injectExtension(instance);\n\t    //处理包装类\n\t    Set<Class<?>> wrapperClasses = cachedWrapperClasses;\n\t    if (wrapperClasses != null && !wrapperClasses.isEmpty()) {\n\t        //当前扩展接口type存在包装类扩展实现类\n\t\t//遍历包装类列表\n\t\tfor (Class<?> wrapperClass : wrapperClasses) {\n\t\t    //通过参数为type接口的构造方法创建包装类实例(将当前实例instance传递进去)，然后处理包装类的依赖注入\n\t\t    //这里可能会有多个包装类，依次进行包装\n\t\t    instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));\n\t\t}\n\t    }\n\t    //返回扩展实例\n\t    return instance;\n\t} catch (Throwable t) {\n\t    throw new IllegalStateException(\"Extension instance(name: \" + name + \", class: \" +\n\t\t    type + \")  could not be instantiated: \" + t.getMessage(), t);\n\t}\n}\n\n/**\n * 处理扩展实现类实例instance的依赖项，进行依赖注入\n * 通过set方法注入依赖项\n * @param instance 扩展实现类的实例\n * @return\n */\nprivate T injectExtension(T instance) {\n\ttry {\n\t    //判断加载器是否为空\n\t    if (objectFactory != null) {\n\t        //遍历实现类中的方法\n\t\tfor (Method method : instance.getClass().getMethods()) {\n\t\t    //找到参数长度为1、public修饰符的set方法\n\t\t    if (method.getName().startsWith(\"set\")\n\t\t\t    && method.getParameterTypes().length == 1\n\t\t\t    && Modifier.isPublic(method.getModifiers())) {\n\t\t\t//获取set方法的参数类型\n\t\t\tClass<?> pt = method.getParameterTypes()[0];\n\t\t\ttry {\n\t\t\t    //截取set方法的方法名，去掉\"set\"字符，并将余下的字符转换成小写字母，作为属性\n\t\t\t    String property = method.getName().length() > 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : \"\";\n\t\t\t    //从扩展工厂中找到该依赖项实例(pt为依赖项的类型，property为依赖项的名称)\n\t\t\t    Object object = objectFactory.getExtension(pt, property);\n\t\t\t    if (object != null) {\n\t\t\t\t//依赖项实例存在的话，通过该set方法则将该依赖项实例注入到扩展实现类实例instance中\n\t\t\t\tmethod.invoke(instance, object);\n\t\t\t    }\n\t\t\t} catch (Exception e) {\n\t\t\t    logger.error(\"fail to inject via method \" + method.getName()\n\t\t\t\t    + \" of interface \" + type.getName() + \": \" + e.getMessage(), e);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t} catch (Exception e) {\n\t    logger.error(e.getMessage(), e);\n\t}\n\t//返回扩展实现类的实例\n\treturn instance;\n}\n```\n以上便是获取扩展实例的过程，最终会将扩展实例放入到缓存变量cachedInstances中,即<扩展名称，扩展实例>。\n\n#### getActivateExtension方法\n接下来我们在看下ExtensionLoader类中的getActivateExtension方法，通过该方法可以得到已启用的扩展列表\n```java\n/**\n * key为url中标识扩展名称的参数\n */\npublic List<T> getActivateExtension(URL url, String key) {\n\t//调用了下面的重载方法\n\treturn getActivateExtension(url, key, null);\n}\n\npublic List<T> getActivateExtension(URL url, String key, String group) {\n\t//从url中获取参数key对应的值(即获取扩展名称)\n\tString value = url.getParameter(key);\n\t//调用了下面的重载方法\n\treturn getActivateExtension(\n\t\turl, \n\t\tvalue == null || value.length() == 0 ? null : Constants.COMMA_SPLIT_PATTERN.split(value), \n\t\tgroup\n\t);\n}\n\n/**\n * 获取已启用的扩展列表\n * url \n * values为扩展名称列表\n * group为配置的组\n */\npublic List<T> getActivateExtension(URL url, String[] values, String group) {\n\tList<T> exts = new ArrayList<T>();\n\t//扩展名称数组\n\tList<String> names = values == null ? new ArrayList<String>(0) : Arrays.asList(values);\n\t//names是否包含-default\n\tif (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) {\n\t    //先获取下扩展接口type的扩展实现类集合(上文介绍过该方法)\n\t    //执行getExtensionClasses方法时，会将存在@Activate注解的实现类缓存起来：<扩展名称，Activate注解>\n\t    getExtensionClasses();\n\t    //遍历cachedActivates集合\n\t    for (Map.Entry<String, Activate> entry : cachedActivates.entrySet()) {\n\t\t//扩展名称\n\t\tString name = entry.getKey();\n\t\t//@Activate注解\n\t\tActivate activate = entry.getValue();\n\t\t//group是否匹配(后面会分析该方法)\n\t\tif (isMatchGroup(group, activate.group())) {\n\t\t    //根据扩展名称name获取扩展实例\n\t\t    T ext = getExtension(name);\n\t\t    if (!names.contains(name)\n\t\t\t    && !names.contains(Constants.REMOVE_VALUE_PREFIX + name)\n\t\t\t    && isActive(activate, url)) {\n\t\t\t//当扩展名称数组不包含该扩展名name，并且不包含-name，并且已激活时，\n\t\t\t//将当前扩展实例添加到返回结果集中\n\t\t\texts.add(ext);\n\t\t    }\n\t\t}\n\t    }\n\t    //按照配置的before()和after()/order()进行排序\n\t    Collections.sort(exts, ActivateComparator.COMPARATOR);\n\t}\n\tList<T> usrs = new ArrayList<T>();\n\tfor (int i = 0; i < names.size(); i++) {\n\t    //当前扩展名称name\n\t    String name = names.get(i);\n\t    if (!name.startsWith(Constants.REMOVE_VALUE_PREFIX)\n\t\t    //当前扩展名称name不是以-开头，并且扩展名称数组names不包含-name时，\n\t\t    && !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) {\n\t\tif (Constants.DEFAULT_KEY.equals(name)) {\n\t\t    //当前扩展名称name=default\n\t\t    if (!usrs.isEmpty()) {\n\t\t        //usrs不为空，将usrs集合添加到exts头部\n\t\t\texts.addAll(0, usrs);\n\t\t\t//清空usrs\n\t\t\tusrs.clear();\n\t\t    }\n\t\t} else {\n\t\t    //当前扩展名称name != default时，获取该name的扩展实例，并存起来\n\t\t    T ext = getExtension(name);\n\t\t    usrs.add(ext);\n\t\t}\n\t    }\n\t}\n\tif (!usrs.isEmpty()) {\n\t    exts.addAll(usrs);\n\t}\n\treturn exts;\n}\n\n/**\n * group是否匹配\n * 1、group为空，则匹配\n * 2、group在groups中存在，则匹配\n * @param group\n * @param groups @Activate中配置的group数组\n * @return\n */\nprivate boolean isMatchGroup(String group, String[] groups) {\n\tif (group == null || group.length() == 0) {\n\t    return true;\n\t}\n\tif (groups != null && groups.length > 0) {\n\t    for (String g : groups) {\n\t\tif (group.equals(g)) {\n\t\t    return true;\n\t\t}\n\t    }\n\t}\n\treturn false;\n}\n/**\n * 是否已激活\n * 1、@activate没有配置value()\n * 2、@Activate中配置的value()在url的参数列表中存在,且url参数对应的value不为空\n * @param activate\n * @param url\n * @return\n */\nprivate boolean isActive(Activate activate, URL url) {\n        //获取@Activate注解中配置的keys\n\tString[] keys = activate.value();\n\tif (keys.length == 0) {\n\t    return true;\n\t}\n\tfor (String key : keys) {\n\t    for (Map.Entry<String, String> entry : url.getParameters().entrySet()) {\n\t\tString k = entry.getKey();\n\t\tString v = entry.getValue();\n\t\tif ((k.equals(key) || k.endsWith(\".\" + key))\n\t\t\t&& ConfigUtils.isNotEmpty(v)) {\n\t\t    return true;\n\t\t}\n\t    }\n\t}\n\treturn false;\n}\n```\n\n#### getAdaptiveExtension方法\n接下来看下getAdaptiveExtension方法，该方法用来获取扩展接口type对应的自适应扩展实例。\n```java\n\n/**\n * 缓存的自适应实例\n */\nprivate final Holder<Object> cachedAdaptiveInstance = new Holder<Object>();\n\n/**\n * 记录创建自适应扩展实例时发生的异常\n */\nprivate volatile Throwable createAdaptiveInstanceError;\n\n\n/**\n * 获取扩展接口type的自适应扩展实例\n */\npublic T getAdaptiveExtension() {\n\t//先从缓存中获取\n\tObject instance = cachedAdaptiveInstance.get();\n\tif (instance == null) {\n\t    //缓存中不存在\n\t    //判断createAdaptiveInstanceError变量是否为空，不为空说明之前创建自适应实例时发生了异常\n\t    if (createAdaptiveInstanceError == null) {\n\t        //没有发生异常，同步创建自适应扩展实例\n\t\tsynchronized (cachedAdaptiveInstance) {\n\t\t    //再次验证缓存中是否存在该实例\n\t\t    instance = cachedAdaptiveInstance.get();\n\t\t    if (instance == null) {\n\t\t\ttry {\n\t\t\t    //创建自适应扩展实例(后面会分析该方法)\n\t\t\t    instance = createAdaptiveExtension();\n\t\t\t    //将创建好的实例保存进缓存\n\t\t\t    cachedAdaptiveInstance.set(instance);\n\t\t\t} catch (Throwable t) {\n\t\t\t    //创建实例时发生异常，记录异常\n\t\t\t    createAdaptiveInstanceError = t;\n\t\t\t    throw new IllegalStateException(\"fail to create adaptive instance: \" + t.toString(), t);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    } else {\n\t\tthrow new IllegalStateException(\"fail to create adaptive instance: \" + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);\n\t    }\n\t}\n\treturn (T) instance;\n}\n\n/**\n * 为扩展接口type创建自适应扩展实例，并处理依赖注入\n * @return\n */\nprivate T createAdaptiveExtension() {\n\ttry {\n\t    //在这里调用了getAdaptiveExtensionClass方法获取到自适应扩展类，然后生成实例\n\t    return injectExtension((T) getAdaptiveExtensionClass().newInstance());\n\t} catch (Exception e) {\n\t    throw new IllegalStateException(\"Can not create adaptive extension \" + type + \", cause: \" + e.getMessage(), e);\n\t}\n}\n\n/**\n * 获取扩展接口type的自适应扩展类\n * @return\n */\nprivate Class<?> getAdaptiveExtensionClass() {\n        //加载扩展接口type对应的所有扩展实现类(上文介绍过该方法)\n\tgetExtensionClasses();\n\t//查看缓存中是否已经存在扩展接口type对应的自适应扩展类，如果存在，则直接返回(调用getExtensionClasses方法时，会去设置cachedAdaptiveClass值)\n\tif (cachedAdaptiveClass != null) {\n\t    return cachedAdaptiveClass;\n\t}\n\t//不存在的话，为该扩展接口type创建一个自适应扩展类(后面会分析该方法)\n\treturn cachedAdaptiveClass = createAdaptiveExtensionClass();\n}\n\n/**\n * 扩展接口type不存在自适应扩展类的时候，dubbo默认会为其创建\n * 创建条件：type接口的方法中必须有一个带@Adaptive注解的方法dubbo才会创建自适应扩展类\n * @return\n */\nprivate Class<?> createAdaptiveExtensionClass() {\n\t//生成自适应扩展实现类的代码(后面会分析该方法)\n\tString code = createAdaptiveExtensionClassCode();\n\t//获取类加载器\n\tClassLoader classLoader = findClassLoader();\n\t//获取Compiler自适应扩展实例\n\tcom.alibaba.dubbo.common.compiler.Compiler compiler =\n\t\tExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class)\n\t\t\t.getAdaptiveExtension();\n\t//编译code(后面会分析该方法)\n\treturn compiler.compile(code, classLoader);\n}\n```\n\n接下来的createAdaptiveExtensionClassCode方法比较长，在分析之前，我们先来看下ProxyFactory接口，我们将使用该接口作为例子(即假设当前扩展接口type为ProxyFactory),配合着该方法一起看：\n```java\n@SPI(\"javassist\")\npublic interface ProxyFactory {\n    \n    //@Adaptive({\"proxy\"})\n    @Adaptive({Constants.PROXY_KEY})\n    <T> T getProxy(Invoker<T> invoker) throws RpcException;\n   \n    @Adaptive({Constants.PROXY_KEY})\n    <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException;\n```\n可以看到该接口上添加了@SPI(\"javassist\")注解、接口方法上添加了@Adaptive({Constants.PROXY_KEY})\n\n```java\n/**\n* 为扩展接口type生成自适应扩展类的类代码\n* 假设 type = com.alibaba.dubbo.rpc.ProxyFactory\n* @return\n*/\nprivate String createAdaptiveExtensionClassCode() {\n\tStringBuilder codeBuilder = new StringBuilder();\n\t//获取扩展接口type的方法列表，查看方法上是否存在@Adaptive注解，\n\t//如果不存在@Adaptive注解，则不用生成自适应扩展类\n\tMethod[] methods = type.getMethods();\n\tboolean hasAdaptiveAnnotation = false;\n\tfor (Method m : methods) {\n\t    if (m.isAnnotationPresent(Adaptive.class)) {\n\t\thasAdaptiveAnnotation = true;\n\t\tbreak;\n\t    }\n\t}\n\t// 不存在带有@Adaptive注解的方法，因此不需要生成自适应扩展类\n\tif (!hasAdaptiveAnnotation) {\n\t    throw new IllegalStateException(\"No adaptive method on extension \" + type.getName() + \", refuse to create the adaptive class!\");\n\t}\n\t//添加包声明：type扩展接口所在包包名\n\t//package com.alibaba.dubbo.rpc;\n\tcodeBuilder.append(\"package \").append(type.getPackage().getName()).append(\";\");\n\n\t//import com.alibaba.dubbo.common.extension.ExtensionLoader;\n\tcodeBuilder.append(\"\\nimport \").append(ExtensionLoader.class.getName()).append(\";\");\n\t\n\t//可以看到生成的实现类名称为ProxyFactory$Adaptive，实现了ProxyFactory接口\n\t//public class com.alibaba.dubbo.rpc.ProxyFactory$Adaptive implements com.alibaba.dubbo.rpc.ProxyFactory{\n\tcodeBuilder.append(\"\\npublic class \")\n\t\t.append(type.getSimpleName())\n\t\t.append(\"$Adaptive\")\n\t\t.append(\" implements \")\n\t\t.append(type.getCanonicalName()).append(\" {\");\n\n\t//遍历type接口的方法\n\tfor (Method method : methods) {\n\t    //接口方法返回类型\n\t    Class<?> rt = method.getReturnType();\n\t    //接口方法参数类型数组\n\t    Class<?>[] pts = method.getParameterTypes();\n\t    //接口方法异常类型数组\n\t    Class<?>[] ets = method.getExceptionTypes();\n\t   \n\t    //判断当前方法上是否存在@Adaptive注解\n\t    Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class);\n            //方法内容\n\t    StringBuilder code = new StringBuilder(512);\n\t    if (adaptiveAnnotation == null) {\n\t\t//添加异常：type接口的当前方法不是一个adaptive方法\n\t\tcode.append(\"throw new UnsupportedOperationException(\\\"method \")\n\t\t\t.append(method.toString()).append(\" of interface \")\n\t\t\t.append(type.getName()).append(\" is not adaptive method!\\\");\");\n\t    } else {\n\t\t//获取到的当前方法的\"URL类型参数/返回URL类型的get方法的参数\"的下标（在当前方法参数中的下标）\n\t\tint urlTypeIndex = -1;\n\t\t//遍历当前方法参数\n\t\tfor (int i = 0; i < pts.length; ++i) {\n\t\t    if (pts[i].equals(URL.class)) {\n\t\t        //第i个下标是URL类型的参数\n\t\t\turlTypeIndex = i;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (urlTypeIndex != -1) {\n\t\t    //从当前方法参数中找到了URL类型的参数\n\t\t    //添加\"校验Url类型参数是否为空\"的code\n\t\t    String s = String.format(\"\\nif (arg%d == null) throw new IllegalArgumentException(\\\"url == null\\\");\",\n\t\t\t    urlTypeIndex);\n\t\t    code.append(s);\n\t\t    \n\t\t    //添加\"声明url类型的变量\"的code\n\t\t    //URL url = arg{$urlTypeIndex}\n\t\t    s = String.format(\"\\n%s url = arg%d;\", URL.class.getName(), urlTypeIndex);\n\t\t    code.append(s);\n\t\t}else {\n\t\t    //从当前方法参数中没有找到URL类型的参数\n\t\t    //返回URL类型的get方法的名称\n\t\t    String attribMethod = null;\n\n\t\t    //遍历参数列表，查询每个参数的方法列表，查找返回URL类型的get方法\n\t\t    LBL_PTS:\n\t\t    //遍历当前方法参数\n\t\t    for (int i = 0; i < pts.length; ++i) {\n\t\t\t//遍历方法第i个参数的所有方法\n\t\t\tMethod[] ms = pts[i].getMethods();\n\t\t\tfor (Method m : ms) {\n\t\t\t    //当前方法名\n\t\t\t    String name = m.getName();\n\t\t\t    //当前方法没有参数，且返回值是URL类型，以get开头或者长度>3,且是public修饰，没有static修饰\n\t\t\t    if ((name.startsWith(\"get\") || name.length() > 3)\n\t\t\t\t    && Modifier.isPublic(m.getModifiers())\n\t\t\t\t    && !Modifier.isStatic(m.getModifiers())\n\t\t\t\t    && m.getParameterTypes().length == 0\n\t\t\t\t    && m.getReturnType() == URL.class) {\n\t\t\t\t//方法的第i个参数是\"返回URL类型的get方法\"\n\t\t\t\turlTypeIndex = i;\n\t\t\t\t//“返回URL类型的get方法的名称”\n\t\t\t\tattribMethod = name;\n\t\t\t\t//跳转到LBL_PTS\n\t\t\t\tbreak LBL_PTS;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (attribMethod == null) {\n\t\t\t//没有找到返回URL类型的方法，抛异常\n\t\t\tthrow new IllegalStateException(\"fail to create adaptive class for interface \" + type.getName()\n\t\t\t\t+ \": not found url parameter or url attribute in parameters of method \" + method.getName());\n\t\t    }\n\t\t\t\n\t\t    //添加“方法第urlTypeIndex个参数为空的判断”\n\t\t    String s = String.format(\"\\nif (arg%d == null) throw new IllegalArgumentException(\\\"%s argument == null\\\");\",\n\t\t\t    urlTypeIndex, pts[urlTypeIndex].getName());\n\t\t    code.append(s);\n\t\t\t\n\t\t    //添加“方法第urlTypeIndex个参数的attribMethod方法的返回值为空的判断”\n\t\t    s = String.format(\"\\nif (arg%d.%s() == null) throw new IllegalArgumentException(\\\"%s argument %s() == null\\\");\",\n\t\t\t    urlTypeIndex, attribMethod, pts[urlTypeIndex].getName(), attribMethod);\n\t\t    code.append(s);\n\n\t\t    //添加：com.alibaba.dubbo.common.URL url = arg{$urlTypeIndex}.attribMethod();\n\t\t    s = String.format(\"%s url = arg%d.%s();\", URL.class.getName(), urlTypeIndex, attribMethod);\n\t\t    code.append(s);\n\t\t}\n\t\t//@Adaptive注解的value值\n\t\tString[] value = adaptiveAnnotation.value();\n\t\tif (value.length == 0) {\n\t\t    //没有设置value，则根据扩展接口名称按照一定规则生成value\n\t\t    //如：ProxyFactory 将生成value：proxy.factory\n\t\t    //则charArray = [P,r,o,x,y,F,a,c,t,o,r,y]\n\t\t    char[] charArray = type.getSimpleName().toCharArray();\n\t\t    StringBuilder sb = new StringBuilder(128);\n\t\t    for (int i = 0; i < charArray.length; i++) {\n\t\t\tif (Character.isUpperCase(charArray[i])) {\n\t\t\t    //当前字符是大写的\n\t\t\t    if (i != 0) {\n\t\t\t        //当前字符不是第1个字符，则添加“.”到sb中\n\t\t\t\tsb.append(\".\");\n\t\t\t    }\n\t\t\t    //将当前字符转为小写，并添加到sb中\n\t\t\t    sb.append(Character.toLowerCase(charArray[i]));\n\t\t\t} else {\n\t\t\t    //当前字符是小写的，直接添加到sb中\n\t\t\t    sb.append(charArray[i]);\n\t\t\t}\n\t\t    }\n\t\t    //生成的value = [{\"proxy.factory\"}]\n\t\t    value = new String[]{sb.toString()};\n\t\t}\n\t\t//当前方法中是否存在Invocation类型的参数\n\t\tboolean hasInvocation = false;\n\t\tfor (int i = 0; i < pts.length; ++i) {\n\t\t    //当前方法的第i个参数名称是否为“com.alibaba.dubbo.rpc.Invocation”\n\t\t    if (pts[i].getName().equals(\"com.alibaba.dubbo.rpc.Invocation\")) {\n\t\t\t//添加\"校验参数Invocation是否为空\"的code\n\t\t\tString s = String.format(\"\\nif (arg%d == null) throw new IllegalArgumentException(\\\"invocation == null\\\");\", i);\n\t\t\tcode.append(s);\n\t\t\t//添加\"获取方法名\"的code\n\t\t\ts = String.format(\"\\nString methodName = arg%d.getMethodName();\", i);\n\t\t\tcode.append(s);\n\t\t\t//标识 存在Invocation类型的参数\n\t\t\thasInvocation = true;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t//@SPI注解上配置的值，默认扩展名称\n\t\tString defaultExtName = cachedDefaultName;\n\t\tString getNameCode = null;\n\t\t//遍历@Adaptive注解的value数组\n\t\tfor (int i = value.length - 1; i >= 0; --i) {\n\t\t    if (i == value.length - 1) {\n\t\t        //当前i为value的最后1个元素\n\t\t\tif (null != defaultExtName) {\n\t\t\t    //默认扩展名称不为空，如果没有获取到值，则会使用默认值\n\t\t\t    //第i个元素是否等于protocol\n\t\t\t    if (!\"protocol\".equals(value[i])) {\n\t\t\t\tif (hasInvocation) {\n\t\t\t\t    //存在Invocation类型的参数\n\t\t\t\t    //调用url的getMethodParameter方法，获取value[i]对应的扩展名，如果为空，则取默认扩展名defaultExtName\n\t\t\t\t    getNameCode = String.format(\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName);\n\t\t\t\t} else {\n\t\t\t\t    //不存在Invocation类型的参数\n\t\t\t\t    //从url的value[i]参数中(当前例子为proxy)获取扩展名，如果没有获取到，则使用默认扩展名javassist\n\t\t\t\t    //url.getParameter(\"proxy\",\"javassist\")\n\t\t\t\t    getNameCode = String.format(\"url.getParameter(\\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName);\n\t\t\t\t}\n\t\t\t    } else {\n\t\t\t        //第i个元素等于protocol\n\t\t\t\t//从url中获取protocol属性值，如果没有获取到，则使用默认扩展名defaultExtName\n\t\t\t\tgetNameCode = String.format(\"( url.getProtocol() == null ? \\\"%s\\\" : url.getProtocol() )\", defaultExtName);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    //默认扩展名称为空，如果没有获取到值，则不会使用默认值\n\t\t\t    if (!\"protocol\".equals(value[i])) {\n\t\t\t\tif (hasInvocation) {\n\t\t\t\t    getNameCode = String.format(\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName);\n\t\t\t\t} else {\n\t\t\t\t    //从url中获取参数value[i]对应的值\n\t\t\t\t    getNameCode = String.format(\"url.getParameter(\\\"%s\\\")\", value[i]);\n\t\t\t\t}\n\t\t\t    } else {\n\t\t\t        //从url中获取protocol属性值\n\t\t\t\tgetNameCode = \"url.getProtocol()\";\n\t\t\t    }\n\t\t\t}\n\t\t    } else {\n\t\t        //当前第i个元素不是value最后一个元素\n\t\t\tif (!\"protocol\".equals(value[i])) {\n\t\t\t    if (hasInvocation) {\n\t\t\t\tgetNameCode = String.format(\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName);\n\t\t\t    } else {\n\t\t\t\tgetNameCode = String.format(\"url.getParameter(\\\"%s\\\", %s)\", value[i], getNameCode);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    getNameCode = String.format(\"url.getProtocol() == null ? (%s) : url.getProtocol()\", getNameCode);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\t\n\t\t//添加：String extName = url.getParameter(\"proxy\", \"javassist\");\n\t\t//获取扩展名\n\t\tcode.append(\"\\nString extName = \").append(getNameCode).append(\";\");\n\t\t\n\t\t//添加“校验扩展名不为空”的code\n\t\tString s = String.format(\"\\nif(extName == null) \" +\n\t\t\t\t\"throw new IllegalStateException(\\\"Fail to get extension(%s) name from url(\\\" + url.toString() + \\\") use keys(%s)\\\");\",\n\t\t\ttype.getName(), Arrays.toString(value));\n\t\tcode.append(s);\n\n\t\t//添加\"根据扩展名获取扩展实例\"的code\n\t\t//com.alibaba.dubbo.rpc.ProxyFactory extension = (com.alibaba.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.ProxyFactory.class).getExtension(extName) ;\n\t\ts = String.format(\"\\n%s extension = (%<s)%s.getExtensionLoader(%s.class).getExtension(extName);\",\n\t\t\ttype.getName(), ExtensionLoader.class.getSimpleName(), type.getName());\n\t\tcode.append(s);\n\n\t\t//处理返回值\n\t\tif (!rt.equals(void.class)) {\n\t\t    //返回值不是void类型\n\t\t    code.append(\"\\nreturn \");\n\t\t}\n\n\t\t//例如：return extension.getInvoker(arg0);\n\t\t//这里的逻辑就是：根据扩展名称的不同获取相应的扩展实现，然后调用方法，并返回\n\t\ts = String.format(\"extension.%s(\", method.getName());\n\t\t//先填写调用信息\n\t\tcode.append(s);\n\t\t\n\t\t//遍历当前方法参数，添加方法参数\n\t\tfor (int i = 0; i < pts.length; i++) {\n\t\t    if (i != 0) {\n\t\t\tcode.append(\", \");\n\t\t    }\n\t\t    code.append(\"arg\").append(i);\n\t\t}\n\t\tcode.append(\");\");\n\t    }\n\n\t    //生成方法签名code\n\t    //如：public java.lang.Object getProxy(com.alibaba.dubbo.rpc.Invoker arg0) throws com.alibaba.dubbo.rpc.RpcException\n\t    codeBuilder.append(\"\\npublic \")\n\t\t    .append(rt.getCanonicalName())\n\t\t    .append(\" \")\n\t\t    .append(method.getName())\n\t\t    .append(\"(\");\n\n            //添加参数\n\t    for (int i = 0; i < pts.length; i++) {\n\t\tif (i > 0) {\n\t\t    codeBuilder.append(\", \");\n\t\t}\n\t\tcodeBuilder.append(pts[i].getCanonicalName());\n\t\tcodeBuilder.append(\" \");\n\t\tcodeBuilder.append(\"arg\").append(i);\n\t    }\n\t    codeBuilder.append(\")\");\n\n\t    //添加异常\n\t    if (ets.length > 0) {\n\t\tcodeBuilder.append(\" throws \");\n\t\tfor (int i = 0; i < ets.length; i++) {\n\t\t    if (i > 0) {\n\t\t\tcodeBuilder.append(\", \");\n\t\t    }\n\t\t    codeBuilder.append(ets[i].getCanonicalName());\n\t\t}\n\t    }\n\t   \n\t    codeBuilder.append(\" {\");\n\t     //将方法code添加到方法代码块中\n\t    codeBuilder.append(code.toString());\n\t    codeBuilder.append(\"\\n}\");\n\t}\n\tcodeBuilder.append(\"\\n}\");\n\tif (logger.isDebugEnabled()) {\n\t    logger.debug(codeBuilder.toString());\n\t}\n\t//返回生产的code\n\treturn codeBuilder.toString();\n}\n```\n以type = com.alibaba.dubbo.rpc.ProxyFactory为例子，生成的代码大概如下所示:\n```java\npackage com.alibaba.dubbo.rpc;\nimport com.alibaba.dubbo.common.extension.ExtensionLoader;\n\npublic class ProxyFactory$Adaptive implements com.alibaba.dubbo.rpc.ProxyFactory {\n\n    public java.lang.Object getProxy(com.alibaba.dubbo.rpc.Invoker arg0) throws com.alibaba.dubbo.rpc.RpcException {\n\t if (arg0 == null){\n\t    throw new IllegalArgumentException(\"com.alibaba.dubbo.rpc.Invoker argument == null\");\n\t }\n\t if (arg0.getUrl() == null) {\n\t    throw new IllegalArgumentException(\"com.alibaba.dubbo.rpc.Invoker argument getUrl() == null\");\n\t }\n\t com.alibaba.dubbo.common.URL url = arg0.getUrl();\n\t String extName = url.getParameter(\"proxy\", \"javassist\");\n\t if(extName == null) {\n\t    throw new IllegalStateException(\"Fail to get extension(com.alibaba.dubbo.rpc.ProxyFactory) name from url(\" + url.toString() + \") use keys([proxy])\");\n\t }\n\t com.alibaba.dubbo.rpc.ProxyFactory extension = (com.alibaba.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.ProxyFactory.class).getExtension(extName);\n\t return extension.getProxy(arg0);\n    }\n\n    public com.alibaba.dubbo.rpc.Invoker getInvoker(java.lang.Object arg0, java.lang.Class arg1, com.alibaba.dubbo.common.URL arg2) throws com.alibaba.dubbo.rpc.RpcException {\n\tif (arg2 == null) {\n\t    throw new IllegalArgumentException(\"url == null\");\n\t}\n\tcom.alibaba.dubbo.common.URL url = arg2;\n\tString extName = url.getParameter(\"proxy\", \"javassist\");\n\tif(extName == null){\n\t    throw new IllegalStateException(\"Fail to get extension(com.alibaba.dubbo.rpc.ProxyFactory) name from url(\" + url.toString() + \") use keys([proxy])\");\n\t}\n\tcom.alibaba.dubbo.rpc.ProxyFactory extension = (com.alibaba.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.ProxyFactory.class).getExtension(extName);\n\treturn extension.getInvoker(arg0, arg1, arg2);\n    }\n}\n```\n以上就是生成自适应实现类的全部内容，生成好代码后，会交由Compiler扩展进行编译得到Class对象，然后在本小节开头介绍的createAdaptiveExtension()方法中进行实例化，并进行依赖注入。\n本文内容过多，Compiler编译的部分就放到后面的博文中在介绍了。另外ExtensionLoader类中也提供了很多辅助方法，内容比较简单，在这里就不详细介绍了。\n\n### ExtensionFactory工厂实现\n```\n@SPI\npublic interface ExtensionFactory {\n    /**\n     * 获取扩展实现类实例\n     * Get extension.\n     * @param type object type. 扩展接口类型\n     * @param name object name. 扩展名称\n     * @return object instance. 返回扩展实例\n     */\n    <T> T getExtension(Class<T> type, String name);\n}\n```\n该接口根据扩展类型和扩展名称获取扩展实例。可以看到该接口声明上也加上了@SPI注解，说明存在多种实现，Dubbo提供了三种实现，分别为AdaptiveExtensionFactory、SpiExtensionFactory、SpringExtensionFactory.\n\n#### SpringExtensionFactory\n```java\npublic class SpringExtensionFactory implements ExtensionFactory {\n\n    /**\n     * 保存所有的ApplicationContext上下文对象\n     */\n    private static final Set<ApplicationContext> contexts = new ConcurrentHashSet<ApplicationContext>();\n\n    /**\n     * 添加ApplicationContext\n     */\n    public static void addApplicationContext(ApplicationContext context) {\n        contexts.add(context);\n    }\n\n    /**\n     * 移除ApplicationContext\n     */\n    public static void removeApplicationContext(ApplicationContext context) {\n        contexts.remove(context);\n    }\n\n    @Override\n    public <T> T getExtension(Class<T> type, String name) {\n        //遍历所有的context\n        for (ApplicationContext context : contexts) {\n            //判断该context上下文是否包含此bean\n            if (context.containsBean(name)) {\n                //根据名称获取context中的bean\n                Object bean = context.getBean(name);\n                //判断该bean是否是type类型的实例，如果是的话，则返回该bean\n                if (type.isInstance(bean)) {\n                    return (T) bean;\n                }\n            }\n        }\n        return null;\n    }\n}\n```\n\n#### SpiExtensionFactory\n\n```java\npublic class SpiExtensionFactory implements ExtensionFactory {\n\n    @Override\n    public <T> T getExtension(Class<T> type, String name) {\n        //判断类型type是否是接口，并且存在@SPI注解\n        if (type.isInterface() && type.isAnnotationPresent(SPI.class)) {\n            //获取扩展接口type的扩展加载器\n            ExtensionLoader<T> loader = ExtensionLoader.getExtensionLoader(type);\n\t    //通过扩展加载器获取接口type支持的所有扩展的名称列表\n            if (!loader.getSupportedExtensions().isEmpty()) {\n                //返回自适应扩展实例\n                return loader.getAdaptiveExtension();\n            }\n        }\n        return null;\n    }\n}\n```\n\n#### AdaptiveExtensionFactory\n该ExtensionFactory实现存在@Adaptive注解，因此它是自适应实现。\n\n```java\n@Adaptive\npublic class AdaptiveExtensionFactory implements ExtensionFactory {\n\n    /**\n     * ExtensionFactory扩展实现类实例集合\n     */\n    private final List<ExtensionFactory> factories;\n\n    public AdaptiveExtensionFactory() {\n        //获取ExtensionFactory.class对应的扩展加载器\n        ExtensionLoader<ExtensionFactory> loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);\n        \n        List<ExtensionFactory> list = new ArrayList<ExtensionFactory>();\n        \n        //遍历扩展接口ExtensionFactory支持的扩展名称列表(spi、spring)\n        for (String name : loader.getSupportedExtensions()) {\n            //根据扩展名称name加载扩展实现类实例\n            list.add(loader.getExtension(name));\n        }\n        factories = Collections.unmodifiableList(list);\n    }\n\n    /**\n     * 自适应的扩展工厂，挨个遍历spring和spi，从中查询指定类型的实例\n     * @param type object type. 扩展接口类型\n     * @param name object name. 扩展名称\n     * @param <T>\n     * @return\n     */\n    @Override\n    public <T> T getExtension(Class<T> type, String name) {\n        //遍历ExtensionFactory实现类集合，从中挨个查找指定类型的扩展\n        for (ExtensionFactory factory : factories) {\n            //获取type类型的扩展实例\n            T extension = factory.getExtension(type, name);\n            if (extension != null) {\n               //实例不为空，返回实例 \n               return extension;\n            }\n        }\n        return null;\n    }\n}\n```\n\n到此，关于SPI的实现就全部介绍完了，下一小节将会介绍和Sping集成相关的内容。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["dubbo"]},{"title":"Spring注解之@Import注解","url":"/blog/2018/07/30/Spring注解之-Import注解/","content":">本小节介绍Spring提供的@Import注解\n\n* @Import注解的作用\n* @Import注解的定义\n* @Import注解的使用\n\n### @Import注解的作用\n表示要导入1个或多个@Configuration配置类。提供了与Spring XML中的<import/>元素等效的作用.\n@Import注解允许我们使用导入的方式将实例添加到Spring BeanFactory中.允许我们导入@Configuration类、ImportSelector接口和ImportBeanDefinitionRegistrar接口的实现类,类似于AnnotationConfigApplicationContext类的register方法。\n\n### @Import注解的定义\n可以看到该注解只可以使用在类上.\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Import {\n\t/**\n\t * {@link Configuration}, {@link ImportSelector}, {@link ImportBeanDefinitionRegistrar}\n\t * or regular component classes to import.\n\t */\n\tClass<?>[] value();\n}\n```\n### @Import注解的使用\n\n接下来，我们分别介绍这三种使用方式,我们先创建一些测试类和测试方法:\n```java\npackage org.dubbo.import;\npublic class A{}\n\npublic class B{}\n\npublic class C{}\n\npublic class D{}\n\n//测试方法\npublic static void main(String args[]){\n   //创建配置上下文\n   AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\n   //注册当前配置 Bean\n   context.register(DubboConfiguration.class);\n   context.refresh();\n   \n   //获取所有已注册的beanNames\n   String[] beanNames = context.getBeanDefinitionNames();\n   for(String beanName : beanNames){\n       //输出beanNames\n       System.out.println(\"beanName -> \"+ beanName);\n   }\n}\n```\n\n#### Configuration方式\n```java\n@Import({A.class,B.class})\n@Configuration\npublic class DubboConfig{} \n```\n执行测试方法，将会输出：\n```java\nbeanName -> DubboConfig\nbeanName -> org.dubbo.import.A\nbeanName -> org.dubbo.import.B\n```\n\n#### 实现ImportSelector接口方式\n```java\n/**\n * ImportSelector实现类\n */\npublic class DubboImportSelector implements ImportSelector{\n    public String[] selectImports(AnnotationMetadata metadata) {\n        return new String[]{\"org.dubbo.import.C\"};\n    }\n}\n\n/**\n * 修改配置\n */\n@Import({A.class,B.class,DubboImportSelector.class})\n@Configuration\npublic class DubboConfig{}\n```\n\n执行测试方法，将会输出：\n```java\nbeanName -> DubboConfig\nbeanName -> org.dubbo.import.A\nbeanName -> org.dubbo.import.B\nbeanName -> org.dubbo.import.C\n```\n\n#### 实现ImportBeanDefinitionRegistrar接口方式\n\n```java\n/**\n *\n * ImportBeanDefinitionRegistrar实现类\n */\npublic class DubboImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar{\n    \n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata metadata,BeanDefinitionRegistry registry) {\n        //创建一个D类的rootBeanDefinition对象\n        RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(D.class);\n        //注册beanName=d的bean\n        registry.registerBeanDefinition(\"d\", rootBeanDefinition);\n    }\n}\n\n/**\n * 修改配置\n */\n@Import({A.class,B.class,DubboImportSelector.class,DubboImportBeanDefinitionRegistrar.class})\n@Configuration\npublic class DubboConfig{}\n```\n\n然后执行测试方法，将会输出：\n```java\nbeanName -> DubboConfig\nbeanName -> org.dubbo.import.A\nbeanName -> org.dubbo.import.B\nbeanName -> org.dubbo.import.C\nbeanName -> org.dubbo.import.D\n```\n\n可以看到，我们成功将A/B/C/D添加到了BeanFactory中.\n","tags":["spring"]},{"title":"自己动手实现Idea插件","url":"/blog/2018/07/29/自己动手实现Idea插件/","content":">在阅读开源项目源代码的时候，会时常一起读作者写的注释来理解代码的意图，对于英文不好的码农来说实在是比较吃力，或者当我们在写代码的时候，为了一个变量名称纠结半天时，都会需要一个强大的词典来支持我们的工作，用有道词典的话，启动过慢、电脑太卡、来回切换屏幕会感觉很不爽还好Idea提供了强大的插件扩展能力，能让我们在集成开发环境中嵌入翻译引擎，当然只要有足够的想象力，可以在Idea集成环境中开发各种插件，自定义自己的开发环境，比如下面的炫酷插件\n![](img/1.gif)\n本文就向大家介绍一下如何开发一个Idea翻译插件。\n首先，打开Idea集成开发环境，然后新建一个Idea plugin项目：\n![](img/2.jpg)\n然后输入项目名称，以及项目位置，并点击Finish按钮完成创建：\n![](img/3.jpg)\n创建好项目以后，结构如下图：\n![](img/4.jpg)\n然后我们在src目录下创建一个easy.form的包，并在该包路径下创建一个名称为TranslationForm的 GUI Form：\n![](img/5.jpg)\n![](img/6.jpg)\n此时，Idea会自动帮我们生成一个TranslationForm.form文件和一个TranslationForm类。我们可以通过在TranslationForm.form文件中拖拽组件迅速构建一个配置面板（玩过Visual Studio的童鞋一定对这个功能很熟悉了），与此同时，Idea会自动在TranslationForm类中生成相应的组件元素：\n![](img/7.jpg)\n在这里，我们新创建了一个主面板JPanel，然后在该面板下创建了6个子元素JRadioButton单选按钮，以及一个标签JLabel。现在挑一个单选按钮讲解下，其他的都类似：\n![](img/8.jpg)\nButton Group选项是定义一个按钮组，我们这里定义了一个engineGroup的按钮组，用来对按钮进行归组。field name选项就是将要在TranslationForm类中动态创建的变量名称，text就是显示的文本，selected标识是否默认选中，enabled标识是否启用，这里只简单设置了这几个选项，还有其他丰富的选项，有兴趣的童鞋可以自行研究尝试。\n接下来我们看下我们的TranslationForm类：\n![](img/9.jpg)\n可以看到Idea为我们的各个组件元素都自动生成相对应的变量，同时，我们也自定义了一个selectValue变量（用来保存当前值）和currentSelectButton变量（用来保存当前选中的按钮），再来看下该类中的方法：\n![](img/10.jpg)\n在构造函数中，我们定义了一个监听器用来监听当前用户选择的选项，并保存起来，后文会用到。\n组件开发完毕,我们再来看下配置。\n如何让Idea能够保存起来我们的配置，以便下次启动时能够自动加载用户相应的配置，其实，刚创建完项目后，在resources/META-INF/目录下会生成一个plugin.xml文件：\n![](img/11.jpg)\n![](img/12.jpg)\n![](img/13.jpg)\n在extensions标签下，我们指定了实例easy.config.TranslationConfig类以及实现实现类easy.config.TranslationSetting，该实现类就是用来管理我们的配置信息的。在application-components标签下，我们定义了easy.idea.MyPluginRegistration实现类，Idea组件是插件整合的基础概念，有三种组件类型：application-level、project-level和module-level。 Application-level组件在IDEA启动时就被创建并初始化。在action标签下的add-to-group中的group-id很重要，它指定了你的插件在整个idea界面上的入口，这个值可以指定的很多（比如代码区域的右键菜单、编辑器顶部的菜单）。action节点中重要的是class和text，class是指定插件的入口action，一般情况下，一个插件定义一个就行了，相当于main函数吧，而text是指定插件的具体的名称，就是点击这个text然后执行class指定的类。\n我们先来看下MyPluginRegistration类，在这里我们简单的注册了我们的ToChineseAction类：\n![](img/14.jpg)\n我们再来看下TranslationSetting类，该类实现了PersistentStateComponent接口，这样组件的状态将会自动保存和加载：\n![](img/15.jpg)\n我们指定了@State和@Storage注解，这样组件的状态将会保存到一个XML文件中。在该类我们定义了一个engine的变量，用来保存当前用户选择的翻译引擎（谷歌、欧米等），同时提供了getState方法、loadState方法来设置获取配置。其中Constant.ELEMENT_NAME就是\"TranslationSetting\"，Constant.ELEMENT_ATTR_NAME就是\"engine\"，是我们自己定义的变量。\n\n我们再来看下TranslationConfig类：\n![](img/16.jpg)\n在该类中，我们定义了TranslationForm类和TranslationSetting类的变量。isModified方法是用来判断选项是否被修改过（如：我们是否更换了翻译引擎）。getDisplayName是在配置面板上显示的名称，如：\n![](img/17.jpg)\napply方法是用来将设置用户选择的翻译引擎，reset方法是重置用户选择项：\n![](img/18.jpg)\ncreateComponent方法是用来创建组件：\n![](img/19.jpg)\n现在我们来看下ToChineseAction类：\n![](img/20.jpg)\n在该类中持有一个TranslationSetting类的引用，用来获取当前用户选择的翻译引擎。我们首先获取代码编辑区对象，然后判断用户是否选中了一些文本，如果选中了文本，则获取到选中的内容，然后调用formatText方法将没用的干扰文本去掉，最后获取翻译引擎，执行翻译，并将翻译结果以气泡的方式展示出来。\n![](img/21.jpg)\n效果如下：\n![](img/22.jpg)\n我们再来看下ToEnglishAction类，该类和ToChineseAction类似，唯一的不同就是提示面板不一样：该类是先弹出来一个框提示用户输入中文，然后将中文翻译成相应的英文：\n![](img/23.jpg)\n效果如下：\n![](img/24.jpg)\n![](img/25.jpg)\n关于Idea插件开发的部分就介绍完毕了，具体怎么执行翻译的呢？有兴趣的可以去看下源码(https://github.com/limengyu1990/easy-translation)，这里就不多介绍了，同时可以去Idea官方插件库中下载该插件试用：\n![](img/26.jpg)\n","tags":["plugin"]},{"title":"ScalaSTM官网翻译","url":"/blog/2018/07/29/ScalaSTM官网翻译/","content":"\n### 欢迎\n欢迎来自 Scala STM 的创造者。我们已经为 scala 构建了一个轻量级的软件事务性内存, 灵感来自于Haskell STMs和Clojure, 同时利用了Scala 的力量和性能。\nScalaSTM 是一个没有依赖关系的单一 JAR, 包括\n* 支持多个 STM 实现的 API\n* 基于 CCSTM 的参考实现\n* 可扩展的并发sets和maps(具有快速快照), 可以在事务内部或外部使用\n\nScalaSTM 提供一个可变单元称为一个Ref，如果使用不可变对象和 Ref-s构建共享数据结构, 则可以从多个threads或actors访问该结构。没有同步、没有死锁或争用条件以及良好的可伸缩性。包括并发sets和maps, 我们也有一个更容易和更安全的替代wait和notifyAll。\n\n### 介绍\n#### STM是什么？\nSTM（软件事务性内存）是介于代码的关键部分 (atomic原子块) 和程序堆之间的中介。STM 在atomic原子块中读取和写入过程中进行干预, 允许它检查and/or避免干扰其他线程。如果多个线程的负载和存储变得交错, 则将回滚该atomic原子块的所有写入, 然后重试整个块。如果关键部分的访问不是交错的, 则它就像是以原子的样子完成的, 并且可以提交原子块。其他threads或actors只能看到已提交的更改。\nSTMs 使用乐观并发控制。他们乐观地认为, atomic原子块将能够并行运行, 然后备份和重试, 如果推测是不正确的。保留旧版本的数据以便备份可能会带来一些开销, 但乐观并发通常比其他方法具有更好的可伸缩性。\n\n#### ScalaSTM - 没有魔力\n有几个雄心勃勃的尝试来创建 STMs, 可以并行运行现有的顺序命令代码。这是一项难度很大的任务, 需要大量的魔力, 因为对 STM 的调用需要插入到一个atomic原子块内的非final字段或数组元素的每个负载和存储中。良好的性能也很难, 因为大量的读写。\nScalaSTM API 通过只管理 Ref-s, 避免了对魔力的需要。这意味着要管理的内存位置较少, 因此不需要字节码检测或编译器修改。就像在Haskell和Clojure中 一样, Ref 的效用通过语言对不可变数据结构的良好支持被放大。ScalaSTM 还包括可在事务中使用的并发sets和maps。\n\n#### ScalaSTM是给谁的呢？\nScalaSTM 是程序员用来协调threads或actors对共享数据的访问。在服务器中, 这可能是活动连接或缓存的列表。在客户端中, 这可能是部分结果或工作线程状态。\n\n优点：\n* 说出你的意思。你编写atomic原子, ScalaSTM 原子执行它没有deadlocks 或者 races。不需要将锁映射到数据。嵌套的原子块做了正确的事情, 所以你可以从简单的开始构造复杂的线程安全的操作。\n* 读取规模。系统中的所有线程都可以在不相互干扰的情况下读取数据。乐观算法比悲观方法更好地利用了现代架构上的缓存。\n* 异常自动触发清理。如果atomic原子块引发异常, 则所有 Ref-s 都将重置为其原始状态。(如果愿意, 可以更改此默认值）\n* 等待复杂的条件是容易的。如果一个atomic原子块找不到它要查找的状态, 它可以调用重试备份并等待其任何输入更改。如果有多种方式标识成功, 你可以将它们链接起来，ScalaSTM 将尝试他们所有。\n* 简单。ScalaSTM 只是一个独立的库, 所以它不会影响应用程序中不使用它的部分。这意味着可以将其包含在框架或隐藏组件中。\n缺点：\n* 每次读或写两个额外字符。如果 x 是 Ref, 则 x () 读取其值, x () = v 写入它的值。\n* 单线程开销。在大多数情况下, 当程序实际上没有并行运行时, STMs 的速度会减慢。我们已经得到了实际成本相当低, 所以对于大多数使用者来说这不会是一个问题。即使在单线程程序中，回滚也非常有用，以便在异常情况下自动清除。\n* 回滚与I/O混合的不是很好。只会自动撤消对 Ref-s 的更改。ScalaSTM API 提供了hooks , 因此您可以执行手动补偿或数据库集成, 但无法撤回数据包或像素。当然, 当你持有一个锁的时候你可能不应该做I/O。\n\n### 快速开始\n作为一个简单的例子,我们将构建一个可以被多个线程或actor安全使用的双向链表。我们将会教我们的列表如何成为一个阻塞队列,然后我们将添加从多个队列中选择下一个可用元素的能力。\n\n#### 安装\n如果你使用`sbt`，把下面的依赖添加到你的工程中build.sbt文件中，\n然后运行`sbt update`\nMaven2的配置可以从如下链接获取：https://nbronson.github.io/scala-stm/releases.html\n\n#### 对共享变量使用Ref\n在我们的可变链表中， 我们需要每个节点的下一个和上一个指针是线程安全的。通常， 如果一个线程可能在另一个线程访问它 (读取或写入) 的同时写一个变量，那么STM需要通过Ref来参与。\nRef是单个的可变单元，还有事务性集合(如TMap和Tset)，它们是scala.collection.mutable.集合的替代品.\n![](img/1.jpg)\n为了让代码更简单，我们通过一个额外的header节点使列表循环，在创建时，这个header节点的next节点和prev节点指向自身，next节点和prev节点总是非空的。\n\n#### 用atomic包装你的代码\n如果 x 是 Ref, 则 x () 获取存储在 x 中的值, x () = v 将其设置为值 v。\n只能在atomic代码块内读取和写入Ref-s。这在编译时通过要求可用的隐式InTxn 值来进行检查，Atomic代码块是一个需要一个lnTxn参数的函数，因此可以通过将参数标记为隐式的来满足此要求。\n![](img/2.jpg)\n\n#### 组合atomic操作\nAtomic代码块嵌套，因此你可以通过一个简单的开始构建复合操作.\n![](img/3.jpg)\n\n#### 优化单一操作事务\nRef.single返回一个Ref.View类型的实例，这个行为就像原始的Ref只是它也可以在一个atomic代码块之外访问。Ref.View上的每一个方法都类似于单操作事务，因此name.Ref.View提供了多种执行读写的方法，例如swap，compareAndSet和transform。如果一个atomic块只访问一个Ref，那么使用Ref.View可能会更简洁、更高效。\n![](img/4.jpg)\n\n#### 等待条件变化\n当一个atomic代码块无法在当前输入状态下完成时使用retry关键字。在atomic代码块内调用retry将导致它回滚，等待它的一个输入更改，然后重试执行。这大致类似于调用wait等待ScalaSTM 自动生成相匹配 notifyAll 的调用。作为其实现乐观并发的一部分，STM跟踪了一个atomic代码块的read集合，Ref-s的集合已在事务期间读取（即在事务过程中读取的 Ref-s 集合），这意味着STM可以有效的阻塞当前线程，直到另一个线程已经写入其read集合中的一个元素，在这段时间内，可以重试该atomic代码块，这使得等待复杂的条件变得微不足道，并可避免丢失唤醒。\n为了演示，我们将会添加一个函数到我们的列表，等待直到这个列表是非空的，然后移除并返回第一个元素：\n![](img/5.jpg)\n\n#### 等待多个事件\n在atomic代码块结束后重试的另一种方法是提供另一种选择。你可以用 orAtomic去链接atomic代码块;如果上层的调用retry, 则会尝试较低的替代方案。这就允许你组合功能如使用retry阻塞或者从一个阻塞行为中进行转换。\n例如，我们可以通过提供一个可选方案并使用阻塞版本的removeFirst 来构造一个返回Option的方法：\n![](img/6.jpg)\n这样也很容易从一个返回故障代码的函数切换到返回一个块的函数，下面的select方法阻塞直到他的输入是非空的，然后从列表中移除并返回第一个元素：\n![](img/7.jpg)\n\n#### 当心回滚\n在乐观并发能够成功之前, ScalaSTM 可能需要多次尝试一个atomic代码块，任何对 STM 的调用都可能会发现故障并触发回滚和重试。如果本地非 Ref 变量的生存期长于atomic代码块， 则不会回滚, 因此应该避免它们。不过, 只在atomic代码块的内部或仅在外部使用的局部变量是很好的。\n\n下面，badToString 是不正确的， 因为它在atomic代码块的外部和内部使用可变 StringBuilder。返回值将会明确提到列表中的所有元素, 但它其中的一些内容可能会出现两次或更多次。\ntoString是正确的, 因为对于每次atomic尝试它都使用一个新的 StringBuilder。\n![](img/8.jpg)\n\n#### 查看源代码\n此列表示例是 GitHub 上源代码的一部分: ConcurrentIntList.scala\n文章来源：https://nbronson.github.io/scala-stm/quick_start.html\n示例源代码：https://github.com/nbronson/scala-stm/blob/master/src/test/scala/scala/concurrent/stm/examples/ConcurrentIntList.scala\n\n### 真人秀哲学家Demo\n\nDijkstra 创建了餐厅哲学家的问题, 作为并发系统中的死锁的例子 (维基百科上的用餐哲学家)。每个哲学家必须拿起两个叉子吃他的饭, 但没有足够的叉子, 他们都吃一次。哲学家必须有某种策略, 以确保他们不都拿起一分叉, 然后永远等待一秒钟。\n许多解决方案都可能避免死锁, 但 STM 提供了一个特别简单的方法。ScalaSTM 的atomic原子块提供了一种方法, 让哲学家同时拿起两个叉子, 这是大多数实现者不可用的能力。\n![](img/9.jpg)\n这表明当结合重试时，Ref [Boolean] 表现的可以像锁一样。\n\n#### 添加一个摄像头\n在这个时代, 食客们更有可能不得不在真人秀节目上比在闭门的情况下为叉子而战。与基于信号量或代理的解决方案不同, STM 解决方案可以很容易地添加摄像头的外部透视图。在实际系统中, 外部视图可能来自管理控制台 (读取和写入)、检查点线程或 GUI 组件。\n\n#### 记录所有权\n首先, 我们将更改叉子, 以便他们使用一个选项来记录所有者的存在和所有者的名称。请注意, 当使用Ref工厂方法创建 Ref[Option[String]] 时, 我们需要强制 类型为\"None\" 。如果我们没有这样做, 那么所有者将最终作为一个 Ref [None], 这不是很有用。\n我们还将给每个哲学家一个名称和一个 Ref[Int] 来记录他们的进展。为方便起见, Ref和Ref.View为具有关联Numeric[A] 的类型 A 提供就地算术运算 (如+=)。\n![](img/10.jpg)\n\n#### 捕获快照\n捕捉系统状态的图像现在就像遍历原子块中的叉子和哲学家一样容易。事务不能访问在原子块外声明的可变对象 (或 var), 这一点很重要。下面的可变 StringBuilder 是在原子块内创建的, 所以它是安全的。\n![](img/11.jpg)\n\n#### Demo全部源码\n此示例的完整源可用作 github 的 ScalaSTM 源的一部分: RealityShowPhilosophers.scala.它包括一个摄像头线程, 它可以一秒钟打印图像60次, 以及处理线程停止。\n下面是运行 RealityShowPhilosophers 的摘录。注意, 因为叉子被拾起并且立刻被放下, 摄像头从未观察一个哲学家只拿着一个叉子。\n![](img/12.jpg)\n\n#### 异常\n当原子块引发异常时会发生什么情况？STM 社区中存在关于是否应回滚或提交事务的辩论。ScalaSTM 使用一种混合的方法来尝试做正确的事情。\n\n#### 异常 -> 回滚 + 重新抛出\n如果atomic原子块引发异常, ScalaSTM 将其回滚, 然后重新抛出该异常。当异常被再次引发时, atomic原子块将被左回滚。对于表示实际错误的异常, 这是一个很好的默认行为, 因为它防止了任何共享数据结构的损坏。\n\n\n#### 控制流异常 –> 提交 + 重新抛出\n有时, 异常表示非本地控制转移, 而不是一个意外的错误。在这种情况下, 应该提交事务。ScalaSTM 测试每个异常转义一个atomic原子块以确定哪个行为是合适的 (查看scaladoc文档TxnExecutor.isControlFlow了解更多)。默认情况下, 扩展 scala.util.control.ControlThrowable 的所有异常都被视为控制流。\n\n#### 异常和嵌套\n以前有关异常处理的规则适用于嵌套事务。这意味着在提交外部事务时可能会回滚嵌套事务。例如, 在下面的代码运行后, 最后将保存值 \"outer\"：\n![](img/13.jpg)\n为了使嵌套更廉价, ScalaSTM 尝试将所有嵌套级别拼合成一个顶级事务。如果内部事务引发异常, 则没有足够的信息来执行部分回滚, 因此 ScalaSTM 将以精确嵌套的模式重新启动整个事务。此优化称为包容。\n\n#### 语法速查表 \nRef, Ref.View and atomic\n![](img/14.jpg)\n\n\n\n\n\n\n","tags":["STM"]},{"title":"FSM状态机","url":"/blog/2018/07/29/FSM状态机/","content":"> 本文主要讲解如何使用状态模式来消除大量的if-else条件判断代码\n\n在我们的App中，订单模块会有很多的状态，例如待付款、付款中、已预约、已取消、已评价等。我们抽一个取消的流程来看下，取消时需要判断当前状态是否允许取消，伪代码如下：\n![](img/1.jpg)\n\n如果状态类型很少的话，这样子判断还可以，一旦我们的状态类型多起来的话，那么我们这里就会是一大堆的if-else条件判断，不仅难以阅读，而且维护起来容易出错。\n我们有三种方式来重构这样的代码：\n* 设计模式之状态模式\n* 领域驱动设计之状态建模\n* 状态机\n\n### 设计模式之状态模式\n![](img/2.jpg)\n其中State是状态接口，ConcreteState是各个具体的状态实现。我们在这里定义个订单状态接口OrderState：\n![](img/3.jpg)\n![](img/4.jpg)\n![](img/5.jpg)\n\n可以看到不是每个状态都能够支持所有操作的，例如：支付中的状态不可以进行支付操作；未支付的状态不可以进行退款操作等。当然我们可以创建一个抽象类AbstractOrderState，把操作的默认实现都放进去，具体的状态实现只覆盖自己能进行的操作。\n然后我们定义一个Context，即订单实体类Order，它持有一个State字段，通过State实现所有的状态转换逻辑：\n![](img/6.jpg)\n通过状态模式，可以省略一大堆条件判断，逻辑实现起来更清晰。\n\n\n### 领域驱动设计之状态建模\n在领域驱动设计中，我们可以定义一些操作接口，然后将每种状态的订单都定义为一个实体类，让这些实体类实现需要的操作接口：\n![](img/7.jpg)\n\n### 状态机\n不管是状态模式还是状态实体，多个状态之间的转换，还是分散在各个状态的实现里的。其实所有的状态转换都可以概括为：\n```scala\nState(S) x Event(E) -> Actions (A), State(S')\n```\n即如果当前状态为S，接收到一个事件E，则执行动作A，同时状态转换为S‘。\nAkka 框架实现了一个有限状态机FSM，它定义了强有力的DSL语法，可以把状态转换和业务处理逻辑分离开来。我们这节主要讲解下Akka FSM的使用。我们先假设我们的订单流程如下面流程图所示：\n![](img/8.jpg)\n然后我们定义一些状态，OrderState继承自FSMState：\n![](img/11.jpg)\n![](img/12.jpg)\n![](img/13.jpg)\n然后我们定义一些Command和DomainEvent。DomainEvent将会被写入日志，它与Command的关系是：我们可以给FSM发送Command，FSM执行Command时会产生DomainEvent，然后这些产生的DomainEvent会被写入日志：\n![](img/14.jpg)\n![](img/15.jpg)\n然后我们定义我们的状态数据：\n![](img/16.jpg)\n然后我们创建我们的状态机MedicalOrderFSM：\n![](img/17.jpg)\n可以看到我们的状态机继承自PersistentFSM trait，我们看下PersistentFSM trait：\n![](img/18.jpg)\nPersistentFSM继承了PersistentActor，说明它具备了事件持久化和日志恢复能力。继承的另一个类型PersistentFSMBase是FSM trait的重新定义，针对状态机的持久化特性设计了一套持久化状态转换的DSL。三个类参数S,D,E分别代表状态类型（State）、状态数据（Data）、领域事件（Event），与FSM比较：PersistentFSM除增加了event参数外，State类型是以FSMState类型为基础的，方便对State进行序列化（serialization）.\n![](img/19.jpg)\n然后我们就可以使用DSL来定义我们的状态机处理流程：\n```scala\nstartWith(initState,initData)  //定义状态机起始状态\nwhen(stateA) {...}   //处理各种状态\nwhen(stateB) {...}\nwhenUnhandled {...}   //处理共性状态\nonTransition {...}  //状态转变跟踪\n```\n状态转换是通过stay(保持当前状态)、goto(到下一个状态)、stop(停止)实现的：\n![](img/20.jpg)\n可以看到stay是通过goto来实现的：\n![](img/21.jpg)\n我们挑一个看下：\n![](img/22.jpg)\n状态机默认状态为InitState，他可以处理CreateOrderCommand，然后跳转到WaitingPayState状态(待支付)，然后应用CreateOrderEvent事件。\n只有状态转换（即InitState转换成WaitingPayState）和数据转换都成功（即CreateOrderEvent执行成功），状态机的本次状态流程才会最终完成，任何一个执行失败，都会执行回滚。这里执行成功后，我们调用saveStateSnapshot保存当前快照，用来重启后状态恢复。\n然后我们定义一个Tracker Actor用来处理事件流：\n![](img/23.jpg)\n然后我们可以测试下我们的状态机，因为actor是轻量级的，因此我们的一个订单交由一个actor来处理，每个actor大概有30字节，1G的内存可以有上百万的actor：\n![](img/24.jpg)\n![](img/25.jpg)\n\n可以看到我们创建了两个订单，状态由“初始状态0“变成了“待支付3“。\n![](img/26.jpg)\n然后对订单支付，可以看到支付成后，状态由“待支付3“变成了“已支付4”。\n我们的状态机状态数据会异步的写到外部存储中，这里使用的是mysql-async组件：\n![](img/27.jpg)\n今天就先简单介绍到这里，后面有时间会分享下Akka FSM的源码。\n\n\n","tags":["akka"]},{"title":"Metasploit渗透测试","url":"/blog/2018/07/28/Metasploit渗透测试/","content":">Metasploit渗透测试系列教程\n\n","tags":["渗透测试"]}]