<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        Lambda演算 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>不负如来不负卿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda演算"><span class="toc-text">Lambda演算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SKI-Combinators"><span class="toc-text">SKI Combinators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementation-實現"><span class="toc-text">Implementation(實現)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Substitution-替換"><span class="toc-text">Substitution(替換)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Conversion-and-Equivalences-轉換和相等關係"><span class="toc-text">Conversion and Equivalences(轉換和相等關係)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Alpha-α-等價"><span class="toc-text">Alpha(α)等價</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Beta-reduction歸約-β"><span class="toc-text">Beta-reduction歸約(β)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Eta-reduction歸約-η"><span class="toc-text">Eta-reduction歸約(η)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Eta-expansion-展開"><span class="toc-text">Eta-expansion(展開)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reduction"><span class="toc-text">Reduction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Let"><span class="toc-text">Let</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Everything-Can-Be-a-λ-term-一切都可以成为λ项"><span class="toc-text">Everything Can Be a λ term(一切都可以成为λ项)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Recursion-遞歸"><span class="toc-text">Recursion(遞歸)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Omega-Combinator"><span class="toc-text">Omega Combinator</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pretty-Printing"><span class="toc-text">Pretty Printing</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Lambda演算
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-09-28 15:17:38</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/blog/tags/#λ" title="λ">λ</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Write-Haskell" title="Write-Haskell">Write-Haskell</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p>語言是人類理性的工具，而不僅僅是表達思想的媒介，這是公認的真理。 — George Boole<br><a href="http://dev.stephendiehl.com/fun/003_lambda_calculus.html" target="_blank" rel="noopener">http://dev.stephendiehl.com/fun/003_lambda_calculus.html</a></p>
</blockquote>
<h2 id="Lambda演算"><a href="#Lambda演算" class="headerlink" title="Lambda演算"></a>Lambda演算</h2><p>所有函數式語言的基礎都是原子的組合概念，即單個變量的函數抽象。<code>Lambda</code>演算非常簡單的由三個項及其所有有效的遞歸組合組成。<br><img src="img/img01.png" alt=""></p>
<p>這個緊湊的符號看起來與您在<code>Haskell</code>中使用的符號略有不同，但實際上沒有: <code>λx.xa</code>等同於<code>\x -&gt; x a</code>。這意味著您在上圖中看到的內容將轉換為<code>(\x -&gt; x) (\y -&gt; y)</code>，這等同於<code>id id</code>（當然，其結果為<code>id</code>）。</p>
<p>這三個術語通常在代碼中通過它們名稱的幾個縮寫來表示:</p>
<ul>
<li><strong>Var</strong> - 標識一個變量</li>
<li><strong>Lam</strong> - 標識一個lambda抽象</li>
<li><strong>App</strong> - 標識一個應用</li>
</ul>
<p>一個lambda項被稱為綁定它的變量。例如這裏的<code>lambda</code>綁定<code>x</code>，在數學中我們通常會這麼寫:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span>(x) = e</span><br></pre></td></tr></table></figure></p>
<p>使用lambda演算符號，我們寫為:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> = λx.e</span><br></pre></td></tr></table></figure></p>
<p>換句話説，<code>λx.e</code>是一個接收變量<code>x</code>，返回<code>e</code>的函數.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">e</span> := x      (<span class="type">Var</span>)</span><br><span class="line">     λx.e   (<span class="type">Lam</span>)</span><br><span class="line">     e e    (<span class="type">App</span>)</span><br></pre></td></tr></table></figure></p>
<p><code>lambda</code>演算通常被稱為函數式編程的”匯編語言”，它的變體和擴展構成了許多函數編譯器中間形式的基礎，這些中間形式適用於<code>Haskell/Ocaml/StandardML</code>等語言。</p>
<p>我們首先討論的變體稱為<code>無類型的Lambda演算</code>，相比之下，稍後我們將討論<code>類型化的Lambda演算</code>，它是其擴展。</p>
<p>編寫<code>Lambda</code>表達式時，我們將採用機種語法約定。多個表達式的<code>App</code>執行左關聯:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">x1</span> x2 x3 ...<span class="type">Xn</span> = (...((x1x2)x3)...<span class="type">Xn</span>)</span><br></pre></td></tr></table></figure></p>
<p>按照慣例，<code>App</code>在語法上盡可能向右擴展，括號用於消除歧異。</p>
<p>在<code>Lambda</code>演算中，每個<code>Lambda</code>抽象綁定一個變量，而<code>lambda</code>抽象的主體可能是另一個<code>lambda</code>抽象，為了方便，我們經常在一個符號上寫多個<code>lambda</code>抽象及其變量。這只是一種語法約定，並不會改變其基本含義。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">λxy.z = λx.λy.z</span><br></pre></td></tr></table></figure></p>
<p><code>lambda</code>演算的實際實現允許在表示<code>lambda</code>抽象方面有幾個自由度。<br>最值得注意的是為綁定變量選擇標識符。</p>
<p>如果一個變量包含在同一個變量綁定的<code>lambda</code>表達式中，則稱該變量<code>bound</code>(範圍內的)。相反，如果變量沒有<code>bound</code>(不在範圍內)，則稱它是<code>free</code>(自由)的。<br>有<code>free</code>變量的項稱為<code>open term</code>(開項)，而沒有<code>free</code>變量的項稱為<code>closed</code>(閉項)或<code>combinator</code>(組合子)。</p>
<p><img src="img/img02.png" alt=""></p>
<p><code>e0</code>是一個<code>combinator</code>，而<code>e1</code>不是。<br>在<code>e1</code>中出現的兩次<code>x</code>，都是<code>bound</code>的，第一個<code>y</code>也是<code>bound</code>的，而第二個<code>y</code>是<code>free</code>的。<code>a</code>也是<code>free</code>的。</p>
<p>多個<code>lambda</code>抽象可以綁定相同的變量名稱，然後，每次出現的變量都由最近的<code>enclosing binder</code>(封閉綁定器)來<code>bound</code>(限定它的範圍)。<br>例如: 以下表達式中的<code>x</code>變量<code>bound</code>(限定)在內部的<code>lambda</code>上，而<code>y</code>變量<code>bound</code>(限定)在外部<code>lambda</code>上。這種現象稱為<code>name shadowing</code>(名稱陰影)。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">λxy.(λxz.x + y)</span><br></pre></td></tr></table></figure></p>
<h3 id="SKI-Combinators"><a href="#SKI-Combinators" class="headerlink" title="SKI Combinators"></a>SKI Combinators</h3><p>有三個基本的<code>closed</code>表達式，稱為<code>SKI</code>組合器。<br><img src="img/img03.png" alt=""></p>
<p>在<code>Haskell</code>中，它們被寫做:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">s</span> f g x = f x (g x)</span><br><span class="line"><span class="title">k</span> x y = x</span><br><span class="line"><span class="title">i</span> x = x</span><br></pre></td></tr></table></figure></p>
<p>相當引人注目的<code>Moses Schonfinkel</code>表明: 所有的<code>closed lambda</code>表達式都可以僅用<code>S</code>和<code>K</code>組合子表示(甚至是<code>I</code>組合子)。<br>例如，我們可以很容易的證明<code>SKK</code>可以簡化為<code>I</code>.<br><img src="img/img04.png" alt=""></p>
<p>在测试<code>lambda</code>演算的实现时，这是一个有用的完整性检查。</p>
<h3 id="Implementation-實現"><a href="#Implementation-實現" class="headerlink" title="Implementation(實現)"></a>Implementation(實現)</h3><p>具有命名綁定的<code>lambda</code>演算語法 最簡單的實現是使用以下定義:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Name</span> = <span class="type">String</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span></span></span><br><span class="line">  = <span class="type">Var</span> <span class="type">Name</span></span><br><span class="line">  | <span class="type">App</span> <span class="type">Expr</span> <span class="type">Expr</span></span><br><span class="line">  | <span class="type">Lam</span> <span class="type">Name</span> <span class="type">Expr</span></span><br></pre></td></tr></table></figure></p>
<p><code>lambda</code>表達式有機種詞法語法選擇，我們將簡單的選擇<code>Haskell</code>約定, 它以反斜槓(<code>\</code>)到具有(<code>-&gt;</code>)的主體表示<code>lambda</code>，并以空格表示<code>App</code>。命名變量只是字母數字字符序列。</p>
<ul>
<li><strong><em>Logical notation</em></strong>: <code>𝚌𝚘𝚗𝚜𝚝 = λxy.x</code></li>
<li><strong><em>Haskell notation</em></strong>: <code>const = \x y -&gt; x</code></li>
</ul>
<p>此外，可以添加其他術語，如文字數字或布爾值，這使編寫說明性示例更加容易，對於這些，我們將添加一個<code>Lit</code>構造函數。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span></span></span><br><span class="line">  = ...</span><br><span class="line">  | <span class="type">Lit</span> <span class="type">Lit</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Lit</span></span></span><br><span class="line">  = <span class="type">LInt</span> <span class="type">Int</span></span><br><span class="line">  | <span class="type">LBool</span> <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
<h3 id="Substitution-替換"><a href="#Substitution-替換" class="headerlink" title="Substitution(替換)"></a>Substitution(替換)</h3><p><code>lambda</code>項<code>(((xx.e)a))</code>的評估通過用參數<code>a</code>替換<code>e</code>中所有自由出現的變量<code>x</code>來進行。<br>一個單個的替換步驟被稱為<code>reduction</code>(減少/約簡)。</p>
<p>我們將替換<code>application</code>放在要應用的表達式之前的方括號中，<br><code>[x/a]e</code>将变量<code>x</code>映射到表达式<code>e</code>上的新替换<code>a</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(λx.e)a → [x/a]e</span><br></pre></td></tr></table></figure></p>
<p>一個替換元變量被寫作<code>[s]</code>.<br>詳細的替換定義如下:<br><img src="img/img05.png" alt=""></p>
<p><code>fv(e)</code>是<code>e</code>中的自由變量集.</p>
<p>使用本地命名的綁定器的根本問題是名稱捕獲的問題，或者如何處理替換與自由變量的名稱衝突的情況。我們需要在最後一種情況下使用該條件，以避免將<code>y</code>重寫為<code>x</code>時會從根本上改變以下表達式含義的幼稚替換。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[y/x](λx.xy) → λx.xx</span><br></pre></td></tr></table></figure></p>
<p>按照慣例，我們總是使用<code>capture-avoiding</code>(避免捕獲)替換，只有當變量不在表達式的自由變量集合中時，替換才會繼續進行，如果變量不在表達式的自由變量集合中，則會在其位置上創建一個新的變量。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(λx.e)a → [x/a]e   <span class="keyword">if</span> x ∉ 𝚏𝚟(a)</span><br></pre></td></tr></table></figure></p>
<p>有幾個綁定庫和<code>lambda</code>演算語法的替代實現可以避免這些問題，這是一個非常常見的問題，即使是專家也很容易執行錯誤。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">### free occurance demo</span></span><br><span class="line">(λx. x) y  =  y</span><br><span class="line">(λx. f x x) y  =  f y y</span><br><span class="line">(λx. f x x) (g y)  =  f (g y) (g y)</span><br><span class="line"></span><br><span class="line">(λx. λz. f x z) (g y)  =  λz. f (g y) z</span><br><span class="line"></span><br><span class="line">(λx. λz. f (λx. g x) z) (g y)  =  λz. f (λx. g x) z</span><br><span class="line"></span><br><span class="line"><span class="meta">### 这是一个更棘手的示例</span></span><br><span class="line"><span class="meta">### 在执行(避免捕获)替换之前，需要alpha转换(绑定变量的重命名)</span></span><br><span class="line"><span class="meta">### 答案λz. f (λy. f (g y) y) (g y)是錯誤的</span></span><br><span class="line"><span class="meta">### 因為λy. f ..y..中的y和g y中的y不是一個相同的的y)</span></span><br><span class="line">(λx. λz. f (λy. f x y) x) (g y)  =  (λx. λz. f (λt. f x t) x) (g y)  =  λz. f (λt. f (g y) t) (g y)</span><br></pre></td></tr></table></figure></p>
<h3 id="Conversion-and-Equivalences-轉換和相等關係"><a href="#Conversion-and-Equivalences-轉換和相等關係" class="headerlink" title="Conversion and Equivalences(轉換和相等關係)"></a>Conversion and Equivalences(轉換和相等關係)</h3><h4 id="Alpha-α-等價"><a href="#Alpha-α-等價" class="headerlink" title="Alpha(α)等價"></a>Alpha(α)等價</h4><p><img src="img/img06.png" alt=""></p>
<p>Alpha等价是一种属性（当使用命名的活页夹时），更改活页夹上以及整个表达式主体中的变量不应更改整个表达式的基本含义。 因此，例如，以下是等效的字母。<br><code>Alpha</code>等價是一種屬性(當使用<code>named binders</code>命名綁定器時),更改綁定器上以及整個表達式主體中的變量不應該更個整個表達式的基本含義，因此，如下是<code>Alpha</code>等價:</p>
<p><img src="img/img07.png" alt=""></p>
<h5 id="Beta-reduction歸約-β"><a href="#Beta-reduction歸約-β" class="headerlink" title="Beta-reduction歸約(β)"></a>Beta-reduction歸約(β)</h5><p><code>Beta</code>歸約僅是一個簡單的替換步驟，即在整個表達式主體中用<code>lambda</code>的參數替換由<code>lambda</code>表達式綁定的變量。</p>
<p><img src="img/img08.png" alt=""></p>
<h4 id="Eta-reduction歸約-η"><a href="#Eta-reduction歸約-η" class="headerlink" title="Eta-reduction歸約(η)"></a>Eta-reduction歸約(η)</h4><p><img src="img/img09.png" alt=""></p>
<p>這可以通過如下事實證明，如果我們把兩邊都應用到一個<code>term</code>(項)上,一個<code>Beta</code>歸約的步驟會把左邊變成右邊。</p>
<p><img src="img/img10.png" alt=""></p>
<h4 id="Eta-expansion-展開"><a href="#Eta-expansion-展開" class="headerlink" title="Eta-expansion(展開)"></a>Eta-expansion(展開)</h4><p>與<code>Eta-reduction</code>相反的是<code>eta-expansion</code>,它採用一個不飽和的函數並使所有變量顯式綁定在<code>lambda</code>中，當我們討論翻譯成<code>STG</code>時，<code>Eta-expansion</code>將會很重要。</p>
<h3 id="Reduction"><a href="#Reduction" class="headerlink" title="Reduction"></a>Reduction</h3><p><code>λ</code>演算表達式的評估通過<code>Beta-reduction</code>進行。<code>lambda</code>中綁定的變量將在<code>lambda</code>的主體中替換。</p>
<p>在設計空間中，關於如何做到這一點，以及表達式的計算順序，有幾個自由度。<br>例如，我們可以在<code>lambda</code>下求值，然後將變量代入其中，或者取而代之的是對參數求值，然後替換並減少<code>lambda</code>表達式。<br>有關更多信息，我們將在評估模型部分中進行討論。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Untyped</span>&gt; (\x.x) <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="type">Untyped</span>&gt; (\x y . y) <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="type">Untyped</span>&gt; (\x y z. x z (y z)) (\x y . x) (\x y . x)</span><br><span class="line">  =&gt; \x y z . (x z (y z))</span><br><span class="line">  =&gt; \y z . ((\x y . x) z (y z))</span><br><span class="line">    =&gt; \x y . x</span><br><span class="line">    =&gt; \y . z</span><br><span class="line">   =&gt; z</span><br><span class="line"> =&gt; \z . z</span><br><span class="line">\z . z</span><br></pre></td></tr></table></figure></p>
<p>請注意，最後一次評估是我們先前遇到的<code>SKK</code>。</p>
<p>在無類型的<code>lambda</code>演算中，我們可以自由的表示無限發散的表達式:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Untyped</span>&gt; \f . (f (\x . (f x x)) (\x . (f x x)))</span><br><span class="line">\f . (f (\x . (f x x)) (\x . (f x x)))</span><br><span class="line"></span><br><span class="line"><span class="type">Untyped</span>&gt; (\f . (\x. (f x x)) (\x. (f x x))) (\f x . f f)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">Untyped</span>&gt; (\x. x x) (\x. x x)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h3 id="Let"><a href="#Let" class="headerlink" title="Let"></a>Let</h3><p>除了<code>App</code>以外，通常將稱為<code>Let</code>綁定的構造器添加到<code>lambda</code>演算語法中。在無類型的<code>lambda</code>演算中，<code>let</code>綁定在語義上等同於應用的<code>lambda</code>表達式。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">𝚕𝚎𝚝 a = e 𝚒𝚗 b   :=   (λa.b)e</span><br></pre></td></tr></table></figure></p>
<p>在我們的語言中，我們將像在<code>Haskell</code>中一樣編寫<code>let</code>語句。<br><code>Toplevel</code>表達式將被編寫為<code>let</code>語句，沒有一個主體來表示它們被添加到全局範圍。<br><code>Haskell</code>語言不使用這個約定，但是<code>Ocaml</code>和<code>StandardML</code>使用這個約定。在<code>Haskell</code>中，对于<code>toplevel</code>声明，前面的<code>let</code>被简单地省略。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> <span class="type">S</span> f g x = f x (g x);</span><br><span class="line"><span class="title">let</span> <span class="type">K</span> x y = x;</span><br><span class="line"><span class="title">let</span> <span class="type">I</span> x = x;</span><br><span class="line"></span><br><span class="line"><span class="title">let</span> skk = <span class="type">S</span> <span class="type">K</span> <span class="type">K</span>;</span><br></pre></td></tr></table></figure></p>
<p>目前，<code>let</code>的評估規則與所應用的<code>lambda</code>相同.<br><img src="img/img11.png" alt=""><br>在後來的<code>lambda</code>演算變體中，表達式將具有不同的語義，並且將於應用的<code>lambda</code>表達式不同。關於這一點的更多信息將在<code>Hindley-Milner</code>推理部分中進行討論。</p>
<h3 id="Everything-Can-Be-a-λ-term-一切都可以成为λ项"><a href="#Everything-Can-Be-a-λ-term-一切都可以成为λ项" class="headerlink" title="Everything Can Be a λ term(一切都可以成为λ项)"></a>Everything Can Be a λ term(一切都可以成为λ项)</h3><p><strong>0</strong></p>
<p><strong>1</strong></p>
<p><strong>2</strong></p>
<p><strong>succ</strong></p>
<p><strong>pred</strong></p>
<p><strong>not</strong></p>
<p><strong>and</strong></p>
<p><strong>or</strong></p>
<p><strong>add</strong></p>
<p><strong>mul</strong></p>
<h3 id="Recursion-遞歸"><a href="#Recursion-遞歸" class="headerlink" title="Recursion(遞歸)"></a>Recursion(遞歸)</h3><p>可能最著名的組合器是<code>Curry</code>的<code>Y</code>組合器，在無類型的<code>λ</code>演算中，<code>Y</code>可用於允許表達式包含對自身的引用，以及<code>reduce</code>(歸約/減少)對自身的引用，從而允許遞歸和循環邏輯。<br><code>Y</code>組合器是許多所謂的定點組合器之一。<br><img src="img/img12.png" alt=""></p>
<p><code>Y</code>在給定<code>R</code>的情況下非常特殊，它返回<code>R</code>的固定點。</p>
<p><img src="img/img13.png" alt=""></p>
<p>例如，階乘函數可以根據自身對定點的重複應用來遞歸定義，直到基本情況為0!。</p>
<p><img src="img/img14.png" alt=""></p>
<p>處於樂趣，可以證明<code>Y</code>組合器可以用<code>S</code>和<code>K</code>組合器來表示。<br><img src="img/img15.png" alt=""></p>
<p>在沒有顯式定點或遞歸<code>let</code>綁定的無類型<code>lambda</code>演算語言中，<code>Y</code>組合器可以僅使用<code>lambda</code>表達式創建這兩個結構。<br>但是，更常見的是在術語語法中僅添加原子定點運算符或遞歸<code>let</code>作為基本構造。<br><img src="img/img16.png" alt=""></p>
<p><code>fix</code>具有評估規則:</p>
<p><img src="img/img17.png" alt=""></p>
<p>與<code>fixpoint</code>(定點)(或<code>Y</code>組合器)一起，我們可以創建<code>let</code>綁定，這些綁定在綁定表達式的主體內包含對自身的引用。我們將這些遞歸<code>let</code>綁定稱為<code>ML</code>方言中的<code>let rec</code>.<br>目前，我們將實現遞歸<code>let</code>作為簡單的語法糖，並通過以下等效性將定點包裹在<code>lambda</code>綁定周圍。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> <span class="keyword">rec</span> x = e1 <span class="keyword">in</span> e2    =    <span class="keyword">let</span> x = fix (\x. e1) <span class="keyword">in</span> e2</span><br></pre></td></tr></table></figure></p>
<p>因此，現在我們可以寫下每個函數式程序員最喜歡的兩個函數:<code>factorial</code>(階乘)和<code>fibonacci</code>(斐波那契)。</p>
<p>為了顯示兩種風格樣式，一種使用<code>let rec</code>編寫，另一種使用顯式<code>fix</code>編寫。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> fact = fix (\fact -&gt; \n -&gt;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">then</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> (n * (fact (n<span class="number">-1</span>))));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">let</span> <span class="keyword">rec</span> fib n =</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">then</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (n==<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">then</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span> ((fib (n<span class="number">-1</span>)) + (fib (n<span class="number">-2</span>)));</span><br></pre></td></tr></table></figure></p>
<h4 id="Omega-Combinator"><a href="#Omega-Combinator" class="headerlink" title="Omega Combinator"></a>Omega Combinator</h4><p>我們將測試的一個重要的退化案例是<code>omega</code>組合器，該組合器對其自身應用了一個參數。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ω = λx.xx</span><br></pre></td></tr></table></figure></p>
<p>當我們將<code>ω</code>組合器應用與自身時，我們發現這會導致無限長的重複<code>reductions</code>鏈.</p>
<p>沒有正常形式的<code>reductions</code>序列被稱為<code>diverge</code>(發散)</p>
<p><img src="img/img18.png" alt=""></p>
<p>我們將此表達式稱為<code>Ω</code>組合器。它是<code>λ</code>演算中的規範循環<code>term</code>(項)。<br>相當多的靜態類型系統會拒絕使用這個術語，因此它是一個非常有用的測試工具。</p>
<p><img src="img/img19.png" alt=""></p>
<h3 id="Pretty-Printing"><a href="#Pretty-Printing" class="headerlink" title="Pretty Printing"></a>Pretty Printing</h3><p><code>Hackage</code>提供了許多漂亮的打印庫，這些庫簡化了為我們的數據類型轉儲文本形式的過程。儘管庫之間存在一些差異，但大多數庫都使用同一組組合器。我們將使用<code>Hackage</code>上的<code>pretty</code>包中的<code>Text.PrettyPrint</code>模塊。我們大多數漂亮的打印都是不可避免的樣板，但是會使內部狀態的調適更加容易。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	    <span class="type">Combinators</span></span><br><span class="line">&lt;&gt;	    <span class="type">Concatenation</span></span><br><span class="line">&lt;+&gt;	    <span class="type">Spaced</span> concatenation</span><br><span class="line"><span class="title">char</span>	<span class="type">Renders</span> a character <span class="keyword">as</span> a <span class="type">Doc</span></span><br><span class="line"><span class="title">text</span>	<span class="type">Renders</span> a string <span class="keyword">as</span> a <span class="type">Doc</span></span><br><span class="line"><span class="title">hsep</span>	<span class="type">Horizontally</span> concatenates a list <span class="keyword">of</span> <span class="type">Doc</span></span><br><span class="line"><span class="title">vcat</span>	<span class="type">Vertically</span> joins a list <span class="keyword">of</span> <span class="type">Doc</span> with newlines</span><br></pre></td></tr></table></figure>
<p>漂亮打印的核心類型是<code>Doc</code>類型，即文檔的抽象類型。這種類型的組合器將操縱此文檔的內部結構，然後最終使用<code>render</code>函數將其內部化為物理字符串。由於我們打算在多種類型之間進行漂亮打印，因此我們將創建一個漂亮類型類。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Pretty <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Text.PrettyPrint</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Pretty</span> p <span class="keyword">where</span></span></span><br><span class="line">  ppr :: <span class="type">Int</span> -&gt; p -&gt; <span class="type">Doc</span></span><br><span class="line"></span><br><span class="line">  pp :: p -&gt; <span class="type">Doc</span></span><br><span class="line">  pp = ppr <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>首先，我們創建兩個輔助函數來折疊我們的<code>lambda</code>綁定，以便我們可以將它們打印為單個的<code>lambda</code>表達式。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">viewVars</span> :: <span class="type">Expr</span> -&gt; [<span class="type">Name</span>]</span><br><span class="line"><span class="title">viewVars</span> (<span class="type">Lam</span> n a) = n : viewVars a</span><br><span class="line"><span class="title">viewVars</span> _ = []</span><br><span class="line"></span><br><span class="line"><span class="title">viewBody</span> :: <span class="type">Expr</span> -&gt; <span class="type">Expr</span></span><br><span class="line"><span class="title">viewBody</span> (<span class="type">Lam</span> _ a) = viewBody a</span><br><span class="line"><span class="title">viewBody</span> x = x</span><br></pre></td></tr></table></figure></p>
<p>然後，我們創建一個用於對子表達式加括號的輔助函數。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">parensIf</span> ::  <span class="type">Bool</span> -&gt; <span class="type">Doc</span> -&gt; <span class="type">Doc</span></span><br><span class="line"><span class="title">parensIf</span> <span class="type">True</span> = parens</span><br><span class="line"><span class="title">parensIf</span> <span class="type">False</span> = id</span><br></pre></td></tr></table></figure></p>
<p>最後，我們定義<code>ppr</code>，變量<code>p</code>將指示我們在當前正在打印的結構中的深度。並允許我們進行不同的打印，以在必要時將其與周圍環境進行區分。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Pretty</span> <span class="type">Expr</span> <span class="keyword">where</span></span></span><br><span class="line">  ppr p e = <span class="keyword">case</span> e <span class="keyword">of</span></span><br><span class="line">    <span class="type">Lit</span> (<span class="type">LInt</span> a)  -&gt; text (show a)</span><br><span class="line">    <span class="type">Lit</span> (<span class="type">LBool</span> b) -&gt; text (show b)</span><br><span class="line">    <span class="type">Var</span> x   -&gt; text x</span><br><span class="line">    <span class="type">App</span> a b -&gt; parensIf (p&gt;<span class="number">0</span>) $ (ppr (p+<span class="number">1</span>) a) &lt;+&gt; (ppr p b)</span><br><span class="line">    <span class="type">Lam</span> x a -&gt; parensIf (p&gt;<span class="number">0</span>) $</span><br><span class="line">         char '\\'</span><br><span class="line">      &lt;&gt; hsep (fmap pp (viewVars e))</span><br><span class="line">      &lt;+&gt; <span class="string">"-&gt;"</span></span><br><span class="line">      &lt;+&gt; ppr (p+<span class="number">1</span>) (viewBody e)</span><br><span class="line"></span><br><span class="line"><span class="title">ppexpr</span> :: <span class="type">Expr</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">ppexpr</span> = render . ppr <span class="number">0</span></span><br></pre></td></tr></table></figure></p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> thank you </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
        <span><a href="https://serokell.io/blog">serokell</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/blog/js/index.js"></script>

<!--create by tea9-->

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <script>
        var gitalk = new Gitalk({
          clientID: '7cfc73dd62b57f07ed83',
          clientSecret: 'dd03b7e54aadf0d81e4c9c93e23a41272bcfcfa1',
          repo: 'blog',
          owner: 'limengyu1990',
          admin: 'limengyu1990',
          id: location.pathname,      // Ensure uniqueness and length less than 50
          distractionFreeMode: false  // Facebook-like distraction free mode
        })
        gitalk.render('comment-container')
    </script>

<!--end-->


</html>
