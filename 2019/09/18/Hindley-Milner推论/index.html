<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        Hindley-Milneræ¨è®º - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> æ‰€æœ‰çš„å–„æ¶éƒ½æ˜¯æˆ‘ï¼Œè‰¯å¿ƒä¸€è·¯èµ°æ¥ä¾æ—§æ¸…æ¾ˆé²œæ´»... </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>ä¸è´Ÿå¦‚æ¥ä¸è´Ÿå¿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>ä¸»é¡µ</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>æ ‡ç­¾</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>å­˜æ¡£</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>å…³äº</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>æœç´¢</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#HMç±»å‹ç³»ç»Ÿ"><span class="toc-text">HMç±»å‹ç³»ç»Ÿ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#è¯­æ³•"><span class="toc-text">è¯­æ³•</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#å¤šæ€æ€§"><span class="toc-text">å¤šæ€æ€§</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ç±»å‹"><span class="toc-text">ç±»å‹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ä¸Šä¸‹æ–‡"><span class="toc-text">ä¸Šä¸‹æ–‡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Inference-Monad-æ¨ç†"><span class="toc-text">Inference Monad(æ¨ç†)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Substitution-æ›¿æ¢"><span class="toc-text">Substitution(æ›¿æ¢)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unification-ç»Ÿä¸€"><span class="toc-text">Unification(ç»Ÿä¸€)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generalization-and-Instantiation-æ³›åŒ–å’Œå®ä¾‹åŒ–"><span class="toc-text">Generalization and Instantiation (æ³›åŒ–å’Œå®ä¾‹åŒ–)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Typing-Rules-ç±»å‹è§„åˆ™"><span class="toc-text">Typing Rules (ç±»å‹è§„åˆ™)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#T-Var"><span class="toc-text">T-Var</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#T-Lam"><span class="toc-text">T-Lam</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#T-App"><span class="toc-text">T-App</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#T-Let"><span class="toc-text">T-Let</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#T-BinOp"><span class="toc-text">T-BinOp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Literals"><span class="toc-text">Literals</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constraint-Generation-çº¦æŸç”Ÿæˆ"><span class="toc-text">Constraint Generation (çº¦æŸç”Ÿæˆ)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Typing"><span class="toc-text">Typing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constraint-Solver-çº¦æŸè§£å†³å™¨"><span class="toc-text">Constraint Solver (çº¦æŸè§£å†³å™¨)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Worked-Examples"><span class="toc-text">Worked Examples</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ä¾‹å­1"><span class="toc-text">ä¾‹å­1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ä¾‹å­2"><span class="toc-text">ä¾‹å­2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interpreter"><span class="toc-text">Interpreter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interactive-Shell"><span class="toc-text">Interactive Shell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Observations-æ„è§"><span class="toc-text">Observations (æ„è§)</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">æœç´¢</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> æ‰€æœ‰çš„å–„æ¶éƒ½æ˜¯æˆ‘ï¼Œè‰¯å¿ƒä¸€è·¯èµ°æ¥ä¾æ—§æ¸…æ¾ˆé²œæ´»... </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Hindley-Milneræ¨è®º
    </div>

    <div class="post-meta">
        <span class="attr">å‘å¸ƒäºï¼š<span>2019-09-18 20:48:49</span></span>
        
        <span class="attr">æ ‡ç­¾ï¼š/
        
        <a class="tag" href="/blog/tags/#Write-Haskell" title="Write-Haskell">Write-Haskell</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#HM" title="HM">HM</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#ç±»å‹ç³»çµ±" title="ç±»å‹ç³»çµ±">ç±»å‹ç³»çµ±</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">è®¿é—®ï¼š<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p><a href="http://dev.stephendiehl.com/fun/006_hindley_milner.html" target="_blank" rel="noopener">åŸæ–‡</a></p>
</blockquote>
<h3 id="HMç±»å‹ç³»ç»Ÿ"><a href="#HMç±»å‹ç³»ç»Ÿ" class="headerlink" title="HMç±»å‹ç³»ç»Ÿ"></a>HMç±»å‹ç³»ç»Ÿ</h3><p>è¾›å¾·é›·-ç±³å°”çº³ç±»å‹ç³»ç»Ÿ(ä¹Ÿç§°ä¸º<code>Damas-Hindley-Milner</code>æˆ–<code>HM</code>)æ˜¯ä¸€ç»„ç±»å‹ç³»ç»Ÿ,å®ƒä»¬æ‰¿è®¤æœ‰ä¸€ä¸ªå¯å¤„ç†çš„ç®—æ³•å¯ä»¥ä»éç±»å‹åŒ–è¯­æ³•ç¡®å®šç±»å‹,è¿™æ˜¯ä¸€ä¸ªå¶ç„¶çš„ç‰¹æ€§ã€‚<br>è¿™æ˜¯é€šè¿‡ä¸€ä¸ªç§°ä¸º<code>unification</code>(ç»Ÿä¸€)çš„è¿‡ç¨‹æ¥å®ç°çš„,åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­,ä¸€ä¸ªç»“æ„è‰¯å¥½çš„ç¨‹åºçš„ç±»å‹ä¼šäº§ç”Ÿä¸€ç»„çº¦æŸ,å½“è§£å†³è¿™äº›çº¦æŸæ—¶,æ€»æ˜¯æœ‰ä¸€ä¸ªæƒŸä¸€çš„ä¸»ä½“ç±»å‹ã€‚</p>
<p>æœ€ç®€å•çš„<code>Hindley Milner</code>ç±»å‹ç³»ç»Ÿç”±ä¸€ç»„éå¸¸çŸ­çš„è§„åˆ™å®šä¹‰ã€‚<br>å‰å››ä¸ªè§„åˆ™æè¿°äº†æˆ‘ä»¬å¯ä»¥å¦‚ä½•åˆ¤æ–­å°†æ¯ä¸ªå¥æ³•ç»“æ„(<code>Lam</code>ï¼Œ<code>App</code>ï¼Œ<code>Var</code>ï¼Œ<code>Let</code>)æ˜ å°„åˆ°å®ƒä»¬çš„é¢„æœŸç±»å‹,æˆ‘ä»¬å¾ˆå¿«å°±ä¼šè¯¦ç»†é˜è¿°è¿™äº›è§„åˆ™ã€‚<br><img src="img/HM0.png" alt=""><br>ç±³å°”çº³çš„è§‚å¯Ÿæ˜¯,å› ä¸ºç±»å‹è§„åˆ™æ˜ å°„åˆ°å”¯ä¸€çš„è¯­æ³•,æˆ‘ä»¬å®é™…ä¸Šå¯ä»¥å‘åè¿è¡Œç±»å‹è§„åˆ™,æ¯å½“æˆ‘ä»¬æ²¡æœ‰å­è¡¨è¾¾å¼çš„å·²çŸ¥ç±»å‹æ—¶,æˆ‘ä»¬é€šè¿‡åœ¨å…¶ä½ç½®æ”¾ç½®ä¸€ä¸ªæ–°å˜é‡,<br>æ”¶é›†å…³äºå…¶åç»­ç±»å‹åˆ¤æ–­å¼•èµ·çš„ä½¿ç”¨é™åˆ¶æ¥è¿›è¡Œâ€çŒœæµ‹â€.<br>è¿™æ˜¯MLæ—è¯­è¨€ä¸­ç±»å‹æ¨æ–­çš„æœ¬è´¨,é€šè¿‡ç”Ÿæˆå’Œè§£å†³ä¸€ç§ç»Ÿä¸€(<code>unification</code>)é—®é¢˜,æˆ‘ä»¬å¯ä»¥ä»è¯­æ³•ä¸­å”¯ä¸€åœ°é‡æ„ç±»å‹,ç®—æ³•æœ¬èº«å¾ˆå¤§ç¨‹åº¦ä¸Šåªæ˜¯ç»Ÿä¸€æ±‚è§£å™¨çš„ç»“æ„åŒ–ä½¿ç”¨.<br>ç„¶è€Œ,å®Œæ•´çš„ç±»å‹æ¨æ–­ä½¿æˆ‘ä»¬æœ‰ç‚¹æŸç¼š,å› ä¸ºè™½ç„¶æ¨ç†é—®é¢˜åœ¨è¿™ç§ç®€å•çš„è¯­è¨€å’Œç®€å•çš„æ‰©å±•ä¸­æ˜¯æ˜“å¤„ç†çš„,ä½†å‡ ä¹æ‰€æœ‰å¯¹è¯­è¨€çš„é‡è¦è¡¥å……éƒ½ä¼šç ´ååœ¨æ²¡æœ‰æ³¨é‡Šçš„æƒ…å†µä¸‹æ¨æ–­ç±»å‹çš„èƒ½åŠ›,<br>æˆ–è€…ä½¿æ¨ç†ç®—æ³•ä¸¥é‡å¤æ‚åŒ–.ç„¶è€Œ,<code>Hindley-Milner</code>å®¶æ—åœ¨è®¾è®¡é¢†åŸŸä»£è¡¨äº†ä¸€ä¸ªéå¸¸æœ‰ç”¨,å¯Œæœ‰æˆæ•ˆçš„â€ç”œèœœç‚¹â€.</p>
<h3 id="è¯­æ³•"><a href="#è¯­æ³•" class="headerlink" title="è¯­æ³•"></a>è¯­æ³•</h3><p>æˆ‘ä»¬çš„ç¬¬ä¸€ç§ç±»å‹æ¨æ–­è¯­è¨€çš„è¯­æ³•å®é™…ä¸Šå°†æ˜¯æˆ‘ä»¬çš„æ— ç±»å‹<code>lambda</code>æ¼”ç®—çš„æ‰©å±•,åŒ…æ‹¬<code>fixpoint</code>è¿ç®—ç¬¦,<code>booleans</code>,<code>integers</code>,<code>let</code>å’Œä¸€äº›åŸºæœ¬çš„ç®—æœ¯è¿ç®—.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Name</span> = <span class="type">String</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span></span></span><br><span class="line">  = <span class="type">Var</span> <span class="type">Name</span></span><br><span class="line">  | <span class="type">App</span> <span class="type">Expr</span> <span class="type">Expr</span></span><br><span class="line">  | <span class="type">Lam</span> <span class="type">Name</span> <span class="type">Expr</span></span><br><span class="line">  | <span class="type">Let</span> <span class="type">Name</span> <span class="type">Expr</span> <span class="type">Expr</span></span><br><span class="line">  | <span class="type">Lit</span> <span class="type">Lit</span></span><br><span class="line">  | <span class="type">If</span> <span class="type">Expr</span> <span class="type">Expr</span> <span class="type">Expr</span></span><br><span class="line">  | <span class="type">Fix</span> <span class="type">Expr</span></span><br><span class="line">  | <span class="type">Op</span> <span class="type">Binop</span> <span class="type">Expr</span> <span class="type">Expr</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>, <span class="type">Ord</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Lit</span></span></span><br><span class="line">  = <span class="type">LInt</span> <span class="type">Integer</span></span><br><span class="line">  | <span class="type">LBool</span> <span class="type">Bool</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>, <span class="type">Ord</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Binop</span> = <span class="type">Add</span> | <span class="type">Sub</span> | <span class="type">Mul</span> | <span class="type">Eql</span></span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Program</span> = <span class="type">Program</span> [<span class="type">Decl</span>] <span class="type">Expr</span> <span class="keyword">deriving</span> <span class="type">Eq</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Decl</span> = (<span class="type">String</span>, <span class="type">Expr</span>)</span></span><br></pre></td></tr></table></figure></p>
<p><code>parser</code>æ˜¯å¾®ä¸è¶³é“çš„,å”¯ä¸€çš„è¡¥å……æ˜¯<code>toplevel</code> <code>let</code>å£°æ˜(<code>Decl</code>),å®ƒä»¬è¢«åŠ å…¥åˆ°å…¨å±€ç¨‹åºä¸­,<br>æ‰€æœ‰é¡¶çº§å£°æ˜éƒ½å¿…é¡»ä»¥åˆ†å·ç»“æŸ,å°½ç®¡å®ƒä»¬å¯ä»¥è·¨è¶Šå¤šè¡Œå¹¶ä¸”å¿½ç•¥ç©ºæ ¼.ä¾‹å¦‚:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SKI combinators</span></span><br><span class="line"><span class="title">let</span> <span class="type">I</span> x = x;</span><br><span class="line"><span class="title">let</span> <span class="type">K</span> x y = x;</span><br><span class="line"><span class="title">let</span> <span class="type">S</span> f g x = f x (g x);</span><br></pre></td></tr></table></figure></p>
<p>å’Œä¹‹å‰ä¸€æ ·,<code>let rec</code>è¡¨è¾¾å¼å°†æ ¹æ®<code>fixpoint</code>è¿ç®—ç¬¦å±•å¼€,åªæ˜¯è¯­æ³•ç³–.</p>
<h3 id="å¤šæ€æ€§"><a href="#å¤šæ€æ€§" class="headerlink" title="å¤šæ€æ€§"></a>å¤šæ€æ€§</h3><p>æˆ‘ä»¬å°†å‘æˆ‘ä»¬çš„è¯­è¨€æ·»åŠ ä¸€ä¸ªé¢å¤–çš„æ„é€ ,å®ƒå°†å…è®¸æˆ‘ä»¬çš„è¯­è¨€å…·æœ‰ä¸€ç§æ–°çš„å¤šæ€æ€§å½¢å¼.<br>å¤šæ€æ€§æ˜¯ä¸€ä¸ªæœ¯è¯­çš„å±æ€§,å®ƒå…è®¸åŒä¸€å‡½æ•°å®ç°åŒæ—¶ä½¿ç”¨å‡ ç§ä¸åŒçš„ç±»å‹.<br>ä¾‹å¦‚,<code>identity</code>å‡½æ•°çš„å¤šæ€ç­¾åå®ä¾‹æ˜ å°„ä¸€ä¸ª<code>Î±</code>ç±»å‹çš„è¾“å…¥:</p>
<p><img src="img/HM01.png" alt=""><br>ç°åœ¨ä¸å¿…ä¸ºæ¯ç§å¯èƒ½çš„ç±»å‹é‡å¤å‡½æ•°(å³å®ç°<code>idInt</code>,<code>idBool</code>â€¦)<br>æˆ‘ä»¬çš„ç±»å‹ç³»ç»Ÿå…è®¸åŒ…å«åœ¨å¤šæ€ç±»å‹ç­¾åä¸­çš„ä»»ä½•å®ä¾‹.<br><img src="img/HM02.png" alt=""><br>æ™®éé‡åŒ–çš„ä¸€ä¸ªç›¸å½“æ˜¾è‘—çš„äº‹å®æ˜¯,å…³äºä¸€ç±»çš„<code>inhabitants</code>(é¡å‹çš„å¯¦ä¾‹çš„çµ±ç¨±)çš„è®¸å¤šå±æ€§æ˜¯ç”±æ„é€ ä¿è¯çš„,è¿™äº›å°±æ˜¯æ‰€è°“çš„<code>free</code>å®šç†.<br>ä¾‹å¦‚,ä»»ä½•<code>(a, b) -&gt; a</code>ç±»å‹çš„(<code>nonpathological</code>)å®ç°å¿…é¡»ç­‰åŒäº<code>fst</code>.<br>ä¸€ä¸ªç¨å¾®ä¸é‚£ä¹ˆç®€å•çš„ä¾‹å­æ˜¯<code>fmap</code>å‡½æ•°çš„ç±»å‹<code>Functor f =&gt;ï¼ˆa -&gt; bï¼‰-&gt; f a -&gt; f b</code><br>ç¬¬äºŒä¸ª<code>functor</code>æ³•å¾‹è¦æ±‚:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">forall</span> f g. fmap f . fmap g = fmap (f . g)</span><br></pre></td></tr></table></figure></p>
<p>ä½†æ˜¯,æˆ‘ä»¬ä¸å¯èƒ½ä¸º<code>fmap</code>ç¼–å†™ä¸€ä¸ª(<code>nonpathological</code>)å‡½æ•°,è¯¥å‡½æ•°å…·æœ‰æ‰€éœ€çš„ç±»å‹,ä½†æ²¡æœ‰æ­¤å±æ€§.æˆ‘ä»¬å¾—åˆ°<code>free</code>å®šç†!</p>
<h3 id="ç±»å‹"><a href="#ç±»å‹" class="headerlink" title="ç±»å‹"></a>ç±»å‹</h3><p>æˆ‘ä»¬å°†ä½¿ç”¨çš„ç±»å‹è¯­è¨€ä»ç”¨äºç±»å‹åŒ–<code>lambda</code>æ¼”ç®—çš„ç®€å•ç±»å‹ç³»ç»Ÿå¼€å§‹.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">TVar</span> = <span class="type">TV</span> <span class="type">String</span></span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>, <span class="type">Ord</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Type</span></span></span><br><span class="line">  = <span class="type">TVar</span> <span class="type">TVar</span></span><br><span class="line">  | <span class="type">TCon</span> <span class="type">String</span></span><br><span class="line">  | <span class="type">TArr</span> <span class="type">Type</span> <span class="type">Type</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>, <span class="type">Ord</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">typeInt</span>, typeBool :: <span class="type">Type</span></span><br><span class="line"><span class="title">typeInt</span>  = <span class="type">TCon</span> <span class="string">"Int"</span></span><br><span class="line"><span class="title">typeBool</span> = <span class="type">TCon</span> <span class="string">"Bool"</span></span><br></pre></td></tr></table></figure></p>
<p><code>Type schemes`</code>model polymorphic types`(æ ·æ¿å¤šæ€ç±»å‹)ï¼Œå®ƒä»¬è¡¨ç¤ºé‡è¯ä¸­ç»‘å®šçš„ç±»å‹å˜é‡åœ¨å°é—­çš„ç±»å‹ä¸­æ˜¯å¤šæ€çš„ï¼Œå¯ä»¥ç”¨ä¸ç­¾åä¸€è‡´çš„ä»»ä½•ç±»å‹å®ä¾‹åŒ–ã€‚ç›´è§‚åœ°è¯´æ˜äº†è¯¥å‡½æ•°çš„å®ç°:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Scheme</span> = <span class="type">Forall</span> [<span class="type">TVar</span>] <span class="type">Type</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>Type schemes</code>(ç±»å‹æ¨¡å¼)å°†åœ¨æˆ‘ä»¬çš„è¾“å…¥è§„åˆ™ä¸­å†™ä¸º<code>Ïƒ</code>.<br><img src="img/HM03.png" alt=""><br>ä¾‹å¦‚:<code>id</code>å’Œ<code>const</code>å‡½æ•°å°†ä¼šæœ‰ä»¥ä¸‹ç±»å‹:<br><img src="img/HM04.png" alt=""><br>æˆ‘ä»¬ç°åœ¨å°†æˆ‘ä»¬çš„ç±»å‹åˆ’åˆ†ä¸ºä¸¤ä¸ªå¥æ³•ç±»åˆ«,å•å‹å’Œå¤šå‹.<br>åœ¨æˆ‘ä»¬ç®€å•çš„åˆå§‹è¯­è¨€ä¸­,<code>type schemes</code>(ç±»å‹æ¨¡å¼)å°†å§‹ç»ˆæ˜¯<code>top level</code>(é¡¶çº§)ç­¾åçš„è¡¨ç¤º,å³ä½¿æ²¡æœ‰å¤šæ€ç±»å‹å˜é‡.<br>åœ¨å®ç°æœ¯è¯­ä¸­,è¿™æ„å‘³ç€åœ¨æ¨æ–­åä»æˆ‘ä»¬çš„<code>Infer monad</code>ä¸­äº§ç”Ÿå•å‹æ—¶,<br><code>we will immediately generalize it at the toplevel &quot;closing over&quot; all free type variables in a type scheme.</code><br>(æˆ‘ä»¬å°†ç«‹å³åœ¨ç±»å‹æ¨¡å¼çš„é¡¶å±‚â€å…³é—­æ‰€æœ‰â€è‡ªç”±ç±»å‹å˜é‡ä¸­å½’çº³å®ƒ)</p>
<h3 id="ä¸Šä¸‹æ–‡"><a href="#ä¸Šä¸‹æ–‡" class="headerlink" title="ä¸Šä¸‹æ–‡"></a>ä¸Šä¸‹æ–‡</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">TypeEnv</span> = <span class="type">TypeEnv</span> (<span class="type">Map</span>.<span class="type">Map</span> <span class="type">Var</span> <span class="type">Scheme</span>)</span></span><br></pre></td></tr></table></figure>
<p>ä¸¤ä¸ªä¸»è¦æ“ä½œæ˜¯æ‰©å±•å’Œé™å®š,å®ƒä»ä¸Šä¸‹æ–‡ä¸­å¼•å…¥æˆ–åˆ é™¤å‘½åæ•°é‡.<br><img src="img/HM05.png" alt=""><br>å¯¹ä¸Šä¸‹æ–‡çš„æ“ä½œåªæ˜¯å¯¹åº•å±‚<code>map</code>ä¸Šçš„å¸¸ç”¨<code>Set</code>æ“ä½œ.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">extend</span> :: <span class="type">TypeEnv</span> -&gt; (<span class="type">Var</span>, <span class="type">Scheme</span>) -&gt; <span class="type">TypeEnv</span></span><br><span class="line"><span class="title">extend</span> (<span class="type">TypeEnv</span> env) (x, s) = <span class="type">TypeEnv</span> $ <span class="type">Map</span>.insert x s env</span><br></pre></td></tr></table></figure></p>
<h3 id="Inference-Monad-æ¨ç†"><a href="#Inference-Monad-æ¨ç†" class="headerlink" title="Inference Monad(æ¨ç†)"></a>Inference Monad(æ¨ç†)</h3><p>æˆ‘ä»¬æ‰€æœ‰çš„ç±»å‹æ¨æ–­é€»è¾‘éƒ½å°†å­˜åœ¨äº<code>Infer monad</code>ä¸­,å®ƒæ˜¯<code>ExcpetT</code>+<code>State</code>çš„<code>monad</code>å˜æ¢å™¨å †æ ˆ.å…è®¸å„ç§é”™è¯¯æŠ¥å‘Šå¹¶æœ‰çŠ¶æ€åœ°ä¿å­˜æ–°åç§°.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Infer</span> a = <span class="type">ExceptT</span> <span class="type">TypeError</span> (<span class="type">State</span> <span class="type">Unique</span>) a</span></span><br></pre></td></tr></table></figure></p>
<p>åœ¨<code>monad</code>ä¸­è¿è¡Œé€»è¾‘ä¼šå¯¼è‡´ç±»å‹é”™è¯¯æˆ–ç»“æœç±»å‹æ¨¡å¼.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">runInfer</span> :: <span class="type">Infer</span> (<span class="type">Subst</span>, <span class="type">Type</span>) -&gt; <span class="type">Either</span> <span class="type">TypeError</span> <span class="type">Scheme</span></span><br><span class="line"><span class="title">runInfer</span> m = <span class="keyword">case</span> evalState (runExceptT m) initUnique <span class="keyword">of</span></span><br><span class="line">  <span class="type">Left</span> err  -&gt; <span class="type">Left</span> err</span><br><span class="line">  <span class="type">Right</span> res -&gt; <span class="type">Right</span> $ closeOver res</span><br></pre></td></tr></table></figure></p>
<h3 id="Substitution-æ›¿æ¢"><a href="#Substitution-æ›¿æ¢" class="headerlink" title="Substitution(æ›¿æ¢)"></a>Substitution(æ›¿æ¢)</h3><p>æŸ¥è¯¢è¡¨è¾¾å¼çš„è‡ªç”±å˜é‡å’Œå¯¹è¡¨è¾¾å¼åº”ç”¨æ›¿æ¢,è¿™ä¸¤ä¸ªæ“ä½œå°†æ‰§è¡Œç›¸å½“å¤šçš„æ“ä½œ.<br><img src="img/HM06.png" alt=""><br>ç›¸åŒçš„æ¨¡å¼é€‚ç”¨äºç±»å‹çº§åˆ«çš„ç±»å‹å˜é‡.<br><img src="img/HM07.png" alt=""><br>è¡¨è¾¾å¼ä¸Šçš„æ›¿æ¢å°†æ›¿æ¢åº”ç”¨äºå±€éƒ¨å˜é‡ï¼Œå¦‚æœåŒ¹é…ï¼Œåˆ™æ›¿æ¢æŒ‡å®šçš„å­è¡¨è¾¾å¼ã€‚åœ¨åç§°æ•è·çš„æƒ…å†µä¸‹ï¼Œå°†å¼•å…¥ä¸€ä¸ªæ–°çš„å˜é‡ã€‚<br><img src="img/HM08.png" alt=""><br>åŒæ ·ï¼Œæ›¿æ¢ä¹Ÿå¯ä»¥åº”ç”¨äºç±»å‹ç¯å¢ƒä¹‹ä¸Šçš„å…ƒç´ ã€‚<br><img src="img/HM09.png" alt=""><br>æˆ‘ä»¬åœ¨<code>Haskell</code>ä¸­çš„æ›¿æ¢å®ç°åªæ˜¯ä»ç±»å‹å˜é‡åˆ°ç±»å‹çš„<code>Map</code>.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Subst</span> = <span class="type">Map</span>.<span class="type">Map</span> <span class="type">TVar</span> <span class="type">Type</span></span></span><br></pre></td></tr></table></figure></p>
<p>æ›¿æ¢çš„ç»„åˆ(<code>s1 âˆ˜ s2</code>, <code>s1 compose s2</code>)å¯ä»¥ç®€å•åœ°ç¼–ç ä¸ºåŸºç¡€<code>Map</code>ä¸Šçš„æ“ä½œ,é‡è¦çš„æ˜¯è¦æ³¨æ„,åœ¨æˆ‘ä»¬çš„å®ç°ä¸­,æˆ‘ä»¬é€‰æ‹©äº†æ›¿æ¢ä¸º<code>left-biased</code>,å–å†³äºæ¨ç†ç®—æ³•çš„å®ç°,ä»¥ç¡®ä¿åœ¨æ›¿æ¢ä¹‹é—´ä¸å‘ç”Ÿå†²çª.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">nullSubst</span> :: <span class="type">Subst</span></span><br><span class="line"><span class="title">nullSubst</span> = <span class="type">Map</span>.empty</span><br><span class="line"></span><br><span class="line"><span class="title">compose</span> :: <span class="type">Subst</span> -&gt; <span class="type">Subst</span> -&gt; <span class="type">Subst</span></span><br><span class="line"><span class="title">s1</span> `compose` s2 = <span class="type">Map</span>.map (apply s1) s2 `<span class="type">Map</span>.union` s1</span><br></pre></td></tr></table></figure></p>
<p><code>Haskell</code>ä¸­çš„å®ç°æ˜¯é€šè¿‡<code>Substitutable</code>ç±»å‹ç±»çš„ä¸€ç³»åˆ—å®ç°æ¥å…¬å¼€ä¸€ä¸ª<code>apply</code>å‡½æ•°,è¯¥å‡½æ•°åº”ç”¨åœ¨ æŒ‡å®šç±»å‹å˜é‡çš„ ç±»å‹ç»“æ„ä¸Š ç»™å‡ºçš„æ›¿æ¢.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Substitutable</span> a <span class="keyword">where</span></span></span><br><span class="line">  apply :: <span class="type">Subst</span> -&gt; a -&gt; a</span><br><span class="line">  ftv   :: a -&gt; <span class="type">Set</span>.<span class="type">Set</span> <span class="type">TVar</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Substitutable</span> <span class="type">Type</span> <span class="keyword">where</span></span></span><br><span class="line">  apply _ (<span class="type">TCon</span> a)       = <span class="type">TCon</span> a</span><br><span class="line">  apply s t@(<span class="type">TVar</span> a)     = <span class="type">Map</span>.findWithDefault t a s</span><br><span class="line">  apply s (t1 `<span class="type">TArr</span>` t2) = apply s t1 `<span class="type">TArr</span>` apply s t2</span><br><span class="line"></span><br><span class="line">  ftv <span class="type">TCon</span>&#123;&#125;         = <span class="type">Set</span>.empty</span><br><span class="line">  ftv (<span class="type">TVar</span> a)       = <span class="type">Set</span>.singleton a</span><br><span class="line">  ftv (t1 `<span class="type">TArr</span>` t2) = ftv t1 `<span class="type">Set</span>.union` ftv t2</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Substitutable</span> <span class="type">Scheme</span> <span class="keyword">where</span></span></span><br><span class="line">  apply s (<span class="type">Forall</span> <span class="keyword">as</span> t)   = <span class="type">Forall</span> <span class="keyword">as</span> $ apply s' t</span><br><span class="line">                            <span class="keyword">where</span> s' = foldr <span class="type">Map</span>.delete s <span class="keyword">as</span></span><br><span class="line">  ftv (<span class="type">Forall</span> <span class="keyword">as</span> t) = ftv t `<span class="type">Set</span>.difference` <span class="type">Set</span>.fromList <span class="keyword">as</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Substitutable</span> a =&gt; <span class="type">Substitutable</span> [a] <span class="keyword">where</span></span></span><br><span class="line">  apply = fmap . apply</span><br><span class="line">  ftv   = foldr (<span class="type">Set</span>.union . ftv) <span class="type">Set</span>.empty</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Substitutable</span> <span class="type">TypeEnv</span> <span class="keyword">where</span></span></span><br><span class="line">  apply s (<span class="type">TypeEnv</span> env) =  <span class="type">TypeEnv</span> $ <span class="type">Map</span>.map (apply s) env</span><br><span class="line">  ftv (<span class="type">TypeEnv</span> env) = ftv $ <span class="type">Map</span>.elems env</span><br></pre></td></tr></table></figure></p>
<p>åœ¨æ•´ä¸ªç±»å‹è§„åˆ™å’Œæ›¿æ¢ä¸­,æˆ‘ä»¬éœ€è¦æ–°çš„åç§°.åœ¨è¿™ä¸ªå¤©çœŸçš„ç‰ˆæœ¬ä¸­,æˆ‘ä»¬å°†ç®€å•åœ°ä½¿ç”¨æ— é™çš„å­—ç¬¦ä¸²åˆ—è¡¨,å¹¶æŒ‰ç…§æˆ‘ä»¬åœ¨<code>çŠ¶æ€monad</code>ä¸­ä¿å­˜çš„ç´¢å¼•åˆ‡å…¥åˆ—è¡¨çš„ç¬¬<code>n</code>ä¸ªå…ƒç´ ,è¿™æ˜¯æœ€ç®€å•çš„å®ç°,ç¨åæˆ‘ä»¬å°†ä½¿è¿™ç§åç§°ç”ŸæˆæŠ€æœ¯æ›´åŠ å¥å£®.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">letters</span> :: [<span class="type">String</span>]</span><br><span class="line"><span class="title">letters</span> = [<span class="number">1.</span>.] &gt;&gt;= flip replicateM ['a'..'z']</span><br><span class="line"></span><br><span class="line"><span class="title">fresh</span> :: <span class="type">Infer</span> <span class="type">Type</span></span><br><span class="line"><span class="title">fresh</span> = <span class="keyword">do</span></span><br><span class="line">  s &lt;- get</span><br><span class="line">  put s&#123;count = count s + <span class="number">1</span>&#125;</span><br><span class="line">  return $ <span class="type">TVar</span> $ <span class="type">TV</span> (letters !! count s)</span><br></pre></td></tr></table></figure></p>
<p>åˆ›å»ºæ–°å˜é‡å¯¹äºå®æ–½æ¨ç†è§„åˆ™è‡³å…³é‡è¦ã€‚ æ¯å½“æˆ‘ä»¬åœ¨æŸä¸ªè¡¨è¾¾å¼ä¸­é‡åˆ°ç¬¬ä¸€æ¬¡ä½¿ç”¨å˜é‡æ—¶ï¼Œæˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªæ–°çš„ç±»å‹å˜é‡ã€‚</p>
<h3 id="Unification-ç»Ÿä¸€"><a href="#Unification-ç»Ÿä¸€" class="headerlink" title="Unification(ç»Ÿä¸€)"></a>Unification(ç»Ÿä¸€)</h3><p>æ¨ç†æ€æƒ³çš„æ ¸å¿ƒæ˜¯ç»Ÿä¸€çš„æ¦‚å¿µ,ä¸¤ä¸ªè¡¨è¾¾å¼<code>e1</code>å’Œ<code>e2</code>çš„ç»Ÿä¸€ç¬¦æ˜¯æ›¿æ¢<code>s</code>,ä½¿å¾—:<br><img src="img/HM10.png" alt=""><br>å¦‚æœåœ¨å®ƒä»¬ä¹‹é—´å­˜åœ¨ç»Ÿä¸€çš„æ›¿æ¢é›†åˆï¼Œåˆ™è®¤ä¸ºä¸¤ä¸ªæœ¯è¯­æ˜¯ç»Ÿä¸€çš„ã€‚ å¦‚æœæ›¿æ¢çš„åº”ç”¨ä¸æ‰€åº”ç”¨çš„é¡ºåºæ— å…³ï¼Œå³å¦‚æœæˆ‘ä»¬æ€»æ˜¯ä»¥ç›¸åŒçš„æ­£å¸¸å½¢å¼åˆ°è¾¾è€Œä¸ç®¡æ‰€é€‰æ‹©çš„æ›¿æ¢é¡ºåºå¦‚ä½•ï¼Œåˆ™ç§°æ›¿æ¢é›†æ˜¯æ±‡åˆçš„ã€‚<br>æˆ‘ä»¬å°†é‡‡ç”¨è¿™ç§è¡¨ç¤ºæ³•:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ï„ âˆ¼ Ï„â€²:s</span><br></pre></td></tr></table></figure></p>
<p>äº‹å®ä¸Š<code>Ï„,Ï„&#39;</code>è¿™ä¸¤ç§ç±»å‹æ˜¯å¯ä»¥é€šè¿‡ä¸€ä¸ªæ›¿æ¢<code>s</code>è¿›è¡Œç»Ÿä¸€çš„,è¿™æ ·:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[s]Ï„ = [s]Ï„â€²</span><br></pre></td></tr></table></figure></p>
<p>ä¸¤ä¸ªç›¸åŒçš„é¡¹å¯ä»¥ç”¨ç©ºçš„ç»Ÿä¸€å™¨è½»æ¾åœ°ç»Ÿä¸€:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">c</span> âˆ¼ c : [ ]</span><br></pre></td></tr></table></figure></p>
<p>æˆ‘ä»¬çš„å°HMè¯­è¨€çš„ç»Ÿä¸€è§„åˆ™å¦‚ä¸‹:<br><img src="img/HM11.png" alt=""><br>å¦‚æœæˆ‘ä»¬æƒ³è¦å°†ç±»å‹å˜é‡<code>Î±</code>ä¸ç±»å‹<code>Ï„</code>ç»Ÿä¸€èµ·æ¥,æˆ‘ä»¬é€šå¸¸å¯ä»¥ç”¨ç±»å‹æ›¿æ¢å˜é‡: <code>[Î±/Ï„]</code>.ä½†æ˜¯,æˆ‘ä»¬çš„è§„åˆ™è§„å®šäº†ä¸€ä¸ªå‰ææ¡ä»¶,ç§°ä¸ºè¯¥ç»Ÿä¸€çš„å‘ç”Ÿæ£€æŸ¥: ç±»å‹å˜é‡<code>Î±</code>ä¸å¾—åœ¨<code>Ï„</code>ä¸­è‡ªç”±å‡ºç°.å¦‚æœç¡®å®å¦‚æ­¤.åˆ™æ›¿æ¢å°†ä¸æ˜¯ç»Ÿä¸€.<br>ä¾‹å¦‚,ç»Ÿä¸€<code>Î±</code>å’Œ<code>Î± â†’ Î²</code>çš„é—®é¢˜.<br>æ›¿æ¢<code>s</code> = <code>[Î±/Î± â†’ Î²]</code>ä¸ç»Ÿä¸€: æˆ‘ä»¬å¾—åˆ°<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[s]Î± = Î± â†’ Î²</span><br><span class="line"><span class="comment">-- å’Œ</span></span><br><span class="line">[s]Î± â†’ Î² = (Î± â†’ Î²) â†’ Î²</span><br></pre></td></tr></table></figure></p>
<p>å®é™…ä¸Š,æ— è®ºæˆ‘ä»¬å°è¯•ä»€ä¹ˆæ›¿ä»£,<code>[s]Î± â†’ Î²</code>æ€»æ˜¯æ¯”<code>[s]Î±</code>é•¿,æ‰€ä»¥ä¸å­˜åœ¨ç»Ÿä¸€è€…,å”¯ä¸€çš„æœºä¼šæ˜¯ç”¨æ— é™ç±»å‹æ›¿æ¢: <code>[Î±/(...((Î± â†’ Î²) â†’ Î²)â†’ â‹¯ â†’ Î²) â†’ Î²]</code>å°†æ˜¯ä¸€ä¸ªç»Ÿä¸€è€…ï¼Œä½†æˆ‘ä»¬çš„è¯­è¨€æ²¡æœ‰è¿™æ ·çš„ç±»å‹ã€‚<br>å¦‚æœç”±äºå‘ç”Ÿæ£€æŸ¥(<code>occurs check</code>)è€Œç»Ÿä¸€å¤±è´¥,æˆ‘ä»¬è¯´ç»Ÿä¸€å°†ç»™å‡ºæ— é™ç±»å‹ã€‚<br>è¯·æ³¨æ„,å¦‚æœæˆ‘ä»¬å°è¯•ç±»å‹æ£€æŸ¥<code>omega</code>ç»„åˆå™¨<code>Î»x.xx</code>ï¼Œé‚£ä¹ˆç»Ÿä¸€<code>Î± â†’ Î²</code>å’Œ<code>Î±</code>æ­£æ˜¯æˆ‘ä»¬å¿…é¡»è¦åšçš„,æ‰€ä»¥å®ƒè¢«å‘ç”Ÿæ£€æŸ¥(<code>occurs check</code>)æ’é™¤äº†ï¼Œ<br>æ­£å¦‚æˆ‘ä»¬åœ¨è¦†ç›–æ— ç±»å‹<code>lambda</code>æ¼”ç®—æ—¶æ‰€è®¨è®ºçš„å…¶ä»–<code>pathological</code>æœ¯è¯­ä¸€æ ·.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">occursCheck</span> ::  <span class="type">Substitutable</span> a =&gt; <span class="type">TVar</span> -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">occursCheck</span> a t = a `<span class="type">Set</span>.member` ftv t</span><br></pre></td></tr></table></figure></p>
<p><code>unify</code>å‡½æ•°å­˜åœ¨äº<code>Infer monad</code>ä¸­å¹¶äº§ç”Ÿæ›¿æ¢:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">unify</span> ::  <span class="type">Type</span> -&gt; <span class="type">Type</span> -&gt; <span class="type">Infer</span> <span class="type">Subst</span></span><br><span class="line"><span class="title">unify</span> (l `<span class="type">TArr</span>` r) (l' `<span class="type">TArr</span>` r')  = <span class="keyword">do</span></span><br><span class="line">    s1 &lt;- unify l l'</span><br><span class="line">    s2 &lt;- unify (apply s1 r) (apply s1 r')</span><br><span class="line">    return (s2 `compose` s1)</span><br><span class="line"></span><br><span class="line"><span class="title">unify</span> (<span class="type">TVar</span> a) t = bind a t</span><br><span class="line"><span class="title">unify</span> t (<span class="type">TVar</span> a) = bind a t</span><br><span class="line"><span class="title">unify</span> (<span class="type">TCon</span> a) (<span class="type">TCon</span> b) | a == b = return nullSubst</span><br><span class="line"><span class="title">unify</span> t1 t2 = throwError $ <span class="type">UnificationFail</span> t1 t2</span><br><span class="line"></span><br><span class="line"><span class="title">bind</span> ::  <span class="type">TVar</span> -&gt; <span class="type">Type</span> -&gt; <span class="type">Infer</span> <span class="type">Subst</span></span><br><span class="line"><span class="title">bind</span> a t | t == <span class="type">TVar</span> a     = return nullSubst</span><br><span class="line">         | occursCheck a t = throwError $ <span class="type">InfiniteType</span> a t</span><br><span class="line">         | otherwise       = return $ <span class="type">Map</span>.singleton a t</span><br></pre></td></tr></table></figure></p>
<h3 id="Generalization-and-Instantiation-æ³›åŒ–å’Œå®ä¾‹åŒ–"><a href="#Generalization-and-Instantiation-æ³›åŒ–å’Œå®ä¾‹åŒ–" class="headerlink" title="Generalization and Instantiation (æ³›åŒ–å’Œå®ä¾‹åŒ–)"></a>Generalization and Instantiation (æ³›åŒ–å’Œå®ä¾‹åŒ–)</h3><p><code>Hindley-Milner</code>çš„æ ¸å¿ƒæ˜¯ä¸¤ä¸ªåŸºæœ¬æ“ä½œ:<br><code>Generalization</code>æ³›åŒ–: é€šè¿‡å…³é—­ç±»å‹æ–¹æ¡ˆä¸­çš„æ‰€æœ‰è‡ªç”±ç±»å‹å˜é‡,å°†<code>Ï„</code>ç±»å‹è½¬æ¢ä¸º<code>Ïƒ</code>ç±»å‹ã€‚<br><code>Instantiation</code>å®ä¾‹åŒ–: é€šè¿‡ä¸ºå½“å‰ç±»å‹ç¯å¢ƒä¸­æœªå‡ºç°çš„æ¯ä¸ªç±»å‹å˜é‡åˆ›å»ºæ–°åç§°,å°†<code>Ïƒ</code>ç±»å‹è½¬æ¢ä¸º<code>Ï„</code>ç±»å‹ã€‚<br><img src="img/HM12.png" alt=""><br>(<code>T-Inst</code>)è§„åˆ™ä¸­çš„<code>âŠ‘</code>è¿ç®—ç¬¦è¡¨ç¤ºç±»å‹æ˜¯ç±»å‹æ¨¡å¼(<code>type scheme</code>)çš„å®ä¾‹.<br><img src="img/HM13.png" alt=""><br><code>âŠ‘</code>ç¬¦å·å³è¾¹çš„ç±»å‹<code>Ï„1</code>æ˜¯å·¦è¾¹ç±»å‹æ¨¡å¼(<code>Ïƒ = å·¦è¾¹</code>)çš„å®ä¾‹åŒ–,å¦‚æœå¯¹äºæ‰€æœ‰çš„<code>Î² âˆˆ ğšğšğšŸ(Ïƒ)</code>å­˜åœ¨ä¸€ä¸ªæ›¿æ¢<code>[s]Î² = Î²</code>,åˆ™<code>Ï„1 = [s]Ï„2</code>,çœ‹ä¾‹å­:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">âˆ€a.a â†’ a âŠ‘ ğ™¸ğš—ğš â†’ ğ™¸ğš—ğš</span><br><span class="line">âˆ€a.a â†’ a âŠ‘ b â†’ b</span><br><span class="line">âˆ€ab.a â†’ b â†’ a âŠ‘ ğ™¸ğš—ğš â†’ ğ™±ğš˜ğš˜ğš• â†’ ğ™¸ğš—ğš</span><br></pre></td></tr></table></figure>
<p>è¿™äº›æ˜ å°„éå¸¸ç›´è§‚åœ°æ˜ å°„åˆ°ç®€å•åœ°æ“ä½œ<code>Haskell Set</code>å˜é‡å¯¹è±¡å’Œæ–°åç§°ä¾›åº”çš„ä»£ç :<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">instantiate</span> ::  <span class="type">Scheme</span> -&gt; <span class="type">Infer</span> <span class="type">Type</span></span><br><span class="line"><span class="title">instantiate</span> (<span class="type">Forall</span> <span class="keyword">as</span> t) = <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">as</span>' &lt;- mapM (const fresh) <span class="keyword">as</span></span><br><span class="line">  <span class="keyword">let</span> s = <span class="type">Map</span>.fromList $ zip <span class="keyword">as</span> <span class="keyword">as</span>'</span><br><span class="line">  return $ apply s t</span><br><span class="line"></span><br><span class="line"><span class="title">generalize</span> :: <span class="type">TypeEnv</span> -&gt; <span class="type">Type</span> -&gt; <span class="type">Scheme</span></span><br><span class="line"><span class="title">generalize</span> env t  = <span class="type">Forall</span> <span class="keyword">as</span> t</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">as</span> = <span class="type">Set</span>.toList $ ftv t `<span class="type">Set</span>.difference` ftv env</span><br></pre></td></tr></table></figure></p>
<p>æŒ‰ç…§çº¦å®š,<code>let</code>ç»‘å®šè¢«å°½å¯èƒ½åœ°ä¸€èˆ¬åŒ–(<code>generalized</code>).<br>å› æ­¤,åœ¨ä¸‹é¢çš„å®šä¹‰ä¸­,<code>f</code>åœ¨ç»‘å®šçš„ä¸»ä½“ä¸Šè¿›è¡Œäº†ä¸€èˆ¬åŒ–,ä»¥ä¾¿åœ¨æ¯æ¬¡è°ƒç”¨<code>f</code>æ—¶,éƒ½ç”¨æ–°çš„ç±»å‹å˜é‡å®ä¾‹åŒ–å®ƒ.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Poly</span>&gt; <span class="keyword">let</span> f = (\x -&gt; x) <span class="keyword">in</span> <span class="keyword">let</span> g = (f <span class="type">True</span>) <span class="keyword">in</span> f <span class="number">3</span></span><br><span class="line"><span class="number">3</span> : <span class="type">Int</span></span><br></pre></td></tr></table></figure></p>
<p>åœ¨è¿™ä¸ªè¡¨è¾¾å¼ä¸­,<code>f</code>çš„ç±»å‹åœ¨<code>let</code>å®šä¹‰ä¸­ç”Ÿæˆ,å¹¶å°†ä½¿ç”¨ä¸¤ä¸ªä¸åŒçš„ç­¾åå®ä¾‹åŒ–.<br>åœ¨fçš„è°ƒç”¨ä½ç½®,å®ƒå°†ä¸<code>Int</code>ç›¸ç»Ÿä¸€,å¦ä¸€ä¸ªä¸<code>Bool</code>ç›¸ç»Ÿä¸€ã€‚<br>ç›¸å,åœ¨<code>lambda</code>ä¸­ç»‘å®š<code>f</code>å°†å¯¼è‡´ç±»å‹é”™è¯¯.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Poly</span>&gt; (\f -&gt; <span class="keyword">let</span> g = (f <span class="type">True</span>) <span class="keyword">in</span> (f <span class="number">3</span>)) (\x -&gt; x)</span><br><span class="line"><span class="type">Cannot</span> unify types: </span><br><span class="line">    <span class="type">Bool</span></span><br><span class="line"><span class="title">with</span> </span><br><span class="line">    <span class="type">Int</span></span><br></pre></td></tr></table></figure></p>
<p>è¿™æ˜¯<code>let generalization(ä¸€èˆ¬åŒ–)</code>çš„æœ¬è´¨.</p>
<h3 id="Typing-Rules-ç±»å‹è§„åˆ™"><a href="#Typing-Rules-ç±»å‹è§„åˆ™" class="headerlink" title="Typing Rules (ç±»å‹è§„åˆ™)"></a>Typing Rules (ç±»å‹è§„åˆ™)</h3><p>æœ€å,åœ¨æ‰€æœ‰ç±»å‹æœºåˆ¶åˆ°ä½å,æˆ‘ä»¬å¯ä»¥å†™ä¸‹æˆ‘ä»¬ç®€å•çš„å°å¤šæ€<code>lambda</code>æ¼”ç®—çš„ç±»å‹è§„åˆ™.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">infer</span> :: <span class="type">TypeEnv</span> -&gt; <span class="type">Expr</span> -&gt; <span class="type">Infer</span> (<span class="type">Subst</span>, <span class="type">Type</span>)</span><br></pre></td></tr></table></figure></p>
<p><code>infer</code>å°†å±€éƒ¨ç±»å‹ç¯å¢ƒå’Œæ´»åŠ¨è¡¨è¾¾å¼æ˜ å°„åˆ°éƒ¨åˆ†ç»Ÿä¸€è§£å†³æ–¹æ¡ˆå’Œä¸­é—´ç±»å‹çš„2å…ƒç»„.é€šè¿‡åœ¨æ¯ä¸ªéƒ¨åˆ†æ¨æ–­çš„å­è¡¨è¾¾å¼å’Œå±€éƒ¨ç¯å¢ƒä¸­åº”ç”¨æ¥è‡ªç»Ÿä¸€çš„éƒ¨åˆ†æ›¿æ¢,è‡ªä¸‹è€Œä¸Šéå†<code>AST</code>å¹¶ä¸”åœ¨æ¯ä¸ªé€’å½’çº§åˆ«å¤„æ±‚è§£çº¦æŸ,å¦‚æœé‡åˆ°é”™è¯¯,åˆ™ä¼šåœ¨<code>Infer monad</code>ä¸­è°ƒç”¨<code>throwError</code>,å¹¶æŠ¥å‘Šé”™è¯¯:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">infer</span> :: <span class="type">TypeEnv</span> -&gt; <span class="type">Expr</span> -&gt; <span class="type">Infer</span> (<span class="type">Subst</span>, <span class="type">Type</span>)</span><br><span class="line"><span class="title">infer</span> env ex = <span class="keyword">case</span> ex <span class="keyword">of</span></span><br><span class="line"></span><br><span class="line">  <span class="type">Var</span> x -&gt; lookupEnv env x</span><br><span class="line"></span><br><span class="line">  <span class="type">Lam</span> x e -&gt; <span class="keyword">do</span></span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    <span class="keyword">let</span> env' = env `extend` (x, <span class="type">Forall</span> [] tv)</span><br><span class="line">    (s1, t1) &lt;- infer env' e</span><br><span class="line">    return (s1, apply s1 tv `<span class="type">TArr</span>` t1)</span><br><span class="line"></span><br><span class="line">  <span class="type">App</span> e1 e2 -&gt; <span class="keyword">do</span></span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    (s1, t1) &lt;- infer env e1</span><br><span class="line">    (s2, t2) &lt;- infer (apply s1 env) e2</span><br><span class="line">    s3       &lt;- unify (apply s2 t1) (<span class="type">TArr</span> t2 tv)</span><br><span class="line">    return (s3 `compose` s2 `compose` s1, apply s3 tv)</span><br><span class="line"></span><br><span class="line">  <span class="type">Let</span> x e1 e2 -&gt; <span class="keyword">do</span></span><br><span class="line">    (s1, t1) &lt;- infer env e1</span><br><span class="line">    <span class="keyword">let</span> env' = apply s1 env</span><br><span class="line">        t'   = generalize env' t1</span><br><span class="line">    (s2, t2) &lt;- infer (env' `extend` (x, t')) e2</span><br><span class="line">    return (s1 `compose` s2, t2)</span><br><span class="line"></span><br><span class="line">  <span class="type">If</span> cond tr fl -&gt; <span class="keyword">do</span></span><br><span class="line">    (s1, t1) &lt;- infer env cond</span><br><span class="line">    (s2, t2) &lt;- infer env tr</span><br><span class="line">    (s3, t3) &lt;- infer env fl</span><br><span class="line">    s4 &lt;- unify t1 typeBool</span><br><span class="line">    s5 &lt;- unify t2 t3</span><br><span class="line">    return (s5 `compose` s4 `compose` s3 `compose` s2 `compose` s1, apply s5 t2)</span><br><span class="line"></span><br><span class="line">  <span class="type">Fix</span> e1 -&gt; <span class="keyword">do</span></span><br><span class="line">    (s1, t) &lt;- infer env e1</span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    s2 &lt;- unify (<span class="type">TArr</span> tv tv) t</span><br><span class="line">    return (s2, apply s1 tv)</span><br><span class="line"></span><br><span class="line">  <span class="type">Op</span> op e1 e2 -&gt; <span class="keyword">do</span></span><br><span class="line">    (s1, t1) &lt;- infer env e1</span><br><span class="line">    (s2, t2) &lt;- infer env e2</span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    s3 &lt;- unify (<span class="type">TArr</span> t1 (<span class="type">TArr</span> t2 tv)) (ops <span class="type">Map</span>.! op)</span><br><span class="line">    return (s1 `compose` s2 `compose` s3, apply s3 tv)</span><br><span class="line"></span><br><span class="line">  <span class="type">Lit</span> (<span class="type">LInt</span> _)  -&gt; return (nullSubst, typeInt)</span><br><span class="line">  <span class="type">Lit</span> (<span class="type">LBool</span> _) -&gt; return (nullSubst, typeBool)</span><br></pre></td></tr></table></figure></p>
<p>è®©æˆ‘ä»¬æµè§ˆæ¯ä¸ªè§„åˆ™æ´¾ç”Ÿï¼Œçœ‹çœ‹å®ƒå¦‚ä½•è½¬æ¢ä¸ºä»£ç :</p>
<h4 id="T-Var"><a href="#T-Var" class="headerlink" title="T-Var"></a>T-Var</h4><p>T-Varè§„åˆ™ï¼Œåªéœ€ä»<code>typing</code>å˜æ¢ä¸Šä¸‹æ–‡ä¸­æå–å˜é‡çš„ç±»å‹å³å¯.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Var</span> x -&gt; lookupEnv env x</span><br></pre></td></tr></table></figure></p>
<p>å‡½æ•°<code>lookupVar</code>åœ¨<code>typing</code>ç¯å¢ƒä¸­æŸ¥æ‰¾å±€éƒ¨å˜é‡å¼•ç”¨,å¦‚æœæ‰¾åˆ°å®ƒ,åˆ™å®ä¾‹åŒ–ä¸€ä¸ªæ–°å‰¯æœ¬.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lookupEnv</span> :: <span class="type">TypeEnv</span> -&gt; <span class="type">Var</span> -&gt; <span class="type">Infer</span> (<span class="type">Subst</span>, <span class="type">Type</span>)</span><br><span class="line"><span class="title">lookupEnv</span> (<span class="type">TypeEnv</span> env) x = <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Map</span>.lookup x env <span class="keyword">of</span></span><br><span class="line">    <span class="type">Nothing</span> -&gt; throwError $ <span class="type">UnboundVariable</span> (show x)</span><br><span class="line">    <span class="type">Just</span> s  -&gt; <span class="keyword">do</span> t &lt;- instantiate s</span><br><span class="line">                  return (nullSubst, t)</span><br></pre></td></tr></table></figure></p>
<p><img src="img/HM14.png" alt=""></p>
<h4 id="T-Lam"><a href="#T-Lam" class="headerlink" title="T-Lam"></a>T-Lam</h4><p>å¯¹äº<code>lambdas</code>,ç”±<code>lambda</code>ç»‘å®šçš„å˜é‡æœ¬åœ°ä½œç”¨äº<code>typing</code>ç¯å¢ƒ,ç„¶åä½¿ç”¨æ­¤ä½œç”¨åŸŸæ¨æ–­è¡¨è¾¾å¼çš„ä¸»ä½“.<br>è¾“å‡ºç±»å‹æ˜¯ä¸€ä¸ªæ–°ç±»å‹å˜é‡,å¹¶ä¸ç”Ÿæˆçš„æ¨æ–­ç±»å‹ç»Ÿä¸€.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lam</span> x e -&gt; <span class="keyword">do</span></span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    <span class="keyword">let</span> env' = env `extend` (x, <span class="type">Forall</span> [] tv)</span><br><span class="line">    (s1, t1) &lt;- infer env' e</span><br><span class="line">    return (s1, apply s1 tv `<span class="type">TArr</span>` t1)</span><br></pre></td></tr></table></figure></p>
<p><img src="img/HM15.png" alt=""></p>
<h4 id="T-App"><a href="#T-App" class="headerlink" title="T-App"></a>T-App</h4><p>å¯¹äºåº”ç”¨ç¨‹åº,ç¬¬ä¸€ä¸ªå‚æ•°å¿…é¡»æ˜¯<code>lambda</code>è¡¨è¾¾å¼æˆ–è¿”å›<code>lambda</code>è¡¨è¾¾å¼,å› æ­¤è¦çŸ¥é“å®ƒå¿…é¡»æ˜¯<code>t1 -&gt; t2</code>çš„å½¢å¼,ä½†é™¤äº†ä¸¤ä¸ªå€¼çš„æ±‡åˆå¤–,ä¸ç¡®å®šè¾“å‡ºç±»å‹ã€‚<br>æˆ‘ä»¬æ¨æ–­ä¸¤ç§ç±»å‹,<br>å°†ç¬¬ä¸€ä¸ªå‚æ•°ä¸­çš„çº¦æŸåº”ç”¨äºç¬¬äºŒæ¨æ–­ç±»å‹çš„ç»“æœ,ç„¶åä½¿ç”¨æ•´ä¸ªåº”ç”¨ç¨‹åºè¡¨è¾¾å¼çš„ä¾‹å¤–å½¢å¼(<code>excepted form</code>)ç»Ÿä¸€è¿™ä¸¤ä¸ªç±»å‹ã€‚<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">App e1 e2 -&gt; do</span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    (s1, t1) &lt;- infer env e1</span><br><span class="line">    (s2, t2) &lt;- infer (apply s1 env) e2</span><br><span class="line">    s3       &lt;- unify (apply s2 t1) (TArr t2 tv)</span><br><span class="line">    return (s3 `compose` s2 `compose` s1, apply s3 tv)</span><br></pre></td></tr></table></figure></p>
<p><img src="img/HM16.png" alt=""></p>
<h4 id="T-Let"><a href="#T-Let" class="headerlink" title="T-Let"></a>T-Let</h4><p>å¦‚å‰æ‰€è¿°,<code>let</code>å°†ä¼š<code>generalized</code>(ä¸€èˆ¬åŒ–),å› æ­¤æˆ‘ä»¬å°†ä¸º<code>let</code>è¡¨è¾¾å¼çš„ä¸»ä½“åˆ›å»ºä¸€ä¸ªæœ¬åœ°<code>typing</code>ç±»å‹åŒ–ç¯å¢ƒ,å¹¶æ·»åŠ ä¸€èˆ¬åŒ–æ¨æ–­ç±»å‹çš„<code>let</code>ç»‘å®šå€¼åˆ°ä¸»ä½“çš„<code>typing</code>ç¯å¢ƒä¸­.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Let</span> x e1 e2 -&gt; <span class="keyword">do</span></span><br><span class="line">   (s1, t1) &lt;- infer env e1</span><br><span class="line">   <span class="keyword">let</span> env' = apply s1 env</span><br><span class="line">       t'   = generalize env' t1</span><br><span class="line">   (s2, t2) &lt;- infer (env' `extend` (x, t')) e2</span><br><span class="line">   return (s1 `compose` s2, t2)</span><br></pre></td></tr></table></figure></p>
<p><img src="img/HM17.png" alt=""></p>
<h4 id="T-BinOp"><a href="#T-BinOp" class="headerlink" title="T-BinOp"></a>T-BinOp</h4><p>æœ‰å‡ ä¸ªå†…å»ºæ“ä½œ,æˆ‘ä»¬åˆ°ç›®å‰ä¸ºæ­¢è¿˜æ²¡æœ‰æåˆ°,å› ä¸ºç±»å‹è§„åˆ™å¾ˆç®€å•,æˆ‘ä»¬åªéœ€ç»Ÿä¸€è¿™ä¸ªæ“ä½œçš„é¢„è®¾ç½®ç±»å‹ç­¾å.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Op</span> op e1 e2 -&gt; <span class="keyword">do</span></span><br><span class="line">    (s1, t1) &lt;- infer env e1</span><br><span class="line">    (s2, t2) &lt;- infer env e2</span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    s3 &lt;- unify (<span class="type">TArr</span> t1 (<span class="type">TArr</span> t2 tv)) (ops <span class="type">Map</span>.! op)</span><br><span class="line">    return (s1 `compose` s2 `compose` s3, apply s3 tv)</span><br><span class="line"></span><br><span class="line"><span class="title">ops</span> :: <span class="type">Map</span>.<span class="type">Map</span> <span class="type">Binop</span> <span class="type">Type</span></span><br><span class="line"><span class="title">ops</span> = <span class="type">Map</span>.fromList [</span><br><span class="line">      (<span class="type">Add</span>, (typeInt `<span class="type">TArr</span>` (typeInt `<span class="type">TArr</span>` typeInt)))</span><br><span class="line">    , (<span class="type">Mul</span>, (typeInt `<span class="type">TArr</span>` (typeInt `<span class="type">TArr</span>` typeInt)))</span><br><span class="line">    , (<span class="type">Sub</span>, (typeInt `<span class="type">TArr</span>` (typeInt `<span class="type">TArr</span>` typeInt)))</span><br><span class="line">    , (<span class="type">Eql</span>, (typeInt `<span class="type">TArr</span>` (typeInt `<span class="type">TArr</span>` typeBool)))</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p>
<h4 id="Literals"><a href="#Literals" class="headerlink" title="Literals"></a>Literals</h4><p><code>literal</code>æ•´æ•°å’Œ<code>boolean</code>ç±»å‹çš„ç±»å‹é€šå¸¸æ˜¯å®ƒä»¬å„è‡ªçš„ç±»å‹.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(+) :: ğ™¸ğš—ğš â†’ ğ™¸ğš—ğš â†’ ğ™¸ğš—ğš</span><br><span class="line">(Ã—) :: ğ™¸ğš—ğš â†’ ğ™¸ğš—ğš â†’ ğ™¸ğš—ğš</span><br><span class="line">(âˆ’) :: ğ™¸ğš—ğš â†’ ğ™¸ğš—ğš â†’ ğ™¸ğš—ğš</span><br><span class="line">(=) :: ğ™¸ğš—ğš â†’ ğ™¸ğš—ğš â†’ ğ™±ğš˜ğš˜ğš•</span><br></pre></td></tr></table></figure></p>
<p><img src="img/HM18.png" alt=""></p>
<h3 id="Constraint-Generation-çº¦æŸç”Ÿæˆ"><a href="#Constraint-Generation-çº¦æŸç”Ÿæˆ" class="headerlink" title="Constraint Generation (çº¦æŸç”Ÿæˆ)"></a>Constraint Generation (çº¦æŸç”Ÿæˆ)</h3><p><code>Hindley Milner</code>çš„å…ˆå‰å®ç°å¾ˆç®€å•,ä½†å…·æœ‰æ··åˆä¸¤ä¸ªç‹¬ç«‹è¿‡ç¨‹çš„å¥‡æ€ªç‰¹æ€§: <code>constraint solving</code>(çº¦æŸæ±‚è§£å™¨)å’Œ<code>traversal</code>(éå†).è®©æˆ‘ä»¬è®¨è®ºä¸æ‰§è¡Œæ­¤æ“ä½œçš„æ¨ç†ç®—æ³•çš„å¦ä¸€ç§å®ç°.<br>åœ¨çº¦æŸç”Ÿæˆæ–¹æ³•ä¸­,çº¦æŸæ˜¯é€šè¿‡è‡ªä¸‹è€Œä¸Šéå†ç”Ÿæˆçš„,æ·»åŠ åˆ°æœ‰åºå®¹å™¨ä¸­,è§„èŒƒåŒ–,æ±‚è§£,ç„¶åå¯èƒ½åœ¨ç±»å‹åŒ–ASTä¸Šè¿›è¡Œåç½®æ›¿æ¢.è¿™å°†æ˜¯æˆ‘ä»¬å°†ä»è¿™é‡Œä½¿ç”¨çš„æ–¹æ³•,<br>è™½ç„¶ä¸<code>on-line solver</code>ä¹‹é—´å­˜åœ¨ç­‰ä»·,ä½†ä½¿ç”¨å•ç‹¬çš„çº¦æŸæ±‚è§£å™¨å˜å¾—æ›´å®¹æ˜“ç®¡ç†,å› ä¸ºæˆ‘ä»¬çš„ç±»å‹ç³»ç»Ÿå˜å¾—æ›´å¤æ‚,æˆ‘ä»¬å¼€å§‹æ„å»ºè¯­è¨€.<br>ç°åœ¨æˆ‘ä»¬çš„æ¨ç†<code>monad</code>å˜æˆäº†<code>RWST</code>(<code>Reader-Writer-State</code>è½¬æ¢å™¨)+<code>Either</code>(å¤„ç†ç±»å‹é”™è¯¯).æ¨ç†çŠ¶æ€ä¿æŒä¸å˜,åªæ˜¯æä¾›æ–°é²œçš„åç§°.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- | Inference monad</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Infer</span> a = (<span class="type">RWST</span></span></span><br><span class="line"><span class="class">                  <span class="type">Env</span>             <span class="comment">-- Typing environment</span></span></span><br><span class="line"><span class="class">                  [<span class="type">Constraint</span>]    <span class="comment">-- Generated constraints</span></span></span><br><span class="line"><span class="class">                  <span class="type">InferState</span>      <span class="comment">-- Inference state</span></span></span><br><span class="line"><span class="class">                  (<span class="type">Except</span>         <span class="comment">-- Inference errors</span></span></span><br><span class="line"><span class="class">                    <span class="type">TypeError</span>)</span></span><br><span class="line">                  a)              <span class="comment">-- Result</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | Inference state</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">InferState</span> = <span class="type">InferState</span> &#123; <span class="title">count</span> :: <span class="type">Int</span> &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>æˆ‘ä»¬å°†åªæ”¶é›†<code>Writer</code>ä¸­çš„<code>unifier</code>å¹¶ä½¿ç”¨<code>uni</code>å‡½æ•°å‘å‡ºå®ƒä»¬,è€Œä¸æ˜¯åœ¨æ¯ä¸ªéå†çº§åˆ«ç»Ÿä¸€ç±»å‹å˜é‡.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- | Unify two types</span></span><br><span class="line"><span class="title">uni</span> :: <span class="type">Type</span> -&gt; <span class="type">Type</span> -&gt; <span class="type">Infer</span> ()</span><br><span class="line"><span class="title">uni</span> t1 t2 = tell [(t1, t2)]</span><br></pre></td></tr></table></figure></p>
<p>ç”±äº<code>typing</code>è¾“å…¥ç¯å¢ƒå­˜å‚¨åœ¨<code>Reader monad</code>ä¸­,æˆ‘ä»¬å¯ä»¥ä½¿ç”¨<code>local</code>æ¥ä¸º<code>typing</code>ç¯å¢ƒåˆ›å»ºä¸€ä¸ªæœ¬åœ°èŒƒå›´çš„é™„åŠ ç»„ä»¶.è¿™å¯¹äº<code>typing</code>ç»‘å®šå™¨å¾ˆæ–¹ä¾¿.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- | Extend type environment</span></span><br><span class="line"><span class="title">inEnv</span> :: (<span class="type">Name</span>, <span class="type">Scheme</span>) -&gt; <span class="type">Infer</span> a -&gt; <span class="type">Infer</span> a</span><br><span class="line"><span class="title">inEnv</span> (x, sc) m = <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">let</span> scope e = (remove e x) `extend` (x, sc)</span><br><span class="line">  local scope m</span><br></pre></td></tr></table></figure></p>
<h3 id="Typing"><a href="#Typing" class="headerlink" title="Typing"></a>Typing</h3><p>è¿™äº›ç±»å‹è§„åˆ™æ˜¯ç›¸åŒçš„,åªæ˜¯ç°åœ¨æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ç§ä¸éœ€è¦çº¿ç¨‹å¤„ç†å¤ªå¤šçŠ¶æ€çš„æ›´å°‘å™ªéŸ³çš„æ–¹å¼æ¥ç¼–å†™å®ƒä»¬.<br>æ‰€æœ‰çš„ç»†èŠ‚éƒ½è¢«éšè—èµ·æ¥,å¹¶è¢«ç¼–ç åœ¨ç‰¹å®šçš„ç»„åˆå™¨ä¸­,ä»¥ä¸€ç§è®©æˆ‘ä»¬ä¸“æ³¨äºé¢†åŸŸé€»è¾‘çš„æ–¹å¼æ“çºµæˆ‘ä»¬çš„<code>Infer monad</code>çš„çŠ¶æ€ã€‚<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">infer</span> :: <span class="type">Expr</span> -&gt; <span class="type">Infer</span> <span class="type">Type</span></span><br><span class="line"><span class="title">infer</span> expr = <span class="keyword">case</span> expr <span class="keyword">of</span></span><br><span class="line">  <span class="type">Lit</span> (<span class="type">LInt</span> _)  -&gt; return $ typeInt</span><br><span class="line">  <span class="type">Lit</span> (<span class="type">LBool</span> _) -&gt; return $ typeBool</span><br><span class="line"></span><br><span class="line">  <span class="type">Var</span> x -&gt; lookupEnv x</span><br><span class="line"></span><br><span class="line">  <span class="type">Lam</span> x e -&gt; <span class="keyword">do</span></span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    t &lt;- inEnv (x, <span class="type">Forall</span> [] tv) (infer e)</span><br><span class="line">    return (tv `<span class="type">TArr</span>` t)</span><br><span class="line"></span><br><span class="line">  <span class="type">App</span> e1 e2 -&gt; <span class="keyword">do</span></span><br><span class="line">    t1 &lt;- infer e1</span><br><span class="line">    t2 &lt;- infer e2</span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    uni t1 (t2 `<span class="type">TArr</span>` tv)</span><br><span class="line">    return tv</span><br><span class="line"></span><br><span class="line">  <span class="type">Let</span> x e1 e2 -&gt; <span class="keyword">do</span></span><br><span class="line">    env &lt;- ask</span><br><span class="line">    t1 &lt;- infer e1</span><br><span class="line">    <span class="keyword">let</span> sc = generalize env t1</span><br><span class="line">    t2 &lt;- inEnv (x, sc) (infer e2)</span><br><span class="line">    return t2</span><br><span class="line"></span><br><span class="line">  <span class="type">Fix</span> e1 -&gt; <span class="keyword">do</span></span><br><span class="line">    t1 &lt;- infer e1</span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    uni (tv `<span class="type">TArr</span>` tv) t1</span><br><span class="line">    return tv</span><br><span class="line"></span><br><span class="line">  <span class="type">Op</span> op e1 e2 -&gt; <span class="keyword">do</span></span><br><span class="line">    t1 &lt;- infer e1</span><br><span class="line">    t2 &lt;- infer e2</span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    <span class="keyword">let</span> u1 = t1 `<span class="type">TArr</span>` (t2 `<span class="type">TArr</span>` tv)</span><br><span class="line">        u2 = ops <span class="type">Map</span>.! op</span><br><span class="line">    uni u1 u2</span><br><span class="line">    return tv</span><br><span class="line"></span><br><span class="line">  <span class="type">If</span> cond tr fl -&gt; <span class="keyword">do</span></span><br><span class="line">    t1 &lt;- infer cond</span><br><span class="line">    t2 &lt;- infer tr</span><br><span class="line">    t3 &lt;- infer fl</span><br><span class="line">    uni t1 typeBool</span><br><span class="line">    uni t2 t3</span><br><span class="line">    return t2</span><br></pre></td></tr></table></figure></p>
<h3 id="Constraint-Solver-çº¦æŸè§£å†³å™¨"><a href="#Constraint-Solver-çº¦æŸè§£å†³å™¨" class="headerlink" title="Constraint Solver (çº¦æŸè§£å†³å™¨)"></a>Constraint Solver (çº¦æŸè§£å†³å™¨)</h3><p><code>Infer monad</code>çš„<code>Writer</code>å±‚åŒ…å«ä»æ¨ç†ä¼ é€’å‘å‡ºçš„ç”Ÿæˆçš„çº¦æŸé›†.<br>ä¸€æ—¦æ¨æ–­å®Œæˆ,æˆ‘ä»¬å°±ä¼šå¾—åˆ°ä¸€ä¸ªç»“æœç±»å‹ç­¾å,å…¶ä¸­åŒ…å«æ— æ„ä¹‰çš„å”¯ä¸€æ–°å˜é‡å’Œä¸€ç»„çº¦æŸ,æˆ‘ä»¬å¿…é¡»è§£å†³è¿™äº›çº¦æŸä»¥å°†ç±»å‹ç»†åŒ–ä¸ºå…¶ä¸»è¦ç±»å‹.<br>çº¦æŸç”±ä¸€ä¸ªå•ç‹¬çš„<code>Solve monad</code>è§£å†³,è¯¥<code>monad</code>åŒ…å«<code>Unifier</code>(æœ€å¸¸è§çš„ç»Ÿä¸€)è§£å†³æ–¹æ¡ˆ,å½“åº”ç”¨äºç”Ÿæˆçš„ç­¾åæ—¶,å®ƒå°†äº§ç”Ÿè§£å†³æ–¹æ¡ˆ.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Constraint</span> = (<span class="type">Type</span>, <span class="type">Type</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Unifier</span> = (<span class="type">Subst</span>, [<span class="type">Constraint</span>])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | Constraint solver monad</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Solve</span> a = <span class="type">StateT</span> <span class="type">Unifier</span> (<span class="type">ExceptT</span> <span class="type">TypeError</span> <span class="type">Identity</span>) a</span></span><br></pre></td></tr></table></figure></p>
<p>ç»Ÿä¸€é€»è¾‘ä¹Ÿä¸ä»¥å‰ç›¸åŒ,é™¤äº†å®ƒç°åœ¨è„±ç¦»æ¨ç†ç‹¬ç«‹ç¼–å†™,å¹¶å°†å…¶éƒ¨åˆ†çŠ¶æ€å­˜å‚¨åœ¨<code>Solve monad</code>çš„çŠ¶æ€å±‚å†….<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">unifies</span> :: <span class="type">Type</span> -&gt; <span class="type">Type</span> -&gt; <span class="type">Solve</span> <span class="type">Unifier</span></span><br><span class="line"><span class="title">unifies</span> t1 t2 | t1 == t2 = return emptyUnifer</span><br><span class="line"><span class="title">unifies</span> (<span class="type">TVar</span> v) t = v `bind` t</span><br><span class="line"><span class="title">unifies</span> t (<span class="type">TVar</span> v) = v `bind` t</span><br><span class="line"><span class="title">unifies</span> (<span class="type">TArr</span> t1 t2) (<span class="type">TArr</span> t3 t4) = unifyMany [t1, t2] [t3, t4]</span><br><span class="line"><span class="title">unifies</span> t1 t2 = throwError $ <span class="type">UnificationFail</span> t1 t2</span><br><span class="line"></span><br><span class="line"><span class="title">unifyMany</span> :: [<span class="type">Type</span>] -&gt; [<span class="type">Type</span>] -&gt; <span class="type">Solve</span> <span class="type">Unifier</span></span><br><span class="line"><span class="title">unifyMany</span> [] [] = return emptyUnifer</span><br><span class="line"><span class="title">unifyMany</span> (t1 : ts1) (t2 : ts2) =</span><br><span class="line">  <span class="keyword">do</span> (su1,cs1) &lt;- unifies t1 t2</span><br><span class="line">     (su2,cs2) &lt;- unifyMany (apply su1 ts1) (apply su1 ts2)</span><br><span class="line">     return (su2 `compose` su1, cs1 ++ cs2)</span><br><span class="line"><span class="title">unifyMany</span> t1 t2 = throwError $ <span class="type">UnificationMismatch</span> t1 t2</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The solver function simply iterates over the set of constraints, composing them and applying the resulting constraint solution over the intermediate solution eventually converting on the most general unifier which yields the final substitution which when applied over the inferred type signature, yields the principal type solution for the expression.</span><br></pre></td></tr></table></figure>
<p>æ±‚è§£å™¨å‡½æ•°ç®€å•åœ°è¿­ä»£çº¦æŸé›†,ç»„åˆå®ƒä»¬å¹¶å°†ç»“æœçº¦æŸè§£å†³æ–¹æ¡ˆåº”ç”¨äºä¸­é—´è§£å†³æ–¹æ¡ˆ,æœ€ç»ˆè½¬æ¢ä¸ºæœ€é€šç”¨çš„ç»Ÿä¸€,äº§ç”Ÿæœ€ç»ˆæ›¿æ¢,å½“åº”ç”¨äºæ¨æ–­ç±»å‹ç­¾åæ—¶,ä¸ºè¡¨è¾¾å¼äº§ç”Ÿä¸»è¦ç±»å‹è§£å†³æ–¹æ¡ˆ.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Unification solver</span></span><br><span class="line"><span class="title">solver</span> :: <span class="type">Solve</span> <span class="type">Subst</span></span><br><span class="line"><span class="title">solver</span> = <span class="keyword">do</span></span><br><span class="line">  (su, cs) &lt;- get</span><br><span class="line">  <span class="keyword">case</span> cs <span class="keyword">of</span></span><br><span class="line">    [] -&gt; return su</span><br><span class="line">    ((t1, t2): cs0) -&gt; <span class="keyword">do</span></span><br><span class="line">      (su1, cs1)  &lt;- unifies t1 t2</span><br><span class="line">      put (su1 `compose` su, cs1 ++ (apply su1 cs0))</span><br><span class="line">      solver</span><br></pre></td></tr></table></figure>
<p>è¿™æ˜¯ä¸€ä¸ªæ›´åŠ ä¼˜é›…çš„è§£å†³æ–¹æ¡ˆï¼Œè€Œä¸æ˜¯åœ¨åŒä¸€ä¸ªä¼ é€’ä¸­æ··åˆæ¨ç†å’Œæ±‚è§£ï¼Œå¹¶ä¸”å¾ˆå¥½åœ°é€‚åº”äº†æˆ‘ä»¬å°†åœ¨åé¢çš„ç« èŠ‚ä¸­è®¨è®ºçš„ç±»å‹åŒ–æ ¸å¿ƒå½¢å¼çš„ç”Ÿæˆã€‚</p>
<h3 id="Worked-Examples"><a href="#Worked-Examples" class="headerlink" title="Worked Examples"></a>Worked Examples</h3><p>è®©æˆ‘ä»¬æ¥çœ‹ä¸¤ä¸ªæ¨ç†å¦‚ä½•é€‚ç”¨äºç®€å•å‡½æ•°çš„ä¾‹å­.</p>
<h4 id="ä¾‹å­1"><a href="#ä¾‹å­1" class="headerlink" title="ä¾‹å­1"></a>ä¾‹å­1</h4><p>è€ƒè™‘:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x y z -&gt; x + y + z</span><br></pre></td></tr></table></figure></p>
<p><code>infer</code>å‡½æ•°ç”Ÿæˆçš„ç±»å‹åªåŒ…å«æ¯ä¸ªå‚æ•°å’Œè¿”å›ç±»å‹çš„æ–°å˜é‡.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">a</span> -&gt; b -&gt; c -&gt; e</span><br></pre></td></tr></table></figure></p>
<p>å½“æˆ‘ä»¬éå†ä¸¤ä¸ªåŠ æ³•è¿ç®—æ—¶ï¼Œå‘å‡ºç”±T-BinOpå¼•èµ·çš„çº¦æŸ.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> a -&gt; b -&gt; d ~ <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="number">2.</span> d -&gt; c -&gt; e ~ <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure></p>
<p>è¿™é‡Œ<code>d</code>æ˜¯ä¸­é—´é¡¹<code>x + y</code>çš„ç±»å‹.é€šè¿‡åº”ç”¨<code>Uni-Arrow</code>,æˆ‘ä»¬å¯ä»¥æ¨å¯¼å‡ºä»¥ä¸‹ä¸€ç»„æ›¿æ¢.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> a ~ <span class="type">Int</span></span><br><span class="line"><span class="number">2.</span> b ~ <span class="type">Int</span></span><br><span class="line"><span class="number">3.</span> c ~ <span class="type">Int</span></span><br><span class="line"><span class="number">4.</span> d ~ <span class="type">Int</span></span><br><span class="line"><span class="number">5.</span> e ~ <span class="type">Int</span></span><br></pre></td></tr></table></figure></p>
<p>å°†æ­¤è§£å†³æ–¹æ¡ˆæ›¿æ¢å›ç±»å‹ä¼šäº§ç”Ÿæ¨æ–­ç±»å‹:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure></p>
<h4 id="ä¾‹å­2"><a href="#ä¾‹å­2" class="headerlink" title="ä¾‹å­2"></a>ä¾‹å­2</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">compose</span> f g x = f (g x)</span><br></pre></td></tr></table></figure>
<p>æ¨æ–­å‡½æ•°ç”Ÿæˆçš„ç±»å‹ä»…åŒ…å«å”¯ä¸€çš„æ–°å˜é‡.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">a</span> -&gt; b -&gt; c -&gt; e</span><br></pre></td></tr></table></figure></p>
<p>ç”±ä¸¤ä¸ªT-Appè§„åˆ™å¼•èµ·çš„æˆ‘ä»¬å¾—åˆ°ä»¥ä¸‹çº¦æŸ:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> b ~ c -&gt; d</span><br><span class="line"><span class="number">2.</span> a ~ d -&gt; e</span><br></pre></td></tr></table></figure></p>
<p>è¿™é‡Œ<code>d</code>æ˜¯<code>(g x)</code>çš„ç±»å‹,çº¦æŸå·²ç»æ˜¯è§„èŒƒå½¢å¼,é€šè¿‡åº”ç”¨<code>Uni-VarLeft</code>ä¸¤æ¬¡,æˆ‘ä»¬å¾—åˆ°ä»¥ä¸‹ä¸€ç»„æ›¿æ¢:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> b ~ c -&gt; d</span><br><span class="line"><span class="number">2.</span> a ~ d -&gt; e</span><br></pre></td></tr></table></figure></p>
<p>æ‰€ä»¥æˆ‘ä»¬å¾—åˆ°è¿™ç§ç±»å‹:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">compose</span> :: <span class="keyword">forall</span> c d e. (d -&gt; e) -&gt; (c -&gt; d) -&gt; c -&gt; e</span><br></pre></td></tr></table></figure></p>
<p>å¦‚æœéœ€è¦ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰å­—æ¯é¡ºåºé‡å‘½åå˜é‡ä»¥è·å¾—:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">compose</span> :: <span class="keyword">forall</span> a b c. (a -&gt; b) -&gt; (c -&gt; a) -&gt; c -&gt; b</span><br></pre></td></tr></table></figure></p>
<h3 id="Interpreter"><a href="#Interpreter" class="headerlink" title="Interpreter"></a>Interpreter</h3><p>æˆ‘ä»¬çš„æ±‚å€¼ç¨‹åºå°†ç›´æ¥åœ¨è¯­æ³•ä¸Šè¿è¡Œï¼Œå¹¶å°†ç»“æœè®¡ç®—ä¸º<code>Value</code>ç±»å‹.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Value</span></span></span><br><span class="line">  = <span class="type">VInt</span> <span class="type">Integer</span></span><br><span class="line">  | <span class="type">VBool</span> <span class="type">Bool</span></span><br><span class="line">  | <span class="type">VClosure</span> <span class="type">String</span> <span class="type">Expr</span> <span class="type">TermEnv</span></span><br></pre></td></tr></table></figure></p>
<p>è§£é‡Šå™¨è®¾ç½®ä¸º<code>Identity monad</code>,åé¢å®ƒå°†æˆä¸ºä¸€ä¸ªæ›´å¤æ‚çš„<code>monad</code>,ä½†ç°åœ¨å®ƒå¾ˆç®€å•.å€¼(<code>value</code>)ç¯å¢ƒå°†æ˜¾å¼åœ°çº¿ç¨‹åŒ–,å¹¶ä¸”æ¯å½“åˆ›å»ºé—­åŒ…æ—¶,æˆ‘ä»¬åªéœ€åœ¨é—­åŒ…ä¸­å­˜å‚¨æœ¬åœ°ç¯å¢ƒçš„å‰¯æœ¬.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">TermEnv</span> = <span class="type">Map</span>.<span class="type">Map</span> <span class="type">String</span> <span class="type">Value</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Interpreter</span> t = <span class="type">Identity</span> t</span></span><br></pre></td></tr></table></figure></p>
<p>æˆ‘ä»¬çš„è®¡ç®—é€»è¾‘æ˜¯ä¸Šä¸€ç« å®ç°çš„lambdaæ¼”ç®—æ±‚å€¼å™¨çš„æ‰©å±•.<br>ç„¶è€Œï¼Œæ‚¨å¯èƒ½ä¼šæ³¨æ„åˆ°åœ¨æ•´ä¸ªè¯„ä¼°è¿‡ç¨‹ä¸­ä½¿ç”¨äº†è®¸å¤šä¸å®Œæ•´çš„æ¨¡å¼.<br>ä¸è¿‡ä¸è¦å®³æ€•,æˆ‘ä»¬çš„ç¨‹åºè¯„ä¼°ä¸ä¼šâ€å‡ºé”™â€.<br>è¿™äº›æ¨¡å¼ä¸­çš„æ¯ä¸€ä¸ªéƒ½ä»£è¡¨äº†æˆ‘ä»¬çš„ç±»å‹ç³»ç»Ÿä¿è¯æ°¸è¿œä¸ä¼šå‘ç”Ÿçš„ä¸€ç§çŠ¶æ€.<br>ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬çš„ç¨‹åºæ²¡æœ‰åœ¨ä½œç”¨åŸŸä¸­å¼•ç”¨æ¯ä¸ªå˜é‡,é‚£ä¹ˆå®ƒå°†æ°¸è¿œä¸ä¼šè¾¾åˆ°å¼€å§‹æ—¶çš„æ±‚å€¼,å¹¶ä¸”å°†åœ¨ç±»å‹æ£€æŸ¥å™¨ä¸­è¢«æ‹’ç»,æˆ‘ä»¬åœ¨è¿™é‡Œä½¿ç”¨ä¸å®Œæ•´çš„æ¨¡å¼åœ¨é“ä¹‰ä¸Šæ˜¯æ­£ç¡®çš„!<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">eval</span> :: <span class="type">TermEnv</span> -&gt; <span class="type">Expr</span> -&gt; <span class="type">Interpreter</span> <span class="type">Value</span></span><br><span class="line"><span class="title">eval</span> env expr = <span class="keyword">case</span> expr <span class="keyword">of</span></span><br><span class="line">  <span class="type">Lit</span> (<span class="type">LInt</span> k)  -&gt; return $ <span class="type">VInt</span> k</span><br><span class="line">  <span class="type">Lit</span> (<span class="type">LBool</span> k) -&gt; return $ <span class="type">VBool</span> k</span><br><span class="line"></span><br><span class="line">  <span class="type">Var</span> x -&gt; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">let</span> <span class="type">Just</span> v = <span class="type">Map</span>.lookup x env</span><br><span class="line">    return v</span><br><span class="line"></span><br><span class="line">  <span class="type">Op</span> op a b -&gt; <span class="keyword">do</span></span><br><span class="line">    <span class="type">VInt</span> a' &lt;- eval env a</span><br><span class="line">    <span class="type">VInt</span> b' &lt;- eval env b</span><br><span class="line">    return $ (binop op) a' b'</span><br><span class="line"></span><br><span class="line">  <span class="type">Lam</span> x body -&gt; </span><br><span class="line">    return (<span class="type">VClosure</span> x body env)</span><br><span class="line"></span><br><span class="line">  <span class="type">App</span> fun arg -&gt; <span class="keyword">do</span></span><br><span class="line">    <span class="type">VClosure</span> x body clo &lt;- eval env fun</span><br><span class="line">    argv &lt;- eval env arg</span><br><span class="line">    <span class="keyword">let</span> nenv = <span class="type">Map</span>.insert x argv clo</span><br><span class="line">    eval nenv body</span><br><span class="line"></span><br><span class="line">  <span class="type">Let</span> x e body -&gt; <span class="keyword">do</span></span><br><span class="line">    e' &lt;- eval env e</span><br><span class="line">    <span class="keyword">let</span> nenv = <span class="type">Map</span>.insert x e' env</span><br><span class="line">    eval nenv body</span><br><span class="line"></span><br><span class="line">  <span class="type">If</span> cond tr fl -&gt; <span class="keyword">do</span></span><br><span class="line">    <span class="type">VBool</span> br &lt;- eval env cond</span><br><span class="line">    <span class="keyword">if</span> br == <span class="type">True</span></span><br><span class="line">    <span class="keyword">then</span> eval env tr</span><br><span class="line">    <span class="keyword">else</span> eval env fl</span><br><span class="line"></span><br><span class="line">  <span class="type">Fix</span> e -&gt; <span class="keyword">do</span></span><br><span class="line">    eval env (<span class="type">App</span> e (<span class="type">Fix</span> e))</span><br><span class="line"></span><br><span class="line"><span class="title">binop</span> :: <span class="type">Binop</span> -&gt; <span class="type">Integer</span> -&gt; <span class="type">Integer</span> -&gt; <span class="type">Value</span></span><br><span class="line"><span class="title">binop</span> <span class="type">Add</span> a b = <span class="type">VInt</span> $ a + b</span><br><span class="line"><span class="title">binop</span> <span class="type">Mul</span> a b = <span class="type">VInt</span> $ a * b</span><br><span class="line"><span class="title">binop</span> <span class="type">Sub</span> a b = <span class="type">VInt</span> $ a - b</span><br><span class="line"><span class="title">binop</span> <span class="type">Eql</span> a b = <span class="type">VBool</span> $ a == b</span><br></pre></td></tr></table></figure></p>
<h3 id="Interactive-Shell"><a href="#Interactive-Shell" class="headerlink" title="Interactive Shell"></a>Interactive Shell</h3><p>æˆ‘ä»¬çš„è¯­è¨€ç°åœ¨å·²ç»æˆé•¿ä¸ºæˆ‘ä»¬ä¹‹å‰ä½¿ç”¨è¿‡çš„å°å‹<code>shell</code>,ç°åœ¨æˆ‘ä»¬éœ€è¦æ›´å¼ºå¤§çš„ä¸œè¥¿æ¥ä¿æŒæˆ‘ä»¬çš„äº¤äº’å¼è§£é‡Šå™¨çš„é€»è¾‘.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">IState</span> = <span class="type">IState</span></span></span><br><span class="line">  &#123; tyctx :: <span class="type">TypeEnv</span>  <span class="comment">-- Type environment</span></span><br><span class="line">  , tmctx :: <span class="type">TermEnv</span>  <span class="comment">-- Value environment</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="title">initState</span> :: <span class="type">IState</span></span><br><span class="line"><span class="title">initState</span> = <span class="type">IState</span> emptyTyenv emptyTmenv</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Repl</span> a = <span class="type">HaskelineT</span> (<span class="type">StateT</span> <span class="type">IState</span> <span class="type">IO</span>) a</span></span><br><span class="line"></span><br><span class="line"><span class="title">hoistErr</span> :: <span class="type">Show</span> e =&gt; <span class="type">Either</span> e a -&gt; <span class="type">Repl</span> a</span><br><span class="line"><span class="title">hoistErr</span> (<span class="type">Right</span> val) = return val</span><br><span class="line"><span class="title">hoistErr</span> (<span class="type">Left</span> err) = <span class="keyword">do</span></span><br><span class="line">  liftIO $ print err</span><br><span class="line">  abort</span><br></pre></td></tr></table></figure></p>
<p>æˆ‘ä»¬çš„è¯­è¨€å¯ä»¥ç”±<code>GHC</code>ç¼–è¯‘æˆç‹¬ç«‹çš„äºŒè¿›åˆ¶æ–‡ä»¶:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ghc <span class="comment">--make Main.hs -o poly</span></span><br><span class="line">$ ./poly</span><br><span class="line"><span class="type">Poly</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>åœ¨æˆ‘ä»¬ç¨‹åºçš„é¡¶éƒ¨ï¼Œæˆ‘ä»¬å°†æŸ¥çœ‹å‘½ä»¤é€‰é¡¹å¹¶å…è®¸ä¸‰ç§å‘½ä»¤å˜ä½“:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ poly                # launch shell</span><br><span class="line">$ poly input.ml       # launch shell with 'input.ml' loaded</span><br><span class="line">$ poly test input.ml  # dump test for 'input.ml' to stdout</span><br></pre></td></tr></table></figure></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  args &lt;- getArgs</span><br><span class="line">  <span class="keyword">case</span> args <span class="keyword">of</span></span><br><span class="line">    []      -&gt; shell (return ())</span><br><span class="line">    [fname] -&gt; shell (load [fname])</span><br><span class="line">    [<span class="string">"test"</span>, fname] -&gt; shell (load [fname] &gt;&gt; browse [] &gt;&gt; quit ())</span><br><span class="line">    _ -&gt; putStrLn <span class="string">"invalid arguments"</span></span><br></pre></td></tr></table></figure>
<p><code>shell</code>å‘½ä»¤éœ€è¦ä¸€ä¸ª<code>pre</code>åŠ¨ä½œ,è¯¥åŠ¨ä½œåœ¨<code>shell</code>å¯åŠ¨ä¹‹å‰è¿è¡Œ,é€»è¾‘ç®€å•åœ°å°†æˆ‘ä»¬çš„<code>Repl monad</code>è¯„ä¼°ä¸º<code>IO</code>å¹¶ä»<code>main</code>å‡½æ•°è¿è¡Œå®ƒ.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">shell</span> :: <span class="type">Repl</span> a -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">shell</span> pre</span><br><span class="line">  = flip evalStateT initState</span><br><span class="line">  $ evalRepl <span class="string">"Poly&gt; "</span> cmd options completer pre</span><br></pre></td></tr></table></figure></p>
<p><code>cmd</code>é©±åŠ¨ç¨‹åºæ˜¯æˆ‘ä»¬ç¨‹åºçš„ä¸»è¦å…¥å£ç‚¹,æ¯æ¬¡ç”¨æˆ·è¾“å…¥ä¸€è¡Œè¾“å…¥æ—¶éƒ½ä¼šæ‰§è¡Œå®ƒ,ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ç”¨æˆ·è¾“å…¥è¡Œ.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">cmd</span> :: <span class="type">String</span> -&gt; <span class="type">Repl</span> ()</span><br><span class="line"><span class="title">cmd</span> source = exec <span class="type">True</span> (<span class="type">L</span>.pack source)</span><br></pre></td></tr></table></figure></p>
<p>ç„¶åï¼Œæˆ‘ä»¬çš„è¯­è¨€çš„æ ¸å¿ƒæ˜¯<code>exec</code>å‡½æ•°ï¼Œå®ƒå¯¼å…¥æ‰€æœ‰ç¼–è¯‘å™¨ä¼ é€’çš„ä¿¡æ¯ï¼Œç„¶åæŒ‰é¡ºåºçº¿ç¨‹åŒ–è¾“å…¥å’Œè¾“å‡ºï¼Œæœ€ç»ˆç”Ÿæˆä¸€ä¸ªç»“æœç±»å‹ç¯å¢ƒå’Œç¨‹åºçš„è¯„ä¼°ç»“æœã€‚å®ƒä»¬è¢«<code>monoidally</code>è¿æ¥åˆ°è§£é‡Šå™¨çš„çŠ¶æ€ä¸­ï¼Œç„¶åå¾ªç¯äº§ç”Ÿä¸‹ä¸€ç»„è¾“å…¥.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">exec</span> :: <span class="type">Bool</span> -&gt; <span class="type">L</span>.<span class="type">Text</span> -&gt; <span class="type">Repl</span> ()</span><br><span class="line"><span class="title">exec</span> update source = <span class="keyword">do</span></span><br><span class="line">  <span class="comment">-- Get the current interpreter state</span></span><br><span class="line">  st &lt;- get</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Parser ( returns AST )</span></span><br><span class="line">  mod &lt;- hoistErr $ parseModule <span class="string">"&lt;stdin&gt;"</span> source</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Type Inference ( returns Typing Environment )</span></span><br><span class="line">  tyctx' &lt;- hoistErr $ inferTop (tyctx st) mod</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Create the new environment</span></span><br><span class="line">  <span class="keyword">let</span> st' = st &#123; tmctx = foldl' evalDef (tmctx st) mod</span><br><span class="line">               , tyctx = tyctx' &lt;&gt; (tyctx st)</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Update the interpreter state</span></span><br><span class="line">  when update (put st')</span><br></pre></td></tr></table></figure></p>
<p><code>Repline</code>è¿˜æ”¯æŒæ·»åŠ ç‰¹å®šçš„å¥—æ¥å­—è¾“å…¥é›†ï¼Œä»¥ä¾¿å°†å®ƒä»¬æ˜ å°„åˆ°ç¼–è¯‘å™¨ä¸­çš„å†…ç½®å‘½ä»¤ã€‚æˆ‘ä»¬å°†å®ç°å…¶ä¸­ä¸‰ä¸ªã€‚<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Command</span>	<span class="type">Action</span></span><br><span class="line">:browse		<span class="type">Browse</span> the <span class="class"><span class="keyword">type</span> signatures for a program</span></span><br><span class="line">:load &lt;file&gt;	<span class="type">Load</span> a program from file</span><br><span class="line">:<span class="class"><span class="keyword">type</span>		<span class="type">Show</span> the <span class="keyword">type</span> of an expression</span></span><br><span class="line">:quit		<span class="type">Exit</span> interpreter</span><br></pre></td></tr></table></figure></p>
<p>å®ƒä»¬çš„å®ç°å¤§å¤šå¾ˆç®€å•ã€‚<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">options</span> :: [(<span class="type">String</span>, [<span class="type">String</span>] -&gt; <span class="type">Repl</span> ())]</span><br><span class="line"><span class="title">options</span> = [</span><br><span class="line">    (<span class="string">"load"</span>   , load)</span><br><span class="line">  , (<span class="string">"browse"</span> , browse)</span><br><span class="line">  , (<span class="string">"quit"</span>   , quit)</span><br><span class="line">  , (<span class="string">"type"</span>   , <span class="type">Main</span>.typeof)</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- :browse command</span></span><br><span class="line"><span class="title">browse</span> :: [<span class="type">String</span>] -&gt; <span class="type">Repl</span> ()</span><br><span class="line"><span class="title">browse</span> _ = <span class="keyword">do</span></span><br><span class="line">  st &lt;- get</span><br><span class="line">  liftIO $ mapM_ putStrLn $ ppenv (tyctx st)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- :load command</span></span><br><span class="line"><span class="title">load</span> :: [<span class="type">String</span>] -&gt; <span class="type">Repl</span> ()</span><br><span class="line"><span class="title">load</span> args = <span class="keyword">do</span></span><br><span class="line">  contents &lt;- liftIO $ <span class="type">L</span>.readFile (unwords args)</span><br><span class="line">  exec <span class="type">True</span> contents</span><br><span class="line"></span><br><span class="line"><span class="comment">-- :type command</span></span><br><span class="line"><span class="title">typeof</span> :: [<span class="type">String</span>] -&gt; <span class="type">Repl</span> ()</span><br><span class="line"><span class="title">typeof</span> args = <span class="keyword">do</span></span><br><span class="line">  st &lt;- get</span><br><span class="line">  <span class="keyword">let</span> arg = unwords args</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Infer</span>.typeof (tyctx st) arg <span class="keyword">of</span></span><br><span class="line">    <span class="type">Just</span> val -&gt; liftIO $ putStrLn $ ppsignature (arg, val)</span><br><span class="line">    <span class="type">Nothing</span> -&gt; exec <span class="type">False</span> (<span class="type">L</span>.pack arg)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- :quit command</span></span><br><span class="line"><span class="title">quit</span> :: a -&gt; <span class="type">Repl</span> ()</span><br><span class="line"><span class="title">quit</span> _ = liftIO $ exitSuccess</span><br></pre></td></tr></table></figure></p>
<p>æœ€åï¼Œ<code>shell</code>çš„<code>tab</code>è¡¥å…¨å°†ä½¿ç”¨è§£é‡Šå™¨çš„ç±»å‹ç¯å¢ƒ<code>key</code>åœ¨ä¸€ç»„æœ¬åœ°å®šä¹‰çš„å˜é‡ä¸Šå®Œæˆã€‚<code>Repline</code>æ”¯æŒåŸºäºå‰ç¼€çš„<code>tab</code>å®Œæˆï¼Œå…¶ä¸­å°†ä½¿ç”¨å½“å‰å‘½ä»¤çš„å‰ç¼€æ¥ç¡®å®šè¦æ‰§è¡Œå“ªäº›<code>tab</code>å®Œæˆã€‚<br>åœ¨æˆ‘ä»¬ä»¥<code>command:load</code>å¼€å¤´çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†ç›´æ¥åœ¨å½“å‰å·¥ä½œçš„æ–‡ä»¶åä¸Š<code>tab</code>å®Œæˆã€‚<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">completer</span> :: <span class="type">CompleterStyle</span> (<span class="type">StateT</span> <span class="type">IState</span> <span class="type">IO</span>)</span><br><span class="line"><span class="title">completer</span> = <span class="type">Prefix</span> (wordCompleter comp) defaultMatcher</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Prefix tab completer</span></span><br><span class="line"><span class="title">defaultMatcher</span> :: <span class="type">MonadIO</span> m =&gt; [(<span class="type">String</span>, <span class="type">CompletionFunc</span> m)]</span><br><span class="line"><span class="title">defaultMatcher</span> = [</span><br><span class="line">    (<span class="string">":load"</span>  , fileCompleter)</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Default tab completer</span></span><br><span class="line"><span class="title">comp</span> :: (<span class="type">Monad</span> m, <span class="type">MonadState</span> <span class="type">IState</span> m) =&gt; <span class="type">WordCompleter</span> m</span><br><span class="line"><span class="title">comp</span> n = <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">let</span> cmds = [<span class="string">":load"</span>, <span class="string">":browse"</span>, <span class="string">":quit"</span>, <span class="string">":type"</span>]</span><br><span class="line">  <span class="type">TypeEnv</span> ctx &lt;- gets tyctx</span><br><span class="line">  <span class="keyword">let</span> defs = <span class="type">Map</span>.keys ctx</span><br><span class="line">  return $ filter (isPrefixOf n) (cmds ++ defs)</span><br></pre></td></tr></table></figure></p>
<h3 id="Observations-æ„è§"><a href="#Observations-æ„è§" class="headerlink" title="Observations (æ„è§)"></a>Observations (æ„è§)</h3><p>æˆ‘ä»¬æœ‰å®ƒï¼Œæˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªå°å‹æ¨æ–­è¯­è¨€ï¼<br>é€šè¿‡è¿è¡Œ<code>ghci Main.hs</code>åŠ è½½<code>poly</code>è§£é‡Šå™¨å¹¶è°ƒç”¨<code>main</code>å‡½æ•°ã€‚<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ghci <span class="type">Main</span>.hs</span><br><span class="line">Î»: main</span><br><span class="line"><span class="type">Poly</span>&gt; :load test.ml</span><br><span class="line"><span class="type">Poly</span>&gt; :browse</span><br></pre></td></tr></table></figure></p>
<p>é€šè¿‡åœ¨ç¨‹åºçš„<code>toplevel</code>å£°æ˜ä¸€äº›å‡½æ•°æ¥å°è¯•ä¸€äº›ç®€å•çš„ä¾‹å­ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨<code>:type</code>å‘½ä»¤ä»¥äº¤äº’æ–¹å¼æŸ¥è¯¢è¡¨è¾¾å¼çš„ç±»å‹ï¼Œè¯¥å‘½ä»¤å®é™…ä¸Šåªæ˜¯åœ¨ç®¡é“ä¸­é€”è¿è¡Œè¡¨è¾¾å¼å¹¶åœ¨ç±»å‹æ£€æŸ¥ååœæ­¢ã€‚<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Poly</span>&gt; <span class="keyword">let</span> id x = x</span><br><span class="line"><span class="type">Poly</span>&gt; <span class="keyword">let</span> const x y = x</span><br><span class="line"><span class="type">Poly</span>&gt; <span class="keyword">let</span> twice x = x + x</span><br><span class="line"></span><br><span class="line"><span class="type">Poly</span>&gt; :<span class="class"><span class="keyword">type</span> id</span></span><br><span class="line"><span class="title">id</span> : <span class="keyword">forall</span> a. a -&gt; a</span><br><span class="line"></span><br><span class="line"><span class="type">Poly</span>&gt; :<span class="class"><span class="keyword">type</span> const</span></span><br><span class="line"><span class="title">const</span> : <span class="keyword">forall</span> a b. a -&gt; b -&gt; a</span><br><span class="line"></span><br><span class="line"><span class="type">Poly</span>&gt; :<span class="class"><span class="keyword">type</span> twice</span></span><br><span class="line"><span class="title">twice</span> : <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure></p>
<p>æ³¨æ„å‡ ä¸ªé‡è¦çš„äº‹å®ã€‚<br>æˆ‘ä»¬çš„ç±»å‹æ£€æŸ¥å™¨ç°åœ¨å°†åœ¨è§£é‡Šä¹‹å‰å°†æˆ‘ä»¬çš„æ‹’ç»ç¨‹åºä¸èŒƒå›´é”™è¯¯ç›¸å…³è”ã€‚<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Poly</span>&gt; \x -&gt; y</span><br><span class="line"><span class="type">Not</span> <span class="keyword">in</span> scope: <span class="string">"y"</span></span><br></pre></td></tr></table></figure></p>
<p>æ­¤å¤–ï¼Œé‚£äº›ç±»å‹ä¸å¤ªå¥½çš„ç¨‹åºç°åœ¨ä¹Ÿä¼šè¢«ç›´æ¥æ‹’ç».<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Poly</span>&gt; <span class="number">1</span> + <span class="type">True</span></span><br><span class="line"><span class="type">Cannot</span> unify types: </span><br><span class="line">    <span class="type">Bool</span></span><br><span class="line"><span class="title">with</span> </span><br><span class="line">    <span class="type">Int</span></span><br></pre></td></tr></table></figure></p>
<p><code>omega</code>ç»„åˆå­å°†æ— æ³•é€šè¿‡<code>occurs</code>æ£€æŸ¥:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Poly</span>&gt; \x -&gt; x x</span><br><span class="line"><span class="type">Cannot</span> construct the the infinite <span class="class"><span class="keyword">type</span>: a = a -&gt; b</span></span><br></pre></td></tr></table></figure></p>
<p><code>test.ml</code>æ–‡ä»¶æä¾›äº†å¯¹å°è§£é‡Šå™¨çš„å„ç§æµ‹è¯•. ä¾‹å¦‚,<code>fact</code>å’Œ<code>fib</code>å‡½æ•°éƒ½ä½¿ç”¨<code>fixpoint</code>æ¥è®¡ç®—<code>Fibonacci</code>æ•°æˆ–é˜¶ä¹˜ã€‚<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> fact = fix (\fact -&gt; \n -&gt; </span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">then</span> <span class="number">1</span> </span><br><span class="line">    <span class="keyword">else</span> (n * (fact (n<span class="number">-1</span>))));</span><br><span class="line"></span><br><span class="line"><span class="title">let</span> <span class="keyword">rec</span> fib n = </span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">then</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n==<span class="number">1</span>) </span><br><span class="line">      <span class="keyword">then</span> <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span> ((fib (n<span class="number">-1</span>)) + (fib (n<span class="number">-2</span>)));</span><br><span class="line"><span class="type">Poly</span>&gt; :<span class="class"><span class="keyword">type</span> fact</span></span><br><span class="line"><span class="title">fact</span> : <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="type">Poly</span>&gt; fact <span class="number">5</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"></span><br><span class="line"><span class="type">Poly</span>&gt; fib <span class="number">16</span></span><br><span class="line"><span class="number">610</span></span><br></pre></td></tr></table></figure></p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">èµèµ</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> thank you </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
        <span><a href="https://serokell.io/blog">serokell</a></span>
        <span>/</span>
        
        <span><a href="https://iohk.io/en/blog">IOHK</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/blog/js/index.js"></script>

<!--create by tea9-->

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <script>
        var gitalk = new Gitalk({
          clientID: '7cfc73dd62b57f07ed83',
          clientSecret: 'dd03b7e54aadf0d81e4c9c93e23a41272bcfcfa1',
          repo: 'blog',
          owner: 'limengyu1990',
          admin: 'limengyu1990',
          id: location.pathname,      // Ensure uniqueness and length less than 50
          distractionFreeMode: false  // Facebook-like distraction free mode
        })
        gitalk.render('comment-container')
    </script>

<!--end-->


</html>
