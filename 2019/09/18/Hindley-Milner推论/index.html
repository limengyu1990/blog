<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        Hindley-Milner推论 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>不负如来不负卿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#HM类型系统"><span class="toc-text">HM类型系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#语法"><span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态性"><span class="toc-text">多态性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型"><span class="toc-text">类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#上下文"><span class="toc-text">上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Inference-Monad-推理"><span class="toc-text">Inference Monad(推理)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Substitution-替换"><span class="toc-text">Substitution(替换)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unification-统一"><span class="toc-text">Unification(统一)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generalization-and-Instantiation-泛化和实例化"><span class="toc-text">Generalization and Instantiation (泛化和实例化)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Typing-Rules-类型规则"><span class="toc-text">Typing Rules (类型规则)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#T-Var"><span class="toc-text">T-Var</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#T-Lam"><span class="toc-text">T-Lam</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#T-App"><span class="toc-text">T-App</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#T-Let"><span class="toc-text">T-Let</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#T-BinOp"><span class="toc-text">T-BinOp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Literals"><span class="toc-text">Literals</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constraint-Generation-约束生成"><span class="toc-text">Constraint Generation (约束生成)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Typing"><span class="toc-text">Typing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constraint-Solver-约束解决器"><span class="toc-text">Constraint Solver (约束解决器)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Worked-Examples"><span class="toc-text">Worked Examples</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#例子1"><span class="toc-text">例子1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例子2"><span class="toc-text">例子2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interpreter"><span class="toc-text">Interpreter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interactive-Shell"><span class="toc-text">Interactive Shell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Observations-意见"><span class="toc-text">Observations (意见)</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Hindley-Milner推论
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-09-18 20:48:49</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/blog/tags/#Write-Haskell" title="Write-Haskell">Write-Haskell</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#HM" title="HM">HM</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#类型系統" title="类型系統">类型系統</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p><a href="http://dev.stephendiehl.com/fun/006_hindley_milner.html" target="_blank" rel="noopener">原文</a></p>
</blockquote>
<h3 id="HM类型系统"><a href="#HM类型系统" class="headerlink" title="HM类型系统"></a>HM类型系统</h3><p>辛德雷-米尔纳类型系统(也称为<code>Damas-Hindley-Milner</code>或<code>HM</code>)是一组类型系统,它们承认有一个可处理的算法可以从非类型化语法确定类型,这是一个偶然的特性。<br>这是通过一个称为<code>unification</code>(统一)的过程来实现的,在这个过程中,一个结构良好的程序的类型会产生一组约束,当解决这些约束时,总是有一个惟一的主体类型。</p>
<p>最简单的<code>Hindley Milner</code>类型系统由一组非常短的规则定义。<br>前四个规则描述了我们可以如何判断将每个句法结构(<code>Lam</code>，<code>App</code>，<code>Var</code>，<code>Let</code>)映射到它们的预期类型,我们很快就会详细阐述这些规则。<br><img src="img/HM0.png" alt=""><br>米尔纳的观察是,因为类型规则映射到唯一的语法,我们实际上可以向后运行类型规则,每当我们没有子表达式的已知类型时,我们通过在其位置放置一个新变量,<br>收集关于其后续类型判断引起的使用限制来进行”猜测”.<br>这是ML族语言中类型推断的本质,通过生成和解决一种统一(<code>unification</code>)问题,我们可以从语法中唯一地重构类型,算法本身很大程度上只是统一求解器的结构化使用.<br>然而,完整的类型推断使我们有点束缚,因为虽然推理问题在这种简单的语言和简单的扩展中是易处理的,但几乎所有对语言的重要补充都会破坏在没有注释的情况下推断类型的能力,<br>或者使推理算法严重复杂化.然而,<code>Hindley-Milner</code>家族在设计领域代表了一个非常有用,富有成效的”甜蜜点”.</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>我们的第一种类型推断语言的语法实际上将是我们的无类型<code>lambda</code>演算的扩展,包括<code>fixpoint</code>运算符,<code>booleans</code>,<code>integers</code>,<code>let</code>和一些基本的算术运算.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Name</span> = <span class="type">String</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span></span></span><br><span class="line">  = <span class="type">Var</span> <span class="type">Name</span></span><br><span class="line">  | <span class="type">App</span> <span class="type">Expr</span> <span class="type">Expr</span></span><br><span class="line">  | <span class="type">Lam</span> <span class="type">Name</span> <span class="type">Expr</span></span><br><span class="line">  | <span class="type">Let</span> <span class="type">Name</span> <span class="type">Expr</span> <span class="type">Expr</span></span><br><span class="line">  | <span class="type">Lit</span> <span class="type">Lit</span></span><br><span class="line">  | <span class="type">If</span> <span class="type">Expr</span> <span class="type">Expr</span> <span class="type">Expr</span></span><br><span class="line">  | <span class="type">Fix</span> <span class="type">Expr</span></span><br><span class="line">  | <span class="type">Op</span> <span class="type">Binop</span> <span class="type">Expr</span> <span class="type">Expr</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>, <span class="type">Ord</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Lit</span></span></span><br><span class="line">  = <span class="type">LInt</span> <span class="type">Integer</span></span><br><span class="line">  | <span class="type">LBool</span> <span class="type">Bool</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>, <span class="type">Ord</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Binop</span> = <span class="type">Add</span> | <span class="type">Sub</span> | <span class="type">Mul</span> | <span class="type">Eql</span></span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Program</span> = <span class="type">Program</span> [<span class="type">Decl</span>] <span class="type">Expr</span> <span class="keyword">deriving</span> <span class="type">Eq</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Decl</span> = (<span class="type">String</span>, <span class="type">Expr</span>)</span></span><br></pre></td></tr></table></figure></p>
<p><code>parser</code>是微不足道的,唯一的补充是<code>toplevel</code> <code>let</code>声明(<code>Decl</code>),它们被加入到全局程序中,<br>所有顶级声明都必须以分号结束,尽管它们可以跨越多行并且忽略空格.例如:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SKI combinators</span></span><br><span class="line"><span class="title">let</span> <span class="type">I</span> x = x;</span><br><span class="line"><span class="title">let</span> <span class="type">K</span> x y = x;</span><br><span class="line"><span class="title">let</span> <span class="type">S</span> f g x = f x (g x);</span><br></pre></td></tr></table></figure></p>
<p>和之前一样,<code>let rec</code>表达式将根据<code>fixpoint</code>运算符展开,只是语法糖.</p>
<h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>我们将向我们的语言添加一个额外的构造,它将允许我们的语言具有一种新的多态性形式.<br>多态性是一个术语的属性,它允许同一函数实现同时使用几种不同的类型.<br>例如,<code>identity</code>函数的多态签名实例映射一个<code>α</code>类型的输入:</p>
<p><img src="img/HM01.png" alt=""><br>现在不必为每种可能的类型重复函数(即实现<code>idInt</code>,<code>idBool</code>…)<br>我们的类型系统允许包含在多态类型签名中的任何实例.<br><img src="img/HM02.png" alt=""><br>普遍量化的一个相当显著的事实是,关于一类的<code>inhabitants</code>(類型的實例的統稱)的许多属性是由构造保证的,这些就是所谓的<code>free</code>定理.<br>例如,任何<code>(a, b) -&gt; a</code>类型的(<code>nonpathological</code>)实现必须等同于<code>fst</code>.<br>一个稍微不那么简单的例子是<code>fmap</code>函数的类型<code>Functor f =&gt;（a -&gt; b）-&gt; f a -&gt; f b</code><br>第二个<code>functor</code>法律要求:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">forall</span> f g. fmap f . fmap g = fmap (f . g)</span><br></pre></td></tr></table></figure></p>
<p>但是,我们不可能为<code>fmap</code>编写一个(<code>nonpathological</code>)函数,该函数具有所需的类型,但没有此属性.我们得到<code>free</code>定理!</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>我们将使用的类型语言从用于类型化<code>lambda</code>演算的简单类型系统开始.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">TVar</span> = <span class="type">TV</span> <span class="type">String</span></span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>, <span class="type">Ord</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Type</span></span></span><br><span class="line">  = <span class="type">TVar</span> <span class="type">TVar</span></span><br><span class="line">  | <span class="type">TCon</span> <span class="type">String</span></span><br><span class="line">  | <span class="type">TArr</span> <span class="type">Type</span> <span class="type">Type</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>, <span class="type">Ord</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">typeInt</span>, typeBool :: <span class="type">Type</span></span><br><span class="line"><span class="title">typeInt</span>  = <span class="type">TCon</span> <span class="string">"Int"</span></span><br><span class="line"><span class="title">typeBool</span> = <span class="type">TCon</span> <span class="string">"Bool"</span></span><br></pre></td></tr></table></figure></p>
<p><code>Type schemes`</code>model polymorphic types`(样板多态类型)，它们表示量词中绑定的类型变量在封闭的类型中是多态的，可以用与签名一致的任何类型实例化。直观地说明了该函数的实现:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Scheme</span> = <span class="type">Forall</span> [<span class="type">TVar</span>] <span class="type">Type</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>Type schemes</code>(类型模式)将在我们的输入规则中写为<code>σ</code>.<br><img src="img/HM03.png" alt=""><br>例如:<code>id</code>和<code>const</code>函数将会有以下类型:<br><img src="img/HM04.png" alt=""><br>我们现在将我们的类型划分为两个句法类别,单型和多型.<br>在我们简单的初始语言中,<code>type schemes</code>(类型模式)将始终是<code>top level</code>(顶级)签名的表示,即使没有多态类型变量.<br>在实现术语中,这意味着在推断后从我们的<code>Infer monad</code>中产生单型时,<br><code>we will immediately generalize it at the toplevel &quot;closing over&quot; all free type variables in a type scheme.</code><br>(我们将立即在类型模式的顶层”关闭所有”自由类型变量中归纳它)</p>
<h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">TypeEnv</span> = <span class="type">TypeEnv</span> (<span class="type">Map</span>.<span class="type">Map</span> <span class="type">Var</span> <span class="type">Scheme</span>)</span></span><br></pre></td></tr></table></figure>
<p>两个主要操作是扩展和限定,它从上下文中引入或删除命名数量.<br><img src="img/HM05.png" alt=""><br>对上下文的操作只是对底层<code>map</code>上的常用<code>Set</code>操作.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">extend</span> :: <span class="type">TypeEnv</span> -&gt; (<span class="type">Var</span>, <span class="type">Scheme</span>) -&gt; <span class="type">TypeEnv</span></span><br><span class="line"><span class="title">extend</span> (<span class="type">TypeEnv</span> env) (x, s) = <span class="type">TypeEnv</span> $ <span class="type">Map</span>.insert x s env</span><br></pre></td></tr></table></figure></p>
<h3 id="Inference-Monad-推理"><a href="#Inference-Monad-推理" class="headerlink" title="Inference Monad(推理)"></a>Inference Monad(推理)</h3><p>我们所有的类型推断逻辑都将存在于<code>Infer monad</code>中,它是<code>ExcpetT</code>+<code>State</code>的<code>monad</code>变换器堆栈.允许各种错误报告并有状态地保存新名称.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Infer</span> a = <span class="type">ExceptT</span> <span class="type">TypeError</span> (<span class="type">State</span> <span class="type">Unique</span>) a</span></span><br></pre></td></tr></table></figure></p>
<p>在<code>monad</code>中运行逻辑会导致类型错误或结果类型模式.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">runInfer</span> :: <span class="type">Infer</span> (<span class="type">Subst</span>, <span class="type">Type</span>) -&gt; <span class="type">Either</span> <span class="type">TypeError</span> <span class="type">Scheme</span></span><br><span class="line"><span class="title">runInfer</span> m = <span class="keyword">case</span> evalState (runExceptT m) initUnique <span class="keyword">of</span></span><br><span class="line">  <span class="type">Left</span> err  -&gt; <span class="type">Left</span> err</span><br><span class="line">  <span class="type">Right</span> res -&gt; <span class="type">Right</span> $ closeOver res</span><br></pre></td></tr></table></figure></p>
<h3 id="Substitution-替换"><a href="#Substitution-替换" class="headerlink" title="Substitution(替换)"></a>Substitution(替换)</h3><p>查询表达式的自由变量和对表达式应用替换,这两个操作将执行相当多的操作.<br><img src="img/HM06.png" alt=""><br>相同的模式适用于类型级别的类型变量.<br><img src="img/HM07.png" alt=""><br>表达式上的替换将替换应用于局部变量，如果匹配，则替换指定的子表达式。在名称捕获的情况下，将引入一个新的变量。<br><img src="img/HM08.png" alt=""><br>同样，替换也可以应用于类型环境之上的元素。<br><img src="img/HM09.png" alt=""><br>我们在<code>Haskell</code>中的替换实现只是从类型变量到类型的<code>Map</code>.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Subst</span> = <span class="type">Map</span>.<span class="type">Map</span> <span class="type">TVar</span> <span class="type">Type</span></span></span><br></pre></td></tr></table></figure></p>
<p>替换的组合(<code>s1 ∘ s2</code>, <code>s1 compose s2</code>)可以简单地编码为基础<code>Map</code>上的操作,重要的是要注意,在我们的实现中,我们选择了替换为<code>left-biased</code>,取决于推理算法的实现,以确保在替换之间不发生冲突.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">nullSubst</span> :: <span class="type">Subst</span></span><br><span class="line"><span class="title">nullSubst</span> = <span class="type">Map</span>.empty</span><br><span class="line"></span><br><span class="line"><span class="title">compose</span> :: <span class="type">Subst</span> -&gt; <span class="type">Subst</span> -&gt; <span class="type">Subst</span></span><br><span class="line"><span class="title">s1</span> `compose` s2 = <span class="type">Map</span>.map (apply s1) s2 `<span class="type">Map</span>.union` s1</span><br></pre></td></tr></table></figure></p>
<p><code>Haskell</code>中的实现是通过<code>Substitutable</code>类型类的一系列实现来公开一个<code>apply</code>函数,该函数应用在 指定类型变量的 类型结构上 给出的替换.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Substitutable</span> a <span class="keyword">where</span></span></span><br><span class="line">  apply :: <span class="type">Subst</span> -&gt; a -&gt; a</span><br><span class="line">  ftv   :: a -&gt; <span class="type">Set</span>.<span class="type">Set</span> <span class="type">TVar</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Substitutable</span> <span class="type">Type</span> <span class="keyword">where</span></span></span><br><span class="line">  apply _ (<span class="type">TCon</span> a)       = <span class="type">TCon</span> a</span><br><span class="line">  apply s t@(<span class="type">TVar</span> a)     = <span class="type">Map</span>.findWithDefault t a s</span><br><span class="line">  apply s (t1 `<span class="type">TArr</span>` t2) = apply s t1 `<span class="type">TArr</span>` apply s t2</span><br><span class="line"></span><br><span class="line">  ftv <span class="type">TCon</span>&#123;&#125;         = <span class="type">Set</span>.empty</span><br><span class="line">  ftv (<span class="type">TVar</span> a)       = <span class="type">Set</span>.singleton a</span><br><span class="line">  ftv (t1 `<span class="type">TArr</span>` t2) = ftv t1 `<span class="type">Set</span>.union` ftv t2</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Substitutable</span> <span class="type">Scheme</span> <span class="keyword">where</span></span></span><br><span class="line">  apply s (<span class="type">Forall</span> <span class="keyword">as</span> t)   = <span class="type">Forall</span> <span class="keyword">as</span> $ apply s' t</span><br><span class="line">                            <span class="keyword">where</span> s' = foldr <span class="type">Map</span>.delete s <span class="keyword">as</span></span><br><span class="line">  ftv (<span class="type">Forall</span> <span class="keyword">as</span> t) = ftv t `<span class="type">Set</span>.difference` <span class="type">Set</span>.fromList <span class="keyword">as</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Substitutable</span> a =&gt; <span class="type">Substitutable</span> [a] <span class="keyword">where</span></span></span><br><span class="line">  apply = fmap . apply</span><br><span class="line">  ftv   = foldr (<span class="type">Set</span>.union . ftv) <span class="type">Set</span>.empty</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Substitutable</span> <span class="type">TypeEnv</span> <span class="keyword">where</span></span></span><br><span class="line">  apply s (<span class="type">TypeEnv</span> env) =  <span class="type">TypeEnv</span> $ <span class="type">Map</span>.map (apply s) env</span><br><span class="line">  ftv (<span class="type">TypeEnv</span> env) = ftv $ <span class="type">Map</span>.elems env</span><br></pre></td></tr></table></figure></p>
<p>在整个类型规则和替换中,我们需要新的名称.在这个天真的版本中,我们将简单地使用无限的字符串列表,并按照我们在<code>状态monad</code>中保存的索引切入列表的第<code>n</code>个元素,这是最简单的实现,稍后我们将使这种名称生成技术更加健壮.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">letters</span> :: [<span class="type">String</span>]</span><br><span class="line"><span class="title">letters</span> = [<span class="number">1.</span>.] &gt;&gt;= flip replicateM ['a'..'z']</span><br><span class="line"></span><br><span class="line"><span class="title">fresh</span> :: <span class="type">Infer</span> <span class="type">Type</span></span><br><span class="line"><span class="title">fresh</span> = <span class="keyword">do</span></span><br><span class="line">  s &lt;- get</span><br><span class="line">  put s&#123;count = count s + <span class="number">1</span>&#125;</span><br><span class="line">  return $ <span class="type">TVar</span> $ <span class="type">TV</span> (letters !! count s)</span><br></pre></td></tr></table></figure></p>
<p>创建新变量对于实施推理规则至关重要。 每当我们在某个表达式中遇到第一次使用变量时，我们将创建一个新的类型变量。</p>
<h3 id="Unification-统一"><a href="#Unification-统一" class="headerlink" title="Unification(统一)"></a>Unification(统一)</h3><p>推理思想的核心是统一的概念,两个表达式<code>e1</code>和<code>e2</code>的统一符是替换<code>s</code>,使得:<br><img src="img/HM10.png" alt=""><br>如果在它们之间存在统一的替换集合，则认为两个术语是统一的。 如果替换的应用与所应用的顺序无关，即如果我们总是以相同的正常形式到达而不管所选择的替换顺序如何，则称替换集是汇合的。<br>我们将采用这种表示法:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">τ ∼ τ′:s</span><br></pre></td></tr></table></figure></p>
<p>事实上<code>τ,τ&#39;</code>这两种类型是可以通过一个替换<code>s</code>进行统一的,这样:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[s]τ = [s]τ′</span><br></pre></td></tr></table></figure></p>
<p>两个相同的项可以用空的统一器轻松地统一:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">c</span> ∼ c : [ ]</span><br></pre></td></tr></table></figure></p>
<p>我们的小HM语言的统一规则如下:<br><img src="img/HM11.png" alt=""><br>如果我们想要将类型变量<code>α</code>与类型<code>τ</code>统一起来,我们通常可以用类型替换变量: <code>[α/τ]</code>.但是,我们的规则规定了一个前提条件,称为该统一的发生检查: 类型变量<code>α</code>不得在<code>τ</code>中自由出现.如果确实如此.则替换将不是统一.<br>例如,统一<code>α</code>和<code>α → β</code>的问题.<br>替换<code>s</code> = <code>[α/α → β]</code>不统一: 我们得到<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[s]α = α → β</span><br><span class="line"><span class="comment">-- 和</span></span><br><span class="line">[s]α → β = (α → β) → β</span><br></pre></td></tr></table></figure></p>
<p>实际上,无论我们尝试什么替代,<code>[s]α → β</code>总是比<code>[s]α</code>长,所以不存在统一者,唯一的机会是用无限类型替换: <code>[α/(...((α → β) → β)→ ⋯ → β) → β]</code>将是一个统一者，但我们的语言没有这样的类型。<br>如果由于发生检查(<code>occurs check</code>)而统一失败,我们说统一将给出无限类型。<br>请注意,如果我们尝试类型检查<code>omega</code>组合器<code>λx.xx</code>，那么统一<code>α → β</code>和<code>α</code>正是我们必须要做的,所以它被发生检查(<code>occurs check</code>)排除了，<br>正如我们在覆盖无类型<code>lambda</code>演算时所讨论的其他<code>pathological</code>术语一样.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">occursCheck</span> ::  <span class="type">Substitutable</span> a =&gt; <span class="type">TVar</span> -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">occursCheck</span> a t = a `<span class="type">Set</span>.member` ftv t</span><br></pre></td></tr></table></figure></p>
<p><code>unify</code>函数存在于<code>Infer monad</code>中并产生替换:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">unify</span> ::  <span class="type">Type</span> -&gt; <span class="type">Type</span> -&gt; <span class="type">Infer</span> <span class="type">Subst</span></span><br><span class="line"><span class="title">unify</span> (l `<span class="type">TArr</span>` r) (l' `<span class="type">TArr</span>` r')  = <span class="keyword">do</span></span><br><span class="line">    s1 &lt;- unify l l'</span><br><span class="line">    s2 &lt;- unify (apply s1 r) (apply s1 r')</span><br><span class="line">    return (s2 `compose` s1)</span><br><span class="line"></span><br><span class="line"><span class="title">unify</span> (<span class="type">TVar</span> a) t = bind a t</span><br><span class="line"><span class="title">unify</span> t (<span class="type">TVar</span> a) = bind a t</span><br><span class="line"><span class="title">unify</span> (<span class="type">TCon</span> a) (<span class="type">TCon</span> b) | a == b = return nullSubst</span><br><span class="line"><span class="title">unify</span> t1 t2 = throwError $ <span class="type">UnificationFail</span> t1 t2</span><br><span class="line"></span><br><span class="line"><span class="title">bind</span> ::  <span class="type">TVar</span> -&gt; <span class="type">Type</span> -&gt; <span class="type">Infer</span> <span class="type">Subst</span></span><br><span class="line"><span class="title">bind</span> a t | t == <span class="type">TVar</span> a     = return nullSubst</span><br><span class="line">         | occursCheck a t = throwError $ <span class="type">InfiniteType</span> a t</span><br><span class="line">         | otherwise       = return $ <span class="type">Map</span>.singleton a t</span><br></pre></td></tr></table></figure></p>
<h3 id="Generalization-and-Instantiation-泛化和实例化"><a href="#Generalization-and-Instantiation-泛化和实例化" class="headerlink" title="Generalization and Instantiation (泛化和实例化)"></a>Generalization and Instantiation (泛化和实例化)</h3><p><code>Hindley-Milner</code>的核心是两个基本操作:<br><code>Generalization</code>泛化: 通过关闭类型方案中的所有自由类型变量,将<code>τ</code>类型转换为<code>σ</code>类型。<br><code>Instantiation</code>实例化: 通过为当前类型环境中未出现的每个类型变量创建新名称,将<code>σ</code>类型转换为<code>τ</code>类型。<br><img src="img/HM12.png" alt=""><br>(<code>T-Inst</code>)规则中的<code>⊑</code>运算符表示类型是类型模式(<code>type scheme</code>)的实例.<br><img src="img/HM13.png" alt=""><br><code>⊑</code>符号右边的类型<code>τ1</code>是左边类型模式(<code>σ = 左边</code>)的实例化,如果对于所有的<code>β ∈ 𝚏𝚝𝚟(σ)</code>存在一个替换<code>[s]β = β</code>,则<code>τ1 = [s]τ2</code>,看例子:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">∀a.a → a ⊑ 𝙸𝚗𝚝 → 𝙸𝚗𝚝</span><br><span class="line">∀a.a → a ⊑ b → b</span><br><span class="line">∀ab.a → b → a ⊑ 𝙸𝚗𝚝 → 𝙱𝚘𝚘𝚕 → 𝙸𝚗𝚝</span><br></pre></td></tr></table></figure>
<p>这些映射非常直观地映射到简单地操作<code>Haskell Set</code>变量对象和新名称供应的代码:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">instantiate</span> ::  <span class="type">Scheme</span> -&gt; <span class="type">Infer</span> <span class="type">Type</span></span><br><span class="line"><span class="title">instantiate</span> (<span class="type">Forall</span> <span class="keyword">as</span> t) = <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">as</span>' &lt;- mapM (const fresh) <span class="keyword">as</span></span><br><span class="line">  <span class="keyword">let</span> s = <span class="type">Map</span>.fromList $ zip <span class="keyword">as</span> <span class="keyword">as</span>'</span><br><span class="line">  return $ apply s t</span><br><span class="line"></span><br><span class="line"><span class="title">generalize</span> :: <span class="type">TypeEnv</span> -&gt; <span class="type">Type</span> -&gt; <span class="type">Scheme</span></span><br><span class="line"><span class="title">generalize</span> env t  = <span class="type">Forall</span> <span class="keyword">as</span> t</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">as</span> = <span class="type">Set</span>.toList $ ftv t `<span class="type">Set</span>.difference` ftv env</span><br></pre></td></tr></table></figure></p>
<p>按照约定,<code>let</code>绑定被尽可能地一般化(<code>generalized</code>).<br>因此,在下面的定义中,<code>f</code>在绑定的主体上进行了一般化,以便在每次调用<code>f</code>时,都用新的类型变量实例化它.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Poly</span>&gt; <span class="keyword">let</span> f = (\x -&gt; x) <span class="keyword">in</span> <span class="keyword">let</span> g = (f <span class="type">True</span>) <span class="keyword">in</span> f <span class="number">3</span></span><br><span class="line"><span class="number">3</span> : <span class="type">Int</span></span><br></pre></td></tr></table></figure></p>
<p>在这个表达式中,<code>f</code>的类型在<code>let</code>定义中生成,并将使用两个不同的签名实例化.<br>在f的调用位置,它将与<code>Int</code>相统一,另一个与<code>Bool</code>相统一。<br>相反,在<code>lambda</code>中绑定<code>f</code>将导致类型错误.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Poly</span>&gt; (\f -&gt; <span class="keyword">let</span> g = (f <span class="type">True</span>) <span class="keyword">in</span> (f <span class="number">3</span>)) (\x -&gt; x)</span><br><span class="line"><span class="type">Cannot</span> unify types: </span><br><span class="line">    <span class="type">Bool</span></span><br><span class="line"><span class="title">with</span> </span><br><span class="line">    <span class="type">Int</span></span><br></pre></td></tr></table></figure></p>
<p>这是<code>let generalization(一般化)</code>的本质.</p>
<h3 id="Typing-Rules-类型规则"><a href="#Typing-Rules-类型规则" class="headerlink" title="Typing Rules (类型规则)"></a>Typing Rules (类型规则)</h3><p>最后,在所有类型机制到位后,我们可以写下我们简单的小多态<code>lambda</code>演算的类型规则.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">infer</span> :: <span class="type">TypeEnv</span> -&gt; <span class="type">Expr</span> -&gt; <span class="type">Infer</span> (<span class="type">Subst</span>, <span class="type">Type</span>)</span><br></pre></td></tr></table></figure></p>
<p><code>infer</code>将局部类型环境和活动表达式映射到部分统一解决方案和中间类型的2元组.通过在每个部分推断的子表达式和局部环境中应用来自统一的部分替换,自下而上遍历<code>AST</code>并且在每个递归级别处求解约束,如果遇到错误,则会在<code>Infer monad</code>中调用<code>throwError</code>,并报告错误:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">infer</span> :: <span class="type">TypeEnv</span> -&gt; <span class="type">Expr</span> -&gt; <span class="type">Infer</span> (<span class="type">Subst</span>, <span class="type">Type</span>)</span><br><span class="line"><span class="title">infer</span> env ex = <span class="keyword">case</span> ex <span class="keyword">of</span></span><br><span class="line"></span><br><span class="line">  <span class="type">Var</span> x -&gt; lookupEnv env x</span><br><span class="line"></span><br><span class="line">  <span class="type">Lam</span> x e -&gt; <span class="keyword">do</span></span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    <span class="keyword">let</span> env' = env `extend` (x, <span class="type">Forall</span> [] tv)</span><br><span class="line">    (s1, t1) &lt;- infer env' e</span><br><span class="line">    return (s1, apply s1 tv `<span class="type">TArr</span>` t1)</span><br><span class="line"></span><br><span class="line">  <span class="type">App</span> e1 e2 -&gt; <span class="keyword">do</span></span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    (s1, t1) &lt;- infer env e1</span><br><span class="line">    (s2, t2) &lt;- infer (apply s1 env) e2</span><br><span class="line">    s3       &lt;- unify (apply s2 t1) (<span class="type">TArr</span> t2 tv)</span><br><span class="line">    return (s3 `compose` s2 `compose` s1, apply s3 tv)</span><br><span class="line"></span><br><span class="line">  <span class="type">Let</span> x e1 e2 -&gt; <span class="keyword">do</span></span><br><span class="line">    (s1, t1) &lt;- infer env e1</span><br><span class="line">    <span class="keyword">let</span> env' = apply s1 env</span><br><span class="line">        t'   = generalize env' t1</span><br><span class="line">    (s2, t2) &lt;- infer (env' `extend` (x, t')) e2</span><br><span class="line">    return (s1 `compose` s2, t2)</span><br><span class="line"></span><br><span class="line">  <span class="type">If</span> cond tr fl -&gt; <span class="keyword">do</span></span><br><span class="line">    (s1, t1) &lt;- infer env cond</span><br><span class="line">    (s2, t2) &lt;- infer env tr</span><br><span class="line">    (s3, t3) &lt;- infer env fl</span><br><span class="line">    s4 &lt;- unify t1 typeBool</span><br><span class="line">    s5 &lt;- unify t2 t3</span><br><span class="line">    return (s5 `compose` s4 `compose` s3 `compose` s2 `compose` s1, apply s5 t2)</span><br><span class="line"></span><br><span class="line">  <span class="type">Fix</span> e1 -&gt; <span class="keyword">do</span></span><br><span class="line">    (s1, t) &lt;- infer env e1</span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    s2 &lt;- unify (<span class="type">TArr</span> tv tv) t</span><br><span class="line">    return (s2, apply s1 tv)</span><br><span class="line"></span><br><span class="line">  <span class="type">Op</span> op e1 e2 -&gt; <span class="keyword">do</span></span><br><span class="line">    (s1, t1) &lt;- infer env e1</span><br><span class="line">    (s2, t2) &lt;- infer env e2</span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    s3 &lt;- unify (<span class="type">TArr</span> t1 (<span class="type">TArr</span> t2 tv)) (ops <span class="type">Map</span>.! op)</span><br><span class="line">    return (s1 `compose` s2 `compose` s3, apply s3 tv)</span><br><span class="line"></span><br><span class="line">  <span class="type">Lit</span> (<span class="type">LInt</span> _)  -&gt; return (nullSubst, typeInt)</span><br><span class="line">  <span class="type">Lit</span> (<span class="type">LBool</span> _) -&gt; return (nullSubst, typeBool)</span><br></pre></td></tr></table></figure></p>
<p>让我们浏览每个规则派生，看看它如何转换为代码:</p>
<h4 id="T-Var"><a href="#T-Var" class="headerlink" title="T-Var"></a>T-Var</h4><p>T-Var规则，只需从<code>typing</code>变换上下文中提取变量的类型即可.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Var</span> x -&gt; lookupEnv env x</span><br></pre></td></tr></table></figure></p>
<p>函数<code>lookupVar</code>在<code>typing</code>环境中查找局部变量引用,如果找到它,则实例化一个新副本.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lookupEnv</span> :: <span class="type">TypeEnv</span> -&gt; <span class="type">Var</span> -&gt; <span class="type">Infer</span> (<span class="type">Subst</span>, <span class="type">Type</span>)</span><br><span class="line"><span class="title">lookupEnv</span> (<span class="type">TypeEnv</span> env) x = <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Map</span>.lookup x env <span class="keyword">of</span></span><br><span class="line">    <span class="type">Nothing</span> -&gt; throwError $ <span class="type">UnboundVariable</span> (show x)</span><br><span class="line">    <span class="type">Just</span> s  -&gt; <span class="keyword">do</span> t &lt;- instantiate s</span><br><span class="line">                  return (nullSubst, t)</span><br></pre></td></tr></table></figure></p>
<p><img src="img/HM14.png" alt=""></p>
<h4 id="T-Lam"><a href="#T-Lam" class="headerlink" title="T-Lam"></a>T-Lam</h4><p>对于<code>lambdas</code>,由<code>lambda</code>绑定的变量本地作用于<code>typing</code>环境,然后使用此作用域推断表达式的主体.<br>输出类型是一个新类型变量,并与生成的推断类型统一.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lam</span> x e -&gt; <span class="keyword">do</span></span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    <span class="keyword">let</span> env' = env `extend` (x, <span class="type">Forall</span> [] tv)</span><br><span class="line">    (s1, t1) &lt;- infer env' e</span><br><span class="line">    return (s1, apply s1 tv `<span class="type">TArr</span>` t1)</span><br></pre></td></tr></table></figure></p>
<p><img src="img/HM15.png" alt=""></p>
<h4 id="T-App"><a href="#T-App" class="headerlink" title="T-App"></a>T-App</h4><p>对于应用程序,第一个参数必须是<code>lambda</code>表达式或返回<code>lambda</code>表达式,因此要知道它必须是<code>t1 -&gt; t2</code>的形式,但除了两个值的汇合外,不确定输出类型。<br>我们推断两种类型,<br>将第一个参数中的约束应用于第二推断类型的结果,然后使用整个应用程序表达式的例外形式(<code>excepted form</code>)统一这两个类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">App e1 e2 -&gt; do</span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    (s1, t1) &lt;- infer env e1</span><br><span class="line">    (s2, t2) &lt;- infer (apply s1 env) e2</span><br><span class="line">    s3       &lt;- unify (apply s2 t1) (TArr t2 tv)</span><br><span class="line">    return (s3 `compose` s2 `compose` s1, apply s3 tv)</span><br></pre></td></tr></table></figure></p>
<p><img src="img/HM16.png" alt=""></p>
<h4 id="T-Let"><a href="#T-Let" class="headerlink" title="T-Let"></a>T-Let</h4><p>如前所述,<code>let</code>将会<code>generalized</code>(一般化),因此我们将为<code>let</code>表达式的主体创建一个本地<code>typing</code>类型化环境,并添加一般化推断类型的<code>let</code>绑定值到主体的<code>typing</code>环境中.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Let</span> x e1 e2 -&gt; <span class="keyword">do</span></span><br><span class="line">   (s1, t1) &lt;- infer env e1</span><br><span class="line">   <span class="keyword">let</span> env' = apply s1 env</span><br><span class="line">       t'   = generalize env' t1</span><br><span class="line">   (s2, t2) &lt;- infer (env' `extend` (x, t')) e2</span><br><span class="line">   return (s1 `compose` s2, t2)</span><br></pre></td></tr></table></figure></p>
<p><img src="img/HM17.png" alt=""></p>
<h4 id="T-BinOp"><a href="#T-BinOp" class="headerlink" title="T-BinOp"></a>T-BinOp</h4><p>有几个内建操作,我们到目前为止还没有提到,因为类型规则很简单,我们只需统一这个操作的预设置类型签名.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Op</span> op e1 e2 -&gt; <span class="keyword">do</span></span><br><span class="line">    (s1, t1) &lt;- infer env e1</span><br><span class="line">    (s2, t2) &lt;- infer env e2</span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    s3 &lt;- unify (<span class="type">TArr</span> t1 (<span class="type">TArr</span> t2 tv)) (ops <span class="type">Map</span>.! op)</span><br><span class="line">    return (s1 `compose` s2 `compose` s3, apply s3 tv)</span><br><span class="line"></span><br><span class="line"><span class="title">ops</span> :: <span class="type">Map</span>.<span class="type">Map</span> <span class="type">Binop</span> <span class="type">Type</span></span><br><span class="line"><span class="title">ops</span> = <span class="type">Map</span>.fromList [</span><br><span class="line">      (<span class="type">Add</span>, (typeInt `<span class="type">TArr</span>` (typeInt `<span class="type">TArr</span>` typeInt)))</span><br><span class="line">    , (<span class="type">Mul</span>, (typeInt `<span class="type">TArr</span>` (typeInt `<span class="type">TArr</span>` typeInt)))</span><br><span class="line">    , (<span class="type">Sub</span>, (typeInt `<span class="type">TArr</span>` (typeInt `<span class="type">TArr</span>` typeInt)))</span><br><span class="line">    , (<span class="type">Eql</span>, (typeInt `<span class="type">TArr</span>` (typeInt `<span class="type">TArr</span>` typeBool)))</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p>
<h4 id="Literals"><a href="#Literals" class="headerlink" title="Literals"></a>Literals</h4><p><code>literal</code>整数和<code>boolean</code>类型的类型通常是它们各自的类型.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(+) :: 𝙸𝚗𝚝 → 𝙸𝚗𝚝 → 𝙸𝚗𝚝</span><br><span class="line">(×) :: 𝙸𝚗𝚝 → 𝙸𝚗𝚝 → 𝙸𝚗𝚝</span><br><span class="line">(−) :: 𝙸𝚗𝚝 → 𝙸𝚗𝚝 → 𝙸𝚗𝚝</span><br><span class="line">(=) :: 𝙸𝚗𝚝 → 𝙸𝚗𝚝 → 𝙱𝚘𝚘𝚕</span><br></pre></td></tr></table></figure></p>
<p><img src="img/HM18.png" alt=""></p>
<h3 id="Constraint-Generation-约束生成"><a href="#Constraint-Generation-约束生成" class="headerlink" title="Constraint Generation (约束生成)"></a>Constraint Generation (约束生成)</h3><p><code>Hindley Milner</code>的先前实现很简单,但具有混合两个独立过程的奇怪特性: <code>constraint solving</code>(约束求解器)和<code>traversal</code>(遍历).让我们讨论不执行此操作的推理算法的另一种实现.<br>在约束生成方法中,约束是通过自下而上遍历生成的,添加到有序容器中,规范化,求解,然后可能在类型化AST上进行后置替换.这将是我们将从这里使用的方法,<br>虽然与<code>on-line solver</code>之间存在等价,但使用单独的约束求解器变得更容易管理,因为我们的类型系统变得更复杂,我们开始构建语言.<br>现在我们的推理<code>monad</code>变成了<code>RWST</code>(<code>Reader-Writer-State</code>转换器)+<code>Either</code>(处理类型错误).推理状态保持不变,只是提供新鲜的名称.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- | Inference monad</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Infer</span> a = (<span class="type">RWST</span></span></span><br><span class="line"><span class="class">                  <span class="type">Env</span>             <span class="comment">-- Typing environment</span></span></span><br><span class="line"><span class="class">                  [<span class="type">Constraint</span>]    <span class="comment">-- Generated constraints</span></span></span><br><span class="line"><span class="class">                  <span class="type">InferState</span>      <span class="comment">-- Inference state</span></span></span><br><span class="line"><span class="class">                  (<span class="type">Except</span>         <span class="comment">-- Inference errors</span></span></span><br><span class="line"><span class="class">                    <span class="type">TypeError</span>)</span></span><br><span class="line">                  a)              <span class="comment">-- Result</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | Inference state</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">InferState</span> = <span class="type">InferState</span> &#123; <span class="title">count</span> :: <span class="type">Int</span> &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>我们将只收集<code>Writer</code>中的<code>unifier</code>并使用<code>uni</code>函数发出它们,而不是在每个遍历级别统一类型变量.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- | Unify two types</span></span><br><span class="line"><span class="title">uni</span> :: <span class="type">Type</span> -&gt; <span class="type">Type</span> -&gt; <span class="type">Infer</span> ()</span><br><span class="line"><span class="title">uni</span> t1 t2 = tell [(t1, t2)]</span><br></pre></td></tr></table></figure></p>
<p>由于<code>typing</code>输入环境存储在<code>Reader monad</code>中,我们可以使用<code>local</code>来为<code>typing</code>环境创建一个本地范围的附加组件.这对于<code>typing</code>绑定器很方便.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- | Extend type environment</span></span><br><span class="line"><span class="title">inEnv</span> :: (<span class="type">Name</span>, <span class="type">Scheme</span>) -&gt; <span class="type">Infer</span> a -&gt; <span class="type">Infer</span> a</span><br><span class="line"><span class="title">inEnv</span> (x, sc) m = <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">let</span> scope e = (remove e x) `extend` (x, sc)</span><br><span class="line">  local scope m</span><br></pre></td></tr></table></figure></p>
<h3 id="Typing"><a href="#Typing" class="headerlink" title="Typing"></a>Typing</h3><p>这些类型规则是相同的,只是现在我们可以用一种不需要线程处理太多状态的更少噪音的方式来编写它们.<br>所有的细节都被隐藏起来,并被编码在特定的组合器中,以一种让我们专注于领域逻辑的方式操纵我们的<code>Infer monad</code>的状态。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">infer</span> :: <span class="type">Expr</span> -&gt; <span class="type">Infer</span> <span class="type">Type</span></span><br><span class="line"><span class="title">infer</span> expr = <span class="keyword">case</span> expr <span class="keyword">of</span></span><br><span class="line">  <span class="type">Lit</span> (<span class="type">LInt</span> _)  -&gt; return $ typeInt</span><br><span class="line">  <span class="type">Lit</span> (<span class="type">LBool</span> _) -&gt; return $ typeBool</span><br><span class="line"></span><br><span class="line">  <span class="type">Var</span> x -&gt; lookupEnv x</span><br><span class="line"></span><br><span class="line">  <span class="type">Lam</span> x e -&gt; <span class="keyword">do</span></span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    t &lt;- inEnv (x, <span class="type">Forall</span> [] tv) (infer e)</span><br><span class="line">    return (tv `<span class="type">TArr</span>` t)</span><br><span class="line"></span><br><span class="line">  <span class="type">App</span> e1 e2 -&gt; <span class="keyword">do</span></span><br><span class="line">    t1 &lt;- infer e1</span><br><span class="line">    t2 &lt;- infer e2</span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    uni t1 (t2 `<span class="type">TArr</span>` tv)</span><br><span class="line">    return tv</span><br><span class="line"></span><br><span class="line">  <span class="type">Let</span> x e1 e2 -&gt; <span class="keyword">do</span></span><br><span class="line">    env &lt;- ask</span><br><span class="line">    t1 &lt;- infer e1</span><br><span class="line">    <span class="keyword">let</span> sc = generalize env t1</span><br><span class="line">    t2 &lt;- inEnv (x, sc) (infer e2)</span><br><span class="line">    return t2</span><br><span class="line"></span><br><span class="line">  <span class="type">Fix</span> e1 -&gt; <span class="keyword">do</span></span><br><span class="line">    t1 &lt;- infer e1</span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    uni (tv `<span class="type">TArr</span>` tv) t1</span><br><span class="line">    return tv</span><br><span class="line"></span><br><span class="line">  <span class="type">Op</span> op e1 e2 -&gt; <span class="keyword">do</span></span><br><span class="line">    t1 &lt;- infer e1</span><br><span class="line">    t2 &lt;- infer e2</span><br><span class="line">    tv &lt;- fresh</span><br><span class="line">    <span class="keyword">let</span> u1 = t1 `<span class="type">TArr</span>` (t2 `<span class="type">TArr</span>` tv)</span><br><span class="line">        u2 = ops <span class="type">Map</span>.! op</span><br><span class="line">    uni u1 u2</span><br><span class="line">    return tv</span><br><span class="line"></span><br><span class="line">  <span class="type">If</span> cond tr fl -&gt; <span class="keyword">do</span></span><br><span class="line">    t1 &lt;- infer cond</span><br><span class="line">    t2 &lt;- infer tr</span><br><span class="line">    t3 &lt;- infer fl</span><br><span class="line">    uni t1 typeBool</span><br><span class="line">    uni t2 t3</span><br><span class="line">    return t2</span><br></pre></td></tr></table></figure></p>
<h3 id="Constraint-Solver-约束解决器"><a href="#Constraint-Solver-约束解决器" class="headerlink" title="Constraint Solver (约束解决器)"></a>Constraint Solver (约束解决器)</h3><p><code>Infer monad</code>的<code>Writer</code>层包含从推理传递发出的生成的约束集.<br>一旦推断完成,我们就会得到一个结果类型签名,其中包含无意义的唯一新变量和一组约束,我们必须解决这些约束以将类型细化为其主要类型.<br>约束由一个单独的<code>Solve monad</code>解决,该<code>monad</code>包含<code>Unifier</code>(最常见的统一)解决方案,当应用于生成的签名时,它将产生解决方案.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Constraint</span> = (<span class="type">Type</span>, <span class="type">Type</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Unifier</span> = (<span class="type">Subst</span>, [<span class="type">Constraint</span>])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | Constraint solver monad</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Solve</span> a = <span class="type">StateT</span> <span class="type">Unifier</span> (<span class="type">ExceptT</span> <span class="type">TypeError</span> <span class="type">Identity</span>) a</span></span><br></pre></td></tr></table></figure></p>
<p>统一逻辑也与以前相同,除了它现在脱离推理独立编写,并将其部分状态存储在<code>Solve monad</code>的状态层内.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">unifies</span> :: <span class="type">Type</span> -&gt; <span class="type">Type</span> -&gt; <span class="type">Solve</span> <span class="type">Unifier</span></span><br><span class="line"><span class="title">unifies</span> t1 t2 | t1 == t2 = return emptyUnifer</span><br><span class="line"><span class="title">unifies</span> (<span class="type">TVar</span> v) t = v `bind` t</span><br><span class="line"><span class="title">unifies</span> t (<span class="type">TVar</span> v) = v `bind` t</span><br><span class="line"><span class="title">unifies</span> (<span class="type">TArr</span> t1 t2) (<span class="type">TArr</span> t3 t4) = unifyMany [t1, t2] [t3, t4]</span><br><span class="line"><span class="title">unifies</span> t1 t2 = throwError $ <span class="type">UnificationFail</span> t1 t2</span><br><span class="line"></span><br><span class="line"><span class="title">unifyMany</span> :: [<span class="type">Type</span>] -&gt; [<span class="type">Type</span>] -&gt; <span class="type">Solve</span> <span class="type">Unifier</span></span><br><span class="line"><span class="title">unifyMany</span> [] [] = return emptyUnifer</span><br><span class="line"><span class="title">unifyMany</span> (t1 : ts1) (t2 : ts2) =</span><br><span class="line">  <span class="keyword">do</span> (su1,cs1) &lt;- unifies t1 t2</span><br><span class="line">     (su2,cs2) &lt;- unifyMany (apply su1 ts1) (apply su1 ts2)</span><br><span class="line">     return (su2 `compose` su1, cs1 ++ cs2)</span><br><span class="line"><span class="title">unifyMany</span> t1 t2 = throwError $ <span class="type">UnificationMismatch</span> t1 t2</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The solver function simply iterates over the set of constraints, composing them and applying the resulting constraint solution over the intermediate solution eventually converting on the most general unifier which yields the final substitution which when applied over the inferred type signature, yields the principal type solution for the expression.</span><br></pre></td></tr></table></figure>
<p>求解器函数简单地迭代约束集,组合它们并将结果约束解决方案应用于中间解决方案,最终转换为最通用的统一,产生最终替换,当应用于推断类型签名时,为表达式产生主要类型解决方案.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Unification solver</span></span><br><span class="line"><span class="title">solver</span> :: <span class="type">Solve</span> <span class="type">Subst</span></span><br><span class="line"><span class="title">solver</span> = <span class="keyword">do</span></span><br><span class="line">  (su, cs) &lt;- get</span><br><span class="line">  <span class="keyword">case</span> cs <span class="keyword">of</span></span><br><span class="line">    [] -&gt; return su</span><br><span class="line">    ((t1, t2): cs0) -&gt; <span class="keyword">do</span></span><br><span class="line">      (su1, cs1)  &lt;- unifies t1 t2</span><br><span class="line">      put (su1 `compose` su, cs1 ++ (apply su1 cs0))</span><br><span class="line">      solver</span><br></pre></td></tr></table></figure>
<p>这是一个更加优雅的解决方案，而不是在同一个传递中混合推理和求解，并且很好地适应了我们将在后面的章节中讨论的类型化核心形式的生成。</p>
<h3 id="Worked-Examples"><a href="#Worked-Examples" class="headerlink" title="Worked Examples"></a>Worked Examples</h3><p>让我们来看两个推理如何适用于简单函数的例子.</p>
<h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h4><p>考虑:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x y z -&gt; x + y + z</span><br></pre></td></tr></table></figure></p>
<p><code>infer</code>函数生成的类型只包含每个参数和返回类型的新变量.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">a</span> -&gt; b -&gt; c -&gt; e</span><br></pre></td></tr></table></figure></p>
<p>当我们遍历两个加法运算时，发出由T-BinOp引起的约束.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> a -&gt; b -&gt; d ~ <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="number">2.</span> d -&gt; c -&gt; e ~ <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure></p>
<p>这里<code>d</code>是中间项<code>x + y</code>的类型.通过应用<code>Uni-Arrow</code>,我们可以推导出以下一组替换.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> a ~ <span class="type">Int</span></span><br><span class="line"><span class="number">2.</span> b ~ <span class="type">Int</span></span><br><span class="line"><span class="number">3.</span> c ~ <span class="type">Int</span></span><br><span class="line"><span class="number">4.</span> d ~ <span class="type">Int</span></span><br><span class="line"><span class="number">5.</span> e ~ <span class="type">Int</span></span><br></pre></td></tr></table></figure></p>
<p>将此解决方案替换回类型会产生推断类型:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure></p>
<h4 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">compose</span> f g x = f (g x)</span><br></pre></td></tr></table></figure>
<p>推断函数生成的类型仅包含唯一的新变量.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">a</span> -&gt; b -&gt; c -&gt; e</span><br></pre></td></tr></table></figure></p>
<p>由两个T-App规则引起的我们得到以下约束:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> b ~ c -&gt; d</span><br><span class="line"><span class="number">2.</span> a ~ d -&gt; e</span><br></pre></td></tr></table></figure></p>
<p>这里<code>d</code>是<code>(g x)</code>的类型,约束已经是规范形式,通过应用<code>Uni-VarLeft</code>两次,我们得到以下一组替换:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> b ~ c -&gt; d</span><br><span class="line"><span class="number">2.</span> a ~ d -&gt; e</span><br></pre></td></tr></table></figure></p>
<p>所以我们得到这种类型:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">compose</span> :: <span class="keyword">forall</span> c d e. (d -&gt; e) -&gt; (c -&gt; d) -&gt; c -&gt; e</span><br></pre></td></tr></table></figure></p>
<p>如果需要，我们可以按字母顺序重命名变量以获得:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">compose</span> :: <span class="keyword">forall</span> a b c. (a -&gt; b) -&gt; (c -&gt; a) -&gt; c -&gt; b</span><br></pre></td></tr></table></figure></p>
<h3 id="Interpreter"><a href="#Interpreter" class="headerlink" title="Interpreter"></a>Interpreter</h3><p>我们的求值程序将直接在语法上运行，并将结果计算为<code>Value</code>类型.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Value</span></span></span><br><span class="line">  = <span class="type">VInt</span> <span class="type">Integer</span></span><br><span class="line">  | <span class="type">VBool</span> <span class="type">Bool</span></span><br><span class="line">  | <span class="type">VClosure</span> <span class="type">String</span> <span class="type">Expr</span> <span class="type">TermEnv</span></span><br></pre></td></tr></table></figure></p>
<p>解释器设置为<code>Identity monad</code>,后面它将成为一个更复杂的<code>monad</code>,但现在它很简单.值(<code>value</code>)环境将显式地线程化,并且每当创建闭包时,我们只需在闭包中存储本地环境的副本.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">TermEnv</span> = <span class="type">Map</span>.<span class="type">Map</span> <span class="type">String</span> <span class="type">Value</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Interpreter</span> t = <span class="type">Identity</span> t</span></span><br></pre></td></tr></table></figure></p>
<p>我们的计算逻辑是上一章实现的lambda演算求值器的扩展.<br>然而，您可能会注意到在整个评估过程中使用了许多不完整的模式.<br>不过不要害怕,我们的程序评估不会”出错”.<br>这些模式中的每一个都代表了我们的类型系统保证永远不会发生的一种状态.<br>例如，如果我们的程序没有在作用域中引用每个变量,那么它将永远不会达到开始时的求值,并且将在类型检查器中被拒绝,我们在这里使用不完整的模式在道义上是正确的!<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">eval</span> :: <span class="type">TermEnv</span> -&gt; <span class="type">Expr</span> -&gt; <span class="type">Interpreter</span> <span class="type">Value</span></span><br><span class="line"><span class="title">eval</span> env expr = <span class="keyword">case</span> expr <span class="keyword">of</span></span><br><span class="line">  <span class="type">Lit</span> (<span class="type">LInt</span> k)  -&gt; return $ <span class="type">VInt</span> k</span><br><span class="line">  <span class="type">Lit</span> (<span class="type">LBool</span> k) -&gt; return $ <span class="type">VBool</span> k</span><br><span class="line"></span><br><span class="line">  <span class="type">Var</span> x -&gt; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">let</span> <span class="type">Just</span> v = <span class="type">Map</span>.lookup x env</span><br><span class="line">    return v</span><br><span class="line"></span><br><span class="line">  <span class="type">Op</span> op a b -&gt; <span class="keyword">do</span></span><br><span class="line">    <span class="type">VInt</span> a' &lt;- eval env a</span><br><span class="line">    <span class="type">VInt</span> b' &lt;- eval env b</span><br><span class="line">    return $ (binop op) a' b'</span><br><span class="line"></span><br><span class="line">  <span class="type">Lam</span> x body -&gt; </span><br><span class="line">    return (<span class="type">VClosure</span> x body env)</span><br><span class="line"></span><br><span class="line">  <span class="type">App</span> fun arg -&gt; <span class="keyword">do</span></span><br><span class="line">    <span class="type">VClosure</span> x body clo &lt;- eval env fun</span><br><span class="line">    argv &lt;- eval env arg</span><br><span class="line">    <span class="keyword">let</span> nenv = <span class="type">Map</span>.insert x argv clo</span><br><span class="line">    eval nenv body</span><br><span class="line"></span><br><span class="line">  <span class="type">Let</span> x e body -&gt; <span class="keyword">do</span></span><br><span class="line">    e' &lt;- eval env e</span><br><span class="line">    <span class="keyword">let</span> nenv = <span class="type">Map</span>.insert x e' env</span><br><span class="line">    eval nenv body</span><br><span class="line"></span><br><span class="line">  <span class="type">If</span> cond tr fl -&gt; <span class="keyword">do</span></span><br><span class="line">    <span class="type">VBool</span> br &lt;- eval env cond</span><br><span class="line">    <span class="keyword">if</span> br == <span class="type">True</span></span><br><span class="line">    <span class="keyword">then</span> eval env tr</span><br><span class="line">    <span class="keyword">else</span> eval env fl</span><br><span class="line"></span><br><span class="line">  <span class="type">Fix</span> e -&gt; <span class="keyword">do</span></span><br><span class="line">    eval env (<span class="type">App</span> e (<span class="type">Fix</span> e))</span><br><span class="line"></span><br><span class="line"><span class="title">binop</span> :: <span class="type">Binop</span> -&gt; <span class="type">Integer</span> -&gt; <span class="type">Integer</span> -&gt; <span class="type">Value</span></span><br><span class="line"><span class="title">binop</span> <span class="type">Add</span> a b = <span class="type">VInt</span> $ a + b</span><br><span class="line"><span class="title">binop</span> <span class="type">Mul</span> a b = <span class="type">VInt</span> $ a * b</span><br><span class="line"><span class="title">binop</span> <span class="type">Sub</span> a b = <span class="type">VInt</span> $ a - b</span><br><span class="line"><span class="title">binop</span> <span class="type">Eql</span> a b = <span class="type">VBool</span> $ a == b</span><br></pre></td></tr></table></figure></p>
<h3 id="Interactive-Shell"><a href="#Interactive-Shell" class="headerlink" title="Interactive Shell"></a>Interactive Shell</h3><p>我们的语言现在已经成长为我们之前使用过的小型<code>shell</code>,现在我们需要更强大的东西来保持我们的交互式解释器的逻辑.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">IState</span> = <span class="type">IState</span></span></span><br><span class="line">  &#123; tyctx :: <span class="type">TypeEnv</span>  <span class="comment">-- Type environment</span></span><br><span class="line">  , tmctx :: <span class="type">TermEnv</span>  <span class="comment">-- Value environment</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="title">initState</span> :: <span class="type">IState</span></span><br><span class="line"><span class="title">initState</span> = <span class="type">IState</span> emptyTyenv emptyTmenv</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Repl</span> a = <span class="type">HaskelineT</span> (<span class="type">StateT</span> <span class="type">IState</span> <span class="type">IO</span>) a</span></span><br><span class="line"></span><br><span class="line"><span class="title">hoistErr</span> :: <span class="type">Show</span> e =&gt; <span class="type">Either</span> e a -&gt; <span class="type">Repl</span> a</span><br><span class="line"><span class="title">hoistErr</span> (<span class="type">Right</span> val) = return val</span><br><span class="line"><span class="title">hoistErr</span> (<span class="type">Left</span> err) = <span class="keyword">do</span></span><br><span class="line">  liftIO $ print err</span><br><span class="line">  abort</span><br></pre></td></tr></table></figure></p>
<p>我们的语言可以由<code>GHC</code>编译成独立的二进制文件:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ghc <span class="comment">--make Main.hs -o poly</span></span><br><span class="line">$ ./poly</span><br><span class="line"><span class="type">Poly</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>在我们程序的顶部，我们将查看命令选项并允许三种命令变体:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ poly                # launch shell</span><br><span class="line">$ poly input.ml       # launch shell with 'input.ml' loaded</span><br><span class="line">$ poly test input.ml  # dump test for 'input.ml' to stdout</span><br></pre></td></tr></table></figure></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  args &lt;- getArgs</span><br><span class="line">  <span class="keyword">case</span> args <span class="keyword">of</span></span><br><span class="line">    []      -&gt; shell (return ())</span><br><span class="line">    [fname] -&gt; shell (load [fname])</span><br><span class="line">    [<span class="string">"test"</span>, fname] -&gt; shell (load [fname] &gt;&gt; browse [] &gt;&gt; quit ())</span><br><span class="line">    _ -&gt; putStrLn <span class="string">"invalid arguments"</span></span><br></pre></td></tr></table></figure>
<p><code>shell</code>命令需要一个<code>pre</code>动作,该动作在<code>shell</code>启动之前运行,逻辑简单地将我们的<code>Repl monad</code>评估为<code>IO</code>并从<code>main</code>函数运行它.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">shell</span> :: <span class="type">Repl</span> a -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">shell</span> pre</span><br><span class="line">  = flip evalStateT initState</span><br><span class="line">  $ evalRepl <span class="string">"Poly&gt; "</span> cmd options completer pre</span><br></pre></td></tr></table></figure></p>
<p><code>cmd</code>驱动程序是我们程序的主要入口点,每次用户输入一行输入时都会执行它,第一个参数是用户输入行.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">cmd</span> :: <span class="type">String</span> -&gt; <span class="type">Repl</span> ()</span><br><span class="line"><span class="title">cmd</span> source = exec <span class="type">True</span> (<span class="type">L</span>.pack source)</span><br></pre></td></tr></table></figure></p>
<p>然后，我们的语言的核心是<code>exec</code>函数，它导入所有编译器传递的信息，然后按顺序线程化输入和输出，最终生成一个结果类型环境和程序的评估结果。它们被<code>monoidally</code>连接到解释器的状态中，然后循环产生下一组输入.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">exec</span> :: <span class="type">Bool</span> -&gt; <span class="type">L</span>.<span class="type">Text</span> -&gt; <span class="type">Repl</span> ()</span><br><span class="line"><span class="title">exec</span> update source = <span class="keyword">do</span></span><br><span class="line">  <span class="comment">-- Get the current interpreter state</span></span><br><span class="line">  st &lt;- get</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Parser ( returns AST )</span></span><br><span class="line">  mod &lt;- hoistErr $ parseModule <span class="string">"&lt;stdin&gt;"</span> source</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Type Inference ( returns Typing Environment )</span></span><br><span class="line">  tyctx' &lt;- hoistErr $ inferTop (tyctx st) mod</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Create the new environment</span></span><br><span class="line">  <span class="keyword">let</span> st' = st &#123; tmctx = foldl' evalDef (tmctx st) mod</span><br><span class="line">               , tyctx = tyctx' &lt;&gt; (tyctx st)</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Update the interpreter state</span></span><br><span class="line">  when update (put st')</span><br></pre></td></tr></table></figure></p>
<p><code>Repline</code>还支持添加特定的套接字输入集，以便将它们映射到编译器中的内置命令。我们将实现其中三个。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Command</span>	<span class="type">Action</span></span><br><span class="line">:browse		<span class="type">Browse</span> the <span class="class"><span class="keyword">type</span> signatures for a program</span></span><br><span class="line">:load &lt;file&gt;	<span class="type">Load</span> a program from file</span><br><span class="line">:<span class="class"><span class="keyword">type</span>		<span class="type">Show</span> the <span class="keyword">type</span> of an expression</span></span><br><span class="line">:quit		<span class="type">Exit</span> interpreter</span><br></pre></td></tr></table></figure></p>
<p>它们的实现大多很简单。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">options</span> :: [(<span class="type">String</span>, [<span class="type">String</span>] -&gt; <span class="type">Repl</span> ())]</span><br><span class="line"><span class="title">options</span> = [</span><br><span class="line">    (<span class="string">"load"</span>   , load)</span><br><span class="line">  , (<span class="string">"browse"</span> , browse)</span><br><span class="line">  , (<span class="string">"quit"</span>   , quit)</span><br><span class="line">  , (<span class="string">"type"</span>   , <span class="type">Main</span>.typeof)</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- :browse command</span></span><br><span class="line"><span class="title">browse</span> :: [<span class="type">String</span>] -&gt; <span class="type">Repl</span> ()</span><br><span class="line"><span class="title">browse</span> _ = <span class="keyword">do</span></span><br><span class="line">  st &lt;- get</span><br><span class="line">  liftIO $ mapM_ putStrLn $ ppenv (tyctx st)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- :load command</span></span><br><span class="line"><span class="title">load</span> :: [<span class="type">String</span>] -&gt; <span class="type">Repl</span> ()</span><br><span class="line"><span class="title">load</span> args = <span class="keyword">do</span></span><br><span class="line">  contents &lt;- liftIO $ <span class="type">L</span>.readFile (unwords args)</span><br><span class="line">  exec <span class="type">True</span> contents</span><br><span class="line"></span><br><span class="line"><span class="comment">-- :type command</span></span><br><span class="line"><span class="title">typeof</span> :: [<span class="type">String</span>] -&gt; <span class="type">Repl</span> ()</span><br><span class="line"><span class="title">typeof</span> args = <span class="keyword">do</span></span><br><span class="line">  st &lt;- get</span><br><span class="line">  <span class="keyword">let</span> arg = unwords args</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Infer</span>.typeof (tyctx st) arg <span class="keyword">of</span></span><br><span class="line">    <span class="type">Just</span> val -&gt; liftIO $ putStrLn $ ppsignature (arg, val)</span><br><span class="line">    <span class="type">Nothing</span> -&gt; exec <span class="type">False</span> (<span class="type">L</span>.pack arg)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- :quit command</span></span><br><span class="line"><span class="title">quit</span> :: a -&gt; <span class="type">Repl</span> ()</span><br><span class="line"><span class="title">quit</span> _ = liftIO $ exitSuccess</span><br></pre></td></tr></table></figure></p>
<p>最后，<code>shell</code>的<code>tab</code>补全将使用解释器的类型环境<code>key</code>在一组本地定义的变量上完成。<code>Repline</code>支持基于前缀的<code>tab</code>完成，其中将使用当前命令的前缀来确定要执行哪些<code>tab</code>完成。<br>在我们以<code>command:load</code>开头的情况下，我们将直接在当前工作的文件名上<code>tab</code>完成。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">completer</span> :: <span class="type">CompleterStyle</span> (<span class="type">StateT</span> <span class="type">IState</span> <span class="type">IO</span>)</span><br><span class="line"><span class="title">completer</span> = <span class="type">Prefix</span> (wordCompleter comp) defaultMatcher</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Prefix tab completer</span></span><br><span class="line"><span class="title">defaultMatcher</span> :: <span class="type">MonadIO</span> m =&gt; [(<span class="type">String</span>, <span class="type">CompletionFunc</span> m)]</span><br><span class="line"><span class="title">defaultMatcher</span> = [</span><br><span class="line">    (<span class="string">":load"</span>  , fileCompleter)</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Default tab completer</span></span><br><span class="line"><span class="title">comp</span> :: (<span class="type">Monad</span> m, <span class="type">MonadState</span> <span class="type">IState</span> m) =&gt; <span class="type">WordCompleter</span> m</span><br><span class="line"><span class="title">comp</span> n = <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">let</span> cmds = [<span class="string">":load"</span>, <span class="string">":browse"</span>, <span class="string">":quit"</span>, <span class="string">":type"</span>]</span><br><span class="line">  <span class="type">TypeEnv</span> ctx &lt;- gets tyctx</span><br><span class="line">  <span class="keyword">let</span> defs = <span class="type">Map</span>.keys ctx</span><br><span class="line">  return $ filter (isPrefixOf n) (cmds ++ defs)</span><br></pre></td></tr></table></figure></p>
<h3 id="Observations-意见"><a href="#Observations-意见" class="headerlink" title="Observations (意见)"></a>Observations (意见)</h3><p>我们有它，我们的第一个小型推断语言！<br>通过运行<code>ghci Main.hs</code>加载<code>poly</code>解释器并调用<code>main</code>函数。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ghci <span class="type">Main</span>.hs</span><br><span class="line">λ: main</span><br><span class="line"><span class="type">Poly</span>&gt; :load test.ml</span><br><span class="line"><span class="type">Poly</span>&gt; :browse</span><br></pre></td></tr></table></figure></p>
<p>通过在程序的<code>toplevel</code>声明一些函数来尝试一些简单的例子。我们可以使用<code>:type</code>命令以交互方式查询表达式的类型，该命令实际上只是在管道中途运行表达式并在类型检查后停止。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Poly</span>&gt; <span class="keyword">let</span> id x = x</span><br><span class="line"><span class="type">Poly</span>&gt; <span class="keyword">let</span> const x y = x</span><br><span class="line"><span class="type">Poly</span>&gt; <span class="keyword">let</span> twice x = x + x</span><br><span class="line"></span><br><span class="line"><span class="type">Poly</span>&gt; :<span class="class"><span class="keyword">type</span> id</span></span><br><span class="line"><span class="title">id</span> : <span class="keyword">forall</span> a. a -&gt; a</span><br><span class="line"></span><br><span class="line"><span class="type">Poly</span>&gt; :<span class="class"><span class="keyword">type</span> const</span></span><br><span class="line"><span class="title">const</span> : <span class="keyword">forall</span> a b. a -&gt; b -&gt; a</span><br><span class="line"></span><br><span class="line"><span class="type">Poly</span>&gt; :<span class="class"><span class="keyword">type</span> twice</span></span><br><span class="line"><span class="title">twice</span> : <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure></p>
<p>注意几个重要的事实。<br>我们的类型检查器现在将在解释之前将我们的拒绝程序与范围错误相关联。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Poly</span>&gt; \x -&gt; y</span><br><span class="line"><span class="type">Not</span> <span class="keyword">in</span> scope: <span class="string">"y"</span></span><br></pre></td></tr></table></figure></p>
<p>此外，那些类型不太好的程序现在也会被直接拒绝.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Poly</span>&gt; <span class="number">1</span> + <span class="type">True</span></span><br><span class="line"><span class="type">Cannot</span> unify types: </span><br><span class="line">    <span class="type">Bool</span></span><br><span class="line"><span class="title">with</span> </span><br><span class="line">    <span class="type">Int</span></span><br></pre></td></tr></table></figure></p>
<p><code>omega</code>组合子将无法通过<code>occurs</code>检查:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Poly</span>&gt; \x -&gt; x x</span><br><span class="line"><span class="type">Cannot</span> construct the the infinite <span class="class"><span class="keyword">type</span>: a = a -&gt; b</span></span><br></pre></td></tr></table></figure></p>
<p><code>test.ml</code>文件提供了对小解释器的各种测试. 例如,<code>fact</code>和<code>fib</code>函数都使用<code>fixpoint</code>来计算<code>Fibonacci</code>数或阶乘。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> fact = fix (\fact -&gt; \n -&gt; </span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">then</span> <span class="number">1</span> </span><br><span class="line">    <span class="keyword">else</span> (n * (fact (n<span class="number">-1</span>))));</span><br><span class="line"></span><br><span class="line"><span class="title">let</span> <span class="keyword">rec</span> fib n = </span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">then</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n==<span class="number">1</span>) </span><br><span class="line">      <span class="keyword">then</span> <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span> ((fib (n<span class="number">-1</span>)) + (fib (n<span class="number">-2</span>)));</span><br><span class="line"><span class="type">Poly</span>&gt; :<span class="class"><span class="keyword">type</span> fact</span></span><br><span class="line"><span class="title">fact</span> : <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="type">Poly</span>&gt; fact <span class="number">5</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"></span><br><span class="line"><span class="type">Poly</span>&gt; fib <span class="number">16</span></span><br><span class="line"><span class="number">610</span></span><br></pre></td></tr></table></figure></p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> thank you </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
        <span><a href="https://serokell.io/blog">serokell</a></span>
        <span>/</span>
        
        <span><a href="https://iohk.io/en/blog">IOHK</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/blog/js/index.js"></script>

<!--create by tea9-->

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <script>
        var gitalk = new Gitalk({
          clientID: '7cfc73dd62b57f07ed83',
          clientSecret: 'dd03b7e54aadf0d81e4c9c93e23a41272bcfcfa1',
          repo: 'blog',
          owner: 'limengyu1990',
          admin: 'limengyu1990',
          id: location.pathname,      // Ensure uniqueness and length less than 50
          distractionFreeMode: false  // Facebook-like distraction free mode
        })
        gitalk.render('comment-container')
    </script>

<!--end-->


</html>
