<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        深入理解Haskell-IO - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 我，Lionel Messi，我不是天生强大，我只是天生要强。 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>不负如来不负卿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#IO内部"><span class="toc-text">IO内部</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Haskell是一门纯语言"><span class="toc-text">Haskell是一门纯语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#monad是什么"><span class="toc-text">monad是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#欢迎来到真实世界，宝贝"><span class="toc-text">欢迎来到真实世界，宝贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-和-do-表示法"><span class="toc-text">&gt;&gt;= 和 do 表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可变数据-引用-数组-哈希表"><span class="toc-text">可变数据(引用/数组/哈希表)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-actions作为值"><span class="toc-text">IO actions作为值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#示例-IO-actions列表"><span class="toc-text">示例: IO actions列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#例子-返回一个IO-actions作为结果"><span class="toc-text">例子: 返回一个IO actions作为结果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#示例：内存分配器生成器"><span class="toc-text">示例：内存分配器生成器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#示例-使用记录类型模拟OOP"><span class="toc-text">示例: 使用记录类型模拟OOP</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异常处理"><span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#与C-C-和外部库的接口"><span class="toc-text">与C/C++和外部库的接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-monad的黑暗面"><span class="toc-text">IO monad的黑暗面</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#unsafePerformIO"><span class="toc-text">unsafePerformIO</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#inlinePerformIO"><span class="toc-text">inlinePerformIO</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unsafeInterleaveIO"><span class="toc-text">unsafeInterleaveIO</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更安全的方法-ST-monad"><span class="toc-text">更安全的方法: ST monad</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#欢迎来到机器-实际的GHC实现"><span class="toc-text">欢迎来到机器: 实际的GHC实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Yhc-nhc98-实现"><span class="toc-text">Yhc/nhc98 实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进一步阅读"><span class="toc-text">进一步阅读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#to-do列表"><span class="toc-text">to-do列表</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 我，Lionel Messi，我不是天生强大，我只是天生要强。 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        深入理解Haskell-IO
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-05-29 15:18:26</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/blog/tags/#haskell" title="haskell">haskell</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#IO" title="IO">IO</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p>本文翻译自<a href="https://wiki.haskell.org/IO_inside" target="_blank" rel="noopener">维基百科</a>,想要看原文的可以去那里查看.</p>
</blockquote>
<h3 id="IO内部"><a href="#IO内部" class="headerlink" title="IO内部"></a>IO内部</h3><p>Haskell I/O一直是新Haskellers混乱和惊喜的根源。虽然Haskell中的简单I/O代码看起来非常类似于命令式语言中的等价物，但尝试编写更复杂的代码通常会导致完全混乱。这是因为Haskell I/O内部真的非常不同。Haskell是一种纯语言，甚至I/O系统也无法打破这种纯度。<br>以下正文试图解释Haskell I/O实现的细节，这个解释应该可以帮助你最终掌握所有的智能I/O技巧。此外，我已经添加了您可能遇到的各种陷阱的详细说明。阅读本文后，您将获得”Haskell I/O大师”学位，该学位同等于计算机科学和数学学士学位。<br>如果您是Haskell I/O新手，您可能更愿意从阅读<a href="https://wiki.haskell.org/Introduction_to_IO" target="_blank" rel="noopener">IO简介</a>开始</p>
<h4 id="Haskell是一门纯语言"><a href="#Haskell是一门纯语言" class="headerlink" title="Haskell是一门纯语言"></a>Haskell是一门纯语言</h4><p>Haskell是一门纯语言，这意味着任何函数调用的结果完全由其参数决定，像C中的<code>rand()</code>或<code>getchar()</code>这样的伪函数在每次调用时都会返回不同的结果，这些函数根本不可能在Haskell中编写。而且，Haskell函数不能有副作用，这意味着这些函数不能对”真实世界”做任何更改，例如：更改文件/写入文件/打印/通过网络发送数据等。这两个限制一起意味着任何函数调用都可以被具有相同参数的先前调用的结果替换，并且语言保证所有这些重新排列不会改变程序结果!</p>
<p>让我们将其与C语言进行比较: 优化C编译器尝试猜测哪些函数没有副作用，并且不依赖于可变全局变量。如果这个猜测错了，优化可以改变程序的语义！为了避免这种灾难，C优化器在猜测中是保守的，或者需要程序员提供有关函数纯度的提示。</p>
<p>与优化的C编译器相比，Haskell编译器是一组纯数学转换。这导致更好的高级优化设施。此外，纯数学计算可以更容易地分成几个可以并行执行的线程，这在多核CPU的这些日子里越来越重要。最后，纯计算不易出错且更容易验证，这增加了Haskell的稳健性和使用Haskell的程序开发速度。Haskell纯度允许编译器只调用其结果确实需要计算高级函数的最终值的函数(例如: main) - 这称为惰性求值。纯粹的数学计算是件好事，但是I/O动作怎么样？函数如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">putStrLn &quot;Press any key to begin formatting&quot;</span><br></pre></td></tr></table></figure></p>
<p>不能返回任何有意义的结果值，那么我们如何确保编译器不会省略或重新排序其执行？总的来说，我们如何使用完全惰性的语言处理有状态的算法和副作用？这个问题在18年的Haskell开发中提出了许多不同的解决方案(参见Haskell的历史)，尽管现在基于monads的解决方案已成为标准。</p>
<h4 id="monad是什么"><a href="#monad是什么" class="headerlink" title="monad是什么?"></a>monad是什么?</h4><p>什么是monad? 这是来自数学范畴理论的东西，我不知道了。为了理解monad如何用于解决I/O和副作用的问题，您不需要知道它。就像我一样，只知道小学数学就足够了。<br>让我们想象一下，我们想在Haskell中实现众所周知的<code>getchar</code>函数。它应该有什么样的类型？我们试试吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getchar :: Char</span><br><span class="line"></span><br><span class="line">get2chars = [getchar,getchar]</span><br></pre></td></tr></table></figure></p>
<p>只有<code>Char</code>类型的<code>getchar</code>函数会得到什么？您可以在<code>get2chars</code>的定义中看到所有可能出现的问题：</p>
<ul>
<li>因为Haskell编译器将所有函数视为纯函数(没有副作用)，所以它可以避免对<code>getchar</code>的”过度”调用, 并使用两次返回值.</li>
<li>即使它确实进行了两次调用，也无法确定应首先执行哪个调用。你想按照阅读顺序或相反的顺序返回两个字符吗？<code>get2chars</code>定义中没有任何内容可以回答这个问题。</li>
</ul>
<p>从程序员的角度来看，如何解决这些问题呢？<br>让我们为<code>getchar</code>函数增加一个”伪装”的参数，使每个调用与编译器的观点”不同”:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getchar :: Int -&gt; Char</span><br><span class="line"></span><br><span class="line">get2chars = [getchar 1, getchar 2]</span><br></pre></td></tr></table></figure></p>
<p>马上，这解决了上面提到的第一个问题 - 现在编译器将进行两次调用，因为编译器将它们视为具有不同的参数。整个<code>get2chars</code>函数也应该有一个”伪装”参数，否则我们会遇到同样的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getchar   :: Int -&gt; Char</span><br><span class="line">get2chars :: Int -&gt; String</span><br><span class="line"></span><br><span class="line">get2chars _ = [getchar 1, getchar 2]</span><br></pre></td></tr></table></figure></p>
<p>现在我们需要给编译器一些线索来确定它应该首先调用哪个函数。Haskell语言没有提供任何表达评估顺序的方法……除了数据依赖性！如何添加一个人工数据依赖项，以防止在第一个<code>getchar</code>之前评估第二个<code>getchar</code>？为了实现这一目标，我们将从<code>getchar</code>函数返回一个额外的”伪装”结果，该”伪装”结果将用作下一个<code>getchar</code>函数调用的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getchar :: Int -&gt; (Char, Int)</span><br><span class="line"></span><br><span class="line">get2chars _ = [a,b]  where (a,i) = getchar 1</span><br><span class="line">                           (b,_) = getchar i</span><br></pre></td></tr></table></figure></p>
<p>到目前为止还不错 - 现在我们可以保证在读<code>b</code>之前读取<code>a</code>，因为读<code>b</code>需要通过读<code>a</code>返回的值(<code>i</code>)!<br>我们在<code>get2chars</code>中添加了一个”伪装”参数，但问题是Haskell编译器太聪明了! 它可以相信外部<code>getchar</code>函数真的依赖于它的参数，但是对于<code>get2chars</code>函数，它会看到我们是在作弊，因为我们扔掉了它(参数使用了_占位符)! 因此，编译器不会觉得有必要按照我们想要的顺序执行调用。我们该如何解决这个问题? 将这个”虚假”的参数传递给<code>getchar</code>函数怎么样?! 这样的话，编译器就无法猜测它是否真的未使用过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get2chars i0 = [a,b]  where (a,i1) = getchar i0</span><br><span class="line">                            (b,i2) = getchar i1</span><br></pre></td></tr></table></figure>
<p>还有更多 - <code>get2chars</code>具有与<code>getchar</code>功能相同的纯度问题。<br>如果需要调用<code>get2chars</code>两次，则需要一种方法来描述这些调用的顺序。看着：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get4chars = [get2chars 1, get2chars 2]  -- order of &apos;get2chars&apos; calls isn&apos;t defined 未定义&apos;get2chars&apos;调用的顺序</span><br></pre></td></tr></table></figure></p>
<p>我们已经知道如何处理这些问题 - <code>get2chars</code>函数也应该返回一些可以用来顺序调用的”伪装”值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get2chars :: Int -&gt; (String, Int)</span><br><span class="line"></span><br><span class="line">get4chars i0 = (a++b)  where (a,i1) = get2chars i0</span><br><span class="line">                             (b,i2) = get2chars i1</span><br></pre></td></tr></table></figure></p>
<p>但是<code>get2chars</code>函数应该返回什么”伪装”值？如果我们使用一些整数常量，那么过于聪明的Haskell编译器会猜测我们想再次作弊。如何返回<code>getchar</code>函数返回的值？看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get2chars :: Int -&gt; (String, Int)</span><br><span class="line">get2chars i0 = ([a,b], i2)  where (a,i1) = getchar i0</span><br><span class="line">                                  (b,i2) = getchar i1</span><br></pre></td></tr></table></figure></p>
<p>信不信由你，但我们刚刚已经构建了整个<code>monadic</code> Haskell I/O系统。</p>
<h4 id="欢迎来到真实世界，宝贝"><a href="#欢迎来到真实世界，宝贝" class="headerlink" title="欢迎来到真实世界，宝贝"></a>欢迎来到真实世界，宝贝</h4><p>警告：关于IO的以下故事是不正确的，因为它无法实际解释IO的一些重要方面（包括交互和并发）。但是，有些人发现开始理解是有用的。<br>Haskell <code>main</code>函数具有以下类型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main :: RealWorld -&gt; ((), RealWorld)</span><br></pre></td></tr></table></figure></p>
<p>其中<code>RealWorld</code>是一种”伪装”的类型，用来替换我们的Int。<br>这就像在接力赛中接过的接力棒。当<code>main</code>函数调用某些IO函数时，它将作为参数收到的”RealWorld”传递给了IO函数。所有IO函数都有类似的类型，涉及<code>RealWorld</code>作为参数和结果。确切地说，<code>IO</code>是以下列方式定义的类型同义词：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type IO a  =  RealWorld -&gt; (a, RealWorld)</span><br></pre></td></tr></table></figure></p>
<p>因此，<code>main</code>函数只有类型<code>IO()</code>，<code>getChar</code>函数有类型<code>IO Char</code>,等等。您可以将<code>IO Char</code>类型视为”获取当前的<code>RealWorld</code>，对其执行某些操作，并返回<code>Char</code>和（可能已更改的）<code>RealWorld</code>。让我们看<code>main</code>调用<code>getChar</code>两次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getChar :: RealWorld -&gt; (Char, RealWorld)</span><br><span class="line"></span><br><span class="line">main :: RealWorld -&gt; ((), RealWorld)</span><br><span class="line">main world0 = let (a, world1) = getChar world0</span><br><span class="line">                  (b, world2) = getChar world1</span><br><span class="line">              in ((), world2)</span><br></pre></td></tr></table></figure></p>
<p>仔细看看：<code>main</code>函数将收到的<code>world0</code>传递给第一个<code>getChar</code>函数。 这个<code>getChar</code>函数返回一些<code>RealWorld</code>类型的新值，它将在下一次调用中使用。最后，<code>main</code>返回它从第二个<code>getChar</code>获得的<code>world2</code>。</p>
<ul>
<li>如果没有使用它读取的字符，这里是否可以省略任何<code>getChar</code>调用？不，因为我们需要返回第二个<code>getChar</code>结果的<code>world2</code>，这又需要从第一个<code>getChar</code>返回的<code>world1</code>。</li>
<li>是否可以重新排序<code>getChar</code>调用？ 否：第二个<code>getChar</code>在第一个之前无法调用，因为它使用了第一次调用返回的<code>world1</code>.</li>
<li>是否可以重复调用？ 在Haskell语义中 - 是的，但真正的编译器永远不会在这种简单的情况下重复工作（否则，生成的程序将没有任何速度保证）。</li>
</ul>
<p>正如我们已经说过的那样，RealWorld值被用作一个接力棒，它在严格的顺序中被<code>main</code>调用的所有例程之间传递。在每个例程中，RealWorld值以相同的方式使用。 总的来说，为了”计算”从<code>main</code>返回的<code>world</code>，我们应该直接或间接地执行从<code>main</code>调用的每个IO过程。这意味着插入链中的每个程序都将在我们打算调用它时执行(相对于其他IO操作)。让我们考虑以下程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main = do a &lt;- ask &quot;What is your name?&quot;</span><br><span class="line">          b &lt;- ask &quot;How old are you?&quot;</span><br><span class="line">          return ()</span><br><span class="line"></span><br><span class="line">ask s = do putStr s</span><br><span class="line">           readLn</span><br></pre></td></tr></table></figure></p>
<p>现在你有足够的知识以低级别方式重写它，并检查每个应该执行的操作是否真的将使用它应该具有的参数并按照我们期望的顺序执行(练习)。<br>但是条件执行呢？没问题。让我们定义众所周知的<code>when</code>操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">when :: Bool -&gt; IO () -&gt; IO ()</span><br><span class="line">when condition action world =</span><br><span class="line">    if condition</span><br><span class="line">      then action world</span><br><span class="line">      else ((), world)</span><br></pre></td></tr></table></figure></p>
<p>如您所见，我们可以根据数据值轻松地在执行链中包含或排除IO过程(操作)，如果在<code>when</code>的调用中<code>condition</code>为False，那么<code>action</code>将永远不会被调用，因为真实的Haskell编译器，从不调用其结果不用于最终结果的函数(例如: 这里main函数的<code>world</code>最终值)。循环和更复杂的控制结构可以以相同的方式实现。试试看吧！<br>最后，你可能想要知道，在程序中传递这些RealWorld值需要花费的成本，它是免费的，这些”伪装”值仅在编译器分析和优化代码时存在，但是当它进入汇编代码生成时，它”突然”意识到这种类型就像<code>()</code>，因此所有的这些参数和结果值都可以从最终生成的代码中省略。这不漂亮吗？</p>
<h4 id="gt-gt-和-do-表示法"><a href="#gt-gt-和-do-表示法" class="headerlink" title="&gt;&gt;= 和 do 表示法"></a><code>&gt;&gt;=</code> 和 <code>do</code> 表示法</h4><p>所有初学者(包括我)都认为<code>do</code>是执行IO动作的魔术语句。那是错的,<code>do</code>只是语法糖，它简化了使用IO(以及其他monad的程序)的编写，但这超出了本教程的范围。<code>do</code>符号最终被转换为传递<code>world</code>值的语句，就像我们上面手动编写的那样，用于简化几个IO操作的粘合。您不需要只为一条语句使用<code>do</code>语句,例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main = do putStr &quot;Hello!&quot;</span><br></pre></td></tr></table></figure></p>
<p>脱糖后:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main = putStr &quot;Hello!&quot;</span><br></pre></td></tr></table></figure></p>
<p>让我们来看看如何在下面的例子中使用多个语句来解释<code>do</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main = do putStr &quot;What is your name?&quot;</span><br><span class="line">          putStr &quot;How old are you?&quot;</span><br><span class="line">          putStr &quot;Nice day!&quot;</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>do</code>语句只是加入了应该按顺序执行的几个IO动作。它被翻译成一个所谓的”绑定运算符”的顺序应用程序，即<code>&gt;&gt;</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main = (putStr &quot;What is your name?&quot;) &gt;&gt; ((putStr &quot;How old are you?&quot;) &gt;&gt; (putStr &quot;Nice day!&quot;))</span><br></pre></td></tr></table></figure></p>
<p>这个绑定操作符只是结合了两个IO动作，通过在它们之间传递<code>world</code>来顺序执行它们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(&gt;&gt;) :: IO a -&gt; IO b -&gt; IO b</span><br><span class="line">(action1 &gt;&gt; action2) world0 =</span><br><span class="line">   let (a, world1) = action1 world0</span><br><span class="line">       (b, world2) = action2 world1</span><br><span class="line">   in (b, world2)</span><br></pre></td></tr></table></figure></p>
<p>如果以这种方式定义运算符对您来说很奇怪，请按以下方式阅读此定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">action1 &gt;&gt; action2 = action</span><br><span class="line">  where</span><br><span class="line">    action world0 = let (a, world1) = action1 world0</span><br><span class="line">                        (b, world2) = action2 world1</span><br><span class="line">                    in (b, world2)</span><br></pre></td></tr></table></figure></p>
<p>现在，您可以在使用<code>&gt;&gt;</code>的位置替换其定义，并检查由<code>do</code>语法糖构造的程序实际上与我们通过手动操作<code>world</code>值编写的程序相同。</p>
<p>更复杂的示例涉及使用<code>&lt;-</code>绑定的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main = do </span><br><span class="line">   a &lt;- readLn</span><br><span class="line">   print a</span><br></pre></td></tr></table></figure></p>
<p>这段代码可以脱糖为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main = readLn &gt;&gt;= (\a -&gt; print a)</span><br></pre></td></tr></table></figure></p>
<p>正如您应该记住的那样,<code>&gt;&gt;</code>绑定操作符默默地忽略其第一个<code>action</code>的值，仅将其第二个<code>action</code>的结果做为整体结果返回。<br>另一方面,<code>&gt;&gt;=</code>绑定操作符(注意末尾的额外’=’)允许我们使用其第一个<code>action</code>的结果, 并将其作为附加参数传递给第二个<code>action</code>,看看定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b</span><br><span class="line">(action1 &gt;&gt;= action2) world0 =</span><br><span class="line">   let (a, world1) = action1 world0</span><br><span class="line">       (b, world2) = action2 a world1</span><br><span class="line">   in (b, world2)</span><br></pre></td></tr></table></figure></p>
<p>首先,第二个<code>action</code>的类型(更准确地说,是一个返回IO action的函数),即<code>a -&gt; IO b</code>是什么意思?<br>通过替换IO定义,我们得到<code>a -&gt; RealWorld -&gt; (b, RealWorld)</code>,这意味着第二个action实际上有两个参数: 实际在其中使用的类型<code>a</code>,以及用于IO action排序的<code>RealWorld</code>类型的值.<br>情况总是如此,与您在其类型签名中看到的相比较,任何IO过程都另有一个参数,此参数隐藏在别名”IO”的定义中。<br>其次,您可以使用<code>&gt;&gt;</code>和<code>&gt;&gt;=</code>这些操作来简化您的程序。例如,在上面的代码中我们不需要引入变量a,因为<code>readLn</code>的结果可以直接发送到<code>print</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main = readLn &gt;&gt;= print</span><br></pre></td></tr></table></figure></p>
<p>第三,如你所见,符号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">do x &lt;- action1</span><br><span class="line">    action2</span><br></pre></td></tr></table></figure></p>
<p>其中<code>action1</code>的类型为<code>IO a</code>,而<code>action2</code>的类型为<code>IO b</code>,转换为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action1 &gt;&gt;= (\x -&gt; action2)</span><br></pre></td></tr></table></figure></p>
<p>其中<code>&gt;&gt;=</code>的第二个参数的类型为<code>a -&gt; IO b</code>,这就是处理<code>&lt;-</code>绑定的方式: <code>&lt;-</code>左侧的名称只是后续操作的一个参数,表示为一个大的IO action.<br>另请注意,如果<code>action1</code>的类型为<code>IO a</code>,那么<code>x</code>将只有类型<code>a</code>; 您可以将<code>&lt;-</code>的效果视为将<code>action1</code>的IO值”解包”为<code>x</code>.<br>还要注意<code>&lt;-</code>不是真正的运算符,它是纯语法,就像<code>do</code>本身一样,它的含义只取决于它被脱糖的方式.</p>
<p>看下一个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main = do putStr &quot;What is your name?&quot;</span><br><span class="line">          a &lt;- readLn</span><br><span class="line">          putStr &quot;How old are you?&quot;</span><br><span class="line">          b &lt;- readLn</span><br><span class="line">          print (a,b)</span><br></pre></td></tr></table></figure></p>
<p>这段代码可以脱糖为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main = putStr &quot;What is your name?&quot;</span><br><span class="line">       &gt;&gt; readLn</span><br><span class="line">       &gt;&gt;= \a -&gt; putStr &quot;How old are you?&quot;</span><br><span class="line">       &gt;&gt; readLn</span><br><span class="line">       &gt;&gt;= \b -&gt; print (a,b)</span><br></pre></td></tr></table></figure></p>
<p>我在这里省略了括号,<code>&gt;&gt;</code>和<code>&gt;&gt;=</code>运算符都是左关联的,但是lambda绑定总是尽可能向右延伸,这意味着这里引入的<code>a</code>和<code>b</code>绑定对所有剩余的动作都有效.<br>作为练习,自己添加括号并将此过程转换为显式传递<code>world</code>值的低级代码(练习),我认为这应该足以帮助您最终了解<code>do</code>转换和绑定操作符<code>&gt;&gt;=</code>的工作原理.</p>
<p>不好,我忘记了第三个monadic运算符: <code>return</code>,它只是结合了它的两个参数: 传递的值和<code>world</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">return :: a -&gt; IO a</span><br><span class="line">return a world0 = (a, world0)</span><br></pre></td></tr></table></figure></p>
<p>转换一个简单的<code>return</code>用法示例怎么样？说，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main = do a &lt;- readLn</span><br><span class="line">          return (a*2)</span><br></pre></td></tr></table></figure></p>
<p>具有命令式语言背景的程序员通常认为Haskell中的<code>return</code>与其他语言一样,会立即从IO过程返回.正如你在其定义中看到的那样(甚至只是从它的类型),这样的假设是完全错误的,<br>使用<code>return</code>的唯一目的是将一些值(类型为’a’)<code>lift</code>到整个动作的结果中(类型为<code>IO a</code>),因此它通常应该仅用作某个IO序列的最后执行语句,例如,尝试将以下过程转换为相应的低级代码(练习)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main = do a &lt;- readLn</span><br><span class="line">          when (a&gt;=0) $ do</span><br><span class="line">              return ()</span><br><span class="line">          print &quot;a is negative&quot;</span><br></pre></td></tr></table></figure></p>
<p>并且您将意识到即使对于<code>a</code>的非负值,也会执行<code>print</code>语句. 如果需要从IO过程中间退出,可以使用<code>if</code>语句:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ain = do a &lt;- readLn</span><br><span class="line">          if (a&gt;=0)</span><br><span class="line">            then return ()</span><br><span class="line">            else print &quot;a is negative&quot;</span><br></pre></td></tr></table></figure></p>
<p>而且，Haskell设计规则允许我们使用以下设计:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main = do a &lt;- readLn</span><br><span class="line">          if (a&gt;=0) then return ()</span><br><span class="line">            else do</span><br><span class="line">          print &quot;a is negative&quot;</span><br><span class="line">          ...</span><br></pre></td></tr></table></figure></p>
<p>这可能有助于从冗长的<code>do</code>语句中逃脱。</p>
<p>最后一个练习: 实现一个函数<code>liftM</code>.它将普通值的操作提升到monadic的操作,它的类型签名:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liftM :: (a -&gt; b) -&gt; (IO a -&gt; IO b)</span><br></pre></td></tr></table></figure></p>
<p>如果这对您来说太难了,请从以下高级定义开始并以低级方式重写它(练习):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">liftM f action = do </span><br><span class="line">	    x &lt;- action</span><br><span class="line">            return (f x)</span><br></pre></td></tr></table></figure></p>
<h4 id="可变数据-引用-数组-哈希表"><a href="#可变数据-引用-数组-哈希表" class="headerlink" title="可变数据(引用/数组/哈希表)"></a>可变数据(引用/数组/哈希表)</h4><p>正如您应该知道的,Haskell中的每个名称都绑定到一个固定(不可变)值,这大大简化了理解算法和代码优化,但在某些情况下这是不合适的,众所周知,有许多算法在可更新变量,数组等方面更容易实现.<br>这意味着与变量关联的值(例如,在不同的执行点)可能不同,因此读取其值不能视为纯函数.想象一下,例如,以下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main = do let a0 = readVariable varA</span><br><span class="line">              _  = writeVariable varA 1</span><br><span class="line">              a1 = readVariable varA</span><br><span class="line">          print (a0, a1)</span><br></pre></td></tr></table></figure></p>
<p>这看起来很奇怪吗? 首先,对<code>readVariable</code>的两次调用看起来是一样的,因此编译器可以只重用第一次调用返回的值. 其次,不使用<code>writeVariable</code>调用的结果,因此编译器可以(并且将会)完全省略此调用,为了完成描述,这三个调用可以按任何顺序重新排列,因为它们看起来彼此独立,这显然不是预期的. 解决方案是什么？你已经知道了, 使用IO actions, 使用IO actions可确保完成:</p>
<ul>
<li>按照书面形式的顺序执行</li>
<li>每个action都必须执行</li>
<li>相同action的结果将不会被重用(例如: <code>readVariable varA</code>)<br>所以,上面的代码应该写成:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import Data.IORef</span><br><span class="line">main = do varA &lt;- newIORef 0  -- Create and initialize a new variable</span><br><span class="line">          a0 &lt;- readIORef varA</span><br><span class="line">          writeIORef varA 1</span><br><span class="line">          a1 &lt;- readIORef varA</span><br><span class="line">          print (a0, a1)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里,<code>varA</code>的类型为<code>IORef Int</code>,意思是”IO monad中的一个变量(引用),持有一个类型为Int的值”,<code>newIORef</code>创建一个新变量(引用)并返回它,然后使用此引用进行读/写操作,<code>readIORef varA</code>操作返回的值不仅取决于所涉及的变量,还取决于执行此操作的时刻,因此它可以在每次调用时返回不同的值. 数组,散列表和任何其他<em>mutable</em>数据结构以相同的方式定义,对于每个数据结构,都有一个操作可以创建新的”可变值”并返回对它的引用,然后使用<code>IO monad</code>中的特殊读写操作,以下代码显示了使用可变数组的示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import Data.Array.IO</span><br><span class="line">main = do arr &lt;- newArray (1,10) 37 :: IO (IOArray Int Int)</span><br><span class="line">          a &lt;- readArray arr 1</span><br><span class="line">          writeArray arr 1 64</span><br><span class="line">          b &lt;- readArray arr 1</span><br><span class="line">          print (a, b)</span><br></pre></td></tr></table></figure></p>
<p>这里,创建了一个由10个元素组成的数组,其中37作为每个位置的初始值,接着将第一个元素(索引为1)的值读入变量<code>a</code>,然后将索引为1的元素的值设置为64,然后再次读入<code>b</code>,正如您通过执行此代码所看到的，<code>a</code>将设置为37,<code>b</code>将设置为64.</p>
<p>其他依赖于状态的操作通常也实现为IO操作,例如,随机数生成器应在每次调用时返回不同的值。给它一个涉及IO的类型看起来很自然：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rand :: IO Int</span><br></pre></td></tr></table></figure></p>
<p>另外,当你导入C例程时你应该小心,如果这个例程不纯,即它的结果取决于”真实世界”(文件系统，内存内容……),内部状态等等,你应该给它是一种IO类型,否则,编译器可以”优化”此程序(使用相同参数的程序)的重复调用.<br>例如，我们可以为以下内容编写非IO类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oreign import ccall</span><br><span class="line">   sin :: Double -&gt; Double</span><br></pre></td></tr></table></figure></p>
<p>因为<code>sin</code>的结果只取决于它的论点，但是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foreign import ccall</span><br><span class="line">   tell :: Int -&gt; IO Int</span><br></pre></td></tr></table></figure></p>
<p>如果您将<code>tell</code>声明为纯函数(没有IO),那么您可以在每次调用时获得相同的位置.</p>
<h4 id="IO-actions作为值"><a href="#IO-actions作为值" class="headerlink" title="IO actions作为值"></a>IO actions作为值</h4><p>到目前为止,您应该理解为什么在非IO(纯)程序中使用IO操作是不可能的,这样的程序只是没有得到”接力棒”;他们不知道传递给IO action的任何<code>world</code>值,<code>RealWorld</code>类型是一种抽象数据类型,因此纯函数也不能自己构造<code>RealWorld</code>值,并且它是严格类型,因此也不能使用<code>undefined</code>,因此,禁止在纯过程中使用IO操作只是一种类型系统技巧(通常在Haskell中)。<br>但是虽然纯代码不能<em>execute</em> IO动作，<br>它可以与任何其他功能值一起使用 - 它们可以存储在数据结构中,作为参数传递,作为结果返回,收集在列表中,并部分应用,但IO action仍然是一个功能值,因为我们不能将它应用于最后一个参数 - 类型为RealWorld。<br>为了<em>execute</em> IO动作,我们需要将它应用于一些RealWorld值,这只能在一些IO过程中,在其”action链”中完成。<br>只有当这个过程被调用(作为”为<code>main</code>函数计算world最终值”过程的一部分时),才会真正执行此操作。<br>看看这个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main world0 = let get2chars = getChar &gt;&gt; getChar</span><br><span class="line">                  ((), world1) = putStr &quot;Press two keys&quot; world0</span><br><span class="line">                  (answer, world2) = get2chars world1</span><br><span class="line">              in ((), world2)</span><br></pre></td></tr></table></figure></p>
<p>这里我们首先将一个值绑定到<code>get2chars</code>,然后编写一个涉及<code>putStr</code>的绑定,但是执行顺序是什么？它不是由<code>let</code>绑定的顺序定义的,它是由处理<code>world</code>值的顺序定义的!<br>您可以随意重新排序绑定语句,执行顺序将由关于传递的<code>world</code>值的数据依赖性定义,让我们看看<code>do</code>语法中的<code>main</code>是什么样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main = do let get2chars = getChar &gt;&gt; getChar</span><br><span class="line">          putStr &quot;Press two keys&quot;</span><br><span class="line">          get2chars</span><br><span class="line">          return ()</span><br></pre></td></tr></table></figure></p>
<p>正如您所看到的,我们已经消除了两个<code>let</code>绑定,只留下了一个定义<code>get2chars</code>的绑定,非<code>let</code>语句按照它们写入的确切顺序执行,因为如上所述它们将声明中的<code>world</code>值传递给声明(语句),因此,这个版本的函数更容易理解,因为我们不必在心理上弄清楚<code>world</code>值的数据依赖性.</p>
<p>此外,像<code>get2chars</code>这样的IO action不能直接执行,因为它们是具有<code>RealWorld</code>参数的函数,要执行它们,我们需要提供<code>RealWorld</code>参数,即将它们插入到<code>main</code>链中,将它们放在从<code>main</code>执行的某些<code>do</code>序列中(直接在<code>main</code>函数中,或间接在从<code>main</code>调用的IO函数中).在完成之前,它们将保留(就像任何部分评估形式的函数),我们可以像使用任何其他函数一样使用IO操作 - 将它们绑定到名称(如上所述),将它们保存在数据结构中,将它们作为函数参数传递并将它们作为结果返回 - 直到你给他们魔法的<code>RealWorld</code>参数,他们才会被执行!</p>
<h5 id="示例-IO-actions列表"><a href="#示例-IO-actions列表" class="headerlink" title="示例: IO actions列表"></a>示例: IO actions列表</h5><p>让我们尝试定义IO actions列表:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ioActions :: [IO ()]</span><br><span class="line">ioActions = [</span><br><span class="line">              (print &quot;Hello!&quot;),</span><br><span class="line">              (putStr &quot;just kidding&quot;),</span><br><span class="line">              (getChar &gt;&gt; return ())</span><br><span class="line">            ]</span><br></pre></td></tr></table></figure></p>
<p>我在每个action周围使用了额外的括号，尽管它们并不是真正需要的。如果您仍然无法相信这些操作不会立即执行，请回忆一下此列表的实际类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioActions :: [RealWorld -&gt; ((), RealWorld)]</span><br></pre></td></tr></table></figure></p>
<p>好吧，现在我们要执行其中一些操作。没问题，只需将它们插入<code>main</code>链：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main = do head ioActions</span><br><span class="line">          ioActions !! 1</span><br><span class="line">          last ioActions</span><br></pre></td></tr></table></figure></p>
<p>看起来很奇怪吧？实际上，您在<code>do</code>语句中编写的任何IO操作(或用作<code>&gt;&gt;</code> / <code>&gt;&gt;=</code>运算符的参数)都是一个表达式，为某些类型<code>a</code>返回类型<code>IO a</code>的结果。<br>通常，您使用某些类型为<code>x -&gt; y -&gt; ... -&gt; IO a</code>的函数,并提供所有<code>x,y</code>等参数。<br>但是你并不局限于这个标准场景 - 不要忘记Haskell是一种函数式语言,你可以以任何可能的方式自由计算所需的函数值(回想一下<code>IO a</code>实际上是一种函数类型).</p>
<p>这里我们刚从列表中提取了几个函数 - 没问题,正如我们在前面的例子中所做的那样,这个函数值也可以即时构建 - 这也没问题。<br>想看到这个函数值作为参数传递？只要看看<code>when</code>的定义. 嘿,我们可以像任何其他函数值一样购买,出售和出租这些IO操作! 例如,让我们定义一个执行列表中所有IO actions的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sequence_ :: [IO a] -&gt; IO ()</span><br><span class="line">sequence_ [] = return ()</span><br><span class="line">sequence_ (x:xs) = do x</span><br><span class="line">               sequence_ xs</span><br></pre></td></tr></table></figure></p>
<p>没有黑魔法 - 我们只是从列表中提取IO actions并将它们插入到一系列IO操作中，这些操作应该一个接一个地执行(按照它们在列表中的顺序)以”计算整个<code>sequence_</code>调用的最终world值”。<br>在<code>sequence_</code>的帮助下，我们可以将最后一个<code>main</code>函数重写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main = sequence_ ioActions</span><br></pre></td></tr></table></figure></p>
<p>与任何其他（功能和非功能）值一样，Haskell使用IO操作的能力允许我们定义任意复杂度的控制结构。例如，尝试定义一个重复动作的控制结构，直到它返回<code>False</code>结果(练习)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while :: IO Bool -&gt; IO ()</span><br><span class="line">while action = ???</span><br></pre></td></tr></table></figure></p>
<p>大多数编程语言根本不允许您定义控制结构，而那些允许的通常是需要您使用宏扩展系统的编程语言。在Haskell中，控制结构只是任何人都可以编写的简单函数。</p>
<h5 id="例子-返回一个IO-actions作为结果"><a href="#例子-返回一个IO-actions作为结果" class="headerlink" title="例子: 返回一个IO actions作为结果"></a>例子: 返回一个IO actions作为结果</h5><p>如何通过函数返回IO操作? 好吧,我们每次定义IO过程时都会这样做 - 它们都返回需要执行RealWorld值的IO actions。虽然我们通常只是将它们作为更高级别IO过程的一部分来执行,但也可以在没有实际执行的情况下收集它们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main = do let a = sequence ioActions</span><br><span class="line">              b = when True getChar</span><br><span class="line">              c = getChar &gt;&gt; getChar</span><br><span class="line">          putStr &quot;These &apos;let&apos; statements are not executed!&quot;</span><br></pre></td></tr></table></figure></p>
<p>这些分配的IO过程可以用作其他过程的参数，或者写入全局变量，或者以其他方式处理，或者稍后执行，就像我们在<code>get2chars</code>示例中所做的那样。<br>但是如何从IO过程返回参数化IO action呢？让我们定义一个过程，该过程从表示为句柄的文件返回第i个字节：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readi h i = do hSeek h AbsoluteSeek i</span><br><span class="line">               hGetChar h</span><br></pre></td></tr></table></figure></p>
<p>到现在为止还挺好。但是，如果一个程序返回具有给定名称的文件的第i个字节，而不是每次都重新打开它？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">readfilei :: String -&gt; IO (Integer -&gt; IO Char)</span><br><span class="line">readfilei name = do h &lt;- openFile name ReadMode</span><br><span class="line">                    return (readi h)</span><br></pre></td></tr></table></figure></p>
<p>如您所见，这是一个IO过程，它打开一个文件并返回另一个将读取指定字节的IO过程。但我们可以更进一步，在<code>readfilei</code>中包含<code>readi</code>内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">readfilei name = do h &lt;- openFile name ReadMode</span><br><span class="line">                    let readi h i = do hSeek h AbsoluteSeek i</span><br><span class="line">                                       hGetChar h</span><br><span class="line">                    return (readi h)</span><br></pre></td></tr></table></figure></p>
<p>现在看起来更好了。但是，如果可以从当前定义<code>readi</code>的环境中获取作为<code>readi</code>参数的<code>h</code>，我们为什么要添加<code>h</code>? 更短的版本是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">readfilei name = do h &lt;- openFile name ReadMode</span><br><span class="line">                    let readi i = do hSeek h AbsoluteSeek i</span><br><span class="line">                                     hGetChar h</span><br><span class="line">                    return readi</span><br></pre></td></tr></table></figure></p>
<p>我们在这做了什么? 我们在<code>readfilei</code>中构建了一个涉及本地名称的参数化IO action，并将其作为结果返回。现在可以通过以下方式使用它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main = do myfile &lt;- readfilei &quot;test&quot;</span><br><span class="line">          a &lt;- myfile 0</span><br><span class="line">          b &lt;- myfile 1</span><br><span class="line">          print (a,b)</span><br></pre></td></tr></table></figure></p>
<p>这种使用IO操作的方式对于Haskell程序来说非常典型 - 您只需构造一个或多个所需的IO操作(带或不带参数),可能涉及”构造函数”接收的参数,并将它们返回给调用者。然后,这些IO操作可以在程序的其余部分中使用,而无需了解您的内部实现策略。可以使用的一件事是部分模拟OOP(或更确切地说ADT)编程范例。</p>
<h5 id="示例：内存分配器生成器"><a href="#示例：内存分配器生成器" class="headerlink" title="示例：内存分配器生成器"></a>示例：内存分配器生成器</h5><p>例如,我的一个程序有一个模块,它是一个内存子分配器。它接收大内存块的地址和大小,并返回两个过程 - 一个用于分配给定大小的子块,另一个用于释放分配的子块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">memoryAllocator :: Ptr a -&gt; Int -&gt; IO (Int -&gt; IO (Ptr b),</span><br><span class="line">                                       Ptr c -&gt; IO ())</span><br><span class="line"></span><br><span class="line">memoryAllocator buf size = do ......</span><br><span class="line">               let alloc size = do ...</span><br><span class="line">                                   ...</span><br><span class="line">                   free ptr = do ...</span><br><span class="line">                                 ...</span><br><span class="line">               return (alloc, free)</span><br></pre></td></tr></table></figure></p>
<p>这是如何实现的？<code>alloc</code>和<code>free</code>函数使用在memoryAllocator过程中创建的引用。由于这些引用的创建是<code>memoryAllocator IO</code>操作链的一部分，因此将为每个调用memoryAllocator的内存块创建一组新的独立引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memoryAllocator buf size = do start &lt;- newIORef buf</span><br><span class="line">                 end &lt;- newIORef (buf `plusPtr` size)</span><br><span class="line">                 ...</span><br></pre></td></tr></table></figure></p>
<p>这两个引用是在<code>alloc</code>和<code>free</code>定义中读取和写入的(我们将为这个例子实现一个非常简单的内存分配器):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">      let alloc size = do addr &lt;- readIORef start</span><br><span class="line">                          writeIORef start (addr `plusPtr` size)</span><br><span class="line">                          return addr</span><br><span class="line">                          </span><br><span class="line">      let free ptr = do writeIORef start ptr</span><br></pre></td></tr></table></figure></p>
<p>我们在这里定义的只是一对闭包,它们在定义时使用可用的状态。正如您所看到的,尽管Haskell缺乏对不纯函数的直接支持,但它与任何其他函数语言一样简单。<br>以下示例使用memoryAllocator返回的过程在两个独立的内存缓冲区中同时分配/释放块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main = do buf1 &lt;- mallocBytes (2^16)</span><br><span class="line">          buf2 &lt;- mallocBytes (2^20)</span><br><span class="line">          (alloc1, free1) &lt;- memoryAllocator buf1 (2^16)</span><br><span class="line">          (alloc2, free2) &lt;- memoryAllocator buf2 (2^20)</span><br><span class="line">          ptr11 &lt;- alloc1 100</span><br><span class="line">          ptr21 &lt;- alloc2 1000</span><br><span class="line">          free1 ptr11</span><br><span class="line">          free2 ptr21</span><br><span class="line">          ptr12 &lt;- alloc1 100</span><br><span class="line">          ptr22 &lt;- alloc2 1000</span><br></pre></td></tr></table></figure></p>
<h5 id="示例-使用记录类型模拟OOP"><a href="#示例-使用记录类型模拟OOP" class="headerlink" title="示例: 使用记录类型模拟OOP"></a>示例: 使用记录类型模拟OOP</h5><p>让我们实现经典的OOP示例：绘制图形。有不同类型的数字：圆形，矩形等。任务是创建一个异构的图列表。此列表中的所有图应支持相同的操作集：绘制<code>draw</code>，移动<code>move</code>等。我们将这些操作表示为IO过程。让我们定义一个包含所有所需过程的实现的结构，而不是<code>class</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data Figure = Figure &#123; </span><br><span class="line">	draw :: IO (),</span><br><span class="line">        move :: Displacement -&gt; IO ()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Displacement = (Int, Int)  -- horizontal and vertical displacement in points</span><br></pre></td></tr></table></figure></p>
<p>每个图形类型的构造函数应该只返回一个Figure记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">circle    :: Point -&gt; Radius -&gt; IO Figure -- 圆 </span><br><span class="line">rectangle :: Point -&gt; Point -&gt; IO Figure  -- 矩形</span><br><span class="line"></span><br><span class="line">type Point = (Int, Int)  -- 点坐标</span><br><span class="line">type Radius = Int        -- 以圆为单位的圆半径</span><br></pre></td></tr></table></figure></p>
<p>我们将通过打印当前参数来绘制<code>draw</code>图。让我们从<code>circle</code>和<code>rectangle</code>构造函数的简化实现开始，而不需要实际的<code>move</code>支持:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">circle center radius = do</span><br><span class="line">    let description = &quot;  Circle at &quot;++show center++&quot; with radius &quot;++show radius</span><br><span class="line">    return $ Figure &#123; draw = putStrLn description &#125;</span><br><span class="line"></span><br><span class="line">rectangle from to = do</span><br><span class="line">    let description = &quot;  Rectangle &quot;++show from++&quot;-&quot;++show to)</span><br><span class="line">    return $ Figure &#123; draw = putStrLn description &#125;</span><br></pre></td></tr></table></figure></p>
<p>如您所见，每个构造函数只返回一个固定的绘图<code>draw</code>过程，该过程打印用于创建具体图形的参数。我们来测试一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">drawAll :: [Figure] -&gt; IO ()</span><br><span class="line">drawAll figures = do putStrLn &quot;Drawing figures:&quot;</span><br><span class="line">                     mapM_ draw figures</span><br><span class="line"></span><br><span class="line">main = do figures &lt;- sequence [circle (10,10) 5,</span><br><span class="line">                               circle (20,20) 3,</span><br><span class="line">                               rectangle (10,10) (20,20),</span><br><span class="line">                               rectangle (15,15) (40,40)]</span><br><span class="line">          drawAll figures</span><br></pre></td></tr></table></figure></p>
<p>现在让我们定义可以实际移动的”全功能full-featured”图。为了实现这一点，我们应该为每个图形提供一个可变变量，用于保存每个图形的当前屏幕位置。该变量的类型为<code>IORef Point</code>。该变量应该在图构造函数中创建，并在图记录中包含的IO过程(闭包)中进行操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">circle center radius = do</span><br><span class="line">    centerVar &lt;- newIORef center</span><br><span class="line"></span><br><span class="line">    let drawF = do center &lt;- readIORef centerVar</span><br><span class="line">                   putStrLn (&quot;  Circle at &quot;++show center</span><br><span class="line">                             ++&quot; with radius &quot;++show radius)</span><br><span class="line"></span><br><span class="line">    let moveF (addX,addY) = do (x,y) &lt;- readIORef centerVar</span><br><span class="line">                   writeIORef centerVar (x+addX, y+addY)</span><br><span class="line"></span><br><span class="line">    return $ Figure &#123; draw=drawF, move=moveF &#125;</span><br><span class="line"></span><br><span class="line">rectangle from to = do</span><br><span class="line">    fromVar &lt;- newIORef from</span><br><span class="line">    toVar   &lt;- newIORef to</span><br><span class="line"></span><br><span class="line">    let drawF = do from &lt;- readIORef fromVar</span><br><span class="line">                   to   &lt;- readIORef toVar</span><br><span class="line">                   putStrLn (&quot;  Rectangle &quot;++show from++&quot;-&quot;++show to)</span><br><span class="line"></span><br><span class="line">    let moveF (addX,addY) = do (fromX,fromY) &lt;- readIORef fromVar</span><br><span class="line">                               (toX,toY)     &lt;- readIORef toVar</span><br><span class="line">                               writeIORef fromVar (fromX+addX, fromY+addY)</span><br><span class="line">                               writeIORef toVar   (toX+addX, toY+addY)</span><br><span class="line"></span><br><span class="line">    return $ Figure &#123; draw=drawF, move=moveF &#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们可以测试移动图的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main = do figures &lt;- sequence [circle (10,10) 5,</span><br><span class="line">                               rectangle (10,10) (20,20)]</span><br><span class="line">          drawAll figures</span><br><span class="line">          mapM_ (\fig -&gt; move fig (10,10)) figures</span><br><span class="line">          drawAll figures</span><br></pre></td></tr></table></figure></p>
<p>重要的是要意识到我们不仅限于在一个旨在模拟C++/Java风格接口的记录中仅包含IO action。记录还可以包括值，IORefs，纯函数 - 简而言之，任何类型的数据。例如，我们可以轻松地将area和origin字段添加到图形接口中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data Figure = Figure &#123; draw :: IO (),</span><br><span class="line">                       move :: Displacement -&gt; IO (),</span><br><span class="line">                       area :: Double,</span><br><span class="line">                       origin :: IORef Point</span><br><span class="line">                     &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h4 id="与C-C-和外部库的接口"><a href="#与C-C-和外部库的接口" class="headerlink" title="与C/C++和外部库的接口"></a>与C/C++和外部库的接口</h4><h4 id="IO-monad的黑暗面"><a href="#IO-monad的黑暗面" class="headerlink" title="IO monad的黑暗面"></a>IO monad的黑暗面</h4><h5 id="unsafePerformIO"><a href="#unsafePerformIO" class="headerlink" title="unsafePerformIO"></a>unsafePerformIO</h5><p>来自命令式语言背景的程序员经常寻找在纯过程中执行IO操作的方法。但是，这是什么意思? 想象一下，您正在尝试编写一个读取具有给定名称的文件内容的过程，并尝试将其写为纯（非IO）函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readContents :: Filename -&gt; String</span><br></pre></td></tr></table></figure></p>
<p>将readContents定义为纯函数肯定会简化使用它的代码。但它也会给编译器带来问题：</p>
<ul>
<li>此调用未插入”world转换”序列中,因此编译器不知道您希望何时执行此操作。例如,如果文件在程序开头有一种内容而另一种在结尾 - 你想看哪些内容？您不知道何时(或者甚至是)将要调用此函数,因为Haskell将此函数视为纯函数,并且可以根据需要重新排序任何或所有纯函数的执行。</li>
<li>尽管可以在调用之间改变文件(或当前目录),但是可以考虑尝试读取具有相同名称的文件的内容(即,减少到单个调用)。同样,Haskell认为所有非IO函数都是纯粹的,并且可以随意省略具有相同参数的多个调用。<br>因此,实现与真实世界交互的纯函数被认为是不良的行为,好男孩和女孩从来没有这样做;<br>然而,有(半官方)方法在纯函数内部使用IO动作。你应该记住,通过要求一个RealWorld接力棒去调用一个IO action是禁止的。<br>纯函数没有接力棒,但是有一个特殊的<code>magic</code>程序可以从不知名的地方产生这个”接力棒”,使用它来调用IO action,然后抛出所产生的<code>world</code>!这是一个有点低级魔法。这个非常特殊(危险)的程序是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsafePerformIO :: IO a -&gt; a</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>让我们来看看它的(可能的)定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unsafePerformIO :: (RealWorld -&gt; (a, RealWorld)) -&gt; a</span><br><span class="line">unsafePerformIO action = </span><br><span class="line">	let (a, world1) = action createNewWorld </span><br><span class="line">	in a</span><br></pre></td></tr></table></figure></p>
<p>其中<code>createNewWorld</code>是一个内部函数，产生RealWorld类型的新值。<br>使用<code>unsafePerformIO</code>,您可以轻松编写内部执行I/O的纯函数。但是不要在没有真正需要的情况下这样做,并记住遵循这条规则: 编译器不知道你在作弊;它仍然认为每个非IO功能都是纯粹的。因此,所有通常的优化规则都可以(并且将会)应用于其执行。所以你必须确保:</p>
<ul>
<li>每次调用的结果仅取决于其参数</li>
<li>您不依赖于此函数的副作用,如果不需要其结果,则该函数可能不会执行<br>让我们更深入地研究这个问题。Haskell中的函数评估由值的必要性决定 - 语言仅计算计算最终结果所需的值。但这对于<code>main</code>函数意味着什么呢?为了计算”最终world值”，您需要执行<code>main</code>链中包含的所有中间IO操作,通过使用<code>unsafePerformIO</code>,我们在此链之外调用IO操作,我们有什么保证可以运行它们？没有。只有在需要运行它们来计算整个函数结果时才会运行它们(这反过来也应该被要求在<code>main</code>链中执行一些操作)，这是Haskell按需评估策略的一个例子。现在你应该清楚地看到差异:</li>
<li>IO过程中的IO操作保证只要(直接或间接)在<code>main</code>链内执行 - 即使未使用其结果(因为它返回的隐式<code>world</code>值将被使用)。您可以直接在IO过程中指定操作的执行顺序。通过从每个IO操作传递到下一个IO操作的隐式<code>world</code>值来模拟数据依赖性。</li>
<li>只有在真正使用此操作的结果时,才会执行<code>unsafePerformIO</code>内的IO操作,评估顺序无法保证,您不应该依赖它(除非您确定可能存在任何数据依赖性)。<br>我还应该说，在<code>unsafePerformIO</code>调用中你可以在相同的绑定操作符<code>and/or</code>我们上面看到的<code>do</code>语法糖的帮助下组织一个小的内部IO actions链。<br>例如，这里有一个特别复杂的方法来计算0之后的整数:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">one :: Int</span><br><span class="line">one = unsafePerformIO $ do var &lt;- newIORef 0</span><br><span class="line">                           modifyIORef var (+1)</span><br><span class="line">                           readIORef var</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在这种情况下,只要需要<code>unsafePerformIO</code>调用的结果,就会执行该链中的所有操作。为了确保这一点,实际的<code>unsafePerformIO</code>实现会评估<code>action</code>返回的<code>world</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsafePerformIO action = let (a,world1) = action createNewWorld</span><br><span class="line">                         in (world1 `seq` a)</span><br></pre></td></tr></table></figure></p>
<p>(<code>seq</code>操作在返回第二个参数的值之前严格评估其第一个参数)</p>
<h5 id="inlinePerformIO"><a href="#inlinePerformIO" class="headerlink" title="inlinePerformIO"></a>inlinePerformIO</h5><p><code>inlinePerformIO</code>与<code>unsafePerformIO</code>具有相同的定义,但添加了<code>INLINE</code>编译指示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 就像unsafePerformIO一样,但我们内联它,大量的性能提升,因为它暴露了很多东西进一步内联</span><br><span class="line">&#123;-# INLINE inlinePerformIO #-&#125;</span><br><span class="line">inlinePerformIO action = let (a, world1) = action createNewWorld</span><br><span class="line">                         in (world1 `seq` a)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>语义上<code>inlinePerformIO = unsafePerformIO</code>，其中任何一个都有任何语义。<br>当然,不同之处在于<code>inlinePerformIO</code>比<code>unsafePerformIO</code>更不安全。虽然<code>ghc</code>将尽量不重复或共同使用<code>unsafePerformIO</code>的不同用途,但我们积极地内联<code>inlinePerformIO</code>。因此,实际上您只能在IO内容非常纯正的地方使用它,例如从不可变的内存缓冲区读取(如<code>ByteStrings</code>的情况),然而,分配新缓冲区之类的事情不应该在<code>inlinePerformIO</code>内部完成,因为它可以很容易地在整个程序中浮动并只执行一次，所以最终会有许多东西共享同一个缓冲区，这很糟糕。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">write :: Int -&gt; (Ptr Word8 -&gt; IO ()) -&gt; Put ()</span><br><span class="line">write !n body = Put $ \c buf@(Buffer fp o u l) -&gt;</span><br><span class="line">  if n &lt;= l</span><br><span class="line">    then write&apos; c fp o u l</span><br><span class="line">    else write&apos; (flushOld c n fp o u) (newBuffer c n) 0 0 0</span><br><span class="line"></span><br><span class="line">  where &#123;-# NOINLINE write&apos; #-&#125;</span><br><span class="line">        write&apos; c !fp !o !u !l =</span><br><span class="line">          -- warning: this is a tad hardcore</span><br><span class="line">          inlinePerformIO</span><br><span class="line">            (withForeignPtr fp</span><br><span class="line">              (\p -&gt; body $! (p `plusPtr` (o+u))))</span><br><span class="line">          `seq` c () (Buffer fp o (u+n) (l-n))</span><br></pre></td></tr></table></figure></p>
<p>它的使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">word8 w = write 1 (\p -&gt; poke p w)</span><br></pre></td></tr></table></figure></p>
<p>这不符合我的经验法则,不要问我们为什么声称它是安全的(如果有人真的想知道,请问<code>Ross Paterson</code>谁先在<code>Builder monoid</code>中做过)</p>
<h5 id="unsafeInterleaveIO"><a href="#unsafeInterleaveIO" class="headerlink" title="unsafeInterleaveIO"></a>unsafeInterleaveIO</h5><p>但是还有一个更奇怪的操作叫做<code>unsafeInterleaveIO</code>,它得到了”官方接力棒”,制作了自己的翻印副本,然后与main接力棒同时进行一场”非法”的接力比赛!我无法在不引起悲痛和愤慨的情况下进一步讨论它的行为,因此,在俄罗斯和中国等软件盗版的温床国家,这种操作被广泛使用也就不足为奇了!)别问我 —— 我不会再提我经常用的这种卑鄙的伎俩了。<br>可以使用<code>unsafePerformIO</code>(不是<code>unsafeInterleaveIO</code>)来执行I/O操作,而不是按预定义顺序执行I/O操作。例如,以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">do let c = unsafePerformIO getChar</span><br><span class="line">   do_proc c</span><br></pre></td></tr></table></figure></p>
<p>只有当代码确实需要<code>c</code>的值时才会执行<code>getChar I/O</code>调用,即它将像任何通常的Haskell计算一样懒惰地执行.<br>现在想象下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">do let s = [unsafePerformIO getChar, unsafePerformIO getChar, unsafePerformIO getChar]</span><br><span class="line">   do_proc s</span><br></pre></td></tr></table></figure></p>
<p>此列表中的三个字符也将按需计算,这意味着它们的值将取决于它们的消耗顺序。这通常不是我们需要的。<br><code>unsafeInterleaveIO</code>解决了这个问题 - 它只在需要时执行I/O,但允许为数据结构的各个部分定义精确的<em>内部</em>执行顺序。这就是为什么我写道<code>unsafeInterleaveIO</code>制作非法复制的接力棒。</p>
<p>首先,<code>unsafeInterleaveIO</code>将<code>(IO a)</code>action 作为参数并返回类型为<code>a</code>的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do str &lt;- unsafeInterleaveIO myGetContents</span><br></pre></td></tr></table></figure></p>
<p>其次,<code>unsafeInterleaveIO</code>不会立即执行任何操作,它只创建一个类型为<code>a</code>的盒子,在请求此值时将执行指定为参数的操作。<br>第三,这个action本身可以立即计算整个值或者……再次使用<code>unsafeInterleaveIO</code>推迟计算一些子组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myGetContents = do</span><br><span class="line">   c &lt;- getChar</span><br><span class="line">   s &lt;- unsafeInterleaveIO myGetContents</span><br><span class="line">   return (c:s)</span><br></pre></td></tr></table></figure></p>
<p>此代码仅在确实需要<code>str</code>的值时执行,在这一刻,将执行<code>getChar</code>(结果分配给<code>c</code>),并且将创建一个更懒的IO盒子<code>s</code>。 此盒子再次包含指向<code>myGetContents</code>调用的链接<br>然后,返回一个包含<code>char read</code>的list单元格,并链接到<code>myGetContents</code>调用(作为计算列表其余部分的方法)。<br>仅当需要list中的下一个值时,才会再次执行此操作。<br>作为最终结果,我们无法在读取第一个之前读取到列表中的第二个字符,而是读取整个列表的懒惰字符。答对了！</p>
<p>PS:当然，实际代码应该包括EOF检查。请注意，你可以在每次通话中读取多个字符/记录:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myGetContents = do</span><br><span class="line">   c &lt;- replicateM 512 getChar</span><br><span class="line">   s &lt;- unsafeInterleaveIO myGetContents</span><br><span class="line">   return (c++s)</span><br></pre></td></tr></table></figure></p>
<h4 id="更安全的方法-ST-monad"><a href="#更安全的方法-ST-monad" class="headerlink" title="更安全的方法: ST monad"></a>更安全的方法: ST monad</h4><p>我们之前说过，我们可以使用<code>unsafePerformIO</code>来执行完全纯粹但仍以某种方式与真实世界交互的计算。但是，还有更好的方法! 它保持了完全纯粹性，并且允许使用引用/数组等等 - 并且它已经完成了使用，你猜对了，类型魔法。这是<code>ST monad</code>。<br><code>ST monad</code>的<code>unsafePerformIO</code>版本称为<code>runST</code>,它有一种非常不寻常的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runST :: (forall s . ST s a) -&gt; a</span><br></pre></td></tr></table></figure></p>
<p><code>ST monad中</code>的<code>s</code>变量是状态类型。此外,<code>ST monad</code>中可用的所有有趣的可变内容都是通过<code>s</code>来量化的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newSTRef :: a -&gt; ST s (STRef s a)</span><br><span class="line">newArray_ :: Ix i =&gt; (i, i) -&gt; ST s (STArray s i e)</span><br></pre></td></tr></table></figure></p>
<p>那么为什么<code>runST</code>有这么时髦的类型呢？让我们看看如果我们写下会发生什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">makeSTRef :: a -&gt; STRef s a</span><br><span class="line">makeSTRef a = runST (newSTRef a)</span><br></pre></td></tr></table></figure></p>
<p>这将失败,因为<code>newSTRef a</code>并不适用于所有状态类型<code>s</code> —— 它只适用于返回类型<code>STRef s a</code>的<code>s</code>。<br>这有点古怪,但结果是,您只能运行一个<code>ST</code>计算,其中输出类型在功能上是纯的,并且不引用计算的内部可变状态,<code>ST monad</code>也不能访问I/O操作,比如写入控制台 —— 只有引用、数组之类的操作才能方便地进行纯计算。<br>重要提示 - <code>state</code>类型实际上并不意味着什么。例如，我们从未拥有类型<code>s</code>的值。这只是让类型系统通过烟雾和镜子来确保我们的纯度工作的一种方式。<br>它实际上只是一种类型系统魔法:在内部,<code>runST</code>像<code>unsafePerformIO</code>一样，用真实世界的接力棒运行计算。它们的内部实现几乎是相同的, 事实上,有一个函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stToIO :: ST RealWorld a -&gt; IO a</span><br></pre></td></tr></table></figure></p>
<p>不同之处在于<code>ST</code>使用类型系统魔法禁止不安全行为,例如从安全<code>ST</code>包装中提取可变对象,但是允许使用对可变引用和数组的所有方便访问来执行纯函数输出。<br>下面是我们如何用上面的<code>unsafePerformIO</code>重写我们的函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">oneST :: ST s Int -- note that this works correctly for any s</span><br><span class="line">oneST = do var &lt;- newSTRef 0</span><br><span class="line">           modifySTRef var (+1)</span><br><span class="line">           readSTRef var</span><br><span class="line"></span><br><span class="line">one :: Int</span><br><span class="line">one = runST oneST</span><br></pre></td></tr></table></figure></p>
<h4 id="欢迎来到机器-实际的GHC实现"><a href="#欢迎来到机器-实际的GHC实现" class="headerlink" title="欢迎来到机器: 实际的GHC实现"></a>欢迎来到机器: 实际的GHC实现</h4><p>一个小小的免责声明: 我应该说我并没有在这里详细描述monad是什么(我自己甚至都不完全理解它)而且我的解释只显示了在Haskell中实现<code>IO monad</code>的一种可能方式。例如,<code>hbc Haskell</code>编译器和<code>Hugs</code>解释器通过<code>continuation</code>实现<code>IO monad</code>。我还没有谈到异常处理,这是<code>monad</code>概念的一个自然部分。您可以阅读”All About Monads”指南,了解有关这些主题的更多信息。<br>但有一些好消息:首先,你刚刚获得的<code>IO monad</code>理解将适用于任何许多其他<code>monad</code>的实现。您只是无法直接使用<code>RealWorld</code>值。<br>其次,这里描述的<code>IO monad</code>实现实际上是在<code>GHC、yhc/nhc (jhc?)</code>编译器中使用的。下面是GHC来源的IO定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newtype IO a = IO (State# RealWorld -&gt; (# State# RealWorld, a #))</span><br></pre></td></tr></table></figure></p>
<p>它使用<code>State# RealWorld</code>类型而不是我们的<code>RealWorld</code>,它使用<code>(# #)</code>严格的元组进行优化,并围绕该类型添加一个IO数据构造函数。然而,从我们的解释来看,并没有什么重大的变化。了解了通过<code>伪装world状态</code>值”链接”IO操作的原则,您现在可以轻松理解和编写<code>GHC I/O</code>操作的底层实现。</p>
<h5 id="Yhc-nhc98-实现"><a href="#Yhc-nhc98-实现" class="headerlink" title="Yhc/nhc98 实现"></a>Yhc/nhc98 实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data World = World</span><br><span class="line">newtype IO a = IO (World -&gt; Either IOError a)</span><br></pre></td></tr></table></figure>
<p>这个实现使<code>World</code>在某种程度上消失,并返回类型为<code>a</code>的结果,或者如果出现错误,则返回<code>IOError</code>。只有当编译器知道IO类型的一些特殊信息,并且不会对其进行过度优化时,函数右边才会缺少<code>World</code>。</p>
<h4 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h4><h4 id="to-do列表"><a href="#to-do列表" class="headerlink" title="to-do列表"></a>to-do列表</h4>
        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/blog/js/index.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/blog/js/gitment.js"></script>
<script>
    var gitment = new Gitment({
        id: '深入理解Haskell-IO',
        owner: 'limengyu1990',
        repo: 'hexo-blog',
        oauth: {
            client_id: '7cfc73dd62b57f07ed83',
            client_secret: 'dd03b7e54aadf0d81e4c9c93e23a41272bcfcfa1',
        },
    })
    gitment.render('comment-container')
</script>

</html>
