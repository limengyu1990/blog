<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        Haskell-Template-Haskell - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 我，Lionel Messi，我不是天生强大，我只是天生要强。 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>不负如来不负卿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Perils-of-Metaprogramming-元编程的危险"><span class="toc-text">Perils of Metaprogramming (元编程的危险)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Quasiquotation"><span class="toc-text">Quasiquotation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#language-c-quote"><span class="toc-text">language-c-quote</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Template-Haskell"><span class="toc-text">Template Haskell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Antiquotation"><span class="toc-text">Antiquotation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Templated-Type-Families"><span class="toc-text">Templated Type Families</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Templated-Type-Classes"><span class="toc-text">Templated Type Classes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Multiline-Strings"><span class="toc-text">Multiline Strings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-embed-嵌入"><span class="toc-text">git-embed (嵌入)</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 我，Lionel Messi，我不是天生强大，我只是天生要强。 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Haskell-Template-Haskell
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-10-16 19:26:15</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/blog/tags/#Wish-Knew" title="Wish-Knew">Wish-Knew</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Haskell" title="Haskell">Haskell</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Template-Haskell" title="Template-Haskell">Template-Haskell</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p>这是高级部分，编写Haskell通常无需了解<a href="http://dev.stephendiehl.com/hask/#template-haskell" target="_blank" rel="noopener">TemplateHaskell</a>。</p>
</blockquote>
<h3 id="Perils-of-Metaprogramming-元编程的危险"><a href="#Perils-of-Metaprogramming-元编程的危险" class="headerlink" title="Perils of Metaprogramming (元编程的危险)"></a>Perils of Metaprogramming (元编程的危险)</h3><p><code>Template Haskell</code>是一组非常强大的抽象，有些人可能会说它太强大了。它有效地允许我们在编译时运行任意代码来生成其他<code>haskell</code>代码。你可以做一些非常疯狂的事情，比如从文件系统中读取，或者做一些网络调用来通知你的代码如何编译，从而导致不确定的构建。</p>
<p>虽然在某些极端情况下这是有用的，但在生产环境中使用时需要谨慎。<code>TemplateHaskell</code>可以导致构建时间的增长而不受绑定，迫使您手动对模块的所有定义进行排序，并且通常会生成无法维护的代码。如果你发现自己又回到元编程上来了，问问自己，在我的抽象中，什么让我失败了，以至于我唯一的选择是编写可编写代码的代码。</p>
<blockquote>
<p>在启用TemplateHaskell之前，应使用注意事项。 首先考虑惯用的解决方案。</p>
</blockquote>
<h3 id="Quasiquotation"><a href="#Quasiquotation" class="headerlink" title="Quasiquotation"></a>Quasiquotation</h3><p><code>Quasiquotation</code>允许我们表达<code>quoted</code>的语法块，这些语法块不一定是宿主语言的语法，但与只编写一个巨大的字符串不同，它被解析为宿主语言中的一些<code>AST</code>数据类型。<br>值得注意的是，来自宿主语言的值可以通过用户可定义的逻辑注入到自定义语言中，从而允许信息在两种语言之间流动。</p>
<p>实际上，<code>Quasiquotation</code>可用于实现定制的特定于領域的语言或完全通过代码生成与其他通用语言集成。</p>
<p>我们已经了解了如何编写<code>Parsec</code>解析器，现在让我们为其编写一个<code>Quasiquotation</code>程序。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE QuasiQuotes #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TemplateHaskell #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Quasiquote <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Language.Haskell.TH</span><br><span class="line"><span class="keyword">import</span> Language.Haskell.TH.Syntax</span><br><span class="line"><span class="keyword">import</span> Language.Haskell.TH.Quote</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Text.Parsec</span><br><span class="line"><span class="keyword">import</span> Text.Parsec.String (<span class="type">Parser</span>)</span><br><span class="line"><span class="keyword">import</span> Text.Parsec.Language (<span class="title">emptyDef</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Text.Parsec.Expr <span class="keyword">as</span> Ex</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Text.Parsec.Token <span class="keyword">as</span> Tok</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Control.Monad.Identity</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span></span></span><br><span class="line">  = <span class="type">Tr</span></span><br><span class="line">  | <span class="type">Fl</span></span><br><span class="line">  | <span class="type">Zero</span></span><br><span class="line">  | <span class="type">Succ</span> <span class="type">Expr</span></span><br><span class="line">  | <span class="type">Pred</span> <span class="type">Expr</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Lift</span> <span class="type">Expr</span> <span class="keyword">where</span></span></span><br><span class="line">  lift <span class="type">Tr</span>         = [| <span class="type">Tr</span> |]</span><br><span class="line">  lift <span class="type">Fl</span>         = [| <span class="type">Tr</span> |]</span><br><span class="line">  lift <span class="type">Zero</span>       = [| <span class="type">Zero</span> |]</span><br><span class="line">  lift (<span class="type">Succ</span> a)   = [| <span class="type">Succ</span> a |]</span><br><span class="line">  lift (<span class="type">Pred</span> a)   = [| <span class="type">Pred</span> a |]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Op</span> = <span class="type">Ex</span>.<span class="type">Operator</span> <span class="type">String</span> () <span class="type">Identity</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">lexer</span> :: <span class="type">Tok</span>.<span class="type">TokenParser</span> ()</span><br><span class="line"><span class="title">lexer</span> = <span class="type">Tok</span>.makeTokenParser emptyDef</span><br><span class="line"></span><br><span class="line"><span class="title">parens</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> a</span><br><span class="line"><span class="title">parens</span> = <span class="type">Tok</span>.parens lexer</span><br><span class="line"></span><br><span class="line"><span class="title">reserved</span> :: <span class="type">String</span> -&gt; <span class="type">Parser</span> ()</span><br><span class="line"><span class="title">reserved</span> = <span class="type">Tok</span>.reserved lexer</span><br><span class="line"></span><br><span class="line"><span class="title">semiSep</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> [a]</span><br><span class="line"><span class="title">semiSep</span> = <span class="type">Tok</span>.semiSep lexer</span><br><span class="line"></span><br><span class="line"><span class="title">reservedOp</span> :: <span class="type">String</span> -&gt; <span class="type">Parser</span> ()</span><br><span class="line"><span class="title">reservedOp</span> = <span class="type">Tok</span>.reservedOp lexer</span><br><span class="line"></span><br><span class="line"><span class="title">prefixOp</span> :: <span class="type">String</span> -&gt; (a -&gt; a) -&gt; <span class="type">Op</span> a</span><br><span class="line"><span class="title">prefixOp</span> x f = <span class="type">Ex</span>.<span class="type">Prefix</span> (reservedOp x &gt;&gt; return f)</span><br><span class="line"></span><br><span class="line"><span class="title">table</span> :: [[<span class="type">Op</span> <span class="type">Expr</span>]]</span><br><span class="line"><span class="title">table</span> = [</span><br><span class="line">    [ prefixOp <span class="string">"succ"</span> <span class="type">Succ</span></span><br><span class="line">    , prefixOp <span class="string">"pred"</span> <span class="type">Pred</span></span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="title">expr</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">expr</span> = <span class="type">Ex</span>.buildExpressionParser table factor</span><br><span class="line"></span><br><span class="line"><span class="title">true</span>, false, zero :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">true</span>  = reserved <span class="string">"true"</span> &gt;&gt; return <span class="type">Tr</span></span><br><span class="line"><span class="title">false</span> = reserved <span class="string">"false"</span> &gt;&gt; return <span class="type">Fl</span></span><br><span class="line"><span class="title">zero</span>  = reservedOp <span class="string">"0"</span> &gt;&gt; return <span class="type">Zero</span></span><br><span class="line"></span><br><span class="line"><span class="title">factor</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">factor</span> =</span><br><span class="line">      true</span><br><span class="line">  &lt;|&gt; false</span><br><span class="line">  &lt;|&gt; zero</span><br><span class="line">  &lt;|&gt; parens expr</span><br><span class="line"></span><br><span class="line"><span class="title">contents</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> a</span><br><span class="line"><span class="title">contents</span> p = <span class="keyword">do</span></span><br><span class="line">  <span class="type">Tok</span>.whiteSpace lexer</span><br><span class="line">  r &lt;- p</span><br><span class="line">  eof</span><br><span class="line">  return r</span><br><span class="line"></span><br><span class="line"><span class="title">toplevel</span> :: <span class="type">Parser</span> [<span class="type">Expr</span>]</span><br><span class="line"><span class="title">toplevel</span> = semiSep expr</span><br><span class="line"></span><br><span class="line"><span class="title">parseExpr</span> :: <span class="type">String</span> -&gt; <span class="type">Either</span> <span class="type">ParseError</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">parseExpr</span> s = parse (contents expr) <span class="string">"&lt;stdin&gt;"</span> s</span><br><span class="line"></span><br><span class="line"><span class="title">parseToplevel</span> :: <span class="type">String</span> -&gt; <span class="type">Either</span> <span class="type">ParseError</span> [<span class="type">Expr</span>]</span><br><span class="line"><span class="title">parseToplevel</span> s = parse (contents toplevel) <span class="string">"&lt;stdin&gt;"</span> s</span><br><span class="line"></span><br><span class="line"><span class="title">calcExpr</span> :: <span class="type">String</span> -&gt; <span class="type">Q</span> <span class="type">Exp</span></span><br><span class="line"><span class="title">calcExpr</span> str = <span class="keyword">do</span></span><br><span class="line">  filename &lt;- loc_filename `fmap` location</span><br><span class="line">  <span class="keyword">case</span> parse (contents expr) filename str <span class="keyword">of</span></span><br><span class="line">    <span class="type">Left</span> err -&gt; error (show err)</span><br><span class="line">    <span class="type">Right</span> tag -&gt; [| tag |]</span><br><span class="line"></span><br><span class="line"><span class="title">calc</span> :: <span class="type">QuasiQuoter</span></span><br><span class="line"><span class="title">calc</span> = <span class="type">QuasiQuoter</span> calcExpr err err err</span><br><span class="line">  <span class="keyword">where</span> err = error <span class="string">"Only defined for values"</span></span><br></pre></td></tr></table></figure></p>
<p>测试一下:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE QuasiQuotes #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Quasiquote</span><br><span class="line"></span><br><span class="line"><span class="title">a</span> :: <span class="type">Expr</span></span><br><span class="line"><span class="title">a</span> = [calc|true|]</span><br><span class="line"><span class="comment">-- Tr</span></span><br><span class="line"></span><br><span class="line"><span class="title">b</span> :: <span class="type">Expr</span></span><br><span class="line"><span class="title">b</span> = [calc|succ (succ <span class="number">0</span>)|]</span><br><span class="line"><span class="comment">-- Succ (Succ Zero)</span></span><br><span class="line"></span><br><span class="line"><span class="title">c</span> :: <span class="type">Expr</span></span><br><span class="line"><span class="title">c</span> = [calc|pred (succ <span class="number">0</span>)|]</span><br><span class="line"><span class="comment">-- Pred (Succ Zero)</span></span><br></pre></td></tr></table></figure></p>
<p>一项非常重要的特性是保留位置信息的能力，以便可以将嵌入语言中的错误追溯到宿主语法的这一行。</p>
<h3 id="language-c-quote"><a href="#language-c-quote" class="headerlink" title="language-c-quote"></a>language-c-quote</h3><p>当然，由于我们可以为引用的表达式提供一个任意的解析器，因此可以考虑完全嵌入另一种语言的<code>AST</code>。例如<code>C</code>或<code>CUDA C</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">hello</span> :: <span class="type">String</span> -&gt; <span class="type">C</span>.<span class="type">Func</span></span><br><span class="line"><span class="title">hello</span> msg = [cfun|</span><br><span class="line"></span><br><span class="line"><span class="title">int</span> main(int argc, const char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf($msg);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|]</span><br></pre></td></tr></table></figure></p>
<p>对此进行评估，我们获得了引用的<code>C</code>程序的<code>AST</code>表示，可以使用<code>ppr</code>函数对其进行操作或打印回文本<code>C</code>代码:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Func</span></span><br><span class="line">  (<span class="type">DeclSpec</span> [] [] (<span class="type">Tint</span> <span class="type">Nothing</span>))</span><br><span class="line">  (<span class="type">Id</span> <span class="string">"main"</span>)</span><br><span class="line">  <span class="type">DeclRoot</span></span><br><span class="line">  (<span class="type">Params</span></span><br><span class="line">     [ <span class="type">Param</span> (<span class="type">Just</span> (<span class="type">Id</span> <span class="string">"argc"</span>)) (<span class="type">DeclSpec</span> [] [] (<span class="type">Tint</span> <span class="type">Nothing</span>)) <span class="type">DeclRoot</span></span><br><span class="line">     , <span class="type">Param</span></span><br><span class="line">         (<span class="type">Just</span> (<span class="type">Id</span> <span class="string">"argv"</span>))</span><br><span class="line">         (<span class="type">DeclSpec</span> [] [ <span class="type">Tconst</span> ] (<span class="type">Tchar</span> <span class="type">Nothing</span>))</span><br><span class="line">         (<span class="type">Array</span> [] <span class="type">NoArraySize</span> (<span class="type">Ptr</span> [] <span class="type">DeclRoot</span>))</span><br><span class="line">     ]</span><br><span class="line">     <span class="type">False</span>)</span><br><span class="line">  [ <span class="type">BlockStm</span></span><br><span class="line">      (<span class="type">Exp</span></span><br><span class="line">         (<span class="type">Just</span></span><br><span class="line">            (<span class="type">FnCall</span></span><br><span class="line">               (<span class="type">Var</span> (<span class="type">Id</span> <span class="string">"printf"</span>))</span><br><span class="line">               [ <span class="type">Const</span> (<span class="type">StringConst</span> [ <span class="string">"\"Hello Haskell!\""</span> ] <span class="string">"Hello Haskell!"</span>)</span><br><span class="line">               ])))</span><br><span class="line">  , <span class="type">BlockStm</span> (<span class="type">Return</span> (<span class="type">Just</span> (<span class="type">Const</span> (<span class="type">IntConst</span> <span class="string">"0"</span> <span class="type">Signed</span> <span class="number">0</span>))))</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，我们只是在<code>printf</code>语句中拼接了反引号的<code>Haskell</code>字符串，但是我们可以在引号表达式之间传递许多其他值，包括标识符，数字和其他实现<code>Lift</code>类型类的引号表达式。</p>
<p>例如，现在，如果我们想以编程方式生成<code>CUDA</code>内核的源代码以在<code>GPU</code>上运行，我们可以切换<code>CUDA C</code>语言以发出<code>C</code>代码。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE QuasiQuotes #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TemplateHaskell #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Text.PrettyPrint.Mainland</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Language.C.Syntax <span class="keyword">as</span> C</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Language.C.Quote.CUDA <span class="keyword">as</span> Cuda</span><br><span class="line"></span><br><span class="line"><span class="title">cuda_fun</span> :: <span class="type">String</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">C</span>.<span class="type">Func</span></span><br><span class="line"><span class="title">cuda_fun</span> fn n a = [<span class="type">Cuda</span>.cfun|</span><br><span class="line"></span><br><span class="line"><span class="title">__global__</span> void $id:fn (float *x, float *y) &#123;</span><br><span class="line">  int i = blockIdx.x*blockDim.x + threadIdx.x;</span><br><span class="line">  <span class="keyword">if</span> ( i&lt;$n ) &#123; y[i] = $a*x[i] + y[i]; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|]</span><br><span class="line"></span><br><span class="line"><span class="title">cuda_driver</span> :: <span class="type">String</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">C</span>.<span class="type">Func</span></span><br><span class="line"><span class="title">cuda_driver</span> fn n = [<span class="type">Cuda</span>.cfun|</span><br><span class="line"></span><br><span class="line"><span class="title">void</span> driver (float *x, float *y) &#123;</span><br><span class="line">  float *d_x, *d_y;</span><br><span class="line"></span><br><span class="line">  cudaMalloc(&amp;d_x, $n*sizeof(float));</span><br><span class="line">  cudaMalloc(&amp;d_y, $n*sizeof(float));</span><br><span class="line"></span><br><span class="line">  cudaMemcpy(d_x, x, $n, cudaMemcpyHostToDevice);</span><br><span class="line">  cudaMemcpy(d_y, y, $n, cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">  $id:fn&lt;&lt;&lt;($n+<span class="number">255</span>)/<span class="number">256</span>, <span class="number">256</span>&gt;&gt;&gt;(d_x, d_y);</span><br><span class="line"></span><br><span class="line">  cudaFree(d_x);</span><br><span class="line">  cudaFree(d_y);</span><br><span class="line">  return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">|]</span><br><span class="line"></span><br><span class="line"><span class="title">makeKernel</span> :: <span class="type">String</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Int</span> -&gt; [<span class="type">C</span>.<span class="type">Func</span>]</span><br><span class="line"><span class="title">makeKernel</span> fn a n = [</span><br><span class="line">    cuda_fun fn n a</span><br><span class="line">  , cuda_driver fn n</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">let</span> ker = makeKernel <span class="string">"saxpy"</span> <span class="number">2</span> <span class="number">65536</span></span><br><span class="line">  mapM_ (print . ppr) ker</span><br></pre></td></tr></table></figure></p>
<p>运行此代碼生成:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">saxpy</span><span class="params">(<span class="keyword">float</span>* x, <span class="keyword">float</span>* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">65536</span>) &#123;</span><br><span class="line">        y[i] = <span class="number">2.0</span> * x[i] + y[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver</span><span class="params">(<span class="keyword">float</span>* x, <span class="keyword">float</span>* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span>* d_x, * d_y;</span><br><span class="line"></span><br><span class="line">    cudaMalloc(&amp;d_x, <span class="number">65536</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    cudaMalloc(&amp;d_y, <span class="number">65536</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    cudaMemcpy(d_x, x, <span class="number">65536</span>, cudaMemcpyHostToDevice);</span><br><span class="line">    cudaMemcpy(d_y, y, <span class="number">65536</span>, cudaMemcpyHostToDevice);</span><br><span class="line">    saxpy&lt;&lt;&lt;(<span class="number">65536</span> + <span class="number">255</span>) / <span class="number">256</span>, <span class="number">256</span>&gt;&gt;&gt;(d_x, d_y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>nvcc -ptx -c</code>运行结果输出，以获得与输出代码相关联的<code>PTX</code>.</p>
<h3 id="Template-Haskell"><a href="#Template-Haskell" class="headerlink" title="Template Haskell"></a>Template Haskell</h3><p>当然，最有用的<code>quasiquotation</code>是从<code>Haskell</code>内部程序生成<code>Haskell</code>代码本身的能力。<br><code>template-haskell</code>框架为<code>quotation</code>(引句)提供了四个入口点，以生成各种类型的<code>Haskell</code>声明和表达式。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Type</span>	    <span class="type">Quasiquoted</span>	    <span class="type">Class</span></span><br><span class="line"><span class="comment">----------------------------------------</span></span><br><span class="line"><span class="type">Q</span> <span class="type">Exp</span>	    [e| ... |]	    expression</span><br><span class="line"><span class="type">Q</span> <span class="type">Pat</span>	    [p| ... |]	    pattern</span><br><span class="line"><span class="type">Q</span> <span class="type">Type</span>	    [t| ... |]	    <span class="class"><span class="keyword">type</span></span></span><br><span class="line"><span class="type">Q</span> [<span class="type">Dec</span>]	    [d| ... |]	    declaration</span><br></pre></td></tr></table></figure></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">QuasiQuoter</span> = <span class="type">QuasiQuoter</span></span></span><br><span class="line">  &#123; quoteExp  :: <span class="type">String</span> -&gt; <span class="type">Q</span> <span class="type">Exp</span></span><br><span class="line">  , quotePat  :: <span class="type">String</span> -&gt; <span class="type">Q</span> <span class="type">Pat</span></span><br><span class="line">  , quoteType :: <span class="type">String</span> -&gt; <span class="type">Q</span> <span class="type">Type</span></span><br><span class="line">  , quoteDec  :: <span class="type">String</span> -&gt; <span class="type">Q</span> [<span class="type">Dec</span>]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>logic evaluating</code>(评估)，<code>splicing</code>(拼接)和<code>introspecting</code>(内省)编译时值的逻辑嵌入在<code>Q monad</code>中，后者具有一个<code>runQ</code>，可用于评估其上下文。此<code>monad</code>的这些功能已深深嵌入到<code>GHC</code>的实现中。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">runQ</span> :: <span class="type">Quasi</span> m =&gt; <span class="type">Q</span> a -&gt; m a</span><br><span class="line"><span class="title">runIO</span> :: <span class="type">IO</span> a -&gt; <span class="type">Q</span> a</span><br></pre></td></tr></table></figure></p>
<p>与以前一样，<code>TemplateHaskell</code>提供了使用<code>Lift</code>类型类将<code>Haskell</code>值提升为引用表达式内的<code>AST quantities</code>(数量)的功能。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Lift</span> t <span class="keyword">where</span></span></span><br><span class="line">  lift :: t -&gt; <span class="type">Q</span> <span class="type">Exp</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Lift</span> <span class="type">Integer</span> <span class="keyword">where</span></span></span><br><span class="line">  lift x = return (<span class="type">LitE</span> (<span class="type">IntegerL</span> x))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Lift</span> <span class="type">Int</span> <span class="keyword">where</span></span></span><br><span class="line">  lift x= return (<span class="type">LitE</span> (<span class="type">IntegerL</span> (fromIntegral x)))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Lift</span> <span class="type">Char</span> <span class="keyword">where</span></span></span><br><span class="line">  lift x = return (<span class="type">LitE</span> (<span class="type">CharL</span> x))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Lift</span> <span class="type">Bool</span> <span class="keyword">where</span></span></span><br><span class="line">  lift <span class="type">True</span>  = return (<span class="type">ConE</span> trueName)</span><br><span class="line">  lift <span class="type">False</span> = return (<span class="type">ConE</span> falseName)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Lift</span> a =&gt; <span class="type">Lift</span> (<span class="type">Maybe</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">  lift <span class="type">Nothing</span>  = return (<span class="type">ConE</span> nothingName)</span><br><span class="line">  lift (<span class="type">Just</span> x) = liftM (<span class="type">ConE</span> justName `<span class="type">AppE</span>`) (lift x)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Lift</span> a =&gt; <span class="type">Lift</span> [a] <span class="keyword">where</span></span></span><br><span class="line">  lift xs = <span class="keyword">do</span> &#123; xs' &lt;- mapM lift xs; return (<span class="type">ListE</span> xs') &#125;</span><br></pre></td></tr></table></figure></p>
<p>在许多情况下，<code>Template Haskell</code>可用于交互式探索各种<code>Haskell</code>语法的<code>AST</code>形式。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">λ: runQ [e| \x -&gt; x |]</span><br><span class="line"><span class="type">LamE</span> [<span class="type">VarP</span> x_2] (<span class="type">VarE</span> x_2)</span><br><span class="line"></span><br><span class="line">λ: runQ [d| <span class="class"><span class="keyword">data</span> <span class="type">Nat</span> = <span class="type">Z</span> | <span class="type">S</span> <span class="type">Nat</span> |]</span></span><br><span class="line">[<span class="type">DataD</span> [] <span class="type">Nat_0</span> [] [<span class="type">NormalC</span> <span class="type">Z_2</span> [],<span class="type">NormalC</span> <span class="type">S_1</span> [(<span class="type">NotStrict</span>,<span class="type">ConT</span> <span class="type">Nat_0</span>)]] []]</span><br><span class="line"></span><br><span class="line">λ: runQ [p| <span class="type">S</span> (<span class="type">S</span> <span class="type">Z</span>)|]</span><br><span class="line"><span class="type">ConP</span> <span class="type">Singleton</span>.<span class="type">S</span> [<span class="type">ConP</span> <span class="type">Singleton</span>.<span class="type">S</span> [<span class="type">ConP</span> <span class="type">Singleton</span>.<span class="type">Z</span> []]]</span><br><span class="line"></span><br><span class="line">λ: runQ [t| <span class="type">Int</span> -&gt; [<span class="type">Int</span>] |]</span><br><span class="line"><span class="type">AppT</span> (<span class="type">AppT</span> <span class="type">ArrowT</span> (<span class="type">ConT</span> <span class="type">GHC</span>.<span class="type">Types</span>.<span class="type">Int</span>)) (<span class="type">AppT</span> <span class="type">ListT</span> (<span class="type">ConT</span> <span class="type">GHC</span>.<span class="type">Types</span>.<span class="type">Int</span>))</span><br><span class="line"></span><br><span class="line">λ: <span class="keyword">let</span> g = $(runQ [| \x -&gt; x |])</span><br><span class="line"></span><br><span class="line">λ: g <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>使用<a href="http://hackage.haskell.org/package/template-haskell-2.4.0.0/docs/Language-Haskell-TH-Syntax.html#t:Dec" target="_blank" rel="noopener">Language.Haskell.TH</a>，我们可以将<code>Haskell AST</code>一个元素一个元素地拼凑在一起，但是需要遵循我们自己的自定义逻辑来生成代码。尽管<code>Haskell</code>的源语言(称为<code>HsSyn</code>)非常庞大，在其<code>AST</code>中大约有100个节点，其中许多节点都依赖于语言<code>pragmas</code>(编译指令)的状态，但这可能会有些痛苦。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- builds the function (f = \(a,b) -&gt; a)</span></span><br><span class="line"><span class="title">f</span> :: <span class="type">Q</span> [<span class="type">Dec</span>]</span><br><span class="line"><span class="title">f</span> = <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">let</span> f = mkName <span class="string">"f"</span></span><br><span class="line">  a &lt;- newName <span class="string">"a"</span></span><br><span class="line">  b &lt;- newName <span class="string">"b"</span></span><br><span class="line">  return [ <span class="type">FunD</span> f [ <span class="type">Clause</span> [<span class="type">TupP</span> [<span class="type">VarP</span> a, <span class="type">VarP</span> b]] (<span class="type">NormalB</span> (<span class="type">VarE</span> a)) [] ] ]</span><br><span class="line"><span class="title">my_id</span> :: a -&gt; a</span><br><span class="line"><span class="title">my_id</span> x = $( [| x |] )</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = print (my_id <span class="string">"Hello Haskell!"</span>)</span><br></pre></td></tr></table></figure></p>
<p>作为一种调试工具，能够交互式地将特定符号的<code>reified</code>(具体化)信息<code>dump</code>(转储)出来是很有用的，为此有一个简单的小技巧。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE QuasiQuotes #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TemplateHaskell #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Text.Show.Pretty (<span class="title">ppShow</span>)</span><br><span class="line"><span class="keyword">import</span> Language.Haskell.TH</span><br><span class="line"></span><br><span class="line"><span class="title">introspect</span> :: <span class="type">Name</span> -&gt; <span class="type">Q</span> <span class="type">Exp</span></span><br><span class="line"><span class="title">introspect</span> n = <span class="keyword">do</span></span><br><span class="line">  t &lt;- reify n</span><br><span class="line">  runIO $ putStrLn $ ppShow t</span><br><span class="line">  [| return () |]</span><br><span class="line">λ: $(introspect 'id)</span><br><span class="line"><span class="type">VarI</span></span><br><span class="line">  <span class="type">GHC</span>.<span class="type">Base</span>.id</span><br><span class="line">  (<span class="type">ForallT</span></span><br><span class="line">     [ <span class="type">PlainTV</span> a_1627405383 ]</span><br><span class="line">     []</span><br><span class="line">     (<span class="type">AppT</span> (<span class="type">AppT</span> <span class="type">ArrowT</span> (<span class="type">VarT</span> a_1627405383)) (<span class="type">VarT</span> a_1627405383)))</span><br><span class="line">  <span class="type">Nothing</span></span><br><span class="line">  (<span class="type">Fixity</span> <span class="number">9</span> <span class="type">InfixL</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">λ: $(introspect ''<span class="type">Maybe</span>)</span><br><span class="line"><span class="type">TyConI</span></span><br><span class="line">  (<span class="type">DataD</span></span><br><span class="line">     []</span><br><span class="line">     <span class="type">Data</span>.<span class="type">Maybe</span>.<span class="type">Maybe</span></span><br><span class="line">     [ <span class="type">PlainTV</span> a_1627399528 ]</span><br><span class="line">     [ <span class="type">NormalC</span> <span class="type">Data</span>.<span class="type">Maybe</span>.<span class="type">Nothing</span> []</span><br><span class="line">     , <span class="type">NormalC</span> <span class="type">Data</span>.<span class="type">Maybe</span>.<span class="type">Just</span> [ ( <span class="type">NotStrict</span> , <span class="type">VarT</span> a_1627399528 ) ]</span><br><span class="line">     ]</span><br><span class="line">     [])</span><br><span class="line"><span class="keyword">import</span> Language.Haskell.TH</span><br><span class="line"></span><br><span class="line"><span class="title">foo</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">foo</span> x = x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Bar</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">fooInfo</span> :: <span class="type">InfoQ</span></span><br><span class="line"><span class="title">fooInfo</span> = reify 'foo</span><br><span class="line"></span><br><span class="line"><span class="title">barInfo</span> :: <span class="type">InfoQ</span></span><br><span class="line"><span class="title">barInfo</span> = reify ''<span class="type">Bar</span></span><br><span class="line">$( [d| <span class="class"><span class="keyword">data</span> <span class="type">T</span> = <span class="type">T1</span> | <span class="type">T2</span> |] )</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = print [<span class="type">T1</span>, <span class="type">T2</span>]</span><br></pre></td></tr></table></figure></p>
<p><code>Splices</code>(拼接)由表达式级别的<code>$(f)</code>语法表示，而在顶层仅通过调用<code>template Haskell</code>函数来表示。运行带有<code>-ddump-splices</code>的<code>GHC</code>可以显示我们的代码在编译时被<code>spliced</code>(拼接)到<code>AST</code>中的特定位置。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$(f)</span><br><span class="line"></span><br><span class="line"><span class="title">template_haskell_show</span>.hs:<span class="number">1</span>:<span class="number">1</span>: <span class="type">Splicing</span> declarations</span><br><span class="line">    f</span><br><span class="line">  ======&gt;</span><br><span class="line">    template_haskell_show.hs:<span class="number">8</span>:<span class="number">3</span><span class="number">-10</span></span><br><span class="line">    f (a_a5bd, b_a5be) = a_a5bd</span><br><span class="line"><span class="meta">&#123;-# LANGUAGE QuasiQuotes #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TemplateHaskell #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Splice <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Language.Haskell.TH</span><br><span class="line"><span class="keyword">import</span> Language.Haskell.TH.Syntax</span><br><span class="line"></span><br><span class="line"><span class="title">spliceF</span> :: <span class="type">Q</span> [<span class="type">Dec</span>]</span><br><span class="line"><span class="title">spliceF</span> = <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">let</span> f = mkName <span class="string">"f"</span></span><br><span class="line">  a &lt;- newName <span class="string">"a"</span></span><br><span class="line">  b &lt;- newName <span class="string">"b"</span></span><br><span class="line">  return [ <span class="type">FunD</span> f [ <span class="type">Clause</span> [<span class="type">VarP</span> a, <span class="type">VarP</span> b] (<span class="type">NormalB</span> (<span class="type">VarE</span> a)) [] ] ]</span><br><span class="line"></span><br><span class="line"><span class="title">spliceG</span> :: <span class="type">Lift</span> a =&gt; a -&gt; <span class="type">Q</span> [<span class="type">Dec</span>]</span><br><span class="line"><span class="title">spliceG</span> n = runQ [d| g a = n |]</span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TemplateHaskell #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Splice</span><br><span class="line"></span><br><span class="line"><span class="title">spliceF</span></span><br><span class="line"><span class="title">spliceG</span> <span class="string">"argument"</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  print $ f <span class="number">1</span> <span class="number">2</span></span><br><span class="line">  print $ g ()</span><br></pre></td></tr></table></figure></p>
<p>在<code>splice</code>(拼接)点，使用的所有变量和类型都必须在作用域中，因此它必须出现在模块中它们的声明之后。因此，在使用<code>TemplateHaskell</code>时，我们通常必须在心理上对代码进行拓扑排序，以便按顺序定义声明。</p>
<p>請看:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH.html#t:Exp" target="_blank" rel="noopener">Template Haskell AST</a></li>
</ul>
<h3 id="Antiquotation"><a href="#Antiquotation" class="headerlink" title="Antiquotation"></a>Antiquotation</h3><p>既然我们有了<code>TemplateHaskell</code>机制，就可以从上面扩展我们的<code>quasiquotation</code>，我们可以实现用于传递<code>Haskell</code>值和通过在模板表达式上进行模式匹配将<code>Haskell</code>值拉出的同一类逻辑。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE QuasiQuotes #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TemplateHaskell #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DeriveDataTypeable #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Antiquote <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Generics</span><br><span class="line"><span class="keyword">import</span> Language.Haskell.TH</span><br><span class="line"><span class="keyword">import</span> Language.Haskell.TH.Quote</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Text.Parsec</span><br><span class="line"><span class="keyword">import</span> Text.Parsec.String (<span class="type">Parser</span>)</span><br><span class="line"><span class="keyword">import</span> Text.Parsec.Language (<span class="title">emptyDef</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Text.Parsec.Expr <span class="keyword">as</span> Ex</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Text.Parsec.Token <span class="keyword">as</span> Tok</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span></span></span><br><span class="line">  = <span class="type">Tr</span></span><br><span class="line">  | <span class="type">Fl</span></span><br><span class="line">  | <span class="type">Zero</span></span><br><span class="line">  | <span class="type">Succ</span> <span class="type">Expr</span></span><br><span class="line">  | <span class="type">Pred</span> <span class="type">Expr</span></span><br><span class="line">  | <span class="type">Antiquote</span> <span class="type">String</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>, <span class="type">Data</span>, <span class="type">Typeable</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">lexer</span> :: <span class="type">Tok</span>.<span class="type">TokenParser</span> ()</span><br><span class="line"><span class="title">lexer</span> = <span class="type">Tok</span>.makeTokenParser emptyDef</span><br><span class="line"></span><br><span class="line"><span class="title">parens</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> a</span><br><span class="line"><span class="title">parens</span> = <span class="type">Tok</span>.parens lexer</span><br><span class="line"></span><br><span class="line"><span class="title">reserved</span> :: <span class="type">String</span> -&gt; <span class="type">Parser</span> ()</span><br><span class="line"><span class="title">reserved</span> = <span class="type">Tok</span>.reserved lexer</span><br><span class="line"></span><br><span class="line"><span class="title">identifier</span> :: <span class="type">Parser</span> <span class="type">String</span></span><br><span class="line"><span class="title">identifier</span> = <span class="type">Tok</span>.identifier lexer</span><br><span class="line"></span><br><span class="line"><span class="title">semiSep</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> [a]</span><br><span class="line"><span class="title">semiSep</span> = <span class="type">Tok</span>.semiSep lexer</span><br><span class="line"></span><br><span class="line"><span class="title">reservedOp</span> :: <span class="type">String</span> -&gt; <span class="type">Parser</span> ()</span><br><span class="line"><span class="title">reservedOp</span> = <span class="type">Tok</span>.reservedOp lexer</span><br><span class="line"></span><br><span class="line"><span class="title">oper</span> s f assoc = <span class="type">Ex</span>.<span class="type">Prefix</span> (reservedOp s &gt;&gt; return f)</span><br><span class="line"></span><br><span class="line"><span class="title">table</span> = [ oper <span class="string">"succ"</span> <span class="type">Succ</span> <span class="type">Ex</span>.<span class="type">AssocLeft</span></span><br><span class="line">        , oper <span class="string">"pred"</span> <span class="type">Pred</span> <span class="type">Ex</span>.<span class="type">AssocLeft</span></span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line"><span class="title">expr</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">expr</span> = <span class="type">Ex</span>.buildExpressionParser [table] factor</span><br><span class="line"></span><br><span class="line"><span class="title">true</span>, false, zero :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">true</span>  = reserved <span class="string">"true"</span> &gt;&gt; return <span class="type">Tr</span></span><br><span class="line"><span class="title">false</span> = reserved <span class="string">"false"</span> &gt;&gt; return <span class="type">Fl</span></span><br><span class="line"><span class="title">zero</span>  = reservedOp <span class="string">"0"</span> &gt;&gt; return <span class="type">Zero</span></span><br><span class="line"></span><br><span class="line"><span class="title">antiquote</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">antiquote</span> = <span class="keyword">do</span></span><br><span class="line">  char '$'</span><br><span class="line">  var &lt;- identifier</span><br><span class="line">  return $ <span class="type">Antiquote</span> var</span><br><span class="line"></span><br><span class="line"><span class="title">factor</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">factor</span> = true</span><br><span class="line">      &lt;|&gt; false</span><br><span class="line">      &lt;|&gt; zero</span><br><span class="line">      &lt;|&gt; antiquote</span><br><span class="line">      &lt;|&gt; parens expr</span><br><span class="line"></span><br><span class="line"><span class="title">contents</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> a</span><br><span class="line"><span class="title">contents</span> p = <span class="keyword">do</span></span><br><span class="line">  <span class="type">Tok</span>.whiteSpace lexer</span><br><span class="line">  r &lt;- p</span><br><span class="line">  eof</span><br><span class="line">  return r</span><br><span class="line"></span><br><span class="line"><span class="title">parseExpr</span> :: <span class="type">String</span> -&gt; <span class="type">Either</span> <span class="type">ParseError</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">parseExpr</span> s = parse (contents expr) <span class="string">"&lt;stdin&gt;"</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Expressible</span> a <span class="keyword">where</span></span></span><br><span class="line">  express :: a -&gt; <span class="type">Expr</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Expressible</span> <span class="type">Expr</span> <span class="keyword">where</span></span></span><br><span class="line">  express = id</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Expressible</span> <span class="type">Bool</span> <span class="keyword">where</span></span></span><br><span class="line">  express <span class="type">True</span> = <span class="type">Tr</span></span><br><span class="line">  express <span class="type">False</span> = <span class="type">Fl</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Expressible</span> <span class="type">Integer</span> <span class="keyword">where</span></span></span><br><span class="line">  express <span class="number">0</span> = <span class="type">Zero</span></span><br><span class="line">  express n = <span class="type">Succ</span> (express (n - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">exprE</span> :: <span class="type">String</span> -&gt; <span class="type">Q</span> <span class="type">Exp</span></span><br><span class="line"><span class="title">exprE</span> s = <span class="keyword">do</span></span><br><span class="line">  filename &lt;- loc_filename `fmap` location</span><br><span class="line">  <span class="keyword">case</span> parse (contents expr) filename s <span class="keyword">of</span></span><br><span class="line">    <span class="type">Left</span> err -&gt; error (show err)</span><br><span class="line">    <span class="type">Right</span> exp -&gt; dataToExpQ (const <span class="type">Nothing</span> `extQ` antiExpr) exp</span><br><span class="line"></span><br><span class="line"><span class="title">exprP</span> :: <span class="type">String</span> -&gt; <span class="type">Q</span> <span class="type">Pat</span></span><br><span class="line"><span class="title">exprP</span> s = <span class="keyword">do</span></span><br><span class="line">  filename &lt;- loc_filename `fmap` location</span><br><span class="line">  <span class="keyword">case</span> parse (contents expr) filename s <span class="keyword">of</span></span><br><span class="line">    <span class="type">Left</span> err -&gt; error (show err)</span><br><span class="line">    <span class="type">Right</span> exp -&gt; dataToPatQ (const <span class="type">Nothing</span> `extQ` antiExprPat) exp</span><br><span class="line"></span><br><span class="line"><span class="comment">-- antiquote RHS</span></span><br><span class="line"><span class="title">antiExpr</span> :: <span class="type">Expr</span> -&gt; <span class="type">Maybe</span> (<span class="type">Q</span> <span class="type">Exp</span>)</span><br><span class="line"><span class="title">antiExpr</span> (<span class="type">Antiquote</span> v) = <span class="type">Just</span> embed</span><br><span class="line">  <span class="keyword">where</span> embed = [| express $(varE (mkName v)) |]</span><br><span class="line"><span class="title">antiExpr</span> _ = <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- antiquote LHS</span></span><br><span class="line"><span class="title">antiExprPat</span> :: <span class="type">Expr</span> -&gt; <span class="type">Maybe</span> (<span class="type">Q</span> <span class="type">Pat</span>)</span><br><span class="line"><span class="title">antiExprPat</span> (<span class="type">Antiquote</span> v) = <span class="type">Just</span> $ varP (mkName v)</span><br><span class="line"><span class="title">antiExprPat</span> _ = <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="title">mini</span> :: <span class="type">QuasiQuoter</span></span><br><span class="line"><span class="title">mini</span> = <span class="type">QuasiQuoter</span> exprE exprP undefined undefined</span><br><span class="line"><span class="meta">&#123;-# LANGUAGE QuasiQuotes #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Antiquote</span><br><span class="line"></span><br><span class="line"><span class="comment">-- extract</span></span><br><span class="line"><span class="title">a</span> :: <span class="type">Expr</span> -&gt; <span class="type">Expr</span></span><br><span class="line"><span class="title">a</span> [mini|succ $x|] = x</span><br><span class="line"></span><br><span class="line"><span class="title">b</span> :: <span class="type">Expr</span> -&gt; <span class="type">Expr</span></span><br><span class="line"><span class="title">b</span> [mini|succ $x|] = [mini|pred $x|]</span><br><span class="line"></span><br><span class="line"><span class="title">c</span> :: <span class="type">Expressible</span> a =&gt; a -&gt; <span class="type">Expr</span></span><br><span class="line"><span class="title">c</span> x = [mini|succ $x|]</span><br><span class="line"></span><br><span class="line"><span class="title">d</span> :: <span class="type">Expr</span></span><br><span class="line"><span class="title">d</span> = c (<span class="number">8</span> :: <span class="type">Integer</span>)</span><br><span class="line"><span class="comment">-- Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ Zero)))))))</span></span><br><span class="line"></span><br><span class="line"><span class="title">e</span> :: <span class="type">Expr</span></span><br><span class="line"><span class="title">e</span> = c <span class="type">True</span></span><br><span class="line"><span class="comment">-- Succ Tr</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Templated-Type-Families"><a href="#Templated-Type-Families" class="headerlink" title="Templated Type Families"></a>Templated Type Families</h3><blockquote>
<p>这是高级部分，编写Haskell通常无需了解TemplateHaskell.</p>
</blockquote>
<p>就像在<code>value-level</code>级别上一样，我们可以通过将它们的<code>AST</code>拼凑在一起来构造<code>type-level</code>(类型级别)的构造。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Type</span>          <span class="type">AST</span></span><br><span class="line"><span class="comment">----------    ----------</span></span><br><span class="line"><span class="title">t1</span> -&gt; t2      <span class="type">ArrowT</span> `<span class="type">AppT</span>` t2 `<span class="type">AppT</span>` t2</span><br><span class="line">[t]           <span class="type">ListT</span> `<span class="type">AppT</span>` t</span><br><span class="line">(t1,t2)       <span class="type">TupleT</span> <span class="number">2</span> `<span class="type">AppT</span>` t1 `<span class="type">AppT</span>` t2</span><br></pre></td></tr></table></figure></p>
<p>例如，考虑到类型级算术在<code>GHC 7.6</code>中仍然有点不完整，但通常情况下，类型级<code>numbers</code>(数字)的范围不是完整的整数集，而是一些有界的数字集。相反，我们可以用类型族来定义操作，而不是使用归纳定义(通常需要手动证明)，只需将参数的整个域枚举到类型族，并将它们映射到编译时计算的某个结果。</p>
<p>例如，<code>modulus</code>(模)运算符在类型级别实现是非常<code>non-trivial</code>(重要)的，但是我们可以使用<code>enumFamily</code>函数在<code>type-family</code>中进行<code>splice</code>(拼接)，该函数只需枚举所有可能的数字对，直到所需的深度。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> EnumFamily <span class="keyword">where</span></span><br><span class="line"><span class="keyword">import</span> Language.Haskell.TH</span><br><span class="line"></span><br><span class="line"><span class="title">enumFamily</span> :: (<span class="type">Integer</span> -&gt; <span class="type">Integer</span> -&gt; <span class="type">Integer</span>)</span><br><span class="line">           -&gt; <span class="type">Name</span></span><br><span class="line">           -&gt; <span class="type">Integer</span></span><br><span class="line">           -&gt; <span class="type">Q</span> [<span class="type">Dec</span>]</span><br><span class="line"><span class="title">enumFamily</span> f bop upper = return decls</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    decls = <span class="keyword">do</span></span><br><span class="line">      i &lt;- [<span class="number">1.</span>.upper]</span><br><span class="line">      j &lt;- [<span class="number">2.</span>.upper]</span><br><span class="line">      return $ <span class="type">TySynInstD</span> bop (rhs i j)</span><br><span class="line"></span><br><span class="line">    rhs i j = <span class="type">TySynEqn</span></span><br><span class="line">      [<span class="type">LitT</span> (<span class="type">NumTyLit</span> i), <span class="type">LitT</span> (<span class="type">NumTyLit</span> j)]</span><br><span class="line">      (<span class="type">LitT</span> (<span class="type">NumTyLit</span> (i `f` j)))</span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TemplateHaskell #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> EnumFamily</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Proxy</span><br><span class="line"><span class="keyword">import</span> GHC.TypeLits</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Mod</span> (<span class="title">m</span> :: <span class="type">Nat</span>) (<span class="title">n</span> :: <span class="type">Nat</span>) :: <span class="type">Nat</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Add</span> (<span class="title">m</span> :: <span class="type">Nat</span>) (<span class="title">n</span> :: <span class="type">Nat</span>) :: <span class="type">Nat</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Pow</span> (<span class="title">m</span> :: <span class="type">Nat</span>) (<span class="title">n</span> :: <span class="type">Nat</span>) :: <span class="type">Nat</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">enumFamily</span> mod ''<span class="type">Mod</span> <span class="number">10</span></span><br><span class="line"><span class="title">enumFamily</span> (+) ''<span class="type">Add</span> <span class="number">10</span></span><br><span class="line"><span class="title">enumFamily</span> (^) ''<span class="type">Pow</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="title">a</span> :: <span class="type">Integer</span></span><br><span class="line"><span class="title">a</span> = natVal (<span class="type">Proxy</span> :: <span class="type">Proxy</span> (<span class="type">Mod</span> <span class="number">6</span> <span class="number">4</span>))</span><br><span class="line"><span class="comment">-- 2</span></span><br><span class="line"></span><br><span class="line"><span class="title">b</span> :: <span class="type">Integer</span></span><br><span class="line"><span class="title">b</span> = natVal (<span class="type">Proxy</span> :: <span class="type">Proxy</span> (<span class="type">Pow</span> <span class="number">3</span> (<span class="type">Mod</span> <span class="number">6</span> <span class="number">4</span>)))</span><br><span class="line"><span class="comment">-- 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--    enumFamily mod ''Mod 3</span></span><br><span class="line"><span class="comment">--  ======&gt;</span></span><br><span class="line"><span class="comment">--    template_typelevel_splice.hs:7:1-14</span></span><br><span class="line"><span class="comment">--    type instance Mod 2 1 = 0</span></span><br><span class="line"><span class="comment">--    type instance Mod 2 2 = 0</span></span><br><span class="line"><span class="comment">--    type instance Mod 2 3 = 2</span></span><br><span class="line"><span class="comment">--    type instance Mod 3 1 = 0</span></span><br><span class="line"><span class="comment">--    type instance Mod 3 2 = 1</span></span><br><span class="line"><span class="comment">--    type instance Mod 3 3 = 0</span></span><br><span class="line"><span class="comment">--    ...</span></span><br></pre></td></tr></table></figure></p>
<p>在实践中，尽管编译时间可能会因此增加一些，但<code>GHC</code>对于大量的<code>type-family</code>(类型族)声明似乎很好。<br><code>singletons</code>库还提供了一种自动化此过程的方法，它允许我们在<code>quasiqoter</code>中编写看似值级别的声明，然后将逻辑<code>promoting</code>(提升)到类型级别。<br>例如，如果我们想为<code>HList</code>编写一个值级别和类型级别的映射函数，这通常需要相当多的样板文件，现在可以非常简洁地说明。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE PolyKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE QuasiQuotes #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TemplateHaskell #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE KindSignatures #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE StandaloneDeriving #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleInstances #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleContexts #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeSynonymInstances #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Singletons</span><br><span class="line"><span class="keyword">import</span> Data.Singletons.TH</span><br><span class="line"></span><br><span class="line">$(promote [d|</span><br><span class="line">  map :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><br><span class="line">  map _ [] = []</span><br><span class="line">  map f (x:xs) = f x : map f xs</span><br><span class="line">  |])</span><br><span class="line"></span><br><span class="line"><span class="keyword">infixr</span> <span class="number">5</span> :::</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">HList</span> (<span class="title">ts</span> :: [ * ]) where</span></span><br><span class="line">  <span class="type">Nil</span> :: <span class="type">HList</span> '[]</span><br><span class="line">  (:::) :: t -&gt; <span class="type">HList</span> ts -&gt; <span class="type">HList</span> (t ': ts)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- TypeLevel</span></span><br><span class="line"><span class="comment">-- MapJust :: [*] -&gt; [Maybe *]</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">MapJust</span> xs = <span class="type">Map</span> <span class="type">Maybe</span> xs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Value Level</span></span><br><span class="line"><span class="comment">-- mapJust :: [a] -&gt; [Maybe a]</span></span><br><span class="line"><span class="title">mapJust</span> :: <span class="type">HList</span> xs -&gt; <span class="type">HList</span> (<span class="type">MapJust</span> xs)</span><br><span class="line"><span class="title">mapJust</span> <span class="type">Nil</span> = <span class="type">Nil</span></span><br><span class="line"><span class="title">mapJust</span> (x ::: xs) = (<span class="type">Just</span> x) ::: mapJust xs</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">A</span> = [<span class="type">Bool</span>, <span class="type">String</span> , <span class="type">Double</span> , ()]</span></span><br><span class="line"></span><br><span class="line"><span class="title">a</span> :: <span class="type">HList</span> <span class="type">A</span></span><br><span class="line"><span class="title">a</span> = <span class="type">True</span> ::: <span class="string">"foo"</span> ::: <span class="number">3.14</span> ::: () ::: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line"><span class="title">example1</span> :: <span class="type">HList</span> (<span class="type">MapJust</span> <span class="type">A</span>)</span><br><span class="line"><span class="title">example1</span> = mapJust a</span><br><span class="line"></span><br><span class="line"><span class="comment">-- example1 reduces to example2 when expanded</span></span><br><span class="line"><span class="comment">-- 展开后，example1`化简`为example2</span></span><br><span class="line"><span class="title">example2</span> :: <span class="type">HList</span> ([<span class="type">Maybe</span> <span class="type">Bool</span>, <span class="type">Maybe</span> <span class="type">String</span> , <span class="type">Maybe</span> <span class="type">Double</span> , <span class="type">Maybe</span> ()])</span><br><span class="line"><span class="title">example2</span> = <span class="type">Just</span> <span class="type">True</span> ::: <span class="type">Just</span> <span class="string">"foo"</span> ::: <span class="type">Just</span> <span class="number">3.14</span> ::: <span class="type">Just</span> () ::: <span class="type">Nil</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Templated-Type-Classes"><a href="#Templated-Type-Classes" class="headerlink" title="Templated Type Classes"></a>Templated Type Classes</h3><blockquote>
<p>这是高级部分，编写Haskell通常无需了解TemplateHaskell.</p>
</blockquote>
<p><code>Template Haskell</code>的最常见用法是自动生成类型类实例。考虑一下，如果我们想为<code>flat</code>(平面)数据结构编写一个简单的<code>Pretty</code>打印类，该类根据<code>AST</code>中构造函数的名称<code>derived</code>(派生)出<code>ppr</code>方法，我们可以编写一个简单的实例。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE QuasiQuotes #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TemplateHaskell #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleInstances #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleContexts #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Class <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Language.Haskell.TH</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Pretty</span> a <span class="keyword">where</span></span></span><br><span class="line">  ppr :: a -&gt; <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="title">normalCons</span> :: <span class="type">Con</span> -&gt; <span class="type">Name</span></span><br><span class="line"><span class="title">normalCons</span> (<span class="type">NormalC</span> n _) = n</span><br><span class="line"></span><br><span class="line"><span class="title">getCons</span> :: <span class="type">Info</span> -&gt; [<span class="type">Name</span>]</span><br><span class="line"><span class="title">getCons</span> cons = <span class="keyword">case</span> cons <span class="keyword">of</span></span><br><span class="line">    <span class="type">TyConI</span> (<span class="type">DataD</span>    _ _ _ tcons _) -&gt; map normalCons tcons</span><br><span class="line">    con -&gt; error $ <span class="string">"Can't derive for:"</span> ++ (show con)</span><br><span class="line"></span><br><span class="line"><span class="title">pretty</span> :: <span class="type">Name</span> -&gt; <span class="type">Q</span> [<span class="type">Dec</span>]</span><br><span class="line"><span class="title">pretty</span> dt = <span class="keyword">do</span></span><br><span class="line">  info &lt;- reify dt</span><br><span class="line">  <span class="type">Just</span> cls &lt;- lookupTypeName <span class="string">"Pretty"</span></span><br><span class="line">  <span class="keyword">let</span> datatypeStr = nameBase dt</span><br><span class="line">  <span class="keyword">let</span> cons = getCons info</span><br><span class="line">  <span class="keyword">let</span> dtype = mkName (datatypeStr)</span><br><span class="line">  <span class="keyword">let</span> mkInstance xs =</span><br><span class="line">        <span class="type">InstanceD</span></span><br><span class="line">        []                              <span class="comment">-- Context</span></span><br><span class="line">        (<span class="type">AppT</span></span><br><span class="line">          (<span class="type">ConT</span> cls)                    <span class="comment">-- Instance</span></span><br><span class="line">          (<span class="type">ConT</span> dtype))                 <span class="comment">-- Head</span></span><br><span class="line">        [(<span class="type">FunD</span> (mkName <span class="string">"ppr"</span>) xs)]      <span class="comment">-- Methods</span></span><br><span class="line">  <span class="keyword">let</span> methods = map cases cons</span><br><span class="line">  return $ [mkInstance methods]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Pattern matches on the ``ppr`` method</span></span><br><span class="line"><span class="title">cases</span> :: <span class="type">Name</span> -&gt; <span class="type">Clause</span></span><br><span class="line"><span class="title">cases</span> a = <span class="type">Clause</span> [<span class="type">ConP</span> a []] (<span class="type">NormalB</span> (<span class="type">LitE</span> (<span class="type">StringL</span> (nameBase a)))) []</span><br></pre></td></tr></table></figure></p>
<p>在一个单独的文件中，在<code>top-level</code>(顶层)调用<code>pretty</code>实例，如果要查看已<code>spliced</code>(拼接)的类实例，则使用<code>--ddump-splice</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE QuasiQuotes #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TemplateHaskell #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Class</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">PlatonicSolid</span></span></span><br><span class="line">  = <span class="type">Tetrahedron</span></span><br><span class="line">  | <span class="type">Cube</span></span><br><span class="line">  | <span class="type">Octahedron</span></span><br><span class="line">  | <span class="type">Dodecahedron</span></span><br><span class="line">  | <span class="type">Icosahedron</span></span><br><span class="line"></span><br><span class="line"><span class="title">pretty</span> ''<span class="type">PlatonicSolid</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  putStrLn (ppr <span class="type">Octahedron</span>)</span><br><span class="line">  putStrLn (ppr <span class="type">Dodecahedron</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="Multiline-Strings"><a href="#Multiline-Strings" class="headerlink" title="Multiline Strings"></a>Multiline Strings</h3><p><code>Haskell</code>不支持多行字符串文本，尽管我们可以使用<code>quasiqueoter</code>来模拟它。然后使用<code>tostring</code>将得到的<code>String</code>文本转换为<code>desired</code>(所需)的任何结果类型。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE TemplateHaskell #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Multiline (<span class="title">s</span>) <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.String</span><br><span class="line"><span class="keyword">import</span> Language.Haskell.TH.Quote</span><br><span class="line"></span><br><span class="line"><span class="title">s</span> :: <span class="type">QuasiQuoter</span></span><br><span class="line"><span class="title">s</span> = <span class="type">QuasiQuoter</span></span><br><span class="line">  &#123; quoteExp  = (\a -&gt; [|fromString a|]) . trim</span><br><span class="line">  , quotePat  = \_ -&gt; fail <span class="string">"illegal raw string QuasiQuote"</span></span><br><span class="line">  , quoteType = \_ -&gt; fail <span class="string">"illegal raw string QuasiQuote"</span></span><br><span class="line">  , quoteDec  = \_ -&gt; fail <span class="string">"illegal raw string QuasiQuote"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="title">trim</span> :: <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">trim</span> ('\n':xs) = xs</span><br><span class="line"><span class="title">trim</span> xs = xs</span><br></pre></td></tr></table></figure></p>
<p>然后，在一个单独的模块中，我们可以启用<code>Quasiquotes</code>并嵌入字符串。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE QuasiQuotes #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Multiline (<span class="title">s</span>)</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Text <span class="keyword">as</span> T</span><br><span class="line"></span><br><span class="line"><span class="title">foo</span> :: <span class="type">T</span>.<span class="type">Text</span></span><br><span class="line"><span class="title">foo</span> = [s|</span><br><span class="line"><span class="type">This</span></span><br><span class="line"><span class="title">is</span></span><br><span class="line"><span class="title">my</span></span><br><span class="line"><span class="title">multiline</span></span><br><span class="line"><span class="title">string</span></span><br><span class="line">|]</span><br></pre></td></tr></table></figure></p>
<h3 id="git-embed-嵌入"><a href="#git-embed-嵌入" class="headerlink" title="git-embed (嵌入)"></a>git-embed (嵌入)</h3><p>通常需要在可执行文件中嵌入生成的特定<code>Git</code>版本哈希。<br>使用<code>git-embed</code>，编译器将有效地向命令行发出<code>shell</code>，以检索<code>CWD Git</code>存储库的版本信息，并在编译时使用<code>Template Haskell</code>定义然後嵌入此信息。<br>这对于在程序或服务的命令行接口中嵌入版本信息通常很有用。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE TemplateHaskell #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Git.Embed</span><br><span class="line"><span class="keyword">import</span> Data.Version</span><br><span class="line"><span class="keyword">import</span> Paths_myprog</span><br><span class="line"></span><br><span class="line"><span class="title">gitRev</span> :: <span class="type">String</span></span><br><span class="line"><span class="title">gitRev</span> = $(embedGitShortRevision)</span><br><span class="line"></span><br><span class="line"><span class="title">gitBranch</span> :: <span class="type">String</span></span><br><span class="line"><span class="title">gitBranch</span> = $(embedGitBranch)</span><br><span class="line"></span><br><span class="line"><span class="title">ver</span> :: <span class="type">String</span></span><br><span class="line"><span class="title">ver</span> = showVersion <span class="type">Paths_myprog</span>.version</span><br></pre></td></tr></table></figure></p>
<p>請看: </p>
<ul>
<li><a href="https://hackage.haskell.org/package/git-embed" target="_blank" rel="noopener">git-embed</a></li>
</ul>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/blog/js/index.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/blog/js/gitment.js"></script>
<script>
    var gitment = new Gitment({
        id: 'Haskell-Template-Haskell',
        owner: 'limengyu1990',
        repo: 'hexo-blog',
        oauth: {
            client_id: '7cfc73dd62b57f07ed83',
            client_secret: 'dd03b7e54aadf0d81e4c9c93e23a41272bcfcfa1',
        },
    })
    gitment.render('comment-container')
</script>

</html>
