<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        Haskell-Data-Structures - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>不负如来不负卿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-text">Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tree"><span class="toc-text">Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-text">Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector"><span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mutable-Vectors"><span class="toc-text">Mutable Vectors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unordered-Containers-无序容器"><span class="toc-text">Unordered-Containers(无序容器)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hashtables"><span class="toc-text">Hashtables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Graphs"><span class="toc-text">Graphs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Graph-Theory-图论"><span class="toc-text">Graph Theory(图论)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DList"><span class="toc-text">DList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sequence"><span class="toc-text">Sequence</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fingertree-指状树"><span class="toc-text">Fingertree(指状树)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vault"><span class="toc-text">Vault</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Haskell-Data-Structures
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-10-16 19:29:51</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/blog/tags/#Wish-Knew" title="Wish-Knew">Wish-Knew</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Haskell" title="Haskell">Haskell</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Structures" title="Structures">Structures</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p><a href="http://dev.stephendiehl.com/hask/#data-structures" target="_blank" rel="noopener">原文</a></p>
</blockquote>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><img src="img/map.png" alt=""></p>
<p><code>map</code>是将<code>Ord</code>键的任何实例映射到任何类型的值的关联数组。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Map <span class="keyword">as</span> Map</span><br><span class="line"></span><br><span class="line"><span class="title">kv</span> :: <span class="type">Map</span>.<span class="type">Map</span> <span class="type">Integer</span> <span class="type">String</span></span><br><span class="line"><span class="title">kv</span> = <span class="type">Map</span>.fromList [(<span class="number">1</span>, <span class="string">"a"</span>), (<span class="number">2</span>, <span class="string">"b"</span>)]</span><br><span class="line"></span><br><span class="line"><span class="title">lkup</span> :: <span class="type">Integer</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">lkup</span> key def =</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Map</span>.lookup key kv <span class="keyword">of</span></span><br><span class="line">    <span class="type">Just</span> val -&gt; val</span><br><span class="line">    <span class="type">Nothing</span>  -&gt; def</span><br></pre></td></tr></table></figure></p>
<h3 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h3><p><img src="img/tree.png" alt=""></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.Tree</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;-</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   A</span></span><br><span class="line"><span class="comment">  / \</span></span><br><span class="line"><span class="comment"> B   C</span></span><br><span class="line"><span class="comment">    / \</span></span><br><span class="line"><span class="comment">   D   E</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">tree</span> :: <span class="type">Tree</span> <span class="type">String</span></span><br><span class="line"><span class="title">tree</span> = <span class="type">Node</span> <span class="string">"A"</span> [<span class="type">Node</span> <span class="string">"B"</span> [], <span class="type">Node</span> <span class="string">"C"</span> [<span class="type">Node</span> <span class="string">"D"</span> [], <span class="type">Node</span> <span class="string">"E"</span> []]]</span><br><span class="line"></span><br><span class="line"><span class="title">postorder</span> :: <span class="type">Tree</span> a -&gt; [a]</span><br><span class="line"><span class="title">postorder</span> (<span class="type">Node</span> a ts) = elts ++ [a]</span><br><span class="line">  <span class="keyword">where</span> elts = concat (map postorder ts)</span><br><span class="line"></span><br><span class="line"><span class="title">preorder</span> :: <span class="type">Tree</span> a -&gt; [a]</span><br><span class="line"><span class="title">preorder</span> (<span class="type">Node</span> a ts) = a : elts</span><br><span class="line">  <span class="keyword">where</span> elts = concat (map preorder ts)</span><br><span class="line"></span><br><span class="line"><span class="title">ex1</span> = drawTree tree</span><br><span class="line"><span class="title">ex2</span> = drawForest (subForest tree)</span><br><span class="line"><span class="title">ex3</span> = flatten tree</span><br><span class="line"><span class="title">ex4</span> = levels tree</span><br><span class="line"><span class="title">ex5</span> = preorder tree</span><br><span class="line"><span class="title">ex6</span> = postorder tree</span><br></pre></td></tr></table></figure>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><img src="img/set.png" alt=""></p>
<p><code>Sets</code>是一种无序的数据结构，允许任何类型的<code>Ord</code>值，并保证结构中的唯一性。尽管它们具有相同的名称，但它们与<code>Set</code>的数学概念并不相同。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Set <span class="keyword">as</span> Set</span><br><span class="line"></span><br><span class="line"><span class="title">set</span> :: <span class="type">Set</span>.<span class="type">Set</span> <span class="type">Integer</span></span><br><span class="line"><span class="title">set</span> = <span class="type">Set</span>.fromList [<span class="number">1.</span><span class="number">.1000</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">memtest</span> :: <span class="type">Integer</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">memtest</span> elt = <span class="type">Set</span>.member elt set</span><br></pre></td></tr></table></figure></p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p><img src="img/vector.png" alt=""></p>
<p>向量是高性能的一维数组，有六种变体，对于以下类型的可变和不可变变体各有两种。</p>
<ul>
<li>Data.Vector</li>
<li>Data.Vector.Storable</li>
<li>Data.Vector.Unboxed</li>
</ul>
<p>向量最显着的特征是通过<code>(!)</code>进行恒定时间的内存访问，以及在生成令人惊讶的最佳代码的<code>fusion</code>(融合)框架之上的各种高效的<code>map</code>,<code>fold</code>和<code>scan</code>操作。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fromList</span> :: [a] -&gt; <span class="type">Vector</span> a</span><br><span class="line"><span class="title">toList</span> :: <span class="type">Vector</span> a -&gt; [a]</span><br><span class="line">(!) :: <span class="type">Vector</span> a -&gt; <span class="type">Int</span> -&gt; a</span><br><span class="line"><span class="title">map</span> :: (a -&gt; b) -&gt; <span class="type">Vector</span> a -&gt; <span class="type">Vector</span> b</span><br><span class="line"><span class="title">foldl</span> :: (a -&gt; b -&gt; a) -&gt; a -&gt; <span class="type">Vector</span> b -&gt; a</span><br><span class="line"><span class="title">scanl</span> :: (a -&gt; b -&gt; a) -&gt; a -&gt; <span class="type">Vector</span> b -&gt; <span class="type">Vector</span> a</span><br><span class="line"><span class="title">zipWith</span> :: (a -&gt; b -&gt; c) -&gt; <span class="type">Vector</span> a -&gt; <span class="type">Vector</span> b -&gt; <span class="type">Vector</span> c</span><br><span class="line"><span class="title">iterateN</span> :: <span class="type">Int</span> -&gt; (a -&gt; a) -&gt; a -&gt; <span class="type">Vector</span> a</span><br><span class="line"><span class="keyword">import</span> Data.Vector.Unboxed <span class="keyword">as</span> V</span><br><span class="line"></span><br><span class="line"><span class="title">norm</span> ::  <span class="type">Vector</span> <span class="type">Double</span> -&gt; <span class="type">Double</span></span><br><span class="line"><span class="title">norm</span> = sqrt . <span class="type">V</span>.sum . <span class="type">V</span>.map (\x -&gt; x*x)</span><br><span class="line"></span><br><span class="line"><span class="title">example1</span> :: <span class="type">Double</span></span><br><span class="line"><span class="title">example1</span> = norm $ <span class="type">V</span>.iterateN <span class="number">100000000</span> (+<span class="number">1</span>) <span class="number">0.0</span></span><br></pre></td></tr></table></figure></p>
<p>請看:</p>
<ul>
<li><a href="http://wiki.haskell.org/Numeric_Haskell:_A_Vector_Tutorial" target="_blank" rel="noopener">Numerical Haskell: A Vector Tutorial</a></li>
</ul>
<h3 id="Mutable-Vectors"><a href="#Mutable-Vectors" class="headerlink" title="Mutable Vectors"></a>Mutable Vectors</h3><p><img src="img/mu-vector.png" alt=""></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">freeze</span> :: <span class="type">MVector</span> (<span class="type">PrimState</span> m) a -&gt; m (<span class="type">Vector</span> a)</span><br><span class="line"><span class="title">thaw</span> :: <span class="type">Vector</span> a -&gt; <span class="type">MVector</span> (<span class="type">PrimState</span> m) a</span><br></pre></td></tr></table></figure>
<p>在<code>IO monad</code>中，我们可以以恒定的时间读写对可变向量执行任意读写。必要时，可以使用<code>freeze</code>/<code>thaw</code>函數从<code>MVector</code>创建静态<code>Vector</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GHC.Prim</span><br><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line"><span class="keyword">import</span> Control.Monad.ST</span><br><span class="line"><span class="keyword">import</span> Control.Monad.Primitive</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Vector.Unboxed (<span class="title">freeze</span>)</span><br><span class="line"><span class="keyword">import</span> Data.Vector.Unboxed.Mutable</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Vector.Unboxed <span class="keyword">as</span> V</span><br><span class="line"></span><br><span class="line"><span class="title">example</span> :: <span class="type">PrimMonad</span> m =&gt; m (<span class="type">V</span>.<span class="type">Vector</span> <span class="type">Int</span>)</span><br><span class="line"><span class="title">example</span> = <span class="keyword">do</span></span><br><span class="line">  v &lt;- new <span class="number">10</span></span><br><span class="line">  forM_ [<span class="number">0.</span><span class="number">.9</span>] $ \i -&gt;</span><br><span class="line">     write v i (<span class="number">2</span>*i)</span><br><span class="line">  freeze v</span><br><span class="line"></span><br><span class="line"><span class="comment">-- vector computation in IO</span></span><br><span class="line"><span class="title">vecIO</span> :: <span class="type">IO</span> (<span class="type">V</span>.<span class="type">Vector</span> <span class="type">Int</span>)</span><br><span class="line"><span class="title">vecIO</span> = example</span><br><span class="line"></span><br><span class="line"><span class="comment">-- vector computation in ST</span></span><br><span class="line"><span class="title">vecST</span> :: <span class="type">ST</span> s (<span class="type">V</span>.<span class="type">Vector</span> <span class="type">Int</span>)</span><br><span class="line"><span class="title">vecST</span> = example</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  vecIO &gt;&gt;= print</span><br><span class="line">  print $ runST vecST</span><br></pre></td></tr></table></figure></p>
<p>向量库本身通常会对索引操作进行边界检查，以防止内存损坏。通过使用<code>boundschecks cabal</code>标志进行编译，可以在库级别启用或禁用此功能。</p>
<h3 id="Unordered-Containers-无序容器"><a href="#Unordered-Containers-无序容器" class="headerlink" title="Unordered-Containers(无序容器)"></a>Unordered-Containers(无序容器)</h3><p><img src="img/unordered-containers.png" alt=""></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fromList</span> :: (<span class="type">Eq</span> k, <span class="type">Hashable</span> k) =&gt; [(k, v)] -&gt; <span class="type">HashMap</span> k v</span><br><span class="line"><span class="title">lookup</span> :: (<span class="type">Eq</span> k, <span class="type">Hashable</span> k) =&gt; k -&gt; <span class="type">HashMap</span> k v -&gt; <span class="type">Maybe</span> v</span><br><span class="line"><span class="title">insert</span> :: (<span class="type">Eq</span> k, <span class="type">Hashable</span> k) =&gt; k -&gt; v -&gt; <span class="type">HashMap</span> k v -&gt; <span class="type">HashMap</span> k v</span><br></pre></td></tr></table></figure>
<p><code>HashMap</code>和<code>HashSet</code>都是纯函數性数据结构，是<code>containers</code>(容器)等价物的替代品，但具有更高效的空间和时间性能。此外，所有存储的元素都必须有一个<code>Hashable</code>实例。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.HashSet <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.HashMap.Lazy <span class="keyword">as</span> M</span><br><span class="line"></span><br><span class="line"><span class="title">example1</span> :: <span class="type">M</span>.<span class="type">HashMap</span> <span class="type">Int</span> <span class="type">Char</span></span><br><span class="line"><span class="title">example1</span> = <span class="type">M</span>.fromList $ zip [<span class="number">1.</span><span class="number">.10</span>] ['a'..]</span><br><span class="line"></span><br><span class="line"><span class="title">example2</span> :: <span class="type">S</span>.<span class="type">HashSet</span> <span class="type">Int</span></span><br><span class="line"><span class="title">example2</span> = <span class="type">S</span>.fromList [<span class="number">1.</span><span class="number">.10</span>]</span><br></pre></td></tr></table></figure></p>
<p>請看:</p>
<ul>
<li><a href="http://blog.johantibell.com/2012/03/announcing-unordered-containers-02.html" target="_blank" rel="noopener">Announcing Unordered Containers</a></li>
</ul>
<h3 id="Hashtables"><a href="#Hashtables" class="headerlink" title="Hashtables"></a>Hashtables</h3><p><img src="img/hashtable.png" alt=""></p>
<p><code>Hashtables</code>在<code>ST</code>或<code>IO monad</code>中提供高效查找的哈希表。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Prelude <span class="keyword">hiding</span> (<span class="title">lookup</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Control.Monad.ST</span><br><span class="line"><span class="keyword">import</span> Data.HashTable.ST.Basic</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Hashtable parameterized by ST "thread"</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">HT</span> s = <span class="type">HashTable</span> s <span class="type">String</span> <span class="type">String</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">set</span> :: <span class="type">ST</span> s (<span class="type">HT</span> s)</span><br><span class="line"><span class="title">set</span> = <span class="keyword">do</span></span><br><span class="line">  ht &lt;- new</span><br><span class="line">  insert ht <span class="string">"key"</span> <span class="string">"value1"</span></span><br><span class="line">  return ht</span><br><span class="line"></span><br><span class="line"><span class="title">get</span> :: <span class="type">HT</span> s -&gt; <span class="type">ST</span> s (<span class="type">Maybe</span> <span class="type">String</span>)</span><br><span class="line"><span class="title">get</span> ht = <span class="keyword">do</span></span><br><span class="line">  val &lt;- lookup ht <span class="string">"key"</span></span><br><span class="line">  return val</span><br><span class="line"></span><br><span class="line"><span class="title">example</span> :: <span class="type">Maybe</span> <span class="type">String</span></span><br><span class="line"><span class="title">example</span> = runST (set &gt;&gt;= get)</span><br><span class="line"><span class="title">new</span> :: <span class="type">ST</span> s (<span class="type">HashTable</span> s k v)</span><br><span class="line"><span class="title">insert</span> :: (<span class="type">Eq</span> k, <span class="type">Hashable</span> k) =&gt; <span class="type">HashTable</span> s k v -&gt; k -&gt; v -&gt; <span class="type">ST</span> s ()</span><br><span class="line"><span class="title">lookup</span> :: (<span class="type">Eq</span> k, <span class="type">Hashable</span> k) =&gt; <span class="type">HashTable</span> s k v -&gt; k -&gt; <span class="type">ST</span> s (<span class="type">Maybe</span> v)</span><br></pre></td></tr></table></figure>
<h3 id="Graphs"><a href="#Graphs" class="headerlink" title="Graphs"></a>Graphs</h3><p><code>containers</code>库中的<code>Graph</code>模块是用于处理有向图的有点过时的<code>API</code>。<br>一点点的数据包装使它更易于使用。该库不一定非常适合于大型图论操作，但非常适合用于需要解析模块定义图的强连接组件的类型检查器中。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.Tree</span><br><span class="line"><span class="keyword">import</span> Data.Graph</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Grph</span> node key = <span class="type">Grph</span></span></span><br><span class="line">  &#123; _graph :: <span class="type">Graph</span></span><br><span class="line">  , _vertices :: <span class="type">Vertex</span> -&gt; (node, key, [key])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="title">fromList</span> :: <span class="type">Ord</span> key =&gt; [(node, key, [key])] -&gt; <span class="type">Grph</span> node key</span><br><span class="line"><span class="title">fromList</span> = uncurry <span class="type">Grph</span> . graphFromEdges'</span><br><span class="line"></span><br><span class="line"><span class="title">vertexLabels</span> :: <span class="type">Functor</span> f =&gt; <span class="type">Grph</span> b t -&gt; (f <span class="type">Vertex</span>) -&gt; f b</span><br><span class="line"><span class="title">vertexLabels</span> g = fmap (vertexLabel g)</span><br><span class="line"></span><br><span class="line"><span class="title">vertexLabel</span> :: <span class="type">Grph</span> b t -&gt; <span class="type">Vertex</span> -&gt; b</span><br><span class="line"><span class="title">vertexLabel</span> g = (\(vi, _, _) -&gt; vi) . (_vertices g)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拓扑排序图</span></span><br><span class="line"><span class="title">topo'</span> :: <span class="type">Grph</span> node key -&gt; [node]</span><br><span class="line"><span class="title">topo'</span> g = vertexLabels g $ topSort (_graph g)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 图的强连接组件</span></span><br><span class="line"><span class="title">scc'</span> :: <span class="type">Grph</span> node key -&gt; [[node]]</span><br><span class="line"><span class="title">scc'</span> g = fmap (vertexLabels g . flatten) $ scc (_graph g)</span><br></pre></td></tr></table></figure></p>
<p>因此，例如，我们可以构造一个简单的图形:<br><img src="img/graph001.png" alt=""></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ex1</span> :: [(<span class="type">String</span>, <span class="type">String</span>, [<span class="type">String</span>])]</span><br><span class="line"><span class="title">ex1</span> = [</span><br><span class="line">    (<span class="string">"a"</span>,<span class="string">"a"</span>,[<span class="string">"b"</span>]),</span><br><span class="line">    (<span class="string">"b"</span>,<span class="string">"b"</span>,[<span class="string">"c"</span>]),</span><br><span class="line">    (<span class="string">"c"</span>,<span class="string">"c"</span>,[<span class="string">"a"</span>])</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="title">ts1</span> :: [<span class="type">String</span>]</span><br><span class="line"><span class="title">ts1</span> = topo' (fromList ex1)</span><br><span class="line"><span class="comment">-- ["a","b","c"]</span></span><br><span class="line"></span><br><span class="line"><span class="title">sc1</span> :: [[<span class="type">String</span>]]</span><br><span class="line"><span class="title">sc1</span> = scc' (fromList ex1)</span><br><span class="line"><span class="comment">-- [["a","b","c"]]</span></span><br></pre></td></tr></table></figure>
<p>或具有两个紧密相连的子图:</p>
<p><img src="img/graph002.png" alt=""></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ex2</span> :: [(<span class="type">String</span>, <span class="type">String</span>, [<span class="type">String</span>])]</span><br><span class="line"><span class="title">ex2</span> = [</span><br><span class="line">    (<span class="string">"a"</span>,<span class="string">"a"</span>,[<span class="string">"b"</span>]),</span><br><span class="line">    (<span class="string">"b"</span>,<span class="string">"b"</span>,[<span class="string">"c"</span>]),</span><br><span class="line">    (<span class="string">"c"</span>,<span class="string">"c"</span>,[<span class="string">"a"</span>]),</span><br><span class="line"></span><br><span class="line">    (<span class="string">"d"</span>,<span class="string">"d"</span>,[<span class="string">"e"</span>]),</span><br><span class="line">    (<span class="string">"e"</span>,<span class="string">"e"</span>,[<span class="string">"f"</span>, <span class="string">"e"</span>]),</span><br><span class="line">    (<span class="string">"f"</span>,<span class="string">"f"</span>,[<span class="string">"d"</span>, <span class="string">"e"</span>])</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="title">ts2</span> :: [<span class="type">String</span>]</span><br><span class="line"><span class="title">ts2</span> = topo' (fromList ex2)</span><br><span class="line"><span class="comment">-- ["d","e","f","a","b","c"]</span></span><br><span class="line"></span><br><span class="line"><span class="title">sc2</span> :: [[<span class="type">String</span>]]</span><br><span class="line"><span class="title">sc2</span> = scc' (fromList ex2)</span><br><span class="line"><span class="comment">-- [["d","e","f"],["a","b","c"]]</span></span><br></pre></td></tr></table></figure>
<p>請看:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/GraphSCC" target="_blank" rel="noopener">GraphSCC</a></li>
</ul>
<h3 id="Graph-Theory-图论"><a href="#Graph-Theory-图论" class="headerlink" title="Graph Theory(图论)"></a>Graph Theory(图论)</h3><p><code>fgl</code>库提供了更有效的图结构和各种常见的图论操作。例如，在编译器设计的控制流分析中，计算图的优势边界经常出现。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Graph.Inductive <span class="keyword">as</span> G</span><br><span class="line"></span><br><span class="line"><span class="title">cyc3</span> :: <span class="type">G</span>.<span class="type">Gr</span> <span class="type">Char</span> <span class="type">String</span></span><br><span class="line"><span class="title">cyc3</span> = <span class="type">G</span>.buildGr</span><br><span class="line">       [([(<span class="string">"ca"</span>,<span class="number">3</span>)],<span class="number">1</span>,'a',[(<span class="string">"ab"</span>,<span class="number">2</span>)]),</span><br><span class="line">                ([],<span class="number">2</span>,'b',[(<span class="string">"bc"</span>,<span class="number">3</span>)]),</span><br><span class="line">                ([],<span class="number">3</span>,'c',[])]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Loop query</span></span><br><span class="line"><span class="title">ex1</span> :: <span class="type">Bool</span></span><br><span class="line"><span class="title">ex1</span> = <span class="type">G</span>.hasLoop x</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Dominators</span></span><br><span class="line"><span class="title">ex2</span> :: [(<span class="type">G</span>.<span class="type">Node</span>, [<span class="type">G</span>.<span class="type">Node</span>])]</span><br><span class="line"><span class="title">ex2</span> = <span class="type">G</span>.dom x <span class="number">0</span></span><br><span class="line"><span class="title">x</span> :: <span class="type">G</span>.<span class="type">Gr</span> <span class="type">Int</span> ()</span><br><span class="line"><span class="title">x</span> = <span class="type">G</span>.insEdges edges gr</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">  gr = <span class="type">G</span>.insNodes nodes <span class="type">G</span>.empty</span><br><span class="line">  edges = [(<span class="number">0</span>,<span class="number">1</span>,()), (<span class="number">0</span>,<span class="number">2</span>,()), (<span class="number">2</span>,<span class="number">1</span>,()), (<span class="number">2</span>,<span class="number">3</span>,())]</span><br><span class="line">  nodes = zip [<span class="number">0</span>,<span class="number">1</span> ..] [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p><img src="img/graph003.png" alt=""></p>
<h3 id="DList"><a href="#DList" class="headerlink" title="DList"></a>DList</h3><p><img src="img/dList.png" alt=""></p>
<p><code>dlist</code>是一种类似于列表的结构，它针对<code>O(1)</code>追加操作进行了优化，在内部使用列表结构的<code>Church</code>编码。它特别适合于仅<code>append</code>的操作，并且在显示整个结构时只需要访问它。它特别适合在<code>Writer monad</code>上使用。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.DList</span><br><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line"><span class="keyword">import</span> Control.Monad.Writer</span><br><span class="line"></span><br><span class="line"><span class="title">logger</span> :: <span class="type">Writer</span> (<span class="type">DList</span> <span class="type">Int</span>) ()</span><br><span class="line"><span class="title">logger</span> = replicateM_ <span class="number">100000</span> $ tell (singleton <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h3><p>序列数据结构在结构上与列表类似，但针对<code>append</code>/<code>prepend</code>操作和<code>traversal</code>(遍历)进行了优化。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.Sequence</span><br><span class="line"></span><br><span class="line"><span class="title">a</span> :: <span class="type">Seq</span> <span class="type">Int</span></span><br><span class="line"><span class="title">a</span> = fromList [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">a0</span> :: <span class="type">Seq</span> <span class="type">Int</span></span><br><span class="line"><span class="title">a0</span> = a |&gt; <span class="number">4</span></span><br><span class="line"><span class="comment">-- [1,2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="title">a1</span> :: <span class="type">Seq</span> <span class="type">Int</span></span><br><span class="line"><span class="title">a1</span> = <span class="number">0</span> &lt;| a</span><br><span class="line"><span class="comment">-- [0,1,2,3]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Fingertree-指状树"><a href="#Fingertree-指状树" class="headerlink" title="Fingertree(指状树)"></a>Fingertree(指状树)</h3><blockquote>
<p>TODO</p>
</blockquote>
<p>請看:</p>
<ul>
<li><a href="https://hackage.haskell.org/package/fingertree" target="_blank" rel="noopener">fingertree</a></li>
</ul>
<h3 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h3><blockquote>
<p>TODO</p>
</blockquote>
<p>請看:</p>
<ul>
<li><a href="https://hackage.haskell.org/package/vault" target="_blank" rel="noopener">vault</a></li>
</ul>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> thank you </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
        <span><a href="https://serokell.io/blog">serokell</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/blog/js/index.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--create by tea9-->

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <script>
        var gitalk = new Gitalk({
          clientID: '7cfc73dd62b57f07ed83',
          clientSecret: 'dd03b7e54aadf0d81e4c9c93e23a41272bcfcfa1',
          repo: 'blog',
          owner: 'limengyu1990',
          admin: 'limengyu1990',
          id: location.pathname,      // Ensure uniqueness and length less than 50
          distractionFreeMode: false  // Facebook-like distraction free mode
        })
        gitalk.render('comment-container')
    </script>

<!--end-->


</html>
