<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        Haskell-Advanced-Monads - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 我，Lionel Messi，我不是天生强大，我只是天生要强。 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>不负如来不负卿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Function-Monad"><span class="toc-text">Function Monad</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RWS-Monad"><span class="toc-text">RWS Monad</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cont"><span class="toc-text">Cont</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MonadPlus"><span class="toc-text">MonadPlus</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MonadFix"><span class="toc-text">MonadFix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ST-Monad"><span class="toc-text">ST Monad</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Free-Monads"><span class="toc-text">Free Monads</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Indexed-Monads"><span class="toc-text">Indexed Monads</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lifted-base"><span class="toc-text">lifted-base</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#monad-base"><span class="toc-text">monad-base</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#monad-control"><span class="toc-text">monad-control</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 我，Lionel Messi，我不是天生强大，我只是天生要强。 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Haskell-Advanced-Monads
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-10-16 19:32:59</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/blog/tags/#Wish-Knew" title="Wish-Knew">Wish-Knew</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Haskell" title="Haskell">Haskell</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Advanced-Monads" title="Advanced-Monads">Advanced-Monads</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p><a href="http://dev.stephendiehl.com/hask/#advanced-monads" target="_blank" rel="noopener">原文</a></p>
</blockquote>
<h3 id="Function-Monad"><a href="#Function-Monad" class="headerlink" title="Function Monad"></a>Function Monad</h3><p>如果一个人写了<code>Haskell</code>足够长的时间，他可能最终会遇到奇怪的野兽，即(<code>(-&gt;) r</code>)的<code>monad</code>实例。使用它通常不太直观，但是当人们认为它是未包装的<code>Reader monad</code>时，它非常简单。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">  fmap = (.)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">  return = const</span><br><span class="line">  f &gt;&gt;= k = \r -&gt; k (f r) r</span><br></pre></td></tr></table></figure></p>
<p>这仅使用<code>arrow</code>(箭头)类型运算符的前缀形式。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line"></span><br><span class="line"><span class="title">id'</span> :: (-&gt;) a a</span><br><span class="line"><span class="title">id'</span> = id</span><br><span class="line"></span><br><span class="line"><span class="title">const'</span> :: (-&gt;) a ((-&gt;) b a)</span><br><span class="line"><span class="title">const'</span> = const</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Monad m =&gt; a -&gt; m a</span></span><br><span class="line"><span class="title">fret</span> :: a -&gt; b -&gt; a</span><br><span class="line"><span class="title">fret</span> = return</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</span></span><br><span class="line"><span class="title">fbind</span> :: (r -&gt; a) -&gt; (a -&gt; (r -&gt; b)) -&gt; (r -&gt; b)</span><br><span class="line"><span class="title">fbind</span> f k = f &gt;&gt;= k</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Monad m =&gt; m (m a) -&gt; m a</span></span><br><span class="line"><span class="title">fjoin</span> :: (r -&gt; (r -&gt; a)) -&gt; (r -&gt; a)</span><br><span class="line"><span class="title">fjoin</span> = join</span><br><span class="line"></span><br><span class="line"><span class="title">fid</span> :: a -&gt; a</span><br><span class="line"><span class="title">fid</span> = const &gt;&gt;= id</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span></span><br><span class="line"><span class="title">fcompose</span> :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)</span><br><span class="line"><span class="title">fcompose</span> = (.)</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Reader</span> r = (-&gt;) r <span class="comment">-- pseudocode</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> (<span class="type">Reader</span> <span class="title">r</span>) <span class="keyword">where</span></span></span><br><span class="line">  return a = \_ -&gt; a</span><br><span class="line">  f &gt;&gt;= k = \r -&gt; k (f r) r</span><br><span class="line"></span><br><span class="line"><span class="title">ask'</span> :: r -&gt; r</span><br><span class="line"><span class="title">ask'</span> = id</span><br><span class="line"></span><br><span class="line"><span class="title">asks'</span> :: (r -&gt; a) -&gt; (r -&gt; a)</span><br><span class="line"><span class="title">asks'</span> f = id . f</span><br><span class="line"></span><br><span class="line"><span class="title">runReader'</span> :: (r -&gt; a) -&gt; r -&gt; a</span><br><span class="line"><span class="title">runReader'</span> = id</span><br></pre></td></tr></table></figure></p>
<h3 id="RWS-Monad"><a href="#RWS-Monad" class="headerlink" title="RWS Monad"></a>RWS Monad</h3><p><code>RWS monad</code>结合了以上讨论的三个<code>monad</code>的功能，即<code>Reader</code>，<code>Writer</code>和<code>State</code>。还有一个<code>RWST transformer</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">runReader</span> :: <span class="type">Reader</span> r a -&gt; r -&gt; a</span><br><span class="line"><span class="title">runWriter</span> :: <span class="type">Writer</span> w a -&gt; (a, w)</span><br><span class="line"><span class="title">runState</span>  :: <span class="type">State</span> s a -&gt; s -&gt; (a, s)</span><br></pre></td></tr></table></figure></p>
<p>这三个评估函数现在合并为以下函数:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">runRWS</span>  :: <span class="type">RWS</span> r w s a -&gt; r -&gt; s -&gt; (a, s, w)</span><br><span class="line"><span class="title">execRWS</span> :: <span class="type">RWS</span> r w s a -&gt; r -&gt; s -&gt; (s, w)</span><br><span class="line"><span class="title">evalRWS</span> :: <span class="type">RWS</span> r w s a -&gt; r -&gt; s -&gt; (a, w)</span><br><span class="line"><span class="keyword">import</span> Control.Monad.RWS</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">R</span> = <span class="type">Int</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">W</span> = [<span class="type">Int</span>]</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">S</span> = <span class="type">Int</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">computation</span> :: <span class="type">RWS</span> <span class="type">R</span> <span class="type">W</span> <span class="type">S</span> ()</span><br><span class="line"><span class="title">computation</span> = <span class="keyword">do</span></span><br><span class="line">  e &lt;- ask</span><br><span class="line">  a &lt;- get</span><br><span class="line">  <span class="keyword">let</span> b = a + e</span><br><span class="line">  put b</span><br><span class="line">  tell [b]</span><br><span class="line"></span><br><span class="line"><span class="title">example</span> = runRWS computation <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>关于<code>Writer laziness</code>的常见警告也适用于<code>RWS</code>.</p>
<h3 id="Cont"><a href="#Cont" class="headerlink" title="Cont"></a>Cont</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">runCont</span> :: <span class="type">Cont</span> r a -&gt; (a -&gt; r) -&gt; r</span><br><span class="line"><span class="title">callCC</span> :: <span class="type">MonadCont</span> m =&gt; ((a -&gt; m b) -&gt; m a) -&gt; m a</span><br><span class="line"><span class="title">cont</span> :: ((a -&gt; r) -&gt; r) -&gt; <span class="type">Cont</span> r a</span><br></pre></td></tr></table></figure>
<p>在<code>continuation-passing</code>(连续传递)样式中，复合计算是由嵌套计算序列构成的，嵌套计算序列以<code>final continuation</code>(连续)结束，<code>final continuation</code>通过将函数传递到<code>continuation</code>链中而产生完整计算的结果。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">add</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">add</span> x y = x + y</span><br><span class="line"></span><br><span class="line"><span class="title">add</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; (<span class="type">Int</span> -&gt; r) -&gt; r</span><br><span class="line"><span class="title">add</span> x y k = k (x + y)</span><br><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line"><span class="keyword">import</span> Control.Monad.Cont</span><br><span class="line"></span><br><span class="line"><span class="title">add</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Cont</span> k <span class="type">Int</span></span><br><span class="line"><span class="title">add</span> x y = return $ x + y</span><br><span class="line"></span><br><span class="line"><span class="title">mult</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Cont</span> k <span class="type">Int</span></span><br><span class="line"><span class="title">mult</span> x y = return $ x * y</span><br><span class="line"></span><br><span class="line"><span class="title">contt</span> :: <span class="type">ContT</span> () <span class="type">IO</span> ()</span><br><span class="line"><span class="title">contt</span> = <span class="keyword">do</span></span><br><span class="line">    k &lt;- <span class="keyword">do</span></span><br><span class="line">      callCC $ \exit -&gt; <span class="keyword">do</span></span><br><span class="line">        lift $ putStrLn <span class="string">"Entry"</span></span><br><span class="line">        exit $ \_ -&gt; <span class="keyword">do</span></span><br><span class="line">          putStrLn <span class="string">"Exit"</span></span><br><span class="line">    lift $ putStrLn <span class="string">"Inside"</span></span><br><span class="line">    lift $ k ()</span><br><span class="line"></span><br><span class="line"><span class="title">callcc</span> :: <span class="type">Cont</span> <span class="type">String</span> <span class="type">Integer</span></span><br><span class="line"><span class="title">callcc</span> = <span class="keyword">do</span></span><br><span class="line">  a &lt;- return <span class="number">1</span></span><br><span class="line">  b &lt;- callCC (\k -&gt; k <span class="number">2</span>)</span><br><span class="line">  return $ a+b</span><br><span class="line"></span><br><span class="line"><span class="title">ex1</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">ex1</span> = print $ runCont (f &gt;&gt;= g) id</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    f = add <span class="number">1</span> <span class="number">2</span></span><br><span class="line">    g = mult <span class="number">3</span></span><br><span class="line"><span class="comment">-- 9</span></span><br><span class="line"></span><br><span class="line"><span class="title">ex2</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">ex2</span> = print $ runCont callcc show</span><br><span class="line"><span class="comment">-- "3"</span></span><br><span class="line"></span><br><span class="line"><span class="title">ex3</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">ex3</span> = runContT contt print</span><br><span class="line"><span class="comment">-- Entry</span></span><br><span class="line"><span class="comment">-- Inside</span></span><br><span class="line"><span class="comment">-- Exit</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  ex1</span><br><span class="line">  ex2</span><br><span class="line">  ex3</span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Cont</span> r a = <span class="type">Cont</span> &#123; <span class="title">runCont</span> :: ((<span class="title">a</span> -&gt; <span class="title">r</span>) -&gt; <span class="title">r</span>) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> (<span class="type">Cont</span> <span class="title">r</span>) <span class="keyword">where</span></span></span><br><span class="line">  return a       = <span class="type">Cont</span> $ \k -&gt; k a</span><br><span class="line">  (<span class="type">Cont</span> c) &gt;&gt;= f = <span class="type">Cont</span> $ \k -&gt; c (\a -&gt; runCont (f a) k)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Monad</span> <span class="title">m</span>) =&gt; <span class="type">MonadCont</span> m <span class="keyword">where</span></span></span><br><span class="line">  callCC :: ((a -&gt; m b) -&gt; m a) -&gt; m a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadCont</span> (<span class="type">Cont</span> <span class="title">r</span>) <span class="keyword">where</span></span></span><br><span class="line">  callCC f = <span class="type">Cont</span> $ \k -&gt; runCont (f (\a -&gt; <span class="type">Cont</span> $ \_ -&gt; k a)) k</span><br></pre></td></tr></table></figure></p>
<p>請看:<br>    <a href="http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style" target="_blank" rel="noopener">Wikibooks: Continuation Passing Style</a><br>    <a href="https://wiki.haskell.org/MonadCont_under_the_hood" target="_blank" rel="noopener">MonadCont Under the Hood</a></p>
<h3 id="MonadPlus"><a href="#MonadPlus" class="headerlink" title="MonadPlus"></a>MonadPlus</h3><p>选择与失败.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Alternative</span> <span class="title">m</span>, <span class="type">Monad</span> <span class="title">m</span>) =&gt; <span class="type">MonadPlus</span> m <span class="keyword">where</span></span></span><br><span class="line">   mzero :: m a</span><br><span class="line">   mplus :: m a -&gt; m a -&gt; m a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadPlus</span> [] <span class="keyword">where</span></span></span><br><span class="line">   mzero = []</span><br><span class="line">   mplus = (++)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadPlus</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">   mzero = <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line">   <span class="type">Nothing</span> `mplus` ys  = ys</span><br><span class="line">   xs      `mplus` _ys = xs</span><br></pre></td></tr></table></figure></p>
<p><code>MonadPlus forms a monoid with</code><br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mzero</span> `mplus` a = a</span><br><span class="line"><span class="title">a</span> `mplus` mzero = a</span><br><span class="line">(a `mplus` b) `mplus` c = a `mplus` (b `mplus` c)</span><br><span class="line"><span class="title">asum</span> :: (<span class="type">Foldable</span> t, <span class="type">Alternative</span> f) =&gt; t (f a) -&gt; f a</span><br><span class="line"><span class="title">asum</span> = foldr (&lt;|&gt;) empty</span><br><span class="line"></span><br><span class="line"><span class="title">msum</span> :: (<span class="type">Foldable</span> t, <span class="type">MonadPlus</span> m) =&gt; t (m a) -&gt; m a</span><br><span class="line"><span class="title">msum</span> = asum</span><br><span class="line"><span class="keyword">import</span> Safe</span><br><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line"></span><br><span class="line"><span class="title">list1</span> :: [(<span class="type">Int</span>,<span class="type">Int</span>)]</span><br><span class="line"><span class="title">list1</span> = [(a,b) | a &lt;- [<span class="number">1.</span><span class="number">.25</span>], b &lt;- [<span class="number">1.</span><span class="number">.25</span>], a &lt; b]</span><br><span class="line"></span><br><span class="line"><span class="title">list2</span> :: [(<span class="type">Int</span>,<span class="type">Int</span>)]</span><br><span class="line"><span class="title">list2</span> = <span class="keyword">do</span></span><br><span class="line">  a &lt;- [<span class="number">1.</span><span class="number">.25</span>]</span><br><span class="line">  b &lt;- [<span class="number">1.</span><span class="number">.25</span>]</span><br><span class="line">  guard (a &lt; b)</span><br><span class="line">  return $ (a,b)</span><br><span class="line"></span><br><span class="line"><span class="title">maybe1</span> :: <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">Maybe</span> <span class="type">Double</span></span><br><span class="line"><span class="title">maybe1</span> a b = <span class="keyword">do</span></span><br><span class="line">  a' &lt;- readMay a</span><br><span class="line">  b' &lt;- readMay b</span><br><span class="line">  guard (b' /= <span class="number">0.0</span>)</span><br><span class="line">  return $ a'/b'</span><br><span class="line"></span><br><span class="line"><span class="title">maybe2</span> :: <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">maybe2</span> = msum [<span class="type">Nothing</span>, <span class="type">Nothing</span>, <span class="type">Just</span> <span class="number">3</span>, <span class="type">Just</span> <span class="number">4</span>]</span><br><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line"></span><br><span class="line"><span class="title">range</span> :: <span class="type">MonadPlus</span> m =&gt; [a] -&gt; m a</span><br><span class="line"><span class="title">range</span> [] = mzero</span><br><span class="line"><span class="title">range</span> (x:xs) = range xs `mplus` return x</span><br><span class="line"></span><br><span class="line"><span class="title">pyth</span> :: <span class="type">Integer</span> -&gt; [(<span class="type">Integer</span>,<span class="type">Integer</span>,<span class="type">Integer</span>)]</span><br><span class="line"><span class="title">pyth</span> n = <span class="keyword">do</span></span><br><span class="line">  x &lt;- range [<span class="number">1.</span>.n]</span><br><span class="line">  y &lt;- range [<span class="number">1.</span>.n]</span><br><span class="line">  z &lt;- range [<span class="number">1.</span>.n]</span><br><span class="line">  <span class="keyword">if</span> x*x + y*y == z*z <span class="keyword">then</span> return (x,y,z) <span class="keyword">else</span> mzero</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = print $ pyth <span class="number">15</span></span><br><span class="line"><span class="comment">&#123;-</span></span><br><span class="line"><span class="comment">[ ( 12 , 9 , 15 )</span></span><br><span class="line"><span class="comment">, ( 12 , 5 , 13 )</span></span><br><span class="line"><span class="comment">, ( 9 , 12 , 15 )</span></span><br><span class="line"><span class="comment">, ( 8 , 6 , 10 )</span></span><br><span class="line"><span class="comment">, ( 6 , 8 , 10 )</span></span><br><span class="line"><span class="comment">, ( 5 , 12 , 13 )</span></span><br><span class="line"><span class="comment">, ( 4 , 3 , 5 )</span></span><br><span class="line"><span class="comment">, ( 3 , 4 , 5 )</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">-&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="MonadFix"><a href="#MonadFix" class="headerlink" title="MonadFix"></a>MonadFix</h3><p><code>monadic</code>计算的<code>fixed</code>(固定)点。<code>mfix f</code>仅执行一次<code>f</code>动作，最终的输出作为输入被反馈。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fix</span> :: (a -&gt; a) -&gt; a</span><br><span class="line"><span class="title">fix</span> f = <span class="keyword">let</span> x = f x <span class="keyword">in</span> x</span><br><span class="line"></span><br><span class="line"><span class="title">mfix</span> :: (a -&gt; m a) -&gt; m a</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m =&gt; <span class="type">MonadFix</span> m <span class="keyword">where</span></span></span><br><span class="line">   mfix :: (a -&gt; m a) -&gt; m a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadFix</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">   mfix f = <span class="keyword">let</span> a = f (unJust a) <span class="keyword">in</span> a</span><br><span class="line">            <span class="keyword">where</span> unJust (<span class="type">Just</span> x) = x</span><br><span class="line">                  unJust <span class="type">Nothing</span>  = error <span class="string">"mfix Maybe: Nothing"</span></span><br></pre></td></tr></table></figure></p>
<p>常规的<code>do-notation</code>也可以通过<code>-XRecursiveDo</code>扩展，以适应递归<code>monadic</code>绑定。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE RecursiveDo #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Control.Applicative</span><br><span class="line"><span class="keyword">import</span> Control.Monad.Fix</span><br><span class="line"></span><br><span class="line"><span class="title">stream1</span> :: <span class="type">Maybe</span> [<span class="type">Int</span>]</span><br><span class="line"><span class="title">stream1</span> = <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">rec</span> xs &lt;- <span class="type">Just</span> (<span class="number">1</span>:xs)</span><br><span class="line">  return (map negate xs)</span><br><span class="line"></span><br><span class="line"><span class="title">stream2</span> :: <span class="type">Maybe</span> [<span class="type">Int</span>]</span><br><span class="line"><span class="title">stream2</span> = mfix $ \xs -&gt; <span class="keyword">do</span></span><br><span class="line">  xs' &lt;- <span class="type">Just</span> (<span class="number">1</span>:xs)</span><br><span class="line">  return (map negate xs')</span><br></pre></td></tr></table></figure></p>
<p>s</p>
<h3 id="ST-Monad"><a href="#ST-Monad" class="headerlink" title="ST Monad"></a>ST Monad</h3><p><code>ST monad</code>为有状态计算的<code>threads</code>建模，这些<code>threads</code>可以操作可变引用，但在计算时仅限于返回<code>pure</code>(纯)值，并且静态地限制在<code>s</code>线程的<code>ST monad</code>中。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">runST</span> :: (<span class="keyword">forall</span> s. <span class="type">ST</span> s a) -&gt; a</span><br><span class="line"><span class="title">newSTRef</span> :: a -&gt; <span class="type">ST</span> s (<span class="type">STRef</span> s a)</span><br><span class="line"><span class="title">readSTRef</span> :: <span class="type">STRef</span> s a -&gt; <span class="type">ST</span> s a</span><br><span class="line"><span class="title">writeSTRef</span> :: <span class="type">STRef</span> s a -&gt; a -&gt; <span class="type">ST</span> s ()</span><br><span class="line"><span class="keyword">import</span> Data.STRef</span><br><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line"><span class="keyword">import</span> Control.Monad.ST</span><br><span class="line"><span class="keyword">import</span> Control.Monad.State.Strict</span><br><span class="line"></span><br><span class="line"><span class="title">example1</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">example1</span> = runST $ <span class="keyword">do</span></span><br><span class="line">  x &lt;- newSTRef <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  forM_ [<span class="number">1.</span><span class="number">.1000</span>] $ \j -&gt; <span class="keyword">do</span></span><br><span class="line">    writeSTRef x j</span><br><span class="line"></span><br><span class="line">  readSTRef x</span><br><span class="line"></span><br><span class="line"><span class="title">example2</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">example2</span> = runST $ <span class="keyword">do</span></span><br><span class="line">  count &lt;- newSTRef <span class="number">0</span></span><br><span class="line">  replicateM_ (<span class="number">10</span>^<span class="number">6</span>) $ modifySTRef' count (+<span class="number">1</span>)</span><br><span class="line">  readSTRef count</span><br><span class="line"></span><br><span class="line"><span class="title">example3</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">example3</span> = flip evalState <span class="number">0</span> $ <span class="keyword">do</span></span><br><span class="line">  replicateM_ (<span class="number">10</span>^<span class="number">6</span>) $ modify' (+<span class="number">1</span>)</span><br><span class="line">  get</span><br><span class="line"></span><br><span class="line"><span class="title">modify'</span> :: <span class="type">MonadState</span> a m =&gt; (a -&gt; a) -&gt; m ()</span><br><span class="line"><span class="title">modify'</span> f = get &gt;&gt;= (\x -&gt; put $! f x)</span><br></pre></td></tr></table></figure></p>
<p>使用<code>ST monad</code>，我们可以创建一类有效的纯函數数据结构，该结构以引用透明的方式使用可变引用。</p>
<h3 id="Free-Monads"><a href="#Free-Monads" class="headerlink" title="Free Monads"></a>Free Monads</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pure</span> :: a -&gt; <span class="type">Free</span> f a</span><br><span class="line"><span class="type">Free</span> :: f (<span class="type">Free</span> f a) -&gt; <span class="type">Free</span> f a</span><br><span class="line"></span><br><span class="line"><span class="title">liftF</span> :: (<span class="type">Functor</span> f, <span class="type">MonadFree</span> f m) =&gt; f a -&gt; m a</span><br><span class="line"><span class="title">retract</span> :: <span class="type">Monad</span> f =&gt; <span class="type">Free</span> f a -&gt; f a</span><br></pre></td></tr></table></figure>
<p><code>Free monad</code>是一个<code>monad</code>，它不具有<code>combines</code>(结合)计算的<code>join</code>操作，而是从<code>functor</code>(函子)的<code>application</code>(应用)中形成<code>composite</code>(复合)计算。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">join</span> :: <span class="type">Monad</span> m =&gt; m (m a) -&gt; m a</span><br><span class="line"><span class="title">wrap</span> :: <span class="type">MonadFree</span> f m =&gt; f (m a) -&gt; m a</span><br></pre></td></tr></table></figure></p>
<p>最好的例子之一是<code>Partiality monad</code>，它对可以分散的计算进行建模。<code>Haskell</code>允许无限制的递归，但是例如，我们可以从<code>Maybe functor</code>(函子)创建一个<code>Free monad</code>，该<code>monad</code>可用于固定调用深度，例如<a href="https://en.wikipedia.org/wiki/Ackermann_function" target="_blank" rel="noopener">Ackermann函数</a>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Monad.Fix</span><br><span class="line"><span class="keyword">import</span> Control.Monad.Free</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Partiality</span> a = <span class="type">Free</span> <span class="type">Maybe</span> a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Non-termination.</span></span><br><span class="line"><span class="title">never</span> :: <span class="type">Partiality</span> a</span><br><span class="line"><span class="title">never</span> = fix (<span class="type">Free</span> . <span class="type">Just</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">fromMaybe</span> :: <span class="type">Maybe</span> a -&gt; <span class="type">Partiality</span> a</span><br><span class="line"><span class="title">fromMaybe</span> (<span class="type">Just</span> x) = <span class="type">Pure</span> x</span><br><span class="line"><span class="title">fromMaybe</span> <span class="type">Nothing</span> = <span class="type">Free</span> <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="title">runPartiality</span> :: <span class="type">Int</span> -&gt; <span class="type">Partiality</span> a -&gt; <span class="type">Maybe</span> a</span><br><span class="line"><span class="title">runPartiality</span> <span class="number">0</span> _ = <span class="type">Nothing</span></span><br><span class="line"><span class="title">runPartiality</span> _ (<span class="type">Pure</span> a) = <span class="type">Just</span> a</span><br><span class="line"><span class="title">runPartiality</span> _ (<span class="type">Free</span> <span class="type">Nothing</span>) = <span class="type">Nothing</span></span><br><span class="line"><span class="title">runPartiality</span> n (<span class="type">Free</span> (<span class="type">Just</span> a)) = runPartiality (n<span class="number">-1</span>) a</span><br><span class="line"></span><br><span class="line"><span class="title">ack</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Partiality</span> <span class="type">Int</span></span><br><span class="line"><span class="title">ack</span> <span class="number">0</span> n = <span class="type">Pure</span> $ n + <span class="number">1</span></span><br><span class="line"><span class="title">ack</span> m <span class="number">0</span> = <span class="type">Free</span> $ <span class="type">Just</span> $ ack (m<span class="number">-1</span>) <span class="number">1</span></span><br><span class="line"><span class="title">ack</span> m n = <span class="type">Free</span> $ <span class="type">Just</span> $ ack m (n<span class="number">-1</span>) &gt;&gt;= ack (m<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">let</span> diverge = never :: <span class="type">Partiality</span> ()</span><br><span class="line">  print $ runPartiality <span class="number">1000</span> diverge</span><br><span class="line">  print $ runPartiality <span class="number">1000</span> (ack <span class="number">3</span> <span class="number">4</span>)</span><br><span class="line">  print $ runPartiality <span class="number">5500</span> (ack <span class="number">3</span> <span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>
<p><code>Free monad</code>的另一个常见用途是构建嵌入式领域特定的语言来描述计算。<br>我们可以通过在<code>IOFree</code>单子内部建立对计算的纯描述，然后使用<code>free monad</code>将转换编码为<code>effectful</code>(有效)的<code>IO</code>计算，来对<code>IO monad</code>的子集建模。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DeriveFunctor #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> System.Exit</span><br><span class="line"><span class="keyword">import</span> Control.Monad.Free</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Interaction</span> x</span></span><br><span class="line">  = <span class="type">Puts</span> <span class="type">String</span> x</span><br><span class="line">  | <span class="type">Gets</span> (<span class="type">Char</span> -&gt; x)</span><br><span class="line">  | <span class="type">Exit</span></span><br><span class="line">  <span class="keyword">deriving</span> <span class="type">Functor</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">IOFree</span> a = <span class="type">Free</span> <span class="type">Interaction</span> a</span></span><br><span class="line"></span><br><span class="line"><span class="title">puts</span> :: <span class="type">String</span> -&gt; <span class="type">IOFree</span> ()</span><br><span class="line"><span class="title">puts</span> s = liftF $ <span class="type">Puts</span> s ()</span><br><span class="line"></span><br><span class="line"><span class="title">get</span> :: <span class="type">IOFree</span> <span class="type">Char</span></span><br><span class="line"><span class="title">get</span> = liftF $ <span class="type">Gets</span> id</span><br><span class="line"></span><br><span class="line"><span class="title">exit</span> :: <span class="type">IOFree</span> r</span><br><span class="line"><span class="title">exit</span> = liftF <span class="type">Exit</span></span><br><span class="line"></span><br><span class="line"><span class="title">gets</span> :: <span class="type">IOFree</span> <span class="type">String</span></span><br><span class="line"><span class="title">gets</span> = <span class="keyword">do</span></span><br><span class="line">  c &lt;- get</span><br><span class="line">  <span class="keyword">if</span> c == '\n'</span><br><span class="line">    <span class="keyword">then</span> return <span class="string">""</span></span><br><span class="line">    <span class="keyword">else</span> gets &gt;&gt;= \line -&gt; return (c : line)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Collapse our IOFree DSL into IO monad actions.</span></span><br><span class="line"><span class="comment">-- 将我们的IOFree DSL折叠为IO monad操作。</span></span><br><span class="line"><span class="title">interp</span> :: <span class="type">IOFree</span> a -&gt; <span class="type">IO</span> a</span><br><span class="line"><span class="title">interp</span> (<span class="type">Pure</span> r) = return r</span><br><span class="line"><span class="title">interp</span> (<span class="type">Free</span> x) = <span class="keyword">case</span> x <span class="keyword">of</span></span><br><span class="line">  <span class="type">Puts</span> s t -&gt; putStrLn s &gt;&gt; interp t</span><br><span class="line">  <span class="type">Gets</span> f   -&gt; getChar &gt;&gt;= interp . f</span><br><span class="line">  <span class="type">Exit</span>     -&gt; exitSuccess</span><br><span class="line"></span><br><span class="line"><span class="title">echo</span> :: <span class="type">IOFree</span> ()</span><br><span class="line"><span class="title">echo</span> = <span class="keyword">do</span></span><br><span class="line">  puts <span class="string">"Enter your name:"</span></span><br><span class="line">  str &lt;- gets</span><br><span class="line">  puts str</span><br><span class="line">  <span class="keyword">if</span> length str &gt; <span class="number">10</span></span><br><span class="line">    <span class="keyword">then</span> puts <span class="string">"You have a long name."</span></span><br><span class="line">    <span class="keyword">else</span> puts <span class="string">"You have a short name."</span></span><br><span class="line">  exit</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = interp echo</span><br></pre></td></tr></table></figure></p>
<p>诸如<a href="http://hackage.haskell.org/package/free" target="_blank" rel="noopener">free</a>中的实现的实现可能如下所示:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE MultiParamTypeClasses #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Control.Applicative</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Free</span> f a</span></span><br><span class="line">  = <span class="type">Pure</span> a</span><br><span class="line">  | <span class="type">Free</span> (f (<span class="type">Free</span> f a))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> f =&gt; <span class="type">Monad</span> (<span class="type">Free</span> <span class="title">f</span>) <span class="keyword">where</span></span></span><br><span class="line">  return a     = <span class="type">Pure</span> a</span><br><span class="line">  <span class="type">Pure</span> a &gt;&gt;= f = f a</span><br><span class="line">  <span class="type">Free</span> f &gt;&gt;= g = <span class="type">Free</span> (fmap (&gt;&gt;= g) f)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m =&gt; <span class="type">MonadFree</span> f m  <span class="keyword">where</span></span></span><br><span class="line">  wrap :: f (m a) -&gt; m a</span><br><span class="line"></span><br><span class="line"><span class="title">liftF</span> :: (<span class="type">Functor</span> f, <span class="type">MonadFree</span> f m) =&gt; f a -&gt; m a</span><br><span class="line"><span class="title">liftF</span> = wrap . fmap return</span><br><span class="line"></span><br><span class="line"><span class="title">iter</span> :: <span class="type">Functor</span> f =&gt; (f a -&gt; a) -&gt; <span class="type">Free</span> f a -&gt; a</span><br><span class="line"><span class="title">iter</span> _ (<span class="type">Pure</span> a) = a</span><br><span class="line"><span class="title">iter</span> phi (<span class="type">Free</span> m) = phi (iter phi &lt;$&gt; m)</span><br><span class="line"></span><br><span class="line"><span class="title">retract</span> :: <span class="type">Monad</span> f =&gt; <span class="type">Free</span> f a -&gt; f a</span><br><span class="line"><span class="title">retract</span> (<span class="type">Pure</span> a) = return a</span><br><span class="line"><span class="title">retract</span> (<span class="type">Free</span> <span class="keyword">as</span>) = <span class="keyword">as</span> &gt;&gt;= retract</span><br></pre></td></tr></table></figure></p>
<p>請看:<br>    <a href="http://www.andres-loeh.de/Free.pdf" target="_blank" rel="noopener">Monads for Free!</a><br>    <a href="http://r6.ca/blog/20110520T220201Z.html" target="_blank" rel="noopener">I/O is not a Monad</a></p>
<h3 id="Indexed-Monads"><a href="#Indexed-Monads" class="headerlink" title="Indexed Monads"></a>Indexed Monads</h3><p><code>Indexed monad</code>是<code>monad</code>的概括，它向类添加了附加的类型参数，该参数携带有关<code>monadic implementation</code>的计算或结构的信息。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">IxMonad</span> md <span class="keyword">where</span></span></span><br><span class="line">  return :: a -&gt; md i i a</span><br><span class="line">  (&gt;&gt;=) :: md i m a -&gt; (a -&gt; md m o b) -&gt; md i o b</span><br></pre></td></tr></table></figure></p>
<p><code>canonical</code>(规范)用例是<code>vanilla</code>状态的一种变体，它允许在<code>monad</code>内部的中间步骤的状态上进行类型更改。<br>实际上，这对于处理涉及资源管理的一类问题非常有用，因为额外的索引参数为我们提供了空间，可以通过在编译时允许和限制索引参数上的某些状态转换来静态执行<code>monadic</code>动作序列。<br>为了使它更有用，我们将使用比较深奥的<code>-XRebindableSyntax</code>，通过提供模块本地的替代定义，使我们可以重载<code>do-notation</code>和<code>if-then-else</code>语法。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE RebindableSyntax #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ScopedTypeVariables #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE NoMonomorphismRestriction #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.IORef</span><br><span class="line"><span class="keyword">import</span> Data.Char</span><br><span class="line"><span class="keyword">import</span> Prelude <span class="keyword">hiding</span> (<span class="title">fmap</span>, (&gt;&gt;=), (&gt;&gt;), return)</span><br><span class="line"><span class="keyword">import</span> Control.Applicative</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">IState</span> i o a = <span class="type">IState</span> &#123; <span class="title">runIState</span> :: <span class="title">i</span> -&gt; (<span class="title">a</span>, <span class="title">o</span>) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">evalIState</span> :: <span class="type">IState</span> i o a -&gt; i -&gt; a</span><br><span class="line"><span class="title">evalIState</span> st i = fst $ runIState st i</span><br><span class="line"></span><br><span class="line"><span class="title">execIState</span> :: <span class="type">IState</span> i o a -&gt; i -&gt; o</span><br><span class="line"><span class="title">execIState</span> st i = snd $ runIState st i</span><br><span class="line"></span><br><span class="line"><span class="title">ifThenElse</span> :: <span class="type">Bool</span> -&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">ifThenElse</span> b i j = <span class="keyword">case</span> b <span class="keyword">of</span></span><br><span class="line">  <span class="type">True</span> -&gt; i</span><br><span class="line">  <span class="type">False</span> -&gt; j</span><br><span class="line"></span><br><span class="line"><span class="title">return</span> :: a -&gt; <span class="type">IState</span> s s a</span><br><span class="line"><span class="title">return</span> a = <span class="type">IState</span> $ \s -&gt; (a, s)</span><br><span class="line"></span><br><span class="line"><span class="title">fmap</span> :: (a -&gt; b) -&gt; <span class="type">IState</span> i o a -&gt; <span class="type">IState</span> i o b</span><br><span class="line"><span class="title">fmap</span> f v = <span class="type">IState</span> $ \i -&gt; <span class="keyword">let</span> (a, o) = runIState v i</span><br><span class="line">                          <span class="keyword">in</span> (f a, o)</span><br><span class="line"></span><br><span class="line"><span class="title">join</span> :: <span class="type">IState</span> i m (<span class="type">IState</span> m o a) -&gt; <span class="type">IState</span> i o a</span><br><span class="line"><span class="title">join</span> v = <span class="type">IState</span> $ \i -&gt; <span class="keyword">let</span> (w, m) = runIState v i</span><br><span class="line">                        <span class="keyword">in</span> runIState w m</span><br><span class="line"></span><br><span class="line">(&gt;&gt;=) :: <span class="type">IState</span> i m a -&gt; (a -&gt; <span class="type">IState</span> m o b) -&gt; <span class="type">IState</span> i o b</span><br><span class="line"><span class="title">v</span> &gt;&gt;= f = <span class="type">IState</span> $ \i -&gt; <span class="keyword">let</span> (a, m) = runIState v i</span><br><span class="line">                         <span class="keyword">in</span> runIState (f a) m</span><br><span class="line"></span><br><span class="line">(&gt;&gt;) :: <span class="type">IState</span> i m a -&gt; <span class="type">IState</span> m o b -&gt; <span class="type">IState</span> i o b</span><br><span class="line"><span class="title">v</span> &gt;&gt; w = v &gt;&gt;= \_ -&gt; w</span><br><span class="line"></span><br><span class="line"><span class="title">get</span> :: <span class="type">IState</span> s s s</span><br><span class="line"><span class="title">get</span> = <span class="type">IState</span> $ \s -&gt; (s, s)</span><br><span class="line"></span><br><span class="line"><span class="title">gets</span> :: (a -&gt; o) -&gt; <span class="type">IState</span> a o a</span><br><span class="line"><span class="title">gets</span> f = <span class="type">IState</span> $ \s -&gt; (s, f s)</span><br><span class="line"></span><br><span class="line"><span class="title">put</span> :: o -&gt; <span class="type">IState</span> i o ()</span><br><span class="line"><span class="title">put</span> o = <span class="type">IState</span> $ \_ -&gt; ((), o)</span><br><span class="line"></span><br><span class="line"><span class="title">modify</span> :: (i -&gt; o) -&gt; <span class="type">IState</span> i o ()</span><br><span class="line"><span class="title">modify</span> f = <span class="type">IState</span> $ \i -&gt; ((), f i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Locked</span> = <span class="type">Locked</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Unlocked</span> = <span class="type">Unlocked</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Stateful</span> a = <span class="type">IState</span> a <span class="type">Unlocked</span> a</span></span><br><span class="line"></span><br><span class="line"><span class="title">acquire</span> :: <span class="type">IState</span> i <span class="type">Locked</span> ()</span><br><span class="line"><span class="title">acquire</span> = put <span class="type">Locked</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Can only release the lock if it's held, try release the lock</span></span><br><span class="line"><span class="comment">-- that's not held is a now a type error.</span></span><br><span class="line"><span class="title">release</span> :: <span class="type">IState</span> <span class="type">Locked</span> <span class="type">Unlocked</span> ()</span><br><span class="line"><span class="title">release</span> = put <span class="type">Unlocked</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Statically forbids improper handling of resources.</span></span><br><span class="line"><span class="title">lockExample</span> :: <span class="type">Stateful</span> a</span><br><span class="line"><span class="title">lockExample</span> = <span class="keyword">do</span></span><br><span class="line">  ptr &lt;- get  :: <span class="type">IState</span> a a a</span><br><span class="line">  acquire     :: <span class="type">IState</span> a <span class="type">Locked</span> ()</span><br><span class="line">  <span class="comment">-- ...</span></span><br><span class="line">  release     :: <span class="type">IState</span> <span class="type">Locked</span> <span class="type">Unlocked</span> ()</span><br><span class="line">  return ptr</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Couldn't match type `Locked' with `Unlocked'</span></span><br><span class="line"><span class="comment">-- In a stmt of a 'do' block: return ptr</span></span><br><span class="line"><span class="title">failure1</span> :: <span class="type">Stateful</span> a</span><br><span class="line"><span class="title">failure1</span> = <span class="keyword">do</span></span><br><span class="line">  ptr &lt;- get</span><br><span class="line">  acquire</span><br><span class="line">  return ptr <span class="comment">-- didn't release</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Couldn't match type `a' with `Locked'</span></span><br><span class="line"><span class="comment">-- In a stmt of a 'do' block: release</span></span><br><span class="line"><span class="title">failure2</span> :: <span class="type">Stateful</span> a</span><br><span class="line"><span class="title">failure2</span> = <span class="keyword">do</span></span><br><span class="line">  ptr &lt;- get</span><br><span class="line">  release <span class="comment">-- didn't acquire</span></span><br><span class="line">  return ptr</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Evaluate the resulting state, statically ensuring that the</span></span><br><span class="line"><span class="comment">-- lock is released when finished.</span></span><br><span class="line"><span class="title">evalReleased</span> :: <span class="type">IState</span> i <span class="type">Unlocked</span> a -&gt; i -&gt; a</span><br><span class="line"><span class="title">evalReleased</span> f st = evalIState f st</span><br><span class="line"></span><br><span class="line"><span class="title">example</span> :: <span class="type">IO</span> (<span class="type">IORef</span> <span class="type">Integer</span>)</span><br><span class="line"><span class="title">example</span> = evalReleased &lt;$&gt; pure lockExample &lt;*&gt; newIORef <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>請看: <a href="http://www.cl.cam.ac.uk/~dao29/ixmonad/ixmonad-fita14.pdf" target="_blank" rel="noopener">Fun with Indexed monads</a></p>
<h3 id="lifted-base"><a href="#lifted-base" class="headerlink" title="lifted-base"></a>lifted-base</h3><p>默认的<code>prelude</code>早于<code>monad transformers</code>上的许多工作.<br>因此，用于处理错误和与<code>IO</code>交互的许多常用功能严格地绑定到<code>IO monad</code>，而不是绑定到在<code>IO</code>或<code>ST</code>之上实现堆栈的函數。</p>
<p><code>lifted-base</code>提供了通用的控制操作，例如可以从<code>IO</code>或任何其他基础<code>monad</code>提升的<code>catch</code>。</p>
<h4 id="monad-base"><a href="#monad-base" class="headerlink" title="monad-base"></a>monad-base</h4><p><code>Monad base</code>提供了<code>liftIO</code>和其他功能的抽象，以明确提升到转换器堆栈的<code>privileged</code>(特权)层。<br>它使用<code>base monad</code>作为参数<code>b</code>实现了多参数类型类。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- | Lift a computation from the base monad</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Applicative</span> <span class="title">b</span>, <span class="type">Applicative</span> <span class="title">m</span>, <span class="type">Monad</span> <span class="title">b</span>, <span class="type">Monad</span> <span class="title">m</span>)</span></span><br><span class="line"><span class="class">      =&gt; <span class="type">MonadBase</span> b m | m -&gt; b <span class="keyword">where</span></span></span><br><span class="line">  liftBase ∷ b a -&gt; m a</span><br></pre></td></tr></table></figure></p>
<h4 id="monad-control"><a href="#monad-control" class="headerlink" title="monad-control"></a>monad-control</h4><p><code>Monad control</code>建立在<code>monad-base</code>之上，扩展了<code>lifting</code>操作以控制诸如<code>catch</code>和<code>bracket</code>之类的操作，可以用任何支持这些操作的基础层的变压器来通用地编写.<br>然后，<code>Generic operations</code>(泛型操作)可以用<code>MonadBaseControl</code>表示，并可以用组合器<code>control</code>来編寫，该组合器处理<code>bracket</code>和自动处理<code>lifting</code>.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">control</span> :: <span class="type">MonadBaseControl</span> b m =&gt; (<span class="type">RunInBase</span> m b -&gt; b (<span class="type">StM</span> m a)) -&gt; m a</span><br></pre></td></tr></table></figure></p>
<p>例如，通常由<code>Control.Exception</code>提供的<code>catch</code>函数被锁定在<code>IO</code>中:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">catch</span> :: <span class="type">Exception</span> e =&gt; <span class="type">IO</span> a -&gt; (e -&gt; <span class="type">IO</span> a) -&gt; <span class="type">IO</span> a</span><br></pre></td></tr></table></figure></p>
<p>通过使用<code>control</code>来组合它，我们可以构造一个通用版本，它可以自动<code>lift</code>(提升)到具有<code>Monadbasecontrol</code>实例的常用变压器堆栈的任何组合中.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">catch</span></span><br><span class="line">  :: (<span class="type">MonadBaseControl</span> <span class="type">IO</span> m, <span class="type">Exception</span> e)</span><br><span class="line">  =&gt; m a        <span class="comment">-- ^ Computation</span></span><br><span class="line">  -&gt; (e -&gt; m a) <span class="comment">-- ^ Handler</span></span><br><span class="line">  -&gt; m a</span><br><span class="line"><span class="title">catch</span> a handler = control $ \runInIO -&gt;</span><br><span class="line">                    <span class="type">E</span>.catch (runInIO a)</span><br><span class="line">                            (\e -&gt; runInIO $ handler e)</span><br></pre></td></tr></table></figure></p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/blog/js/index.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/blog/js/gitment.js"></script>
<script>
    var gitment = new Gitment({
        id: 'Haskell-Advanced-Monads',
        owner: 'limengyu1990',
        repo: 'hexo-blog',
        oauth: {
            client_id: '7cfc73dd62b57f07ed83',
            client_secret: 'dd03b7e54aadf0d81e4c9c93e23a41272bcfcfa1',
        },
    })
    gitment.render('comment-container')
</script>

</html>
