<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        Haskell-Concurrency - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>不负如来不负卿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Sparks"><span class="toc-text">Sparks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Threadscope"><span class="toc-text">Threadscope</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Strategies-策略"><span class="toc-text">Strategies (策略)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STM"><span class="toc-text">STM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Monad-Par"><span class="toc-text">Monad Par</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async"><span class="toc-text">async</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Haskell-Concurrency
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-10-16 19:28:25</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/blog/tags/#Wish-Knew" title="Wish-Knew">Wish-Knew</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Haskell" title="Haskell">Haskell</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Concurrency" title="Concurrency">Concurrency</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p><a href="http://dev.stephendiehl.com/hask/#concurrency" target="_blank" rel="noopener">原文</a></p>
</blockquote>
<p><code>Haskell</code>中关于并行性和并行性的权威参考是<code>Simon Marlow</code>的文章。本节将仅<code>gloss over</code>(掩盖)这些主题，因为在本书中对它们进行了更好的解释.<br>請看:</p>
<ul>
<li><a href="http://chimera.labs.oreilly.com/books/1230000000929" target="_blank" rel="noopener">Parallel and Concurrent Programming in Haskell</a></li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">forkIO</span> :: <span class="type">IO</span> () -&gt; <span class="type">IO</span> <span class="type">ThreadId</span></span><br></pre></td></tr></table></figure>
<p><code>Haskell</code>线程的产生极其便宜，仅使用1.5KB的<code>RAM</code>(具体取决于平台)，并且比<code>C</code>语言中的<code>pthread</code>便宜得多。调用<code>forkIO</code>106次只需不到1s即可完成。此外，<code>Haskell</code>中的函数纯度还确保即使在计算过程中也几乎可以随时终止线程而无需担心。</p>
<p>請看:</p>
<ul>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Scheduler#TheScheduler" target="_blank" rel="noopener">The Scheduler</a></li>
</ul>
<h3 id="Sparks"><a href="#Sparks" class="headerlink" title="Sparks"></a>Sparks</h3><p><code>Haskell</code>中最基本的并行性<code>atom</code>是<code>spark</code>。这是对<code>GHC</code>运行时的提示: 可以并行将计算评估为<code>weak head normal form</code>(弱头范式)。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">rpar</span> :: a -&gt; <span class="type">Eval</span> a</span><br><span class="line"><span class="title">rseq</span> :: <span class="type">Strategy</span> a</span><br><span class="line"><span class="title">rdeepseq</span> :: <span class="type">NFData</span> a =&gt; <span class="type">Strategy</span> a</span><br><span class="line"></span><br><span class="line"><span class="title">runEval</span> :: <span class="type">Eval</span> a -&gt; a</span><br></pre></td></tr></table></figure></p>
<p><code>rpar a</code>产生一个独立的<code>spark</code>，该<code>spark</code>逐渐演变为<code>weak head normal form</code>，并将计算结果放入<code>spark</code>池中。<br>当运行时确定有可用的<code>CPU</code>可以评估计算时，它将评估(转换)<code>spark</code>。<br>如果程序的主线程是<code>spark</code>的评估器, 则<code>spark</code>被称为<code>fizzled</code>(模糊)。<code>Fizzling</code>通常是不好的，它表明逻辑或并行性策略不适用于正在评估的工作。</p>
<p><code>spark</code>池也被限制为(但用户可调)默认值8000(从<code>GHC 7.8.3</code>开始)。超出此限制创建的<code>spark</code>被称为<code>overflow</code>(溢出)。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Evaluates the arguments to f in parallel before application.</span></span><br><span class="line"><span class="title">par2</span> f x y = x `rpar` y `rpar` f x y</span><br></pre></td></tr></table></figure></p>
<p><code>rseq</code>的参数在评估继续之前强制评估<code>spark</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Action</span>	    <span class="type">Description</span></span><br><span class="line"><span class="comment">-----------------------------------------</span></span><br><span class="line"><span class="type">Fizzled</span>	    主线程已经评估了结果值，因此无需转换spark。</span><br><span class="line"><span class="type">Dud</span>	<span class="type">The</span>     已对表达式求值，将返回计算值，并且不转换spark。</span><br><span class="line"><span class="type">GC'd</span>	    spark被添加到spark池中，但是结果没有被引用，因此它被垃圾收集。</span><br><span class="line"><span class="type">Overflowed</span>	`spawning`(生成)时spark池中的空间不足。</span><br></pre></td></tr></table></figure></p>
<p>并行运行时对于使用<code>spark</code>是必需的，并且生成的程序必须使用<code>-threaded</code>进行编译。<br>另外，程序本身可以通过<code>-rtsopts</code>指定运行时选项，例如要使用的内核数量。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghc</span> -threaded -rtsopts program.hs</span><br><span class="line">./program +<span class="type">RTS</span> -s <span class="type">N8</span> <span class="comment">-- use 8 cores</span></span><br></pre></td></tr></table></figure></p>
<p>通过传递<code>-s</code>标志，可以要求运行时<code>dump</code>(转储)有关<code>spark</code>评估的信息。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./spark +<span class="type">RTS</span> -<span class="type">N4</span> -s</span><br><span class="line"></span><br><span class="line">                                    <span class="type">Tot</span> time (elapsed)  <span class="type">Avg</span> pause  <span class="type">Max</span> pause</span><br><span class="line">  <span class="type">Gen</span>  <span class="number">0</span>         <span class="number">5</span> colls,     <span class="number">5</span> par    <span class="number">0.02</span>s    <span class="number">0.01</span>s     <span class="number">0.0017</span>s    <span class="number">0.0048</span>s</span><br><span class="line">  <span class="type">Gen</span>  <span class="number">1</span>         <span class="number">3</span> colls,     <span class="number">2</span> par    <span class="number">0.00</span>s    <span class="number">0.00</span>s     <span class="number">0.0004</span>s    <span class="number">0.0007</span>s</span><br><span class="line"></span><br><span class="line">  <span class="type">Parallel</span> <span class="type">GC</span> work balance: <span class="number">1.83</span>% (serial <span class="number">0</span>%, perfect <span class="number">100</span>%)</span><br><span class="line"></span><br><span class="line">  <span class="type">TASKS</span>: <span class="number">6</span> (<span class="number">1</span> bound, <span class="number">5</span> peak workers (<span class="number">5</span> total), using -<span class="type">N4</span>)</span><br><span class="line"></span><br><span class="line">  <span class="type">SPARKS</span>: <span class="number">20000</span> (<span class="number">20000</span> converted, <span class="number">0</span> overflowed, <span class="number">0</span> dud, <span class="number">0</span> <span class="type">GC'd</span>, <span class="number">0</span> fizzled)</span><br></pre></td></tr></table></figure></p>
<p>并行计算本身是在<code>Eval monad</code>中排序的，用<code>runEval</code>进行计算本身就是一个纯计算。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">example</span> :: (a -&gt; b) -&gt; a -&gt; a -&gt; (b, b)</span><br><span class="line"><span class="title">example</span> f x y = runEval $ <span class="keyword">do</span></span><br><span class="line">  a &lt;- rpar $ f x</span><br><span class="line">  b &lt;- rpar $ f y</span><br><span class="line">  rseq a</span><br><span class="line">  rseq b</span><br><span class="line">  return (a, b)</span><br></pre></td></tr></table></figure></p>
<h3 id="Threadscope"><a href="#Threadscope" class="headerlink" title="Threadscope"></a>Threadscope</h3><p>传递标志<code>-l</code>会生成事件日志，该事件日志可以用<code>threadscope</code>库呈现。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ghc -<span class="type">O2</span> -threaded -rtsopts -eventlog <span class="type">Example</span>.hs</span><br><span class="line">$ ./program +<span class="type">RTS</span> -<span class="type">N4</span> -l</span><br><span class="line">$ threadscope <span class="type">Example</span>.eventlog</span><br></pre></td></tr></table></figure></p>
<p><img src="img/img01.png" alt=""></p>
<p>有关使用<code>Threadscope</code>解释和分析的详细指南，请参见<code>Simon Marlows</code>的<code>Parallel and Concurrent Programming in Haskell</code>。</p>
<p>請看:</p>
<ul>
<li><a href="http://www.well-typed.com/blog/86/" target="_blank" rel="noopener">Performance profiling with ghc-events-analyze</a></li>
</ul>
<h3 id="Strategies-策略"><a href="#Strategies-策略" class="headerlink" title="Strategies (策略)"></a>Strategies (策略)</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Strategy</span> a = a -&gt; <span class="type">Eval</span> a</span></span><br><span class="line"><span class="title">using</span> :: a -&gt; <span class="type">Strategy</span> a -&gt; a</span><br></pre></td></tr></table></figure>
<p><code>Sparks</code>本身构成了称为<code>strategies</code>(策略)的高级并行结构的基础，这些结构使<code>Spark</code>的创建适合所评估的计算或数据结构。</p>
<p>例如，如果我们想同时评估一个元组的两个元素，我们可以创建一个使用<code>spark</code>来评估该元组两侧的<code>strategies</code>。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Parallel.Strategies</span><br><span class="line"></span><br><span class="line"><span class="title">parPair'</span> :: <span class="type">Strategy</span> (a, b)</span><br><span class="line"><span class="title">parPair'</span> (a, b) = <span class="keyword">do</span></span><br><span class="line">  a' &lt;- rpar a</span><br><span class="line">  b' &lt;- rpar b</span><br><span class="line">  return (a', b')</span><br><span class="line"></span><br><span class="line"><span class="title">fib</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">fib</span> <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="title">fib</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="title">fib</span> n = fib (n<span class="number">-1</span>) + fib (n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">serial</span> :: (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="title">serial</span>   = (fib <span class="number">30</span>, fib <span class="number">31</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">parallel</span> :: (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="title">parallel</span> = runEval . parPair' $ (fib <span class="number">30</span>, fib <span class="number">31</span>)</span><br></pre></td></tr></table></figure>
<p>这种模式如此频繁地出现，组合器<code>using</code>可用于等效地以<code>operator-like</code>的形式写成，这在某些方面可能更具视觉吸引力。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">using</span> :: a -&gt; <span class="type">Strategy</span> a -&gt; a</span><br><span class="line"><span class="title">x</span> `using` s = runEval (s x)</span><br><span class="line"></span><br><span class="line"><span class="title">parallel</span> ::: (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="title">parallel</span> = (fib <span class="number">30</span>, fib <span class="number">31</span>) `using` parPair</span><br></pre></td></tr></table></figure></p>
<p>对于一个不太复杂的示例，请考虑一个并行的<code>parmap</code>，它将一个纯函数映射到一个并行的值列表上。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Parallel.Strategies</span><br><span class="line"></span><br><span class="line"><span class="title">parMap'</span> :: (a -&gt; b) -&gt; [a] -&gt; <span class="type">Eval</span> [b]</span><br><span class="line"><span class="title">parMap'</span> f [] = return []</span><br><span class="line"><span class="title">parMap'</span> f (a:<span class="keyword">as</span>) = <span class="keyword">do</span></span><br><span class="line">  b  &lt;- rpar (f a)</span><br><span class="line">  bs &lt;- parMap' f <span class="keyword">as</span></span><br><span class="line">  return (b:bs)</span><br><span class="line"></span><br><span class="line"><span class="title">result</span> :: [<span class="type">Int</span>]</span><br><span class="line"><span class="title">result</span> = runEval $ parMap' (+<span class="number">1</span>) [<span class="number">1.</span><span class="number">.1000</span>]</span><br></pre></td></tr></table></figure></p>
<p>上面的函数非常有用，但是如果需要对参数的求值进行并行处理，而不仅仅是简单的弱首范式，则会破坏这些函数。<br>例如，如果<code>rpar</code>的参数是一个嵌套的构造函数，我们希望将评估表达式的整个部分并行化为<code>normal form</code>(普通形式)，而不只是<code>outer layer</code>(外层)。<br>因此，我们想对我们的策略进行<code>generalize</code>(概括)，以便可以将参数的评估策略作为参数传递给该策略。</p>
<p><code>Control.Parallel.Strategies</code>包含<code>rpar</code>的通用版本，该版本在<code>Eval monad</code>的<code>rpar</code>计算中嵌入了附加的评估逻辑。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">rparWith</span> :: <span class="type">Strategy</span> a -&gt; <span class="type">Strategy</span> a</span><br></pre></td></tr></table></figure></p>
<p>现在，使用<code>deepseq</code>库，我们可以构建<code>rseq</code>的<code>Strategy</code>变体，其评估结果为<code>full normal form</code>(完整范式)。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">rdeepseq</span> :: <span class="type">NFData</span> a =&gt; <span class="type">Strategy</span> a</span><br><span class="line"><span class="title">rdeepseq</span> x = rseq (force x)</span><br></pre></td></tr></table></figure></p>
<p>现在，我们可以创建一个采用两个策略的<code>higher-order</code>(高阶)策略，它本身会产生一个计算，该计算在被评估时在其调度中使用传递的策略。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.DeepSeq</span><br><span class="line"><span class="keyword">import</span> Control.Parallel.Strategies</span><br><span class="line"></span><br><span class="line"><span class="title">evalPair</span> :: <span class="type">Strategy</span> a -&gt; <span class="type">Strategy</span> b -&gt; <span class="type">Strategy</span> (a, b)</span><br><span class="line"><span class="title">evalPair</span> sa sb (a, b) = <span class="keyword">do</span></span><br><span class="line">  a' &lt;- sa a</span><br><span class="line">  b' &lt;- sb b</span><br><span class="line">  return (a', b')</span><br><span class="line"></span><br><span class="line"><span class="title">parPair</span> :: <span class="type">Strategy</span> a -&gt; <span class="type">Strategy</span> b -&gt; <span class="type">Strategy</span> (a, b)</span><br><span class="line"><span class="title">parPair</span> sa sb = evalPair (rparWith sa) (rparWith sb)</span><br><span class="line"></span><br><span class="line"><span class="title">fib</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">fib</span> <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="title">fib</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="title">fib</span> n = fib (n<span class="number">-1</span>) + fib (n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">serial</span> :: ([<span class="type">Int</span>], [<span class="type">Int</span>])</span><br><span class="line"><span class="title">serial</span> = (a, b)</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    a = fmap fib [<span class="number">0.</span><span class="number">.30</span>]</span><br><span class="line">    b = fmap fib [<span class="number">1.</span><span class="number">.30</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">parallel</span> :: ([<span class="type">Int</span>], [<span class="type">Int</span>])</span><br><span class="line"><span class="title">parallel</span> = (a, b) `using` evalPair rdeepseq rdeepseq</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    a = fmap fib [<span class="number">0.</span><span class="number">.30</span>]</span><br><span class="line">    b = fmap fib [<span class="number">1.</span><span class="number">.30</span>]</span><br></pre></td></tr></table></figure></p>
<p>这些模式与其他几种通用形式和组合器一起在<code>Strategies</code>库中实现，用于组合策略以适合许多不同的并行计算。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">parTraverse</span> :: <span class="type">Traversable</span> t =&gt; <span class="type">Strategy</span> a -&gt; <span class="type">Strategy</span> (t a)</span><br><span class="line"><span class="title">dot</span> :: <span class="type">Strategy</span> a -&gt; <span class="type">Strategy</span> a -&gt; <span class="type">Strategy</span> a</span><br><span class="line">($||) :: (a -&gt; b) -&gt; <span class="type">Strategy</span> a -&gt; a -&gt; b</span><br><span class="line">(.||) :: (b -&gt; c) -&gt; <span class="type">Strategy</span> b -&gt; (a -&gt; b) -&gt; a -&gt; c</span><br></pre></td></tr></table></figure></p>
<p>請看:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/parallel-3.2.0.4/docs/Control-Parallel-Strategies.html" target="_blank" rel="noopener">Control.Concurent.Strategies</a></li>
</ul>
<h3 id="STM"><a href="#STM" class="headerlink" title="STM"></a>STM</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">atomically</span> :: <span class="type">STM</span> a -&gt; <span class="type">IO</span> a</span><br><span class="line"><span class="title">orElse</span> :: <span class="type">STM</span> a -&gt; <span class="type">STM</span> a -&gt; <span class="type">STM</span> a</span><br><span class="line"><span class="title">retry</span> :: <span class="type">STM</span> a</span><br><span class="line"></span><br><span class="line"><span class="title">newTVar</span> :: a -&gt; <span class="type">STM</span> (<span class="type">TVar</span> a)</span><br><span class="line"><span class="title">newTVarIO</span> :: a -&gt; <span class="type">IO</span> (<span class="type">TVar</span> a)</span><br><span class="line"><span class="title">writeTVar</span> :: <span class="type">TVar</span> a -&gt; a -&gt; <span class="type">STM</span> ()</span><br><span class="line"><span class="title">readTVar</span> :: <span class="type">TVar</span> a -&gt; <span class="type">STM</span> a</span><br><span class="line"></span><br><span class="line"><span class="title">modifyTVar</span> :: <span class="type">TVar</span> a -&gt; (a -&gt; a) -&gt; <span class="type">STM</span> ()</span><br><span class="line"><span class="title">modifyTVar'</span> :: <span class="type">TVar</span> a -&gt; (a -&gt; a) -&gt; <span class="type">STM</span> ()</span><br></pre></td></tr></table></figure>
<p>软件事务内存是一种保证并行计算中值原子性的技术，这样所有上下文在读写时都能看到相同的数据，保证不会导致不一致的状态。<br><code>Haskell</code>的纯度保证了<code>STM</code>内的事务是纯净的，并且在提交失败时总是可以回滚。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line"><span class="keyword">import</span> Control.Concurrent</span><br><span class="line"><span class="keyword">import</span> Control.Concurrent.STM</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Account</span> = <span class="type">TVar</span> <span class="type">Double</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">transfer</span> :: <span class="type">Account</span> -&gt; <span class="type">Account</span> -&gt; <span class="type">Double</span> -&gt; <span class="type">STM</span> ()</span><br><span class="line"><span class="title">transfer</span> from to amount = <span class="keyword">do</span></span><br><span class="line">  available &lt;- readTVar from</span><br><span class="line">  when (amount &gt; available) retry</span><br><span class="line"></span><br><span class="line">  modifyTVar from (+ (-amount))</span><br><span class="line">  modifyTVar to   (+ amount)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Threads are scheduled non-deterministically.</span></span><br><span class="line"><span class="comment">-- 线程是不确定性调度的.</span></span><br><span class="line"><span class="title">actions</span> :: <span class="type">Account</span> -&gt; <span class="type">Account</span> -&gt; [<span class="type">IO</span> <span class="type">ThreadId</span>]</span><br><span class="line"><span class="title">actions</span> a b = map forkIO [</span><br><span class="line">     <span class="comment">-- transfer to</span></span><br><span class="line">       atomically (transfer a b <span class="number">10</span>)</span><br><span class="line">     , atomically (transfer a b (<span class="number">-20</span>))</span><br><span class="line">     , atomically (transfer a b <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">     <span class="comment">-- transfer back</span></span><br><span class="line">     , atomically (transfer a b (<span class="number">-30</span>))</span><br><span class="line">     , atomically (transfer a b <span class="number">20</span>)</span><br><span class="line">     , atomically (transfer a b (<span class="number">-10</span>))</span><br><span class="line">   ]</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  accountA &lt;- atomically $ newTVar <span class="number">60</span></span><br><span class="line">  accountB &lt;- atomically $ newTVar <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  sequence_ (actions accountA accountB)</span><br><span class="line"></span><br><span class="line">  balanceA &lt;- atomically $ readTVar accountA</span><br><span class="line">  balanceB &lt;- atomically $ readTVar accountB</span><br><span class="line"></span><br><span class="line">  print $ balanceA == <span class="number">60</span></span><br><span class="line">  print $ balanceB == <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>請看:</p>
<ul>
<li><a href="https://www.fpcomplete.com/school/advanced-haskell/beautiful-concurrency" target="_blank" rel="noopener">Beautiful Concurrency</a></li>
</ul>
<h3 id="Monad-Par"><a href="#Monad-Par" class="headerlink" title="Monad Par"></a>Monad Par</h3><p>使用<code>Par monad</code>，我们将计算表示为数据流图，该数据流按<code>forked</code>(分叉)计算之间的<code>connections</code>(连接)顺序进行调度，这些分叉计算与<code>IVar</code>交换结果计算。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">new</span> :: <span class="type">Par</span> (<span class="type">IVar</span> a)</span><br><span class="line"><span class="title">put</span> :: <span class="type">NFData</span> a =&gt; <span class="type">IVar</span> a -&gt; a -&gt; <span class="type">Par</span> ()</span><br><span class="line"><span class="title">get</span> :: <span class="type">IVar</span> a -&gt; <span class="type">Par</span> a</span><br><span class="line"><span class="title">fork</span> :: <span class="type">Par</span> () -&gt; <span class="type">Par</span> ()</span><br><span class="line"><span class="title">spawn</span> :: <span class="type">NFData</span> a =&gt; <span class="type">Par</span> a -&gt; <span class="type">Par</span> (<span class="type">IVar</span> a)</span><br></pre></td></tr></table></figure></p>
<p><img src="img/img02.png" alt=""><br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line"><span class="keyword">import</span> Control.Monad.Par</span><br><span class="line"></span><br><span class="line"><span class="title">f</span>, g :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">f</span> x = x + <span class="number">10</span></span><br><span class="line"><span class="title">g</span> x = x * <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--   f x      g x</span></span><br><span class="line"><span class="comment">--     \     /</span></span><br><span class="line"><span class="comment">--      a + b</span></span><br><span class="line"><span class="comment">--      /   \</span></span><br><span class="line"><span class="comment">-- f (a+b)  g (a+b)</span></span><br><span class="line"><span class="comment">--      \   /</span></span><br><span class="line"><span class="comment">--      (d,e)</span></span><br><span class="line"></span><br><span class="line"><span class="title">example1</span> :: <span class="type">Int</span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="title">example1</span> x = runPar $ <span class="keyword">do</span></span><br><span class="line">  [a,b,c,d,e] &lt;- replicateM <span class="number">5</span> new</span><br><span class="line">  fork (put a (f x))</span><br><span class="line">  fork (put b (g x))</span><br><span class="line">  a' &lt;- get a</span><br><span class="line">  b' &lt;- get b</span><br><span class="line">  fork (put c (a' + b'))</span><br><span class="line">  c' &lt;- get c</span><br><span class="line">  fork (put d (f c'))</span><br><span class="line">  fork (put e (g c'))</span><br><span class="line">  d' &lt;- get d</span><br><span class="line">  e' &lt;- get e</span><br><span class="line">  return (d', e')</span><br><span class="line"></span><br><span class="line"><span class="title">example2</span> :: [<span class="type">Int</span>]</span><br><span class="line"><span class="title">example2</span> = runPar $ <span class="keyword">do</span></span><br><span class="line">  xs &lt;- parMap (+<span class="number">1</span>) [<span class="number">1.</span><span class="number">.25</span>]</span><br><span class="line">  return xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- foldr (+) 0 (map (^2) [1..xs])</span></span><br><span class="line"><span class="title">example3</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">example3</span> n = runPar $ <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">let</span> range = (<span class="type">InclusiveRange</span> <span class="number">1</span> n)</span><br><span class="line">  <span class="keyword">let</span> mapper x = return (x^<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">let</span> reducer x y = return (x+y)</span><br><span class="line">  parMapReduceRangeThresh <span class="number">10</span> range mapper reducer <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p><code>async</code>是一组在<code>Control.Concurrent</code>和<code>STM</code>之上工作的高级函數.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">async</span> :: <span class="type">IO</span> a -&gt; <span class="type">IO</span> (<span class="type">Async</span> a)</span><br><span class="line"><span class="title">wait</span> :: <span class="type">Async</span> a -&gt; <span class="type">IO</span> a</span><br><span class="line"><span class="title">cancel</span> :: <span class="type">Async</span> a -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">concurrently</span> :: <span class="type">IO</span> a -&gt; <span class="type">IO</span> b -&gt; <span class="type">IO</span> (a, b)</span><br><span class="line"><span class="title">race</span> :: <span class="type">IO</span> a -&gt; <span class="type">IO</span> b -&gt; <span class="type">IO</span> (<span class="type">Either</span> a b)</span><br><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line"><span class="keyword">import</span> Control.Applicative</span><br><span class="line"><span class="keyword">import</span> Control.Concurrent</span><br><span class="line"><span class="keyword">import</span> Control.Concurrent.Async</span><br><span class="line"><span class="keyword">import</span> Data.Time</span><br><span class="line"></span><br><span class="line"><span class="title">timeit</span> :: <span class="type">IO</span> a -&gt; <span class="type">IO</span> (a,<span class="type">Double</span>)</span><br><span class="line"><span class="title">timeit</span> io = <span class="keyword">do</span></span><br><span class="line">  t0 &lt;- getCurrentTime</span><br><span class="line">  a &lt;- io</span><br><span class="line">  t1 &lt;- getCurrentTime</span><br><span class="line">  return (a, realToFrac (t1 `diffUTCTime` t0))</span><br><span class="line"></span><br><span class="line"><span class="title">worker</span> :: <span class="type">Int</span> -&gt; <span class="type">IO</span> <span class="type">Int</span></span><br><span class="line"><span class="title">worker</span> n = <span class="keyword">do</span></span><br><span class="line">  <span class="comment">-- simulate some work</span></span><br><span class="line">  threadDelay (<span class="number">10</span>^<span class="number">2</span> * n)</span><br><span class="line">  return (n * n)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Spawn 2 threads in parallel, halt on both finished.</span></span><br><span class="line"><span class="comment">-- 并行生成2个线程，两个线程都完成時停止。</span></span><br><span class="line"><span class="title">test1</span> :: <span class="type">IO</span> (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="title">test1</span> = <span class="keyword">do</span></span><br><span class="line">  val1 &lt;- async $ worker <span class="number">1000</span></span><br><span class="line">  val2 &lt;- async $ worker <span class="number">2000</span></span><br><span class="line">  (,) &lt;$&gt; wait val1 &lt;*&gt; wait val2</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Spawn 2 threads in parallel, halt on first finished.</span></span><br><span class="line"><span class="comment">-- 并行生成2个线程，第一個完成时停止。</span></span><br><span class="line"><span class="title">test2</span> :: <span class="type">IO</span> (<span class="type">Either</span> <span class="type">Int</span> <span class="type">Int</span>)</span><br><span class="line"><span class="title">test2</span> = <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">let</span> val1 = worker <span class="number">1000</span></span><br><span class="line">  <span class="keyword">let</span> val2 = worker <span class="number">2000</span></span><br><span class="line">  race val1 val2</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Spawn 10000 threads in parallel, halt on all finished.</span></span><br><span class="line"><span class="comment">-- 并行生成10000个线程，全部完成时停止。</span></span><br><span class="line"><span class="title">test3</span> :: <span class="type">IO</span> [<span class="type">Int</span>]</span><br><span class="line"><span class="title">test3</span> = mapConcurrently worker [<span class="number">0.</span><span class="number">.10000</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  print =&lt;&lt; timeit test1</span><br><span class="line">  print =&lt;&lt; timeit test2</span><br><span class="line">  print =&lt;&lt; timeit test3</span><br></pre></td></tr></table></figure></p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> thank you </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
        <span><a href="https://serokell.io/blog">serokell</a></span>
        <span>/</span>
        
        <span><a href="https://iohk.io/en/blog">IOHK</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/blog/js/index.js"></script>

<!--create by tea9-->

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <script>
        var gitalk = new Gitalk({
          clientID: '7cfc73dd62b57f07ed83',
          clientSecret: 'dd03b7e54aadf0d81e4c9c93e23a41272bcfcfa1',
          repo: 'blog',
          owner: 'limengyu1990',
          admin: 'limengyu1990',
          id: location.pathname,      // Ensure uniqueness and length less than 50
          distractionFreeMode: false  // Facebook-like distraction free mode
        })
        gitalk.render('comment-container')
    </script>

<!--end-->


</html>
