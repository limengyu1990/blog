<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        Haskell-Categories - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>不负如来不负卿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Algebraic-Relations-代数关系"><span class="toc-text">Algebraic Relations (代数关系)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Categories"><span class="toc-text">Categories</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Isomorphisms-同构"><span class="toc-text">Isomorphisms(同构)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Duality-二元性-对偶性"><span class="toc-text">Duality(二元性/对偶性)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Functors-函子"><span class="toc-text">Functors(函子)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Natural-Transformations-自然变换"><span class="toc-text">Natural Transformations(自然变换)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Yoneda-Lemma"><span class="toc-text">Yoneda Lemma</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Continuation-Passing-连续传递"><span class="toc-text">Continuation Passing(连续传递)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Double-negated-principle-of-excluded-middle-排除中间的双重否定原则"><span class="toc-text">Double-negated principle of excluded middle(排除中间的双重否定原则)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kleisli-Category"><span class="toc-text">Kleisli Category</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Adjunctions"><span class="toc-text">Adjunctions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cartesian-Closed-Categories"><span class="toc-text">Cartesian Closed Categories</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Monoidal-Categories"><span class="toc-text">Monoidal Categories</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Resources"><span class="toc-text">Resources</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Haskell-Categories
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-10-16 19:35:25</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/blog/tags/#Categories" title="Categories">Categories</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Wish-Knew" title="Wish-Knew">Wish-Knew</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Haskell" title="Haskell">Haskell</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p>这是高级部分，编写Haskell通常不需要<a href="http://dev.stephendiehl.com/hask/#categories" target="_blank" rel="noopener">范畴</a>理论知识。</p>
</blockquote>
<p>唉，我们来谈谈范畴理论。<br>有人可能会说，所有关于<code>Haskell</code>的讨论最终都会在某一点上引向这里，然而，范畴理论在<code>Haskell</code>语境中的整体重要性被夸大了，不幸的是在某种程度上被迷惑了。<br>事实上，直接适用于<code>Haskell</code>的范畴理论的数量大致相当于任何本科文本第一章的一个子集。即使这样，使用<code>Haskell</code>也不需要真正的范畴理论知识。</p>
<h3 id="Algebraic-Relations-代数关系"><a href="#Algebraic-Relations-代数关系" class="headerlink" title="Algebraic Relations (代数关系)"></a>Algebraic Relations (代数关系)</h3><p>粗略地说，范畴理论对<code>haskell</code>编程并不十分重要，尽管一些库从这个主题中获得了一些灵感，但大多数库都没有。<br>更重要的是对等式推理有一个全面的了解，并熟悉各种代数关系。<br>某些关系出现得如此频繁，以至于我们通常按名称引用它们的属性(通常是从等价的抽象代数概念中提取)。<br>考虑一个二元运算(<code>a &#39;op&#39; b</code>)和一元运算<code>f</code>.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Associativity</span>(结合律)</span><br><span class="line"></span><br><span class="line"><span class="title">a</span> `op` (b `op` c) = (a `op` b) `op` c</span><br><span class="line"></span><br><span class="line"><span class="type">Commutativity</span>(交换律)</span><br><span class="line"></span><br><span class="line"><span class="title">a</span> `op` b = b `op` a</span><br><span class="line"></span><br><span class="line"><span class="type">Units</span>(单元)</span><br><span class="line"></span><br><span class="line"><span class="title">a</span> `op` e = a</span><br><span class="line"><span class="title">e</span> `op` a = a</span><br><span class="line"></span><br><span class="line"><span class="type">Inversion</span>(反转)</span><br><span class="line"></span><br><span class="line">(inv a) `op` a = e</span><br><span class="line"><span class="title">a</span> `op` (inv a) = e</span><br><span class="line"></span><br><span class="line"><span class="type">Zeros</span>(零点)</span><br><span class="line"></span><br><span class="line"><span class="title">a</span> `op` e = e</span><br><span class="line"><span class="title">e</span> `op` a = e</span><br><span class="line"></span><br><span class="line"><span class="type">Linearity</span>(线性度)</span><br><span class="line"></span><br><span class="line"><span class="title">f</span> (x `op` y) = f x `op` f y</span><br><span class="line"></span><br><span class="line"><span class="type">Idempotency</span>(幂等性)</span><br><span class="line"></span><br><span class="line"><span class="title">f</span> (f x) = f x</span><br><span class="line"></span><br><span class="line"><span class="type">Distributivity</span>(分配律)</span><br><span class="line"></span><br><span class="line"><span class="title">a</span> `f` (b `g` c) = (a `f` b) `g` (a `f` c)</span><br><span class="line">(b `g` c) `f` a = (b `f` a) `g` (c `f` a)</span><br><span class="line"></span><br><span class="line"><span class="type">Anticommutativity</span>(反交换律)</span><br><span class="line"></span><br><span class="line"><span class="title">a</span> `op` b = inv (b `op` a)</span><br></pre></td></tr></table></figure></p>
<p>当然，这些属性在多个函数上的组合会产生在函数编程中反复出现的高阶关系系统，一旦我们认识到它们，我们就可以对它们进行抽象。<br>例如，<code>monoid</code>(幺半群)是一个<code>unit</code>(单元)和一组值上的单个关联操作的组合。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Structure</span>(結構)   <span class="type">Notation</span>(符號)</span><br><span class="line"><span class="comment">---------------|-----------------------</span></span><br><span class="line"><span class="type">Monoid</span>	       |  (<span class="type">M</span>, •)</span><br><span class="line"><span class="type">Monad</span>	       |  (<span class="type">T</span>, μ, η)</span><br></pre></td></tr></table></figure></p>
<h3 id="Categories"><a href="#Categories" class="headerlink" title="Categories"></a>Categories</h3><p>最基本的结构是一个<code>category</code>(范畴)，它是<code>objects</code>(<code>Obj</code>)和<code>morphisms</code>(<code>Hom</code>)的代数结构，其中<code>morphisms</code>(态射)相关联地构成，并且每个对象都具有<code>identity</code>(同一性)射态。</p>
<p>启用<code>kind</code>(种类)多态性后，我们可以写下由类型变量<code>c</code>参数化的类别的一般类别，并写下<code>Haskell</code>类型类别的实例<code>Hask</code>，并将类型之间的函数作为<code>morphisms</code>(态射)。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE PolyKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeSynonymInstances #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Prelude <span class="keyword">hiding</span> ((.), id)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Morphisms</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> (<span class="title">a</span> ~&gt; <span class="title">b</span>) c = c a b</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Category</span> (<span class="title">c</span> :: <span class="title">k</span> -&gt; <span class="title">k</span> -&gt; *) <span class="keyword">where</span></span></span><br><span class="line">  id :: (a ~&gt; a) c</span><br><span class="line">  (.) :: (y ~&gt; z) c -&gt; (x ~&gt; y) c -&gt; (x ~&gt; z) c</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Hask</span> = (-&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Category</span> <span class="type">Hask</span> <span class="keyword">where</span></span></span><br><span class="line">  id x = x</span><br><span class="line">  (f . g) x = f (g x)</span><br></pre></td></tr></table></figure>
<p>类别是有趣的，因为它们展示了各种<code>composition</code>(组合)属性，以及类别中的各种元素可以组合和重写的方式，同时保留了关于程序的几个不变量。</p>
<h3 id="Isomorphisms-同构"><a href="#Isomorphisms-同构" class="headerlink" title="Isomorphisms(同构)"></a>Isomorphisms(同构)</h3><p>如果我们可以构造具有<code>2-sided invers</code>(两面逆)的态射，即将一个對象的结构转换为另一种形式，然后在反转时返回自身，则称该类别的两个对象为同构。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span>  :: a -&gt; b</span><br><span class="line"><span class="title">f'</span> :: b -&gt; a</span><br></pre></td></tr></table></figure></p>
<p>以便:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> . f' = id</span><br><span class="line"><span class="title">f'</span>. f  = id</span><br></pre></td></tr></table></figure></p>
<p>例如，类型<code>Either（）a</code>和<code>Maybe a</code>是同构的。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE ExplicitForAll #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Iso</span> a b = <span class="type">Iso</span> &#123; <span class="title">to</span> :: <span class="title">a</span> -&gt; <span class="title">b</span>, <span class="title">from</span> :: <span class="title">b</span> -&gt; <span class="title">a</span> &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">f</span> :: <span class="keyword">forall</span> a. <span class="type">Maybe</span> a -&gt; <span class="type">Either</span> () a</span><br><span class="line"><span class="title">f</span> (<span class="type">Just</span> a) = <span class="type">Right</span> a</span><br><span class="line"><span class="title">f</span> <span class="type">Nothing</span>  = <span class="type">Left</span> ()</span><br><span class="line"></span><br><span class="line"><span class="title">f'</span> :: <span class="keyword">forall</span> a. <span class="type">Either</span> () a -&gt; <span class="type">Maybe</span> a</span><br><span class="line"><span class="title">f'</span> (<span class="type">Left</span> _)  = <span class="type">Nothing</span></span><br><span class="line"><span class="title">f'</span> (<span class="type">Right</span> a) = <span class="type">Just</span> a</span><br><span class="line"></span><br><span class="line"><span class="title">iso</span> :: <span class="type">Iso</span> (<span class="type">Maybe</span> a) (<span class="type">Either</span> () a)</span><br><span class="line"><span class="title">iso</span> = <span class="type">Iso</span> f f'</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">V</span> = <span class="type">V</span> <span class="keyword">deriving</span> <span class="type">Eq</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">ex1</span> = f  (f' (<span class="type">Right</span> <span class="type">V</span>)) == <span class="type">Right</span> <span class="type">V</span></span><br><span class="line"><span class="title">ex2</span> = f' (f  (<span class="type">Just</span> <span class="type">V</span>))  == <span class="type">Just</span> <span class="type">V</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Iso</span> a b = <span class="type">Iso</span> &#123; <span class="title">to</span> :: <span class="title">a</span> -&gt; <span class="title">b</span>, <span class="title">from</span> :: <span class="title">b</span> -&gt; <span class="title">a</span> &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Category</span> <span class="type">Iso</span> <span class="keyword">where</span></span></span><br><span class="line">  id = <span class="type">Iso</span> id id</span><br><span class="line">  (<span class="type">Iso</span> f f') . (<span class="type">Iso</span> g g') = <span class="type">Iso</span> (f . g) (g' . f')</span><br></pre></td></tr></table></figure></p>
<h3 id="Duality-二元性-对偶性"><a href="#Duality-二元性-对偶性" class="headerlink" title="Duality(二元性/对偶性)"></a>Duality(二元性/对偶性)</h3><p>中心思想之一是对偶性的概念，即反转某些内部结构会产生带有’镜像’定理的新结构。<br>范畴的对偶性反转了<code>forming</code>(形成)范畴<code>C^Op</code>的态射的方向。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Category</span><br><span class="line"><span class="keyword">import</span> Prelude <span class="keyword">hiding</span> ((.), id)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Op</span> a b = <span class="type">Op</span> (<span class="title">b</span> -&gt; <span class="title">a</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Category</span> <span class="type">Op</span> <span class="keyword">where</span></span></span><br><span class="line">  id = <span class="type">Op</span> id</span><br><span class="line">  (<span class="type">Op</span> f) . (<span class="type">Op</span> g) = <span class="type">Op</span> (g . f)</span><br></pre></td></tr></table></figure></p>
<p>請看:</p>
<ul>
<li><a href="http://blog.ezyang.com/2012/10/duality-for-haskellers/" target="_blank" rel="noopener">Duality for Haskellers</a></li>
</ul>
<h3 id="Functors-函子"><a href="#Functors-函子" class="headerlink" title="Functors(函子)"></a>Functors(函子)</h3><p>函子是对象和范畴的<code>morphisms</code>(态射)之间的映射，可以保留<code>identities</code>(标识)和<code>composition</code>(组成)。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE MultiParamTypeClasses #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeSynonymInstances #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Prelude <span class="keyword">hiding</span> (<span class="type">Functor</span>, <span class="title">fmap</span>, <span class="title">id</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Category</span> <span class="title">c</span>, <span class="type">Category</span> <span class="title">d</span>) =&gt; <span class="type">Functor</span> c d t <span class="keyword">where</span></span></span><br><span class="line">  fmap :: c a b -&gt; d (t a) (t b)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Hask</span> = (-&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Category</span> <span class="type">Hask</span> <span class="keyword">where</span></span></span><br><span class="line">  id x = x</span><br><span class="line">  (f . g) x = f (g x)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Hask</span> <span class="type">Hask</span> [] <span class="keyword">where</span></span></span><br><span class="line">  fmap f [] = []</span><br><span class="line">  fmap f (x:xs) = f x : (fmap f xs)</span><br><span class="line"><span class="title">fmap</span> id ≡ id</span><br><span class="line"><span class="title">fmap</span> (a . b) ≡ (fmap a) . (fmap b)</span><br></pre></td></tr></table></figure></p>
<h3 id="Natural-Transformations-自然变换"><a href="#Natural-Transformations-自然变换" class="headerlink" title="Natural Transformations(自然变换)"></a>Natural Transformations(自然变换)</h3><p>自然变换是在态射组成顺序<code>interchange</code>(交换)下不变的<code>functor</code>之间的映射。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Nat</span> f g = forall a. f a -&gt; g a</span></span><br></pre></td></tr></table></figure></p>
<p>这样，对于自然变换<code>h</code>，我们有：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fmap</span> f . h ≡ h . fmap f</span><br></pre></td></tr></table></figure></p>
<p>最简单的例子是在<code>(f = List)</code>和<code>(g = Maybe)</code>类型之间。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">headMay</span> :: <span class="keyword">forall</span> a. [a] -&gt; <span class="type">Maybe</span> a</span><br><span class="line"><span class="title">headMay</span> []     = <span class="type">Nothing</span></span><br><span class="line"><span class="title">headMay</span> (x:xs) = <span class="type">Just</span> x</span><br></pre></td></tr></table></figure></p>
<p>不管我们如何<code>chase</code>(追求)<code>safeHead</code>，我们最终都会得到相同的结果。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fmap</span> f (headMay xs) ≡ headMay (fmap f xs)</span><br><span class="line"><span class="title">fmap</span> f (headMay [])</span><br><span class="line">= fmap f <span class="type">Nothing</span></span><br><span class="line">= <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="title">headMay</span> (fmap f [])</span><br><span class="line">= headMay []</span><br><span class="line">= <span class="type">Nothing</span></span><br><span class="line"><span class="title">fmap</span> f (headMay (x:xs))</span><br><span class="line">= fmap f (<span class="type">Just</span> x)</span><br><span class="line">= <span class="type">Just</span> (f x)</span><br><span class="line"></span><br><span class="line"><span class="title">headMay</span> (fmap f (x:xs))</span><br><span class="line">= headMay [f x]</span><br><span class="line">= <span class="type">Just</span> (f x)</span><br></pre></td></tr></table></figure></p>
<p>或考虑函子<code>(-&gt;)</code>.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: (<span class="type">Functor</span> t)</span><br><span class="line">  =&gt; (-&gt;) a b</span><br><span class="line">  -&gt; (-&gt;) (t a) (t b)</span><br><span class="line"><span class="title">f</span> = fmap</span><br><span class="line"></span><br><span class="line"><span class="title">g</span> :: (b -&gt; c)</span><br><span class="line">  -&gt; (-&gt;) a b</span><br><span class="line">  -&gt; (-&gt;) a c</span><br><span class="line"><span class="title">g</span> = (.)</span><br><span class="line"></span><br><span class="line"><span class="title">c</span> :: (<span class="type">Functor</span> t)</span><br><span class="line">  =&gt; (b -&gt; c)</span><br><span class="line">  -&gt; (-&gt;) (t a) (t b)</span><br><span class="line">  -&gt; (-&gt;) (t a) (t c)</span><br><span class="line"><span class="title">c</span> = f . g</span><br><span class="line"><span class="title">f</span> . g x = c x . g</span><br></pre></td></tr></table></figure></p>
<p><code>Haskell</code>类型的许多表达能力来自有趣的事实，即有一些注意事项，多态<code>Haskell</code>函数是自然变换。<br>請看:</p>
<ul>
<li><a href="http://blog.sigfpe.com/2008/05/you-could-have-defined-natural.html" target="_blank" rel="noopener">You Could Have Defined Natural Transformations</a></li>
</ul>
<h3 id="Yoneda-Lemma"><a href="#Yoneda-Lemma" class="headerlink" title="Yoneda Lemma"></a>Yoneda Lemma</h3><p><code>Yoneda</code>引理是范畴论中的一个基本而深刻的结果。<br><code>Yoneda</code>引理指出，对于任何函子<code>F</code>，类型<code>F a</code>和<code>∀ b. (a -&gt; b) -&gt; F b</code>是同构的。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE RankNTypes #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">embed</span> :: <span class="type">Functor</span> f =&gt; f a -&gt; (<span class="keyword">forall</span> b . (a -&gt; b) -&gt; f b)</span><br><span class="line"><span class="title">embed</span> x f = fmap f x</span><br><span class="line"></span><br><span class="line"><span class="title">unembed</span> :: <span class="type">Functor</span> f =&gt; (<span class="keyword">forall</span> b . (a -&gt; b) -&gt; f b) -&gt; f a</span><br><span class="line"><span class="title">unembed</span> f = f id</span><br></pre></td></tr></table></figure></p>
<p>这样我们就可以:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">embed</span> . unembed ≡ id</span><br><span class="line"><span class="title">unembed</span> . embed ≡ id</span><br></pre></td></tr></table></figure></p>
<p>这个定理最宽泛的表述是，一个范畴中的一个对象可以用它的一组态射来表示，仅这些态射的信息就足以决定对象本身的所有性质。</p>
<p>对于<code>Haskell</code>类型，给定一个固定类型<code>a</code>和一个函子<code>f</code>，如果我们有一个更高阶的多态函数<code>g</code>，当给定一个类型<code>a -&gt; b</code>的函数产生<code>f b</code>时，那么<code>g</code>行为完全由<code>a -&gt; b</code>决定，<code>g</code>的行为完全可以用<code>f a</code>来写。</p>
<h4 id="Continuation-Passing-连续传递"><a href="#Continuation-Passing-连续传递" class="headerlink" title="Continuation Passing(连续传递)"></a>Continuation Passing(连续传递)</h4><blockquote>
<p>TODO</p>
</blockquote>
<p>請看:</p>
<ul>
<li><a href="https://www.cs.ox.ac.uk/ralf.hinze/publications/WGP10.pdf" target="_blank" rel="noopener">Reason Isomorphically</a></li>
<li><a href="https://golem.ph.utexas.edu/category/2008/01/the_continuation_passing_trans.html" target="_blank" rel="noopener">The Continuation Passing Transform and the Yoneda Embedding</a></li>
<li><a href="https://github.com/manzyuk/blog/blob/master/yoneda-embedding-is-cps.org" target="_blank" rel="noopener">Yoneda is CPS</a></li>
</ul>
<h4 id="Double-negated-principle-of-excluded-middle-排除中间的双重否定原则"><a href="#Double-negated-principle-of-excluded-middle-排除中间的双重否定原则" class="headerlink" title="Double-negated principle of excluded middle(排除中间的双重否定原则)"></a>Double-negated principle of excluded middle(排除中间的双重否定原则)</h4><blockquote>
<p>TODO</p>
</blockquote>
<p>請看:</p>
<ul>
<li><a href="http://blog.sigfpe.com/2006/11/yoneda-lemma.html" target="_blank" rel="noopener">Reverse Engineering Machines with the Yoneda Lemma</a></li>
</ul>
<h3 id="Kleisli-Category"><a href="#Kleisli-Category" class="headerlink" title="Kleisli Category"></a>Kleisli Category</h3><p><code>Kleisli</code>組成(即<code>Kleisli FIsh</code>)定义为:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(&gt;=&gt;) :: <span class="type">Monad</span> m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; a -&gt; m c</span><br><span class="line"><span class="title">f</span> &gt;=&gt; g ≡ \x -&gt; f x &gt;&gt;= g</span><br><span class="line"></span><br><span class="line">(&lt;=&lt;) :: <span class="type">Monad</span> m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c</span><br><span class="line">(&lt;=&lt;) = flip (&gt;=&gt;)</span><br></pre></td></tr></table></figure></p>
<p>用一個<code>monad m</code>的<code>Kleisli</code>范畴表示的单子律被更<code>symmetrically</code>(对称)地表述为一个<code>associativity</code>(关联)律和两个<code>identity</code>(同一)律。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(f &gt;=&gt; g) &gt;=&gt; h ≡ f &gt;=&gt; (g &gt;=&gt; h)</span><br><span class="line"><span class="title">return</span> &gt;=&gt; f ≡ f</span><br><span class="line"><span class="title">f</span> &gt;=&gt; return ≡  f</span><br></pre></td></tr></table></figure></p>
<p>简单地说，上述单子法则只是<code>Kleisli</code>类别中的类别法则。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ExplicitForAll #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line"><span class="keyword">import</span> Control.Category</span><br><span class="line"><span class="keyword">import</span> Prelude <span class="keyword">hiding</span> ((.))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Kleisli category</span></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Kleisli</span> m a b = <span class="type">K</span> (<span class="title">a</span> -&gt; <span class="title">m</span> <span class="title">b</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Kleisli morphisms ( a -&gt; m b )</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> (<span class="title">a</span> :~&gt; <span class="title">b</span>) m = <span class="type">Kleisli</span> m a b</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> m =&gt; <span class="type">Category</span> (<span class="type">Kleisli</span> <span class="title">m</span>) <span class="keyword">where</span></span></span><br><span class="line">  id            = <span class="type">K</span> return</span><br><span class="line">  (<span class="type">K</span> f) . (<span class="type">K</span> g) = <span class="type">K</span> (f &lt;=&lt; g)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">just</span> :: (a :~&gt; a) <span class="type">Maybe</span></span><br><span class="line"><span class="title">just</span> = <span class="type">K</span> <span class="type">Just</span></span><br><span class="line"></span><br><span class="line"><span class="title">left</span> :: <span class="keyword">forall</span> a b. (a :~&gt; b) <span class="type">Maybe</span> -&gt; (a :~&gt; b) <span class="type">Maybe</span></span><br><span class="line"><span class="title">left</span> f = just . f</span><br><span class="line"></span><br><span class="line"><span class="title">right</span> :: <span class="keyword">forall</span> a b. (a :~&gt; b) <span class="type">Maybe</span> -&gt; (a :~&gt; b) <span class="type">Maybe</span></span><br><span class="line"><span class="title">right</span> f = f . just</span><br></pre></td></tr></table></figure></p>
<p>例如，<code>Just</code>只是<code>Maybe</code>单子的<code>Kleisli</code>类别中的一个<code>identity</code>(身份)<code>morphism</code>(同态)。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Just</span> &gt;=&gt; f ≡ f</span><br><span class="line"><span class="title">f</span> &gt;=&gt; <span class="type">Just</span> ≡ f</span><br></pre></td></tr></table></figure></p>
<h3 id="Adjunctions"><a href="#Adjunctions" class="headerlink" title="Adjunctions"></a>Adjunctions</h3><blockquote>
<p>TODO</p>
</blockquote>
<h3 id="Cartesian-Closed-Categories"><a href="#Cartesian-Closed-Categories" class="headerlink" title="Cartesian Closed Categories"></a>Cartesian Closed Categories</h3><blockquote>
<p>TODO</p>
</blockquote>
<h3 id="Monoidal-Categories"><a href="#Monoidal-Categories" class="headerlink" title="Monoidal Categories"></a>Monoidal Categories</h3><p>在一個<code>symmetric monoidal closed category</code>(单项封闭类别)中，例如<code>lambda</code>演算</p>
<h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><ul>
<li><a href="http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182" target="_blank" rel="noopener">Category Theory, Awodey</a></li>
<li><a href="https://www.youtube.com/watch?v=ZKmodCApZwk" target="_blank" rel="noopener">Category Theory Foundations</a></li>
<li><a href="https://www.youtube.com/watch?v=I8LbkfSSR58&amp;list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_" target="_blank" rel="noopener">Category Theory for Programmers</a></li>
<li><a href="http://www.youtube.com/user/TheCatsters" target="_blank" rel="noopener">The Catsters</a></li>
</ul>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> thank you </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
        <span><a href="https://serokell.io/blog">serokell</a></span>
        <span>/</span>
        
        <span><a href="https://iohk.io/en/blog">IOHK</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/blog/js/index.js"></script>

<!--create by tea9-->

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <script>
        var gitalk = new Gitalk({
          clientID: '7cfc73dd62b57f07ed83',
          clientSecret: 'dd03b7e54aadf0d81e4c9c93e23a41272bcfcfa1',
          repo: 'blog',
          owner: 'limengyu1990',
          admin: 'limengyu1990',
          id: location.pathname,      // Ensure uniqueness and length less than 50
          distractionFreeMode: false  // Facebook-like distraction free mode
        })
        gitalk.render('comment-container')
    </script>

<!--end-->


</html>
