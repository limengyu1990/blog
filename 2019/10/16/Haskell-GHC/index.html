<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        Haskell-GHC - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>不负如来不负卿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Block-Diagram-程序框图"><span class="toc-text">Block Diagram (程序框图)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GHC-Compiler"><span class="toc-text">GHC Compiler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GHC-Compiler-Passes"><span class="toc-text">GHC Compiler Passes</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Core"><span class="toc-text">Core</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Reading-Core"><span class="toc-text">Reading Core</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Inliner"><span class="toc-text">Inliner</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rewrite-Rules"><span class="toc-text">Rewrite Rules</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fusion-聚变-融合"><span class="toc-text">Fusion (聚变/融合)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dictionaries"><span class="toc-text">Dictionaries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Specialization-特殊化-特化"><span class="toc-text">Specialization (特殊化/特化)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Non-specialized"><span class="toc-text">Non-specialized</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Static-Compilation-静态编译"><span class="toc-text">Static Compilation (静态编译)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unboxed-Types-未装箱的类型"><span class="toc-text">Unboxed Types (未装箱的类型)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-ST"><span class="toc-text">IO/ST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ghc-heap-view"><span class="toc-text">ghc-heap-view</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STG"><span class="toc-text">STG</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Worker-Wrapper"><span class="toc-text">Worker/Wrapper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Z-Encoding"><span class="toc-text">Z-Encoding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cmm"><span class="toc-text">Cmm</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cmm-Registers-寄存器"><span class="toc-text">Cmm Registers (寄存器)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Examples"><span class="toc-text">Examples</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Macros-宏"><span class="toc-text">Macros (宏)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Optimization-Hacks-优化技巧"><span class="toc-text">Optimization Hacks (优化技巧)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Tables-Next-to-Code"><span class="toc-text">Tables Next to Code</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pointer-Tagging"><span class="toc-text">Pointer Tagging</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interface-Files"><span class="toc-text">Interface Files</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Resources"><span class="toc-text">Resources</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Haskell-GHC
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-10-16 19:26:58</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/blog/tags/#Wish-Knew" title="Wish-Knew">Wish-Knew</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Haskell" title="Haskell">Haskell</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#GHC" title="GHC">GHC</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p><a href="http://dev.stephendiehl.com/hask/#ghc" target="_blank" rel="noopener">原文</a></p>
</blockquote>
<h3 id="Block-Diagram-程序框图"><a href="#Block-Diagram-程序框图" class="headerlink" title="Block Diagram (程序框图)"></a>Block Diagram (程序框图)</h3><p>经过<code>GHC</code>的代码流是在几种中间语言之间进行翻译以及对其进行优化和转换的过程。<br>这些<code>AST</code>类型中的许多类型的通用模式是，它们是根据<code>binder</code>类型进行参数化设置的，并且在各个阶段，<code>binder</code>将被转换。<br>当用户输入由包含模块和程序包名称的<code>qualified</code>(合格)名称参数化的<code>HsSyn</code>参数时，<code>Renamer pass</code>(传递)有效地将<code>AST</code>参数化的超文本字符串中的<code>HsSyn</code>数据类型转换为更高级别的<code>Name</code>类型。</p>
<h4 id="GHC-Compiler"><a href="#GHC-Compiler" class="headerlink" title="GHC Compiler"></a>GHC Compiler</h4><p><img src="img/img01.png" alt=""></p>
<h4 id="GHC-Compiler-Passes"><a href="#GHC-Compiler-Passes" class="headerlink" title="GHC Compiler Passes"></a>GHC Compiler Passes</h4><ul>
<li><p><strong>Parser/Frontend</strong> 从人类语法转换而来的巨大<code>AST</code>，使得所有可表达的语法(声明，<code>do-notation</code>，<code>where</code>子句，语法扩展，模板<code>haskell</code>等)都可以显式地实现。这是未经过滤的<code>Haskell</code>，它非常庞大.</p>
</li>
<li><p><strong>Renamer</strong> 从<code>Frontend</code>获取语法，并将所有要限定的名称(用<code>base:Prelude.map</code>而不是<code>map</code>)以及<code>lambda binders</code>(绑定器)中的任何<code>shadowed</code>(阴影)名称转换为唯一名称。</p>
</li>
<li><p><strong>Typechecker</strong> 是一个大<code>pass</code>，它有两个用途: 第一个是核心类型双向推理引擎，其中大部分工作都在这里进行，以及前端<code>Core</code>语法之间的转换。</p>
</li>
<li><p><strong>Desugarer</strong>翻译了几个更高层次的语法构造函数</p>
<ul>
<li>将<code>where</code>语句转换为(可能是递归的)嵌套的<code>let</code>语句。</li>
<li>嵌套模式匹配扩展为<code>case</code>语句的拆分树。</li>
<li><code>do-notation</code>扩展为显式<code>bind</code>语句。</li>
<li>还有很多。</li>
</ul>
</li>
<li><p><strong>Simplifier</strong> 将许多<code>Core</code>结构转换成更适合编译的形式。例如，<code>let</code>语句将被<code>floated</code>(浮动)或<code>raised</code>(提升)，模式匹配将被简化，<code>inner loops</code>(内部循环)将被拉出并转换为更优化的形式。直觉上来说，经过简化后，结果实际上可能要复杂得多(对人类而言)!</p>
</li>
<li><p><strong>Stg</strong> 将生成的<code>Core</code>转换为<code>STG</code>(<code>Spineless Tagless G-Machine</code>)，它有效地使所有惰性都<code>explicit</code>(明確清晰/显式化)，并对將在评估期间处理的<code>trunk</code>和<code>update frames</code>(更新帧)进行编码。</p>
</li>
<li><p><strong>Codegen/Cmm</strong> 会将<code>STG</code>转换为<code>Cmm</code>(<code>flavoured C--</code>)，这是一种简单的命令式语言，可以显示运行时类型的低级实现细节。运行时闭包类型和<code>stack frames</code>(堆栈帧)是显式的，关于数据和代码(arity, updatability, free variables, pointer layout)的低级別信息在大多数<code>constructs</code>(构造)的<code>info</code>(信息)表中显示出来。</p>
</li>
<li><p><strong>Native Code</strong><code>最後的pass</code>将通过<code>GHC</code>的本地本机代码生成器(<code>NCG</code>)或<code>LLVM</code>后端将生成的代码转换为<code>LLVM</code>或<code>Assembly</code>. </p>
</li>
</ul>
<p>每個<code>pass</code>的信息可以通过相当大的标志集合來<code>dumped out</code>(转储)。虽然有些<code>passes</code>比其他<code>passes</code>更容易理解，但<code>GHC</code>的内部结构非常容易理解。<br>大多数时候使用<code>-ddump siml</code>和<code>-ddump stg</code>就足以理解代码将如何编译，除非您处理的是非常专门的优化或对<code>GHC</code>本身的黑客攻击。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Flag</span>	         |      <span class="type">Action</span></span><br><span class="line"><span class="comment">--------------------------------------------------------------</span></span><br><span class="line">-ddump-parsed    |	    <span class="type">Frontend</span> <span class="type">AST</span>(抽象語法樹).</span><br><span class="line">-ddump-rn	     |      <span class="type">Output</span> <span class="keyword">of</span> the rename pass.</span><br><span class="line">-ddump-tc	     |      <span class="type">Output</span> <span class="keyword">of</span> the typechecker.</span><br><span class="line">-ddump-splices   |	    <span class="type">Output</span> <span class="keyword">of</span> <span class="type">TemplateHaskell</span> splices(拼接).</span><br><span class="line">-ddump-types     |	    <span class="type">Typed</span> <span class="type">AST</span> representation.(类型的<span class="type">AST</span>表示).</span><br><span class="line">-ddump-deriv     |	    <span class="type">Output</span> <span class="keyword">of</span> <span class="keyword">deriving</span> instances.</span><br><span class="line">-ddump-ds	     |      <span class="type">Output</span> <span class="keyword">of</span> the desugar pass.</span><br><span class="line">-ddump-spec	     |      <span class="type">Output</span> <span class="keyword">of</span> spescialisation pass.</span><br><span class="line">-ddump-rules     |	    <span class="type">Output</span> <span class="keyword">of</span> applying rewrite rules (应用重写规则).</span><br><span class="line">-ddump-vect	     |      <span class="type">Output</span> results <span class="keyword">of</span> vectorize(矢量化) pass.</span><br><span class="line">-ddump-simpl     |	    <span class="type">Ouptut</span> <span class="keyword">of</span> the <span class="type">SimplCore</span> pass.</span><br><span class="line">-ddump-inlinings |	    <span class="type">Output</span> <span class="keyword">of</span> the inliner.</span><br><span class="line">-ddump-cse	     |      <span class="type">Output</span> <span class="keyword">of</span> the common subexpression elimination pass(公共子表达式消除).</span><br><span class="line">-ddump-prep	     |      <span class="type">The</span> <span class="type">CorePrep</span> pass.</span><br><span class="line">-ddump-stg	     |      <span class="type">The</span> resulting <span class="type">STG</span>.</span><br><span class="line">-ddump-cmm	     |      <span class="type">The</span> resulting <span class="type">Cmm</span>.</span><br><span class="line">-ddump-opt-cmm	 |      <span class="type">The</span> resulting <span class="type">Cmm</span> optimization pass.</span><br><span class="line">-ddump-asm	     |      <span class="type">The</span> final assembly generated.</span><br><span class="line">-ddump-llvm	     |      <span class="type">The</span> final <span class="type">LLVM</span> <span class="type">IR</span> generated.</span><br></pre></td></tr></table></figure></p>
<h3 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h3><p><code>Core</code>是<code>explicitly</code>(显式)类型化的<code>System-F</code>系列语法，通过它可以表达所有的<code>Haskell</code>构造。<br>从<code>GHCi</code>來<code>inspect</code>(检查)<code>core</code>，我们可以使用以下<code>flags</code>(标志)和以下<code>Shell</code>别名来调用它。<br>我们已明确禁用<code>certain</code>(某些)元数据和长格式名称的打印，以使<code>representation</code>(表示)更易于阅读。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">alias</span> ghci-core=<span class="string">"ghci -ddump-simpl -dsuppress-idinfo \</span></span><br><span class="line"><span class="string">-dsuppress-coercions -dsuppress-type-applications \</span></span><br><span class="line"><span class="string">-dsuppress-uniques -dsuppress-module-prefixes"</span></span><br></pre></td></tr></table></figure></p>
<p>然后在交互提示下，我们可以交互地探索<code>core</code>(核心)表示形式:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ghci-core</span><br><span class="line">λ: <span class="keyword">let</span> f x = x + <span class="number">2</span> ; f :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">==================== <span class="type">Simplified</span> expression ====================</span><br><span class="line"><span class="title">returnIO</span></span><br><span class="line">  (: ((\ (x :: <span class="type">Int</span>) -&gt; + $fNumInt x (<span class="type">I</span># <span class="number">2</span>)) `cast` ...) ([]))</span><br><span class="line"></span><br><span class="line">λ: <span class="keyword">let</span> f x = (x, x)</span><br><span class="line"></span><br><span class="line">==================== <span class="type">Simplified</span> expression ====================</span><br><span class="line"><span class="title">returnIO</span> (: ((\ (@ t) (x :: t) -&gt; (x, x)) `cast` ...) ([]))</span><br></pre></td></tr></table></figure></p>
<p><a href="http://hackage.haskell.org/package/ghc-core" target="_blank" rel="noopener">ghc-core</a>对查看<code>GHC</code>的<code>compilation artifacts</code>(编译工件)也非常有用。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ghc-core <span class="comment">--no-cast --no-asm</span></span><br></pre></td></tr></table></figure></p>
<p>另外，可以通过将几个标志传递给编译器来手动输出和检查编译器的主要阶段(<code>parse tree</code>,<code>core</code>,<code>stg</code>,<code>cmm</code>,<code>asm</code>):<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ghc -ddump-to-file -ddump-parsed -ddump-simpl -ddump-stg -ddump-cmm -ddump-asm</span><br></pre></td></tr></table></figure></p>
<h4 id="Reading-Core"><a href="#Reading-Core" class="headerlink" title="Reading Core"></a>Reading Core</h4><p><code>GHC</code>中的<code>Core</code>基本上是人类可读的，但是看看简单的人类书写的例子来了解正在发生的事情是有帮助的。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">id</span> :: a -&gt; a</span><br><span class="line"><span class="title">id</span> x = x</span><br><span class="line"><span class="title">id</span> :: <span class="keyword">forall</span> a. a -&gt; a</span><br><span class="line"><span class="title">id</span> = \ (@ a) (x :: a) -&gt; x</span><br><span class="line"></span><br><span class="line"><span class="title">idInt</span> :: <span class="type">GHC</span>.<span class="type">Types</span>.<span class="type">Int</span> -&gt; <span class="type">GHC</span>.<span class="type">Types</span>.<span class="type">Int</span></span><br><span class="line"><span class="title">idInt</span> = id @ <span class="type">GHC</span>.<span class="type">Types</span>.<span class="type">Int</span></span><br><span class="line"><span class="title">compose</span> :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</span><br><span class="line"><span class="title">compose</span> f g x = f (g x)</span><br><span class="line"><span class="title">compose</span> :: <span class="keyword">forall</span> b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</span><br><span class="line"><span class="title">compose</span> = \ (@ b) (@ c) (@ a) (f1 :: b -&gt; c) (g :: a -&gt; b) (x1 :: a) -&gt; f1 (g x1)</span><br><span class="line"><span class="title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">map</span> f []     = []</span><br><span class="line"><span class="title">map</span> f (x:xs) = f x : map f xs</span><br><span class="line"><span class="title">map</span> :: <span class="keyword">forall</span> a b. (a -&gt; b) -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">map</span> =</span><br><span class="line">  \ (@ a) (@ b) (f :: a -&gt; b) (xs :: [a]) -&gt;</span><br><span class="line">    <span class="keyword">case</span> xs <span class="keyword">of</span> _ &#123;</span><br><span class="line">      []     -&gt; [] @ b;</span><br><span class="line">      : y ys -&gt; : @ b (f y) (map @ a @ b f ys)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>机器生成的名称是为<code>Core</code>的许多转换而创建的。<br>通常，它们由前缀和唯一标识符组成。<br>前缀通常是传递特定的，有时会为特定的自动生成的代码生成特定的名称。<br>常见前缀及其含义的列表如下所示:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prefix</span>	    <span class="type">Description</span></span><br><span class="line"><span class="comment">----------------------------------------------------------------------</span></span><br><span class="line">$f...	    <span class="type">Dict</span>-fun identifiers (from inst decls)</span><br><span class="line">$dmop	    <span class="type">Default</span> method for 'op'</span><br><span class="line">$wf	        <span class="type">Worker</span> for function 'f'</span><br><span class="line">$sf	        <span class="type">Specialised</span> version <span class="keyword">of</span> f</span><br><span class="line">$gdm	    <span class="type">Generated</span> <span class="keyword">class</span> method</span><br><span class="line">$d	        <span class="type">Dictionary</span> names</span><br><span class="line">$s	        <span class="type">Specialized</span> function name</span><br><span class="line">$f	        <span class="type">Foreign</span> <span class="keyword">export</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--          (C类的第n个超类选择器)</span></span><br><span class="line">$pnC	    n'th superclass selector for <span class="keyword">class</span> <span class="type">C</span></span><br><span class="line"></span><br><span class="line"><span class="type">T</span>:<span class="type">C</span>	        <span class="type">Tycon</span> for dictionary for <span class="keyword">class</span> <span class="type">C</span></span><br><span class="line"><span class="type">D</span>:<span class="type">C</span>	        <span class="type">Data</span> constructor for dictionary for <span class="keyword">class</span> <span class="type">C</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--          (将newtype T强制转换为其底层的运行时表示形式)</span></span><br><span class="line"><span class="type">NTCo</span>:<span class="type">T</span>	    <span class="type">Coercion</span> for <span class="class"><span class="keyword">newtype</span> <span class="type">T</span> to its underlying runtime representation</span></span><br></pre></td></tr></table></figure></p>
<p>需要特别注意的是，用于类型级别和值级别<code>lambda</code>抽象的<code>Λ</code>和<code>λ</code>在<code>core</code>中用相同的符号(<code>\</code>)表示，这是<code>GHC</code>实现的简化细节，卻是开始时有些混乱的根源。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- System-F Notation</span></span><br><span class="line">Λ b c a. λ (f1 : b -&gt; c) (g : a -&gt; b) (x1 : a). f1 (g x1)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Haskell Core</span></span><br><span class="line">\ (@ b) (@ c) (@ a) (f1 :: b -&gt; c) (g :: a -&gt; b) (x1 :: a) -&gt; f1 (g x1)</span><br></pre></td></tr></table></figure></p>
<p><code>seq</code>函数在<code>Core</code>语言中有一個直观的实现。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">x</span> `seq` y</span><br><span class="line"><span class="title">case</span> x <span class="keyword">of</span> _ &#123;</span><br><span class="line">  __DEFAULT -&gt; y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Core</code>脫糖处理時的一个特别值得注意的情况是，对重载数字进行模式匹配会隐式转换为相等性测试(即<code>Eq</code>).<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="title">f</span> <span class="number">1</span> = <span class="number">2</span></span><br><span class="line"><span class="title">f</span> <span class="number">2</span> = <span class="number">3</span></span><br><span class="line"><span class="title">f</span> <span class="number">3</span> = <span class="number">4</span></span><br><span class="line"><span class="title">f</span> <span class="number">4</span> = <span class="number">5</span></span><br><span class="line"><span class="title">f</span> _ = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">f</span> :: <span class="keyword">forall</span> a b. (<span class="type">Eq</span> a, <span class="type">Num</span> a, <span class="type">Num</span> b) =&gt; a -&gt; b</span><br><span class="line"><span class="title">f</span> =</span><br><span class="line">  \ (@ a)</span><br><span class="line">    (@ b)</span><br><span class="line">    ($dEq :: <span class="type">Eq</span> a)</span><br><span class="line">    ($dNum :: <span class="type">Num</span> a)</span><br><span class="line">    ($dNum1 :: <span class="type">Num</span> b)</span><br><span class="line">    (ds :: a) -&gt;</span><br><span class="line">    <span class="keyword">case</span> == $dEq ds (fromInteger $dNum (__integer <span class="number">0</span>)) <span class="keyword">of</span> _ &#123;</span><br><span class="line">      <span class="type">False</span> -&gt;</span><br><span class="line">        <span class="keyword">case</span> == $dEq ds (fromInteger $dNum (__integer <span class="number">1</span>)) <span class="keyword">of</span> _ &#123;</span><br><span class="line">          <span class="type">False</span> -&gt;</span><br><span class="line">            <span class="keyword">case</span> == $dEq ds (fromInteger $dNum (__integer <span class="number">2</span>)) <span class="keyword">of</span> _ &#123;</span><br><span class="line">              <span class="type">False</span> -&gt;</span><br><span class="line">                <span class="keyword">case</span> == $dEq ds (fromInteger $dNum (__integer <span class="number">3</span>)) <span class="keyword">of</span> _ &#123;</span><br><span class="line">                  <span class="type">False</span> -&gt;</span><br><span class="line">                    <span class="keyword">case</span> == $dEq ds (fromInteger $dNum (__integer <span class="number">4</span>)) <span class="keyword">of</span> _ &#123;</span><br><span class="line">                      <span class="type">False</span> -&gt; fromInteger $dNum1 (__integer <span class="number">0</span>);</span><br><span class="line">                      <span class="type">True</span> -&gt; fromInteger $dNum1 (__integer <span class="number">5</span>)</span><br><span class="line">                    &#125;;</span><br><span class="line">                  <span class="type">True</span> -&gt; fromInteger $dNum1 (__integer <span class="number">4</span>)</span><br><span class="line">                &#125;;</span><br><span class="line">              <span class="type">True</span> -&gt; fromInteger $dNum1 (__integer <span class="number">3</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">          <span class="type">True</span> -&gt; fromInteger $dNum1 (__integer <span class="number">2</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">      <span class="type">True</span> -&gt; fromInteger $dNum1 (__integer <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，添加一个具体的类型签名会改变<code>desugar</code>(脫糖)只匹配<code>unboxed</code>(未装箱)的值.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">f</span> =</span><br><span class="line">  \ (ds :: <span class="type">Int</span>) -&gt;</span><br><span class="line">    <span class="keyword">case</span> ds <span class="keyword">of</span> _ &#123; <span class="type">I</span># ds1 -&gt;</span><br><span class="line">        <span class="keyword">case</span> ds1 <span class="keyword">of</span> _ &#123;</span><br><span class="line">            __DEFAULT -&gt; <span class="type">I</span># <span class="number">0</span>;</span><br><span class="line">            <span class="number">0</span> -&gt; <span class="type">I</span># <span class="number">1</span>;</span><br><span class="line">            <span class="number">1</span> -&gt; <span class="type">I</span># <span class="number">2</span>;</span><br><span class="line">            <span class="number">2</span> -&gt; <span class="type">I</span># <span class="number">3</span>;</span><br><span class="line">            <span class="number">3</span> -&gt; <span class="type">I</span># <span class="number">4</span>;</span><br><span class="line">            <span class="number">4</span> -&gt; <span class="type">I</span># <span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>請看:</p>
<ul>
<li><a href="https://github.com/ghc/ghc/blob/master/docs/core-spec/core-spec.pdf" target="_blank" rel="noopener">Core Spec</a></li>
<li><a href="http://alpmestan.com/2013/06/27/ghc-core-by-example-episode-1/" target="_blank" rel="noopener">Core By Example</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType" target="_blank" rel="noopener">CoreSynType</a></li>
</ul>
<h3 id="Inliner"><a href="#Inliner" class="headerlink" title="Inliner"></a>Inliner</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infixr</span> <span class="number">0</span>  $</span><br><span class="line"></span><br><span class="line">($):: (a -&gt; b) -&gt; a -&gt; b</span><br><span class="line"><span class="title">f</span> $ x =  f x</span><br></pre></td></tr></table></figure>
<p>每次使用(<code>$</code>)时都必须输入辅助闭包将带来巨大的开销。<br>幸运的是，<code>GHC</code>可以通过在适当的调用位置简单地用其定义的主体替换函数调用来消除此类小函数。<br>编译器包含多种启发式方法，用于确定何时适合使用这种替代方法以及所涉及的潜在成本。</p>
<p>除了自动的<code>inliner</code>(内联)之外，还提供了手动编译指示，以更精细地控制内联。值得注意的是，<code>naive</code>(幼稚/天真)的内联经常导致性能显着下降和更长的编译时间。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# INLINE func #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# INLINABLE func #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# NOINLINE func #-&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>例如，在我们将二进制函数应用于两个参数的情况下。<br>函数主体很小，实际上我们可以只在调用站点内联函数应用，而不必为了应用给定函数而输入另一个闭包。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# INLINE foo #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# NOINLINE bar #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">foo</span> :: (a -&gt; b -&gt; c) -&gt; a -&gt; b -&gt; c</span><br><span class="line"><span class="title">foo</span> f x y = f x y</span><br><span class="line"></span><br><span class="line"><span class="title">bar</span> :: (a -&gt; b -&gt; c) -&gt; a -&gt; b -&gt; c</span><br><span class="line"><span class="title">bar</span> f x y = f x y</span><br><span class="line"></span><br><span class="line"><span class="title">test1</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">test1</span> = foo (+) <span class="number">10</span> <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="title">test2</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">test2</span> = bar (+) <span class="number">20</span> <span class="number">30</span></span><br></pre></td></tr></table></figure></p>
<p>看一下<code>core</code>，我们可以看到在<code>test1</code>中，函数实际上已经在调用位置进行了扩展，只是在那里执行了加法操作，而不是另一个间接操作。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">test1</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">test1</span> =</span><br><span class="line">  <span class="keyword">let</span> &#123;</span><br><span class="line">    f :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line">    f = + $fNumInt &#125; <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> &#123;</span><br><span class="line">    x :: <span class="type">Int</span></span><br><span class="line">    x = <span class="type">I</span># <span class="number">10</span> &#125; <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> &#123;</span><br><span class="line">    y :: <span class="type">Int</span></span><br><span class="line">    y = <span class="type">I</span># <span class="number">20</span> &#125; <span class="keyword">in</span></span><br><span class="line">  f x y</span><br><span class="line"></span><br><span class="line"><span class="title">test2</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">test2</span> = bar (+ $fNumInt) (<span class="type">I</span># <span class="number">20</span>) (<span class="type">I</span># <span class="number">30</span>)</span><br></pre></td></tr></table></figure></p>
<p>标有<code>NOINLINE</code>的情况通常表明该函数中的逻辑使用的是诸如<code>unsafePerformIO</code>之类的东西或其他一些邪恶的函数。<br>在这些情况下，幼稚的内联可能会在整个程序的多个调用位置重复产生效果，这是我們不希望看到的。</p>
<p>請看: <a href="https://research.microsoft.com/en-us/um/people/simonpj/Papers/inlining/inline.pdf" target="_blank" rel="noopener">Secrets of the Glasgow Haskell Compiler inliner</a> (<code>GHC</code>编译器内联的秘密)</p>
<h3 id="Rewrite-Rules"><a href="#Rewrite-Rules" class="headerlink" title="Rewrite Rules"></a>Rewrite Rules</h3><blockquote>
<p>这是高级部分，编写Haskell通常不需要。</p>
</blockquote>
<blockquote>
<p>TODO</p>
</blockquote>
<p>請看:</p>
<ul>
<li><a href="https://wiki.haskell.org/GHC/Using_rules" target="_blank" rel="noopener">Using Rules</a></li>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/rewrite-rules.html" target="_blank" rel="noopener">Rewrite Rules</a></li>
</ul>
<h3 id="Fusion-聚变-融合"><a href="#Fusion-聚变-融合" class="headerlink" title="Fusion (聚变/融合)"></a>Fusion (聚变/融合)</h3><blockquote>
<p>这是高级部分，编写Haskell通常不需要。</p>
</blockquote>
<blockquote>
<p>TODO</p>
</blockquote>
<p>請看: <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/rewrite-rules.html" target="_blank" rel="noopener">List Fusion</a></p>
<h3 id="Dictionaries"><a href="#Dictionaries" class="headerlink" title="Dictionaries"></a>Dictionaries</h3><p><code>Haskell</code>语言定义了<code>Typeclass</code>的概念，但与在<code>Haskell</code>编译器中如何实现它们无关。<br><code>GHC</code>的特殊实现使用了一个名为<code>dictionary</code>的传递过程，它传递了<code>typechecker</code>的<code>elaboration phase</code>(細化阶段)的翻译部分，该翻译部分将带有类型类约束的<code>Core</code>函数转换为隐式参数，该隐含参数将传递包含函数实现的类似记录的结构.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Num</span> a <span class="keyword">where</span></span></span><br><span class="line">  (+) :: a -&gt; a -&gt; a</span><br><span class="line">  (*) :: a -&gt; a -&gt; a</span><br><span class="line">  negate :: a -&gt; a</span><br></pre></td></tr></table></figure></p>
<p>可以将此类视为等效于以下函数参数化记录的实现:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">DNum</span> a = <span class="type">DNum</span> (<span class="title">a</span> -&gt; <span class="title">a</span> -&gt; <span class="title">a</span>) (<span class="title">a</span> -&gt; <span class="title">a</span> -&gt; <span class="title">a</span>) (<span class="title">a</span> -&gt; <span class="title">a</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="title">add</span> (<span class="type">DNum</span> a m n) = a</span><br><span class="line"><span class="title">mul</span> (<span class="type">DNum</span> a m n) = m</span><br><span class="line"><span class="title">neg</span> (<span class="type">DNum</span> a m n) = n</span><br><span class="line"></span><br><span class="line"><span class="title">numDInt</span> :: <span class="type">DNum</span> <span class="type">Int</span></span><br><span class="line"><span class="title">numDInt</span> = <span class="type">DNum</span> plusInt timesInt negateInt</span><br><span class="line"></span><br><span class="line"><span class="title">numDFloat</span> :: <span class="type">DNum</span> <span class="type">Float</span></span><br><span class="line"><span class="title">numDFloat</span> = <span class="type">DNum</span> plusFloat timesFloat negateFloat</span><br><span class="line">+ :: <span class="keyword">forall</span> a. <span class="type">Num</span> a =&gt; a -&gt; a -&gt; a</span><br><span class="line">+ = \ (@ a) (tpl :: <span class="type">Num</span> a) -&gt;</span><br><span class="line">  <span class="keyword">case</span> tpl <span class="keyword">of</span> _ &#123; <span class="type">D</span>:<span class="type">Num</span> tpl _ _ -&gt; tpl &#125;</span><br><span class="line"></span><br><span class="line">* :: <span class="keyword">forall</span> a. <span class="type">Num</span> a =&gt; a -&gt; a -&gt; a</span><br><span class="line">* = \ (@ a) (tpl :: <span class="type">Num</span> a) -&gt;</span><br><span class="line">  <span class="keyword">case</span> tpl <span class="keyword">of</span> _ &#123; <span class="type">D</span>:<span class="type">Num</span> _ tpl _ -&gt; tpl &#125;</span><br><span class="line"></span><br><span class="line"><span class="title">negate</span> :: <span class="keyword">forall</span> a. <span class="type">Num</span> a =&gt; a -&gt; a</span><br><span class="line"><span class="title">negate</span> = \ (@ a) (tpl :: <span class="type">Num</span> a) -&gt;</span><br><span class="line">  <span class="keyword">case</span> tpl <span class="keyword">of</span> _ &#123; <span class="type">D</span>:<span class="type">Num</span> _ _ tpl -&gt; tpl &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Num</code>和<code>Ord</code>的翻译很简单，但对于签名中存在<code>existential</code>(存在)类型变量的<code>monads</code>，表示等效<code>dictionary</code>(字典)的唯一方法是使用<code>RankNTypes</code>.<br>另外，类型类还可以包括将包含在类型类字典中并在相同参数上进行参数化的超类，并创建一个隐式超类构造函数以从当前<code>monad</code>的超类中提取函数。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">DMonad</span> m = <span class="type">DMonad</span></span></span><br><span class="line">  &#123; bind   :: <span class="keyword">forall</span> a b. m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">  , return :: <span class="keyword">forall</span> a. a -&gt; m a</span><br><span class="line">  &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Functor</span> <span class="title">t</span>, <span class="type">Foldable</span> <span class="title">t</span>) =&gt; <span class="type">Traversable</span> t <span class="keyword">where</span></span></span><br><span class="line">    traverse :: <span class="type">Applicative</span> f =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)</span><br><span class="line">    traverse f = sequenceA . fmap f</span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">DTraversable</span> t = <span class="type">DTraversable</span></span></span><br><span class="line">  &#123; dFunctorTraversable :: <span class="type">DFunctor</span> t  <span class="comment">-- superclass dictionary</span></span><br><span class="line">  , dFoldableTraversable :: <span class="type">DFoldable</span> t <span class="comment">-- superclass dictionary</span></span><br><span class="line">  , traverse :: <span class="keyword">forall</span> a. <span class="type">Applicative</span> f =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>确实，这与<code>GHC</code>实际实现类型类的方式并不遥远。它详细介绍了与此几乎相同的<code>projection</code>(投影)函数和数据构造函数，并针对每个多态函数的每个类型类约束将其扩展为字典参数。</p>
<h3 id="Specialization-特殊化-特化"><a href="#Specialization-特殊化-特化" class="headerlink" title="Specialization (特殊化/特化)"></a>Specialization (特殊化/特化)</h3><p>默认情况下，<code>Haskell</code>中的重载通常不是完全免费的，尽管可以使用一种称为<code>specialization</code>(特殊化)的优化方法，使其在性能至关重要的代码中的特定点上的成本为零。<br>由于<code>GHC</code>不是整个程序优化的编译器，并且大多数优化(并非全部)都停留在模块边界，因此默认情况下不会启用此功能。</p>
<p><code>GHC</code>实现类型类的方法意味着显式字典在整个调用站点中都是隐式的。<br>这通常是实现此功能的最自然的方法，因为它保留单独的编译。</p>
<p>函数可以独立于声明的位置进行编译，而不是在调用它的程序中的每个点重新编译。通过字典传递，调用者可以将类型的实现逻辑线程化到调用站点，然后可以在函数的整个主体中使用它。</p>
<p>当然，这意味着为了获得特定的类型类函数，我们需要(可能多次)<code>project</code>(投影)到字典结构中以<code>pluck out</code>(提取)函数引用. 运行时使它非常便宜，但并非完全免费。</p>
<p>许多<code>C++</code>编译器或整个程序优化的编译器却相反，它们在调用站点上明確地<code>specialize</code>(特殊化)了每个函数，并用其特定于类型的实现代替了重载函数。我们可以使用类<code>specialization</code>(特殊化)来选择性地启用这种行为。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Specialize (<span class="title">spec</span>, <span class="title">nonspec</span>, <span class="title">f</span>) <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&#123;-# SPECIALIZE INLINE f :: Double -&gt; Double -&gt; Double #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">f</span> :: <span class="type">Floating</span> a =&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">f</span> x y = exp (x + y) * exp (x + y)</span><br><span class="line"></span><br><span class="line"><span class="title">nonspec</span> :: <span class="type">Float</span></span><br><span class="line"><span class="title">nonspec</span> = f (<span class="number">10</span> :: <span class="type">Float</span>) (<span class="number">20</span> :: <span class="type">Float</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">spec</span> :: <span class="type">Double</span></span><br><span class="line"><span class="title">spec</span> = f (<span class="number">10</span> :: <span class="type">Double</span>) (<span class="number">20</span> :: <span class="type">Double</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="Non-specialized"><a href="#Non-specialized" class="headerlink" title="Non-specialized"></a>Non-specialized</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="keyword">forall</span> a. <span class="type">Floating</span> a =&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">f</span> =</span><br><span class="line">  \ (@ a) ($dFloating :: <span class="type">Floating</span> a) (eta :: a) (eta1 :: a) -&gt;</span><br><span class="line">    <span class="keyword">let</span> &#123;</span><br><span class="line">      a :: <span class="type">Fractional</span> a</span><br><span class="line">      a = $p1Floating @ a $dFloating &#125; <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> &#123;</span><br><span class="line">      $dNum :: <span class="type">Num</span> a</span><br><span class="line">      $dNum = $p1Fractional @ a a &#125; <span class="keyword">in</span></span><br><span class="line">    * @ a</span><br><span class="line">      $dNum</span><br><span class="line">      (exp @ a $dFloating (+ @ a $dNum eta eta1))</span><br><span class="line">      (exp @ a $dFloating (+ @ a $dNum eta eta1))</span><br></pre></td></tr></table></figure>
<p>在<code>specialize</code>版本中，类型类操作直接放置在调用站点上，并且只是簡單的拆箱运算。这将映射到一组<code>tight</code>(严格/緊湊)的顺序<code>CPU</code>指令，并且很有可能是<code>C</code>生成的相同代码。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">spec</span> :: <span class="type">Double</span></span><br><span class="line"><span class="title">spec</span> = <span class="type">D</span># (*## (expDouble# <span class="number">30.0</span>) (expDouble# <span class="number">30.0</span>))</span><br></pre></td></tr></table></figure></p>
<p><code>non-specialized</code>版本必须投影到<code>typeclass</code>词典(<code>$fFloatingFloat</code>)中6次，并且可能要遍历25个分支才能执行相同的操作。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">nonspec</span> :: <span class="type">Float</span></span><br><span class="line"><span class="title">nonspec</span> =</span><br><span class="line">  f @ <span class="type">Float</span> $fFloatingFloat (<span class="type">F</span># (__float <span class="number">10.0</span>)) (<span class="type">F</span># (__float <span class="number">20.0</span>))</span><br></pre></td></tr></table></figure></p>
<p>对于在调用点<code>specialize</code>(特殊化)的<code>numeric</code>(数字)类型上的<code>tight loop</code>(紧密循环)，可以导致性能提高几个数量级。尽管编译时的开销通常是不小的，而且当在许多调用点使用函数时，这可能会使<code>GHC</code>的<code>simplifier pass</code>速度变慢。</p>
<p>最好的建议是进行概要分析，并在<code>tight</code>(紧密)的循环中寻找<code>dictionary projection</code>(字典投影)的大量使用，然后在这些地方进行<code>specialize</code>(特殊化)和<code>inline</code>内联。</p>
<p>如果将<code>SPECIALISE INLINE</code>编译指示应用于递归函数，可能会无意间导致<code>GHC</code>发生<code>diverge</code>(发散)，它将尝试无限<code>specialize</code>(特殊化)它自己。</p>
<h3 id="Static-Compilation-静态编译"><a href="#Static-Compilation-静态编译" class="headerlink" title="Static Compilation (静态编译)"></a>Static Compilation (静态编译)</h3><p>在<code>Linux</code>上，<code>Haskell</code>程序可以编译为独立的静态链接二进制文件，其中包括静态链接到其中的运行时。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ghc -<span class="type">O2</span> <span class="comment">--make -static -optc-static -optl-static -optl-pthread Example.hs</span></span><br><span class="line"></span><br><span class="line">$ file <span class="type">Example</span></span><br><span class="line"><span class="type">Example</span>: <span class="type">ELF</span> <span class="number">64</span>-bit <span class="type">LSB</span> executable, x86<span class="number">-64</span>, version <span class="number">1</span> (<span class="type">GNU</span>/<span class="type">Linux</span>), statically linked, for <span class="type">GNU</span>/<span class="type">Linux</span> <span class="number">2.6</span><span class="number">.32</span>, not stripped</span><br><span class="line"></span><br><span class="line">$ ldd <span class="type">Example</span></span><br><span class="line">        not a dynamic executable</span><br></pre></td></tr></table></figure></p>
<p>此外，可以通过剥离不需要的符号来减少生成的二进制文件的文件大小。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ strip <span class="type">Example</span></span><br></pre></td></tr></table></figure></p>
<p>还可以使用<a href="http://upx.sourceforge.net/" target="_blank" rel="noopener">upx</a>将可执行文件的大小进一步压缩.</p>
<h3 id="Unboxed-Types-未装箱的类型"><a href="#Unboxed-Types-未装箱的类型" class="headerlink" title="Unboxed Types (未装箱的类型)"></a>Unboxed Types (未装箱的类型)</h3><p><code>Haskell</code>中的常规<code>numerics</code>(数字)类型可以被认为是常规代数数据类型，其底層<code>unboxed</code>(未装箱)值带有特殊的构造函数参数。<br>通常在常规代码中不使用<code>unboxed</code>(未装箱)类型和显式<code>unboxing</code>(拆箱)，它们是连接到编译器的。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Int</span> = <span class="type">I</span># <span class="type">Int</span>#</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Integer</span></span></span><br><span class="line">  = <span class="type">S</span># <span class="type">Int</span>#              <span class="comment">-- Small integers</span></span><br><span class="line">  | <span class="type">J</span># <span class="type">Int</span># <span class="type">ByteArray</span>#   <span class="comment">-- Large GMP integers</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Float</span> = <span class="type">F</span># <span class="type">Float</span>#</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Syntax</span>	        <span class="type">Primitive</span> <span class="type">Type</span> (原始类型)</span><br><span class="line"><span class="comment">--------------------------------------</span></span><br><span class="line"><span class="number">3</span>#	            <span class="type">GHC</span>.<span class="type">Prim</span>.<span class="type">Int</span>#</span><br><span class="line"><span class="number">3</span>##	            <span class="type">GHC</span>.<span class="type">Prim</span>.<span class="type">Word</span>#</span><br><span class="line"><span class="number">3.14</span>#	        <span class="type">GHC</span>.<span class="type">Prim</span>.<span class="type">Float</span>#</span><br><span class="line"><span class="number">3.14</span>##	        <span class="type">GHC</span>.<span class="type">Prim</span>.<span class="type">Double</span>#</span><br><span class="line">'c'#	        <span class="type">GHC</span>.<span class="type">Prim</span>.<span class="type">Char</span>#</span><br><span class="line"><span class="string">"Haskell"</span>##	    <span class="type">GHC</span>.<span class="type">Prim</span>.<span class="type">Addr</span>#</span><br></pre></td></tr></table></figure>
<p><code>kind</code>为<code>#</code>的未装箱类型，永远不会<code>unify</code>(统一)<code>kind</code>为<code>*</code>的类型变量。<br>直观地，<code>kind</code>为<code>*</code>的类型表示具有<code>uniform</code>(统一)运行时表示形式的类型，该类型可以多态使用。</p>
<ul>
<li><strong>Lifted</strong>  - 可以包含一個<code>bottom term</code>,由一個指針表示.(<code>Int</code>,<code>Any</code>, <code>(,)</code>)</li>
<li><strong>Unlited</strong> - 不可以包含一個<code>bottom term</code>,由<code>stack</code>(堆栈)上的值表示.(<code>Int#</code>,<code>(#, #)</code>)<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE BangPatterns, MagicHash, UnboxedTuples #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.Exts</span><br><span class="line"><span class="keyword">import</span> GHC.Prim</span><br><span class="line"></span><br><span class="line"><span class="title">ex1</span> :: <span class="type">Bool</span></span><br><span class="line"><span class="title">ex1</span> = gtChar# a# b#</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    !(<span class="type">C</span># a#) = 'a'</span><br><span class="line">    !(<span class="type">C</span># b#) = 'b'</span><br><span class="line"></span><br><span class="line"><span class="title">ex2</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">ex2</span> = <span class="type">I</span># (a# +# b#)</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    !(<span class="type">I</span># a#) = <span class="number">1</span></span><br><span class="line">    !(<span class="type">I</span># b#) = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="title">ex3</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">ex3</span> = (<span class="type">I</span># (<span class="number">1</span># +# <span class="number">2</span># *# <span class="number">3</span># +# <span class="number">4</span>#))</span><br><span class="line"></span><br><span class="line"><span class="title">ex4</span> :: (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="title">ex4</span> = (<span class="type">I</span># (dataToTag# <span class="type">False</span>), <span class="type">I</span># (dataToTag# <span class="type">True</span>))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>用于<code>Int</code>的<code>Num</code>类型类中使用的<code>integer</code>算术函数只是对该类型的模式匹配，以显示底层未装箱的值，执行内置算术，然后再次执行打包到<code>Int</code>的操作。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">plusInt</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line">(<span class="type">I</span># x) `plusInt` (<span class="type">I</span># y) = <span class="type">I</span># (x +# y)</span><br></pre></td></tr></table></figure></p>
<p>其中(<code>+＃</code>)是<code>GHC</code>内置的低级函数，它映射到<code>CPU</code>的内部整数加法指令。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">plusInt</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">plusInt</span> a b = <span class="keyword">case</span> a <span class="keyword">of</span> &#123;</span><br><span class="line">    (<span class="type">I</span># a_) -&gt; <span class="keyword">case</span> b <span class="keyword">of</span> &#123;</span><br><span class="line">      (<span class="type">I</span># b_) -&gt; <span class="type">I</span># (+# a_ b_);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，<code>Haskell</code>中的运行时值由一个<code>boxed</code>(裝箱)的<code>StgClosure*</code>结构体(<code>struct</code>)统一表示，该<code>struct</code>本身包含多个<code>payload</code>(有效负载)值，这些<code>payload</code>(有效负载)值本身可以是指向其他<code>boxed</code>值的指针，也可以是指向符合系统<code>word</code>(字)大小并直接存储在内存闭包中的未裝箱<code>literal</code>(文本)值的指针。</p>
<p><code>box</code>的布局由闭包头中的<code>bitmap</code>(位图)描述，该位图描述<code>payload</code>(有效负载)中的哪些值是指针或非指针。</p>
<p>通过读取闭包上的位图，可以使用<code>unpackClosure＃ primop</code>在运行时提取此信息。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE MagicHash, UnboxedTuples #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# OPTIONS_GHC -O1 #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Main <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.Exts</span><br><span class="line"><span class="keyword">import</span> GHC.Base</span><br><span class="line"><span class="keyword">import</span> Foreign</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Size</span> = <span class="type">Size</span></span></span><br><span class="line">  &#123; ptrs  :: <span class="type">Int</span></span><br><span class="line">  , nptrs :: <span class="type">Int</span></span><br><span class="line">  , size  :: <span class="type">Int</span></span><br><span class="line">  &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">unsafeSizeof</span> :: a -&gt; <span class="type">Size</span></span><br><span class="line"><span class="title">unsafeSizeof</span> a =</span><br><span class="line">  <span class="keyword">case</span> unpackClosure# a <span class="keyword">of</span></span><br><span class="line">    (# x, ptrs, nptrs #) -&gt;</span><br><span class="line">      <span class="keyword">let</span> header  = sizeOf (undefined :: <span class="type">Int</span>)</span><br><span class="line">          ptr_c   = <span class="type">I</span># (sizeofArray# ptrs)</span><br><span class="line">          nptr_c  = <span class="type">I</span># (sizeofByteArray# nptrs) `div` sizeOf (undefined :: <span class="type">Word</span>)</span><br><span class="line">          payload = <span class="type">I</span># (sizeofArray# ptrs +# sizeofByteArray# nptrs)</span><br><span class="line">          size    = header + payload</span><br><span class="line">      <span class="keyword">in</span> <span class="type">Size</span> ptr_c nptr_c size</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">A</span> = <span class="type">A</span> <span class="meta">&#123;-# UNPACK #-&#125;</span> !<span class="type">Int</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">B</span> = <span class="type">B</span> <span class="type">Int</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  print (unsafeSizeof (<span class="type">A</span> <span class="number">42</span>))</span><br><span class="line">  print (unsafeSizeof (<span class="type">B</span> <span class="number">42</span>))</span><br></pre></td></tr></table></figure></p>
<p>例如，带有<code>UNPACK</code>编译指示的<code>datatype</code>包含1个非指针和0个指针。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">A</span> = <span class="type">A</span> <span class="meta">&#123;-# UNPACK #-&#125;</span> !<span class="type">Int</span></span></span><br><span class="line"><span class="type">Size</span> &#123;ptrs = <span class="number">0</span>, nptrs = <span class="number">1</span>, size = <span class="number">16</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>而默认的<code>packed</code>的<code>datatype</code>包含1个指针和0个非指针.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">B</span> = <span class="type">B</span> <span class="type">Int</span></span></span><br><span class="line"><span class="type">Size</span> &#123;ptrs = <span class="number">1</span>, nptrs = <span class="number">0</span>, size = <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>数据构造函数的闭包表示在运行时也带有特定构造函数的标签<code>tagged</code>(标记)。<br>但是，这不是运行时类型标记，因为没有办法从<code>tag</code>(标记)中恢复类型，因为所有构造函数都只使用序列(0，1，2，…).</p>
<p><code>tag</code>(标记)用于区分模式匹配中的大小写。<br>内置的<code>dataToTag＃</code>可用于抽取任意数据类型的<code>tag</code>。<br>在某些情况下，当脫糖模式匹配时使用此选项很有用。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">dataToTag</span># :: a -&gt; <span class="type">Int</span>#</span><br></pre></td></tr></table></figure>
<p>例如:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- data Bool = False | True</span></span><br><span class="line"><span class="comment">-- False ~ 0</span></span><br><span class="line"><span class="comment">-- True  ~ 1</span></span><br><span class="line"></span><br><span class="line"><span class="title">a</span> :: (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="title">a</span> = (<span class="type">I</span># (dataToTag# <span class="type">False</span>), <span class="type">I</span># (dataToTag# <span class="type">True</span>))</span><br><span class="line"><span class="comment">-- (0, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- data Ordering = LT | EQ | GT</span></span><br><span class="line"><span class="comment">-- LT ~ 0</span></span><br><span class="line"><span class="comment">-- EQ ~ 1</span></span><br><span class="line"><span class="comment">-- GT ~ 2</span></span><br><span class="line"></span><br><span class="line"><span class="title">b</span> :: (<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="title">b</span> = (<span class="type">I</span># (dataToTag# <span class="type">LT</span>), <span class="type">I</span># (dataToTag# <span class="type">EQ</span>), <span class="type">I</span># (dataToTag# <span class="type">GT</span>))</span><br><span class="line"><span class="comment">-- (0, 1, 2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- data Either a b = Left a | Right b</span></span><br><span class="line"><span class="comment">-- Left ~ 0</span></span><br><span class="line"><span class="comment">-- Right ~ 1</span></span><br><span class="line"></span><br><span class="line"><span class="title">c</span> :: (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="title">c</span> = (<span class="type">I</span># (dataToTag# (<span class="type">Left</span> <span class="number">0</span>)), <span class="type">I</span># (dataToTag# (<span class="type">Right</span> <span class="number">1</span>)))</span><br><span class="line"><span class="comment">-- (0, 1)</span></span><br></pre></td></tr></table></figure></p>
<p>源代码中包含的<code>String literals</code>(字符串文字)也将转换为几个<code>primop</code>操作。<br><code>Haskell</code>中的<code>Addr＃</code>类型代表在<code>Haskell</code>堆上预分配的静态<code>contagious</code>(可传染)缓冲区，该缓冲区可以容纳<code>char*</code>序列。<code>unpackCString＃</code>操作可以扫描此缓冲区并将其折叠到<code>Haskell</code>内部的<code>Chars</code>列表中。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">unpackCString</span># :: <span class="type">Addr</span># -&gt; [<span class="type">Char</span>]</span><br></pre></td></tr></table></figure></p>
<p>这是在早期的前端<code>脫糖</code>阶段完成的，在此阶段，<code>literals</code>(文字)被转换为内联的<code>Addr＃</code>，而不是由大量的<code>Cons</code>字符组成。<br>因此，我们的“ Hello World”转化为以下<code>Core</code>:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- print "Hello World"</span></span><br><span class="line"><span class="title">print</span> (unpackCString# <span class="string">"Hello World"</span>#)</span><br></pre></td></tr></table></figure></p>
<p>請看: </p>
<ul>
<li><a href="http://www.haskell.org/ghc/docs/papers/unboxed-values.ps.gz" target="_blank" rel="noopener">Unboxed Values as First-Class Citizens</a> (未装箱值作为一等公民)</li>
</ul>
<h3 id="IO-ST"><a href="#IO-ST" class="headerlink" title="IO/ST"></a>IO/ST</h3><p><code>IO</code>和<code>ST monad</code>在<code>GHC</code>运行时中都具有特殊状态，并且共享非常相似的实现。<code>ST a</code>和<code>IO a</code>都传递以下形式的未装箱元组:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(# token, a #)</span><br></pre></td></tr></table></figure></p>
<p><code>RealWorld＃</code>令牌具有<code>深奥的魔力</code>，在编译时实际上不会<code>expand into</code>(扩展)为任何代码，而只是在<code>IO</code>或<code>ST monad</code>的每个绑定中<code>threaded around through</code>(四处穿线)，并且具有多个唯一性和不可复制性,确保顺序的IO操作实际上是顺序的。</p>
<p><code>unsafePerformIO</code>可以被认为是一种独特的操作，它丢弃<code>world</code>令牌并将<code>a</code>取出，顾名思义，它通常并不安全。</p>
<p><code>PrimMonad</code>将这两个<code>monad</code>以及与<code>world</code>令牌或<code>ST</code>线程相关联的数据族抽象出来，并可用于编写在<code>ST</code>和<code>IO</code>上通用的操作。它在<code>vector</code>(向量)包内部广泛使用，以使向量算法可以在<code>IO</code>或<code>ST</code>内部通用编写。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE MagicHash #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE UnboxedTuples #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.IO ( <span class="type">IO(..)</span> )</span><br><span class="line"><span class="keyword">import</span> GHC.Prim ( <span class="type">State</span>#, <span class="type">RealWorld</span> )</span><br><span class="line"><span class="keyword">import</span> GHC.Base ( <span class="title">realWorld</span># )</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span>  <span class="type">Monad</span> <span class="type">IO</span>  <span class="keyword">where</span></span></span><br><span class="line">    m &gt;&gt; k    = m &gt;&gt;= \ _ -&gt; k</span><br><span class="line">    return    = returnIO</span><br><span class="line">    (&gt;&gt;=)     = bindIO</span><br><span class="line">    fail s    = failIO s</span><br><span class="line"></span><br><span class="line"><span class="title">returnIO</span> :: a -&gt; <span class="type">IO</span> a</span><br><span class="line"><span class="title">returnIO</span> x = <span class="type">IO</span> $ \ s -&gt; (# s, x #)</span><br><span class="line"></span><br><span class="line"><span class="title">bindIO</span> :: <span class="type">IO</span> a -&gt; (a -&gt; <span class="type">IO</span> b) -&gt; <span class="type">IO</span> b</span><br><span class="line"><span class="title">bindIO</span> (<span class="type">IO</span> m) k = <span class="type">IO</span> $ \ s -&gt; <span class="keyword">case</span> m s <span class="keyword">of</span> (# new_s, a #) -&gt; unIO (k a) new_s</span><br><span class="line"></span><br><span class="line"><span class="title">thenIO</span> :: <span class="type">IO</span> a -&gt; <span class="type">IO</span> b -&gt; <span class="type">IO</span> b</span><br><span class="line"><span class="title">thenIO</span> (<span class="type">IO</span> m) k = <span class="type">IO</span> $ \ s -&gt; <span class="keyword">case</span> m s <span class="keyword">of</span> (# new_s, _ #) -&gt; unIO k new_s</span><br><span class="line"></span><br><span class="line"><span class="title">unIO</span> :: <span class="type">IO</span> a -&gt; (<span class="type">State</span># <span class="type">RealWorld</span> -&gt; (# <span class="type">State</span># <span class="type">RealWorld</span>, a #))</span><br><span class="line"><span class="title">unIO</span> (<span class="type">IO</span> a) = a</span><br><span class="line"><span class="meta">&#123;-# LANGUAGE MagicHash #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE UnboxedTuples #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.IO ( <span class="type">IO(..)</span> )</span><br><span class="line"><span class="keyword">import</span> GHC.ST ( <span class="type">ST(..)</span> )</span><br><span class="line"><span class="keyword">import</span> GHC.Prim ( <span class="type">State</span>#, <span class="type">RealWorld</span> )</span><br><span class="line"><span class="keyword">import</span> GHC.Base ( <span class="title">realWorld</span># )</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m =&gt; <span class="type">PrimMonad</span> m <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="type">PrimState</span> m</span></span><br><span class="line">  primitive :: (<span class="type">State</span># (<span class="type">PrimState</span> m) -&gt; (# <span class="type">State</span># (<span class="type">PrimState</span> m), a #)) -&gt; m a</span><br><span class="line">  internal :: m a -&gt; <span class="type">State</span># (<span class="type">PrimState</span> m) -&gt; (# <span class="type">State</span># (<span class="type">PrimState</span> m), a #)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">PrimMonad</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="type">PrimState</span> <span class="type">IO</span> = <span class="type">RealWorld</span></span></span><br><span class="line">  primitive = <span class="type">IO</span></span><br><span class="line">  internal (<span class="type">IO</span> p) = p</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">PrimMonad</span> (<span class="type">ST</span> <span class="title">s</span>) <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="type">PrimState</span> (<span class="type">ST</span> <span class="title">s</span>) = s</span></span><br><span class="line">  primitive = <span class="type">ST</span></span><br><span class="line">  internal (<span class="type">ST</span> p) = p</span><br></pre></td></tr></table></figure></p>
<p>請看:</p>
<ul>
<li><a href="https://www.fpcomplete.com/user/snoyberg/general-haskell/advanced/evaluation-order-and-state-tokens" target="_blank" rel="noopener">Evaluation order and state tokens</a>（评估顺序和状态令牌）</li>
</ul>
<h3 id="ghc-heap-view"><a href="#ghc-heap-view" class="headerlink" title="ghc-heap-view"></a>ghc-heap-view</h3><p>通过一些黑暗的运行时魔法，我们实际上可以使用各种<code>C</code>和<code>Cmm</code>技巧在运行时检查<code>StgClosure</code>结构，以在运行时探究结构表示形式的字段。<br><code>ghc-heap-view</code>库可以用于内省此类事情，尽管在日常代码中这种东西实际上没有用，但在研究<code>GHC</code>内部结构以检查运行时实现细节并获取所有<code>Haskell</code>类型的底层原始位时非常有帮助。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE MagicHash #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.Exts</span><br><span class="line"><span class="keyword">import</span> GHC.HeapView</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> System.Mem</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  <span class="comment">-- Constr</span></span><br><span class="line">  clo &lt;- getClosureData $! ([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] :: [<span class="type">Int</span>])</span><br><span class="line">  print clo</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Thunk</span></span><br><span class="line">  <span class="keyword">let</span> thunk = id (<span class="number">1</span>+<span class="number">1</span>)</span><br><span class="line">  clo &lt;- getClosureData thunk</span><br><span class="line">  print clo</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- evaluate to WHNF</span></span><br><span class="line">  thunk `seq` return ()</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Indirection(间接的)</span></span><br><span class="line">  clo &lt;- getClosureData thunk</span><br><span class="line">  print clo</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- force garbage collection</span></span><br><span class="line">  performGC</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Value</span></span><br><span class="line">  clo &lt;- getClosureData thunk</span><br><span class="line">  print clo</span><br></pre></td></tr></table></figure></p>
<p>构造函数(在此为列表类型的<code>cons</code>构造函数)由<code>CONSTR</code>闭包表示，该闭包包含指向头部和尾部的两个指针。<br><code>head</code>参数中的<code>integer</code>(整数)是对预分配<code>number</code>(数字)的静态引用，我们在<code>SRT</code>(静态引用表)中看到一个静态引用。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConsClosure</span> &#123;</span><br><span class="line">  info = <span class="type">StgInfoTable</span> &#123;</span><br><span class="line">    ptrs = <span class="number">2</span>,</span><br><span class="line">    nptrs = <span class="number">0</span>,</span><br><span class="line">    tipe = <span class="type">CONSTR_2_0</span>,</span><br><span class="line">    srtlen = <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ptrArgs = [<span class="number">0x000000000074aba8</span>/<span class="number">1</span>,<span class="number">0x00007fca10504260</span>/<span class="number">2</span>],</span><br><span class="line">  dataArgs = [],</span><br><span class="line">  pkg = <span class="string">"ghc-prim"</span>,</span><br><span class="line">  modl = <span class="string">"GHC.Types"</span>,</span><br><span class="line">  name = <span class="string">":"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们还可以观察到进程中的<code>thunk</code>的评估和更新(<code>id（1 + 1</code>)。<br>最初的<code>thunk</code>只是一个<code>thunk</code>类型，带有指向代码的指针以将其评估为值。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThunkClosure</span> &#123;</span><br><span class="line">  info = <span class="type">StgInfoTable</span> &#123;</span><br><span class="line">    ptrs = <span class="number">0</span>,</span><br><span class="line">    nptrs = <span class="number">0</span>,</span><br><span class="line">    tipe = <span class="type">THUNK</span>,</span><br><span class="line">    srtlen = <span class="number">9</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ptrArgs = [],</span><br><span class="line">  dataArgs = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>强制时，将对其进行评估并替换为一个指向已计算值的间接闭包。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BlackholeClosure</span> &#123;</span><br><span class="line">  info = <span class="type">StgInfoTable</span> &#123;</span><br><span class="line">    ptrs = <span class="number">1</span>,</span><br><span class="line">    nptrs = <span class="number">0</span>,</span><br><span class="line">    tipe = <span class="type">BLACKHOLE</span>,</span><br><span class="line">    srtlen = <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  indirectee = <span class="number">0x00007fca10511e88</span>/<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当复制垃圾收集器通过<code>indirection</code>(间接)时，它只是用一个由<code>indirectee</code>计算的实际计算值的引用替换<code>indirection</code>(间接)，这样以后的访问就需要通过<code>indirection</code>(间接)指针<code>chase</code>(追逐)指针以获得结果。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConsClosure</span> &#123;</span><br><span class="line">  info = <span class="type">StgInfoTable</span> &#123;</span><br><span class="line">    ptrs = <span class="number">0</span>,</span><br><span class="line">    nptrs = <span class="number">1</span>,</span><br><span class="line">    tipe = <span class="type">CONSTR_0_1</span>,</span><br><span class="line">    srtlen = <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ptrArgs = [],</span><br><span class="line">  dataArgs = [<span class="number">2</span>],</span><br><span class="line">  pkg = <span class="string">"integer-gmp"</span>,</span><br><span class="line">  modl = <span class="string">"GHC.Integer.Type"</span>,</span><br><span class="line">  name = <span class="string">"S#"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="STG"><a href="#STG" class="headerlink" title="STG"></a>STG</h3><p>在被编译为<code>Core</code>之后，程序会被翻译成非常相似的中间形式，称为<code>STG</code>(无脊椎无标签G机器)，该抽象机器模型使所有<code>laziness</code>(惰性)变得<code>explicit</code>(清晰明確)。<br><code>spineless</code>表示该语言中的<code>function applications</code>(函数应用)没有函数应用的<code>spine</code>(脊柱)，而是将其折叠为一系列参数。由于语义信息被存储并且部分应用的函数与<code>saturated</code>(饱和)函数的评估方式不同，因此语义中仍然存在<code>Currying</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Spine</span></span><br><span class="line"><span class="title">f</span> x y z = <span class="type">App</span> (<span class="type">App</span> (<span class="type">App</span> f x) y) z</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Spineless</span></span><br><span class="line"><span class="title">f</span> x y z = <span class="type">App</span> f [x, y, z]</span><br></pre></td></tr></table></figure></p>
<p><code>STG</code>中的所有<code>let</code>语句都将名称绑定到<code>lambda form</code>。不带参数的<code>lambda form</code>是<code>thunk</code>，而带参数的<code>lambda form</code>表示将分配闭包，以捕获显式提及的变量。<br><code>Thunks</code>本身要么是可重入的(<code>\r</code>)，要么是可更新的(<code>\u</code>)，这表明<code>thunk</code>会向栈中产生一个值，或者在<code>update frame</code>(更新帧)被求值后在堆中分配一个值。<br><code>thunk</code>的所有后续条目将生成已经计算过的值，而不需要重新执行相同的工作。</p>
<p><code>Lambda form</code>还指示静态引用表，该引用是对函数体所引用的静态堆分配值的引用的集合。<br>例如，打开<code>-ddump-stg</code>，我们可以看到以下<code>compose</code>函数的扩展。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Frontend</span></span><br><span class="line"><span class="title">compose</span> f g = \x -&gt; f (g x)</span><br><span class="line"><span class="comment">-- Core</span></span><br><span class="line"><span class="title">compose</span> :: <span class="keyword">forall</span> t t1 t2. (t1 -&gt; t) -&gt; (t2 -&gt; t1) -&gt; t2 -&gt; t</span><br><span class="line"><span class="title">compose</span> =</span><br><span class="line">  \ (@ t) (@ t1) (@ t2) (f :: t1 -&gt; t) (g :: t2 -&gt; t1) (x :: t2) -&gt;</span><br><span class="line">    f (g x)</span><br><span class="line"><span class="comment">-- STG</span></span><br><span class="line"><span class="title">compose</span> :: <span class="keyword">forall</span> t t1 t2. (t1 -&gt; t) -&gt; (t2 -&gt; t1) -&gt; t2 -&gt; t =</span><br><span class="line">    \r [f g x] <span class="keyword">let</span> &#123; sat :: t1 = \u [] g x; &#125; <span class="keyword">in</span>  f sat;</span><br><span class="line"><span class="type">SRT</span>(compose): []</span><br></pre></td></tr></table></figure></p>
<p>对于更复杂的示例，让我们跟踪阶乘函数的编译。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Frontend</span></span><br><span class="line"><span class="title">fac</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">fac</span> a <span class="number">0</span> = a</span><br><span class="line"><span class="title">fac</span> a n = fac (n*a) (n<span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- Core</span></span><br><span class="line"><span class="type">Rec</span> &#123;</span><br><span class="line"><span class="title">fac</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">fac</span> =</span><br><span class="line">  \ (a :: <span class="type">Int</span>) (ds :: <span class="type">Int</span>) -&gt;</span><br><span class="line">    <span class="keyword">case</span> ds <span class="keyword">of</span> wild &#123; <span class="type">I</span># ds1 -&gt;</span><br><span class="line">    <span class="keyword">case</span> ds1 <span class="keyword">of</span> _ &#123;</span><br><span class="line">      __DEFAULT -&gt;</span><br><span class="line">        fac (* @ <span class="type">Int</span> $fNumInt wild a) (- @ <span class="type">Int</span> $fNumInt wild (<span class="type">I</span># <span class="number">1</span>));</span><br><span class="line">      <span class="number">0</span> -&gt; a</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="title">end</span> <span class="type">Rec</span> &#125;</span><br><span class="line"><span class="comment">-- STG</span></span><br><span class="line"><span class="title">fac</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> =</span><br><span class="line">    \r srt:(<span class="number">0</span>,*bitmap*) [a ds]</span><br><span class="line">        <span class="keyword">case</span> ds <span class="keyword">of</span> wild &#123;</span><br><span class="line">          <span class="type">I</span># ds1 -&gt;</span><br><span class="line">              <span class="keyword">case</span> ds1 <span class="keyword">of</span> _ &#123;</span><br><span class="line">                __DEFAULT -&gt;</span><br><span class="line">                    <span class="keyword">let</span> &#123;</span><br><span class="line">                      sat :: <span class="type">Int</span> =</span><br><span class="line">                          <span class="comment">-- \u</span></span><br><span class="line">                          \u srt:(<span class="number">1</span>,*bitmap*) []</span><br><span class="line">                              <span class="keyword">let</span> &#123; sat :: <span class="type">Int</span> = <span class="type">NO_CCS</span> <span class="type">I</span>#! [<span class="number">1</span>]; &#125; <span class="keyword">in</span>  - $fNumInt wild sat; &#125; <span class="keyword">in</span></span><br><span class="line">                    <span class="comment">-- \u</span></span><br><span class="line">                    <span class="keyword">let</span> &#123; sat :: <span class="type">Int</span> = \u srt:(<span class="number">1</span>,*bitmap*) [] * $fNumInt wild a;</span><br><span class="line">                    &#125; <span class="keyword">in</span>  fac sat sat;</span><br><span class="line">                <span class="number">0</span> -&gt; a;</span><br><span class="line">              &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="type">SRT</span>(fac): [fac, $fNumInt]</span><br></pre></td></tr></table></figure></p>
<p>注意，阶乘函数在循环内部分配了两个<code>thunk</code>(查找<code>\u</code>)，在计算时会更新它们。它还包括对自身(用于递归)和字典的静态引用，例如对<code>Int</code>类型的<code>Num</code>类型类的实例。</p>
<h3 id="Worker-Wrapper"><a href="#Worker-Wrapper" class="headerlink" title="Worker/Wrapper"></a>Worker/Wrapper</h3><p>打开<code>-O2</code>后，<code>GHC</code>将执行一种特殊的优化，称为<code>Worker-Wrapper</code>转换，它将把阶乘函数的逻辑拆分为两个定义，<br><code>worker</code>将操作<code>stack</code>(堆栈)上<code>unboxed</code>(未装箱)的已分配的机器<code>integers</code>(整数)，这些整数將编译成一个紧凑的内部循环，而<code>wrapper</code>调用<code>worker</code>并收集循环的最终结果，并将其打包回到一个<code>boxed</code>(装箱)的<code>heap</code>(堆)值。这通常比单纯的实现要快一个数量级，后者需要在每次迭代中打包和解包已装箱的整数。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Worker</span></span><br><span class="line">$wfac :: <span class="type">Int</span># -&gt; <span class="type">Int</span># -&gt; <span class="type">Int</span># =</span><br><span class="line">    \r [ww ww1]</span><br><span class="line">        <span class="keyword">case</span> ww1 <span class="keyword">of</span> ds &#123;</span><br><span class="line">          __DEFAULT -&gt;</span><br><span class="line">              <span class="keyword">case</span> -# [ds <span class="number">1</span>] <span class="keyword">of</span> sat &#123;</span><br><span class="line">                __DEFAULT -&gt;</span><br><span class="line">                    <span class="keyword">case</span> *# [ds ww] <span class="keyword">of</span> sat &#123; __DEFAULT -&gt; $wfac sat sat; &#125;;</span><br><span class="line">              &#125;;</span><br><span class="line">          <span class="number">0</span> -&gt; ww;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="type">SRT</span>($wfac): []</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Wrapper</span></span><br><span class="line"><span class="title">fac</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> =</span><br><span class="line">    \r [w w1]</span><br><span class="line">        <span class="keyword">case</span> w <span class="keyword">of</span> _ &#123;</span><br><span class="line">          <span class="type">I</span># ww -&gt;</span><br><span class="line">              <span class="keyword">case</span> w1 <span class="keyword">of</span> _ &#123;</span><br><span class="line">                <span class="type">I</span># ww1 -&gt; <span class="keyword">case</span> $wfac ww ww1 <span class="keyword">of</span> ww2 &#123; __DEFAULT -&gt; <span class="type">I</span># [ww2]; &#125;;</span><br><span class="line">              &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="type">SRT</span>(fac): []</span><br></pre></td></tr></table></figure></p>
<p>請看:</p>
<ul>
<li><a href="https://donsbot.wordpress.com/2008/05/06/write-haskell-as-fast-as-c-exploiting-strictness-laziness-and-recursion/" target="_blank" rel="noopener">Writing Haskell as Fast as C</a></li>
</ul>
<h3 id="Z-Encoding"><a href="#Z-Encoding" class="headerlink" title="Z-Encoding"></a>Z-Encoding</h3><p><code>Z-Encoding</code>是<code>Haskell</code>的约定，用于生成在编译器目标语言中安全表示的名称。<br>简单地说，<code>Z-Encoding</code>将许多符号字符重命名为<code>z</code>字符的特殊序列。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span>	  <span class="type">Z</span>-<span class="type">Encoded</span> <span class="type">String</span></span><br><span class="line"><span class="comment">----------------------------</span></span><br><span class="line"><span class="title">foo</span>	          foo</span><br><span class="line"><span class="title">z</span>	          zz</span><br><span class="line"><span class="type">Z</span>	          <span class="type">ZZ</span></span><br><span class="line">()            <span class="type">Z0T</span></span><br><span class="line">(,)	          <span class="type">Z2T</span></span><br><span class="line">(,,)	      <span class="type">Z3T</span></span><br><span class="line"><span class="title">_</span>	          zu</span><br><span class="line">(	          <span class="type">ZL</span></span><br><span class="line">)	          <span class="type">ZR</span></span><br><span class="line">:	          <span class="type">ZC</span></span><br><span class="line"><span class="meta">#	          zh</span></span><br><span class="line">.	          zi</span><br><span class="line">(#,#)	      <span class="type">Z2H</span></span><br><span class="line">(-&gt;)	      <span class="type">ZLzmzgZR</span></span><br></pre></td></tr></table></figure></p>
<p>这样，我们不必为<code>character-rich</code>(字符丰富)的名称生成唯一的无法识别的名称，而可以简单地通过一种直接的方法将它们转换为唯一但可识别的名称。<br>因此，对于<code>GHC</code>生成的代码中的一些示例名称:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Z</span>-<span class="type">Encoded</span> <span class="type">String</span>	                    <span class="type">Decoded</span> <span class="type">String</span></span><br><span class="line"><span class="comment">----------------------------------------------------------------------</span></span><br><span class="line"><span class="type">ZCMain_main_closure</span>	                    :<span class="type">Main_main_closure</span></span><br><span class="line"><span class="title">base_GHCziBase_map_closure</span>	            base_GHC.<span class="type">Base_map_closure</span></span><br><span class="line"><span class="title">base_GHCziInt_I32zh_con_info</span>	        base_GHC.<span class="type">Int_I32</span>#_con_info</span><br><span class="line"><span class="title">ghczmprim_GHCziTuple_Z3T_con_info</span>	    ghc-prim_GHC.<span class="type">Tuple_</span>(,,)_con_in</span><br><span class="line"><span class="title">ghczmprim_GHCziTypes_ZC_con_info</span>	    ghc-prim_GHC.<span class="type">Types_</span>:_con_info</span><br></pre></td></tr></table></figure></p>
<h3 id="Cmm"><a href="#Cmm" class="headerlink" title="Cmm"></a>Cmm</h3><p><code>Cmm</code>是<code>GHC</code>的复杂内部中间表示形式，可直接映射到编译器目标的生成代码上。<br>从<code>Haskell</code>生成的<code>Cmm</code>代码是经过<code>CPS</code>转换的，<br>所有函数从不返回值，它们仅调用<code>continuation</code>(连续)堆栈中的下一<code>frame</code>(帧)。<br>对函数的所有评估都是通过调用方<code>indirectly</code>(间接)跳转到代码对象并将其参数放在<code>stack</code>(堆栈)上来进行的。<br>这与<code>C</code>的评估模型截然不同，后者的评估模型放置在堆栈上，函数返回后会向堆栈产生一个值。</p>
<p>您会在所有闭包和函数名称中看到几个常见的后缀:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Symbol</span>	<span class="type">Meaning</span></span><br><span class="line"><span class="comment">----------------------------------</span></span><br><span class="line"><span class="number">0</span>	      <span class="type">No</span> argument</span><br><span class="line"><span class="title">p</span>	      <span class="type">Garbage</span> <span class="type">Collected</span> <span class="type">Pointer</span></span><br><span class="line"><span class="title">n</span>	      <span class="type">Word</span>-sized non-pointer</span><br><span class="line"><span class="title">l</span>	      <span class="number">64</span>-bit non-pointer (long)</span><br><span class="line"><span class="title">v</span>	      <span class="type">Void</span></span><br><span class="line"><span class="title">f</span>	      <span class="type">Float</span></span><br><span class="line"><span class="title">d</span>	      <span class="type">Double</span></span><br><span class="line"><span class="title">v16</span>	    <span class="number">16</span>-byte vector</span><br><span class="line"><span class="title">v32</span>	    <span class="number">32</span>-byte vector</span><br><span class="line"><span class="title">v64</span>	    <span class="number">64</span>-byte vector</span><br></pre></td></tr></table></figure></p>
<h4 id="Cmm-Registers-寄存器"><a href="#Cmm-Registers-寄存器" class="headerlink" title="Cmm Registers (寄存器)"></a>Cmm Registers (寄存器)</h4><p>机器模型中描述了10个寄存器。<code>Sp</code>是指向堆栈顶部的指针，<code>SpLim</code>是指向堆栈中最后一个元素的指针。<code>Hp</code>是堆指针，用于通过当前堆限制<code>HpLim</code>进行分配和垃圾回收。<br><code>R1</code>寄存器始终持有活动闭包，<code>subsequent</code>(后续)寄存器是在寄存器中传递的参数。<code>Functions with more than 10 values spill into memory</code>(具有10个以上值的函数会溢出到内存中)。</p>
<ul>
<li><strong>Sp</strong></li>
<li><strong>SpLim</strong></li>
<li><strong>Hp</strong></li>
<li><strong>HpLim</strong></li>
<li><strong>HpAlloc</strong></li>
<li><strong>R1</strong></li>
<li><strong>R2</strong></li>
<li><strong>R3</strong></li>
<li><strong>R4</strong></li>
<li><strong>R5</strong></li>
<li><strong>R6</strong></li>
<li><strong>R7</strong></li>
<li><strong>R8</strong></li>
<li><strong>R9</strong></li>
<li><strong>R10</strong></li>
</ul>
<h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><p>为了理解<code>Cmm</code>，查看由等价的<code>Haskell</code>生成的代码并慢慢理解等价性和机械翻译之间的映射是很有用的。<br>每个<code>Cmm</code>定义通常都有两部分，即<code>info table</code>(信息表)和<code>entry code</code>(输入代码)。</p>
<p><code>info table</code>直接映射<code>StgInfoTable</code>结构，包含与闭包类型、其<code>payload</code>(有效负载)和<code>references</code>(引用)相关的各种字段。</p>
<p><code>code</code>(代码)对象是生成代码的基本<code>blocks</code>(块)，与<code>Haskell</code>函数/构造函数的逻辑相对应。</p>
<p>对于最简单的示例，请考虑一个常量静态构造函数。只是产生<code>Unit</code>值的函数。<br>在这种情况下，该函数只是没有<code>payload</code>(有效负载)的构造函数，并且是静态分配的:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Haskell</span>:</span><br><span class="line"></span><br><span class="line"><span class="title">unit</span> = ()</span><br><span class="line"><span class="type">Cmm</span>:</span><br><span class="line"></span><br><span class="line">[section <span class="string">"data"</span> &#123;</span><br><span class="line">     unit_closure:</span><br><span class="line">         const ()_static_info;</span><br><span class="line"> &#125;]</span><br></pre></td></tr></table></figure></p>
<p>考虑带有参数的静态构造函数:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Haskell</span>:</span><br><span class="line"></span><br><span class="line"><span class="title">con</span> :: <span class="type">Maybe</span> ()</span><br><span class="line"><span class="title">con</span> = <span class="type">Just</span> ()</span><br><span class="line"><span class="type">Cmm</span>:</span><br><span class="line"></span><br><span class="line">[section <span class="string">"data"</span> &#123;</span><br><span class="line">     con_closure:</span><br><span class="line">         const <span class="type">Just_static_info</span>;</span><br><span class="line">         const ()_closure+<span class="number">1</span>;</span><br><span class="line">         const <span class="number">1</span>;</span><br><span class="line"> &#125;]</span><br></pre></td></tr></table></figure></p>
<p>考虑<code>literal</code>(字面)常量。这是一个静态值:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Haskell</span>:</span><br><span class="line"></span><br><span class="line"><span class="title">lit</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">lit</span> = <span class="number">1</span></span><br><span class="line"><span class="type">Cmm</span>:</span><br><span class="line"></span><br><span class="line">[section <span class="string">"data"</span> &#123;</span><br><span class="line">     lit_closure:</span><br><span class="line">         const <span class="type">I</span>#_static_info;</span><br><span class="line">         const <span class="number">1</span>;</span><br><span class="line"> &#125;]</span><br></pre></td></tr></table></figure></p>
<p>考虑<code>identity</code>函數:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Haskell</span>:</span><br><span class="line"></span><br><span class="line"><span class="title">id</span> x = x</span><br><span class="line"><span class="type">Cmm</span>:</span><br><span class="line"></span><br><span class="line">[section <span class="string">"data"</span> &#123;</span><br><span class="line">     id_closure:</span><br><span class="line">         const id_info;</span><br><span class="line"> &#125;,</span><br><span class="line"> id_info()</span><br><span class="line">         &#123; label: id_info</span><br><span class="line">           rep:<span class="type">HeapRep</span> static &#123; <span class="type">Fun</span> &#123;arity: <span class="number">1</span> fun_type: <span class="type">ArgSpec</span> <span class="number">5</span>&#125; &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     ch1:</span><br><span class="line">         <span class="type">R1</span> = <span class="type">R2</span>;</span><br><span class="line">         jump stg_ap_0_fast; // [<span class="type">R1</span>]</span><br><span class="line"> &#125;]</span><br></pre></td></tr></table></figure></p>
<p>考虑常数函数:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Haskell</span>:</span><br><span class="line"></span><br><span class="line"><span class="title">constant</span> x y = x</span><br><span class="line"><span class="type">Cmm</span>:</span><br><span class="line"></span><br><span class="line">[section <span class="string">"data"</span> &#123;</span><br><span class="line">     constant_closure:</span><br><span class="line">         const constant_info;</span><br><span class="line"> &#125;,</span><br><span class="line"> constant_info()</span><br><span class="line">         &#123; label: constant_info</span><br><span class="line">           rep:<span class="type">HeapRep</span> static &#123; <span class="type">Fun</span> &#123;arity: <span class="number">2</span> fun_type: <span class="type">ArgSpec</span> <span class="number">12</span>&#125; &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     cgT:</span><br><span class="line">         <span class="type">R1</span> = <span class="type">R2</span>;</span><br><span class="line">         jump stg_ap_0_fast; // [<span class="type">R1</span>]</span><br><span class="line"> &#125;]</span><br></pre></td></tr></table></figure></p>
<p><code>Consider a function where application of a function (of unknown arity) occurs.</code>(考虑发生函数应用的函数)<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Haskell</span>:</span><br><span class="line"></span><br><span class="line"><span class="title">compose</span> f g x = f (g x)</span><br><span class="line"><span class="type">Cmm</span>:</span><br><span class="line"></span><br><span class="line">[section <span class="string">"data"</span> &#123;</span><br><span class="line">     compose_closure:</span><br><span class="line">         const compose_info;</span><br><span class="line"> &#125;,</span><br><span class="line"> compose_info()</span><br><span class="line">         &#123; label: compose_info</span><br><span class="line">           rep:<span class="type">HeapRep</span> static &#123; <span class="type">Fun</span> &#123;arity: <span class="number">3</span> fun_type: <span class="type">ArgSpec</span> <span class="number">20</span>&#125; &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     ch9:</span><br><span class="line">         <span class="type">Hp</span> = <span class="type">Hp</span> + <span class="number">32</span>;</span><br><span class="line">         <span class="keyword">if</span> (<span class="type">Hp</span> &gt; <span class="type">HpLim</span>) goto chd;</span><br><span class="line">         <span class="type">I64</span>[<span class="type">Hp</span> - <span class="number">24</span>] = stg_ap_2_upd_info;</span><br><span class="line">         <span class="type">I64</span>[<span class="type">Hp</span> - <span class="number">8</span>] = <span class="type">R3</span>;</span><br><span class="line">         <span class="type">I64</span>[<span class="type">Hp</span> + <span class="number">0</span>] = <span class="type">R4</span>;</span><br><span class="line">         <span class="type">R1</span> = <span class="type">R2</span>;</span><br><span class="line">         <span class="type">R2</span> = <span class="type">Hp</span> - <span class="number">24</span>;</span><br><span class="line">         jump stg_ap_p_fast; // [<span class="type">R1</span>, <span class="type">R2</span>]</span><br><span class="line">     che:</span><br><span class="line">         <span class="type">R1</span> = compose_closure;</span><br><span class="line">         jump stg_gc_fun; // [<span class="type">R1</span>, <span class="type">R4</span>, <span class="type">R3</span>, <span class="type">R2</span>]</span><br><span class="line">     chd:</span><br><span class="line">         <span class="type">HpAlloc</span> = <span class="number">32</span>;</span><br><span class="line">         goto che;</span><br><span class="line"> &#125;]</span><br></pre></td></tr></table></figure></p>
<p>考虑使用模式匹配进行分支的函数:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Haskell</span>:</span><br><span class="line"></span><br><span class="line"><span class="title">match</span> :: <span class="type">Either</span> a a -&gt; a</span><br><span class="line"><span class="title">match</span> x = <span class="keyword">case</span> x <span class="keyword">of</span></span><br><span class="line">  <span class="type">Left</span> a -&gt; a</span><br><span class="line">  <span class="type">Right</span> b -&gt; b</span><br><span class="line"><span class="type">Cmm</span>:</span><br><span class="line"></span><br><span class="line">[section <span class="string">"data"</span> &#123;</span><br><span class="line">     match_closure:</span><br><span class="line">         const match_info;</span><br><span class="line"> &#125;,</span><br><span class="line"> sio_ret()</span><br><span class="line">         &#123; label: sio_info</span><br><span class="line">           rep:<span class="type">StackRep</span> []</span><br><span class="line">         &#125;</span><br><span class="line">     ciL:</span><br><span class="line">         _ciM::<span class="type">I64</span> = <span class="type">R1</span> &amp; <span class="number">7</span>;</span><br><span class="line">         <span class="keyword">if</span> (_ciM::<span class="type">I64</span> &gt;= <span class="number">2</span>) goto ciN;</span><br><span class="line">         <span class="type">R1</span> = <span class="type">I64</span>[<span class="type">R1</span> + <span class="number">7</span>];</span><br><span class="line">         <span class="type">Sp</span> = <span class="type">Sp</span> + <span class="number">8</span>;</span><br><span class="line">         jump stg_ap_0_fast; // [<span class="type">R1</span>]</span><br><span class="line">     ciN:</span><br><span class="line">         <span class="type">R1</span> = <span class="type">I64</span>[<span class="type">R1</span> + <span class="number">6</span>];</span><br><span class="line">         <span class="type">Sp</span> = <span class="type">Sp</span> + <span class="number">8</span>;</span><br><span class="line">         jump stg_ap_0_fast; // [<span class="type">R1</span>]</span><br><span class="line"> &#125;,</span><br><span class="line"> match_info()</span><br><span class="line">         &#123; label: match_info</span><br><span class="line">           rep:<span class="type">HeapRep</span> static &#123; <span class="type">Fun</span> &#123;arity: <span class="number">1</span> fun_type: <span class="type">ArgSpec</span> <span class="number">5</span>&#125; &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     ciP:</span><br><span class="line">         <span class="keyword">if</span> (<span class="type">Sp</span> - <span class="number">8</span> &lt; <span class="type">SpLim</span>) goto ciR;</span><br><span class="line">         <span class="type">R1</span> = <span class="type">R2</span>;</span><br><span class="line">         <span class="type">I64</span>[<span class="type">Sp</span> - <span class="number">8</span>] = sio_info;</span><br><span class="line">         <span class="type">Sp</span> = <span class="type">Sp</span> - <span class="number">8</span>;</span><br><span class="line">         <span class="keyword">if</span> (<span class="type">R1</span> &amp; <span class="number">7</span> != <span class="number">0</span>) goto ciU;</span><br><span class="line">         jump <span class="type">I64</span>[<span class="type">R1</span>]; // [<span class="type">R1</span>]</span><br><span class="line">     ciR:</span><br><span class="line">         <span class="type">R1</span> = match_closure;</span><br><span class="line">         jump stg_gc_fun; // [<span class="type">R1</span>, <span class="type">R2</span>]</span><br><span class="line">     ciU: jump sio_info; // [<span class="type">R1</span>]</span><br><span class="line"> &#125;]</span><br></pre></td></tr></table></figure></p>
<h4 id="Macros-宏"><a href="#Macros-宏" class="headerlink" title="Macros (宏)"></a>Macros (宏)</h4><p><code>Cmm</code>本身使用许多宏来代表各种构造，其中许多是在外部<code>C</code>头文件中定义的。常见类型的简短参考：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cmm</span>	  <span class="type">Description</span></span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line"><span class="type">C_</span>	  char</span><br><span class="line"><span class="type">D_</span>	  double</span><br><span class="line"><span class="type">F_</span>	  float</span><br><span class="line"><span class="type">W_</span>	  word</span><br><span class="line"><span class="type">P_</span>	  garbage collected pointer</span><br><span class="line"><span class="type">I_</span>	  int</span><br><span class="line"><span class="type">L_</span>	  long</span><br><span class="line"><span class="type">FN_</span>	  function pointer (no arguments)</span><br><span class="line"><span class="type">EF_</span>	  extern function pointer</span><br><span class="line"><span class="type">I8</span>	  <span class="number">8</span>-bit integer</span><br><span class="line"><span class="type">I16</span>	  <span class="number">16</span>-bit integer</span><br><span class="line"><span class="type">I32</span>	  <span class="number">32</span>-bit integer</span><br><span class="line"><span class="type">I64</span>	  <span class="number">64</span>-bit integer</span><br></pre></td></tr></table></figure></p>
<p>许多预定义的闭包(<code>stg_ap_p_fast</code>等)本身都是机械生成的，或多或少共享相同的<code>form</code>(形式)(关于闭包类型，<code>update frame</code>更新框架，<code>stack adjustment</code>堆栈调整的巨大<code>switch</code>语句)。</p>
<p><code>GHC</code>的内部是一个名为<code>GenApply.hs</code>的文件，该文件生成大多数这些函數。有关<code>GHC</code>生成的当前源文件，请参见阅读部分的<code>Gist</code>链接。</p>
<p>例如<code>stg_ap_p_fast</code>的输出:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">stg_ap_p_fast</span><br><span class="line">&#123;   W_ info;</span><br><span class="line">    W_ arity;</span><br><span class="line">    <span class="keyword">if</span> (GETTAG(R1)==<span class="number">1</span>) &#123;</span><br><span class="line">        Sp_adj(<span class="number">0</span>);</span><br><span class="line">        jump %GET_ENTRY(R1<span class="number">-1</span>) [R1,R2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Sp - WDS(<span class="number">2</span>) &lt; SpLim) &#123;</span><br><span class="line">        Sp_adj(<span class="number">-2</span>);</span><br><span class="line">        W_[Sp+WDS(<span class="number">1</span>)] = R2;</span><br><span class="line">        Sp(<span class="number">0</span>) = stg_ap_p_info;</span><br><span class="line">        jump __stg_gc_enter_1 [R1];</span><br><span class="line">    &#125;</span><br><span class="line">    R1 = UNTAG(R1);</span><br><span class="line">    info = %GET_STD_INFO(R1);</span><br><span class="line">    <span class="keyword">switch</span> [INVALID_OBJECT .. N_CLOSURE_TYPES] (TO_W_(%INFO_TYPE(info))) &#123;</span><br><span class="line">        <span class="keyword">case</span> FUN,</span><br><span class="line">             FUN_1_0,</span><br><span class="line">             FUN_0_1,</span><br><span class="line">             FUN_2_0,</span><br><span class="line">             FUN_1_1,</span><br><span class="line">             FUN_0_2,</span><br><span class="line">             FUN_STATIC: &#123;</span><br><span class="line">            arity = TO_W_(StgFunInfoExtra_arity(%GET_FUN_INFO(R1)));</span><br><span class="line">            ASSERT(arity &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (arity == <span class="number">1</span>) &#123;</span><br><span class="line">                Sp_adj(<span class="number">0</span>);</span><br><span class="line">                R1 = R1 + <span class="number">1</span>;</span><br><span class="line">                jump %GET_ENTRY(UNTAG(R1)) [R1,R2];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Sp_adj(<span class="number">-2</span>);</span><br><span class="line">                W_[Sp+WDS(<span class="number">1</span>)] = R2;</span><br><span class="line">                <span class="keyword">if</span> (arity &lt; <span class="number">8</span>) &#123;</span><br><span class="line">                  R1 = R1 + arity;</span><br><span class="line">                &#125;</span><br><span class="line">                BUILD_PAP(<span class="number">1</span>,<span class="number">1</span>,stg_ap_p_info,FUN);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            Sp_adj(<span class="number">-2</span>);</span><br><span class="line">            W_[Sp+WDS(<span class="number">1</span>)] = R2;</span><br><span class="line">            jump RET_LBL(stg_ap_p) [];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>手写<code>Cmm</code>可以通过以下方式手动包含在模块中: 首先通过<code>GHC</code>将其编译为对象，然后使用特殊的<code>FFI</code>调用。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include "Cmm.h"</span></span><br><span class="line"></span><br><span class="line"><span class="title">factorial</span> &#123;</span><br><span class="line">  entry:</span><br><span class="line">      <span class="type">W_</span> n  ;</span><br><span class="line">      <span class="type">W_</span> acc;</span><br><span class="line">      n = <span class="type">R1</span> ;</span><br><span class="line">      acc = n ;</span><br><span class="line">      n = n - <span class="number">1</span> ;</span><br><span class="line">    </span><br><span class="line">  for:</span><br><span class="line">      <span class="keyword">if</span> (n &lt;= <span class="number">0</span> ) &#123;</span><br><span class="line">          <span class="type">RET_N</span>(acc);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          acc = acc * n  ;</span><br><span class="line">          n = n - <span class="number">1</span> ;</span><br><span class="line">          goto for ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">RET_N</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">-- ghc -c factorial.cmm -o factorial.o</span></span><br><span class="line"><span class="comment">-- ghc factorial.o Example.hs -o Example</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE MagicHash #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE UnliftedFFITypes #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE GHCForeignImportPrim #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ForeignFunctionInterface #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Main <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.Prim</span><br><span class="line"><span class="keyword">import</span> GHC.Word</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">import</span> prim <span class="string">"factorial"</span> factorial_cmm  :: <span class="type">Word</span># -&gt; <span class="type">Word</span>#</span><br><span class="line"></span><br><span class="line"><span class="title">factorial</span> :: <span class="type">Word64</span> -&gt; <span class="type">Word64</span></span><br><span class="line"><span class="title">factorial</span> (<span class="type">W64</span># n) =  <span class="type">W64</span># (factorial_cmm n)</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = print (factorial <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p>
<p>請看:</p>
<ul>
<li><a href="http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/CmmType" target="_blank" rel="noopener">CmmType</a></li>
<li><a href="https://github.com/ghc/ghc/blob/master/includes/stg/MiscClosures.h" target="_blank" rel="noopener">MiscClosures</a></li>
<li><a href="https://github.com/ghc/ghc/blob/master/compiler/codeGen/StgCmmArgRep.hs" target="_blank" rel="noopener">StgCmmArgRep</a></li>
</ul>
<p><code>Cmm</code>运行时:</p>
<ul>
<li><a href="https://github.com/ghc/ghc/blob/master/rts/Apply.cmm" target="_blank" rel="noopener">Apply.cmm</a></li>
<li><a href="https://github.com/ghc/ghc/blob/master/rts/StgStdThunks.cmm" target="_blank" rel="noopener">StgStdThunks.cmm</a></li>
<li><a href="https://github.com/ghc/ghc/blob/master/rts/StgMiscClosures.cmm" target="_blank" rel="noopener">StgMiscClosures.cmm</a></li>
<li><a href="https://github.com/ghc/ghc/blob/master/rts/PrimOps.cmm" target="_blank" rel="noopener">PrimOps.cmm</a></li>
<li><a href="https://github.com/ghc/ghc/blob/master/rts/Updates.cmm" target="_blank" rel="noopener">Updates.cmm</a></li>
<li><a href="https://gist.github.com/sdiehl/e5c9daab7a6d1da0ede7" target="_blank" rel="noopener">Precompiled Closures(Autogenerated Output)</a>(预编译的闭包(自动生成的输出))</li>
</ul>
<h3 id="Optimization-Hacks-优化技巧"><a href="#Optimization-Hacks-优化技巧" class="headerlink" title="Optimization Hacks (优化技巧)"></a>Optimization Hacks (优化技巧)</h3><h4 id="Tables-Next-to-Code"><a href="#Tables-Next-to-Code" class="headerlink" title="Tables Next to Code"></a>Tables Next to Code</h4><p><code>GHC</code>会将顶级闭包的<code>info table</code>直接放在内存中对象的<code>entry code</code>旁边，这样<code>info table</code>中的字段就可以通过指向代码本身的函数指针上的指针算术来访问。<br>如果不执行此优化，则需要再跟踪一个指针以获取<code>info table</code>。<br>考虑到使用<code>tables-next-to-code</code>访问<code>info table</code>的频率，优化结果会有一个可处理的加速。</p>
<h4 id="Pointer-Tagging"><a href="#Pointer-Tagging" class="headerlink" title="Pointer Tagging"></a>Pointer Tagging</h4><p>根据所涉及的闭包的类型，<code>GHC</code>将利用指向闭包的指针的最后几<code>bits</code>(位)来存储信息，这些信息可以在<code>jumping into</code>(跳入)或<code>access</code>(访问)<code>info tables</code>之前从指针本身的<code>bits</code>(位)中读取。</p>
<p>对于<code>trunk</code>，这可能是诸如是否将其评估为<code>WHNF</code>的信息，对于构造函数，它包含构造函数<code>tag</code>(标记)以避免<code>info tables</code>信息表查找。</p>
<p>根据<code>architecture</code>(体系结构)，<code>tag bits</code>(标记位)是指针的最后2位或3位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 32 bit arch</span></span><br><span class="line">TAG_BITS = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 64-bit arch</span></span><br><span class="line">TAG_BITS = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>在<code>CMM</code>中，通过以下宏定义, 最常出现这些情况:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAG_MASK ((1 &lt;&lt; TAG_BITS) - 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTAG(p) (p &amp; ~TAG_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETTAG(p) (p &amp; TAG_MASK)</span></span><br></pre></td></tr></table></figure></p>
<p>因此，例如，在许多预编译函数中，将测试<code>active closure</code>(活动闭包)<code>r1</code>是否已经求值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (GETTAG(R1)==<span class="number">1</span>) &#123;</span><br><span class="line">    Sp_adj(<span class="number">0</span>);</span><br><span class="line">    jump %GET_ENTRY(R1<span class="number">-1</span>) [R1,R2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Interface-Files"><a href="#Interface-Files" class="headerlink" title="Interface Files"></a>Interface Files</h3><p>在编译过程中，<code>GHC</code>将为每个模块生成接口文件，这些文件是该模块导出的特定符号(函数，类型类等)的二进制编码，以及它本身依赖的任何程序包依赖项。这实际上是编译器内部使用的<code>ModGuts</code>结构的序列化形式。可以使用<code>--show-iface</code>标志来转储该文件的内部结构。<code>GHC</code>版本之间的精确结构有所不同。</p>
<h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><p>請看:</p>
<ul>
<li><a href="https://takenobu-hs.github.io/downloads/haskell_ghc_illustrated.pdf" target="_blank" rel="noopener">GHC Illustrated</a></li>
<li><a href="http://www.stephendiehl.com/posts/ghc_01.html" target="_blank" rel="noopener">Dive into GHC: Pipeline</a></li>
<li><a href="http://www.stephendiehl.com/posts/ghc_02.html" target="_blank" rel="noopener">Dive into GHC: Intermediate Forms</a></li>
<li><a href="http://www.stephendiehl.com/posts/ghc_03.html" target="_blank" rel="noopener">Dive into GHC: Targeting Core</a></li>
</ul>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> thank you </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
        <span><a href="https://serokell.io/blog">serokell</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/blog/js/index.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/blog/js/gitment.js"></script>
<script>
    var gitment = new Gitment({
        id: 'Haskell-GHC',
        owner: 'limengyu1990',
        repo: 'hexo-blog',
        oauth: {
            client_id: '7cfc73dd62b57f07ed83',
            client_secret: 'dd03b7e54aadf0d81e4c9c93e23a41272bcfcfa1',
        },
    })
    gitment.render('comment-container')
</script>

</html>
