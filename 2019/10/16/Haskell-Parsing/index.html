<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        Haskell-Parsing - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 不会Haskell的Scala写不出好的JavaScript。 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>不负如来不负卿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Parsec"><span class="toc-text">Parsec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Custom-Lexer-自定义词法分析器"><span class="toc-text">Custom Lexer (自定义词法分析器)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Simple-Parsing"><span class="toc-text">Simple Parsing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generic-Parsing"><span class="toc-text">Generic Parsing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Attoparsec"><span class="toc-text">Attoparsec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Optparse-Applicative"><span class="toc-text">Optparse Applicative</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Happy-amp-Alex"><span class="toc-text">Happy &amp; Alex</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Lexer"><span class="toc-text">Lexer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parser"><span class="toc-text">Parser</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Configurator-配置器"><span class="toc-text">Configurator (配置器)</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 不会Haskell的Scala写不出好的JavaScript。 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Haskell-Parsing
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-10-16 19:24:58</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/blog/tags/#Wish-Knew" title="Wish-Knew">Wish-Knew</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Haskell" title="Haskell">Haskell</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Parsing" title="Parsing">Parsing</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p><a href="http://dev.stephendiehl.com/hask/#parsing" target="_blank" rel="noopener">原文</a></p>
</blockquote>
<h3 id="Parsec"><a href="#Parsec" class="headerlink" title="Parsec"></a>Parsec</h3><p>对于在<code>Haskell</code>进行解析，使用称为<code>Parser Combinators</code>的库家族是很常见的，该库使我们可以编写代码来生成解析器，它们本身看起来与解析器语法本身非常相似！<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	     <span class="type">Combinators</span></span><br><span class="line"><span class="comment">---------------------------</span></span><br><span class="line">&lt;|&gt;	     选择运算符在继续处理第二个参数之前尝试分析第一个参数。它可以按顺序链接以生成一系列选项。</span><br><span class="line"><span class="title">many</span>	 消耗与给定模式匹配的任意数量的模式，并将它们作为列表返回。</span><br><span class="line"><span class="title">many1</span>	 与many一样，但至少需要一个匹配。</span><br><span class="line"><span class="title">optional</span> 可选地解析给定的模式，返回其值作为<span class="type">Maybe</span>。</span><br><span class="line"><span class="title">try</span>	     回溯运算符将允许我们解析不明确的匹配表达式，并使用不同的模式重新启动。</span><br></pre></td></tr></table></figure></p>
<p><code>Parsec</code>有两种编写风格，一种可以选择使用<code>monad</code>编写，另一种可以选择使用<code>applicatives</code>编写。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">parseM</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">parseM</span> = <span class="keyword">do</span></span><br><span class="line">  a &lt;- identifier</span><br><span class="line">  char '+'</span><br><span class="line">  b &lt;- identifier</span><br><span class="line">  return $ <span class="type">Add</span> a b</span><br></pre></td></tr></table></figure></p>
<p>使用<code>applicatives</code>编写的相同代码，使用<code>applicative combinator</code>:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- | Sequential application.</span></span><br><span class="line">(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line"></span><br><span class="line"><span class="comment">-- | Sequence actions, discarding the value of the first argument.</span></span><br><span class="line">(*&gt;) :: f a -&gt; f b -&gt; f b</span><br><span class="line">(*&gt;) = liftA2 (const id)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- | Sequence actions, discarding the value of the second argument.</span></span><br><span class="line">(&lt;*) :: f a -&gt; f b -&gt; f a</span><br><span class="line">(&lt;*) = liftA2 const</span><br><span class="line"><span class="title">parseA</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">parseA</span> = <span class="type">Add</span> &lt;$&gt; identifier &lt;* char '+' &lt;*&gt; identifier</span><br></pre></td></tr></table></figure></p>
<p>现在，例如，如果我们想解析简单的<code>lambda</code>表达式，我们可以将解析器逻辑编码为这些组合器的组合，当使用<code>parse</code>进行评估时，这些组合器将产生<code>string parser</code>(字符串解析器)。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Text.Parsec</span><br><span class="line"><span class="keyword">import</span> Text.Parsec.String</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span></span></span><br><span class="line">  = <span class="type">Var</span> <span class="type">Char</span></span><br><span class="line">  | <span class="type">Lam</span> <span class="type">Char</span> <span class="type">Expr</span></span><br><span class="line">  | <span class="type">App</span> <span class="type">Expr</span> <span class="type">Expr</span></span><br><span class="line">  <span class="keyword">deriving</span> <span class="type">Show</span></span><br><span class="line"></span><br><span class="line"><span class="title">lam</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">lam</span> = <span class="keyword">do</span></span><br><span class="line">  char '\\'</span><br><span class="line">  n &lt;- letter</span><br><span class="line">  string <span class="string">"-&gt;"</span></span><br><span class="line">  e &lt;- expr</span><br><span class="line">  return $ <span class="type">Lam</span> n e</span><br><span class="line"></span><br><span class="line"><span class="title">app</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">app</span> = <span class="keyword">do</span></span><br><span class="line">  apps &lt;- many1 term</span><br><span class="line">  return $ foldl1 <span class="type">App</span> apps</span><br><span class="line"></span><br><span class="line"><span class="title">var</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">var</span> = <span class="keyword">do</span></span><br><span class="line">  n &lt;- letter</span><br><span class="line">  return $ <span class="type">Var</span> n</span><br><span class="line"></span><br><span class="line"><span class="title">parens</span> :: <span class="type">Parser</span> <span class="type">Expr</span> -&gt; <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">parens</span> p = <span class="keyword">do</span></span><br><span class="line">  char '('</span><br><span class="line">  e &lt;- p</span><br><span class="line">  char ')'</span><br><span class="line">  return e</span><br><span class="line"></span><br><span class="line"><span class="title">term</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">term</span> = var &lt;|&gt; parens expr</span><br><span class="line"></span><br><span class="line"><span class="title">expr</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">expr</span> = lam &lt;|&gt; app</span><br><span class="line"></span><br><span class="line"><span class="title">decl</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">decl</span> = <span class="keyword">do</span></span><br><span class="line">  e &lt;- expr</span><br><span class="line">  eof</span><br><span class="line">  return e</span><br><span class="line"></span><br><span class="line"><span class="title">test</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">test</span> = parseTest decl <span class="string">"\\y-&gt;y(\\x-&gt;x)y"</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = test &gt;&gt;= print</span><br></pre></td></tr></table></figure></p>
<h3 id="Custom-Lexer-自定义词法分析器"><a href="#Custom-Lexer-自定义词法分析器" class="headerlink" title="Custom Lexer (自定义词法分析器)"></a>Custom Lexer (自定义词法分析器)</h3><p>在我们之前的示例中，无需进行<code>lexing pass</code>(词法遍历)，因为每个<code>lexeme</code>(词素)都映射到流类型中字符的顺序集合。如果我们想用一组<code>non-trivial</code>(不重要)的<code>tokens</code>(令牌/标记)集合来扩展此解析器，则<code>Parsec</code>为我们提供了一组函数，用于定义词法分析器并将其与<code>parser combinators</code>(解析器组合器)集成在一起。<br>最简单的示例建立在内置的<code>Parsec</code>语言定义之上，该定义定义了一组最常见的词汇方案。</p>
<p>例如，我们将在使用<code>Text token</code>(标记)而不是字符串的<code>haskellDef</code>语法之上构建<code>empty</code>(空)语言语法。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE OverloadedStrings #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Text.Parsec</span><br><span class="line"><span class="keyword">import</span> Text.Parsec.Text</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Text.Parsec.Token <span class="keyword">as</span> Tok</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Text.Parsec.Language <span class="keyword">as</span> Lang</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Functor.Identity (<span class="type">Identity</span>)</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Text <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Text.IO <span class="keyword">as</span> TIO</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span></span></span><br><span class="line">  = <span class="type">Var</span> <span class="type">T</span>.<span class="type">Text</span></span><br><span class="line">  | <span class="type">App</span> <span class="type">Expr</span> <span class="type">Expr</span></span><br><span class="line">  | <span class="type">Lam</span> <span class="type">T</span>.<span class="type">Text</span> <span class="type">Expr</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">lexer</span> :: <span class="type">Tok</span>.<span class="type">GenTokenParser</span> <span class="type">T</span>.<span class="type">Text</span> () <span class="type">Identity</span></span><br><span class="line"><span class="title">lexer</span> = <span class="type">Tok</span>.makeTokenParser style</span><br><span class="line"></span><br><span class="line"><span class="title">style</span> :: <span class="type">Tok</span>.<span class="type">GenLanguageDef</span> <span class="type">T</span>.<span class="type">Text</span> () <span class="type">Identity</span></span><br><span class="line"><span class="title">style</span> = <span class="type">Lang</span>.emptyDef</span><br><span class="line">  &#123; <span class="type">Tok</span>.commentStart    = <span class="string">"&#123;-"</span></span><br><span class="line">  , <span class="type">Tok</span>.commentEnd      = <span class="string">"-&#125;"</span></span><br><span class="line">  , <span class="type">Tok</span>.commentLine     = <span class="string">"--"</span></span><br><span class="line">  , <span class="type">Tok</span>.nestedComments  = <span class="type">True</span></span><br><span class="line">  , <span class="type">Tok</span>.identStart      = letter</span><br><span class="line">  , <span class="type">Tok</span>.identLetter     = alphaNum &lt;|&gt; oneOf <span class="string">"_'"</span></span><br><span class="line">  , <span class="type">Tok</span>.opStart         = <span class="type">Tok</span>.opLetter style</span><br><span class="line">  , <span class="type">Tok</span>.opLetter        = oneOf <span class="string">":!#$%&amp;*+./&lt;=&gt;?@\\^|-~"</span></span><br><span class="line">  , <span class="type">Tok</span>.reservedOpNames = []</span><br><span class="line">  , <span class="type">Tok</span>.reservedNames   = []</span><br><span class="line">  , <span class="type">Tok</span>.caseSensitive   = <span class="type">True</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="title">parens</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> a</span><br><span class="line"><span class="title">parens</span> = <span class="type">Tok</span>.parens lexer</span><br><span class="line"></span><br><span class="line"><span class="title">reservedOp</span> :: <span class="type">T</span>.<span class="type">Text</span> -&gt; <span class="type">Parser</span> ()</span><br><span class="line"><span class="title">reservedOp</span> op = <span class="type">Tok</span>.reservedOp lexer (<span class="type">T</span>.unpack op)</span><br><span class="line"></span><br><span class="line"><span class="title">ident</span> :: <span class="type">Parser</span> <span class="type">T</span>.<span class="type">Text</span></span><br><span class="line"><span class="title">ident</span> = <span class="type">T</span>.pack &lt;$&gt; <span class="type">Tok</span>.identifier lexer</span><br><span class="line"></span><br><span class="line"><span class="title">contents</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> a</span><br><span class="line"><span class="title">contents</span> p = <span class="keyword">do</span></span><br><span class="line">  <span class="type">Tok</span>.whiteSpace lexer</span><br><span class="line">  r &lt;- p</span><br><span class="line">  eof</span><br><span class="line">  return r</span><br><span class="line"></span><br><span class="line"><span class="title">var</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">var</span> = <span class="keyword">do</span></span><br><span class="line">  var &lt;- ident</span><br><span class="line">  return (<span class="type">Var</span> var )</span><br><span class="line"></span><br><span class="line"><span class="title">app</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">app</span> = <span class="keyword">do</span></span><br><span class="line">  e1 &lt;- expr</span><br><span class="line">  e2 &lt;- expr</span><br><span class="line">  return (<span class="type">App</span> e1 e2)</span><br><span class="line"></span><br><span class="line"><span class="title">fun</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">fun</span> = <span class="keyword">do</span></span><br><span class="line">  reservedOp <span class="string">"\\"</span></span><br><span class="line">  binder &lt;- ident</span><br><span class="line">  reservedOp <span class="string">"."</span></span><br><span class="line">  rhs &lt;- expr</span><br><span class="line">  return (<span class="type">Lam</span> binder rhs)</span><br><span class="line"></span><br><span class="line"><span class="title">expr</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">expr</span> = <span class="keyword">do</span></span><br><span class="line">  es &lt;- many1 aexp</span><br><span class="line">  return (foldl1 <span class="type">App</span> es)</span><br><span class="line"></span><br><span class="line"><span class="title">aexp</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">aexp</span> = fun &lt;|&gt; var &lt;|&gt; (parens expr)</span><br><span class="line"></span><br><span class="line"><span class="title">test</span> :: <span class="type">T</span>.<span class="type">Text</span> -&gt; <span class="type">Either</span> <span class="type">ParseError</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">test</span> = parse (contents expr) <span class="string">"&lt;stdin&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="title">repl</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">repl</span> = <span class="keyword">do</span></span><br><span class="line">  str &lt;- <span class="type">TIO</span>.getLine</span><br><span class="line">  print (test str)</span><br><span class="line">  repl</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = repl</span><br></pre></td></tr></table></figure></p>
<p>請看:</p>
<ul>
<li><a href="https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Language.html" target="_blank" rel="noopener">Text.Parsec.Language</a></li>
</ul>
<h3 id="Simple-Parsing"><a href="#Simple-Parsing" class="headerlink" title="Simple Parsing"></a>Simple Parsing</h3><p>将我们的词法分析器和解析器放在一起，我们可以为我们的小<code>λ</code>演算语法编写一个更强大的解析器。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Parser (<span class="title">parseExpr</span>) <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Text.Parsec</span><br><span class="line"><span class="keyword">import</span> Text.Parsec.String (<span class="type">Parser</span>)</span><br><span class="line"><span class="keyword">import</span> Text.Parsec.Language (<span class="title">haskellStyle</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Text.Parsec.Expr <span class="keyword">as</span> Ex</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Text.Parsec.Token <span class="keyword">as</span> Tok</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Id</span> = <span class="type">String</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span></span></span><br><span class="line">  = <span class="type">Lam</span> <span class="type">Id</span> <span class="type">Expr</span></span><br><span class="line">  | <span class="type">App</span> <span class="type">Expr</span> <span class="type">Expr</span></span><br><span class="line">  | <span class="type">Var</span> <span class="type">Id</span></span><br><span class="line">  | <span class="type">Num</span> <span class="type">Int</span></span><br><span class="line">  | <span class="type">Op</span>  <span class="type">Binop</span> <span class="type">Expr</span> <span class="type">Expr</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Binop</span> = <span class="type">Add</span> | <span class="type">Sub</span> | <span class="type">Mul</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">lexer</span> :: <span class="type">Tok</span>.<span class="type">TokenParser</span> ()</span><br><span class="line"><span class="title">lexer</span> = <span class="type">Tok</span>.makeTokenParser style</span><br><span class="line">  <span class="keyword">where</span> ops = [<span class="string">"-&gt;"</span>,<span class="string">"\\"</span>,<span class="string">"+"</span>,<span class="string">"*"</span>,<span class="string">"-"</span>,<span class="string">"="</span>]</span><br><span class="line">        style = haskellStyle &#123;<span class="type">Tok</span>.reservedOpNames = ops &#125;</span><br><span class="line"></span><br><span class="line"><span class="title">reservedOp</span> :: <span class="type">String</span> -&gt; <span class="type">Parser</span> ()</span><br><span class="line"><span class="title">reservedOp</span> = <span class="type">Tok</span>.reservedOp lexer</span><br><span class="line"></span><br><span class="line"><span class="title">identifier</span> :: <span class="type">Parser</span> <span class="type">String</span></span><br><span class="line"><span class="title">identifier</span> = <span class="type">Tok</span>.identifier lexer</span><br><span class="line"></span><br><span class="line"><span class="title">parens</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> a</span><br><span class="line"><span class="title">parens</span> = <span class="type">Tok</span>.parens lexer</span><br><span class="line"></span><br><span class="line"><span class="title">contents</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> a</span><br><span class="line"><span class="title">contents</span> p = <span class="keyword">do</span></span><br><span class="line">  <span class="type">Tok</span>.whiteSpace lexer</span><br><span class="line">  r &lt;- p</span><br><span class="line">  eof</span><br><span class="line">  return r</span><br><span class="line"></span><br><span class="line"><span class="title">natural</span> :: <span class="type">Parser</span> <span class="type">Integer</span></span><br><span class="line"><span class="title">natural</span> = <span class="type">Tok</span>.natural lexer</span><br><span class="line"></span><br><span class="line"><span class="title">variable</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">variable</span> = <span class="keyword">do</span></span><br><span class="line">  x &lt;- identifier</span><br><span class="line">  return (<span class="type">Var</span> x)</span><br><span class="line"></span><br><span class="line"><span class="title">number</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">number</span> = <span class="keyword">do</span></span><br><span class="line">  n &lt;- natural</span><br><span class="line">  return (<span class="type">Num</span> (fromIntegral n))</span><br><span class="line"></span><br><span class="line"><span class="title">lambda</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">lambda</span> = <span class="keyword">do</span></span><br><span class="line">  reservedOp <span class="string">"\\"</span></span><br><span class="line">  x &lt;- identifier</span><br><span class="line">  reservedOp <span class="string">"-&gt;"</span></span><br><span class="line">  e &lt;- expr</span><br><span class="line">  return (<span class="type">Lam</span> x e)</span><br><span class="line"></span><br><span class="line"><span class="title">aexp</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">aexp</span> =  parens expr</span><br><span class="line">    &lt;|&gt; variable</span><br><span class="line">    &lt;|&gt; number</span><br><span class="line">    &lt;|&gt; lambda</span><br><span class="line"></span><br><span class="line"><span class="title">term</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">term</span> = <span class="type">Ex</span>.buildExpressionParser table aexp</span><br><span class="line">  <span class="keyword">where</span> infixOp x f = <span class="type">Ex</span>.<span class="type">Infix</span> (reservedOp x &gt;&gt; return f)</span><br><span class="line">        table = [[infixOp <span class="string">"*"</span> (<span class="type">Op</span> <span class="type">Mul</span>) <span class="type">Ex</span>.<span class="type">AssocLeft</span>],</span><br><span class="line">                 [infixOp <span class="string">"+"</span> (<span class="type">Op</span> <span class="type">Add</span>) <span class="type">Ex</span>.<span class="type">AssocLeft</span>]]</span><br><span class="line"></span><br><span class="line"><span class="title">expr</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">expr</span> = <span class="keyword">do</span></span><br><span class="line">  es &lt;- many1 term</span><br><span class="line">  return (foldl1 <span class="type">App</span> es)</span><br><span class="line"></span><br><span class="line"><span class="title">parseExpr</span> :: <span class="type">String</span> -&gt; <span class="type">Expr</span></span><br><span class="line"><span class="title">parseExpr</span> input =</span><br><span class="line">  <span class="keyword">case</span> parse (contents expr) <span class="string">"&lt;stdin&gt;"</span> input <span class="keyword">of</span></span><br><span class="line">    <span class="type">Left</span> err -&gt; error (show err)</span><br><span class="line">    <span class="type">Right</span> ast -&gt; ast</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = getLine &gt;&gt;= print . parseExpr &gt;&gt; main</span><br></pre></td></tr></table></figure></p>
<p>尝试一下:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">λ: runhaskell simpleparser.hs</span><br><span class="line"><span class="number">1</span>+<span class="number">2</span></span><br><span class="line"><span class="type">Op</span> <span class="type">Add</span> (<span class="type">Num</span> <span class="number">1</span>) (<span class="type">Num</span> <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">\i -&gt; \x -&gt; x</span><br><span class="line"><span class="type">Lam</span> <span class="string">"i"</span> (<span class="type">Lam</span> <span class="string">"x"</span> (<span class="type">Var</span> <span class="string">"x"</span>))</span><br><span class="line"></span><br><span class="line">\s -&gt; \f -&gt; \g -&gt; \x -&gt; f x (g x)</span><br><span class="line"><span class="type">Lam</span> <span class="string">"s"</span> (<span class="type">Lam</span> <span class="string">"f"</span> (<span class="type">Lam</span> <span class="string">"g"</span> (<span class="type">Lam</span> <span class="string">"x"</span> (<span class="type">App</span> (<span class="type">App</span> (<span class="type">Var</span> <span class="string">"f"</span>) (<span class="type">Var</span> <span class="string">"x"</span>)) (<span class="type">App</span> (<span class="type">Var</span> <span class="string">"g"</span>) (<span class="type">Var</span> <span class="string">"x"</span>))))))</span><br></pre></td></tr></table></figure></p>
<h3 id="Generic-Parsing"><a href="#Generic-Parsing" class="headerlink" title="Generic Parsing"></a>Generic Parsing</h3><p>以前，我们为漂亮的打印定义了<code>generic</code>(通用/泛型)运算，这引出了我们是否可以在<code>Generics</code>(通用/泛型)之上编写解析器的问题。<br>答案是肯定的，只要特定<code>lexemes</code>(词素)与<code>sum</code>和<code>products</code>类型之间存在直接映射即可。<br>考虑最简单的情况，我们只是使用<code>regular</code>(常规)泛型机制读取构造函数的名称，然后为其构建一个<code>Parsec</code>解析器<code>terms</code>(术语)。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DeriveGeneric #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE OverloadedStrings #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleInstances #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleContexts #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ScopedTypeVariables #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Text.Parsec</span><br><span class="line"><span class="keyword">import</span> Text.Parsec.Text.Lazy</span><br><span class="line"><span class="keyword">import</span> Control.Applicative ((&lt;*), (&lt;*&gt;), (&lt;$&gt;))</span><br><span class="line"><span class="keyword">import</span> GHC.Generics</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">GParse</span> f <span class="keyword">where</span></span></span><br><span class="line">  gParse :: <span class="type">Parser</span> (f a)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Type synonym metadata for constructors</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">GParse</span> <span class="title">f</span>, <span class="type">Constructor</span> <span class="title">c</span>) =&gt; <span class="type">GParse</span> (<span class="type">C1</span> <span class="title">c</span> <span class="title">f</span>) <span class="keyword">where</span></span></span><br><span class="line">  gParse =</span><br><span class="line">    <span class="keyword">let</span> con = conName (undefined :: t c f a) <span class="keyword">in</span></span><br><span class="line">    (fmap <span class="type">M1</span> gParse) &lt;* string con</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Constructor names</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">GParse</span> f =&gt; <span class="type">GParse</span> (<span class="type">D1</span> <span class="title">c</span> <span class="title">f</span>) <span class="keyword">where</span></span></span><br><span class="line">  gParse = fmap <span class="type">M1</span> gParse</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Sum types</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">GParse</span> <span class="title">a</span>, <span class="type">GParse</span> <span class="title">b</span>) =&gt; <span class="type">GParse</span> (<span class="title">a</span> :+: <span class="title">b</span>) <span class="keyword">where</span></span></span><br><span class="line">  gParse = try (fmap <span class="type">L1</span> gParse &lt;|&gt; fmap <span class="type">R1</span> gParse)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Product types</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">GParse</span> <span class="title">f</span>, <span class="type">GParse</span> <span class="title">g</span>) =&gt; <span class="type">GParse</span> (<span class="title">f</span> :*: <span class="title">g</span>) <span class="keyword">where</span></span></span><br><span class="line">  gParse = (:*:) &lt;$&gt; gParse &lt;*&gt; gParse</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Nullary constructors</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">GParse</span> <span class="type">U1</span> <span class="keyword">where</span></span></span><br><span class="line">  gParse = return <span class="type">U1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Scientist</span></span></span><br><span class="line">  = <span class="type">Newton</span></span><br><span class="line">  | <span class="type">Einstein</span></span><br><span class="line">  | <span class="type">Schrodinger</span></span><br><span class="line">  | <span class="type">Feynman</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Generic</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Musician</span></span></span><br><span class="line">  = <span class="type">Vivaldi</span></span><br><span class="line">  | <span class="type">Bach</span></span><br><span class="line">  | <span class="type">Mozart</span></span><br><span class="line">  | <span class="type">Beethoven</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Generic</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">gparse</span> :: (<span class="type">Generic</span> g, <span class="type">GParse</span> (<span class="type">Rep</span> g)) =&gt; <span class="type">Parser</span> g</span><br><span class="line"><span class="title">gparse</span> = fmap to gParse</span><br><span class="line"></span><br><span class="line"><span class="title">scientist</span> :: <span class="type">Parser</span> <span class="type">Scientist</span></span><br><span class="line"><span class="title">scientist</span> = gparse</span><br><span class="line"></span><br><span class="line"><span class="title">musician</span> :: <span class="type">Parser</span> <span class="type">Musician</span></span><br><span class="line"><span class="title">musician</span> = gparse</span><br><span class="line">λ: parseTest parseMusician <span class="string">"Bach"</span></span><br><span class="line"><span class="type">Bach</span></span><br><span class="line"></span><br><span class="line">λ: parseTest parseScientist <span class="string">"Feynman"</span></span><br><span class="line"><span class="type">Feynman</span></span><br></pre></td></tr></table></figure></p>
<p>通过更多的工作和外部包装，可以轻松扩展此示例以自动解析简单的递归类型。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DeriveGeneric #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE OverloadedStrings #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleInstances #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleContexts #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ScopedTypeVariables #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DeriveAnyClass #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DefaultSignatures #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Control.Applicative    ((&lt;*), (*&gt;), (&lt;*&gt;), (&lt;$&gt;), pure)</span><br><span class="line"><span class="keyword">import</span> GHC.Generics</span><br><span class="line"><span class="keyword">import</span> Text.Parsec            ((&lt;|&gt;), string, try, many1, digit, char, letter, spaces)</span><br><span class="line"><span class="keyword">import</span> Text.Parsec.Text.Lazy  (<span class="type">Parser</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">GParse</span> f <span class="keyword">where</span></span></span><br><span class="line">  gParse :: <span class="type">Parser</span> (f a)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Types</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Parse</span> <span class="title">a</span>) =&gt; <span class="type">GParse</span> (<span class="type">K1</span> <span class="type">R</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">  gParse = fmap <span class="type">K1</span> parse</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Selector names</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">GParse</span> <span class="title">f</span>, <span class="type">Selector</span> <span class="title">s</span>) =&gt; <span class="type">GParse</span> (<span class="type">M1</span> <span class="type">S</span> <span class="title">s</span> <span class="title">f</span>) <span class="keyword">where</span></span></span><br><span class="line">  gParse = fmap <span class="type">M1</span> gParse</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Type synonym metadata for constructors</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">GParse</span> <span class="title">f</span>, <span class="type">Constructor</span> <span class="title">c</span>) =&gt; <span class="type">GParse</span> (<span class="type">C1</span> <span class="title">c</span> <span class="title">f</span>) <span class="keyword">where</span></span></span><br><span class="line">  gParse =</span><br><span class="line">    <span class="keyword">let</span> con = conName (undefined :: t c f a) <span class="keyword">in</span></span><br><span class="line">      (spaces &gt;&gt; string con &gt;&gt; spaces) *&gt; fmap <span class="type">M1</span> gParse</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Constructor names</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Datatype</span> <span class="title">d</span>, <span class="type">GParse</span> <span class="title">f</span>) =&gt; <span class="type">GParse</span> (<span class="type">D1</span> <span class="title">d</span> <span class="title">f</span>) <span class="keyword">where</span></span></span><br><span class="line">  gParse = fmap <span class="type">M1</span> gParse</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Sum types</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">GParse</span> <span class="title">a</span>, <span class="type">GParse</span> <span class="title">b</span>) =&gt; <span class="type">GParse</span> (<span class="title">a</span> :+: <span class="title">b</span>) <span class="keyword">where</span></span></span><br><span class="line">  gParse = try (fmap <span class="type">L1</span> gParse) &lt;|&gt; try (fmap <span class="type">R1</span> gParse)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Product types</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">GParse</span> <span class="title">f</span>, <span class="type">GParse</span> <span class="title">g</span>) =&gt; <span class="type">GParse</span> (<span class="title">f</span> :*: <span class="title">g</span>) <span class="keyword">where</span></span></span><br><span class="line">  gParse = (:*:) &lt;$&gt; try gParse &lt;*&gt; try gParse</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Nullary constructors</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">GParse</span> <span class="type">U1</span> <span class="keyword">where</span></span></span><br><span class="line">  gParse = return <span class="type">U1</span></span><br><span class="line"></span><br><span class="line"><span class="title">gparse</span> :: (<span class="type">Generic</span> g, <span class="type">GParse</span> (<span class="type">Rep</span> g)) =&gt; <span class="type">Parser</span> g</span><br><span class="line"><span class="title">gparse</span> = fmap to gParse</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Parse</span> a <span class="keyword">where</span></span></span><br><span class="line">  parse :: <span class="type">Parser</span> a</span><br><span class="line">  <span class="keyword">default</span> parse :: (<span class="type">Generic</span> <span class="title">a</span>, <span class="type">GParse</span> (<span class="type">Rep</span> <span class="title">a</span>)) =&gt; <span class="type">Parser</span> a</span><br><span class="line">  parse = spaces &gt;&gt; char '(' &gt;&gt; gparse &gt;&gt;= \e -&gt; char ')' &gt;&gt; return e</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Parse</span> <span class="type">Integer</span> <span class="keyword">where</span></span></span><br><span class="line">  parse = rd &lt;$&gt; (plus &lt;|&gt; minus &lt;|&gt; number)</span><br><span class="line">    <span class="keyword">where</span> rd     = read :: <span class="type">String</span> -&gt; <span class="type">Integer</span></span><br><span class="line">          plus   = char '+' *&gt; number</span><br><span class="line">          minus  = (:) &lt;$&gt; char '-' &lt;*&gt; number</span><br><span class="line">          number = many1 digit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Parse</span> <span class="type">String</span> <span class="keyword">where</span></span></span><br><span class="line">   parse = many1 letter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Name</span> = <span class="type">String</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Exp</span> </span></span><br><span class="line">  = <span class="type">Lit</span> <span class="type">Integer</span></span><br><span class="line">  | <span class="type">Var</span> <span class="type">Name</span></span><br><span class="line">  | <span class="type">Plus</span> <span class="type">Exp</span> <span class="type">Exp</span> </span><br><span class="line">  | <span class="type">App</span> <span class="type">Exp</span> <span class="type">Exp</span> </span><br><span class="line">  | <span class="type">Abs</span> <span class="type">Name</span> <span class="type">Exp</span> <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Generic</span>, <span class="type">Parse</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">expr</span> :: <span class="type">Parser</span> <span class="type">Exp</span></span><br><span class="line"><span class="title">expr</span> = parse</span><br><span class="line">λ: parseTest expr <span class="string">"(App (Plus (Lit 1) (Var n)) (App (Plus (Lit 5) (Lit 5)) (Plus (Lit 6) (Lit 6))))"</span></span><br><span class="line"><span class="type">App</span> (<span class="type">Plus</span> (<span class="type">Lit</span> <span class="number">1</span>) (<span class="type">Var</span> <span class="string">"n"</span>)) (<span class="type">App</span> (<span class="type">Plus</span> (<span class="type">Lit</span> <span class="number">5</span>) (<span class="type">Lit</span> <span class="number">5</span>)) (<span class="type">Plus</span> (<span class="type">Lit</span> <span class="number">6</span>) (<span class="type">Lit</span> <span class="number">6</span>)))</span><br></pre></td></tr></table></figure></p>
<h3 id="Attoparsec"><a href="#Attoparsec" class="headerlink" title="Attoparsec"></a>Attoparsec</h3><p><code>Attoparsec</code>是类似于<code>Parsec</code>的解析器组合器，但更适合于大文本和二进制文件的批量解析，而不是将语言语法解析为<code>AST</code>。正确编写后，<code>Attoparsec</code>解析器可能会<a href="http://www.serpentine.com/blog/2014/05/31/attoparsec/" target="_blank" rel="noopener">efficient</a>。</p>
<p><code>Parsec</code>和<code>Attoparsec</code>之间的显着区别是不存在回溯运算符<code>(try)</code>，而是反映在<code>attoparsec</code>的不同底层解析器模型上。</p>
<p>对于简单的小<code>λ</code>演算语言，我们可以像使用<code>parsec</code>一样使用<code>attoparsec</code>:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE OverloadedStrings #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# OPTIONS_GHC -fno-warn-unused-do-bind #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Control.Applicative</span><br><span class="line"><span class="keyword">import</span> Data.Attoparsec.Text</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Text <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Text.IO <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">import</span> Data.List (<span class="title">foldl1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Name</span></span></span><br><span class="line">  = <span class="type">Gen</span> <span class="type">Int</span></span><br><span class="line">  | <span class="type">Name</span> <span class="type">T</span>.<span class="type">Text</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>, <span class="type">Ord</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span></span></span><br><span class="line">  = <span class="type">Var</span> <span class="type">Name</span></span><br><span class="line">  | <span class="type">App</span> <span class="type">Expr</span> <span class="type">Expr</span></span><br><span class="line">  | <span class="type">Lam</span> [<span class="type">Name</span>] <span class="type">Expr</span></span><br><span class="line">  | <span class="type">Lit</span> <span class="type">Int</span></span><br><span class="line">  | <span class="type">Prim</span> <span class="type">PrimOp</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">PrimOp</span></span></span><br><span class="line">  = <span class="type">Add</span></span><br><span class="line">  | <span class="type">Sub</span></span><br><span class="line">  | <span class="type">Mul</span></span><br><span class="line">  | <span class="type">Div</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Defn</span> = <span class="type">Defn</span> <span class="type">Name</span> <span class="type">Expr</span></span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">name</span> :: <span class="type">Parser</span> <span class="type">Name</span></span><br><span class="line"><span class="title">name</span> = <span class="type">Name</span> . <span class="type">T</span>.pack &lt;$&gt; many1 letter</span><br><span class="line"></span><br><span class="line"><span class="title">num</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">num</span> = <span class="type">Lit</span> &lt;$&gt; signed decimal</span><br><span class="line"></span><br><span class="line"><span class="title">var</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">var</span> = <span class="type">Var</span> &lt;$&gt; name</span><br><span class="line"></span><br><span class="line"><span class="title">lam</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">lam</span> = <span class="keyword">do</span></span><br><span class="line">  string <span class="string">"\\"</span></span><br><span class="line">  vars &lt;- many1 (skipSpace *&gt; name)</span><br><span class="line">  skipSpace *&gt; string <span class="string">"-&gt;"</span></span><br><span class="line">  body &lt;- expr</span><br><span class="line">  return (<span class="type">Lam</span> vars body)</span><br><span class="line"></span><br><span class="line"><span class="title">eparen</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">eparen</span> = char '(' *&gt; expr &lt;* skipSpace &lt;* char ')'</span><br><span class="line"></span><br><span class="line"><span class="title">prim</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">prim</span> = <span class="type">Prim</span> &lt;$&gt; (</span><br><span class="line">      char '+' *&gt; return <span class="type">Add</span></span><br><span class="line">  &lt;|&gt; char '-' *&gt; return <span class="type">Sub</span></span><br><span class="line">  &lt;|&gt; char '*' *&gt; return <span class="type">Mul</span></span><br><span class="line">  &lt;|&gt; char '/' *&gt; return <span class="type">Div</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">expr</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">expr</span> = foldl1' <span class="type">App</span> &lt;$&gt; many1 (skipSpace *&gt; atom)</span><br><span class="line"></span><br><span class="line"><span class="title">atom</span> :: <span class="type">Parser</span> <span class="type">Expr</span></span><br><span class="line"><span class="title">atom</span> = try lam</span><br><span class="line">    &lt;|&gt; eparen</span><br><span class="line">    &lt;|&gt; prim</span><br><span class="line">    &lt;|&gt; var</span><br><span class="line">    &lt;|&gt; num</span><br><span class="line"></span><br><span class="line"><span class="title">def</span> :: <span class="type">Parser</span> <span class="type">Defn</span></span><br><span class="line"><span class="title">def</span> = <span class="keyword">do</span></span><br><span class="line">  skipSpace</span><br><span class="line">  nm &lt;- name</span><br><span class="line">  skipSpace *&gt; char '=' *&gt; skipSpace</span><br><span class="line">  ex &lt;- expr</span><br><span class="line">  skipSpace &lt;* char ';'</span><br><span class="line">  return $ <span class="type">Defn</span> nm ex</span><br><span class="line"></span><br><span class="line"><span class="title">file</span> :: <span class="type">T</span>.<span class="type">Text</span> -&gt; <span class="type">Either</span> <span class="type">String</span> [<span class="type">Defn</span>]</span><br><span class="line"><span class="title">file</span> = parseOnly (many def &lt;* skipSpace)</span><br><span class="line"></span><br><span class="line"><span class="title">parseFile</span> :: <span class="type">FilePath</span> -&gt; <span class="type">IO</span> (<span class="type">Either</span> <span class="type">T</span>.<span class="type">Text</span> [<span class="type">Defn</span>])</span><br><span class="line"><span class="title">parseFile</span> path = <span class="keyword">do</span></span><br><span class="line">  contents &lt;- <span class="type">T</span>.readFile path</span><br><span class="line">  <span class="keyword">case</span> file contents <span class="keyword">of</span></span><br><span class="line">    <span class="type">Left</span> a -&gt; return $ <span class="type">Left</span> (<span class="type">T</span>.pack a)</span><br><span class="line">    <span class="type">Right</span> b -&gt; return $ <span class="type">Right</span> b</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> (<span class="type">Either</span> <span class="type">T</span>.<span class="type">Text</span> [<span class="type">Defn</span>])</span><br><span class="line"><span class="title">main</span> = parseFile <span class="string">"simple.ml"</span></span><br></pre></td></tr></table></figure></p>
<p>例如，使用下面的简单<code>lambda</code>表达式尝试上面的解析器:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> = g (x - <span class="number">1</span>);</span><br><span class="line"><span class="title">g</span> = f (x + <span class="number">1</span>);</span><br><span class="line"><span class="title">h</span> = \x y -&gt; (f x) + (g y);</span><br></pre></td></tr></table></figure></p>
<p><code>Attoparsec</code>也非常适合二进制和网络协议样式解析，这是从分布式共识网络协议的一个小实现中提取的:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE OverloadedStrings #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Attoparsec</span><br><span class="line"><span class="keyword">import</span> Data.Attoparsec.Char8 <span class="keyword">as</span> A</span><br><span class="line"><span class="keyword">import</span> Data.ByteString.Char8</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Action</span></span></span><br><span class="line">  = <span class="type">Success</span></span><br><span class="line">  | <span class="type">KeepAlive</span></span><br><span class="line">  | <span class="type">NoResource</span></span><br><span class="line">  | <span class="type">Hangup</span></span><br><span class="line">  | <span class="type">NewLeader</span></span><br><span class="line">  | <span class="type">Election</span></span><br><span class="line">  <span class="keyword">deriving</span> <span class="type">Show</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Sender</span> = <span class="type">ByteString</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Payload</span> = <span class="type">ByteString</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Message</span> = <span class="type">Message</span></span></span><br><span class="line">  &#123; action :: <span class="type">Action</span></span><br><span class="line">  , sender :: <span class="type">Sender</span></span><br><span class="line">  , payload :: <span class="type">Payload</span></span><br><span class="line">  &#125; <span class="keyword">deriving</span> <span class="type">Show</span></span><br><span class="line"></span><br><span class="line"><span class="title">proto</span> :: <span class="type">Parser</span> <span class="type">Message</span></span><br><span class="line"><span class="title">proto</span> = <span class="keyword">do</span></span><br><span class="line">  act  &lt;- paction</span><br><span class="line">  send &lt;- <span class="type">A</span>.takeTill (== '.')</span><br><span class="line">  body &lt;- <span class="type">A</span>.takeTill (<span class="type">A</span>.isSpace)</span><br><span class="line">  endOfLine</span><br><span class="line">  return $ <span class="type">Message</span> act send body</span><br><span class="line"></span><br><span class="line"><span class="title">paction</span> :: <span class="type">Parser</span> <span class="type">Action</span></span><br><span class="line"><span class="title">paction</span> = <span class="keyword">do</span></span><br><span class="line">  c &lt;- anyWord8</span><br><span class="line">  <span class="keyword">case</span> c <span class="keyword">of</span></span><br><span class="line">    <span class="number">1</span>  -&gt; return <span class="type">Success</span></span><br><span class="line">    <span class="number">2</span>  -&gt; return <span class="type">KeepAlive</span></span><br><span class="line">    <span class="number">3</span>  -&gt; return <span class="type">NoResource</span></span><br><span class="line">    <span class="number">4</span>  -&gt; return <span class="type">Hangup</span></span><br><span class="line">    <span class="number">5</span>  -&gt; return <span class="type">NewLeader</span></span><br><span class="line">    <span class="number">6</span>  -&gt; return <span class="type">Election</span></span><br><span class="line">    _  -&gt; mzero</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">let</span> msgtext = <span class="string">"\x01\x6c\x61\x70\x74\x6f\x70\x2e\x33\x2e\x31\x34\x31\x35\x39\x32\x36\x35\x33\x35\x0A"</span></span><br><span class="line">  <span class="keyword">let</span> msg = parseOnly proto msgtext</span><br><span class="line">  print msg</span><br></pre></td></tr></table></figure></p>
<p>請看:</p>
<ul>
<li><a href="https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec" target="_blank" rel="noopener">Text Parsing Tutorial</a></li>
</ul>
<h3 id="Optparse-Applicative"><a href="#Optparse-Applicative" class="headerlink" title="Optparse Applicative"></a>Optparse Applicative</h3><p><code>Optparse-applicative</code>是一个组合器库，用于构建命令行界面，这些命令行界面可以接收各种用户<code>flags</code>(标志)，<code>commands</code>(命令)和<code>switches</code>(开关)，并将它们映射到可以处理输入的<code>Haskell</code>数据结构中。<br><code>main</code>界面是通过<code>applicative functor</code>(应用函子)<code>Parser</code>和各种组合器(例如<code>strArgument</code>和<code>flag</code>)组成的，这些组合器通过一些<code>monadic</code>(单子)动作填充选项解析表，这些动作返回一個<code>Haskell</code>值。<br>所得的值序列可以适当地组合到一个较大的<code>Config</code>数据结构中，该数据结构包含所有给定的选项。<code>--help header</code>标头也会自动从组合器生成.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">./optparse</span><br><span class="line"><span class="type">Usage</span>: optparse.hs [filename...] [<span class="comment">--quiet] [--cheetah]</span></span><br><span class="line"></span><br><span class="line"><span class="type">Available</span> options:</span><br><span class="line">  -h,<span class="comment">--help                Show this help text</span></span><br><span class="line">  filename...              <span class="type">Input</span> files</span><br><span class="line">  <span class="comment">--quiet                  Whether to shut up.</span></span><br><span class="line">  <span class="comment">--cheetah                Perform task quickly.</span></span><br><span class="line"><span class="keyword">import</span> Data.List</span><br><span class="line"><span class="keyword">import</span> Data.Monoid</span><br><span class="line"><span class="keyword">import</span> Options.Applicative</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Opts</span> = <span class="type">Opts</span></span></span><br><span class="line">  &#123; _files :: [<span class="type">String</span>]</span><br><span class="line">  , _quiet :: <span class="type">Bool</span></span><br><span class="line">  , _fast :: <span class="type">Speed</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Speed</span> = <span class="type">Slow</span> | <span class="type">Fast</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">options</span> :: <span class="type">Parser</span> <span class="type">Opts</span></span><br><span class="line"><span class="title">options</span> = <span class="type">Opts</span> &lt;$&gt; filename &lt;*&gt; quiet &lt;*&gt; fast</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    filename :: <span class="type">Parser</span> [<span class="type">String</span>]</span><br><span class="line">    filename = many $ argument str $</span><br><span class="line">         metavar <span class="string">"filename..."</span></span><br><span class="line">      &lt;&gt; help <span class="string">"Input files"</span></span><br><span class="line"></span><br><span class="line">    fast :: <span class="type">Parser</span> <span class="type">Speed</span></span><br><span class="line">    fast = flag <span class="type">Slow</span> <span class="type">Fast</span> $</span><br><span class="line">         long <span class="string">"cheetah"</span></span><br><span class="line">      &lt;&gt; help <span class="string">"Perform task quickly."</span></span><br><span class="line"></span><br><span class="line">    quiet :: <span class="type">Parser</span> <span class="type">Bool</span></span><br><span class="line">    quiet = switch $</span><br><span class="line">         long <span class="string">"quiet"</span></span><br><span class="line">      &lt;&gt; help <span class="string">"Whether to shut up."</span></span><br><span class="line"></span><br><span class="line"><span class="title">greet</span> :: <span class="type">Opts</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">greet</span> (<span class="type">Opts</span> files quiet fast) = <span class="keyword">do</span></span><br><span class="line">  putStrLn <span class="string">"reading these files:"</span></span><br><span class="line">  mapM_ print files</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> fast <span class="keyword">of</span></span><br><span class="line">    <span class="type">Fast</span> -&gt; putStrLn <span class="string">"quickly"</span></span><br><span class="line">    <span class="type">Slow</span> -&gt; putStrLn <span class="string">"slowly"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> quiet <span class="keyword">of</span></span><br><span class="line">    <span class="type">True</span>  -&gt; putStrLn <span class="string">"quietly"</span></span><br><span class="line">    <span class="type">False</span> -&gt; putStrLn <span class="string">"loudly"</span></span><br><span class="line"></span><br><span class="line"><span class="title">opts</span> :: <span class="type">ParserInfo</span> <span class="type">Opts</span></span><br><span class="line"><span class="title">opts</span> = info (helper &lt;*&gt; options) fullDesc</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = execParser opts &gt;&gt;= greet</span><br></pre></td></tr></table></figure></p>
<p>請看:</p>
<ul>
<li><a href="https://github.com/pcapriotti/optparse-applicative" target="_blank" rel="noopener">Optparse Applicative Tutorial</a></li>
</ul>
<h3 id="Happy-amp-Alex"><a href="#Happy-amp-Alex" class="headerlink" title="Happy &amp; Alex"></a>Happy &amp; Alex</h3><p><code>Happy</code>是<code>Haskell</code>的解析器生成器系统，类似于<code>c</code>的工具<code>yacc</code>。<br>它作为一个预处理器，使用自己的语法从两个规范(<code>lexer</code>文件和<code>parser</code>文件)生成一个解析表。<br><code>happy</code>没有与解析器组合器相同的底层解析器实现，并且可以有效地使用左递归文法，而无需显式<code>factorization</code>(分解)。<br>它还可以很容易地被修改以跟踪<code>tokens</code>(标记)的位置信息，并处理缩进敏感语法的<code>offside</code>(越位)解析规则。<code>Happy</code>在<code>GHC</code>中用于<code>Haskell</code>的语法。</p>
<ul>
<li>Lexer.x</li>
<li>Parser.y</li>
</ul>
<p>运行<code>standalone</code>(独立)命令将为模块生成<code>haskell</code>源代码。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ alex <span class="type">Lexer</span>.x -o <span class="type">Lexer</span>.hs</span><br><span class="line">$ happy <span class="type">Parser</span>.y -o <span class="type">Parser</span>.hs</span><br></pre></td></tr></table></figure></p>
<p>生成的模块通常不可读，不幸的是，错误消息是在<code>Haskell</code>源代码中给出的，而不是<code>Happy</code>源代码.</p>
<h4 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h4><p>例如，我们可以定义一个带有自定义<code>tokens</code>(标记)集的小玩具<code>lexer</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">module</span> Lexer (</span><br><span class="line">  <span class="type">Token(..)</span>,</span><br><span class="line">  <span class="title">scanTokens</span></span><br><span class="line">) <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Syntax</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%wrapper <span class="string">"basic"</span></span><br><span class="line"></span><br><span class="line">$digit = <span class="number">0</span><span class="number">-9</span></span><br><span class="line">$alpha = [a-zA-<span class="type">Z</span>]</span><br><span class="line">$eol   = [\n]</span><br><span class="line"></span><br><span class="line"><span class="title">tokens</span> :-</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Whitespace insensitive (空格不敏感)</span></span><br><span class="line">  $eol                          ;</span><br><span class="line">  $white+                       ;</span><br><span class="line">  print                         &#123; \s -&gt; <span class="type">TokenPrint</span> &#125;</span><br><span class="line">  $digit+                       &#123; \s -&gt; <span class="type">TokenNum</span> (read s) &#125;</span><br><span class="line">  \=                            &#123; \s -&gt; <span class="type">TokenEq</span> &#125;</span><br><span class="line">  $alpha [$alpha $digit \_ \']* &#123; \s -&gt; <span class="type">TokenSym</span> s &#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Token</span> </span></span><br><span class="line">  = <span class="type">TokenNum</span> <span class="type">Int</span></span><br><span class="line">  | <span class="type">TokenSym</span> <span class="type">String</span></span><br><span class="line">  | <span class="type">TokenPrint</span></span><br><span class="line">  | <span class="type">TokenEq</span></span><br><span class="line">  | <span class="type">TokenEOF</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Eq</span>,<span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">scanTokens</span> = alexScanTokens</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h4><p>关联的解析器是<code>production</code>(生产)规则和运行解析器的<code>monad</code>(单子)的列表。<code>Production</code>(生产)规则由左侧的一组选项和右侧的带有索引元变量(<code>$1</code>，<code>$2</code>，…)的<code>Haskell</code>表达式生成，这些变量映射到左侧的有序<code>terms</code>(术语)(即第二个术语<code>term</code>〜<code>$1</code>，<code>term</code>〜<code>$2</code>).<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">terms</span></span><br><span class="line">    : term                   &#123; [$<span class="number">1</span>] &#125;</span><br><span class="line">    | term terms             &#123; $<span class="number">1</span> : $<span class="number">2</span> &#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">&#123;-# LANGUAGE GeneralizedNewtypeDeriving #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Parser (</span><br><span class="line">  <span class="title">parseExpr</span>,</span><br><span class="line">) <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Lexer</span><br><span class="line"><span class="keyword">import</span> Syntax</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Control.Monad.Except</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%name expr</span><br><span class="line">%tokentype &#123; <span class="type">Token</span> &#125;</span><br><span class="line">%monad &#123; <span class="type">Except</span> <span class="type">String</span> &#125; &#123; (&gt;&gt;=) &#125; &#123; return &#125;</span><br><span class="line">%error &#123; parseError &#125;</span><br><span class="line"></span><br><span class="line">%token</span><br><span class="line">    int   &#123; <span class="type">TokenNum</span> $$ &#125;</span><br><span class="line">    var   &#123; <span class="type">TokenSym</span> $$ &#125;</span><br><span class="line">    print &#123; <span class="type">TokenPrint</span> &#125;</span><br><span class="line">    '='   &#123; <span class="type">TokenEq</span> &#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="title">terms</span> </span><br><span class="line">    : term                   &#123; [$<span class="number">1</span>] &#125;</span><br><span class="line">    | term terms             &#123; $<span class="number">1</span> : $<span class="number">2</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="title">term</span> </span><br><span class="line">   : var                     &#123; <span class="type">Var</span> $<span class="number">1</span> &#125;</span><br><span class="line">   | var '=' int             &#123; <span class="type">Assign</span> $<span class="number">1</span> $<span class="number">3</span> &#125;</span><br><span class="line">   | print term              &#123; <span class="type">Print</span> $<span class="number">2</span> &#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="title">parseError</span> :: [<span class="type">Token</span>] -&gt; <span class="type">Except</span> <span class="type">String</span> a</span><br><span class="line"><span class="title">parseError</span> (l:ls) = throwError (show l)</span><br><span class="line"><span class="title">parseError</span> [] = throwError <span class="string">"Unexpected end of Input"</span></span><br><span class="line"></span><br><span class="line"><span class="title">parseExpr</span> :: <span class="type">String</span> -&gt; <span class="type">Either</span> <span class="type">String</span> [<span class="type">Expr</span>]</span><br><span class="line"><span class="title">parseExpr</span> input = </span><br><span class="line">  <span class="keyword">let</span> tokenStream = scanTokens input <span class="keyword">in</span></span><br><span class="line">  runExcept (expr tokenStream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>作为简单的输入，请考虑以下简单的程序:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">x</span> = <span class="number">4</span></span><br><span class="line"><span class="title">print</span> x</span><br><span class="line"><span class="title">y</span> = <span class="number">5</span></span><br><span class="line"><span class="title">print</span> y</span><br><span class="line"><span class="title">y</span> = <span class="number">6</span></span><br><span class="line"><span class="title">print</span> y</span><br></pre></td></tr></table></figure></p>
<h3 id="Configurator-配置器"><a href="#Configurator-配置器" class="headerlink" title="Configurator (配置器)"></a>Configurator (配置器)</h3><p><code>Configurator</code>是用于配置<code>Haskell daemons</code>(守护进程)和程序的库。它使用一种简单但灵活的配置语言，支持几种最常用的数据类型，以及来自配置或系统环境的字符串插值。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE OverloadedStrings #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Text</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Configurator <span class="keyword">as</span> C</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Config</span> = <span class="type">Config</span></span></span><br><span class="line">  &#123; verbose      :: <span class="type">Bool</span></span><br><span class="line">  , loggingLevel :: <span class="type">Int</span></span><br><span class="line">  , logfile      :: <span class="type">FilePath</span></span><br><span class="line">  , dbHost       :: <span class="type">Text</span></span><br><span class="line">  , dbUser       :: <span class="type">Text</span></span><br><span class="line">  , dbDatabase   :: <span class="type">Text</span></span><br><span class="line">  , dbpassword   :: <span class="type">Maybe</span> <span class="type">Text</span></span><br><span class="line">  &#125; <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">readConfig</span> :: <span class="type">FilePath</span> -&gt; <span class="type">IO</span> <span class="type">Config</span></span><br><span class="line"><span class="title">readConfig</span> cfgFile = <span class="keyword">do</span></span><br><span class="line">  cfg          &lt;- <span class="type">C</span>.load [<span class="type">C</span>.<span class="type">Required</span> cfgFile]</span><br><span class="line">  verbose      &lt;- <span class="type">C</span>.require cfg <span class="string">"logging.verbose"</span></span><br><span class="line">  loggingLevel &lt;- <span class="type">C</span>.require cfg <span class="string">"logging.loggingLevel"</span></span><br><span class="line">  logFile      &lt;- <span class="type">C</span>.require cfg <span class="string">"logging.logfile"</span></span><br><span class="line">  hostname     &lt;- <span class="type">C</span>.require cfg <span class="string">"database.hostname"</span></span><br><span class="line">  username     &lt;- <span class="type">C</span>.require cfg <span class="string">"database.username"</span></span><br><span class="line">  database     &lt;- <span class="type">C</span>.require cfg <span class="string">"database.database"</span></span><br><span class="line">  password     &lt;- <span class="type">C</span>.lookup cfg <span class="string">"database.password"</span></span><br><span class="line">  return $ <span class="type">Config</span> verbose loggingLevel logFile hostname username database password</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  cfg &lt;-readConfig <span class="string">"example.config"</span></span><br><span class="line">  print cfg</span><br></pre></td></tr></table></figure></p>
<p>一個簡單的配置文件:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">logging</span> </span><br><span class="line">&#123;</span><br><span class="line">  verbose      = true</span><br><span class="line">  logfile      = <span class="string">"/tmp/app.log"</span></span><br><span class="line">  loggingLevel = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">database</span></span><br><span class="line">&#123;</span><br><span class="line">  hostname = <span class="string">"us-east-1.rds.amazonaws.com"</span></span><br><span class="line">  username = <span class="string">"app"</span></span><br><span class="line">  database = <span class="string">"booktown"</span></span><br><span class="line">  password = <span class="string">"hunter2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Configurator</code>还包含一个<code>import</code>指令，它允许将复杂应用程序的配置拆分为几个较小的文件，或者将配置数据共享给多个应用程序。</p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="https://github.com/bobcn/hexo_resize_image.js"></script>
<script src="/blog/js/index.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/blog/js/gitment.js"></script>
<script>
    var gitment = new Gitment({
        id: 'Haskell-Parsing',
        owner: 'limengyu1990',
        repo: 'hexo-blog',
        oauth: {
            client_id: '7cfc73dd62b57f07ed83',
            client_secret: 'dd03b7e54aadf0d81e4c9c93e23a41272bcfcfa1',
        },
    })
    gitment.render('comment-container')
</script>

</html>
