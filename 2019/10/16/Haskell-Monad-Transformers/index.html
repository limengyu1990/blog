<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        Haskell-Monad-Transformers - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 不会Haskell的Scala写不出好的JavaScript。 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>不负如来不负卿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#mtl-transformers"><span class="toc-text">mtl / transformers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transformers"><span class="toc-text">Transformers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Basics"><span class="toc-text">Basics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReaderT"><span class="toc-text">ReaderT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Newtype-Deriving"><span class="toc-text">Newtype Deriving</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Efficiency-效率"><span class="toc-text">Efficiency (效率)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Monad-Morphisms-单子态射"><span class="toc-text">Monad Morphisms (单子态射)</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 不会Haskell的Scala写不出好的JavaScript。 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Haskell-Monad-Transformers
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-10-16 19:32:23</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/blog/tags/#Wish-Knew" title="Wish-Knew">Wish-Knew</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Haskell" title="Haskell">Haskell</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Monad-Transformers" title="Monad-Transformers">Monad-Transformers</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p><a href="http://dev.stephendiehl.com/hask/#monad-transformers" target="_blank" rel="noopener">原文</a></p>
</blockquote>
<h3 id="mtl-transformers"><a href="#mtl-transformers" class="headerlink" title="mtl / transformers"></a>mtl / transformers</h3><p>所以，前一章对<code>Monads</code>的描述有点不可信。现代的<code>Haskell monad</code>库通常使用一种更通用的形式，用<code>monad transformers</code>来编写，它允许我们将<code>monad</code>合在一起形成复合<code>monad</code>。前面提到的<code>monad</code>被包含在由<code>Identity</code>单子组成的<code>transformer</code>形式的特例中。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Monad</span>	| <span class="type">Transformer</span>  |  <span class="type">Type</span>	      |  <span class="type">Transformed</span> <span class="type">Type</span></span><br><span class="line"><span class="comment">--------|--------------|--------------|---------------------</span></span><br><span class="line"><span class="type">Maybe</span>	| <span class="type">MaybeT</span>	   |  <span class="type">Maybe</span> a	  |  m (<span class="type">Maybe</span> a)</span><br><span class="line"><span class="type">Reader</span>	| <span class="type">ReaderT</span>	   |  r -&gt; a	  |  r -&gt; m a</span><br><span class="line"><span class="type">Writer</span>	| <span class="type">WriterT</span>	   |  (a,w)	      |  m (a,w)</span><br><span class="line"><span class="type">State</span>	| <span class="type">StateT</span>	   |  s -&gt; (a,s)  |	 s -&gt; m (a,s)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">State</span>  s = <span class="type">StateT</span>  s <span class="type">Identity</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Writer</span> w = <span class="type">WriterT</span> w <span class="type">Identity</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Reader</span> r = <span class="type">ReaderT</span> r <span class="type">Identity</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> m =&gt; <span class="type">MonadState</span> s (<span class="type">StateT</span> <span class="title">s</span> <span class="title">m</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> m =&gt; <span class="type">MonadReader</span> r (<span class="type">ReaderT</span> <span class="title">r</span> <span class="title">m</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Monoid</span> <span class="title">w</span>, <span class="type">Monad</span> <span class="title">m</span>) =&gt; <span class="type">MonadWriter</span> w (<span class="type">WriterT</span> <span class="title">w</span> <span class="title">m</span>)</span></span><br></pre></td></tr></table></figure>
<p>就通用性而言，<code>mtl</code>库是这些<code>monad</code>最常见的通用接口，它本身依赖于<code>transformers</code>库，该库将上述基本<code>monad</code>概括为<code>transformers</code>.</p>
<h3 id="Transformers"><a href="#Transformers" class="headerlink" title="Transformers"></a>Transformers</h3><p><code>monad transformers</code>的核心是使我们能够将<code>monadic</code>计算嵌套<code>stack</code>堆栈中，这个堆栈有一个接口，用於在<code>levels</code>(级别)之间交换值，称为<code>lift</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lift</span> :: (<span class="type">Monad</span> m, <span class="type">MonadTrans</span> t) =&gt; m a -&gt; t m a</span><br><span class="line"><span class="title">liftIO</span> :: <span class="type">MonadIO</span> m =&gt; <span class="type">IO</span> a -&gt; m a</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">MonadTrans</span> t <span class="keyword">where</span></span></span><br><span class="line">    lift :: <span class="type">Monad</span> m =&gt; m a -&gt; t m a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Monad</span> <span class="title">m</span>) =&gt; <span class="type">MonadIO</span> m <span class="keyword">where</span></span></span><br><span class="line">    liftIO :: <span class="type">IO</span> a -&gt; m a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadIO</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">    liftIO = id</span><br></pre></td></tr></table></figure></p>
<p>就像基本的<code>monad</code>类具有法律一样，<code>monad transformers</code>也具有一些法律:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Law</span> #<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    lift . return = return</span><br><span class="line"></span><br><span class="line"><span class="type">Law</span> #<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    lift (m &gt;&gt;= f) = lift m &gt;&gt;= (lift . f)</span><br><span class="line"></span><br><span class="line">或等效地:</span><br><span class="line"></span><br><span class="line"><span class="type">Law</span> #<span class="number">1</span></span><br><span class="line"></span><br><span class="line">     lift (return x)</span><br><span class="line"></span><br><span class="line">    = return x</span><br><span class="line"></span><br><span class="line"><span class="type">Law</span> #<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> x &lt;- lift m</span><br><span class="line">     lift (f x)</span><br><span class="line"></span><br><span class="line">    = lift $ <span class="keyword">do</span> x &lt;- m</span><br><span class="line">                f x</span><br></pre></td></tr></table></figure></p>
<p>请记住，<code>transformers</code>是由<code>outside-in</code>(从外向内)组成的，但由<code>inside out</code>(内而外)展开，這很有用。</p>
<p>請看: <a href="http://catamorph.de/publications/2004-10-01-monad-transformers.html" target="_blank" rel="noopener">Monad Transformers: Step-By-Step</a></p>
<h3 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h3><p>最基本的使用要求我们为外层的每个<code>monad transformers</code>使用<code>T-variants</code>(变量)，并在层之间显式地<code>lift</code>和<code>return</code>值。</p>
<p><code>monad</code>的<code>kind</code>為<code>(* -&gt; *)</code>,所以把<code>monad</code>转换成<code>monad</code>的<code>monad transformers</code>有<code>((* -&gt; *) -&gt; * -&gt; *)</code>:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Monad</span> (m :: * -&gt; *)</span><br><span class="line"><span class="type">MonadTrans</span> (t :: (* -&gt; *) -&gt; * -&gt; *)</span><br></pre></td></tr></table></figure></p>
<p>因此，例如，如果我们想同时使用<code>Reader</code>和<code>Maybe</code>单子构成一个复合计算，我们现在可以将<code>Maybe</code>放在<code>ReaderT</code>内以形成<code>ReaderT t Maybe a</code>.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Monad.Reader</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Env</span> = [(<span class="type">String</span>, <span class="type">Int</span>)]</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Eval</span> a = <span class="type">ReaderT</span> <span class="type">Env</span> <span class="type">Maybe</span> a</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span></span></span><br><span class="line">  = <span class="type">Val</span> <span class="type">Int</span></span><br><span class="line">  | <span class="type">Add</span> <span class="type">Expr</span> <span class="type">Expr</span></span><br><span class="line">  | <span class="type">Var</span> <span class="type">String</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">eval</span> :: <span class="type">Expr</span> -&gt; <span class="type">Eval</span> <span class="type">Int</span></span><br><span class="line"><span class="title">eval</span> ex = <span class="keyword">case</span> ex <span class="keyword">of</span></span><br><span class="line"></span><br><span class="line">  <span class="type">Val</span> n -&gt; return n</span><br><span class="line"></span><br><span class="line">  <span class="type">Add</span> x y -&gt; <span class="keyword">do</span></span><br><span class="line">    a &lt;- eval x</span><br><span class="line">    b &lt;- eval y</span><br><span class="line">    return (a+b)</span><br><span class="line"></span><br><span class="line">  <span class="type">Var</span> x -&gt; <span class="keyword">do</span></span><br><span class="line">    env &lt;- ask</span><br><span class="line">    val &lt;- lift (lookup x env)</span><br><span class="line">    return val</span><br><span class="line"></span><br><span class="line"><span class="title">env</span> :: <span class="type">Env</span></span><br><span class="line"><span class="title">env</span> = [(<span class="string">"x"</span>, <span class="number">2</span>), (<span class="string">"y"</span>, <span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="title">ex1</span> :: <span class="type">Eval</span> <span class="type">Int</span></span><br><span class="line"><span class="title">ex1</span> = eval (<span class="type">Add</span> (<span class="type">Val</span> <span class="number">2</span>) (<span class="type">Add</span> (<span class="type">Val</span> <span class="number">1</span>) (<span class="type">Var</span> <span class="string">"x"</span>)))</span><br><span class="line"></span><br><span class="line"><span class="title">example1</span>, example2 :: <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">example1</span> = runReaderT ex1 env</span><br><span class="line"><span class="title">example2</span> = runReaderT ex1 []</span><br></pre></td></tr></table></figure></p>
<p>这种方法的基本局限性在于，我们发现我們有自己有很多的<code>lift.lift.lifting</code>和<code>return.return.returning</code>。</p>
<h3 id="ReaderT"><a href="#ReaderT" class="headerlink" title="ReaderT"></a>ReaderT</h3><p>例如，<code>Reader monad</code>存在三种可能形式。第一个是<code>Haskell 98</code>版本，该版本已不存在，但对于理解基本思想很有用。另外两个是<code>transformers</code>和<code>mtl</code>变体。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Reader</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">newtype</span> <span class="type">Reader</span> r a = <span class="type">Reader</span> &#123; <span class="title">runReader</span> :: <span class="title">r</span> -&gt; <span class="title">a</span> &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">    <span class="keyword">instance</span> <span class="type">MonadReader</span> r (<span class="type">Reader</span> <span class="title">r</span>) <span class="keyword">where</span></span></span><br><span class="line">    ask       = <span class="type">Reader</span> id</span><br><span class="line">    local f m = <span class="type">Reader</span> (runReader m . f)</span><br><span class="line"></span><br><span class="line"><span class="type">ReaderT</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">newtype</span> <span class="type">ReaderT</span> r m a = <span class="type">ReaderT</span> &#123; <span class="title">runReaderT</span> :: <span class="title">r</span> -&gt; <span class="title">m</span> <span class="title">a</span> &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">    <span class="keyword">instance</span> (<span class="type">Monad</span> <span class="title">m</span>) =&gt; <span class="type">Monad</span> (<span class="type">ReaderT</span> <span class="title">r</span> <span class="title">m</span>) <span class="keyword">where</span></span></span><br><span class="line">    return a = <span class="type">ReaderT</span> $ \_ -&gt; return a</span><br><span class="line">    m &gt;&gt;= k  = <span class="type">ReaderT</span> $ \r -&gt; <span class="keyword">do</span></span><br><span class="line">        a &lt;- runReaderT m r</span><br><span class="line">        runReaderT (k a) r</span><br><span class="line"></span><br><span class="line"><span class="class">    <span class="keyword">instance</span> <span class="type">MonadTrans</span> (<span class="type">ReaderT</span> <span class="title">r</span>) <span class="keyword">where</span></span></span><br><span class="line">        lift m = <span class="type">ReaderT</span> $ \_ -&gt; m</span><br><span class="line"></span><br><span class="line"><span class="type">MonadReader</span></span><br><span class="line"></span><br><span class="line"><span class="class">    <span class="keyword">class</span> (<span class="type">Monad</span> <span class="title">m</span>) =&gt; <span class="type">MonadReader</span> r m | m -&gt; r <span class="keyword">where</span></span></span><br><span class="line">        ask   :: m r</span><br><span class="line">        local :: (r -&gt; r) -&gt; m a -&gt; m a</span><br><span class="line"></span><br><span class="line"><span class="class">    <span class="keyword">instance</span> (<span class="type">Monad</span> <span class="title">m</span>) =&gt; <span class="type">MonadReader</span> r (<span class="type">ReaderT</span> <span class="title">r</span> <span class="title">m</span>) <span class="keyword">where</span></span></span><br><span class="line">        ask       = <span class="type">ReaderT</span> return</span><br><span class="line">        local f m = <span class="type">ReaderT</span> $ \r -&gt; runReaderT m (f r)</span><br></pre></td></tr></table></figure></p>
<p>因此，假设<code>ask</code>的三个变体为:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ask</span> :: <span class="type">Reader</span> r r</span><br><span class="line"><span class="title">ask</span> :: <span class="type">Monad</span> m =&gt; <span class="type">ReaderT</span> r m r</span><br><span class="line"><span class="title">ask</span> :: <span class="type">MonadReader</span> r m =&gt; m r</span><br></pre></td></tr></table></figure></p>
<p>实际上，现代<code>Haskell</code>仅使用最后一个。</p>
<h3 id="Newtype-Deriving"><a href="#Newtype-Deriving" class="headerlink" title="Newtype Deriving"></a>Newtype Deriving</h3><p>通过<code>Newtypes</code>，我们可以引用具有单个构造函数的数据类型作为新的<code>distinct</code>(独特/不同)类型，而装箱不会增加运行时间，这与具有单个构造函数的代数数据类型不同。<br><code>around</code>(圍繞)字符串和数字类型的<code>Newtype</code>包装器通常可以大大减少意外错误。</p>
<p>考虑使用<code>newtype</code>区分具有不同语义的两个不同文本<code>Blob</code>的情况。<br>两者都具有与<code>text</code>(文本)对象相同的运行时表示形式，但都是<code>distinguished statically</code>(静态区分)的，<br>这样明文就不会意外地与加密文本互换。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Plaintext</span> = <span class="type">Plaintext</span> <span class="type">Text</span></span></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Crytpotext</span> = <span class="type">Cryptotext</span> <span class="type">Text</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">encrypt</span> :: <span class="type">Key</span> -&gt; <span class="type">Plaintext</span> -&gt; <span class="type">Cryptotext</span></span><br><span class="line"><span class="title">decrypt</span> :: <span class="type">Key</span> -&gt; <span class="type">Cryptotext</span> -&gt; <span class="type">Plaintext</span></span><br></pre></td></tr></table></figure></p>
<p>另一个常见的用例是使用<code>newtypes</code>来派生逻辑，以在我们的业务逻辑中派生自定义<code>monad transformers</code>。<br>使用<code>-XGeneralizedNewtypeDeriving</code>，我们可以恢复在我们的<code>transformer</code>堆栈中组成的底层类型的实例的函數。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GeneralizedNewtypeDeriving #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Velocity</span> = <span class="type">Velocity</span> &#123; <span class="title">unVelocity</span> :: <span class="type">Double</span> &#125;</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">v</span> :: <span class="type">Velocity</span></span><br><span class="line"><span class="title">v</span> = <span class="type">Velocity</span> <span class="number">2.718</span></span><br><span class="line"></span><br><span class="line"><span class="title">x</span> :: <span class="type">Double</span></span><br><span class="line"><span class="title">x</span> = <span class="number">2.718</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Type error is caught at compile time even though</span></span><br><span class="line"><span class="comment">-- they are the same value at runtime!</span></span><br><span class="line"><span class="title">err</span> = v + x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Quantity</span> v a = <span class="type">Quantity</span> a</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Num</span>, <span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Haskeller</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Haskellers</span> = <span class="type">Quantity</span> <span class="type">Haskeller</span> <span class="type">Int</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">a</span> = <span class="type">Quantity</span> <span class="number">2</span> :: <span class="type">Haskellers</span></span><br><span class="line"><span class="title">b</span> = <span class="type">Quantity</span> <span class="number">6</span> :: <span class="type">Haskellers</span></span><br><span class="line"></span><br><span class="line"><span class="title">totalHaskellers</span> :: <span class="type">Haskellers</span></span><br><span class="line"><span class="title">totalHaskellers</span> = a + b</span><br><span class="line"><span class="type">Couldn't</span> match <span class="class"><span class="keyword">type</span> `<span class="type">Double'</span> with `<span class="type">Velocity'</span></span></span><br><span class="line"><span class="type">Expected</span> <span class="class"><span class="keyword">type</span>: <span class="type">Velocity</span></span></span><br><span class="line">  <span class="type">Actual</span> <span class="class"><span class="keyword">type</span>: <span class="type">Double</span></span></span><br><span class="line"><span class="type">In</span> the second argument <span class="keyword">of</span> `(+)', namely `x'</span><br><span class="line"><span class="type">In</span> the expression: v + x</span><br></pre></td></tr></table></figure></p>
<p>将<code>newtype deriving</code>与<code>mtl</code>库类型类一起使用，我们可以生成不需要在<code>transform</code>(转换器)堆栈中显式提升的<code>flattened transformer</code>(扁平转换器)类型。例如，这里有一个小的<code>stack machine</code>(堆栈机)，它包含了<code>Reader, Writer, State monad</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GeneralizedNewtypeDeriving #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Control.Monad.Reader</span><br><span class="line"><span class="keyword">import</span> Control.Monad.Writer</span><br><span class="line"><span class="keyword">import</span> Control.Monad.State</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Stack</span>   = [<span class="type">Int</span>]</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Output</span>  = [<span class="type">Int</span>]</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Program</span> = [<span class="type">Instr</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">VM</span> a = <span class="type">ReaderT</span> <span class="type">Program</span> (<span class="type">WriterT</span> <span class="type">Output</span> (<span class="type">State</span> <span class="type">Stack</span>)) a</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Comp</span> a = <span class="type">Comp</span> &#123; <span class="title">unComp</span> :: <span class="type">VM</span> <span class="title">a</span> &#125;</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Monad</span>, <span class="type">MonadReader</span> <span class="type">Program</span>, <span class="type">MonadWriter</span> <span class="type">Output</span>, <span class="type">MonadState</span> <span class="type">Stack</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Instr</span> = <span class="type">Push</span> <span class="type">Int</span> | <span class="type">Pop</span> | <span class="type">Puts</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">evalInstr</span> :: <span class="type">Instr</span> -&gt; <span class="type">Comp</span> ()</span><br><span class="line"><span class="title">evalInstr</span> instr = <span class="keyword">case</span> instr <span class="keyword">of</span></span><br><span class="line">  <span class="type">Pop</span>    -&gt; modify tail</span><br><span class="line">  <span class="type">Push</span> n -&gt; modify (n:)</span><br><span class="line">  <span class="type">Puts</span>   -&gt; <span class="keyword">do</span></span><br><span class="line">    tos &lt;- gets head</span><br><span class="line">    tell [tos]</span><br><span class="line"></span><br><span class="line"><span class="title">eval</span> :: <span class="type">Comp</span> ()</span><br><span class="line"><span class="title">eval</span> = <span class="keyword">do</span></span><br><span class="line">  instr &lt;- ask</span><br><span class="line">  <span class="keyword">case</span> instr <span class="keyword">of</span></span><br><span class="line">    []     -&gt; return ()</span><br><span class="line">    (i:is) -&gt; evalInstr i &gt;&gt; local (const is) eval</span><br><span class="line"></span><br><span class="line"><span class="title">execVM</span> :: <span class="type">Program</span> -&gt; <span class="type">Output</span></span><br><span class="line"><span class="title">execVM</span> = flip evalState [] . execWriterT . runReaderT (unComp eval)</span><br><span class="line"></span><br><span class="line"><span class="title">program</span> :: <span class="type">Program</span></span><br><span class="line"><span class="title">program</span> = [</span><br><span class="line">     <span class="type">Push</span> <span class="number">42</span>,</span><br><span class="line">     <span class="type">Push</span> <span class="number">27</span>,</span><br><span class="line">     <span class="type">Puts</span>,</span><br><span class="line">     <span class="type">Pop</span>,</span><br><span class="line">     <span class="type">Puts</span>,</span><br><span class="line">     <span class="type">Pop</span></span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = mapM_ print $ execVM program</span><br></pre></td></tr></table></figure></p>
<p>在<code>newtype</code>构造函数上的模式匹配不会编译成任何东西.<br>例如，<code>extractB</code>函数不会像<code>extractA</code>那样仔细检查<code>MkB</code>构造函数，<br>因为<code>MkB</code>在运行时不存在，所以它纯粹是一个编译时结构。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">A</span> = <span class="type">MkA</span> <span class="type">Int</span></span></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">B</span> = <span class="type">MkB</span> <span class="type">Int</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">extractA</span> :: <span class="type">A</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">extractA</span> (<span class="type">MkA</span> x) = x</span><br><span class="line"></span><br><span class="line"><span class="title">extractB</span> :: <span class="type">B</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">extractB</span> (<span class="type">MkB</span> x) = x</span><br></pre></td></tr></table></figure></p>
<h3 id="Efficiency-效率"><a href="#Efficiency-效率" class="headerlink" title="Efficiency (效率)"></a>Efficiency (效率)</h3><p>第二个<code>monad transformer</code>法则保证连续的<code>lift</code>(提升)操作的<code>sequencing</code>(顺序)在语义上等同于将结果提升到外部<code>monad</code>中。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">do</span> x &lt;- lift m  ==  lift $ <span class="keyword">do</span> x &lt;- m</span><br><span class="line">   lift (f x)                 f x</span><br></pre></td></tr></table></figure></p>
<p>虽然它们可以保证得到相同的结果，但是在使用<code>monad traversal and looping</code>(遍历和循环)函数时，在<code>monad</code>级别之间<code>lift</code>(提升)结果的操作并不是没有代价的，而且经常会出现。<br>例如，下面左侧的所有三个函数的效率都低于右侧，后者在基本<code>monad</code>中执行绑定，而不是在每次迭代时都进行<code>lift</code>(提升)。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Less Efficient      More Efficient</span></span><br><span class="line"><span class="title">forever</span> (lift m)    == lift (forever m)</span><br><span class="line"><span class="title">mapM_</span> (lift . f) xs == lift (mapM_ f xs)</span><br><span class="line"><span class="title">forM_</span> xs (lift . f) == lift (forM_ xs f)</span><br></pre></td></tr></table></figure></p>
<h3 id="Monad-Morphisms-单子态射"><a href="#Monad-Morphisms-单子态射" class="headerlink" title="Monad Morphisms (单子态射)"></a>Monad Morphisms (单子态射)</h3><p>基本的<code>monad transformer</code>程序包提供了一个<code>MonadTrans</code>类，用于提升到另一个<code>monad</code>:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lift</span> :: <span class="type">Monad</span> m =&gt; m a -&gt; t m a</span><br></pre></td></tr></table></figure></p>
<p>但是通常我们需要与<code>monad transformer</code>堆栈一起工作和操作，以产生新的<code>transformer</code>，修改现有的<code>transformers</code>或用新的<code>layers</code>(层)扩展上游库。<code>mmorph</code>库提供了直接在<code>transformer</code>堆栈上构成<code>monad morphism transformation</code>(形态变换)的功能。<br>等效的变压器类型等级映射是“提升”功能。<br>等效的<code>type transformer</code>(类型转换器)<code>type-level</code>映射是<code>hoist</code>功能.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">hoist</span> :: <span class="type">Monad</span> m =&gt; (<span class="keyword">forall</span> a. m a -&gt; n a) -&gt; t m b -&gt; t n b</span><br></pre></td></tr></table></figure></p>
<p><code>Hoist</code>接收<code>monad</code>态射(从<code>m a</code>到<code>n a</code>的映射)并应用于变压器堆栈的内部值<code>monad</code>，从而转换外层下的值.<br><code>monad morphism</code>(态射)<code>generalize</code>将一个<code>Identity</code>单子带入任何其他单子<code>monad m</code>.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">generalize</span> :: <span class="type">Monad</span> m =&gt; <span class="type">Identity</span> a -&gt; m a</span><br></pre></td></tr></table></figure></p>
<p>例如，它将<code>State s a</code>(即<code>StateT s Identity a</code>)概括为<code>StateT s a</code>.<br>因此，我们可以<code>generalize</code>(概括)一个现有的<code>transformer</code>以在其上<code>lift</code>(提升)一個<code>IO</code>层。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Monad.State</span><br><span class="line"><span class="keyword">import</span> Control.Monad.Morph</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Eval</span> a = <span class="type">State</span> [<span class="type">Int</span>] a</span></span><br><span class="line"></span><br><span class="line"><span class="title">runEval</span> :: [<span class="type">Int</span>] -&gt; <span class="type">Eval</span> a -&gt; a</span><br><span class="line"><span class="title">runEval</span> = flip evalState</span><br><span class="line"></span><br><span class="line"><span class="title">pop</span> :: <span class="type">Eval</span> <span class="type">Int</span></span><br><span class="line"><span class="title">pop</span> = <span class="keyword">do</span></span><br><span class="line">  top &lt;- gets head</span><br><span class="line">  modify tail</span><br><span class="line">  return top</span><br><span class="line"></span><br><span class="line"><span class="title">push</span> :: <span class="type">Int</span> -&gt; <span class="type">Eval</span> ()</span><br><span class="line"><span class="title">push</span> x = modify (x:)</span><br><span class="line"></span><br><span class="line"><span class="title">ev1</span> :: <span class="type">Eval</span> <span class="type">Int</span></span><br><span class="line"><span class="title">ev1</span> = <span class="keyword">do</span></span><br><span class="line">  push <span class="number">3</span></span><br><span class="line">  push <span class="number">4</span></span><br><span class="line">  pop</span><br><span class="line">  pop</span><br><span class="line"></span><br><span class="line"><span class="title">ev2</span>  :: <span class="type">StateT</span> [<span class="type">Int</span>] <span class="type">IO</span> ()</span><br><span class="line"><span class="title">ev2</span> = <span class="keyword">do</span></span><br><span class="line">  result &lt;- hoist generalize ev1</span><br><span class="line">  liftIO $ putStrLn $ <span class="string">"Result: "</span> ++ show result</span><br></pre></td></tr></table></figure></p>
<p>請看: <a href="https://hackage.haskell.org/package/mmorph" target="_blank" rel="noopener">mmorph</a></p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
        <span><a href="https://serokell.io/blog">serokell</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/blog/js/index.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/blog/js/gitment.js"></script>
<script>
    var gitment = new Gitment({
        id: 'Haskell-Monad-Transformers',
        owner: 'limengyu1990',
        repo: 'hexo-blog',
        oauth: {
            client_id: '7cfc73dd62b57f07ed83',
            client_secret: 'dd03b7e54aadf0d81e4c9c93e23a41272bcfcfa1',
        },
    })
    gitment.render('comment-container')
</script>

</html>
