<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        Haskell-Monads - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 不会Haskell的Scala写不出好的JavaScript。 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>不负如来不负卿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Eightfold-Path-to-Monad-Satori-通往Monad-Satori的八重路"><span class="toc-text">Eightfold Path to Monad Satori (通往Monad Satori的八重路)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Monadic-Myths-神話"><span class="toc-text">Monadic Myths(神話)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Monadic-Methods"><span class="toc-text">Monadic Methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Laws"><span class="toc-text">Laws</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Law-1"><span class="toc-text">Law 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Law-2"><span class="toc-text">Law 2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Law-3"><span class="toc-text">Law 3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Do-Notation-Do表示法"><span class="toc-text">Do Notation (Do表示法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maybe"><span class="toc-text">Maybe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-text">List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO"><span class="toc-text">IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#What’s-the-point-有什么意义"><span class="toc-text">What’s the point? (有什么意义?)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Maybe-1"><span class="toc-text">Maybe</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List-1"><span class="toc-text">List</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-1"><span class="toc-text">IO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reader-Monad"><span class="toc-text">Reader Monad</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Writer-Monad"><span class="toc-text">Writer Monad</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#State-Monad"><span class="toc-text">State Monad</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Monad-Tutorials"><span class="toc-text">Monad Tutorials</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 不会Haskell的Scala写不出好的JavaScript。 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Haskell-Monads
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-10-16 19:32:07</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/blog/tags/#Wish-Knew" title="Wish-Knew">Wish-Knew</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Haskell" title="Haskell">Haskell</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Monads" title="Monads">Monads</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p><a href="http://dev.stephendiehl.com/hask/#monads" target="_blank" rel="noopener">原文</a></p>
</blockquote>
<h3 id="Eightfold-Path-to-Monad-Satori-通往Monad-Satori的八重路"><a href="#Eightfold-Path-to-Monad-Satori-通往Monad-Satori的八重路" class="headerlink" title="Eightfold Path to Monad Satori (通往Monad Satori的八重路)"></a>Eightfold Path to Monad Satori (通往Monad Satori的八重路)</h3><p>关于所谓的<code>monads</code>的奥秘，抒情诗已经大量涌出。相反，我建议一个启发之路:</p>
<ul>
<li>不要读<code>monad</code>教程。</li>
<li>不，真的，不要读<code>monad</code>的教程。</li>
<li>學習<a href="http://book.realworldhaskell.org/read/types-and-functions.html" target="_blank" rel="noopener">Haskell types</a></li>
<li>学习什么是<code>typeclass</code>(类型类)。</li>
<li>阅读<a href="http://wiki.haskell.org/Typeclassopedia" target="_blank" rel="noopener">Typeclassopedia</a>。</li>
<li>阅读<code>monad</code>的定义。</li>
<li>在代码中使用<code>monads</code>。</li>
<li>不要写<code>monad</code>类比教程。</li>
</ul>
<p>换句话说，了解<code>monad的</code>唯一途径是阅读好的源代码，启动<code>GHC</code>并编写一些代码。 类比和隐喻不会导致理解。</p>
<h3 id="Monadic-Myths-神話"><a href="#Monadic-Myths-神話" class="headerlink" title="Monadic Myths(神話)"></a>Monadic Myths(神話)</h3><p>以下均为<code>false</code>:</p>
<ul>
<li><code>Monads</code>是不纯的。</li>
<li><code>Monads</code>是关于<code>effects</code>(效果)的。</li>
<li><code>Monads</code>是关于状态的。</li>
<li><code>Monads</code>与命令式排序有关。</li>
<li><code>Monads</code>与<code>IO</code>有关。</li>
<li><code>Monads</code>依赖懒惰。</li>
<li><code>Monads</code>是该语言的后门，可以产生副作用。</li>
<li><code>Monads</code>是<code>Haskell</code>内部的嵌入式命令式语言。</li>
<li><code>Monads</code>需要了解抽象数学。</li>
<li><code>Monads</code>是<code>Haskell</code>独有的。</li>
</ul>
<p>請看: <a href="http://wiki.haskell.org/What_a_Monad_is_not" target="_blank" rel="noopener">What a Monad Is Not</a></p>
<h3 id="Monadic-Methods"><a href="#Monadic-Methods" class="headerlink" title="Monadic Methods"></a>Monadic Methods</h3><p><code>Monads</code>并不复杂。它们被实现为具有兩個方法的<code>typeclass</code>: <code>return</code>和<code>(&gt;=)</code>(发音为<code>bind</code>)。</p>
<p>为了实现<code>monad</code>实例，这两个函数必须根据<code>typeclass</code>定义中描述的一致性进行定义：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 'm'指实现 Monad typeClass 的类型构造函数(例如: Maybe,Either等)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line">  return :: a -&gt; m a</span><br><span class="line">  (&gt;&gt;=)  :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br></pre></td></tr></table></figure>
<p><code>Monad</code>类定义中的第一个类型签名是用于<code>return</code>的。</p>
<p>对于<code>return</code>一词可能有的任何先入之见都应该丢弃: 它在<code>Haskell</code>的上下文中具有完全不同的含义，并且与<code>C</code>，<code>Python</code>或<code>Java</code>等语言的行为截然不同。<br>在<code>Haskell</code>中，<code>return</code>不是函数产生什么值的最终仲裁者，而是将类型为<code>a</code>的值注入到<code>monadic</code>上下文语境(例如<code>Maybe</code>，<code>Either</code>等)中，表示为<code>m a</code>。</p>
<p>实现<code>Monad</code>实例的另一个重要函數是<code>(&gt;&gt;=)</code>。<br>此中缀操作符有两个参数。<br>在其左侧是类型为<code>m a</code>的值，而在右侧是类型为<code>(a -&gt; m b)</code>的函数。<code>bind</code>(绑定)操作得出的最终值类型为<code>m b</code>。</p>
<p>第三个辅助函数(<code>(&gt;&gt;)</code>)是根据放弃其参数的绑定操作定义的。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&gt;&gt;) :: <span class="type">Monad</span> m =&gt; m a -&gt; m b -&gt; m b</span><br><span class="line"><span class="title">m</span> &gt;&gt; k = m &gt;&gt;= \_ -&gt; k</span><br></pre></td></tr></table></figure></p>
<p>这个定义是说<code>(&gt;&gt;)</code>有一個<code>left</code>和<code>right</code>參數，它们分别是类型为<code>m a</code>和<code>m b</code>的单子数，而中缀操作符返回类型为<code>m b</code>的值。</p>
<p><code>(&gt;&gt;)</code>的实际实现表示，当将<code>m</code>传递到带有<code>k</code>的右侧的<code>(&gt;&gt;)</code>时，将始终返回值<code>k</code>。</p>
<h3 id="Laws"><a href="#Laws" class="headerlink" title="Laws"></a>Laws</h3><p>除了<code>(&gt;&gt;=)</code>和<code>return</code>的特定实现之外，所有<code>monad</code>实例还必须满足三个定律。</p>
<h4 id="Law-1"><a href="#Law-1" class="headerlink" title="Law 1"></a>Law 1</h4><p>第一定律说，当将<code>(return a)</code>通过<code>(&gt;&gt;=)</code>传递给函数<code>f</code>时，该表达式与<code>f a</code>完全等效。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">return</span> a &gt;&gt;= f ≡ f a  <span class="comment">-- 'a'是指值，而不是类型</span></span><br></pre></td></tr></table></figure></p>
<p>在讨论下两个定律时，我们将提到一个值<code>m</code>。<br>这个符号是包装在<code>monadic</code>上下文中的值的简写。这样的值具有<code>m a</code>类型，可以更具体地用<code>Nothing</code>、<code>Just x</code>或<code>Right x</code>等值来表示。<br>需要注意的是，这些值<code>m</code>的具体实例化中有一些包含多个组件。在讨论第二和第三单子定律时，我们将看到一些例子来说明这一点。</p>
<h4 id="Law-2"><a href="#Law-2" class="headerlink" title="Law 2"></a>Law 2</h4><p>第二定律指出，通过<code>(&gt;&gt;=)</code>传递给<code>return</code>的<code>monadic</code>值<code>m</code>与其自身完全等效。<br>换句话说，使用<code>bind</code>将<code>monadic</code>值传递给<code>return</code>不会改变初始值。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">m</span> &gt;&gt;= return ≡ m  <span class="comment">-- 'm'是指类型为'm a'的值</span></span><br></pre></td></tr></table></figure></p>
<p>存在一种更明确的写第二条<code>Monad</code>定律的方法。在下面的示例代码中，第一个表达式显示了第二定律如何应用于由<a href="https://wiki.haskell.org/Constructor#Type_constructor" target="_blank" rel="noopener">non-nullary</a>类型构造函数表示的值。第二个片段显示了由<code>nullary</code>类型构造函数表示的值在第二定律的上下文中如何工作。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">SomeMonad</span> val) &gt;&gt;= return ≡ <span class="type">SomeMonad</span> val  <span class="comment">-- 'SomeMonad val'具有类型'm a'，就像`Law 2`第一个示例中的`m`一样</span></span><br><span class="line"></span><br><span class="line"><span class="type">NullaryMonadType</span> &gt;&gt;= return ≡ <span class="type">NullaryMonadType</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Law-3"><a href="#Law-3" class="headerlink" title="Law 3"></a>Law 3</h4><p>虽然前两条法律比较明确，但第三条法律可能更难理解。</p>
<p>这条定律规定，当一个<code>monadic</code>值<code>m</code>通过<code>(&gt;&gt;=)</code>传递给函数<code>f</code>，然后將该表达式的结果传递给<code>&gt;&gt;=g</code>時，<br>整个表达式完全等同于将<code>m</code>传递给一个<code>lambda</code>表达式，该<code>lambda</code>表达式接受一个参数<code>x</code>，并产出应用于<code>x</code>的函数<code>f</code>。<br>根据<code>bind</code>的定义，<code>f x</code>必须返回包装在同一个<code>monad</code>中的值。由于此属性，该表达式的结果值可以通过<code>(&gt;&gt;=)</code>传递给函数<code>g</code>，该函数也返回一个<code>monadic</code>值。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 'm'的类型为'm a'</span></span><br><span class="line"><span class="comment">-- 函数'f'和'g'类型分别為'(a -&gt; m b)'和'(b -&gt; m c)'</span></span><br><span class="line">(m &gt;&gt;= f) &gt;&gt;= g ≡ m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</span><br></pre></td></tr></table></figure></p>
<p>同样，可以用更明确的代码编写该定律。就像在<code>Law 2</code>的明确示例中一样，<code>m</code>已由<code>SomeMonad val</code>代替，以非常清楚地表明，<code>monadic</code>值可以有多个<code>components</code>(分量)。<br>尽管代码中的变化很小，但是更容易看到值(即<code>val</code>)与<code>lambda</code>表达式中的<code>x</code>对应。在将<code>(SomeMonad val)</code>通过<code>(&gt;&gt;=)</code>传递给<code>f</code>之后，函数<code>f</code>在<code>val</code>上运行，并返回仍封装在<code>SomeMonad</code>类型构造函数中的结果。</p>
<p>我们可以将此新值称为<code>SomeMonad newVal</code>。由于它仍然包裹在<code>monad</code>上下文中，因此可以将<code>SomeMonad newVal</code>通过绑定操作传递到函数<code>g</code>中。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="type">SomeMonad</span> val) &gt;&gt;= f) &gt;&gt;= g ≡ (<span class="type">SomeMonad</span> val) &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</span><br></pre></td></tr></table></figure>
<p>請看: <a href="http://wiki.haskell.org/Monad_laws" target="_blank" rel="noopener">Monad Laws</a></p>
<h3 id="Do-Notation-Do表示法"><a href="#Do-Notation-Do表示法" class="headerlink" title="Do Notation (Do表示法)"></a>Do Notation (Do表示法)</h3><p>haskell中的<code>Monadic</code>语法是以加糖的形式编写的，称为<code>do</code>符号。这种特殊语法的优点是它更容易编写，并且完全等同于<code>monad</code>操作的应用程序。根据以下规则递归定义脫糖:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将'f'绑定到a，然后继续对'm'进行脱糖</span></span><br><span class="line"><span class="title">do</span> &#123; a &lt;- f ; m &#125; ≡ f &gt;&gt;= \a -&gt; <span class="keyword">do</span> &#123; m &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 评估`f`，然后继续对'm'进行脱糖</span></span><br><span class="line"><span class="title">do</span> &#123; f ; m &#125; ≡ f &gt;&gt; <span class="keyword">do</span> &#123; m &#125;</span><br><span class="line"></span><br><span class="line"><span class="title">do</span> &#123; m &#125; ≡ m</span><br></pre></td></tr></table></figure></p>
<p>因此，通过应用脱糖规则，以下表达式是等效的:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">do</span></span><br><span class="line">  <span class="comment">-- 將f,g和h分別绑定到名称a，b和c。</span></span><br><span class="line">  <span class="comment">-- 然后将这些名称传递给`return`,</span></span><br><span class="line">  <span class="comment">-- 以确保所有值都包裹在适当的monad上下文中</span></span><br><span class="line">  a &lt;- f</span><br><span class="line">  b &lt;- g</span><br><span class="line">  c &lt;- h</span><br><span class="line">  return (a, b, c)</span><br><span class="line"></span><br><span class="line"><span class="title">do</span> &#123;</span><br><span class="line">    <span class="comment">-- 注意: &#123;&#125;和;字符在do符号中很少使用</span></span><br><span class="line">    a &lt;- f;</span><br><span class="line">    b &lt;- g;</span><br><span class="line">    c &lt;- h;</span><br><span class="line">    return (a, b, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">f</span> &gt;&gt;= \a -&gt;</span><br><span class="line">  g &gt;&gt;= \b -&gt;</span><br><span class="line">    h &gt;&gt;= \c -&gt;</span><br><span class="line">      return (a, b, c)</span><br></pre></td></tr></table></figure></p>
<p>如果将<code>bind</code>运算符写为<code>uncurried</code>(非咖喱)函数（这不是<code>Haskell</code>使用它的方式），则相同的<code>desugaring</code>操作可能看起来像以下带有<code>lambda</code>的嵌套绑定链。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">bindMonad</span>(f, lambda a:</span><br><span class="line">  bindMonad(g, lambda b:</span><br><span class="line">    bindMonad(h, lambda c:</span><br><span class="line">      returnMonad (a,b,c))))</span><br></pre></td></tr></table></figure></p>
<p>在<code>do-notation</code>中，上面的<a href="http://dev.stephendiehl.com/hask/#laws" target="_blank" rel="noopener">monad laws</a>等效地写成:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Law 1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> y &lt;- return x</span><br><span class="line">     f y</span><br><span class="line"></span><br><span class="line">= <span class="keyword">do</span> f x</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Law 2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> x &lt;- m</span><br><span class="line">     return x</span><br><span class="line"></span><br><span class="line">= <span class="keyword">do</span> m</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Law 3</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> b &lt;- <span class="keyword">do</span> a &lt;- m</span><br><span class="line">             f a</span><br><span class="line">     g b</span><br><span class="line"></span><br><span class="line">= <span class="keyword">do</span> a &lt;- m</span><br><span class="line">     b &lt;- f a</span><br><span class="line">     g b</span><br><span class="line"></span><br><span class="line">= <span class="keyword">do</span> a &lt;- m</span><br><span class="line">     <span class="keyword">do</span> b &lt;- f a</span><br><span class="line">        g b</span><br></pre></td></tr></table></figure></p>
<p>請看: <a href="http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14" target="_blank" rel="noopener">Haskell 2010: Do Expressions</a></p>
<h3 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h3><p><code>Maybe monad</code>是<code>monad</code>实例的最简单的第一个示例。<code>Maybe monad</code>對计算进行建模，该计算可能在计算过程中的任何时候失敗，无法产生值。</p>
<p><code>Maybe</code>类型具有两个值构造函数。第一个<code>Just</code>是一个表示成功计算的一元构造函数，第二个<code>Nothing</code>是一个表示失败的<code>nullary</code>(无效)构造函数。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Maybe</span> a = <span class="type">Nothing</span> | <span class="type">Just</span> a</span></span><br></pre></td></tr></table></figure></p>
<p><code>Maybe</code>的<code>monad</code>实例通过:在可能传递给<code>bind</code>操作的可能输入上(即<code>Nothing</code>或<code>Just x</code>)进行模式匹配来描述<code>Maybe</code>的<code>(&gt;&gt;=)</code>实现。</p>
<p>該实例声明还提供了<code>return</code>的实现，在这种情况下，它只是<code>Just</code>。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    <span class="comment">-- 'k'是一個具有(a -&gt; Maybe a)類型的函數</span></span><br><span class="line">    (<span class="type">Just</span> x) &gt;&gt;= k = k x</span><br><span class="line">    <span class="type">Nothing</span>  &gt;&gt;= k = <span class="type">Nothing</span></span><br><span class="line">    <span class="comment">-- Just的类型签名是(a -&gt; Maybe a)</span></span><br><span class="line">    <span class="comment">-- 换句话说，与上面的typeclass声明中的·return·类型极为相似。</span></span><br><span class="line">    return = <span class="type">Just</span></span><br></pre></td></tr></table></figure>
<p>以下代码显示了在<code>Maybe monad</code>中执行的一些简单操作。</p>
<p>在第一个示例中，值<code>Just 3</code>通过<code>(&gt;&gt;=)</code>传递给lambda函数<code>\x -&gt; return（x + 1)</code>。<br><code>x</code>是指<code>Just 3</code>的<code>Int</code>部分，我们可以在<code>lambda</code>表达式的后半部分使用<code>x</code>，其中<code>return (x + 1)</code>的值等于<code>Just 4</code>，表示一個成功的计算。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">Just</span> <span class="number">3</span>) &gt;&gt;= (\x -&gt; return (x + <span class="number">1</span>))</span><br><span class="line"><span class="comment">-- Just 4</span></span><br></pre></td></tr></table></figure></p>
<p>在第二个示例中，值<code>Nothing</code>通过<code>(&gt;&gt;=)</code>传递到与上一个示例相同的<code>lambda</code>函数。<br>但是，根据<code>Maybe Monad</code>实例，每当<code>Nothing</code>绑定到一个函数时，表达式的结果将为<code>Nothing</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Nothing</span> &gt;&gt;= (\x -&gt; return (x + <span class="number">1</span>))</span><br><span class="line"><span class="comment">-- Nothing</span></span><br></pre></td></tr></table></figure></p>
<p>下一個例子中，將<code>return</code>應用到<code>4</code>,並返回<code>Just 4</code>.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">return</span> <span class="number">4</span> :: <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="comment">-- Just 4</span></span><br></pre></td></tr></table></figure></p>
<p>下面的代码示例演示在<code>Maybe monad</code>中使用<code>do</code>表示法进行可能失败的加法运算。还提供了脫糖的示例。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">example1</span> :: <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">example1</span> = <span class="keyword">do</span></span><br><span class="line">  a &lt;- <span class="type">Just</span> <span class="number">3</span>    <span class="comment">-- Bind 3 to name a</span></span><br><span class="line">  b &lt;- <span class="type">Just</span> <span class="number">4</span>    <span class="comment">-- Bind 4 to name b</span></span><br><span class="line">  <span class="comment">-- 评估(a + b)，</span></span><br><span class="line">  <span class="comment">-- 然后使用'return'以确保结果在Maybe monad中，</span></span><br><span class="line">  <span class="comment">-- 以便满足类型签名</span></span><br><span class="line">  return $ a + b  <span class="comment">-- Just 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 這是脫糖操作，等同於example1</span></span><br><span class="line"><span class="title">desugared1</span> :: <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">desugared1</span> = <span class="type">Just</span> <span class="number">3</span> &gt;&gt;= \a -&gt;</span><br><span class="line">               <span class="type">Just</span> <span class="number">4</span> &gt;&gt;= \b -&gt;</span><br><span class="line">                 return $ a + b  <span class="comment">-- Just 7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">example2</span> :: <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">example2</span> = <span class="keyword">do</span></span><br><span class="line">  a &lt;- <span class="type">Just</span> <span class="number">3</span>   <span class="comment">-- Bind 3 to name a</span></span><br><span class="line">  b &lt;- <span class="type">Nothing</span>  <span class="comment">-- Bind Nothing to name b</span></span><br><span class="line">  <span class="comment">-- 由於Maybe monad中的加法实际上可以返回'Nothing',这个结果可能有些令人惊讶</span></span><br><span class="line">  <span class="comment">-- 出现此结果是因为其中一个值Nothing指示计算失败。</span></span><br><span class="line">  <span class="comment">-- 由于计算在过程中的某一步失败，因此整个计算失败，最终结果为'Nothing'。</span></span><br><span class="line">  return $ a + b  <span class="comment">-- Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 這是脫糖操作，等同於example2</span></span><br><span class="line"><span class="title">desugared2</span> :: <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">desugared2</span> = <span class="type">Just</span> <span class="number">3</span> &gt;&gt;= \a -&gt;</span><br><span class="line">               <span class="type">Nothing</span> &gt;&gt;= \b -&gt;</span><br><span class="line">                  return $ a + b</span><br><span class="line"><span class="comment">-- Nothing</span></span><br></pre></td></tr></table></figure></p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p><code>List monad</code>是<code>monad</code>实例的第二个最简单的示例。和往常一样，此<code>monad</code>同时实现<code>(&gt;&gt;=)</code>和<code>return</code>。<br><code>bind</code>的定义是，当列表<code>m</code>绑定到函数<code>f</code>时，结果是<code>map f</code>在列表<code>m</code>上的<code>concatenation</code>(串联)。<br><code>return</code>方法仅取一个值<code>x</code>并注入一个<code>singleton</code>列表<code>[x]</code>.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> [] <span class="keyword">where</span></span></span><br><span class="line">  m &gt;&gt;= f   =  concat (map f m)  <span class="comment">-- 'm' is a list</span></span><br><span class="line">  return x  =  [x]</span><br></pre></td></tr></table></figure>
<p>为了演示<code>List monad</code>的方法，我们将定义两个函数:<code>m</code>和<code>f</code>。<br><code>m</code>是一个简单列表，而<code>f</code>是一个函数，它接收单个<code>Int</code>參數并返回擁有兩個元素的列表<code>[1，0]</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">m</span> :: [<span class="type">Int</span>]</span><br><span class="line"><span class="title">m</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">f</span> :: <span class="type">Int</span> -&gt; [<span class="type">Int</span>]</span><br><span class="line"><span class="title">f</span> = \x -&gt; [<span class="number">1</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<p>评估过程如下:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">m</span> &gt;&gt;= f</span><br><span class="line">==&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] &gt;&gt;= \x -&gt; [<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">==&gt; concat (map (\x -&gt; [<span class="number">1</span>,<span class="number">0</span>]) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">==&gt; concat ([[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>]])</span><br><span class="line">==&gt; [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<p>Haskell中的列表<code>comprehension</code>语法可以根据列表<code>monad</code>来实现。<br>对于更明显的<code>monadic</code>实现，列表<code>comprehension</code>可以被视为语法糖。<br>示例<code>a</code>和<code>b</code>说明了这些用例。</p>
<p>第一个示例(<code>a</code>)说明了如何编写列表<code>comprehension</code>。<br>尽管语法一开始看起来很奇怪，但其中的某些元素可能看起来很熟悉。<br>例如，<code>&lt;-</code>的用法就像在<code>do</code>表示法中的<code>bind</code>(绑定): 它将列表的元素绑定到名称。</p>
<p>但是，有一个主要区别是显而易见的：例子<code>a</code>似乎缺少对<code>return</code>的调用。不过，不用担心，<code>[]</code>扮演了这个角色。编译器可以轻松地将此语法脫糖为显式调用<code>return</code>。此外，它还可以提醒用户该计算是在<code>List monad</code>中进行的。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">a</span> = [</span><br><span class="line">      f x y |   <span class="comment">-- 对应于示例b中的'f x y'</span></span><br><span class="line">      x &lt;- xs,</span><br><span class="line">      y &lt;- ys,</span><br><span class="line">      x == y     <span class="comment">-- 对应于示例b中的'guard $ x == y'</span></span><br><span class="line">    ]</span><br></pre></td></tr></table></figure></p>
<p>第二个示例(<code>b</code>)显示了用<code>do</code>表示符重写的列表<code>comprehension</code>:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 与a相同</span></span><br><span class="line"><span class="title">b</span> = <span class="keyword">do</span></span><br><span class="line">  x &lt;- xs</span><br><span class="line">  y &lt;- ys</span><br><span class="line">  guard $ x == y  <span class="comment">-- 对应于示例a中的'x == y'</span></span><br><span class="line">  return $ f x y  <span class="comment">-- 对应于示例a中的'[]' and 'f x y'</span></span><br></pre></td></tr></table></figure></p>
<p>最后的例子是<code>List</code>单子的进一步说明。<br>下面的每个函数都返回一个三元组列表，其中包含三个列表的可能组合，这三个列表绑定了名称<code>a</code>,<code>b</code>和<code>c</code>。<br>注意: 在元组的<code>a</code>位置只能使用绑定到<code>a</code>的列表中的值; 对于绑定到<code>b</code>和<code>c</code>的列表也是如此。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">example</span> :: [(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)]</span><br><span class="line"><span class="title">example</span> = <span class="keyword">do</span></span><br><span class="line">  a &lt;- [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">  b &lt;- [<span class="number">10</span>,<span class="number">20</span>]</span><br><span class="line">  c &lt;- [<span class="number">100</span>,<span class="number">200</span>]</span><br><span class="line">  return (a,b,c)</span><br><span class="line"><span class="comment">-- [(1,10,100),(1,10,200),(1,20,100),(1,20,200),(2,10,100),(2,10,200),(2,20,100),(2,20,200)]</span></span><br><span class="line"></span><br><span class="line"><span class="title">desugared</span> :: [(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)]</span><br><span class="line"><span class="title">desugared</span> = [<span class="number">1</span>, <span class="number">2</span>] &gt;&gt;= \a -&gt;</span><br><span class="line">              [<span class="number">10</span>, <span class="number">20</span>] &gt;&gt;= \b -&gt;</span><br><span class="line">                [<span class="number">100</span>, <span class="number">200</span>] &gt;&gt;= \c -&gt;</span><br><span class="line">                  return (a, b, c)</span><br><span class="line"><span class="comment">-- [(1,10,100),(1,10,200),(1,20,100),(1,20,200),(2,10,100),(2,10,200),(2,20,100),(2,20,200)]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p><code>IO</code>可能是<code>Haskell中</code>最著名的例子(一种<code>monad</code>)。</p>
<p><code>IO a</code>类型的值是一种计算，当执行时，它会在返回<code>a</code>类型的值之前执行一些<code>I/O</code>。这些计算称为<code>actions</code>(动作)。<br>在<code>main</code>中执行的<code>IO</code>动作是程序可以在外部世界上操作或访问信息的方式。<code>IO</code>操作使程序可以执行许多操作，包括但不限于:</p>
<ul>
<li>将字符串打印到终端</li>
<li>从终端读取和分析输入</li>
<li>读取或写入系统上的文件</li>
<li>建立到远程计算机的ssh连接</li>
<li>从无线电天线接收信号进行处理</li>
</ul>
<p>将<code>I/O</code>概念化为<code>monad</code>，使开发人员可以访问程序外部的信息，但可以使用纯函數对数据进行操作。以下示例将说明我们如何使用<code>IO</code>操作和<code>IO</code>值来接收来自<code>stdin</code>的输入并将其打印到<code>stdout</code>。</p>
<p>在<code>Haskell</code>中执行<code>I/O</code>的最直接有用的函數可能是<code>putStrLn</code>。此函数接收<code>String</code>并返回<code>IO ()</code>。<br>在<code>main</code>中调用它將会把<code>String</code>打印到<code>stdout</code>，后跟换行符。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">putStrLn</span> :: <span class="type">String</span> -&gt; <span class="type">IO</span> ()</span><br></pre></td></tr></table></figure>
<p>这是一些向终端打印內容的代码。执行<code>putStrLn</code>的第一次调用，导致将<code>String</code>打印到<code>stdout</code>。其结果绑定到丢弃其参数的<code>lambda</code>表达式，然后执行下一个<code>putStrLn</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = putStrLn <span class="string">"Vesihiisi sihisi hississäään."</span> &gt;&gt;=</span><br><span class="line">         \_ -&gt; putStrLn <span class="string">"Or in English: 'The water devil was hissing in her elevator'."</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Sugared code, written with do notation</span></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span> putStrLn <span class="string">"Vesihiisi sihisi hississäään."</span></span><br><span class="line">          putStrLn <span class="string">"Or in English: 'The water devil was hissing in her elevator'."</span></span><br></pre></td></tr></table></figure></p>
<p>另一个有用的函数是<code>getLine</code>，其类型为<code>IO String</code>。此函数从<code>stdin</code>获取一行输入。然后，开发人员可以将此行绑定到名称，以便对程序中的值进行操作。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">getLine</span> :: <span class="type">IO</span> <span class="type">String</span></span><br></pre></td></tr></table></figure></p>
<p>下面的代码演示了这两个函數的简单组合以及简化的<code>IO</code>代码。首先，<code>putStrLn</code>将一个<code>String</code>打印到<code>stdout</code>，要求用户提供其名称，结果绑定到一个<code>lambda</code>上，该<code>lambda</code>放弃它的参数。然后，执行<code>getLine</code>，向用户提供输入其名称的提示。接下来，将所得的<code>IO</code>字符串绑定到<code>name</code>，并传递给<code>putStrLn</code>。最后，程序将名称打印到终端。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span> putStrLn <span class="string">"What is your name: "</span></span><br><span class="line">          name &lt;- getLine</span><br><span class="line">          putStrLn name</span><br></pre></td></tr></table></figure></p>
<p>下面代码块是上一个示例的经过脫糖的等效代码: 但是，<code>(&gt;&gt;=)</code>的使用是明确的:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = putStrLn <span class="string">"What is your name:"</span> &gt;&gt;=</span><br><span class="line">       \_    -&gt; getLine &gt;&gt;=</span><br><span class="line">       \name -&gt; putStrLn name</span><br></pre></td></tr></table></figure></p>
<p>最后一个示例的执行方式与前两个示例相同。但是，此示例使用特別的<code>(&gt;&gt;)</code>运算符代替将结果绑定到丢弃其参数的<code>lambda</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = putStrLn <span class="string">"What is your name: "</span> &gt;&gt; (getLine &gt;&gt;= (\name -&gt; putStrLn name))</span><br></pre></td></tr></table></figure></p>
<p>請看: <a href="http://www.haskell.org/onlinereport/haskell2010/haskellch7.html" target="_blank" rel="noopener">Haskell 2010: Basic/Input Output</a></p>
<h3 id="What’s-the-point-有什么意义"><a href="#What’s-the-point-有什么意义" class="headerlink" title="What’s the point? (有什么意义?)"></a>What’s the point? (有什么意义?)</h3><p>虽然很难（如果不是不可能的话）, 去接触、查看或以其他方式与<code>monad</code>进行物理交互，但是这个结构对程序员有一些非常有趣的含义。例如，考虑非直观的事实，我们现在有一个<code>uniform</code>(统一)的接口来讨论三种非常不同的，但基本的编程思想: <code>Failure</code>,<code>Collections</code>和<code>Effects</code>.</p>
<p>让我们写下一个名为<code>sequence</code>的新函数，它<code>folds</code>(折叠)函數<code>mcons</code>到单子计算<code>list</code>上.<br>我们可以认为<code>mcons</code>类似于列表构造函数(即<code>(a:b:[])</code>)，但它通过<code>bind</code>从两个<code>monadic</code>值<code>(p，q)</code>中提取两个列表元素.<br>然後，将绑定值与列表构造器<code>:</code>联接在一起，最后再通过<code>return</code>在适当的单子上下文中重新包装。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sequence</span> :: <span class="type">Monad</span> m =&gt; [m a] -&gt; m [a]</span><br><span class="line"><span class="title">sequence</span> = foldr mcons (return [])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- </span></span><br><span class="line"><span class="title">mcons</span> :: <span class="type">Monad</span> m =&gt; m t -&gt; m [t] -&gt; m [t]</span><br><span class="line"><span class="title">mcons</span> p q = <span class="keyword">do</span></span><br><span class="line">  x &lt;- p  <span class="comment">-- 'x'表示单個值, [m a]中的每個值將會傳遞給p</span></span><br><span class="line">  y &lt;- q  <span class="comment">-- 初始值,m []</span></span><br><span class="line">  <span class="comment">-- y是列表,因此,可以在其前面加上x</span></span><br><span class="line">  return (x:y)</span><br></pre></td></tr></table></figure></p>
<p>就上述每个单子而言，此函數有什麼意义？</p>
<h4 id="Maybe-1"><a href="#Maybe-1" class="headerlink" title="Maybe"></a>Maybe</h4><p>在<a href="http://dev.stephendiehl.com/hask/#maybe" target="_blank" rel="noopener">Maybe context</a>中对值列表进行<code>Sequencing</code>使我们能够收集可能会失败的一系列计算的结果。但是，<code>sequence</code>仅在每次计算成功时才产生<code>aggregated</code>(合计)值。换句话说，即使传递给<code>sequence</code>的初始列表中的<code>Maybe</code>值之一是<code>Nothing</code>，<code>sequence</code>的结果也将是<code>Nothing</code>.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sequence</span> :: [<span class="type">Maybe</span> a] -&gt; <span class="type">Maybe</span> [a]</span><br><span class="line"><span class="title">sequence</span> [<span class="type">Just</span> <span class="number">3</span>, <span class="type">Just</span> <span class="number">4</span>] <span class="comment">-- Just [3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 由于结果之一为Nothing，因此整个计算失败</span></span><br><span class="line"><span class="title">sequence</span> [<span class="type">Just</span> <span class="number">3</span>, <span class="type">Just</span> <span class="number">4</span>, <span class="type">Nothing</span>] <span class="comment">-- Nothing</span></span><br></pre></td></tr></table></figure></p>
<h4 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h4><p><a href="http://dev.stephendiehl.com/hask/#list" target="_blank" rel="noopener">list monad</a>的<code>bind</code>操作形成两个操作数中元素的成对列表。<br>因此，将<code>mcons</code>中包含的绑定<code>folding</code>(折叠)到具有<code>sequence</code>的列表列表上，可以实现任意数量列表的通用笛卡尔积。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sequence</span> :: [[a]] -&gt; [[a]]</span><br><span class="line"><span class="title">sequence</span> [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]]</span><br><span class="line"><span class="comment">-- [[1,10],[1,20],[1,30],[2,10],[2,20],[2,30],[3,10],[3,20],[3,30]]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="IO-1"><a href="#IO-1" class="headerlink" title="IO"></a>IO</h4><p>在<a href="http://dev.stephendiehl.com/hask/#io" target="_blank" rel="noopener">IO context</a>上下文中应用<code>sequence</code>仍然会产生不同的结果。函数获取<code>IO actions</code>的列表，按顺序执行这些操作，然后按顺序返回结果值的列表。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sequence</span> :: [<span class="type">IO</span> a] -&gt; <span class="type">IO</span> [a]</span><br><span class="line"><span class="title">sequence</span> [getLine, getLine, getLine]</span><br><span class="line"><span class="comment">-- a</span></span><br><span class="line"><span class="comment">-- b</span></span><br><span class="line"><span class="comment">-- 9</span></span><br><span class="line"><span class="comment">-- ["a", "b", "9"] 所有输入作为IO [String]返回到列表中.</span></span><br></pre></td></tr></table></figure></p>
<p>因此，我们有了它，通常彼此独立定义的三个基本计算概念(<code>Failure</code>,<code>Collections</code>和<code>Effects</code>)实际上都共享这种相似的结构。可以对这种统一模式进行抽象，然后将其重复使用以构建适用于所有当前和将来实现的更高抽象。如果您想要了解<code>monad</code>的动机，就是这样！这些见解是我所希望知道的关于<code>monad</code>回顾的本质。</p>
<p>請看: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#g:4" target="_blank" rel="noopener">Control.Monad</a></p>
<h3 id="Reader-Monad"><a href="#Reader-Monad" class="headerlink" title="Reader Monad"></a>Reader Monad</h3><p><code>reader monad</code>允許我们可以在<code>monadic</code>上下文中访问共享的不可变状态。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ask</span> :: <span class="type">Reader</span> r r</span><br><span class="line"><span class="title">asks</span> :: (r -&gt; a) -&gt; <span class="type">Reader</span> r a</span><br><span class="line"><span class="title">local</span> :: (r -&gt; r) -&gt; <span class="type">Reader</span> r a -&gt; <span class="type">Reader</span> r a</span><br><span class="line"><span class="title">runReader</span> :: <span class="type">Reader</span> r a -&gt; r -&gt; a</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Control.Monad.Reader</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">MyContext</span> = <span class="type">MyContext</span></span></span><br><span class="line">  &#123; foo :: <span class="type">String</span></span><br><span class="line">  , bar :: <span class="type">Int</span></span><br><span class="line">  &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">computation</span> :: <span class="type">Reader</span> <span class="type">MyContext</span> (<span class="type">Maybe</span> <span class="type">String</span>)</span><br><span class="line"><span class="title">computation</span> = <span class="keyword">do</span></span><br><span class="line">  n &lt;- asks bar</span><br><span class="line">  x &lt;- asks foo</span><br><span class="line">  <span class="keyword">if</span> n &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">then</span> return (<span class="type">Just</span> x)</span><br><span class="line">    <span class="keyword">else</span> return <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="title">ex1</span> :: <span class="type">Maybe</span> <span class="type">String</span></span><br><span class="line"><span class="title">ex1</span> = runReader computation $ <span class="type">MyContext</span> <span class="string">"hello"</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="title">ex2</span> :: <span class="type">Maybe</span> <span class="type">String</span></span><br><span class="line"><span class="title">ex2</span> = runReader computation $ <span class="type">MyContext</span> <span class="string">"haskell"</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p><code>Reader monad</code>的簡單實現:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Reader r a 中的 r 类型就是给定数据的类型，可以从中提取想要的信息</span></span><br><span class="line"><span class="comment">-- 类型 r 的值称为环境，即从该环境下读出类型为 a 值来</span></span><br><span class="line"><span class="comment">-- 比如，给定了一个很长的字符串，如果需要读取 它的长度，那么读取器 monad 的类型就应当为 Reader String Int</span></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Reader</span> r a = <span class="type">Reader</span> &#123; <span class="title">runReader</span> :: <span class="title">r</span> -&gt; <span class="title">a</span> &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> (<span class="type">Reader</span> <span class="title">r</span>) <span class="keyword">where</span></span></span><br><span class="line">  return a = <span class="type">Reader</span> $ \_ -&gt; a</span><br><span class="line">  <span class="comment">-- (&gt;&gt;=) :: Reader r a -&gt; (a -&gt; Reader r b) -&gt; Reader r b</span></span><br><span class="line">  <span class="comment">-- (&gt;&gt;=) 运算符在给定的环境r下执行m后，将结果输入函数k中。</span></span><br><span class="line">  m &gt;&gt;= k  = <span class="type">Reader</span> $ \r -&gt; runReader (k (runReader m r)) r</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 獲取當前环境s</span></span><br><span class="line"><span class="title">ask</span> :: <span class="type">Reader</span> r r</span><br><span class="line"><span class="title">ask</span> = <span class="type">Reader</span> id</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 從指定环境中取值</span></span><br><span class="line"><span class="title">asks</span> :: (r -&gt; a) -&gt; <span class="type">Reader</span> r a</span><br><span class="line"><span class="title">asks</span> f = <span class="type">Reader</span> f</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在修改后的环境中执行计算</span></span><br><span class="line"><span class="title">local</span> :: (r -&gt; r) -&gt; <span class="type">Reader</span> r a -&gt; <span class="type">Reader</span> r a</span><br><span class="line"><span class="title">local</span> f m = <span class="type">Reader</span> $ runReader m . f</span><br></pre></td></tr></table></figure></p>
<h3 id="Writer-Monad"><a href="#Writer-Monad" class="headerlink" title="Writer Monad"></a>Writer Monad</h3><p><code>writer monad</code>使我们能够从<code>monadic</code>上下文中<code>emit</code>(發出)惰性的值流。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">tell</span> :: w -&gt; <span class="type">Writer</span> w ()</span><br><span class="line"><span class="title">execWriter</span> :: <span class="type">Writer</span> w a -&gt; w</span><br><span class="line"><span class="title">runWriter</span> :: <span class="type">Writer</span> w a -&gt; (a, w)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Control.Monad.Writer</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">MyWriter</span> = <span class="type">Writer</span> [<span class="type">Int</span>] <span class="type">String</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">example</span> :: <span class="type">MyWriter</span></span><br><span class="line"><span class="title">example</span>  = <span class="keyword">do</span></span><br><span class="line">  tell [<span class="number">1.</span><span class="number">.3</span>]</span><br><span class="line">  tell [<span class="number">3.</span><span class="number">.5</span>]</span><br><span class="line">  return <span class="string">"foo"</span></span><br><span class="line"></span><br><span class="line"><span class="title">output</span> :: (<span class="type">String</span>, [<span class="type">Int</span>])</span><br><span class="line"><span class="title">output</span> = runWriter example</span><br><span class="line"><span class="comment">-- ("foo", [1, 2, 3, 3, 4, 5])</span></span><br></pre></td></tr></table></figure></p>
<p><code>Writer monad</code>的簡單實現:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.Monoid</span><br><span class="line"></span><br><span class="line"><span class="comment">-- w為記錄器，a為值</span></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Writer</span> w a = <span class="type">Writer</span> &#123; <span class="title">runWriter</span> :: (<span class="title">a</span>, <span class="title">w</span>) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> w =&gt; <span class="type">Monad</span> (<span class="type">Writer</span> <span class="title">w</span>) <span class="keyword">where</span></span></span><br><span class="line">  return a = <span class="type">Writer</span> (a, mempty)</span><br><span class="line">  <span class="comment">-- (&gt;&gt;=) :: Writer w a -&gt; (a -&gt; Writer w b) -&gt; Writer w b</span></span><br><span class="line">  m &gt;&gt;= k  = <span class="type">Writer</span> $ <span class="keyword">let</span></span><br><span class="line">      (a, w)  = runWriter m</span><br><span class="line">      (b, w') = runWriter (k a)</span><br><span class="line">      <span class="keyword">in</span> (b, w `mappend` w')</span><br><span class="line"></span><br><span class="line"><span class="title">execWriter</span> :: <span class="type">Writer</span> w a -&gt; w</span><br><span class="line"><span class="title">execWriter</span> m = snd (runWriter m)</span><br><span class="line"></span><br><span class="line"><span class="title">tell</span> :: w -&gt; <span class="type">Writer</span> w ()</span><br><span class="line"><span class="title">tell</span> w = <span class="type">Writer</span> ((), w)</span><br></pre></td></tr></table></figure></p>
<p>这个实现是懒惰的，因此必须注意，实际上只想生成一个<code>thunk</code>流。大多数情况下，<code>lazy writer</code>不适合使用，而是通过在<code>StateT monad</code>中嵌入一些<code>monomial</code>(单值/单项式的)对象或使用严格版本来实现等效结构。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Monad.Writer.Strict</span><br></pre></td></tr></table></figure></p>
<h3 id="State-Monad"><a href="#State-Monad" class="headerlink" title="State Monad"></a>State Monad</h3><p><code>State monad</code>允许有状态<code>monadic</code>上下文中的函数访问和修改共享状态。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">runState</span>  :: <span class="type">State</span> s a -&gt; s -&gt; (a, s)</span><br><span class="line"><span class="title">evalState</span> :: <span class="type">State</span> s a -&gt; s -&gt; a</span><br><span class="line"><span class="title">execState</span> :: <span class="type">State</span> s a -&gt; s -&gt; s</span><br><span class="line"><span class="keyword">import</span> Control.Monad.State</span><br><span class="line"></span><br><span class="line"><span class="title">test</span> :: <span class="type">State</span> <span class="type">Int</span> <span class="type">Int</span></span><br><span class="line"><span class="title">test</span> = <span class="keyword">do</span></span><br><span class="line">  put <span class="number">3</span></span><br><span class="line">  modify (+<span class="number">1</span>)</span><br><span class="line">  get</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = print $ execState test <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>状态<code>monad</code>常常被错误地描述为不纯净，但事实上它是完全纯净的，通过显式传递状态也可以达到同样的效果。<code>State monad</code>的简单实现只需要几行代码:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">State</span> s a = <span class="type">State</span> &#123; <span class="title">runState</span> :: <span class="title">s</span> -&gt; (<span class="title">a</span>,<span class="title">s</span>) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> (<span class="type">State</span> <span class="title">s</span>) <span class="keyword">where</span></span></span><br><span class="line">  return a = <span class="type">State</span> $ \s -&gt; (a, s)</span><br><span class="line"></span><br><span class="line">  <span class="type">State</span> act &gt;&gt;= k = <span class="type">State</span> $ \s -&gt;</span><br><span class="line">    <span class="keyword">let</span> (a, s') = act s</span><br><span class="line">    <span class="keyword">in</span> runState (k a) s'</span><br><span class="line"></span><br><span class="line"><span class="title">get</span> :: <span class="type">State</span> s s</span><br><span class="line"><span class="title">get</span> = <span class="type">State</span> $ \s -&gt; (s, s)</span><br><span class="line"></span><br><span class="line"><span class="title">put</span> :: s -&gt; <span class="type">State</span> s ()</span><br><span class="line"><span class="title">put</span> s = <span class="type">State</span> $ \_ -&gt; ((), s)</span><br><span class="line"></span><br><span class="line"><span class="title">modify</span> :: (s -&gt; s) -&gt; <span class="type">State</span> s ()</span><br><span class="line"><span class="title">modify</span> f = get &gt;&gt;= \x -&gt; put (f x)</span><br><span class="line"></span><br><span class="line"><span class="title">evalState</span> :: <span class="type">State</span> s a -&gt; s -&gt; a</span><br><span class="line"><span class="title">evalState</span> act = fst . runState act</span><br><span class="line"></span><br><span class="line"><span class="title">execState</span> :: <span class="type">State</span> s a -&gt; s -&gt; s</span><br><span class="line"><span class="title">execState</span> act = snd . runState act</span><br></pre></td></tr></table></figure></p>
<h3 id="Monad-Tutorials"><a href="#Monad-Tutorials" class="headerlink" title="Monad Tutorials"></a>Monad Tutorials</h3><p>已经编写了这么多<code>monad</code>教程，以至于产生了一个问题：什么使<code>monads</code>在初学<code>Haskell</code>时如此困难？我认为这是三个方面的原因:</p>
<ul>
<li><p>1.关于脱糖的间接作用有几个层次(<code>There are several levels on indirection with desugaring.</code>)。</p>
<p>我们所写的许多<code>haskell</code>代碼都经过了彻底的重新编排，并在幕后转化为一种全新的形式。<br>大多数<code>monad</code>教程不会手动展开<code>do-sugar</code>。<br>这使得初学者认为<code>monad</code>是一种在代码中嵌入伪命令式语言的方法，并进一步助长了这样一种误解，即像<code>IO</code>这样的特定实例在其<code>full generality</code>(全部方面)都是<code>monad</code>。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  x &lt;- getLine</span><br><span class="line">  putStrLn x</span><br><span class="line">  return ()</span><br></pre></td></tr></table></figure>
<p>能够手动脱糖对理解至关重要。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main =</span><br><span class="line">  getLine &gt;&gt;= \x -&gt;</span><br><span class="line">    putStrLn x &gt;&gt;= \_ -&gt;</span><br><span class="line">      return ()</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.用于高阶函数的非对称二进制中缀运算符在其他语言中并不常见。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&gt;&gt;=) :: <span class="type">Monad</span> m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</span><br></pre></td></tr></table></figure>
<p>在运算符的左侧，我们有一个<code>m a</code>，在右侧，我们有<code>a -&gt; m b</code>。尽管某些语言确实具有中缀运算符，而这些运算符本身就是高阶函数，但这种情况仍然很少见。</p>
<p>因此，对于一个已脫糖的函数,<code>(&gt;&gt;=)</code>运算符实际上是通过将函数组合在一起来构建一个更大的函数，这可能会令人困惑。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> =</span><br><span class="line">  getLine &gt;&gt;= \x -&gt;</span><br><span class="line">    putStrLn &gt;&gt;= \_ -&gt;</span><br><span class="line">      return ()</span><br></pre></td></tr></table></figure>
<p>以前缀形式编写，它变得更易于消化。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> =</span><br><span class="line">  (&gt;&gt;=) getLine (\x -&gt;</span><br><span class="line">    (&gt;&gt;=) putStrLn (\_ -&gt;</span><br><span class="line">          return ()</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>也许从其他语言中完全删除操作符可能更直观。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = bind getLine (\x -&gt; bind putStrLn (\_ -&gt; return ()))</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    bind x y = x &gt;&gt;= y</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.<code>Ad-hoc</code>(特定)多态性在其他语言中并不常见。</p>
<p>如果不熟悉类型推断，<code>Haskell</code>的重载实现可能是不直观的。它是从用户那里抽象出来的，但是<code>(&gt;&gt;=)</code>或<code>bind</code>函数实际上是三个参数的函数，带有额外的<code>typeclass dictionary</code>参数(<code>$dMonad</code>)隐式地缠绕在周围。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> $dMonad = bind $dMonad getLine (\x -&gt; bind $dMonad putStrLn (\_ -&gt; return $dMonad ()))</span><br></pre></td></tr></table></figure>
<p>除非<code>monad</code>类的参数与一个具体的类实例<code>unified</code>(统一)(通过<code>inference</code>推理)，否则<code>instance dictionary ($dMonadIO)</code>会被整个拼接在一起。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = bind $dMonadIO getLine (\x -&gt; bind $dMonadIO putStrLn (\_ -&gt; return $dMonadIO ()))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>现在，所有这些转换都是微不足道的，一旦我们理解了它们，它们通常不会被讨论。<br>在我看来，<code>monad</code>教程的基本谬误并不是说<code>monad</code>的直觉很难传达(也不需要隐喻!)但是，新手们经常在对点(1)(2)和(3)的理解不完全的情况下来到<code>monads</code>，然后发现一个简单的事实，即<code>monads</code>是<code>haskell</code>构造的第一个例子，<code>haskell</code>构造是这三者的<code>confluence</code>(融合)。</p>
<p>請看: <a href="http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/" target="_blank" rel="noopener">Monad Tutorial Fallacy</a></p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
        <span><a href="https://serokell.io/blog">serokell</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/blog/js/index.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/blog/js/gitment.js"></script>
<script>
    var gitment = new Gitment({
        id: 'Haskell-Monads',
        owner: 'limengyu1990',
        repo: 'hexo-blog',
        oauth: {
            client_id: '7cfc73dd62b57f07ed83',
            client_secret: 'dd03b7e54aadf0d81e4c9c93e23a41272bcfcfa1',
        },
    })
    gitment.render('comment-container')
</script>

</html>
