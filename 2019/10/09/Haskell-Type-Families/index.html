<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        Haskell-Type-Families - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 不会Haskell的Scala写不出好的JavaScript。 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>不负如来不负卿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#MultiParam-Typeclasses"><span class="toc-text">MultiParam Typeclasses</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Type-Families"><span class="toc-text">Type Families</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Injectivity-內射性"><span class="toc-text">Injectivity(內射性)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Roles"><span class="toc-text">Roles</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mono-traversable-单行遍历"><span class="toc-text">Mono-traversable(单行遍历)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NonEmpty"><span class="toc-text">NonEmpty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Manual-Proofs-手工證明"><span class="toc-text">Manual Proofs (手工證明)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constraint-Kinds-约束种类"><span class="toc-text">Constraint Kinds (约束种类)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypeFamilyDependencies"><span class="toc-text">TypeFamilyDependencies</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 不会Haskell的Scala写不出好的JavaScript。 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Haskell-Type-Families
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-10-09 10:52:20</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/blog/tags/#Wish-Knew" title="Wish-Knew">Wish-Knew</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Haskell" title="Haskell">Haskell</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Type-Families" title="Type-Families">Type-Families</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p><a href="http://dev.stephendiehl.com/hask/#type-families" target="_blank" rel="noopener">原文</a></p>
</blockquote>
<h3 id="MultiParam-Typeclasses"><a href="#MultiParam-Typeclasses" class="headerlink" title="MultiParam Typeclasses"></a>MultiParam Typeclasses</h3><p>原始<code>Haskell 98</code>类型类的解析是通过非常简单的上下文约简来进行的，该上下文约简可以最大程度地减少谓词之间的相互依赖性，解析超类，并将类型简化为普通形式。例如：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">Eq</span> [a], <span class="type">Ord</span> [a]) =&gt; [a]</span><br><span class="line">==&gt; <span class="type">Ord</span> a =&gt; [a]</span><br></pre></td></tr></table></figure></p>
<p>如果单个参数<code>typeclass</code>表示类型的属性(即,它在类中还是不在<code>class</code>中),则多参数<code>typeclass</code>表示类型之间的关系。例如，如果我们要表达这种关系，则可以将一个类型转换为另一种类型，则可以使用类似以下的类:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE MultiParamTypeClasses #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Char</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Convertible</span> a b <span class="keyword">where</span></span></span><br><span class="line">  convert :: a -&gt; b</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Convertible</span> <span class="type">Int</span> <span class="type">Integer</span> <span class="keyword">where</span></span></span><br><span class="line">  convert = toInteger</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Convertible</span> <span class="type">Int</span> <span class="type">Char</span> <span class="keyword">where</span></span></span><br><span class="line">  convert = chr</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Convertible</span> <span class="type">Char</span> <span class="type">Int</span> <span class="keyword">where</span></span></span><br><span class="line">  convert = ord</span><br></pre></td></tr></table></figure></p>
<p>当然，现在我们的<code>Convertible Int</code>实例不再是唯一的，<br>因此，不再存在一个很好的过程来仅根据<code>a</code>来确定<code>b</code>的推断类型。<br>为了解决这个问题，让我们添加一个函數依赖项<code>a -&gt; b</code>,它告诉<code>GHC</code>实例<code>a</code>唯一地确定了<code>b</code>可以成为的实例。因此，我们将看到将<code>Int</code>与<code>Integer</code>和<code>Char</code>都衝突关联的两个实例。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE MultiParamTypeClasses #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FunctionalDependencies #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Char</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Convertible</span> a b | a -&gt; b <span class="keyword">where</span></span></span><br><span class="line">  convert :: a -&gt; b</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Convertible</span> <span class="type">Int</span> <span class="type">Char</span> <span class="keyword">where</span></span></span><br><span class="line">  convert = chr</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Convertible</span> <span class="type">Char</span> <span class="type">Int</span> <span class="keyword">where</span></span></span><br><span class="line">  convert = ord</span><br><span class="line"></span><br><span class="line"><span class="type">Functional</span> dependencies conflict between <span class="keyword">instance</span> declarations:</span><br><span class="line"><span class="class">  <span class="keyword">instance</span> <span class="type">Convertible</span> <span class="type">Int</span> <span class="type">Integer</span></span></span><br><span class="line"><span class="class">  <span class="keyword">instance</span> <span class="type">Convertible</span> <span class="type">Int</span> <span class="type">Char</span></span></span><br></pre></td></tr></table></figure></p>
<p>现在，有一个更简单的过程来唯一地确定实例，并且多参数<code>typeclass</code>变得更加可用和可推断。<br>有效的函數依赖<code>| a-&gt; b</code>表示我们不能使用相同的<code>a</code>但不同的<code>b</code>定义多个多参数<code>typeclass</code>实例。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">λ: convert (<span class="number">42</span> :: <span class="type">Int</span>)</span><br><span class="line">'*'</span><br><span class="line">λ: convert '*'</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure></p>
<p>现在，让事情变得不那么简单。<br>启用<code>UndecidableInstances</code>会放宽对上下文<code>reduction</code>(缩减)的约束，这种约束只能使该类的约束在结构上小于其头部。<br>结果，隐式计算现在可以在类型类实例搜索中进行。<br>结合<code>Peano</code>数字的类型级别表示，我们发现我们可以在类型级别对基本算术进行编码。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleContexts #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleInstances #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE MultiParamTypeClasses #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FunctionalDependencies #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE UndecidableInstances #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Z</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">S</span> n</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Zero</span>  = <span class="type">Z</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">One</span>   = <span class="type">S</span> <span class="type">Zero</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Two</span>   = <span class="type">S</span> <span class="type">One</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Three</span> = <span class="type">S</span> <span class="type">Two</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Four</span>  = <span class="type">S</span> <span class="type">Three</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">zero</span> :: <span class="type">Zero</span></span><br><span class="line"><span class="title">zero</span> = undefined</span><br><span class="line"></span><br><span class="line"><span class="title">one</span> :: <span class="type">One</span></span><br><span class="line"><span class="title">one</span> = undefined</span><br><span class="line"></span><br><span class="line"><span class="title">two</span> :: <span class="type">Two</span></span><br><span class="line"><span class="title">two</span> = undefined</span><br><span class="line"></span><br><span class="line"><span class="title">three</span> :: <span class="type">Three</span></span><br><span class="line"><span class="title">three</span> = undefined</span><br><span class="line"></span><br><span class="line"><span class="title">four</span> :: <span class="type">Four</span></span><br><span class="line"><span class="title">four</span> = undefined</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Eval</span> a <span class="keyword">where</span></span></span><br><span class="line">  eval :: a -&gt; <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Eval</span> <span class="type">Zero</span> <span class="keyword">where</span></span></span><br><span class="line">  eval _ = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Eval</span> n =&gt; <span class="type">Eval</span> (<span class="type">S</span> <span class="title">n</span>) <span class="keyword">where</span></span></span><br><span class="line">  eval m = <span class="number">1</span> + eval (prev m)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Pred</span> a b | a -&gt; b <span class="keyword">where</span></span></span><br><span class="line">  prev :: a -&gt; b</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Pred</span> <span class="type">Zero</span> <span class="type">Zero</span> <span class="keyword">where</span></span></span><br><span class="line">  prev = undefined</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Pred</span> (<span class="type">S</span> <span class="title">n</span>) n <span class="keyword">where</span></span></span><br><span class="line">  prev = undefined</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Add</span> a b c | a b -&gt; c <span class="keyword">where</span></span></span><br><span class="line">  add :: a -&gt; b -&gt; c</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Add</span> <span class="type">Zero</span> a a <span class="keyword">where</span></span></span><br><span class="line">  add = undefined</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Add</span> a b c =&gt; <span class="type">Add</span> (<span class="type">S</span> <span class="title">a</span>) b (<span class="type">S</span> <span class="title">c</span>) <span class="keyword">where</span></span></span><br><span class="line">  add = undefined</span><br><span class="line"></span><br><span class="line"><span class="title">f</span> :: <span class="type">Three</span></span><br><span class="line"><span class="title">f</span> = add one two</span><br><span class="line"></span><br><span class="line"><span class="title">g</span> :: <span class="type">S</span> (<span class="type">S</span> (<span class="type">S</span> (<span class="type">S</span> <span class="type">Z</span>)))</span><br><span class="line"><span class="title">g</span> = add two two</span><br><span class="line"></span><br><span class="line"><span class="title">h</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">h</span> = eval (add three four)</span><br></pre></td></tr></table></figure></p>
<p>如果类型类的上下文看上去与<code>Prolog</code>相似，那么您没看错，如果人们将上下文限定符(<code>=&gt;</code>)作为旋转門<code>:-</code>逆向读取，那么它就是完全相同的方程式。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">add</span>(<span class="number">0</span>, <span class="type">A</span>, <span class="type">A</span>).</span><br><span class="line"><span class="title">add</span>(s(<span class="type">A</span>), <span class="type">B</span>, s(<span class="type">C</span>)) :- add(<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>).</span><br><span class="line"></span><br><span class="line"><span class="title">pred</span>(<span class="number">0</span>, <span class="number">0</span>).</span><br><span class="line"><span class="title">pred</span>(<span class="type">S</span>(<span class="type">A</span>), <span class="type">A</span>).</span><br></pre></td></tr></table></figure></p>
<p>这是在滥用类型类，如果使用不当，可能会在编译时终止或溢出。在未仔细考虑其含义的情况下，不应打开<code>UndecidableInstances</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;interactive&gt;:<span class="number">1</span>:<span class="number">1</span>:</span><br><span class="line">    <span class="type">Context</span> reduction stack overflow; size = <span class="number">201</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Type-Families"><a href="#Type-Families" class="headerlink" title="Type Families"></a>Type Families</h3><p><code>Type Families</code>允许我们在类型域中编写函数，这些函数将类型作为参数，这些参数可以生成类型或索引在其参数上的值，这些值在编译时进行类型检查时执行。<code>Type Families</code>有两种变体:<code>data families</code>和<code>type synonym families</code>。</p>
<ul>
<li><strong><code>type families</code></strong> are named function on types</li>
<li><strong><code>data families</code></strong> are type-indexed data types</li>
</ul>
<p>首先，让我们看一下<code>type synonym families</code>，有两种等效的语法构造方法。在类型类中声明为关联的<code>type families</code>，或者在<code>toplevel</code>声明为独立的声明。下列形式在语义上是等效的，尽管非关联的形式严格来说更为笼统：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- (1) Unassociated form</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Rep</span> a</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">Rep</span> <span class="type">Int</span> = <span class="type">Char</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">Rep</span> <span class="type">Char</span> = <span class="type">Int</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Convertible</span> a <span class="keyword">where</span></span></span><br><span class="line">  convert :: a -&gt; <span class="type">Rep</span> a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Convertible</span> <span class="type">Int</span> <span class="keyword">where</span></span></span><br><span class="line">  convert = chr</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Convertible</span> <span class="type">Char</span> <span class="keyword">where</span></span></span><br><span class="line">  convert = ord</span><br><span class="line"></span><br><span class="line"><span class="comment">-- (2) Associated form</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Convertible</span> a <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="type">Rep</span> a</span></span><br><span class="line">  convert :: a -&gt; <span class="type">Rep</span> a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Convertible</span> <span class="type">Int</span> <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="type">Rep</span> <span class="type">Int</span> = <span class="type">Char</span></span></span><br><span class="line">  convert = chr</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Convertible</span> <span class="type">Char</span> <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="type">Rep</span> <span class="type">Char</span> = <span class="type">Int</span></span></span><br><span class="line">  convert = ord</span><br></pre></td></tr></table></figure></p>
<p>使用我们用于<code>multiparameter</code>+<code>functional dependencies</code>的示例，我们看到<code>type family</code>方法和<code>functional dependencies</code>之间有直接的转换。这两种方法具有相同的表达能力。</p>
<p>可以在<code>GHCi</code>中使用<code>:kind!</code>命令查询关联的<code>type family</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">λ: :kind! <span class="type">Rep</span> <span class="type">Int</span></span><br><span class="line"><span class="type">Rep</span> <span class="type">Int</span> :: *</span><br><span class="line">= <span class="type">Char</span></span><br><span class="line">λ: :kind! <span class="type">Rep</span> <span class="type">Char</span></span><br><span class="line"><span class="type">Rep</span> <span class="type">Char</span> :: *</span><br><span class="line">= <span class="type">Int</span></span><br></pre></td></tr></table></figure></p>
<p>另一方面，<code>Data families</code>使我们可以创建新型的参数化数据构造函数。<br>通常，我们只能定义<code>typeclasses</code>函数，它们的行为会导致统一的结果，这纯粹是<code>typeclasses</code>参数的结果。<br><code>With data families we can allow specialized behavior indexed on the type.</code>(使用<code>data families</code>，我们可以允许在类型上建立专门的行为索引)。</p>
<p>例如，如果我们想创建更复杂的向量结构(位掩码向量，元组向量，…),这些结构暴露出统一的API,但在内部处理其数据布局中的差异,则可以使用<code>data families</code>来实现这一点:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Vector.Unboxed <span class="keyword">as</span> V</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="keyword">family</span> <span class="type">Array</span> a</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> instance <span class="type">Array</span> <span class="type">Int</span>       = <span class="type">IArray</span> (<span class="type">V</span>.<span class="type">Vector</span> <span class="type">Int</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> instance <span class="type">Array</span> <span class="type">Bool</span>      = <span class="type">BArray</span> (<span class="type">V</span>.<span class="type">Vector</span> <span class="type">Bool</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> instance <span class="type">Array</span> (<span class="title">a</span>,<span class="title">b</span>)     = <span class="type">PArray</span> (<span class="type">Array</span> <span class="title">a</span>) (<span class="type">Array</span> <span class="title">b</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> instance <span class="type">Array</span> (<span class="type">Maybe</span> <span class="title">a</span>) = <span class="type">MArray</span> (<span class="type">V</span>.<span class="type">Vector</span> <span class="type">Bool</span>) (<span class="type">Array</span> <span class="title">a</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">IArray</span> a <span class="keyword">where</span></span></span><br><span class="line">  index :: <span class="type">Array</span> a -&gt; <span class="type">Int</span> -&gt; a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">IArray</span> <span class="type">Int</span> <span class="keyword">where</span></span></span><br><span class="line">  index (<span class="type">IArray</span> xs) i = xs <span class="type">V</span>.! i</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">IArray</span> <span class="type">Bool</span> <span class="keyword">where</span></span></span><br><span class="line">  index (<span class="type">BArray</span> xs) i = xs <span class="type">V</span>.! i</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Vector of pairs</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">IArray</span> <span class="title">a</span>, <span class="type">IArray</span> <span class="title">b</span>) =&gt; <span class="type">IArray</span> (<span class="title">a</span>, <span class="title">b</span>) <span class="keyword">where</span></span></span><br><span class="line">  index (<span class="type">PArray</span> xs ys) i = (index xs i, index ys i)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Vector of missing values</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">IArray</span> <span class="title">a</span>) =&gt; <span class="type">IArray</span> (<span class="type">Maybe</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">  index (<span class="type">MArray</span> bm xs) i =</span><br><span class="line">    <span class="keyword">case</span> bm <span class="type">V</span>.! i <span class="keyword">of</span></span><br><span class="line">      <span class="type">True</span>  -&gt; <span class="type">Nothing</span></span><br><span class="line">      <span class="type">False</span> -&gt; <span class="type">Just</span> $ index xs i</span><br></pre></td></tr></table></figure></p>
<h3 id="Injectivity-內射性"><a href="#Injectivity-內射性" class="headerlink" title="Injectivity(內射性)"></a>Injectivity(內射性)</h3><p><code>type-families</code>定义的类型级别函数不一定是<code>injectivity</code>的，函数可以将两个不同的输入类型映射到相同的输出类型。<br>这不同于<code>injectivity</code>类型构造器(也是类型级别的函数)的行为。</p>
<p>例如: 對於<code>Maybe</code>构造函數，<code>Maybe t1 = Maybe t2</code>意味著<code>t1 = t2</code>.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Maybe</span> a = <span class="type">Nothing</span> | <span class="type">Just</span> a</span></span><br><span class="line"><span class="comment">-- Maybe a ~ Maybe b  implies  a ~ b</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">F</span> <span class="type">Int</span> = <span class="type">Bool</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">F</span> <span class="type">Char</span> = <span class="type">Bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- F a ~ F b does not imply  a ~ b, in general</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h3><blockquote>
<p>这是高级部分，编写Haskell通常不需要。</p>
</blockquote>
<p><code>Roles</code>是<code>datatypes</code>的类型变量参数的进一步规范。</p>
<ul>
<li><code>nominal</code>(名义上的)</li>
<li><code>representational</code>(代表性的/表示形式)</li>
<li><code>phantom</code>(幻影)</li>
</ul>
<p>他们被添加到语言中,以解决围绕<code>newtype</code>及其运行时表示之间的<code>correspondence</code>(对应关系)的一个令人讨厌且长期存在的<code>bug</code>。<br><code>roles</code>引入的基本区别是类型相等有两个概念。当两种类型的名称相同时，它们在名义上是相等的。这是<code>Haskell</code>或<code>Core</code>中通常的等式。当两种类型具有相同的表示形式时，它们在表示上是相等的。(如果类型具有<code>higher-kinded</code>(较高的种类)，则所有名义上相等的实例化将导致表示形式相同的类型。)</p>
<ul>
<li>nominal - 兩個類型是相同的</li>
<li>representational - 兩個類型具有相同的運行時表示形式<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE StandaloneDeriving #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE GeneralizedNewtypeDeriving #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Age</span> = <span class="type">MkAge</span> &#123; <span class="title">unAge</span> :: <span class="type">Int</span> &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Inspect</span> x</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">Inspect</span> <span class="type">Age</span> = <span class="type">Int</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">Inspect</span> <span class="type">Int</span> = <span class="type">Bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Boom</span> a <span class="keyword">where</span></span></span><br><span class="line">  boom :: a -&gt; <span class="type">Inspect</span> a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Boom</span> <span class="type">Int</span> <span class="keyword">where</span></span></span><br><span class="line">  boom = (== <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">deriving</span> <span class="keyword">instance</span> <span class="type">Boom</span> <span class="type">Age</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- GHC 7.6.3 exhibits undefined behavior</span></span><br><span class="line"><span class="title">failure</span> = boom (<span class="type">MkAge</span> <span class="number">3</span>)</span><br><span class="line"><span class="comment">-- -6341068275333450897</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>Roles</code>通常是自动推断的，但是通过<code>RoleAnnotations</code>扩展，可以手动对其进行注释。除极少数情况外，这不是必需的，尽管有助于了解幕后情况。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE PolyKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE KindSignatures #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE RoleAnnotations #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Nat</span> = <span class="type">Zero</span> | <span class="type">Suc</span> <span class="type">Nat</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> role <span class="type">Vec</span> nominal representational</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Vec</span> :: <span class="type">Nat</span> -&gt; * -&gt; * where</span></span><br><span class="line">  <span class="type">Nil</span>  :: <span class="type">Vec</span> <span class="type">Zero</span> a</span><br><span class="line">  (:*) :: a -&gt; <span class="type">Vec</span> n a -&gt; <span class="type">Vec</span> (<span class="type">Suc</span> n) a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> role <span class="type">App</span> representational nominal</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">App</span> (<span class="title">f</span> :: <span class="title">k</span> -&gt; *) (<span class="title">a</span> :: <span class="title">k</span>) = <span class="type">App</span> (<span class="title">f</span> <span class="title">a</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> role <span class="type">Mu</span> nominal nominal</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Mu</span> (<span class="title">f</span> :: (<span class="title">k</span> -&gt; *) -&gt; k -&gt; *) (<span class="title">a</span> :: <span class="title">k</span>) = <span class="type">Roll</span> (<span class="title">f</span> (<span class="type">Mu</span> <span class="title">f</span>) a)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> role <span class="type">Proxy</span> phantom</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Proxy</span> (<span class="title">a</span> :: <span class="title">k</span>) = <span class="type">Proxy</span></span></span><br><span class="line"><span class="title">coerce</span> :: <span class="type">Coercible</span> * a b =&gt; a -&gt; b</span><br><span class="line"><span class="class"><span class="keyword">class</span> (~<span class="type">R</span>#) k k a b =&gt; <span class="type">Coercible</span> k a b</span></span><br></pre></td></tr></table></figure></p>
<p><a href="http://cs.brynmawr.edu/~rae/papers/2014/coercible/coercible.pdf" target="_blank" rel="noopener">Safe Zero-cost Coercions for Haskell</a> (Haskell的安全零成本强制转换)</p>
<p><a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Coerce.html#t:Coercible" target="_blank" rel="noopener">Data.Coerce</a></p>
<p>請看:   </p>
<ul>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Roles" target="_blank" rel="noopener">Roles</a></li>
<li><a href="http://typesandkinds.wordpress.com/2013/08/15/roles-a-new-feature-of-ghc/" target="_blank" rel="noopener">Roles: A New Feature of GHC</a></li>
</ul>
<h3 id="Mono-traversable-单行遍历"><a href="#Mono-traversable-单行遍历" class="headerlink" title="Mono-traversable(单行遍历)"></a>Mono-traversable(单行遍历)</h3><p>使用<code>type families</code>，<code>mono-traversable</code>可以将<code>Functor</code>，<code>Foldable</code>和<code>Traversable</code>的概念进行概括(归纳)，以包括<code>monomorphic</code>(单态)和<code>polymorphic</code>(多态)类型。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">omap</span> :: <span class="type">MonoFunctor</span> mono =&gt; (<span class="type">Element</span> mono -&gt; <span class="type">Element</span> mono) -&gt; mono -&gt; mono</span><br><span class="line"></span><br><span class="line"><span class="title">otraverse</span> :: (<span class="type">Applicative</span> f, <span class="type">MonoTraversable</span> mono)</span><br><span class="line">          =&gt; (<span class="type">Element</span> mono -&gt; f (<span class="type">Element</span> mono)) -&gt; mono -&gt; f mono</span><br><span class="line"></span><br><span class="line"><span class="title">ofoldMap</span> :: (<span class="type">Monoid</span> m, <span class="type">MonoFoldable</span> mono)</span><br><span class="line">         =&gt; (<span class="type">Element</span> mono -&gt; m) -&gt; mono -&gt; m</span><br><span class="line"><span class="title">ofoldl'</span> :: <span class="type">MonoFoldable</span> mono</span><br><span class="line">        =&gt; (a -&gt; <span class="type">Element</span> mono -&gt; a) -&gt; a -&gt; mono -&gt; a</span><br><span class="line"><span class="title">ofoldr</span> :: <span class="type">MonoFoldable</span> mono</span><br><span class="line">        =&gt; (<span class="type">Element</span> mono -&gt; b -&gt; b) -&gt; b -&gt; mono -&gt; b</span><br></pre></td></tr></table></figure></p>
<p>例如，自此以来，文本类型通常不接受任何这些类型类，但是现在我们可以写出对<code>Foldable</code>和<code>Traversable</code>接口进行建模的实例。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE OverloadedStrings #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Text</span><br><span class="line"><span class="keyword">import</span> Data.Char</span><br><span class="line"><span class="keyword">import</span> Data.Monoid</span><br><span class="line"><span class="keyword">import</span> Data.MonoTraversable</span><br><span class="line"><span class="keyword">import</span> Control.Applicative</span><br><span class="line"></span><br><span class="line"><span class="title">bs</span> :: <span class="type">Text</span></span><br><span class="line"><span class="title">bs</span> = <span class="string">"Hello Haskell."</span></span><br><span class="line"></span><br><span class="line"><span class="title">shift</span> :: <span class="type">Text</span></span><br><span class="line"><span class="title">shift</span> = omap (chr . (+<span class="number">1</span>) . ord) bs</span><br><span class="line"><span class="comment">-- "Ifmmp!Ibtlfmm/"</span></span><br><span class="line"></span><br><span class="line"><span class="title">backwards</span> :: [<span class="type">Char</span>]</span><br><span class="line"><span class="title">backwards</span> = ofoldl' (flip (:)) <span class="string">""</span> bs</span><br><span class="line"><span class="comment">-- ".lleksaH olleH"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">MyMonoType</span> = <span class="type">MNil</span> | <span class="type">MCons</span> <span class="type">Int</span> <span class="type">MyMonoType</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">Element</span> <span class="type">MyMonoType</span> = <span class="type">Int</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonoFunctor</span> <span class="type">MyMonoType</span> <span class="keyword">where</span></span></span><br><span class="line">  omap f <span class="type">MNil</span> = <span class="type">MNil</span></span><br><span class="line">  omap f (<span class="type">MCons</span> x xs) = f x `<span class="type">MCons</span>` omap f xs</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonoFoldable</span> <span class="type">MyMonoType</span> <span class="keyword">where</span></span></span><br><span class="line">  ofoldMap f   = ofoldr (mappend . f) mempty</span><br><span class="line">  ofoldr       = mfoldr</span><br><span class="line">  ofoldl'      = mfoldl'</span><br><span class="line">  ofoldr1Ex f  = ofoldr1Ex f . mtoList</span><br><span class="line">  ofoldl1Ex' f = ofoldl1Ex' f . mtoList</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonoTraversable</span> <span class="type">MyMonoType</span> <span class="keyword">where</span></span></span><br><span class="line">  omapM f xs = mapM f (mtoList xs) &gt;&gt;= return . mfromList</span><br><span class="line">  otraverse f = ofoldr acons (pure <span class="type">MNil</span>)</span><br><span class="line">    <span class="keyword">where</span> acons x ys = <span class="type">MCons</span> &lt;$&gt; f x &lt;*&gt; ys</span><br><span class="line"></span><br><span class="line"><span class="title">mtoList</span> :: <span class="type">MyMonoType</span> -&gt; [<span class="type">Int</span>]</span><br><span class="line"><span class="title">mtoList</span> (<span class="type">MNil</span>) = []</span><br><span class="line"><span class="title">mtoList</span> (<span class="type">MCons</span> x xs) = x : (mtoList xs)</span><br><span class="line"></span><br><span class="line"><span class="title">mfromList</span> :: [<span class="type">Int</span>] -&gt; <span class="type">MyMonoType</span></span><br><span class="line"><span class="title">mfromList</span> [] = <span class="type">MNil</span></span><br><span class="line"><span class="title">mfromList</span> (x:xs) = <span class="type">MCons</span> x (mfromList xs)</span><br><span class="line"></span><br><span class="line"><span class="title">mfoldr</span> :: (<span class="type">Int</span> -&gt; a -&gt; a) -&gt; a -&gt; <span class="type">MyMonoType</span> -&gt; a</span><br><span class="line"><span class="title">mfoldr</span> f z <span class="type">MNil</span> =  z</span><br><span class="line"><span class="title">mfoldr</span> f z (<span class="type">MCons</span> x xs) =  f x (mfoldr f z xs)</span><br><span class="line"></span><br><span class="line"><span class="title">mfoldl'</span> :: (a -&gt; <span class="type">Int</span> -&gt; a) -&gt; a -&gt; <span class="type">MyMonoType</span> -&gt; a</span><br><span class="line"><span class="title">mfoldl'</span> f z <span class="type">MNil</span> = z</span><br><span class="line"><span class="title">mfoldl'</span> f z (<span class="type">MCons</span> x xs) = <span class="keyword">let</span> z' = z `f` x</span><br><span class="line">                           <span class="keyword">in</span> seq z' $ mfoldl' f z' xs</span><br><span class="line"></span><br><span class="line"><span class="title">ex1</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">ex1</span> = mfoldl' (+) <span class="number">0</span> (mfromList [<span class="number">1.</span><span class="number">.25</span>])</span><br><span class="line"></span><br><span class="line"><span class="title">ex2</span> :: <span class="type">MyMonoType</span></span><br><span class="line"><span class="title">ex2</span> = omap (+<span class="number">1</span>) (mfromList [<span class="number">1.</span><span class="number">.25</span>])</span><br></pre></td></tr></table></figure></p>
<p>請看: <a href="http://fundeps.com/tables/FromSemigroupToMonads.pdf" target="_blank" rel="noopener">From Semigroups to Monads</a></p>
<h3 id="NonEmpty"><a href="#NonEmpty" class="headerlink" title="NonEmpty"></a>NonEmpty</h3><p>与其让许多<code>Prelude</code>函数的<code>degenerate</code>(退化/简并)情况适应列表的空值情况，不如将静态列表强制构造为某种类型的<code>inhabitant</code>(實例)，有时是更可取的。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infixr</span> <span class="number">5</span> :|, &lt;|</span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">NonEmpty</span> a = a :| [a]</span></span><br><span class="line"></span><br><span class="line"><span class="title">head</span> :: <span class="type">NonEmpty</span> a -&gt; a</span><br><span class="line"><span class="title">toList</span> :: <span class="type">NonEmpty</span> a -&gt; [a]</span><br><span class="line"><span class="title">fromList</span> :: [a] -&gt; <span class="type">NonEmpty</span> a</span><br><span class="line"><span class="title">head</span> :: <span class="type">NonEmpty</span> a -&gt; a</span><br><span class="line"><span class="title">head</span> ~(a :| _) = a</span><br><span class="line"><span class="keyword">import</span> Data.List.NonEmpty</span><br><span class="line"><span class="keyword">import</span> Prelude <span class="keyword">hiding</span> (<span class="title">head</span>, <span class="title">tail</span>, <span class="title">foldl1</span>)</span><br><span class="line"><span class="keyword">import</span> Data.Foldable (<span class="title">foldl1</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">a</span> :: <span class="type">NonEmpty</span> <span class="type">Integer</span></span><br><span class="line"><span class="title">a</span> = fromList [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">-- 1 :| [2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="title">b</span> :: <span class="type">NonEmpty</span> <span class="type">Integer</span></span><br><span class="line"><span class="title">b</span> = <span class="number">1</span> :| [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">-- 1 :| [2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="title">c</span> :: <span class="type">NonEmpty</span> <span class="type">Integer</span></span><br><span class="line"><span class="title">c</span> = fromList []</span><br><span class="line"><span class="comment">-- *** Exception: NonEmpty.fromList: empty list</span></span><br><span class="line"></span><br><span class="line"><span class="title">d</span> :: <span class="type">Integer</span></span><br><span class="line"><span class="title">d</span> = foldl1 (+) $ fromList [<span class="number">1.</span><span class="number">.100</span>]</span><br><span class="line"><span class="comment">-- 5050</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Manual-Proofs-手工證明"><a href="#Manual-Proofs-手工證明" class="headerlink" title="Manual Proofs (手工證明)"></a>Manual Proofs (手工證明)</h3><blockquote>
<p>这是高级部分，编写Haskell通常不需要。</p>
</blockquote>
<p>计算机科学中最深刻的成果之一是<code>curry-howard</code>对应关系，即逻辑命题可以用类型来建模，而将这些类型实例化就构成了这些命题的证明。程序就是证明，证明就是程序。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Types</span>	          <span class="type">Logic</span></span><br><span class="line"><span class="type">A</span>	              proposition</span><br><span class="line"><span class="title">a</span> : <span class="type">A</span>	          proof</span><br><span class="line"><span class="type">B</span>(x)	          predicate</span><br><span class="line"><span class="type">Void</span>        	  ⊥</span><br><span class="line"><span class="type">Unit</span>	          ⊤</span><br><span class="line"><span class="type">A</span> + <span class="type">B</span>	          <span class="type">A</span> ∨ <span class="type">B</span></span><br><span class="line"><span class="type">A</span> × <span class="type">B</span>	          <span class="type">A</span> ∧ <span class="type">B</span></span><br><span class="line"><span class="type">A</span> -&gt; <span class="type">B</span>            <span class="type">A</span> ⇒ <span class="type">B</span></span><br></pre></td></tr></table></figure></p>
<p>在依赖类型的语言中，我们可以充分利用这个结果；在<code>haskell</code>中，我们没有依赖类型提供的优势，但仍然可以证明微不足道的结果。例如，现在我们可以为加法建立类型级別的函数的模型，并提供零是加法恒等式的一个小证明。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">P</span> <span class="number">0</span>                   [ base step ]</span><br><span class="line">∀n. <span class="type">P</span> n  → <span class="type">P</span> (<span class="number">1</span>+n)    [ inductive step ]</span><br><span class="line"><span class="comment">-------------------</span></span><br><span class="line">∀n. <span class="type">P</span>(n)</span><br><span class="line"><span class="type">Axiom</span> <span class="number">1</span>: a + <span class="number">0</span> = a</span><br><span class="line"><span class="type">Axiom</span> <span class="number">2</span>: a + suc b = suc (a + b)</span><br><span class="line"></span><br><span class="line">  <span class="number">0</span> + suc a</span><br><span class="line">= suc (<span class="number">0</span> + a)  [by <span class="type">Axiom</span> <span class="number">2</span>]</span><br><span class="line">= suc a        [<span class="type">Induction</span> hypothesis]</span><br><span class="line">∎</span><br></pre></td></tr></table></figure></p>
<p>翻译成<code>Haskell</code>的公理只是简单的类型化定义，而归纳数据类型的递归构成了我们证明的归纳步骤。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ExplicitForAll #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Z</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">S</span> n</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">SNat</span> n where</span></span><br><span class="line">  <span class="type">Zero</span> :: <span class="type">SNat</span> <span class="type">Z</span></span><br><span class="line">  <span class="type">Succ</span> :: <span class="type">SNat</span> n -&gt; <span class="type">SNat</span> (<span class="type">S</span> n)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Eql</span> a b where</span></span><br><span class="line">  <span class="type">Refl</span> :: <span class="type">Eql</span> a a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Add</span> m n</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">Add</span> <span class="type">Z</span> n = n</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">Add</span> (<span class="type">S</span> <span class="title">m</span>) n = <span class="type">S</span> (<span class="type">Add</span> <span class="title">m</span> <span class="title">n</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="title">add</span> :: <span class="type">SNat</span> n -&gt; <span class="type">SNat</span> m -&gt; <span class="type">SNat</span> (<span class="type">Add</span> n m)</span><br><span class="line"><span class="title">add</span> <span class="type">Zero</span>     m = m</span><br><span class="line"><span class="title">add</span> (<span class="type">Succ</span> n) m = <span class="type">Succ</span> (add n m)</span><br><span class="line"></span><br><span class="line"><span class="title">cong</span> :: <span class="type">Eql</span> a b -&gt; <span class="type">Eql</span> (f a) (f b)</span><br><span class="line"><span class="title">cong</span> <span class="type">Refl</span> = <span class="type">Refl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ∀n. 0 + suc n = suc n</span></span><br><span class="line"><span class="title">plus_suc</span> :: <span class="keyword">forall</span> n.  <span class="type">SNat</span> n</span><br><span class="line">         -&gt; <span class="type">Eql</span> (<span class="type">Add</span> <span class="type">Z</span> (<span class="type">S</span> n)) (<span class="type">S</span> n)</span><br><span class="line"><span class="title">plus_suc</span> <span class="type">Zero</span> = <span class="type">Refl</span></span><br><span class="line"><span class="title">plus_suc</span> (<span class="type">Succ</span> n) = cong (plus_suc n)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ∀n. 0 + n = n</span></span><br><span class="line"><span class="title">plus_zero</span> :: <span class="keyword">forall</span> n. <span class="type">SNat</span> n</span><br><span class="line">         -&gt; <span class="type">Eql</span> (<span class="type">Add</span> <span class="type">Z</span> n) n</span><br><span class="line"><span class="title">plus_zero</span> <span class="type">Zero</span> = <span class="type">Refl</span></span><br><span class="line"><span class="title">plus_zero</span> (<span class="type">Succ</span> n) = cong (plus_zero n)</span><br></pre></td></tr></table></figure></p>
<p>使用<code>TypeOperators</code>扩展，我们还可以在<code>type-level</code>使用中缀符号。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> a :=: b where</span></span><br><span class="line">  <span class="type">Refl</span> :: a :=: a</span><br><span class="line"></span><br><span class="line"><span class="title">cong</span> :: a :=: b -&gt; (f a) :=: (f b)</span><br><span class="line"><span class="title">cong</span> <span class="type">Refl</span> = <span class="type">Refl</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> (<span class="title">n</span> :: <span class="type">Nat</span>) :+ (<span class="title">m</span> :: <span class="type">Nat</span>) :: <span class="type">Nat</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">Zero</span>     :+ m = m</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance (<span class="type">Succ</span> <span class="title">n</span>) :+ m = <span class="type">Succ</span> (<span class="title">n</span> :+ <span class="title">m</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="title">plus_suc</span> :: <span class="keyword">forall</span> n m. <span class="type">SNat</span> n -&gt; <span class="type">SNat</span> m -&gt; (n :+ (<span class="type">S</span> m)) :=: (<span class="type">S</span> (n :+ m))</span><br><span class="line"><span class="title">plus_suc</span> <span class="type">Zero</span> m = <span class="type">Refl</span></span><br><span class="line"><span class="title">plus_suc</span> (<span class="type">Succ</span> n) m = cong (plus_suc n m)</span><br></pre></td></tr></table></figure></p>
<h3 id="Constraint-Kinds-约束种类"><a href="#Constraint-Kinds-约束种类" class="headerlink" title="Constraint Kinds (约束种类)"></a>Constraint Kinds (约束种类)</h3><blockquote>
<p>这是高级部分，编写Haskell通常不需要。</p>
</blockquote>
<p><code>GHC</code>的实现还通过启用<code>-XConstraintKinds</code>扩展，公開了将<code>Haskell</code>中的限定词绑定为类型本身的謂詞。<br>使用此扩展，我们将<code>constraints</code>(约束)作为第一类类型处理。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Num</span> :: * -&gt; <span class="type">Constraint</span></span><br><span class="line"><span class="type">Odd</span> :: * -&gt; <span class="type">Constraint</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">T1</span> a = (<span class="type">Num</span> <span class="title">a</span>, <span class="type">Ord</span> <span class="title">a</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>空约束集由<code>() :: Constraint</code>表示。<br>对于一个虚构的示例，如果我们想创建一个通用的<code>Sized</code>类，该类带有对所涉及容器的元素的约束，则可以使用<code>type families</code>非常简单地实现此目的。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ConstraintKinds #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.Exts (<span class="type">Constraint</span>)</span><br><span class="line"><span class="keyword">import</span> Data.Hashable</span><br><span class="line"><span class="keyword">import</span> Data.HashSet</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Con</span> a :: <span class="type">Constraint</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">Con</span> [a] = (<span class="type">Ord</span> <span class="title">a</span>, <span class="type">Eq</span> <span class="title">a</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">Con</span> (<span class="type">HashSet</span> <span class="title">a</span>) = (<span class="type">Hashable</span> <span class="title">a</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Sized</span> a <span class="keyword">where</span></span></span><br><span class="line">  gsize :: <span class="type">Con</span> a =&gt; a -&gt; <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Sized</span> [a] <span class="keyword">where</span></span></span><br><span class="line">  gsize = length</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Sized</span> (<span class="type">HashSet</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">  gsize = size</span><br></pre></td></tr></table></figure></p>
<p>其中一个用例是捕获受函数约束的<code>typeclass</code>字典并将其具体化为一个值。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ConstraintKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE KindSignatures #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.Exts (<span class="type">Constraint</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Dict</span> :: <span class="type">Constraint</span> -&gt; * where</span></span><br><span class="line">  <span class="type">Dict</span> :: (c) =&gt; <span class="type">Dict</span> c</span><br><span class="line"></span><br><span class="line"><span class="title">dShow</span> :: <span class="type">Dict</span> (<span class="type">Show</span> a) -&gt; a -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">dShow</span> <span class="type">Dict</span> x = show x</span><br><span class="line"></span><br><span class="line"><span class="title">dEqNum</span> :: <span class="type">Dict</span> (<span class="type">Eq</span> a, <span class="type">Num</span> a) -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">dEqNum</span> <span class="type">Dict</span> x = x == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">fShow</span> :: <span class="type">String</span></span><br><span class="line"><span class="title">fShow</span> = dShow <span class="type">Dict</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="title">fEqual</span> :: <span class="type">Bool</span></span><br><span class="line"><span class="title">fEqual</span> = dEqNum <span class="type">Dict</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h3 id="TypeFamilyDependencies"><a href="#TypeFamilyDependencies" class="headerlink" title="TypeFamilyDependencies"></a>TypeFamilyDependencies</h3><p><code>Type families</code>在历史上不是内射的，也就是说，它们不能保证将其参数的不同元素映射到其结果的相同元素。语法类似于<code>multiparmater typeclass functional dependencies</code>(多参数类型类函数依赖项)，因为生成的类型由一组<code>type families</code>参数唯一确定。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE XTypeFamilyDependencies #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">F</span> a b c = (<span class="title">result</span> :: <span class="title">k</span>) | result -&gt; a b c</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">F</span> <span class="type">Int</span>  <span class="type">Char</span> <span class="type">Bool</span> = <span class="type">Bool</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">F</span> <span class="type">Char</span> <span class="type">Bool</span> <span class="type">Int</span>  = <span class="type">Int</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">F</span> <span class="type">Bool</span> <span class="type">Int</span>  <span class="type">Char</span> = <span class="type">Char</span></span></span><br></pre></td></tr></table></figure></p>
<p>請看: <a href="http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf" target="_blank" rel="noopener">Injective type families for Haskell</a> (Haskell的内射性<code>type families</code>)</p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="https://github.com/bobcn/hexo_resize_image.js"></script>
<script src="/blog/js/index.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/blog/js/gitment.js"></script>
<script>
    var gitment = new Gitment({
        id: 'Haskell-Type-Families',
        owner: 'limengyu1990',
        repo: 'hexo-blog',
        oauth: {
            client_id: '7cfc73dd62b57f07ed83',
            client_secret: 'dd03b7e54aadf0d81e4c9c93e23a41272bcfcfa1',
        },
    })
    gitment.render('comment-container')
</script>

</html>
