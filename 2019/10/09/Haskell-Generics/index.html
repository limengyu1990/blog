<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        Haskell-Generics - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>不负如来不负卿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Typeable"><span class="toc-text">Typeable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dynamic"><span class="toc-text">Dynamic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data"><span class="toc-text">Data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Syb"><span class="toc-text">Syb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generic"><span class="toc-text">Generic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generic-Deriving"><span class="toc-text">Generic Deriving</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Higher-Kinded-Generics"><span class="toc-text">Higher Kinded Generics</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#generics-sop"><span class="toc-text">generics-sop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Uniplate"><span class="toc-text">Uniplate</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Biplate"><span class="toc-text">Biplate</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Haskell-Generics
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-10-09 10:53:12</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/blog/tags/#Wish-Knew" title="Wish-Knew">Wish-Knew</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Haskell" title="Haskell">Haskell</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Generics" title="Generics">Generics</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p><a href="http://dev.stephendiehl.com/hask/#generics" target="_blank" rel="noopener">原文</a></p>
</blockquote>
<p><code>Haskell</code>有几种技术可以自动生成用于各种任务的类型类，这些任务主要由样板代码生成组成，例如:</p>
<ul>
<li><strong>Pretty Printing</strong> (漂亮打印)</li>
<li><strong>Equality</strong> (平等/相等)</li>
<li><strong>Serialization</strong> (序列化)</li>
<li><strong>Ordering</strong> (比較)</li>
<li><strong>Traversal</strong> (遍历)</li>
</ul>
<p>这些是通过以下几节中概述的几种工具和技术来实现的:</p>
<ul>
<li><strong>Typeable / Dynamic</strong></li>
<li><strong>Scrap Your Boilerplate</strong> (报废/扔掉你的样板)</li>
<li><strong>GHC.Generics</strong></li>
<li><strong>generics-sop</strong></li>
</ul>
<h3 id="Typeable"><a href="#Typeable" class="headerlink" title="Typeable"></a>Typeable</h3><p><code>Typeable</code>类用于为任意类型创建运行时类型信息。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">typeOf</span> :: <span class="type">Typeable</span> a =&gt; a -&gt; <span class="type">TypeRep</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DeriveDataTypeable #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Typeable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Animal</span> = <span class="type">Cat</span> | <span class="type">Dog</span> <span class="keyword">deriving</span> <span class="type">Typeable</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Zoo</span> a = <span class="type">Zoo</span> [a] <span class="keyword">deriving</span> <span class="type">Typeable</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">equal</span> :: (<span class="type">Typeable</span> a, <span class="type">Typeable</span> b) =&gt; a -&gt; b -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">equal</span> a b = typeOf a == typeOf b</span><br><span class="line"></span><br><span class="line"><span class="title">example1</span> :: <span class="type">TypeRep</span></span><br><span class="line"><span class="title">example1</span> = typeOf <span class="type">Cat</span></span><br><span class="line"><span class="comment">-- Animal</span></span><br><span class="line"></span><br><span class="line"><span class="title">example2</span> :: <span class="type">TypeRep</span></span><br><span class="line"><span class="title">example2</span> = typeOf (<span class="type">Zoo</span> [<span class="type">Cat</span>, <span class="type">Dog</span>])</span><br><span class="line"><span class="comment">-- Zoo Animal</span></span><br><span class="line"></span><br><span class="line"><span class="title">example3</span> :: <span class="type">TypeRep</span></span><br><span class="line"><span class="title">example3</span> = typeOf ((<span class="number">1</span>, <span class="number">6.636e-34</span>, <span class="string">"foo"</span>) :: (<span class="type">Int</span>, <span class="type">Double</span>, <span class="type">String</span>))</span><br><span class="line"><span class="comment">-- (Int,Double,[Char])</span></span><br><span class="line"></span><br><span class="line"><span class="title">example4</span> :: <span class="type">Bool</span></span><br><span class="line"><span class="title">example4</span> = equal <span class="type">False</span> ()</span><br><span class="line"><span class="comment">-- False</span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>typeable</code>实例允许我们编写一个类型安全的<code>cast</code>函数，该函数可以安全地使用<code>unsafecast</code>，并提供结果类型与输入匹配的证明。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">cast</span> :: (<span class="type">Typeable</span> a, <span class="type">Typeable</span> b) =&gt; a -&gt; <span class="type">Maybe</span> b</span><br><span class="line"><span class="title">cast</span> x</span><br><span class="line">  | typeOf x == typeOf ret = <span class="type">Just</span> ret</span><br><span class="line">  | otherwise = <span class="type">Nothing</span></span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    ret = unsafeCast x</span><br></pre></td></tr></table></figure></p>
<p>历史上值得注意的是，目前在<code>GHC 7.6</code>中可以编写我们自己的<code>Typeable</code>类，但是它允许我们引入可能导致崩溃的危险行为，除非<code>GHC</code>本身否則不应该这样做。从<code>GHC 7.8</code>开始，已經禁止我們手写<code>Typeable</code>实例。 从<code>GHC 7.10</code>开始，默认情况下已启用<code>-XAutoDeriveTypeable</code>擴展。</p>
<p>請看: <a href="http://chrisdone.com/posts/data-typeable" target="_blank" rel="noopener">Typeable and Data in Haskell</a></p>
<h3 id="Dynamic"><a href="#Dynamic" class="headerlink" title="Dynamic"></a>Dynamic</h3><p>由于我们有一种查询运行时类型信息的方法，因此可以使用此机器实现<code>Dynamic</code>(动态)类型。<br>这允许我们将任何<code>monotype</code>(单型)打包成一个<code>uniform</code>(统一)的类型，该类型可以传递给任何采用动态类型的函数，然后可以用类型安全的方式解包基础值。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">toDyn</span> :: <span class="type">Typeable</span> a =&gt; a -&gt; <span class="type">Dynamic</span></span><br><span class="line"><span class="title">fromDyn</span> :: <span class="type">Typeable</span> a =&gt; <span class="type">Dynamic</span> -&gt; a -&gt; a</span><br><span class="line"><span class="title">fromDynamic</span> :: <span class="type">Typeable</span> a =&gt; <span class="type">Dynamic</span> -&gt; <span class="type">Maybe</span> a</span><br><span class="line"><span class="title">cast</span> :: (<span class="type">Typeable</span> a, <span class="type">Typeable</span> b) =&gt; a -&gt; <span class="type">Maybe</span> b</span><br><span class="line"><span class="keyword">import</span> Data.Dynamic</span><br><span class="line"><span class="keyword">import</span> Data.Maybe</span><br><span class="line"></span><br><span class="line"><span class="title">dynamicBox</span> :: <span class="type">Dynamic</span></span><br><span class="line"><span class="title">dynamicBox</span> = toDyn (<span class="number">6.62</span> :: <span class="type">Double</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">example1</span> :: <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">example1</span> = fromDynamic dynamicBox</span><br><span class="line"><span class="comment">-- Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="title">example2</span> :: <span class="type">Maybe</span> <span class="type">Double</span></span><br><span class="line"><span class="title">example2</span> = fromDynamic dynamicBox</span><br><span class="line"><span class="comment">-- Just 6.62</span></span><br><span class="line"></span><br><span class="line"><span class="title">example3</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">example3</span> = fromDyn dynamicBox <span class="number">0</span></span><br><span class="line"><span class="comment">-- 0</span></span><br><span class="line"></span><br><span class="line"><span class="title">example4</span> :: <span class="type">Double</span></span><br><span class="line"><span class="title">example4</span> = fromDyn dynamicBox <span class="number">0.0</span></span><br><span class="line"><span class="comment">-- 6.62</span></span><br></pre></td></tr></table></figure></p>
<p>在<code>GHC 7.8</code>中，<code>Typeable</code>类是<code>poly-kinded</code>(多类型)的，因此<code>polymorphic</code>(多态)函数可以应用于函数和<code>higher kinded</code>(更高种类)的类型。</p>
<blockquote>
<p>使用<code>dynamic</code>有点罕见，除了在处理外部内存和<code>ffi</code>接口的奇怪情况下。将它用于业务逻辑被认为是一种代码异味。考虑一个更惯用的解决方案。</p>
</blockquote>
<h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p>正如<code>Typeable</code>允许我们创建运行时类型信息一样，<code>Data</code>类也允许我们根据需要向运行时<code>reflect</code>(反映)有关<code>datatypes</code>结构的信息。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Typeable</span> a =&gt; <span class="type">Data</span> a <span class="keyword">where</span></span></span><br><span class="line">  gfoldl  :: (<span class="keyword">forall</span> d b. <span class="type">Data</span> d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)</span><br><span class="line">          -&gt; (<span class="keyword">forall</span> g. g -&gt; c g)</span><br><span class="line">          -&gt; a</span><br><span class="line">          -&gt; c a</span><br><span class="line"></span><br><span class="line">  gunfold :: (<span class="keyword">forall</span> b r. <span class="type">Data</span> b =&gt; c (b -&gt; r) -&gt; c r)</span><br><span class="line">          -&gt; (<span class="keyword">forall</span> r. r -&gt; c r)</span><br><span class="line">          -&gt; <span class="type">Constr</span></span><br><span class="line">          -&gt; c a</span><br><span class="line"></span><br><span class="line">  toConstr :: a -&gt; <span class="type">Constr</span></span><br><span class="line">  dataTypeOf :: a -&gt; <span class="type">DataType</span></span><br><span class="line">  gmapQl :: (r -&gt; r' -&gt; r) -&gt; r -&gt; (<span class="keyword">forall</span> d. <span class="type">Data</span> d =&gt; d -&gt; r') -&gt; a -&gt; r</span><br></pre></td></tr></table></figure></p>
<p><code>gfoldl</code>和<code>gunfold</code>的类型有些令人生畏(其取决于<code>RankNTypes</code>),最好的理解方法是看一些示例。首先，最简单的情况是<code>sum</code>类型<code>Animal</code>将产生以下代码:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Animal</span> = <span class="type">Cat</span> | <span class="type">Dog</span> <span class="keyword">deriving</span> <span class="type">Typeable</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Data</span> <span class="type">Animal</span> <span class="keyword">where</span></span></span><br><span class="line">  gfoldl k z <span class="type">Cat</span> = z <span class="type">Cat</span></span><br><span class="line">  gfoldl k z <span class="type">Dog</span> = z <span class="type">Dog</span></span><br><span class="line"></span><br><span class="line">  gunfold k z c</span><br><span class="line">    = <span class="keyword">case</span> constrIndex c <span class="keyword">of</span></span><br><span class="line">        <span class="number">1</span> -&gt; z <span class="type">Cat</span></span><br><span class="line">        <span class="number">2</span> -&gt; z <span class="type">Dog</span></span><br><span class="line"></span><br><span class="line">  toConstr <span class="type">Cat</span> = cCat</span><br><span class="line">  toConstr <span class="type">Dog</span> = cDog</span><br><span class="line"></span><br><span class="line">  dataTypeOf _ = tAnimal</span><br><span class="line"></span><br><span class="line"><span class="title">tAnimal</span> :: <span class="type">DataType</span></span><br><span class="line"><span class="title">tAnimal</span> = mkDataType <span class="string">"Main.Animal"</span> [cCat, cDog]</span><br><span class="line"></span><br><span class="line"><span class="title">cCat</span> :: <span class="type">Constr</span></span><br><span class="line"><span class="title">cCat</span> = mkConstr tAnimal <span class="string">"Cat"</span> [] <span class="type">Prefix</span></span><br><span class="line"></span><br><span class="line"><span class="title">cDog</span> :: <span class="type">Constr</span></span><br><span class="line"><span class="title">cDog</span> = mkConstr tAnimal <span class="string">"Dog"</span> [] <span class="type">Prefix</span></span><br></pre></td></tr></table></figure></p>
<p>对于带有非空容器的类型，我们会得到一些更有趣的东西。考虑列表类型:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Data</span> a =&gt; <span class="type">Data</span> [a] <span class="keyword">where</span></span></span><br><span class="line">  gfoldl _ z []     = z []</span><br><span class="line">  gfoldl k z (x:xs) = z (:) `k` x `k` xs</span><br><span class="line"></span><br><span class="line">  toConstr []    = nilConstr</span><br><span class="line">  toConstr (_:_) = consConstr</span><br><span class="line"></span><br><span class="line">  gunfold k z c</span><br><span class="line">    = <span class="keyword">case</span> constrIndex c <span class="keyword">of</span></span><br><span class="line">        <span class="number">1</span> -&gt; z []</span><br><span class="line">        <span class="number">2</span> -&gt; k (k (z (:)))</span><br><span class="line"></span><br><span class="line">  dataTypeOf _ = listDataType</span><br><span class="line"></span><br><span class="line"><span class="title">nilConstr</span> :: <span class="type">Constr</span></span><br><span class="line"><span class="title">nilConstr</span> = mkConstr listDataType <span class="string">"[]"</span> [] <span class="type">Prefix</span></span><br><span class="line"></span><br><span class="line"><span class="title">consConstr</span> :: <span class="type">Constr</span></span><br><span class="line"><span class="title">consConstr</span> = mkConstr listDataType <span class="string">"(:)"</span> [] <span class="type">Infix</span></span><br><span class="line"></span><br><span class="line"><span class="title">listDataType</span> :: <span class="type">DataType</span></span><br><span class="line"><span class="title">listDataType</span> = mkDataType <span class="string">"Prelude.[]"</span> [nilConstr,consConstr]</span><br></pre></td></tr></table></figure></p>
<p>看一下<code>gfoldl</code>，我们看到<code>Data</code>有一个函数的实现，通过在每个元素上应用函数<code>k</code>并在<code>spine</code>(书脊)上应用<code>z</code>，我们可以遍历构造函数的元素。例如，看一个2元组的实例:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Data</span> <span class="title">a</span>, <span class="type">Data</span> <span class="title">b</span>) =&gt; <span class="type">Data</span> (<span class="title">a</span>,<span class="title">b</span>) <span class="keyword">where</span></span></span><br><span class="line">  gfoldl k z (a,b) = z (,) `k` a `k` b</span><br><span class="line"></span><br><span class="line">  toConstr (_,_) = tuple2Constr</span><br><span class="line"></span><br><span class="line">  gunfold k z c</span><br><span class="line">    = <span class="keyword">case</span> constrIndex c <span class="keyword">of</span></span><br><span class="line">      <span class="number">1</span> -&gt; k (k (z (,)))</span><br><span class="line"></span><br><span class="line">  dataTypeOf _  = tuple2DataType</span><br><span class="line"></span><br><span class="line"><span class="title">tuple2Constr</span> :: <span class="type">Constr</span></span><br><span class="line"><span class="title">tuple2Constr</span> = mkConstr tuple2DataType <span class="string">"(,)"</span> [] <span class="type">Infix</span></span><br><span class="line"></span><br><span class="line"><span class="title">tuple2DataType</span> :: <span class="type">DataType</span></span><br><span class="line"><span class="title">tuple2DataType</span> = mkDataType <span class="string">"Prelude.(,)"</span> [tuple2Constr]</span><br></pre></td></tr></table></figure></p>
<p>这非常整洁，现在在同一类型类中，我们有一种<code>generic</code>(通用)的方法可以对任何<code>Data</code>实例进行内省并编写依赖于其子项的结构和类型的逻辑。<br>现在，我们可以编写一个函数，该函数允许我们根据运行时类型上的模式匹配<code>traverse</code>(遍历)<code>Data</code>的任意实例和<code>twiddle</code>(旋转)值。<br>因此，让我们写下一个为<code>n</code>元组和列表增加<code>Value</code>类型的函数。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DeriveDataTypeable #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Data</span><br><span class="line"><span class="keyword">import</span> Control.Monad.Identity</span><br><span class="line"><span class="keyword">import</span> Control.Applicative</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Animal</span> = <span class="type">Cat</span> | <span class="type">Dog</span> <span class="keyword">deriving</span> (<span class="type">Data</span>, <span class="type">Typeable</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Val</span> = <span class="type">Val</span> <span class="type">Int</span> <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Data</span>, <span class="type">Typeable</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="title">incr</span> :: <span class="type">Typeable</span> a =&gt; a -&gt; a</span><br><span class="line"><span class="title">incr</span> = maybe id id (cast f)</span><br><span class="line">  <span class="keyword">where</span> f (<span class="type">Val</span> x) = <span class="type">Val</span> (x * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">over</span> :: <span class="type">Data</span> a =&gt; a -&gt; a</span><br><span class="line"><span class="title">over</span> x = runIdentity $ gfoldl cont base (incr x)</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    cont k d = k &lt;*&gt; (pure $ over d)</span><br><span class="line">    base = pure</span><br><span class="line"></span><br><span class="line"><span class="title">example1</span> :: <span class="type">Constr</span></span><br><span class="line"><span class="title">example1</span> = toConstr <span class="type">Dog</span></span><br><span class="line"><span class="comment">-- Dog</span></span><br><span class="line"></span><br><span class="line"><span class="title">example2</span> :: <span class="type">DataType</span></span><br><span class="line"><span class="title">example2</span> = dataTypeOf <span class="type">Cat</span></span><br><span class="line"><span class="comment">-- DataType &#123;tycon = "Main.Animal", datarep = AlgRep [Cat,Dog]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">example3</span> :: [<span class="type">Val</span>]</span><br><span class="line"><span class="title">example3</span> = over [<span class="type">Val</span> <span class="number">1</span>, <span class="type">Val</span> <span class="number">2</span>, <span class="type">Val</span> <span class="number">3</span>]</span><br><span class="line"><span class="comment">-- [Val 100,Val 200,Val 300]</span></span><br><span class="line"></span><br><span class="line"><span class="title">example4</span> :: (<span class="type">Val</span>, <span class="type">Val</span>, <span class="type">Val</span>)</span><br><span class="line"><span class="title">example4</span> = over (<span class="type">Val</span> <span class="number">1</span>, <span class="type">Val</span> <span class="number">2</span>, <span class="type">Val</span> <span class="number">3</span>)</span><br><span class="line"><span class="comment">-- (Val 100,Val 200,Val 300)</span></span><br></pre></td></tr></table></figure></p>
<p>我们还可以编写<code>generic</code>(通用)操作，例如计算数据类型中参数的数量。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">numHoles</span> :: <span class="type">Data</span> a =&gt; a -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">numHoles</span> = gmapQl (+) <span class="number">0</span> (const <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">example1</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">example1</span> = numHoles (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"><span class="comment">-- 7</span></span><br><span class="line"></span><br><span class="line"><span class="title">example2</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">example2</span> = numHoles (<span class="type">Just</span> <span class="number">3</span>)</span><br><span class="line"><span class="comment">-- 1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Syb"><a href="#Syb" class="headerlink" title="Syb"></a>Syb</h3><p>使用<code>Data</code>提供的接口，我们可以在运行时检索所需的信息，检查表达式的类型并重写它们，收集<code>terms</code>(项)，并找到与特定谓词匹配的<code>subterms</code>(子项)。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">everywhere</span> :: (<span class="keyword">forall</span> a. <span class="type">Data</span> a =&gt; a -&gt; a) -&gt; <span class="keyword">forall</span> a. <span class="type">Data</span> a =&gt; a -&gt; a</span><br><span class="line"><span class="title">everywhereM</span> :: <span class="type">Monad</span> m =&gt; <span class="type">GenericM</span> m -&gt; <span class="type">GenericM</span> m</span><br><span class="line"><span class="title">somewhere</span> :: <span class="type">MonadPlus</span> m =&gt; <span class="type">GenericM</span> m -&gt; <span class="type">GenericM</span> m</span><br><span class="line"><span class="title">listify</span> :: <span class="type">Typeable</span> r =&gt; (r -&gt; <span class="type">Bool</span>) -&gt; <span class="type">GenericQ</span> [r]</span><br><span class="line"><span class="title">everything</span> :: (r -&gt; r -&gt; r) -&gt; <span class="type">GenericQ</span> r -&gt; <span class="type">GenericQ</span> r</span><br></pre></td></tr></table></figure></p>
<p>例如，假设我们有一些自定义的<code>datatypes</code>(数据类型)集合，我们要为其编写<code>generic</code>(通用)转换，以根据重写规则集转换数值子表达式。 我们可以使用<code>syb</code>简洁地编写转换规则。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DeriveDataTypeable #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Data</span><br><span class="line"><span class="keyword">import</span> Data.Typeable</span><br><span class="line"><span class="keyword">import</span> Data.Generics.Schemes</span><br><span class="line"><span class="keyword">import</span> Data.Generics.Aliases (<span class="title">mkT</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">MyTuple</span> a = <span class="type">MyTuple</span> a <span class="type">Float</span></span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Data</span>, <span class="type">Typeable</span>, <span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">exampleT</span> :: <span class="type">Data</span> a =&gt; <span class="type">MyTuple</span> a -&gt; <span class="type">MyTuple</span> a</span><br><span class="line"><span class="title">exampleT</span> = everywhere (mkT go1) . everywhere (mkT go2)</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    go1 :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line">    go1 x = succ x</span><br><span class="line"></span><br><span class="line">    go2 :: <span class="type">Float</span> -&gt; <span class="type">Float</span></span><br><span class="line">    go2 x = succ x</span><br><span class="line"></span><br><span class="line"><span class="title">findFloat</span> :: <span class="type">Data</span> x =&gt; x -&gt; <span class="type">Maybe</span> <span class="type">Float</span></span><br><span class="line"><span class="title">findFloat</span> = gfindtype</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">let</span> term = <span class="type">MyTuple</span> (<span class="type">MyTuple</span> (<span class="number">1</span> :: <span class="type">Int</span>) <span class="number">2.0</span>) <span class="number">3.0</span></span><br><span class="line">  print (exampleT term)</span><br><span class="line">  print (gsize term)</span><br><span class="line">  print (findFloat term)</span><br><span class="line">  print (listify ((&gt;<span class="number">0</span>) :: (<span class="type">Int</span> -&gt; <span class="type">Bool</span>)) term)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><a href="https://hackage.haskell.org/package/syb-0.6/docs/Data-Generics-Schemes.html" target="_blank" rel="noopener">Data.Generics.Schemes</a></li>
</ul>
<h3 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h3><p>最现代的<code>generic programming</code>(泛型编程)方法是使用<code>type families</code>来实现更好的派生任意类型类的结构属性的方法。<br><code>Generic</code>(泛型)实现了一个类型类，该类具有一个关联的类型<code>Rep</code>(<code>Representation</code>表示)和一对函数，这些函数形成一个<code>2-sided inverse</code>(双面逆)(<code>isomorphism</code>同构)，用于在<code>associated</code>(相关联)类型和相关<code>derived</code>(派生)类型之间进行转换。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Generic</span> a <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="type">Rep</span> a</span></span><br><span class="line">  from :: a -&gt; <span class="type">Rep</span> a</span><br><span class="line">  to :: <span class="type">Rep</span> a -&gt; a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Datatype</span> d <span class="keyword">where</span></span></span><br><span class="line">  datatypeName :: t d f a -&gt; <span class="type">String</span></span><br><span class="line">  moduleName :: t d f a -&gt; <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Constructor</span> c <span class="keyword">where</span></span></span><br><span class="line">  conName :: t c f a -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc-prim-0.2.0.0/GHC-Generics.html" target="_blank" rel="noopener">GHC.Generics</a><br><code>GHC.Generics</code>定义了一组<code>named types</code>(命名类型)，用于对<code>Haskell</code>中可用的类型的各种<code>structural properties</code>(结构特性)进行建模。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- | Sums: encode choice between constructors</span></span><br><span class="line"><span class="keyword">infixr</span> <span class="number">5</span> :+:</span><br><span class="line"><span class="class"><span class="keyword">data</span> (:+:) f g p = <span class="type">L1</span> (<span class="title">f</span> <span class="title">p</span>) | <span class="type">R1</span> (<span class="title">g</span> <span class="title">p</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | Products: encode multiple arguments to constructors</span></span><br><span class="line"><span class="keyword">infixr</span> <span class="number">6</span> :*:</span><br><span class="line"><span class="class"><span class="keyword">data</span> (:*:) f g p = f p :*: g p</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | Tag for M1: datatype</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">D</span></span></span><br><span class="line"><span class="comment">-- | Tag for M1: constructor</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">C</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | Constants, additional parameters and recursion of kind *</span></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">K1</span> i c p = <span class="type">K1</span> &#123; <span class="title">unK1</span> :: <span class="title">c</span> &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | Meta-information (constructor names, etc.)</span></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">M1</span> i c f p = <span class="type">M1</span> &#123; <span class="title">unM1</span> :: <span class="title">f</span> <span class="title">p</span> &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | Type synonym for encoding meta-information for datatypes</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">D1</span> = <span class="type">M1</span> <span class="type">D</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | Type synonym for encoding meta-information for constructors</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">C1</span> = <span class="type">M1</span> <span class="type">C</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果我们要手工为一个简单的类型编写<code>Generic</code>(通用)实例，那么使用派生机制<code>GHC</code>可以为我们机械地生成该<code>Generic</code>(通用)实例:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.Generics</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Animal</span></span></span><br><span class="line">  = <span class="type">Dog</span></span><br><span class="line">  | <span class="type">Cat</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Generic</span> <span class="type">Animal</span> <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="type">Rep</span> <span class="type">Animal</span> = <span class="type">D1</span> <span class="type">T_Animal</span> ((<span class="type">C1</span> <span class="type">C_Dog</span> <span class="type">U1</span>) :+: (<span class="type">C1</span> <span class="type">C_Cat</span> <span class="type">U1</span>))</span></span><br><span class="line"></span><br><span class="line">  from <span class="type">Dog</span> = <span class="type">M1</span> (<span class="type">L1</span> (<span class="type">M1</span> <span class="type">U1</span>))</span><br><span class="line">  from <span class="type">Cat</span> = <span class="type">M1</span> (<span class="type">R1</span> (<span class="type">M1</span> <span class="type">U1</span>))</span><br><span class="line"></span><br><span class="line">  to (<span class="type">M1</span> (<span class="type">L1</span> (<span class="type">M1</span> <span class="type">U1</span>))) = <span class="type">Dog</span></span><br><span class="line">  to (<span class="type">M1</span> (<span class="type">R1</span> (<span class="type">M1</span> <span class="type">U1</span>))) = <span class="type">Cat</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">T_Animal</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">C_Dog</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">C_Cat</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Datatype</span> <span class="type">T_Animal</span> <span class="keyword">where</span></span></span><br><span class="line">  datatypeName _ = <span class="string">"Animal"</span></span><br><span class="line">  moduleName _ = <span class="string">"Main"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Constructor</span> <span class="type">C_Dog</span> <span class="keyword">where</span></span></span><br><span class="line">  conName _ = <span class="string">"Dog"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Constructor</span> <span class="type">C_Cat</span> <span class="keyword">where</span></span></span><br><span class="line">  conName _ = <span class="string">"Cat"</span></span><br></pre></td></tr></table></figure></p>
<p>在<code>GHCi</code>中使用<code>kind!</code>我们可以查看与<code>Generic</code>(泛型)实例相关联的<code>type family</code>表示(<code>Rep/Representative</code>)<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">λ: :kind! <span class="type">Rep</span> <span class="type">Animal</span></span><br><span class="line"><span class="type">Rep</span> <span class="type">Animal</span> :: * -&gt; *</span><br><span class="line">= <span class="type">M1</span> <span class="type">D</span> <span class="type">T_Animal</span> (<span class="type">M1</span> <span class="type">C</span> <span class="type">C_Dog</span> <span class="type">U1</span> :+: <span class="type">M1</span> <span class="type">C</span> <span class="type">C_Cat</span> <span class="type">U1</span>)</span><br><span class="line"></span><br><span class="line">λ: :kind! <span class="type">Rep</span> ()</span><br><span class="line"><span class="type">Rep</span> () :: * -&gt; *</span><br><span class="line">= <span class="type">M1</span> <span class="type">D</span> <span class="type">GHC</span>.<span class="type">Generics</span>.<span class="type">D1</span>() (<span class="type">M1</span> <span class="type">C</span> <span class="type">GHC</span>.<span class="type">Generics</span>.<span class="type">C1_0</span>() <span class="type">U1</span>)</span><br><span class="line"></span><br><span class="line">λ: :kind! <span class="type">Rep</span> [()]</span><br><span class="line"><span class="type">Rep</span> [()] :: * -&gt; *</span><br><span class="line">= <span class="type">M1</span></span><br><span class="line">    <span class="type">D</span></span><br><span class="line">    <span class="type">GHC</span>.<span class="type">Generics</span>.<span class="type">D1</span>[]</span><br><span class="line">    (<span class="type">M1</span> <span class="type">C</span> <span class="type">GHC</span>.<span class="type">Generics</span>.<span class="type">C1_0</span>[] <span class="type">U1</span></span><br><span class="line">     :+: <span class="type">M1</span></span><br><span class="line">           <span class="type">C</span></span><br><span class="line">           <span class="type">GHC</span>.<span class="type">Generics</span>.<span class="type">C1_1</span>[]</span><br><span class="line">           (<span class="type">M1</span> <span class="type">S</span> <span class="type">NoSelector</span> (<span class="type">K1</span> <span class="type">R</span> ()) :*: <span class="type">M1</span> <span class="type">S</span> <span class="type">NoSelector</span> (<span class="type">K1</span> <span class="type">R</span> [()])))</span><br></pre></td></tr></table></figure></p>
<p>现在聪明的一点是，我们没有在<code>datatype</code>(数据类型)上编写<code>generic</code>(泛型)函数，而是在<code>Rep</code>上编写了它，然后使用<code>from</code>来<code>reify</code>(具体化)结果.<br>因此，对于<code>Haskell</code>默认<code>Eq</code>的等效版本，它改用<code>generic deriving</code>(泛型派生)，我们可以这样写:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">GEq'</span> f <span class="keyword">where</span></span></span><br><span class="line">  geq' :: f a -&gt; f a -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">GEq'</span> <span class="type">U1</span> <span class="keyword">where</span></span></span><br><span class="line">  geq' _ _ = <span class="type">True</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">GEq</span> <span class="title">c</span>) =&gt; <span class="type">GEq'</span> (<span class="type">K1</span> <span class="title">i</span> <span class="title">c</span>) <span class="keyword">where</span></span></span><br><span class="line">  geq' (<span class="type">K1</span> a) (<span class="type">K1</span> b) = geq a b</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">GEq</span>' <span class="title">a</span>) =&gt; <span class="type">GEq'</span> (<span class="type">M1</span> <span class="title">i</span> <span class="title">c</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">  geq' (<span class="type">M1</span> a) (<span class="type">M1</span> b) = geq' a b</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Equality for sums.</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">GEq</span>' <span class="title">a</span>, <span class="type">GEq</span>' <span class="title">b</span>) =&gt; <span class="type">GEq'</span> (<span class="title">a</span> :+: <span class="title">b</span>) <span class="keyword">where</span></span></span><br><span class="line">  geq' (<span class="type">L1</span> a) (<span class="type">L1</span> b) = geq' a b</span><br><span class="line">  geq' (<span class="type">R1</span> a) (<span class="type">R1</span> b) = geq' a b</span><br><span class="line">  geq' _      _      = <span class="type">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Equality for products.</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">GEq</span>' <span class="title">a</span>, <span class="type">GEq</span>' <span class="title">b</span>) =&gt; <span class="type">GEq'</span> (<span class="title">a</span> :*: <span class="title">b</span>) <span class="keyword">where</span></span></span><br><span class="line">  geq' (a1 :*: b1) (a2 :*: b2) = geq' a1 a2 &amp;&amp; geq' b1 b2</span><br></pre></td></tr></table></figure></p>
<p>为了适应编写类的两种方法(<code>generic-deriving</code>或自定义实现),我们可以使用<code>DefaultSignatures</code>扩展来允许用户将<code>typeclass</code>函数留空，并遵从<code>Generic</code>(泛型)或定义它们自己的函数。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DefaultSignatures #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">GEq</span> a <span class="keyword">where</span></span></span><br><span class="line">  geq :: a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span> geq :: (<span class="type">Generic</span> <span class="title">a</span>, <span class="type">GEq</span>' (<span class="type">Rep</span> <span class="title">a</span>)) =&gt; a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line">  geq x y = geq' (from x) (from y)</span><br></pre></td></tr></table></figure></p>
<p>现在，使用我们库的任何人都只需要(派生)<code>derive Generic</code>并创建我们的<code>typeclass</code>实例的空实例，而无需为<code>GEq</code>编写任何样板。</p>
<p>以下是<code>deriving equality generics</code>(派生相等泛型)的完整示例:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleContexts #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DefaultSignatures #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.Generics</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Auxiliary class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">GEq'</span> f <span class="keyword">where</span></span></span><br><span class="line">  geq' :: f a -&gt; f a -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">GEq'</span> <span class="type">U1</span> <span class="keyword">where</span></span></span><br><span class="line">  geq' _ _ = <span class="type">True</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">GEq</span> <span class="title">c</span>) =&gt; <span class="type">GEq'</span> (<span class="type">K1</span> <span class="title">i</span> <span class="title">c</span>) <span class="keyword">where</span></span></span><br><span class="line">  geq' (<span class="type">K1</span> a) (<span class="type">K1</span> b) = geq a b</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">GEq</span>' <span class="title">a</span>) =&gt; <span class="type">GEq'</span> (<span class="type">M1</span> <span class="title">i</span> <span class="title">c</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">  geq' (<span class="type">M1</span> a) (<span class="type">M1</span> b) = geq' a b</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">GEq</span>' <span class="title">a</span>, <span class="type">GEq</span>' <span class="title">b</span>) =&gt; <span class="type">GEq'</span> (<span class="title">a</span> :+: <span class="title">b</span>) <span class="keyword">where</span></span></span><br><span class="line">  geq' (<span class="type">L1</span> a) (<span class="type">L1</span> b) = geq' a b</span><br><span class="line">  geq' (<span class="type">R1</span> a) (<span class="type">R1</span> b) = geq' a b</span><br><span class="line">  geq' _      _      = <span class="type">False</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">GEq</span>' <span class="title">a</span>, <span class="type">GEq</span>' <span class="title">b</span>) =&gt; <span class="type">GEq'</span> (<span class="title">a</span> :*: <span class="title">b</span>) <span class="keyword">where</span></span></span><br><span class="line">  geq' (a1 :*: b1) (a2 :*: b2) = geq' a1 a2 &amp;&amp; geq' b1 b2</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">GEq</span> a <span class="keyword">where</span></span></span><br><span class="line">  geq :: a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line">  <span class="keyword">default</span> geq :: (<span class="type">Generic</span> <span class="title">a</span>, <span class="type">GEq</span>' (<span class="type">Rep</span> <span class="title">a</span>)) =&gt; a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line">  geq x y = geq' (from x) (from y)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Base equalities</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">GEq</span> <span class="type">Char</span> <span class="keyword">where</span></span> geq = (==)</span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">GEq</span> <span class="type">Int</span> <span class="keyword">where</span></span> geq = (==)</span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">GEq</span> <span class="type">Float</span> <span class="keyword">where</span></span> geq = (==)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Equalities derived from structure of (:+:) and (:*:)</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">GEq</span> a =&gt; <span class="type">GEq</span> (<span class="type">Maybe</span> <span class="title">a</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">GEq</span> <span class="title">a</span>, <span class="type">GEq</span> <span class="title">b</span>) =&gt; <span class="type">GEq</span> (<span class="title">a</span>,<span class="title">b</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">main :: <span class="type">IO</span> ()</span></span><br><span class="line"><span class="class">main = do</span></span><br><span class="line"><span class="class">  print $ geq 2 (3 :: <span class="type">Int</span>)</span></span><br><span class="line"><span class="class">  print $ geq 'a' 'b'</span></span><br><span class="line"><span class="class">  print $ geq (<span class="type">Just</span> '<span class="title">a'</span>) (<span class="type">Just</span> '<span class="title">a'</span>)</span></span><br><span class="line"><span class="class">  print $ geq ('<span class="title">a'</span>,'<span class="title">b'</span>) ('<span class="title">a'</span>, '<span class="title">b'</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>請看:</p>
<ul>
<li><a href="http://www.stephendiehl.com/posts/generics.html" target="_blank" rel="noopener">Cooking Classes with Datatype Generic Programming</a></li>
<li><a href="http://www.andres-loeh.de/DGP-Intro.pdf" target="_blank" rel="noopener">Datatype-generic Programming in Haskell</a></li>
<li><a href="http://hackage.haskell.org/package/generic-deriving-1.6.3" target="_blank" rel="noopener">generic-deriving</a></li>
</ul>
<h3 id="Generic-Deriving"><a href="#Generic-Deriving" class="headerlink" title="Generic Deriving"></a>Generic Deriving</h3><p>使用<code>Generics</code>(泛型)，许多通用库提供了一种派生<code>common</code>(通用)类型类实例的机制。一些真实的例子：<br><a href="http://hackage.haskell.org/package/hashable" target="_blank" rel="noopener">hashable</a>库允许我们派生<code>hash</code>函数。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DeriveGeneric #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.Generics (<span class="type">Generic</span>)</span><br><span class="line"><span class="keyword">import</span> Data.Hashable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Color</span> = <span class="type">Red</span> | <span class="type">Green</span> | <span class="type">Blue</span> <span class="keyword">deriving</span> (<span class="type">Generic</span>, <span class="type">Show</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Hashable</span> <span class="type">Color</span> <span class="keyword">where</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">example1</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">example1</span> = hash <span class="type">Red</span></span><br><span class="line"><span class="comment">-- 839657738087498284</span></span><br><span class="line"></span><br><span class="line"><span class="title">example2</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">example2</span> = hashWithSalt <span class="number">0xDEADBEEF</span> <span class="type">Red</span></span><br><span class="line"><span class="comment">-- 62679985974121021</span></span><br></pre></td></tr></table></figure></p>
<p><a href="http://hackage.haskell.org/package/cereal-0.4.0.1" target="_blank" rel="noopener">cereal</a>库允许我们派生二进制表示。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DeriveGeneric #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Word</span><br><span class="line"><span class="keyword">import</span> Data.ByteString</span><br><span class="line"><span class="keyword">import</span> Data.Serialize</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.Generics</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Val</span> = <span class="type">A</span> [<span class="type">Val</span>] | <span class="type">B</span> [(<span class="type">Val</span>, <span class="type">Val</span>)] | <span class="type">C</span></span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Generic</span>, <span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Serialize</span> <span class="type">Val</span> <span class="keyword">where</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">encoded</span> :: <span class="type">ByteString</span></span><br><span class="line"><span class="title">encoded</span> = encode (<span class="type">A</span> [<span class="type">B</span> [(<span class="type">C</span>, <span class="type">C</span>)]])</span><br><span class="line"><span class="comment">-- "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\SOH\SOH\NUL\NUL\NUL\NUL\NUL\NUL\NUL\SOH\STX\STX"</span></span><br><span class="line"></span><br><span class="line"><span class="title">bytes</span> :: [<span class="type">Word8</span>]</span><br><span class="line"><span class="title">bytes</span> = unpack encoded</span><br><span class="line"><span class="comment">-- [0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,2,2]</span></span><br><span class="line"></span><br><span class="line"><span class="title">decoded</span> :: <span class="type">Either</span> <span class="type">String</span> <span class="type">Val</span></span><br><span class="line"><span class="title">decoded</span> = decode encoded</span><br></pre></td></tr></table></figure></p>
<p><a href="http://hackage.haskell.org/package/aeson" target="_blank" rel="noopener">aeson</a>库允许我们為<code>JSON instances</code>派生JSON表示形式。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DeriveGeneric #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE OverloadedStrings #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Aeson</span><br><span class="line"><span class="keyword">import</span> GHC.Generics</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> &#123; <span class="title">_x</span> :: <span class="type">Double</span>, <span class="title">_y</span> :: <span class="type">Double</span> &#125;</span></span><br><span class="line">   <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Generic</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">FromJSON</span> <span class="type">Point</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">ToJSON</span> <span class="type">Point</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">example1 :: <span class="type">Maybe</span> <span class="type">Point</span></span></span><br><span class="line"><span class="class">example1 = decode "&#123;\"x\":3.0,\"y\":-1.0&#125;"</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">example2 = encode $ <span class="type">Point</span> 123.4 20</span></span><br></pre></td></tr></table></figure></p>
<p>請看: <a href="http://dreixel.net/research/pdf/gdmh.pdf" target="_blank" rel="noopener">A Generic Deriving Mechanism for Haskell</a> (Haskell的通用派生机制)</p>
<h4 id="Higher-Kinded-Generics"><a href="#Higher-Kinded-Generics" class="headerlink" title="Higher Kinded Generics"></a>Higher Kinded Generics</h4><p>使用相同的接口<code>GHC.Generics</code>为<code>higher-kinded</code>(更高种类)的<code>generics</code>(泛型)提供了单独的类型类。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Generic1</span> f <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="type">Rep1</span> f :: * -&gt; *</span></span><br><span class="line">  from1  :: f a -&gt; (<span class="type">Rep1</span> f) a</span><br><span class="line">  to1    :: (<span class="type">Rep1</span> f) a -&gt; f a</span><br></pre></td></tr></table></figure></p>
<p>例如<code>Maybe</code>的<code>Rep1</code>实例格式为：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">Rep1</span> <span class="type">Maybe</span></span></span><br><span class="line">  = <span class="type">D1</span></span><br><span class="line">      <span class="type">GHC</span>.<span class="type">Generics</span>.<span class="type">D1Maybe</span></span><br><span class="line">      (<span class="type">C1</span> <span class="type">C1_0Maybe</span> <span class="type">U1</span></span><br><span class="line">       :+: <span class="type">C1</span> <span class="type">C1_1Maybe</span> (<span class="type">S1</span> <span class="type">NoSelector</span> <span class="type">Par1</span>))</span><br></pre></td></tr></table></figure></p>
<h3 id="generics-sop"><a href="#generics-sop" class="headerlink" title="generics-sop"></a>generics-sop</h3><blockquote>
<p>TODO</p>
</blockquote>
<h3 id="Uniplate"><a href="#Uniplate" class="headerlink" title="Uniplate"></a>Uniplate</h3><p><code>Uniplate</code>是用于编写遍历和转换任意数据结构的泛型库。这对于编写<code>AST</code>转换和<code>rewriting systems</code>(重写系统)非常有用。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">plate</span> :: from -&gt; <span class="type">Type</span> from to</span><br><span class="line">(|*)  :: <span class="type">Type</span> (to -&gt; from) to -&gt; to -&gt; <span class="type">Type</span> from to</span><br><span class="line">(|-)  :: <span class="type">Type</span> (item -&gt; from) to -&gt; item -&gt; <span class="type">Type</span> from to</span><br><span class="line"></span><br><span class="line"><span class="title">descend</span>   :: <span class="type">Uniplate</span> on =&gt; (on -&gt; on) -&gt; on -&gt; on</span><br><span class="line"><span class="title">transform</span> :: <span class="type">Uniplate</span> on =&gt; (on -&gt; on) -&gt; on -&gt; on</span><br><span class="line"><span class="title">rewrite</span>   :: <span class="type">Uniplate</span> on =&gt; (on -&gt; <span class="type">Maybe</span> on) -&gt; on -&gt; on</span><br></pre></td></tr></table></figure></p>
<p><code>descend</code>函数将对表达式的每个直接后代应用一个函数，然后将它们<code>combines</code>(组合)到父表达式。</p>
<p><code>transform</code>函數将对表达式中的所有项执行一次自下而上的转换。</p>
<p><code>rewrite</code>函数将把表达式中的所有项彻底转换为<code>fixed point</code>(不动点)，使用<code>Maybe</code>表示终止。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.Generics.Uniplate.Direct</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span> a</span></span><br><span class="line">  = <span class="type">Fls</span></span><br><span class="line">  | <span class="type">Tru</span></span><br><span class="line">  | <span class="type">Var</span> a</span><br><span class="line">  | <span class="type">Not</span> (<span class="type">Expr</span> a)</span><br><span class="line">  | <span class="type">And</span> (<span class="type">Expr</span> a) (<span class="type">Expr</span> a)</span><br><span class="line">  | <span class="type">Or</span>  (<span class="type">Expr</span> a) (<span class="type">Expr</span> a)</span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Uniplate</span> (<span class="type">Expr</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">  uniplate (<span class="type">Not</span> f)     = plate <span class="type">Not</span> |* f</span><br><span class="line">  uniplate (<span class="type">And</span> f1 f2) = plate <span class="type">And</span> |* f1 |* f2</span><br><span class="line">  uniplate (<span class="type">Or</span> f1 f2)  = plate <span class="type">Or</span> |* f1 |* f2</span><br><span class="line">  uniplate x           = plate x</span><br><span class="line"></span><br><span class="line"><span class="title">simplify</span> :: <span class="type">Expr</span> a -&gt; <span class="type">Expr</span> a</span><br><span class="line"><span class="title">simplify</span> = transform simp</span><br><span class="line"> <span class="keyword">where</span></span><br><span class="line">   simp (<span class="type">Not</span> (<span class="type">Not</span> f)) = f</span><br><span class="line">   simp (<span class="type">Not</span> <span class="type">Fls</span>) = <span class="type">Tru</span></span><br><span class="line">   simp (<span class="type">Not</span> <span class="type">Tru</span>) = <span class="type">Fls</span></span><br><span class="line">   simp x = x</span><br><span class="line"></span><br><span class="line"><span class="title">reduce</span> :: <span class="type">Show</span> a =&gt; <span class="type">Expr</span> a -&gt; <span class="type">Expr</span> a</span><br><span class="line"><span class="title">reduce</span> = rewrite cnf</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    <span class="comment">-- double negation</span></span><br><span class="line">    cnf (<span class="type">Not</span> (<span class="type">Not</span> p)) = <span class="type">Just</span> p</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- de Morgan</span></span><br><span class="line">    cnf (<span class="type">Not</span> (p `<span class="type">Or</span>` q))  = <span class="type">Just</span> $ (<span class="type">Not</span> p) `<span class="type">And</span>` (<span class="type">Not</span> q)</span><br><span class="line">    cnf (<span class="type">Not</span> (p `<span class="type">And</span>` q)) = <span class="type">Just</span> $ (<span class="type">Not</span> p) `<span class="type">Or</span>` (<span class="type">Not</span> q)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- distribute conjunctions</span></span><br><span class="line">    cnf (p `<span class="type">Or</span>` (q `<span class="type">And</span>` r)) = <span class="type">Just</span> $ (p `<span class="type">Or</span>` q) `<span class="type">And</span>` (p `<span class="type">Or</span>` r)</span><br><span class="line">    cnf ((p `<span class="type">And</span>` q) `<span class="type">Or</span>` r) = <span class="type">Just</span> $ (p `<span class="type">Or</span>` q) `<span class="type">And</span>` (p `<span class="type">Or</span>` r)</span><br><span class="line">    cnf _ = <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">example1</span> :: <span class="type">Expr</span> <span class="type">String</span></span><br><span class="line"><span class="title">example1</span> = simplify (<span class="type">Not</span> (<span class="type">Not</span> (<span class="type">Not</span> (<span class="type">Not</span> (<span class="type">Var</span> <span class="string">"a"</span>)))))</span><br><span class="line"><span class="comment">-- Var "a"</span></span><br><span class="line"></span><br><span class="line"><span class="title">example2</span> :: [<span class="type">String</span>]</span><br><span class="line"><span class="title">example2</span> = [a | <span class="type">Var</span> a &lt;- universe ex]</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    ex = <span class="type">Or</span> (<span class="type">And</span> (<span class="type">Var</span> <span class="string">"a"</span>) (<span class="type">Var</span> <span class="string">"b"</span>)) (<span class="type">Not</span> (<span class="type">And</span> (<span class="type">Var</span> <span class="string">"c"</span>) (<span class="type">Var</span> <span class="string">"d"</span>)))</span><br><span class="line"><span class="comment">-- ["a","b","c","d"]</span></span><br><span class="line"></span><br><span class="line"><span class="title">example3</span> :: <span class="type">Expr</span> <span class="type">String</span></span><br><span class="line"><span class="title">example3</span> = reduce $ ((a `<span class="type">And</span>` b) `<span class="type">Or</span>` (c `<span class="type">And</span>` d)) `<span class="type">Or</span>` e</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    a = <span class="type">Var</span> <span class="string">"a"</span></span><br><span class="line">    b = <span class="type">Var</span> <span class="string">"b"</span></span><br><span class="line">    c = <span class="type">Var</span> <span class="string">"c"</span></span><br><span class="line">    d = <span class="type">Var</span> <span class="string">"d"</span></span><br><span class="line">    e = <span class="type">Var</span> <span class="string">"e"</span></span><br></pre></td></tr></table></figure></p>
<p>另外，<code>Uniplate</code>实例可以从<code>Data</code>实例自动派生而无需显式编写<code>Uniplate</code>实例。这种方法在显式的手写实例上会产生少量开销。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.Data</span><br><span class="line"><span class="keyword">import</span> Data.Typeable</span><br><span class="line"><span class="keyword">import</span> Data.Generics.Uniplate.Data</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span> a</span></span><br><span class="line">  = <span class="type">Fls</span></span><br><span class="line">  | <span class="type">Tru</span></span><br><span class="line">  | <span class="type">Lit</span> a</span><br><span class="line">  | <span class="type">Not</span> (<span class="type">Expr</span> a)</span><br><span class="line">  | <span class="type">And</span> (<span class="type">Expr</span> a) (<span class="type">Expr</span> a)</span><br><span class="line">  | <span class="type">Or</span> (<span class="type">Expr</span> a) (<span class="type">Expr</span> a)</span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Data</span>, <span class="type">Typeable</span>, <span class="type">Show</span>, <span class="type">Eq</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="Biplate"><a href="#Biplate" class="headerlink" title="Biplate"></a>Biplate</h4><p><code>Biplates</code>泛化目标类型不一定与源类型相同的<code>plates</code>(板)，它使用多参数类型类来指示<code>sub-target</code>(子目标)的<code>type sub</code>(类型子)。<br><code>Uniplate</code>函数都具有等价的广义<code>biplate</code>形式。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">descendBi</span>   :: <span class="type">Biplate</span> from to =&gt; (to -&gt; to) -&gt; from -&gt; from</span><br><span class="line"><span class="title">transformBi</span> :: <span class="type">Biplate</span> from to =&gt; (to -&gt; to) -&gt; from -&gt; from</span><br><span class="line"><span class="title">rewriteBi</span>   :: <span class="type">Biplate</span> from to =&gt; (to -&gt; <span class="type">Maybe</span> to) -&gt; from -&gt; from</span><br><span class="line"></span><br><span class="line"><span class="title">descendBiM</span>   :: (<span class="type">Monad</span> m, <span class="type">Biplate</span> from to) =&gt; (to -&gt; m to) -&gt; from -&gt; m from</span><br><span class="line"><span class="title">transformBiM</span> :: (<span class="type">Monad</span> m, <span class="type">Biplate</span> from to) =&gt; (to -&gt; m to) -&gt; from -&gt; m from</span><br><span class="line"><span class="title">rewriteBiM</span>   :: (<span class="type">Monad</span> m, <span class="type">Biplate</span> from to) =&gt; (to -&gt; m (<span class="type">Maybe</span> to)) -&gt; from -&gt; m from</span><br><span class="line"><span class="meta">&#123;-# LANGUAGE MultiParamTypeClasses #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleContexts #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Generics.Uniplate.Direct</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Name</span> = <span class="type">String</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span></span></span><br><span class="line">  = <span class="type">Var</span> <span class="type">Name</span></span><br><span class="line">  | <span class="type">Lam</span> <span class="type">Name</span> <span class="type">Expr</span></span><br><span class="line">  | <span class="type">App</span> <span class="type">Expr</span> <span class="type">Expr</span></span><br><span class="line">  <span class="keyword">deriving</span> <span class="type">Show</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Stmt</span></span></span><br><span class="line">  = <span class="type">Decl</span> [<span class="type">Stmt</span>]</span><br><span class="line">  | <span class="type">Let</span> <span class="type">Name</span> <span class="type">Expr</span></span><br><span class="line">  <span class="keyword">deriving</span> <span class="type">Show</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Uniplate</span> <span class="type">Expr</span> <span class="keyword">where</span></span></span><br><span class="line">  uniplate (<span class="type">Var</span> x  ) = plate <span class="type">Var</span> |- x</span><br><span class="line">  uniplate (<span class="type">App</span> x y) = plate <span class="type">App</span> |* x |* y</span><br><span class="line">  uniplate (<span class="type">Lam</span> x y) = plate <span class="type">Lam</span> |- x |* y</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Biplate</span> <span class="type">Expr</span> <span class="type">Expr</span> <span class="keyword">where</span></span></span><br><span class="line">  biplate = plateSelf</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Uniplate</span> <span class="type">Stmt</span> <span class="keyword">where</span></span></span><br><span class="line">  uniplate (<span class="type">Decl</span> x  ) = plate <span class="type">Decl</span> ||* x</span><br><span class="line">  uniplate (<span class="type">Let</span> x y) = plate <span class="type">Let</span> |-  x |- y</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Biplate</span> <span class="type">Stmt</span> <span class="type">Stmt</span> <span class="keyword">where</span></span></span><br><span class="line">  biplate = plateSelf</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Biplate</span> <span class="type">Stmt</span> <span class="type">Expr</span> <span class="keyword">where</span></span></span><br><span class="line">  biplate (<span class="type">Decl</span> x) = plate <span class="type">Decl</span> ||+ x</span><br><span class="line">  biplate (<span class="type">Let</span> x y) = plate <span class="type">Let</span> |- x |* y</span><br><span class="line"></span><br><span class="line"><span class="title">rename</span> :: <span class="type">Name</span> -&gt; <span class="type">Name</span> -&gt; <span class="type">Expr</span> -&gt; <span class="type">Expr</span></span><br><span class="line"><span class="title">rename</span> from to = rewrite f</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    f (<span class="type">Var</span> a) | a == from = <span class="type">Just</span> (<span class="type">Var</span> to)</span><br><span class="line">    f (<span class="type">Lam</span> a b) | a == from = <span class="type">Just</span> (<span class="type">Lam</span> to b)</span><br><span class="line">    f _ = <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="title">s</span>, k, sk :: <span class="type">Expr</span></span><br><span class="line"><span class="title">s</span> = <span class="type">Lam</span> <span class="string">"x"</span> (<span class="type">Lam</span> <span class="string">"y"</span> (<span class="type">Lam</span> <span class="string">"z"</span> (<span class="type">App</span> (<span class="type">App</span> (<span class="type">Var</span> <span class="string">"x"</span>) (<span class="type">Var</span> <span class="string">"z"</span>)) (<span class="type">App</span> (<span class="type">Var</span> <span class="string">"y"</span>) (<span class="type">Var</span> <span class="string">"z"</span>)))))</span><br><span class="line"><span class="title">k</span> = <span class="type">Lam</span> <span class="string">"x"</span> (<span class="type">Lam</span> <span class="string">"y"</span> (<span class="type">Var</span> <span class="string">"x"</span>))</span><br><span class="line"><span class="title">sk</span> = <span class="type">App</span> s k</span><br><span class="line"></span><br><span class="line"><span class="title">m</span> :: <span class="type">Stmt</span></span><br><span class="line"><span class="title">m</span> = descendBi f $ <span class="type">Decl</span> [ (<span class="type">Let</span> <span class="string">"s"</span> s) , <span class="type">Let</span> <span class="string">"k"</span> k , <span class="type">Let</span> <span class="string">"sk"</span> sk ]</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    f = rename <span class="string">"x"</span> <span class="string">"a"</span></span><br><span class="line">      . rename <span class="string">"y"</span> <span class="string">"b"</span></span><br><span class="line">      . rename <span class="string">"z"</span> <span class="string">"c"</span></span><br></pre></td></tr></table></figure></p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> thank you </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
        <span><a href="https://serokell.io/blog">serokell</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/blog/js/index.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/blog/js/gitment.js"></script>
<script>
    var gitment = new Gitment({
        id: 'Haskell-Generics',
        owner: 'limengyu1990',
        repo: 'hexo-blog',
        oauth: {
            client_id: '7cfc73dd62b57f07ed83',
            client_secret: 'dd03b7e54aadf0d81e4c9c93e23a41272bcfcfa1',
        },
    })
    gitment.render('comment-container')
</script>

</html>
