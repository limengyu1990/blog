<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        Haskell-Promotion - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>不负如来不负卿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Higher-Kinded-Types"><span class="toc-text">Higher Kinded Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kind-Polymorphism"><span class="toc-text">Kind Polymorphism</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Kinds"><span class="toc-text">Data Kinds</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Size-Indexed-Vectors"><span class="toc-text">Size-Indexed Vectors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Typelevel-Numbers"><span class="toc-text">Typelevel Numbers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Typelevel-Strings"><span class="toc-text">Typelevel Strings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Custom-Errors"><span class="toc-text">Custom Errors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Type-Equality"><span class="toc-text">Type Equality</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxies-代理人"><span class="toc-text">Proxies (代理人)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promoted-Syntax"><span class="toc-text">Promoted Syntax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Singleton-Types"><span class="toc-text">Singleton Types</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Promoted-Naturals"><span class="toc-text">Promoted Naturals</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Closed-Type-Families"><span class="toc-text">Closed Type Families</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kind-Indexed-Type-Families"><span class="toc-text">Kind Indexed Type Families</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promoted-Symbols"><span class="toc-text">Promoted Symbols</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HLists"><span class="toc-text">HLists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Typelevel-Dictionaries"><span class="toc-text">Typelevel Dictionaries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Advanced-Proofs"><span class="toc-text">Advanced Proofs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Liquid-Haskell"><span class="toc-text">Liquid Haskell</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Haskell-Promotion
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-10-09 10:52:54</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/blog/tags/#Wish-Knew" title="Wish-Knew">Wish-Knew</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Haskell" title="Haskell">Haskell</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Promotion" title="Promotion">Promotion</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p><a href="http://dev.stephendiehl.com/hask/#promotion" target="_blank" rel="noopener">原文</a></p>
</blockquote>
<h3 id="Higher-Kinded-Types"><a href="#Higher-Kinded-Types" class="headerlink" title="Higher Kinded Types"></a>Higher Kinded Types</h3><p><code>higher kinded types</code>是什麼?<br>与大多数其他语言相比，<code>Haskell</code>中的<code>kind</code>系统是独特的，因为它允许构造将<code>types</code>(类型)和<code>type constructors</code>(类型构造函数)带到其他类型的<code>datatypes</code>(数据类型)。<br>据说这样的系统支持<code>higher kinded types</code>。</p>
<p><code>haskell</code>中的所有<code>Kind</code>註解都必然会产生一個<code>kind *</code>，尽管左边的任何<code>terms</code>(术语)都可能是<code>higher-kinded</code>(<code>* -&gt; *</code>)。<br>常见的例子是<code>Monad</code>，它的种类为<code>* -&gt; *</code>。<br>但是我们也已经在<code>free monads</code>中看到了这种<code>higher-kindedness</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Free</span> f a where</span></span><br><span class="line">  <span class="type">Pure</span> :: a -&gt; <span class="type">Free</span> f a</span><br><span class="line">  <span class="type">Free</span> :: f (<span class="type">Free</span> f a) -&gt; <span class="type">Free</span> f a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Cofree</span> f a where</span></span><br><span class="line">  <span class="type">Cofree</span> :: a -&gt; f (<span class="type">Cofree</span> f a) -&gt; <span class="type">Cofree</span> f a</span><br><span class="line"><span class="type">Free</span> :: (* -&gt; *) -&gt; * -&gt; *</span><br><span class="line"><span class="type">Cofree</span> :: (* -&gt; *) -&gt; * -&gt; *</span><br></pre></td></tr></table></figure></p>
<p>例如，对于某些<code>monokinded</code>(单种)类型<code>a</code>的<code>Cofree Maybe a</code>可以通过<code>Maybe :: * -&gt; *</code>来建模非空列表。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Cofree Maybe a is a non-empty list</span></span><br><span class="line"><span class="title">testCofree</span> :: <span class="type">Cofree</span> <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">testCofree</span> = (<span class="type">Cofree</span> <span class="number">1</span> (<span class="type">Just</span> (<span class="type">Cofree</span> <span class="number">2</span> <span class="type">Nothing</span>)))</span><br></pre></td></tr></table></figure></p>
<h3 id="Kind-Polymorphism"><a href="#Kind-Polymorphism" class="headerlink" title="Kind Polymorphism"></a>Kind Polymorphism</h3><blockquote>
<p>这是高级部分，编写Haskell通常不需要了解<code>kind polymorphism</code>(种类多态性)。</p>
</blockquote>
<p><code>regular</code>(正则/常規)值级函数接受一个函数并将其应用于一个参数，它被普遍地推广到通常的<code>hindley-milner</code>方法中。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">app</span> :: <span class="keyword">forall</span> a b. (a -&gt; b) -&gt; a -&gt; b</span><br><span class="line"><span class="title">app</span> f a = f a</span><br></pre></td></tr></table></figure></p>
<p>但是，当我们在<code>type-level</code>(类型级别)执行相同的操作时，我们会发现丢失了有关所应用构造函数的<code>polymorphism</code>(多态性)的信息。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- TApp :: (* -&gt; *) -&gt; * -&gt; *</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">TApp</span> f a = <span class="type">MkTApp</span> (<span class="title">f</span> <span class="title">a</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>启用<code>-XPolyKinds</code>擴展也会允许<code>kind</code>级别的<code>polymorphic</code>(多态)变量。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Default:   (* -&gt; *) -&gt; * -&gt; *</span></span><br><span class="line"><span class="comment">-- PolyKinds: (k -&gt; *) -&gt; k -&gt; *</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">TApp</span> f a = <span class="type">MkTApp</span> (<span class="title">f</span> <span class="title">a</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Default:   ((* -&gt; *) -&gt; (* -&gt; *)) -&gt; (* -&gt; *)</span></span><br><span class="line"><span class="comment">-- PolyKinds: ((k -&gt; *) -&gt; (k -&gt; *)) -&gt; (k -&gt; *)</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Mu</span> f a = <span class="type">Roll</span> (<span class="title">f</span> (<span class="type">Mu</span> <span class="title">f</span>) a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Default:   * -&gt; *</span></span><br><span class="line"><span class="comment">-- PolyKinds: k -&gt; *</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Proxy</span> a = <span class="type">Proxy</span></span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>polykinded</code>(多种类)的<code>Proxy</code>类型允许我们在任意<code>kind</code>(种类)的构造函数上写下类型类函数。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE PolyKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE KindSignatures #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Proxy</span> a = <span class="type">Proxy</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Rep</span> = <span class="type">Rep</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">PolyClass</span> a <span class="keyword">where</span></span></span><br><span class="line">  foo :: <span class="type">Proxy</span> a -&gt; <span class="type">Rep</span></span><br><span class="line">  foo = const <span class="type">Rep</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- () :: *</span></span><br><span class="line"><span class="comment">-- [] :: * -&gt; *</span></span><br><span class="line"><span class="comment">-- Either :: * -&gt; * -&gt; *</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">PolyClass</span> ()</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">PolyClass</span> []</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">PolyClass</span> <span class="type">Either</span></span></span><br></pre></td></tr></table></figure></p>
<p>例如，我们现在可以在类型级别上写下<code>polymorphic</code>(多态)<code>S K combinators</code>(组合器)。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE PolyKinds #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">I</span> (<span class="title">a</span> :: *) = <span class="type">I</span> a</span></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">K</span> (<span class="title">a</span> :: *) (<span class="title">b</span> :: <span class="title">k</span>) = <span class="type">K</span> a</span></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Flip</span> (<span class="title">f</span> :: <span class="title">k1</span> -&gt; <span class="title">k2</span> -&gt; *) (<span class="title">x</span> :: <span class="title">k2</span>) (<span class="title">y</span> :: <span class="title">k1</span>) = <span class="type">Flip</span> (<span class="title">f</span> <span class="title">y</span> <span class="title">x</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="title">unI</span> :: <span class="type">I</span> a -&gt; a</span><br><span class="line"><span class="title">unI</span> (<span class="type">I</span> x) = x</span><br><span class="line"></span><br><span class="line"><span class="title">unK</span> :: <span class="type">K</span> a b -&gt; a</span><br><span class="line"><span class="title">unK</span> (<span class="type">K</span> x) = x</span><br><span class="line"></span><br><span class="line"><span class="title">unFlip</span> :: <span class="type">Flip</span> f x y -&gt; f y x</span><br><span class="line"><span class="title">unFlip</span> (<span class="type">Flip</span> x) = x</span><br></pre></td></tr></table></figure></p>
<h3 id="Data-Kinds"><a href="#Data-Kinds" class="headerlink" title="Data Kinds"></a>Data Kinds</h3><blockquote>
<p>这是高级部分，编写Haskell通常不需要了解<code>Data Kinds</code>。</p>
</blockquote>
<p><code>-XDataKinds</code>扩展允许我们在值级别和类型级别使用<code>refer to</code>(引用)构造函数。考虑一个简单的<code>sum</code>类型:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">S</span> a b = <span class="type">L</span> a | <span class="type">R</span> b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- S :: * -&gt; * -&gt; *</span></span><br><span class="line"><span class="comment">-- L :: a -&gt; S a b</span></span><br><span class="line"><span class="comment">-- R :: b -&gt; S a b</span></span><br></pre></td></tr></table></figure></p>
<p>启用扩展后，我们可以看到我们的类型构造函数现在已自动升级，因此可以将<code>L</code>或<code>R</code>视为类型为<code>S</code>的数据构造函数或<code>kind</code>(種類)为<code>S</code>的<code>L</code>类型的数据构造器。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">S</span> a b = <span class="type">L</span> a | <span class="type">R</span> b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- S :: * -&gt; * -&gt; *</span></span><br><span class="line"><span class="comment">-- L :: * -&gt; S * *</span></span><br><span class="line"><span class="comment">-- R :: * -&gt; S * *</span></span><br></pre></td></tr></table></figure>
<p>可以在类型签名中以单引号作为前缀来引用升级的数据构造函数。<br>同样重要的是，默认情况下，这些提升的构造函数不随模块一起导出，但是可以为勾选的<code>promoted</code>(提升)类型创建<code>type synonym</code>(类型同义词)实例，并直接将其导出。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Foo</span> = <span class="type">Bar</span> | <span class="type">Baz</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Bar</span> = '<span class="type">Bar</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Baz</span> = '<span class="type">Baz</span></span></span><br></pre></td></tr></table></figure></p>
<p>将此与<code>type families</code>相结合，我们看到可以通过将<code>types</code>(类型)提升到<code>kind</code>(种类)级别来编写有意义的类型级别的函数。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Prelude <span class="keyword">hiding</span> (<span class="type">Bool(..)</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Bool</span> = <span class="type">False</span> | <span class="type">True</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Not</span> (<span class="title">a</span> :: <span class="type">Bool</span>) :: <span class="type">Bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">Not</span> <span class="type">True</span> = <span class="type">False</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">Not</span> <span class="type">False</span> = <span class="type">True</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">false</span> :: <span class="type">Not</span> <span class="type">True</span> ~ <span class="type">False</span> =&gt; a</span><br><span class="line"><span class="title">false</span> = undefined</span><br><span class="line"></span><br><span class="line"><span class="title">true</span> :: <span class="type">Not</span> <span class="type">False</span> ~ <span class="type">True</span> =&gt; a</span><br><span class="line"><span class="title">true</span> = undefined</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Fails at compile time.</span></span><br><span class="line"><span class="comment">-- Couldn't match type 'False with 'True</span></span><br><span class="line"><span class="title">invalid</span> :: <span class="type">Not</span> <span class="type">True</span> ~ <span class="type">True</span> =&gt; a</span><br><span class="line"><span class="title">invalid</span> = undefined</span><br></pre></td></tr></table></figure></p>
<h3 id="Size-Indexed-Vectors"><a href="#Size-Indexed-Vectors" class="headerlink" title="Size-Indexed Vectors"></a>Size-Indexed Vectors</h3><p>使用这种新结构，我们现在可以创建一个<code>Vec</code>类型，该类型通过其长度和元素类型进行参数化，因为我们有一种<code>kind</code>(种类)丰富的语言，足以在广义代数数据类型的<code>kind</code>(种类)签名中对后继类型进行编码。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE KindSignatures #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleInstances #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleContexts #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Nat</span> = <span class="type">Z</span> | <span class="type">S</span> <span class="type">Nat</span> <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Zero</span>  = <span class="type">Z</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">One</span>   = <span class="type">S</span> <span class="type">Zero</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Two</span>   = <span class="type">S</span> <span class="type">One</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Three</span> = <span class="type">S</span> <span class="type">Two</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Four</span>  = <span class="type">S</span> <span class="type">Three</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Five</span>  = <span class="type">S</span> <span class="type">Four</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Vec</span> :: <span class="type">Nat</span> -&gt; * -&gt; * where</span></span><br><span class="line">  <span class="type">Nil</span> :: <span class="type">Vec</span> <span class="type">Z</span> a</span><br><span class="line">  <span class="type">Cons</span> :: a -&gt; <span class="type">Vec</span> n a -&gt; <span class="type">Vec</span> (<span class="type">S</span> n) a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Show</span> a =&gt; <span class="type">Show</span> (<span class="type">Vec</span> <span class="title">n</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">  show <span class="type">Nil</span>         = <span class="string">"Nil"</span></span><br><span class="line">  show (<span class="type">Cons</span> x xs) = <span class="string">"Cons "</span> ++ show x ++ <span class="string">" ("</span> ++ show xs ++ <span class="string">")"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">FromList</span> n <span class="keyword">where</span></span></span><br><span class="line">  fromList :: [a] -&gt; <span class="type">Vec</span> n a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">FromList</span> <span class="type">Z</span> <span class="keyword">where</span></span></span><br><span class="line">  fromList [] = <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">FromList</span> n =&gt; <span class="type">FromList</span> (<span class="type">S</span> <span class="title">n</span>) <span class="keyword">where</span></span></span><br><span class="line">  fromList (x:xs) = <span class="type">Cons</span> x $ fromList xs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">lengthVec</span> :: <span class="type">Vec</span> n a -&gt; <span class="type">Nat</span></span><br><span class="line"><span class="title">lengthVec</span> <span class="type">Nil</span> = <span class="type">Z</span></span><br><span class="line"><span class="title">lengthVec</span> (<span class="type">Cons</span> x xs) = <span class="type">S</span> (lengthVec xs)</span><br><span class="line"></span><br><span class="line"><span class="title">zipVec</span> :: <span class="type">Vec</span> n a -&gt; <span class="type">Vec</span> n b -&gt; <span class="type">Vec</span> n (a,b)</span><br><span class="line"><span class="title">zipVec</span> <span class="type">Nil</span> <span class="type">Nil</span> = <span class="type">Nil</span></span><br><span class="line"><span class="title">zipVec</span> (<span class="type">Cons</span> x xs) (<span class="type">Cons</span> y ys) = <span class="type">Cons</span> (x,y) (zipVec xs ys)</span><br><span class="line"></span><br><span class="line"><span class="title">vec4</span> :: <span class="type">Vec</span> <span class="type">Four</span> <span class="type">Int</span></span><br><span class="line"><span class="title">vec4</span> = fromList [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">vec5</span> :: <span class="type">Vec</span> <span class="type">Five</span> <span class="type">Int</span></span><br><span class="line"><span class="title">vec5</span> = fromList [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">example1</span> :: <span class="type">Nat</span></span><br><span class="line"><span class="title">example1</span> = lengthVec vec4</span><br><span class="line"><span class="comment">-- S (S (S (S Z)))</span></span><br><span class="line"></span><br><span class="line"><span class="title">example2</span> :: <span class="type">Vec</span> <span class="type">Four</span> (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="title">example2</span> = zipVec vec4 vec4</span><br><span class="line"><span class="comment">-- Cons (0,0) (Cons (1,1) (Cons (2,2) (Cons (3,3) (Nil))))</span></span><br></pre></td></tr></table></figure></p>
<p>所以现在如果我们尝试<code>zip</code>两个形状错误的<code>vec</code>类型，那么在编译时会得到一个关于<code>off by one</code>错误的错误。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">example2</span> = zipVec vec4 vec5</span><br><span class="line"><span class="comment">-- Couldn't match type 'S 'Z with 'Z</span></span><br><span class="line"><span class="comment">-- Expected type: Vec Four Int</span></span><br><span class="line"><span class="comment">--   Actual type: Vec Five Int</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以使用相同的技术来创建一个由空或非空标志静态索引的容器,这样,如果我们尝试获取空列表的头部,则会得到编译时错误,或者等效地声明为我們有义务向编译器证明我们传递给<code>head</code>函数的参数是非空的。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE KindSignatures #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleInstances #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleContexts #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Size</span> = <span class="type">Empty</span> | <span class="type">NonEmpty</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">List</span> a b where</span></span><br><span class="line">  <span class="type">Nil</span>  :: <span class="type">List</span> <span class="type">Empty</span> a</span><br><span class="line">  <span class="type">Cons</span> :: a -&gt; <span class="type">List</span> b a -&gt; <span class="type">List</span> <span class="type">NonEmpty</span> a</span><br><span class="line"></span><br><span class="line"><span class="title">head'</span> :: <span class="type">List</span> <span class="type">NonEmpty</span> a -&gt; a</span><br><span class="line"><span class="title">head'</span> (<span class="type">Cons</span> x _) = x</span><br><span class="line"></span><br><span class="line"><span class="title">example1</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">example1</span> = head' (<span class="number">1</span> `<span class="type">Cons</span>` (<span class="number">2</span> `<span class="type">Cons</span>` <span class="type">Nil</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Cannot match type Empty with NonEmpty</span></span><br><span class="line"><span class="title">example2</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">example2</span> = head' <span class="type">Nil</span></span><br><span class="line"><span class="type">Couldn't</span> match <span class="class"><span class="keyword">type</span> <span class="type">None</span> with <span class="type">Many</span></span></span><br><span class="line"><span class="type">Expected</span> <span class="class"><span class="keyword">type</span>: <span class="type">List</span> <span class="type">NonEmpty</span> <span class="type">Int</span></span></span><br><span class="line">  <span class="type">Actual</span> <span class="class"><span class="keyword">type</span>: <span class="type">List</span> <span class="type">Empty</span> <span class="type">Int</span></span></span><br></pre></td></tr></table></figure></p>
<p>請看: <a href="https://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf" target="_blank" rel="noopener">Giving Haskell a Promotion</a></p>
<h3 id="Typelevel-Numbers"><a href="#Typelevel-Numbers" class="headerlink" title="Typelevel Numbers"></a>Typelevel Numbers</h3><p><code>GHC</code>的<code>type literals</code>(类型文字)也可以用来代替显式<code>Peano</code>算术。</p>
<p><code>GHC 7.6</code>在执行<code>reduction</code>(约简)方面非常保守，而<code>GHC 7.8</code>则要少得多，它可以解决许多涉及自然数的类型级约束，但有时仍需要一点儿<code>coaxing</code>(哄骗)。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE KindSignatures #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.TypeLits</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Vec</span> :: <span class="type">Nat</span> -&gt; * -&gt; * where</span></span><br><span class="line">  <span class="type">Nil</span> :: <span class="type">Vec</span> <span class="number">0</span> a</span><br><span class="line">  <span class="type">Cons</span> :: a -&gt; <span class="type">Vec</span> n a -&gt; <span class="type">Vec</span> (<span class="number">1</span> + n) a</span><br><span class="line"></span><br><span class="line"><span class="comment">-- GHC 7.6 will not reduce</span></span><br><span class="line"><span class="comment">-- vec3 :: Vec (1 + (1 + (1 + 0))) Int</span></span><br><span class="line"></span><br><span class="line"><span class="title">vec3</span> :: <span class="type">Vec</span> <span class="number">3</span> <span class="type">Int</span></span><br><span class="line"><span class="title">vec3</span> = <span class="number">0</span> `<span class="type">Cons</span>` (<span class="number">1</span> `<span class="type">Cons</span>` (<span class="number">2</span> `<span class="type">Cons</span>` <span class="type">Nil</span>))</span><br><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE KindSignatures #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleContexts #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.TypeLits</span><br><span class="line"><span class="keyword">import</span> Data.Type.Equality</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Foo</span> :: <span class="type">Nat</span> -&gt; * where</span></span><br><span class="line">  <span class="type">Small</span>    :: (n &lt;= <span class="number">2</span>)  =&gt; <span class="type">Foo</span> n</span><br><span class="line">  <span class="type">Big</span>      :: (<span class="number">3</span> &lt;= n) =&gt; <span class="type">Foo</span> n</span><br><span class="line"></span><br><span class="line">  <span class="type">Empty</span>    :: ((n == <span class="number">0</span>) ~ <span class="type">True</span>) =&gt; <span class="type">Foo</span> n</span><br><span class="line">  <span class="type">NonEmpty</span> :: ((n == <span class="number">0</span>) ~ <span class="type">False</span>) =&gt; <span class="type">Foo</span> n</span><br><span class="line"></span><br><span class="line"><span class="title">big</span> :: <span class="type">Foo</span> <span class="number">10</span></span><br><span class="line"><span class="title">big</span> = <span class="type">Big</span></span><br><span class="line"></span><br><span class="line"><span class="title">small</span> :: <span class="type">Foo</span> <span class="number">2</span></span><br><span class="line"><span class="title">small</span> = <span class="type">Small</span></span><br><span class="line"></span><br><span class="line"><span class="title">empty</span> :: <span class="type">Foo</span> <span class="number">0</span></span><br><span class="line"><span class="title">empty</span> = <span class="type">Empty</span></span><br><span class="line"></span><br><span class="line"><span class="title">nonempty</span> :: <span class="type">Foo</span> <span class="number">3</span></span><br><span class="line"><span class="title">nonempty</span> = <span class="type">NonEmpty</span></span><br></pre></td></tr></table></figure></p>
<p>請看: <a href="http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/type-level-literals.html" target="_blank" rel="noopener">Type-Level Literals</a>  </p>
<h3 id="Typelevel-Strings"><a href="#Typelevel-Strings" class="headerlink" title="Typelevel Strings"></a>Typelevel Strings</h3><blockquote>
<p>TODO</p>
</blockquote>
<h3 id="Custom-Errors"><a href="#Custom-Errors" class="headerlink" title="Custom Errors"></a>Custom Errors</h3><p>从<code>GHC 8.0</code>开始，我们可以使用<code>type families</code>提供自定义类型错误。<br>消息本身<code>hook into</code>(挂接)到<code>GHC</code>中，并使用在<code>GHC.TypeLits</code>中找到的小<code>datatype</code>(数据类型)表示。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">ErrorMessage</span> where</span></span><br><span class="line">  <span class="type">Text</span> :: <span class="type">Symbol</span> -&gt; <span class="type">ErrorMessage</span></span><br><span class="line">  <span class="type">ShowType</span> :: t -&gt; <span class="type">ErrorMessage</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Put two messages next to each other</span></span><br><span class="line">  (:&lt;&gt;:) :: <span class="type">ErrorMessage</span> -&gt; <span class="type">ErrorMessage</span> -&gt; <span class="type">ErrorMessage</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Put two messages on top of each other</span></span><br><span class="line">  (:$$:) :: <span class="type">ErrorMessage</span> -&gt; <span class="type">ErrorMessage</span> -&gt; <span class="type">ErrorMessage</span></span><br></pre></td></tr></table></figure></p>
<p>如果在表达式的签名中找到這些表达式中的任意一個，<code>GHC</code>将报告以下形式的错误消息：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">example</span>.hs:<span class="number">1</span>:<span class="number">1</span>: error:</span><br><span class="line">    • <span class="type">My</span> custom error message line <span class="number">1.</span></span><br><span class="line">    • <span class="type">My</span> custom error message line <span class="number">2.</span></span><br><span class="line">    • <span class="type">In</span> the expression: example</span><br><span class="line">      <span class="type">In</span> an equation for ‘foo’: foo = <span class="type">ECoerce</span> (<span class="type">EFloat</span> <span class="number">3</span>) (<span class="type">EInt</span> <span class="number">4</span>)</span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE UndecidableInstances #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.TypeLits</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span></span></span><br><span class="line"><span class="class">  <span class="comment">-- Error Message</span></span></span><br><span class="line">  TypeError (Text "Equality is not defined for functions"</span><br><span class="line">  :$$:</span><br><span class="line">  (<span class="type">ShowType</span> a :&lt;&gt;: <span class="type">Text</span> <span class="string">" -&gt; "</span> :&lt;&gt;: <span class="type">ShowType</span> b))</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Instance head</span></span><br><span class="line">  =&gt; <span class="type">Eq</span> (a -&gt; b) <span class="keyword">where</span> (==) = undefined</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Fail when we try to equate two functions</span></span><br><span class="line"><span class="title">example</span> = id == id</span><br></pre></td></tr></table></figure></p>
<p>一个不太人为的示例是创建一个类型安全的嵌入式<code>DSL</code>，该类型的<code>DSL</code>在类型级别上强制实现<code>semantics</code>(语义上)的<code>invariants</code>(不变性)。 一段时间以来，我们已经能够使用<code>GADT</code>和<code>type-families</code>来做这种事情，但是错误报告却非常可怕。使用<code>GHC 8.0</code>，我们可以拥有<code>type-families</code>，它可以发出有用的类型错误，以反映实际出了什么问题，并将其集成到<code>GHC</code>中。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE UndecidableInstances #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.TypeLits</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Coerce</span> a b where</span></span><br><span class="line">  <span class="type">Coerce</span> <span class="type">Int</span> <span class="type">Int</span>     = <span class="type">Int</span></span><br><span class="line">  <span class="type">Coerce</span> <span class="type">Float</span> <span class="type">Float</span> = <span class="type">Float</span></span><br><span class="line">  <span class="type">Coerce</span> <span class="type">Int</span> <span class="type">Float</span>   = <span class="type">Float</span></span><br><span class="line">  <span class="type">Coerce</span> <span class="type">Float</span> <span class="type">Int</span>   = <span class="type">TypeError</span> (<span class="type">Text</span> <span class="string">"Cannot cast to smaller type"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span> a where</span></span><br><span class="line">  <span class="type">EInt</span>    :: <span class="type">Int</span> -&gt; <span class="type">Expr</span> <span class="type">Int</span></span><br><span class="line">  <span class="type">EFloat</span>  :: <span class="type">Float</span> -&gt; <span class="type">Expr</span> <span class="type">Float</span></span><br><span class="line">  <span class="type">ECoerce</span> :: <span class="type">Expr</span> b -&gt; <span class="type">Expr</span> c -&gt; <span class="type">Expr</span> (<span class="type">Coerce</span> b c)</span><br><span class="line"></span><br><span class="line"><span class="title">foo</span> :: <span class="type">Expr</span> <span class="type">Int</span></span><br><span class="line"><span class="title">foo</span> = <span class="type">ECoerce</span> (<span class="type">EFloat</span> <span class="number">3</span>) (<span class="type">EInt</span> <span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="Type-Equality"><a href="#Type-Equality" class="headerlink" title="Type Equality"></a>Type Equality</h3><p>继续以在<code>Haskell</code>中构建更详尽的证明为主题，<code>ghc 7.8</code>最近附带了<code>data.type.equality</code>模块，该模块为我们提供了一组扩展的类型级操作集，用于将<code>the equality of types</code>(类型相等)表示为<code>values</code>(值)、<code>constraints</code>(约束)和<code>promoted booleans</code>(提升的布尔值)。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(~)   :: k -&gt; k -&gt; <span class="type">Constraint</span></span><br><span class="line">(==)  :: k -&gt; k -&gt; <span class="type">Bool</span></span><br><span class="line">(&lt;=)  :: <span class="type">Nat</span> -&gt; <span class="type">Nat</span> -&gt; <span class="type">Constraint</span></span><br><span class="line">(&lt;=?) :: <span class="type">Nat</span> -&gt; <span class="type">Nat</span> -&gt; <span class="type">Bool</span></span><br><span class="line">(+)   :: <span class="type">Nat</span> -&gt; <span class="type">Nat</span> -&gt; <span class="type">Nat</span></span><br><span class="line">(-)   :: <span class="type">Nat</span> -&gt; <span class="type">Nat</span> -&gt; <span class="type">Nat</span></span><br><span class="line">(*)   :: <span class="type">Nat</span> -&gt; <span class="type">Nat</span> -&gt; <span class="type">Nat</span></span><br><span class="line">(^)   :: <span class="type">Nat</span> -&gt; <span class="type">Nat</span> -&gt; <span class="type">Nat</span></span><br><span class="line">(:~:)     :: k -&gt; k -&gt; *</span><br><span class="line"><span class="type">Refl</span>      :: a1 :~: a1</span><br><span class="line"><span class="title">sym</span>       :: (a :~: b) -&gt; b :~: a</span><br><span class="line"><span class="title">trans</span>     :: (a :~: b) -&gt; (b :~: c) -&gt; a :~: c</span><br><span class="line"><span class="title">castWith</span>  :: (a :~: b) -&gt; a -&gt; b</span><br><span class="line"><span class="title">gcastWith</span> :: (a :~: b) -&gt; (a ~ b =&gt; r) -&gt; r</span><br></pre></td></tr></table></figure></p>
<p>这样，我们就有了一种更强大的语言来编写可以在编译时检查的<code>restrictions</code>(限制/限定/框框)，以及一种将允许我们(稍后)编写更高级的证明的机制。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ConstraintKinds #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.TypeLits</span><br><span class="line"><span class="keyword">import</span> Data.Type.Equality</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Not</span> a b = ((<span class="title">b</span> == <span class="title">a</span>) ~ <span class="type">False</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="title">restrictUnit</span> :: <span class="type">Not</span> () a =&gt; a -&gt; a</span><br><span class="line"><span class="title">restrictUnit</span> = id</span><br><span class="line"></span><br><span class="line"><span class="title">restrictChar</span> :: <span class="type">Not</span> <span class="type">Char</span> a =&gt; a -&gt; a</span><br><span class="line"><span class="title">restrictChar</span> = id</span><br></pre></td></tr></table></figure></p>
<h3 id="Proxies-代理人"><a href="#Proxies-代理人" class="headerlink" title="Proxies (代理人)"></a>Proxies (代理人)</h3><p>对<code>phantom</code>(幻影)类型使用<code>kind polymorphism</code>(種類多态性)使我们可以表达<code>Proxy</code>类型，<br>该代理类型由一个没有参数的构造函数<code>inhabited</code>(所驻留)，但带有一個(可以携带任意一個類型的)<code>polykinded</code>(多種類)幻像类型变量。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE PolyKinds #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | A concrete, poly-kinded proxy type</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Proxy</span> t = <span class="type">Proxy</span></span></span><br><span class="line"><span class="keyword">import</span> Data.Proxy</span><br><span class="line"></span><br><span class="line"><span class="title">a</span> :: <span class="type">Proxy</span> ()</span><br><span class="line"><span class="title">a</span> = <span class="type">Proxy</span></span><br><span class="line"></span><br><span class="line"><span class="title">b</span> :: <span class="type">Proxy</span> <span class="number">3</span></span><br><span class="line"><span class="title">b</span> = <span class="type">Proxy</span></span><br><span class="line"></span><br><span class="line"><span class="title">c</span> :: <span class="type">Proxy</span> <span class="string">"symbol"</span></span><br><span class="line"><span class="title">c</span> = <span class="type">Proxy</span></span><br><span class="line"></span><br><span class="line"><span class="title">d</span> :: <span class="type">Proxy</span> <span class="type">Maybe</span></span><br><span class="line"><span class="title">d</span> = <span class="type">Proxy</span></span><br><span class="line"></span><br><span class="line"><span class="title">e</span> :: <span class="type">Proxy</span> (<span class="type">Maybe</span> ())</span><br><span class="line"><span class="title">e</span> = <span class="type">Proxy</span></span><br></pre></td></tr></table></figure></p>
<p>如果我们通常将<code>undefined</code>作为类型类字典的<code>witness</code>(见证)来传递，我们可以改为传递一个带有幻像类型的<code>Proxy</code>对象，而无需<code>bottom</code>(底部)。<br>(<code>Using scoped type variables we can then operate with the phantom parameter and manipulate wherever is needed.</code>)<br>使用作用域类型变量，我们可以与<code>phantom</code>参数<code>operate with</code>(合作)，并在需要的地方进行<code>manipulate</code>(操作)。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">t1</span> :: a</span><br><span class="line"><span class="title">t1</span> = (undefined :: a)</span><br><span class="line"></span><br><span class="line"><span class="title">t2</span> :: <span class="type">Proxy</span> a</span><br><span class="line"><span class="title">t2</span> <span class="type">Proxy</span> :: <span class="type">Proxy</span> a</span><br></pre></td></tr></table></figure>
<h3 id="Promoted-Syntax"><a href="#Promoted-Syntax" class="headerlink" title="Promoted Syntax"></a>Promoted Syntax</h3><p>我们已经看到使用<code>DataKinds</code>提升(<code>promoted</code>)了构造函数，但就像在<code>value-level</code>上，<code>GHC</code>还允许我们为列表和元组使用一些语法糖，而不是显式的<code>cons</code>和<code>pair</code>。这是通过<code>-XTypeOperators</code>扩展启用的，该扩展在<code>type-level</code>引入了列表语法和任意<code>arity</code>(數)元组。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">HList</span> :: [*] -&gt; * where</span></span><br><span class="line">  <span class="type">HNil</span>  :: <span class="type">HList</span> '[]</span><br><span class="line">  <span class="type">HCons</span> :: a -&gt; <span class="type">HList</span> t -&gt; <span class="type">HList</span> (a ': t)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tuple</span> :: (*,*) -&gt; * where</span></span><br><span class="line">  <span class="type">Tuple</span> :: a -&gt; b -&gt; <span class="type">Tuple</span> '(a,b)</span><br></pre></td></tr></table></figure></p>
<p>使用此方法，我们可以构造所有各种<code>composite</code>(复合)类型级别的对象。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">λ: :kind <span class="number">1</span></span><br><span class="line"><span class="number">1</span> :: <span class="type">Nat</span></span><br><span class="line"></span><br><span class="line">λ: :kind <span class="string">"foo"</span></span><br><span class="line"><span class="string">"foo"</span> :: <span class="type">Symbol</span></span><br><span class="line"></span><br><span class="line">λ: :kind [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] :: [<span class="type">Nat</span>]</span><br><span class="line"></span><br><span class="line">λ: :kind [<span class="type">Int</span>, <span class="type">Bool</span>, <span class="type">Char</span>]</span><br><span class="line">[<span class="type">Int</span>, <span class="type">Bool</span>, <span class="type">Char</span>] :: [*]</span><br><span class="line"></span><br><span class="line">λ: :kind <span class="type">Just</span> [<span class="type">Int</span>, <span class="type">Bool</span>, <span class="type">Char</span>]</span><br><span class="line"><span class="type">Just</span> [<span class="type">Int</span>, <span class="type">Bool</span>, <span class="type">Char</span>] :: <span class="type">Maybe</span> [*]</span><br><span class="line"></span><br><span class="line">λ: :kind '(<span class="string">"a"</span>, <span class="type">Int</span>)</span><br><span class="line">(,) <span class="type">Symbol</span> *</span><br><span class="line"></span><br><span class="line">λ: :kind [ '(<span class="string">"a"</span>, <span class="type">Int</span>), '(<span class="string">"b"</span>, <span class="type">Bool</span>) ]</span><br><span class="line">[ '(<span class="string">"a"</span>, <span class="type">Int</span>), '(<span class="string">"b"</span>, <span class="type">Bool</span>) ] :: [(,) <span class="type">Symbol</span> *]</span><br></pre></td></tr></table></figure></p>
<h3 id="Singleton-Types"><a href="#Singleton-Types" class="headerlink" title="Singleton Types"></a>Singleton Types</h3><blockquote>
<p>这是高级部分，编写Haskell通常不需要<code>Singleton Types</code>知识。</p>
</blockquote>
<p>单例类型是具有单个值<code>inhabitant</code>(居民/實例)的类型。可以使用<code>GADTs</code>或<code>data families</code>以多种方式构造<code>Singleton</code>(单例)类型。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> instance <span class="type">Sing</span> (<span class="title">a</span> :: <span class="type">Nat</span>) where</span></span><br><span class="line">  <span class="type">SZ</span> :: <span class="type">Sing</span> '<span class="type">Z</span></span><br><span class="line">  <span class="type">SS</span> :: <span class="type">Sing</span> n -&gt; <span class="type">Sing</span> ('<span class="type">S</span> n)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> instance <span class="type">Sing</span> (<span class="title">a</span> :: <span class="type">Maybe</span> <span class="title">k</span>) where</span></span><br><span class="line">  <span class="type">SNothing</span> :: <span class="type">Sing</span> '<span class="type">Nothing</span></span><br><span class="line">  <span class="type">SJust</span> :: <span class="type">Sing</span> x -&gt; <span class="type">Sing</span> ('<span class="type">Just</span> x)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> instance <span class="type">Sing</span> (<span class="title">a</span> :: <span class="type">Bool</span>) where</span></span><br><span class="line">  <span class="type">STrue</span> :: <span class="type">Sing</span> <span class="type">True</span></span><br><span class="line">  <span class="type">SFalse</span> :: <span class="type">Sing</span> <span class="type">False</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Promoted-Naturals"><a href="#Promoted-Naturals" class="headerlink" title="Promoted Naturals"></a>Promoted Naturals</h4><p><img src="img/01.png" alt=""><br><code>singleton</code>类型是<code>haskell</code>中伪造<code>dependent types</code>(依赖类型)的小型家庭工业的一个组成部分，即使用基于值的<code>terms</code>(术语)构造类型。<br>单例类型是通过将类型和值之间的映射建模为类型的结构属性来<code>cheating</code>(作弊)的一种方式。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE RankNTypes #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE PolyKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE KindSignatures #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE StandaloneDeriving #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeSynonymInstances #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleContexts #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleInstances #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE UndecidableInstances #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Proxy</span><br><span class="line"><span class="keyword">import</span> GHC.Exts (<span class="type">Any</span>)</span><br><span class="line"><span class="keyword">import</span> Prelude <span class="keyword">hiding</span> (<span class="title">succ</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Nat</span> = <span class="type">Z</span> | <span class="type">S</span> <span class="type">Nat</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- kind-indexed data family</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="keyword">family</span> <span class="type">Sing</span> (<span class="title">a</span> :: <span class="title">k</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> instance <span class="type">Sing</span> (<span class="title">a</span> :: <span class="type">Nat</span>) where</span></span><br><span class="line">  <span class="type">SZ</span> :: <span class="type">Sing</span> '<span class="type">Z</span></span><br><span class="line">  <span class="type">SS</span> :: <span class="type">Sing</span> n -&gt; <span class="type">Sing</span> ('<span class="type">S</span> n)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> instance <span class="type">Sing</span> (<span class="title">a</span> :: <span class="type">Maybe</span> <span class="title">k</span>) where</span></span><br><span class="line">  <span class="type">SNothing</span> :: <span class="type">Sing</span> '<span class="type">Nothing</span></span><br><span class="line">  <span class="type">SJust</span> :: <span class="type">Sing</span> x -&gt; <span class="type">Sing</span> ('<span class="type">Just</span> x)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> instance <span class="type">Sing</span> (<span class="title">a</span> :: <span class="type">Bool</span>) where</span></span><br><span class="line">  <span class="type">STrue</span> :: <span class="type">Sing</span> <span class="type">True</span></span><br><span class="line">  <span class="type">SFalse</span> :: <span class="type">Sing</span> <span class="type">False</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Fin</span> (<span class="title">n</span> :: <span class="type">Nat</span>) where</span></span><br><span class="line">  <span class="type">FZ</span> :: <span class="type">Fin</span> (<span class="type">S</span> n)</span><br><span class="line">  <span class="type">FS</span> :: <span class="type">Fin</span> n -&gt; <span class="type">Fin</span> (<span class="type">S</span> n)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Vec</span> a n where</span></span><br><span class="line">  <span class="type">Nil</span>  :: <span class="type">Vec</span> a <span class="type">Z</span></span><br><span class="line">  <span class="type">Cons</span> :: a -&gt; <span class="type">Vec</span> a n -&gt; <span class="type">Vec</span> a (<span class="type">S</span> n)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">SingI</span> (<span class="title">a</span> :: <span class="title">k</span>) <span class="keyword">where</span></span></span><br><span class="line">  sing :: <span class="type">Sing</span> a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">SingI</span> <span class="type">Z</span> <span class="keyword">where</span></span></span><br><span class="line">  sing = <span class="type">SZ</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">SingI</span> n =&gt; <span class="type">SingI</span> (<span class="type">S</span> <span class="title">n</span>) <span class="keyword">where</span></span></span><br><span class="line">  sing = <span class="type">SS</span> sing</span><br><span class="line"></span><br><span class="line"><span class="title">deriving</span> <span class="keyword">instance</span> <span class="type">Show</span> <span class="type">Nat</span></span><br><span class="line"><span class="title">deriving</span> <span class="keyword">instance</span> <span class="type">Show</span> (<span class="type">SNat</span> a)</span><br><span class="line"><span class="title">deriving</span> <span class="keyword">instance</span> <span class="type">Show</span> (<span class="type">SBool</span> a)</span><br><span class="line"><span class="title">deriving</span> <span class="keyword">instance</span> <span class="type">Show</span> (<span class="type">Fin</span> a)</span><br><span class="line"><span class="title">deriving</span> <span class="keyword">instance</span> <span class="type">Show</span> a =&gt; <span class="type">Show</span> (<span class="type">Vec</span> a n)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> (<span class="title">m</span> :: <span class="type">Nat</span>) :+ (<span class="title">n</span> :: <span class="type">Nat</span>) :: <span class="type">Nat</span> where</span></span><br><span class="line">  <span class="type">Z</span> :+ n = n</span><br><span class="line">  <span class="type">S</span> m :+ n = <span class="type">S</span> (m :+ n)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">SNat</span> (<span class="title">k</span> :: <span class="type">Nat</span>) = <span class="type">Sing</span> k</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">SBool</span> (<span class="title">k</span> :: <span class="type">Bool</span>) = <span class="type">Sing</span> k</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">SMaybe</span> (<span class="title">b</span> :: <span class="title">a</span>) (<span class="title">k</span> :: <span class="type">Maybe</span> <span class="title">a</span>) = <span class="type">Sing</span> k</span></span><br><span class="line"></span><br><span class="line"><span class="title">size</span> :: <span class="type">Vec</span> a n -&gt; <span class="type">SNat</span> n</span><br><span class="line"><span class="title">size</span> <span class="type">Nil</span>         = <span class="type">SZ</span></span><br><span class="line"><span class="title">size</span> (<span class="type">Cons</span> x xs) = <span class="type">SS</span> (size xs)</span><br><span class="line"></span><br><span class="line"><span class="title">forget</span> :: <span class="type">SNat</span> n -&gt; <span class="type">Nat</span></span><br><span class="line"><span class="title">forget</span> <span class="type">SZ</span> = <span class="type">Z</span></span><br><span class="line"><span class="title">forget</span> (<span class="type">SS</span> n) = <span class="type">S</span> (forget n)</span><br><span class="line"></span><br><span class="line"><span class="title">natToInt</span> :: <span class="type">Integral</span> n =&gt; <span class="type">Nat</span> -&gt; n</span><br><span class="line"><span class="title">natToInt</span> <span class="type">Z</span>     = <span class="number">0</span></span><br><span class="line"><span class="title">natToInt</span> (<span class="type">S</span> n) = natToInt n + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="title">intToNat</span> :: (<span class="type">Integral</span> a, <span class="type">Ord</span> a) =&gt; a -&gt; <span class="type">Nat</span></span><br><span class="line"><span class="title">intToNat</span> <span class="number">0</span> = <span class="type">Z</span></span><br><span class="line"><span class="title">intToNat</span> n = <span class="type">S</span> $ intToNat (n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">sNatToInt</span> :: <span class="type">Num</span> n =&gt; <span class="type">SNat</span> x -&gt; n</span><br><span class="line"><span class="title">sNatToInt</span> <span class="type">SZ</span>     = <span class="number">0</span></span><br><span class="line"><span class="title">sNatToInt</span> (<span class="type">SS</span> n) = sNatToInt n + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="title">index</span> :: <span class="type">Fin</span> n -&gt; <span class="type">Vec</span> a n -&gt; a</span><br><span class="line"><span class="title">index</span> <span class="type">FZ</span> (<span class="type">Cons</span> x _)      = x</span><br><span class="line"><span class="title">index</span> (<span class="type">FS</span> n) (<span class="type">Cons</span> _ xs) = index n xs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">test1</span> :: <span class="type">Fin</span> (<span class="type">S</span> (<span class="type">S</span> (<span class="type">S</span> <span class="type">Z</span>)))</span><br><span class="line"><span class="title">test1</span> = <span class="type">FS</span> (<span class="type">FS</span> <span class="type">FZ</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">test2</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">test2</span> = index <span class="type">FZ</span> (<span class="number">1</span> `<span class="type">Cons</span>` (<span class="number">2</span> `<span class="type">Cons</span>` <span class="type">Nil</span>))</span><br><span class="line"></span><br><span class="line"><span class="title">test3</span> :: <span class="type">Sing</span> ('<span class="type">Just</span> ('<span class="type">S</span> ('<span class="type">S</span> <span class="type">Z</span>)))</span><br><span class="line"><span class="title">test3</span> = <span class="type">SJust</span> (<span class="type">SS</span> (<span class="type">SS</span> <span class="type">SZ</span>))</span><br><span class="line"></span><br><span class="line"><span class="title">test4</span> :: <span class="type">Sing</span> ('<span class="type">S</span> ('<span class="type">S</span> <span class="type">Z</span>))</span><br><span class="line"><span class="title">test4</span> = <span class="type">SS</span> (<span class="type">SS</span> <span class="type">SZ</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- polymorphic constructor SingI</span></span><br><span class="line"><span class="title">test5</span> :: <span class="type">Sing</span> ('<span class="type">S</span> ('<span class="type">S</span> <span class="type">Z</span>))</span><br><span class="line"><span class="title">test5</span> = sing</span><br></pre></td></tr></table></figure></p>
<p><code>GHC.TypeLits</code>中提供的内置单例类型具有有用的实现，即:即使存在下，类型级别的值也可以反映到值级别并<code>back up</code>(备份)到类型级别。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">someNatVal</span> :: <span class="type">Integer</span> -&gt; <span class="type">Maybe</span> <span class="type">SomeNat</span></span><br><span class="line"><span class="title">someSymbolVal</span> :: <span class="type">String</span> -&gt; <span class="type">SomeSymbol</span></span><br><span class="line"></span><br><span class="line"><span class="title">natVal</span> :: <span class="type">KnownNat</span> n =&gt; proxy n -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">symbolVal</span> :: <span class="type">KnownSymbol</span> n =&gt; proxy n -&gt; <span class="type">String</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE PolyKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Proxy</span><br><span class="line"><span class="keyword">import</span> GHC.TypeLits</span><br><span class="line"></span><br><span class="line"><span class="title">a</span> :: <span class="type">Integer</span></span><br><span class="line"><span class="title">a</span> = natVal (<span class="type">Proxy</span> :: <span class="type">Proxy</span> <span class="number">1</span>)</span><br><span class="line"><span class="comment">-- 1</span></span><br><span class="line"></span><br><span class="line"><span class="title">b</span> :: <span class="type">String</span></span><br><span class="line"><span class="title">b</span> = symbolVal (<span class="type">Proxy</span> :: <span class="type">Proxy</span> <span class="string">"foo"</span>)</span><br><span class="line"><span class="comment">-- "foo"</span></span><br><span class="line"></span><br><span class="line"><span class="title">c</span> :: <span class="type">Integer</span></span><br><span class="line"><span class="title">c</span> = natVal (<span class="type">Proxy</span> :: <span class="type">Proxy</span> (<span class="number">2</span> + <span class="number">3</span>))</span><br><span class="line"><span class="comment">-- 5</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Closed-Type-Families"><a href="#Closed-Type-Families" class="headerlink" title="Closed Type Families"></a>Closed Type Families</h3><p>到目前为止，在我们使用的类型族(称为<code>open type families</code>)中，没有概念涉及类型级函数中的<code>equations</code>(方程)的顺序。<br><code>type-family</code>可以在代码解析中的任何位置进行扩展，只需按顺序通过可用的定义即可进行扩展。<code>Closed type-families</code>(封闭类型家族)允许另一种声明，该声明为<code>resolution</code>(解决方案)提供<code>a base cas</code>(基本情况)，从而使我们能够实际地对类型(在类型上)编写递归函数。<br>例如，考虑我们是否要编写一个函数，该函数对函数类型中的参数进行计数，并在值级别进行<code>reifies</code>(具体化)。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE UndecidableInstances #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Proxy</span><br><span class="line"><span class="keyword">import</span> GHC.TypeLits</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Count</span> (<span class="title">f</span> :: *) :: <span class="type">Nat</span> where</span></span><br><span class="line">  <span class="type">Count</span> (a -&gt; b) = <span class="number">1</span> + (<span class="type">Count</span> b)</span><br><span class="line">  <span class="type">Count</span> x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Fn1</span> = <span class="type">Int</span> -&gt; <span class="type">Int</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Fn2</span> = <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">fn1</span> :: <span class="type">Integer</span></span><br><span class="line"><span class="title">fn1</span> = natVal (<span class="type">Proxy</span> :: <span class="type">Proxy</span> (<span class="type">Count</span> <span class="type">Fn1</span>))</span><br><span class="line"><span class="comment">-- 2</span></span><br><span class="line"></span><br><span class="line"><span class="title">fn2</span> :: <span class="type">Integer</span></span><br><span class="line"><span class="title">fn2</span> = natVal (<span class="type">Proxy</span> :: <span class="type">Proxy</span> (<span class="type">Count</span> <span class="type">Fn2</span>))</span><br><span class="line"><span class="comment">-- 4</span></span><br></pre></td></tr></table></figure></p>
<p>我们现在可以写下的各种函数都相当出色，允许我们在类型级别编写有意义的逻辑。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE PolyKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ScopedTypeVariables #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE UndecidableInstances #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.TypeLits</span><br><span class="line"><span class="keyword">import</span> Data.Proxy</span><br><span class="line"><span class="keyword">import</span> Data.Type.Equality</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Type-level functions over type-level lists.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Reverse</span> (<span class="title">xs</span> :: [<span class="title">k</span>]) :: [k] where</span></span><br><span class="line">  <span class="type">Reverse</span> '[] = '[]</span><br><span class="line">  <span class="type">Reverse</span> xs = <span class="type">Rev</span> xs '[]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Rev</span> (<span class="title">xs</span> :: [<span class="title">k</span>]) (<span class="title">ys</span> :: [<span class="title">k</span>]) :: [k] where</span></span><br><span class="line">  <span class="type">Rev</span> '[] i = i</span><br><span class="line">  <span class="type">Rev</span> (x ': xs) i = <span class="type">Rev</span> xs (x ': i)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Length</span> (<span class="title">as</span> :: [<span class="title">k</span>]) :: <span class="type">Nat</span> where</span></span><br><span class="line">  <span class="type">Length</span> '[] = <span class="number">0</span></span><br><span class="line">  <span class="type">Length</span> (x ': xs) = <span class="number">1</span> + <span class="type">Length</span> xs</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">If</span> (<span class="title">p</span> :: <span class="type">Bool</span>) (<span class="title">a</span> :: <span class="title">k</span>) (<span class="title">b</span> :: <span class="title">k</span>) :: k where</span></span><br><span class="line">  <span class="type">If</span> <span class="type">True</span> a b = a</span><br><span class="line">  <span class="type">If</span> <span class="type">False</span> a b = b</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Concat</span> (<span class="title">as</span> :: [<span class="title">k</span>]) (<span class="title">bs</span> :: [<span class="title">k</span>]) :: [k] where</span></span><br><span class="line">  <span class="type">Concat</span> a '[] = a</span><br><span class="line">  <span class="type">Concat</span> '[] b = b</span><br><span class="line">  <span class="type">Concat</span> (a ': <span class="keyword">as</span>) bs = a ': <span class="type">Concat</span> <span class="keyword">as</span> bs</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Map</span> (<span class="title">f</span> :: <span class="title">a</span> -&gt; <span class="title">b</span>) (<span class="title">as</span> :: [<span class="title">a</span>]) :: [b] where</span></span><br><span class="line">  <span class="type">Map</span> f '[] = '[]</span><br><span class="line">  <span class="type">Map</span> f (x ': xs) = f x ': <span class="type">Map</span> f xs</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Sum</span> (<span class="title">xs</span> :: [<span class="type">Nat</span>]) :: <span class="type">Nat</span> where</span></span><br><span class="line">  <span class="type">Sum</span> '[] = <span class="number">0</span></span><br><span class="line">  <span class="type">Sum</span> (x ': xs) = x + <span class="type">Sum</span> xs</span><br><span class="line"></span><br><span class="line"><span class="title">ex1</span> :: <span class="type">Reverse</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ~ [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] =&gt; <span class="type">Proxy</span> a</span><br><span class="line"><span class="title">ex1</span> = <span class="type">Proxy</span></span><br><span class="line"></span><br><span class="line"><span class="title">ex2</span> :: <span class="type">Length</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ~ <span class="number">3</span> =&gt; <span class="type">Proxy</span> a</span><br><span class="line"><span class="title">ex2</span> = <span class="type">Proxy</span></span><br><span class="line"></span><br><span class="line"><span class="title">ex3</span> :: (<span class="type">Length</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) ~ (<span class="type">Length</span> (<span class="type">Reverse</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])) =&gt; <span class="type">Proxy</span> a</span><br><span class="line"><span class="title">ex3</span> = <span class="type">Proxy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Reflecting type level computations back to the value level.</span></span><br><span class="line"><span class="title">ex4</span> :: <span class="type">Integer</span></span><br><span class="line"><span class="title">ex4</span> = natVal (<span class="type">Proxy</span> :: <span class="type">Proxy</span> (<span class="type">Length</span> (<span class="type">Concat</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])))</span><br><span class="line"><span class="comment">-- 6</span></span><br><span class="line"></span><br><span class="line"><span class="title">ex5</span> :: <span class="type">Integer</span></span><br><span class="line"><span class="title">ex5</span> = natVal (<span class="type">Proxy</span> :: <span class="type">Proxy</span> (<span class="type">Sum</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br><span class="line"><span class="comment">-- 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Couldn't match type ‘2’ with ‘1’</span></span><br><span class="line"><span class="title">ex6</span> :: <span class="type">Reverse</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ~ [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>] =&gt; <span class="type">Proxy</span> a</span><br><span class="line"><span class="title">ex6</span> = <span class="type">Proxy</span></span><br></pre></td></tr></table></figure></p>
<p><code>type family</code>函数的结果也不一定要<code>kinded</code>(归)为<code>(*)</code>。例如，允许使用<code>Nat</code>或<code>Constraint</code>(约束)。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Elem</span> (<span class="title">a</span> :: <span class="title">k</span>) (<span class="title">bs</span> :: [<span class="title">k</span>]) :: <span class="type">Constraint</span> where</span></span><br><span class="line">  <span class="type">Elem</span> a (a ': bs) = (() :: <span class="type">Constraint</span>)</span><br><span class="line">  <span class="type">Elem</span> a (b ': bs) = a `<span class="type">Elem</span>` bs</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Sum</span> (<span class="title">ns</span> :: [<span class="type">Nat</span>]) :: <span class="type">Nat</span> where</span></span><br><span class="line">  <span class="type">Sum</span> '[] = <span class="number">0</span></span><br><span class="line">  <span class="type">Sum</span> (n ': ns) = n + <span class="type">Sum</span> ns</span><br></pre></td></tr></table></figure></p>
<h3 id="Kind-Indexed-Type-Families"><a href="#Kind-Indexed-Type-Families" class="headerlink" title="Kind Indexed Type Families"></a>Kind Indexed Type Families</h3><blockquote>
<p>这是高级部分，编写Haskell通常不需要。</p>
</blockquote>
<p>正如通常在<code>types</code>(类型)上对<code>typeclasses</code>建立索引一样，<br><code>type families</code>也可以在<code>kinds</code>(种类)上建立索引，这些<code>kinds</code>(种类)作为类型变量的显式<code>kind</code>(种类)签名给出。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> (<span class="title">a</span> :: <span class="title">k</span>) == (<span class="title">b</span> :: <span class="title">k</span>) :: <span class="type">Bool</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance a == b = <span class="type">EqStar</span> a b</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance a == b = <span class="type">EqArrow</span> a b</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance a == b = <span class="type">EqBool</span> a b</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">EqStar</span> (<span class="title">a</span> :: *) (<span class="title">b</span> :: *) where</span></span><br><span class="line">  <span class="type">EqStar</span> a a = <span class="type">True</span></span><br><span class="line">  <span class="type">EqStar</span> a b = <span class="type">False</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">EqArrow</span> (<span class="title">a</span> :: <span class="title">k1</span> -&gt; <span class="title">k2</span>) (<span class="title">b</span> :: <span class="title">k1</span> -&gt; <span class="title">k2</span>) where</span></span><br><span class="line">  <span class="type">EqArrow</span> a a = <span class="type">True</span></span><br><span class="line">  <span class="type">EqArrow</span> a b = <span class="type">False</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">EqBool</span> a b where</span></span><br><span class="line">  <span class="type">EqBool</span> <span class="type">True</span>  <span class="type">True</span>  = <span class="type">True</span></span><br><span class="line">  <span class="type">EqBool</span> <span class="type">False</span> <span class="type">False</span> = <span class="type">True</span></span><br><span class="line">  <span class="type">EqBool</span> a     b     = <span class="type">False</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">EqList</span> a b where</span></span><br><span class="line">  <span class="type">EqList</span> '[]        '[]        = <span class="type">True</span></span><br><span class="line">  <span class="type">EqList</span> (h1 ': t1) (h2 ': t2) = (h1 == h2) &amp;&amp; (t1 == t2)</span><br><span class="line">  <span class="type">EqList</span> a          b          = <span class="type">False</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> a &amp;&amp; b where</span></span><br><span class="line">  <span class="type">True</span> &amp;&amp; <span class="type">True</span> = <span class="type">True</span></span><br><span class="line">  a    &amp;&amp; a    = <span class="type">False</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Promoted-Symbols"><a href="#Promoted-Symbols" class="headerlink" title="Promoted Symbols"></a>Promoted Symbols</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE PolyKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleInstances #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleContexts #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FunctionalDependencies #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ConstraintKinds #-&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.TypeLits</span><br><span class="line"><span class="keyword">import</span> Data.Type.Equality</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Label</span> (<span class="title">l</span> :: <span class="type">Symbol</span>) = <span class="type">Get</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Has</span> a l b | a l -&gt; b <span class="keyword">where</span></span></span><br><span class="line">  from :: a -&gt; <span class="type">Label</span> l -&gt; b</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point2D</span> = <span class="type">Point2</span> <span class="type">Double</span> <span class="type">Double</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point3D</span> = <span class="type">Point3</span> <span class="type">Double</span> <span class="type">Double</span> <span class="type">Double</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Has</span> <span class="type">Point2D</span> "x" <span class="type">Double</span> <span class="keyword">where</span></span></span><br><span class="line">  from (<span class="type">Point2</span> x _) _ = x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Has</span> <span class="type">Point2D</span> "y" <span class="type">Double</span> <span class="keyword">where</span></span></span><br><span class="line">  from (<span class="type">Point2</span> _ y) _ = y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Has</span> <span class="type">Point3D</span> "x" <span class="type">Double</span> <span class="keyword">where</span></span></span><br><span class="line">  from (<span class="type">Point3</span> x _ _) _ = x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Has</span> <span class="type">Point3D</span> "y" <span class="type">Double</span> <span class="keyword">where</span></span></span><br><span class="line">  from (<span class="type">Point3</span> _ y _) _ = y</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Has</span> <span class="type">Point3D</span> "z" <span class="type">Double</span> <span class="keyword">where</span></span></span><br><span class="line">  from (<span class="type">Point3</span> _ _ z) _ = z</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">infixl</span> <span class="number">6</span> #</span><br><span class="line"></span><br><span class="line">(#) :: a -&gt; (a -&gt; b) -&gt; b</span><br><span class="line">(#) = flip ($)</span><br><span class="line"></span><br><span class="line"><span class="title">_x</span> :: <span class="type">Has</span> a <span class="string">"x"</span> b =&gt; a -&gt; b</span><br><span class="line"><span class="title">_x</span> pnt = from pnt (<span class="type">Get</span> :: <span class="type">Label</span> <span class="string">"x"</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">_y</span> :: <span class="type">Has</span> a <span class="string">"y"</span> b =&gt; a -&gt; b</span><br><span class="line"><span class="title">_y</span> pnt = from pnt (<span class="type">Get</span> :: <span class="type">Label</span> <span class="string">"y"</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">_z</span> :: <span class="type">Has</span> a <span class="string">"z"</span> b =&gt; a -&gt; b</span><br><span class="line"><span class="title">_z</span> pnt = from pnt (<span class="type">Get</span> :: <span class="type">Label</span> <span class="string">"z"</span>)</span><br><span class="line"></span><br><span class="line">type Point a r = (Has a "x" r, Has a "y" r)</span><br><span class="line"></span><br><span class="line"><span class="title">distance</span> :: (<span class="type">Point</span> a r, <span class="type">Point</span> b r, <span class="type">Floating</span> r) =&gt; a -&gt; b -&gt; r</span><br><span class="line"><span class="title">distance</span> p1 p2 = sqrt (d1^<span class="number">2</span> + d2^<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    d1 = (p1 # _x) + (p1 # _y)</span><br><span class="line">    d2 = (p2 # _x) + (p2 # _y)</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  print $ (<span class="type">Point2</span> <span class="number">10</span> <span class="number">20</span>) # _x</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Fails with: No instance for (Has Point2D "z" a0)</span></span><br><span class="line">  <span class="comment">-- print $ (Point2 10 20) # _z</span></span><br><span class="line"></span><br><span class="line">  print $ (<span class="type">Point3</span> <span class="number">10</span> <span class="number">20</span> <span class="number">30</span>) # _x</span><br><span class="line">  print $ (<span class="type">Point3</span> <span class="number">10</span> <span class="number">20</span> <span class="number">30</span>) # _z</span><br><span class="line"></span><br><span class="line">  print $ distance (<span class="type">Point2</span> <span class="number">1</span> <span class="number">3</span>) (<span class="type">Point2</span> <span class="number">2</span> <span class="number">7</span>)</span><br><span class="line">  print $ distance (<span class="type">Point2</span> <span class="number">1</span> <span class="number">3</span>) (<span class="type">Point3</span> <span class="number">2</span> <span class="number">7</span> <span class="number">4</span>)</span><br><span class="line">  print $ distance (<span class="type">Point3</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span>) (<span class="type">Point3</span> <span class="number">2</span> <span class="number">7</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>由于<code>record</code>与<code>tuple</code>基本上没有区别，因此我们也可以对记录字段名执行相同的<code>kind</code>构造。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE KindSignatures #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE MultiParamTypeClasses #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FunctionalDependencies #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleInstances #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleContexts #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE StandaloneDeriving #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ExistentialQuantification #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ConstraintKinds #-&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.TypeLits</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Field</span> (<span class="title">n</span> :: <span class="type">Symbol</span>) v = <span class="type">Field</span> &#123; <span class="title">unField</span> :: <span class="title">v</span> &#125;</span></span><br><span class="line">  <span class="keyword">deriving</span> <span class="type">Show</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Person1</span> = <span class="type">Person1</span></span></span><br><span class="line">  &#123; _age      :: <span class="type">Field</span> <span class="string">"age"</span> <span class="type">Int</span></span><br><span class="line">  , _name     :: <span class="type">Field</span> <span class="string">"name"</span> <span class="type">String</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Person2</span> = <span class="type">Person2</span></span></span><br><span class="line">  &#123; _age'  :: <span class="type">Field</span> <span class="string">"age"</span> <span class="type">Int</span></span><br><span class="line">  , _name' :: <span class="type">Field</span> <span class="string">"name"</span> <span class="type">String</span></span><br><span class="line">  , _lib'  :: <span class="type">Field</span> <span class="string">"lib"</span> <span class="type">String</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="title">deriving</span> <span class="keyword">instance</span> <span class="type">Show</span> <span class="type">Person1</span></span><br><span class="line"><span class="title">deriving</span> <span class="keyword">instance</span> <span class="type">Show</span> <span class="type">Person2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Label</span> (<span class="title">l</span> :: <span class="type">Symbol</span>) = <span class="type">Get</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Has</span> a l b | a l -&gt; b <span class="keyword">where</span></span></span><br><span class="line">  from :: a -&gt; <span class="type">Label</span> l -&gt; b</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Has</span> <span class="type">Person1</span> "age" <span class="type">Int</span> <span class="keyword">where</span></span></span><br><span class="line">  from (<span class="type">Person1</span> a _) _ = unField a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Has</span> <span class="type">Person1</span> "name" <span class="type">String</span> <span class="keyword">where</span></span></span><br><span class="line">  from (<span class="type">Person1</span> _ a) _ = unField a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Has</span> <span class="type">Person2</span> "age" <span class="type">Int</span> <span class="keyword">where</span></span></span><br><span class="line">  from (<span class="type">Person2</span> a _ _) _ = unField a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Has</span> <span class="type">Person2</span> "name" <span class="type">String</span> <span class="keyword">where</span></span></span><br><span class="line">  from (<span class="type">Person2</span> _ a _) _ = unField a</span><br><span class="line"></span><br><span class="line"><span class="title">age</span> :: <span class="type">Has</span> a <span class="string">"age"</span> b =&gt; a -&gt; b</span><br><span class="line"><span class="title">age</span> pnt = from pnt (<span class="type">Get</span> :: <span class="type">Label</span> <span class="string">"age"</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">name</span> :: <span class="type">Has</span> a <span class="string">"name"</span> b =&gt; a -&gt; b</span><br><span class="line"><span class="title">name</span> pnt = from pnt (<span class="type">Get</span> :: <span class="type">Label</span> <span class="string">"name"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Parameterized constraint kind for "Simon-ness" of a record.</span></span><br><span class="line">type Simon a = (Has a "name" String, Has a "age" Int)</span><br><span class="line"></span><br><span class="line"><span class="title">spj</span> :: <span class="type">Person1</span></span><br><span class="line"><span class="title">spj</span> = <span class="type">Person1</span> (<span class="type">Field</span> <span class="number">56</span>) (<span class="type">Field</span> <span class="string">"Simon Peyton Jones"</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">smarlow</span> :: <span class="type">Person2</span></span><br><span class="line"><span class="title">smarlow</span> = <span class="type">Person2</span> (<span class="type">Field</span> <span class="number">38</span>) (<span class="type">Field</span> <span class="string">"Simon Marlow"</span>) (<span class="type">Field</span> <span class="string">"rts"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">catNames</span> :: (<span class="type">Simon</span> a, <span class="type">Simon</span> b) =&gt; a -&gt; b -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">catNames</span> a b = name a ++ name b</span><br><span class="line"></span><br><span class="line"><span class="title">addAges</span> :: (<span class="type">Simon</span> a, <span class="type">Simon</span> b) =&gt; a -&gt; b -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">addAges</span> a b = age a + age b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">names</span> :: <span class="type">String</span></span><br><span class="line"><span class="title">names</span> = name smarlow ++ <span class="string">","</span> ++ name spj</span><br><span class="line"><span class="comment">-- "Simon Marlow,Simon Peyton Jones"</span></span><br><span class="line"></span><br><span class="line"><span class="title">ages</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">ages</span> = age spj + age smarlow</span><br><span class="line"><span class="comment">-- 94</span></span><br></pre></td></tr></table></figure></p>
<p>值得注意的是，这种方法大部分只是所有样板类实例化，可以使用<code>TemplateHaskell</code>或<code>Generic deriving</code>(泛型派生)将其抽象化。</p>
<h3 id="HLists"><a href="#HLists" class="headerlink" title="HLists"></a>HLists</h3><blockquote>
<p>这是高级部分，编写Haskell通常不需要。<br><code>heterogeneous</code>(异类)列表是<code>cons</code>列表，其类型静态地编码其值的<code>ordered types</code>(有序类型)。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE KindSignatures #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">infixr</span> <span class="number">5</span> :::</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">HList</span> (<span class="title">ts</span> :: [ * ]) where</span></span><br><span class="line">  <span class="type">Nil</span> :: <span class="type">HList</span> '[]</span><br><span class="line">  (:::) :: t -&gt; <span class="type">HList</span> ts -&gt; <span class="type">HList</span> (t ': ts)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Take the head of a non-empty list with the first value as Bool type.</span></span><br><span class="line"><span class="title">headBool</span> :: <span class="type">HList</span> (<span class="type">Bool</span> ': xs) -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">headBool</span> hlist = <span class="keyword">case</span> hlist <span class="keyword">of</span></span><br><span class="line">  (a ::: _) -&gt; a</span><br><span class="line"></span><br><span class="line"><span class="title">hlength</span> :: <span class="type">HList</span> x -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">hlength</span> <span class="type">Nil</span> = <span class="number">0</span></span><br><span class="line"><span class="title">hlength</span> (_ ::: b) = <span class="number">1</span> + (hlength b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">tuple</span> :: (<span class="type">Bool</span>, (<span class="type">String</span>, (<span class="type">Double</span>, ())))</span><br><span class="line"><span class="title">tuple</span> = (<span class="type">True</span>, (<span class="string">"foo"</span>, (<span class="number">3.14</span>, ())))</span><br><span class="line"></span><br><span class="line"><span class="title">hlist</span> :: <span class="type">HList</span> '[<span class="type">Bool</span>, <span class="type">String</span> , <span class="type">Double</span> , ()]</span><br><span class="line"><span class="title">hlist</span> = <span class="type">True</span> ::: <span class="string">"foo"</span> ::: <span class="number">3.14</span> ::: () ::: <span class="type">Nil</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>当然，这立即引发了一个问题，即在存在<code>type-heterogeneity</code>(类型异质性)的情况下如何将这样的列表打印成字符串。</p>
<p>在这种情况下，我们可以将<code>type-families</code>与<code>constraint kinds</code>(约束类型)结合使用，以对<code>HLists</code>参数应用<code>Show</code>来生成<code>HList</code>中所有类型都是<code>Showable</code>的<code>aggregate constraint</code>(聚合约束)，然后派生<code>Show</code>实例。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE PolyKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE KindSignatures #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ConstraintKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE UndecidableInstances #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.Exts (<span class="type">Constraint</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">infixr</span> <span class="number">5</span> :::</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">HList</span> (<span class="title">ts</span> :: [ * ]) where</span></span><br><span class="line">  <span class="type">Nil</span> :: <span class="type">HList</span> '[]</span><br><span class="line">  (:::) :: t -&gt; <span class="type">HList</span> ts -&gt; <span class="type">HList</span> (t ': ts)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Map</span> (<span class="title">f</span> :: <span class="title">a</span> -&gt; <span class="title">b</span>) (<span class="title">xs</span> :: [<span class="title">a</span>]) :: [b]</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">Map</span> f '[] = '[]</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">Map</span> f (<span class="title">x</span> ': <span class="title">xs</span>) = f x ': <span class="type">Map</span> f xs</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Constraints</span> (<span class="title">cs</span> :: [<span class="type">Constraint</span>]) :: <span class="type">Constraint</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">Constraints</span> '[] = ()</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">Constraints</span> (<span class="title">c</span> ': <span class="title">cs</span>) = (<span class="title">c</span>, <span class="type">Constraints</span> <span class="title">cs</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">AllHave</span> (<span class="title">c</span> :: <span class="title">k</span> -&gt; <span class="type">Constraint</span>) (<span class="title">xs</span> :: [<span class="title">k</span>]) = <span class="type">Constraints</span> (<span class="type">Map</span> <span class="title">c</span> <span class="title">xs</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="title">showHList</span> :: <span class="type">AllHave</span> <span class="type">Show</span> xs =&gt; <span class="type">HList</span> xs -&gt; [<span class="type">String</span>]</span><br><span class="line"><span class="title">showHList</span> <span class="type">Nil</span> = []</span><br><span class="line"><span class="title">showHList</span> (x ::: xs) = (show x) : showHList xs</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">AllHave</span> <span class="type">Show</span> xs =&gt; <span class="type">Show</span> (<span class="type">HList</span> <span class="title">xs</span>) <span class="keyword">where</span></span></span><br><span class="line">  show = show . showHList</span><br><span class="line"></span><br><span class="line"><span class="title">example1</span> :: <span class="type">HList</span> '[<span class="type">Bool</span>, <span class="type">String</span> , <span class="type">Double</span> , ()]</span><br><span class="line"><span class="title">example1</span> = <span class="type">True</span> ::: <span class="string">"foo"</span> ::: <span class="number">3.14</span> ::: () ::: <span class="type">Nil</span></span><br><span class="line"><span class="comment">-- ["True","\"foo\"","3.14","()"]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Typelevel-Dictionaries"><a href="#Typelevel-Dictionaries" class="headerlink" title="Typelevel Dictionaries"></a>Typelevel Dictionaries</h3><p>关于<code>promotion</code>(晋升)的讨论大部分是关于我们是否可以在类型级别创建数据结构以在编译时存储信息的问题。例如，类型级别<code>association list</code>(关联列表)可用于对类型级别<code>symbols</code>(符号)和任何其他<code>promotable</code>(可推广)类型之间的映射进行建模。与<code>type-families</code>一起，我们可以写下类型级别的<code>traversal</code>(遍历)和<code>lookup</code>(查找)函数。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE PolyKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE RankNTypes #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE KindSignatures #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ConstraintKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE UndecidableInstances #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.TypeLits</span><br><span class="line"><span class="keyword">import</span> Data.Proxy</span><br><span class="line"><span class="keyword">import</span> Data.Type.Equality</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">If</span> (<span class="title">p</span> :: <span class="type">Bool</span>) (<span class="title">a</span> :: <span class="title">k</span>) (<span class="title">b</span> :: <span class="title">k</span>) :: k where</span></span><br><span class="line">  <span class="type">If</span> <span class="type">True</span> a b = a</span><br><span class="line">  <span class="type">If</span> <span class="type">False</span> a b = b</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Lookup</span> (<span class="title">k</span> :: <span class="title">a</span>) (<span class="title">ls</span> :: [(<span class="title">a</span>, <span class="title">b</span>)]) :: <span class="type">Maybe</span> b where</span></span><br><span class="line">  <span class="type">Lookup</span> k '[] = '<span class="type">Nothing</span></span><br><span class="line">  <span class="type">Lookup</span> k ('(a, b) ': xs) = <span class="type">If</span> (a == k) ('<span class="type">Just</span> b) (<span class="type">Lookup</span> k xs)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">M</span> = [</span></span><br><span class="line">    '(<span class="string">"a"</span>, <span class="number">1</span>)</span><br><span class="line">  , '(<span class="string">"b"</span>, <span class="number">2</span>)</span><br><span class="line">  , '(<span class="string">"c"</span>, <span class="number">3</span>)</span><br><span class="line">  , '(<span class="string">"d"</span>, <span class="number">4</span>)</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">K</span> = "a"</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> (!!) m (<span class="title">k</span> :: <span class="type">Symbol</span>) a = (<span class="type">Lookup</span> <span class="title">k</span> <span class="title">m</span>) ~ <span class="type">Just</span> a</span></span><br><span class="line"></span><br><span class="line"><span class="title">value</span> :: <span class="type">Integer</span></span><br><span class="line"><span class="title">value</span> = natVal ( <span class="type">Proxy</span> :: (<span class="type">M</span> !! <span class="string">"a"</span>) a =&gt; <span class="type">Proxy</span> a )</span><br></pre></td></tr></table></figure></p>
<p>如果我们要求<code>GHC</code>展开类型签名，则可以查看类型级映射查找函数的显式实现。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(!!)</span><br><span class="line">  :: <span class="type">If</span></span><br><span class="line">       (<span class="type">GHC</span>.<span class="type">TypeLits</span>.<span class="type">EqSymbol</span> <span class="string">"a"</span> k)</span><br><span class="line">       ('<span class="type">Just</span> <span class="number">1</span>)</span><br><span class="line">       (<span class="type">If</span></span><br><span class="line">          (<span class="type">GHC</span>.<span class="type">TypeLits</span>.<span class="type">EqSymbol</span> <span class="string">"b"</span> k)</span><br><span class="line">          ('<span class="type">Just</span> <span class="number">2</span>)</span><br><span class="line">          (<span class="type">If</span></span><br><span class="line">             (<span class="type">GHC</span>.<span class="type">TypeLits</span>.<span class="type">EqSymbol</span> <span class="string">"c"</span> k)</span><br><span class="line">             ('<span class="type">Just</span> <span class="number">3</span>)</span><br><span class="line">             (<span class="type">If</span> (<span class="type">GHC</span>.<span class="type">TypeLits</span>.<span class="type">EqSymbol</span> <span class="string">"d"</span> k) ('<span class="type">Just</span> <span class="number">4</span>) '<span class="type">Nothing</span>)))</span><br><span class="line">     ~ '<span class="type">Just</span> v =&gt;</span><br><span class="line">     <span class="type">Proxy</span> k -&gt; <span class="type">Proxy</span> v</span><br></pre></td></tr></table></figure></p>
<h3 id="Advanced-Proofs"><a href="#Advanced-Proofs" class="headerlink" title="Advanced Proofs"></a>Advanced Proofs</h3><blockquote>
<p>这是高级部分，编写Haskell通常不需要。</p>
</blockquote>
<p>现在我们有了<code>length-indexed</code>(长度索引)的向量，让我们编写反向函数，它有多难？<br>所以我们去写下这样的东西:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">reverseNaive</span> :: <span class="keyword">forall</span> n a. <span class="type">Vec</span> a n -&gt; <span class="type">Vec</span> a n</span><br><span class="line"><span class="title">reverseNaive</span> xs = go <span class="type">Nil</span> xs <span class="comment">-- Error: n + 0 != n</span></span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    go :: <span class="type">Vec</span> a m -&gt; <span class="type">Vec</span> a n -&gt; <span class="type">Vec</span> a (n :+ m)</span><br><span class="line">    go acc <span class="type">Nil</span> = acc</span><br><span class="line">    go acc (<span class="type">Cons</span> x xs) = go (<span class="type">Cons</span> x acc) xs <span class="comment">-- Error: n + succ m != succ (n + m)</span></span><br></pre></td></tr></table></figure></p>
<p>运行此命令，我们发现<code>GHC</code>对代码中的两行感到不满意:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Couldn't</span> match <span class="class"><span class="keyword">type</span> ‘n’ with ‘n :+ '<span class="type">Z</span>’</span></span><br><span class="line">    <span class="type">Expected</span> <span class="class"><span class="keyword">type</span>: <span class="type">Vec</span> a n</span></span><br><span class="line">      <span class="type">Actual</span> <span class="class"><span class="keyword">type</span>: <span class="type">Vec</span> a (<span class="title">n</span> :+ '<span class="type">Z</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">Could</span> not deduce ((n1 :+ '<span class="type">S</span> m) ~ '<span class="type">S</span> (n1 :+ m))</span><br><span class="line">    <span class="type">Expected</span> <span class="class"><span class="keyword">type</span>: <span class="type">Vec</span> a1 (<span class="title">k</span> :+ <span class="title">m</span>)</span></span><br><span class="line">      <span class="type">Actual</span> <span class="class"><span class="keyword">type</span>: <span class="type">Vec</span> a1 (<span class="title">n1</span> :+ '<span class="type">S</span> <span class="title">m</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>当我们从向量中展开元素时，由于向后合并向量的子部分，最终将对索引进行大量类型级别的算术运算，但结果是，我们发现<code>GHC</code>会遇到一些<code>unification</code>(统一)错误，因为它不知道自然数的基本算术属性。即<code>forall n. n + 0 = 0</code>和<code>forall n m. n + (1 + m) = 1 + (n + m)</code>。当然，我们应该在类型级别上构建一个可以直观地对算术进行建模的系统，但是<code>GHC</code>只是一个笨拙的编译器，它不能自动推论自然数和<code>Peano</code>数之间的<code>isomorphism</code>(同构)，这当然不应该是真正的假设。</p>
<p>因此，在这些<code>call sites</code>(调用站点)中，我们现在都有一个证明义务来构造证明条款。回想一下我们对<code>GADTs</code>的<code>propositional equality</code>(命题平等)的讨论，我们实际上已经有了这样的机制来构造它。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE PolyKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE KindSignatures #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ExplicitForAll #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Type.Equality</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Nat</span> = <span class="type">Z</span> | <span class="type">S</span> <span class="type">Nat</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">SNat</span> n where</span></span><br><span class="line">  <span class="type">Zero</span> :: <span class="type">SNat</span> <span class="type">Z</span></span><br><span class="line">  <span class="type">Succ</span> :: <span class="type">SNat</span> n -&gt; <span class="type">SNat</span> (<span class="type">S</span> n)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Vec</span> :: * -&gt; <span class="type">Nat</span> -&gt; * where</span></span><br><span class="line">  <span class="type">Nil</span> :: <span class="type">Vec</span> a <span class="type">Z</span></span><br><span class="line">  <span class="type">Cons</span> :: a -&gt; <span class="type">Vec</span> a n -&gt; <span class="type">Vec</span> a (<span class="type">S</span> n)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Show</span> a =&gt; <span class="type">Show</span> (<span class="type">Vec</span> <span class="title">a</span> <span class="title">n</span>) <span class="keyword">where</span></span></span><br><span class="line">  show <span class="type">Nil</span>         = <span class="string">"Nil"</span></span><br><span class="line">  show (<span class="type">Cons</span> x xs) = <span class="string">"Cons "</span> ++ show x ++ <span class="string">" ("</span> ++ show xs ++ <span class="string">")"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> (<span class="title">m</span> :: <span class="type">Nat</span>) :+ (<span class="title">n</span> :: <span class="type">Nat</span>) :: <span class="type">Nat</span> where</span></span><br><span class="line">  <span class="type">Z</span> :+ n = n</span><br><span class="line">  <span class="type">S</span> m :+ n = <span class="type">S</span> (m :+ n)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- (a ~ b) implies (f a ~ f b)</span></span><br><span class="line"><span class="title">cong</span> :: a :~: b -&gt; f a :~: f b</span><br><span class="line"><span class="title">cong</span> <span class="type">Refl</span> = <span class="type">Refl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- (a ~ b) implies (f a) implies (f b)</span></span><br><span class="line"><span class="title">subst</span> :: a :~: b -&gt; f a -&gt; f b</span><br><span class="line"><span class="title">subst</span> <span class="type">Refl</span> = id</span><br><span class="line"></span><br><span class="line"><span class="title">plus_zero</span> :: <span class="keyword">forall</span> n. <span class="type">SNat</span> n -&gt; (n :+ <span class="type">Z</span>) :~: n</span><br><span class="line"><span class="title">plus_zero</span> <span class="type">Zero</span> = <span class="type">Refl</span></span><br><span class="line"><span class="title">plus_zero</span> (<span class="type">Succ</span> n) = cong (plus_zero n)</span><br><span class="line"></span><br><span class="line"><span class="title">plus_suc</span> :: <span class="keyword">forall</span> n m. <span class="type">SNat</span> n -&gt; <span class="type">SNat</span> m -&gt; (n :+ (<span class="type">S</span> m)) :~: (<span class="type">S</span> (n :+ m))</span><br><span class="line"><span class="title">plus_suc</span> <span class="type">Zero</span> m = <span class="type">Refl</span></span><br><span class="line"><span class="title">plus_suc</span> (<span class="type">Succ</span> n) m = cong (plus_suc n m)</span><br><span class="line"></span><br><span class="line"><span class="title">size</span> :: <span class="type">Vec</span> a n -&gt; <span class="type">SNat</span> n</span><br><span class="line"><span class="title">size</span> <span class="type">Nil</span>         = <span class="type">Zero</span></span><br><span class="line"><span class="title">size</span> (<span class="type">Cons</span> _ xs) = <span class="type">Succ</span> $ size xs</span><br><span class="line"></span><br><span class="line"><span class="title">reverse</span> :: <span class="keyword">forall</span> n a. <span class="type">Vec</span> a n -&gt; <span class="type">Vec</span> a n</span><br><span class="line"><span class="title">reverse</span> xs = subst (plus_zero (size xs)) $ go <span class="type">Nil</span> xs</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    go :: <span class="type">Vec</span> a m -&gt; <span class="type">Vec</span> a k -&gt; <span class="type">Vec</span> a (k :+ m)</span><br><span class="line">    go acc <span class="type">Nil</span> = acc</span><br><span class="line">    go acc (<span class="type">Cons</span> x xs) = subst (plus_suc (size xs) (size acc)) $ go (<span class="type">Cons</span> x acc) xs</span><br><span class="line"></span><br><span class="line"><span class="title">append</span> :: <span class="type">Vec</span> a n -&gt; <span class="type">Vec</span> a m -&gt; <span class="type">Vec</span> a (n :+ m)</span><br><span class="line"><span class="title">append</span> (<span class="type">Cons</span> x xs) ys = <span class="type">Cons</span> x (append xs ys)</span><br><span class="line"><span class="title">append</span> <span class="type">Nil</span>         ys = ys</span><br><span class="line"></span><br><span class="line"><span class="title">vec</span> :: <span class="type">Vec</span> <span class="type">Int</span> (<span class="type">S</span> (<span class="type">S</span> (<span class="type">S</span> <span class="type">Z</span>)))</span><br><span class="line"><span class="title">vec</span> = <span class="number">1</span> `<span class="type">Cons</span>` (<span class="number">2</span> `<span class="type">Cons</span>` (<span class="number">3</span> `<span class="type">Cons</span>` <span class="type">Nil</span>))</span><br><span class="line"></span><br><span class="line"><span class="title">test</span> :: <span class="type">Vec</span> <span class="type">Int</span> (<span class="type">S</span> (<span class="type">S</span> (<span class="type">S</span> <span class="type">Z</span>)))</span><br><span class="line"><span class="title">test</span> = <span class="type">Main</span>.reverse vec</span><br></pre></td></tr></table></figure></p>
<p>我们可以考虑是否可以避免使用<code>singleton</code>(单例)技巧，而只使用类型级自然数，从技术上讲，这种方法应该是可行的，尽管似乎<code>GHC 7.8</code>中的自然数求解器可以确定某些属性，但不能确定某些属性完成<code>reverse</code>函数的自然数证明。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ExplicitForAll #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE UndecidableInstances #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Prelude <span class="keyword">hiding</span> (<span class="type">Eq</span>)</span><br><span class="line"><span class="keyword">import</span> GHC.TypeLits</span><br><span class="line"><span class="keyword">import</span> Data.Type.Equality</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Z</span> = 0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">S</span> (<span class="title">n</span> :: <span class="type">Nat</span>) :: <span class="type">Nat</span> where</span></span><br><span class="line">  <span class="type">S</span> n = n + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Yes!</span></span><br><span class="line"><span class="title">eq_zero</span> :: <span class="type">Z</span> :~: <span class="type">Z</span></span><br><span class="line"><span class="title">eq_zero</span> = <span class="type">Refl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Yes!</span></span><br><span class="line"><span class="title">zero_plus_one</span> :: (<span class="type">Z</span> + <span class="number">1</span>) :~: (<span class="number">1</span> + <span class="type">Z</span>)</span><br><span class="line"><span class="title">zero_plus_one</span> = <span class="type">Refl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Yes!</span></span><br><span class="line"><span class="title">plus_zero</span> :: <span class="keyword">forall</span> n. (n + <span class="type">Z</span>) :~: n</span><br><span class="line"><span class="title">plus_zero</span> = <span class="type">Refl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Yes!</span></span><br><span class="line"><span class="title">plus_one</span> :: <span class="keyword">forall</span> n. (n + <span class="type">S</span> <span class="type">Z</span>) :~: <span class="type">S</span> n</span><br><span class="line"><span class="title">plus_one</span> = <span class="type">Refl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- No.</span></span><br><span class="line"><span class="title">plus_suc</span> :: <span class="keyword">forall</span> n m. (n + (<span class="type">S</span> m)) :~: (<span class="type">S</span> (n + m))</span><br><span class="line"><span class="title">plus_suc</span> = <span class="type">Refl</span></span><br></pre></td></tr></table></figure></p>
<p>请注意，在<code>GHC 7.6</code>中可能有一种我不知道的方法。<br>在<code>GHC 7.10</code>中，有一些计划中的变更，以解决这些问题。特别是，有计划允许<code>pluggable</code>(可插拔)类型的系统扩展，这些扩展可以将这类问题外包给第三方<code>SMT</code>求解器，后者可以解决此类<code>numeric relations</code>(数字关系)并将此信息返回给<code>GHC</code>的<code>typechecker</code>(类型检查器)。</p>
<p>顺便说一句，这是对<code>Agda</code>中等效证明的直接音译，它是通过相同的方法完成的，但没有<code>song and dance</code>(歌舞)来<code>get around</code>(解决)缺少依赖类型的问题。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Vector <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">infixr</span> <span class="number">10</span> _∷_</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> ℕ : <span class="type">Set</span> where</span></span><br><span class="line">  zero : ℕ</span><br><span class="line">  suc  : ℕ → ℕ</span><br><span class="line"></span><br><span class="line"><span class="meta">&#123;-# BUILTIN NATURAL ℕ    #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# BUILTIN ZERO    zero #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# BUILTIN SUC     suc  #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">infixl</span> <span class="number">6</span> _+_</span><br><span class="line"></span><br><span class="line"><span class="title">_</span>+_ : ℕ → ℕ → ℕ</span><br><span class="line"><span class="number">0</span> + n = n</span><br><span class="line"><span class="title">suc</span> m + n = suc (m + n)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Vec</span> (<span class="type">A</span> : <span class="type">Set</span>) : ℕ → <span class="type">Set</span> where</span></span><br><span class="line">  []  : <span class="type">Vec</span> <span class="type">A</span> <span class="number">0</span></span><br><span class="line">  _∷_ : ∀ &#123;n&#125; → <span class="type">A</span> → <span class="type">Vec</span> <span class="type">A</span> n → <span class="type">Vec</span> <span class="type">A</span> (suc n)</span><br><span class="line"></span><br><span class="line"><span class="title">_</span>++_ : ∀ &#123;<span class="type">A</span> n m&#125; → <span class="type">Vec</span> <span class="type">A</span> n → <span class="type">Vec</span> <span class="type">A</span> m → <span class="type">Vec</span> <span class="type">A</span> (n + m)</span><br><span class="line">[] ++ ys = ys</span><br><span class="line">(x ∷ xs) ++ ys = x ∷ (xs ++ ys)</span><br><span class="line"></span><br><span class="line"><span class="keyword">infix</span> <span class="number">4</span> _≡_</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> _≡_ &#123;<span class="type">A</span> : <span class="type">Set</span>&#125; (<span class="title">x</span> : <span class="type">A</span>) : <span class="type">A</span> → <span class="type">Set</span> where</span></span><br><span class="line">  refl : x ≡ x</span><br><span class="line"></span><br><span class="line"><span class="title">subst</span> : &#123;<span class="type">A</span> : <span class="type">Set</span>&#125; → (<span class="type">P</span> : <span class="type">A</span> → <span class="type">Set</span>) → ∀&#123;x y&#125; → x ≡ y → <span class="type">P</span> x → <span class="type">P</span> y</span><br><span class="line"><span class="title">subst</span> <span class="type">P</span> refl p = p</span><br><span class="line"></span><br><span class="line"><span class="title">cong</span> : &#123;<span class="type">A</span> <span class="type">B</span> : <span class="type">Set</span>&#125; (f : <span class="type">A</span> → <span class="type">B</span>) → &#123;x y : <span class="type">A</span>&#125; → x ≡ y → f x ≡ f y</span><br><span class="line"><span class="title">cong</span> f refl = refl</span><br><span class="line"></span><br><span class="line"><span class="title">vec</span> : ∀ &#123;<span class="type">A</span>&#125; (k : ℕ) → <span class="type">Set</span></span><br><span class="line"><span class="title">vec</span> &#123;<span class="type">A</span>&#125; k = <span class="type">Vec</span> <span class="type">A</span> k</span><br><span class="line"></span><br><span class="line"><span class="title">plus_zero</span> : &#123;n : ℕ&#125; → n + <span class="number">0</span> ≡ n </span><br><span class="line"><span class="title">plus_zero</span> &#123;zero&#125;  = refl</span><br><span class="line"><span class="title">plus_zero</span> &#123;suc n&#125; = cong suc plus_zero</span><br><span class="line"></span><br><span class="line"><span class="title">plus_suc</span> : &#123;n : ℕ&#125; → n + (suc <span class="number">0</span>) ≡ suc n </span><br><span class="line"><span class="title">plus_suc</span> &#123;zero&#125;  = refl</span><br><span class="line"><span class="title">plus_suc</span> &#123;suc n&#125; = cong suc (plus_suc &#123;n&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title">reverse</span> : ∀ &#123;<span class="type">A</span> n&#125; → <span class="type">Vec</span> <span class="type">A</span> n → <span class="type">Vec</span> <span class="type">A</span> n</span><br><span class="line"><span class="title">reverse</span> []       = []</span><br><span class="line"><span class="title">reverse</span> &#123;<span class="type">A</span>&#125; &#123;suc n&#125; (x ∷ xs) = subst vec (plus_suc &#123;n&#125;) (reverse xs ++ (x  ∷ []))</span><br></pre></td></tr></table></figure></p>
<h3 id="Liquid-Haskell"><a href="#Liquid-Haskell" class="headerlink" title="Liquid Haskell"></a>Liquid Haskell</h3><blockquote>
<p>这是高级部分，编写Haskell通常不需要<code>LiquidLiskell</code>的知识。</p>
</blockquote>
<p><code>LiquidHaskell</code>是<code>GHC</code>类型系统的一个扩展，它使用<code>annotation</code>(注释)语法增加了<code>refinement</code>(细化)类型的能力。外部可以检查函数的类型签名，以获得比默认ghc提供的更丰富的类型语义，包括需要外部smt解算器验证的<code>non-exhaustive</code>(非穷尽)模式和复杂的算术属性。例如, <code>LiquidHaskell</code>可以静态地验证在<code>Maybe a</code>上操作的函数总是被赋予<code>Just</code>，或者算术函数总是产生一个甚至是正数的<code>Int</code>。</p>
<p>要在<code>Ubuntu</code>中安装<code>LiquidHaskell</code>，请在<code>/etc/sources.list中</code>添加以下行:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">deb</span> http://ppa.launchpad.net/hvr/z3/ubuntu trusty main</span><br></pre></td></tr></table></figure></p>
<p>然后安装外部<code>SMT</code>求解器:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-key adv <span class="comment">--keyserver keyserver.ubuntu.com --recv-keys F6F88286</span></span><br><span class="line">$ sudo apt-get install z3</span><br></pre></td></tr></table></figure></p>
<p>然后<code>clone repo</code>(存储库)并使用<code>stack</code>进行构建:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone <span class="comment">--recursive git@github.com:ucsd-progsys/liquidhaskell.git</span></span><br><span class="line">$ cd liquidhaskell</span><br><span class="line">$ stack install</span><br></pre></td></tr></table></figure></p>
<p>確保<code>$HOME/.local/bin</code>在你的<code>$PATH</code>中.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Prelude <span class="keyword">hiding</span> (<span class="title">mod</span>, <span class="title">gcd</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;-@ mod :: a:Nat -&gt; b:&#123;v:Nat| 0 &lt; v&#125; -&gt; &#123;v:Nat | v &lt; b&#125; @-&#125;</span></span><br><span class="line"><span class="title">mod</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">mod</span> a b</span><br><span class="line">  | a &lt; b = a</span><br><span class="line">  | otherwise = mod (a - b) b</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;-@ gcd :: a:Nat -&gt; b:&#123;v:Nat | v &lt; a&#125; -&gt; Int @-&#125;</span></span><br><span class="line"><span class="title">gcd</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">gcd</span> a <span class="number">0</span> = a</span><br><span class="line"><span class="title">gcd</span> a b = gcd b (a `mod` b)</span><br></pre></td></tr></table></figure></p>
<p>可以使用<code>liquid</code>命令行工具通过<code>solver</code>(求解器)运行该模块。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ liquid example.hs</span><br><span class="line"><span class="type">Done</span> solving.</span><br><span class="line"></span><br><span class="line">**** <span class="type">DONE</span>:  solve **************************************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**** <span class="type">DONE</span>:  annotate ***********************************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**** <span class="type">RESULT</span>: <span class="type">SAFE</span> **************************************************************</span><br></pre></td></tr></table></figure></p>
<p>有关更多详细文档和更多用例，请参见官方文档:<br><a href="https://ucsd-progsys.github.io/liquidhaskell-tutorial/01-intro.html" target="_blank" rel="noopener">Liquid Haskell Documentation</a></p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> thank you </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
        <span><a href="https://serokell.io/blog">serokell</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/blog/js/index.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--create by tea9-->

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <script>
        var gitalk = new Gitalk({
          clientID: '7cfc73dd62b57f07ed83',
          clientSecret: 'dd03b7e54aadf0d81e4c9c93e23a41272bcfcfa1',
          repo: 'blog',
          owner: 'limengyu1990',
          admin: 'limengyu1990',
          id: location.pathname,      // Ensure uniqueness and length less than 50
          distractionFreeMode: false  // Facebook-like distraction free mode
        })
        gitalk.render('comment-container')
    </script>

<!--end-->


</html>
