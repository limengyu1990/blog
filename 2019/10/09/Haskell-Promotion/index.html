<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        Haskell-Promotion - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 我，Lionel Messi，我不是天生强大，我只是天生要强。 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>不负如来不负卿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Higher-Kinded-Types"><span class="toc-text">Higher Kinded Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kind-Polymorphism"><span class="toc-text">Kind Polymorphism</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Kinds"><span class="toc-text">Data Kinds</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Size-Indexed-Vectors"><span class="toc-text">Size-Indexed Vectors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Typelevel-Numbers"><span class="toc-text">Typelevel Numbers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Typelevel-Strings"><span class="toc-text">Typelevel Strings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Custom-Errors"><span class="toc-text">Custom Errors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Type-Equality"><span class="toc-text">Type Equality</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxies-代理人"><span class="toc-text">Proxies (代理人)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promoted-Syntax"><span class="toc-text">Promoted Syntax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Singleton-Types"><span class="toc-text">Singleton Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Closed-Type-Families"><span class="toc-text">Closed Type Families</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kind-Indexed-Type-Families"><span class="toc-text">Kind Indexed Type Families</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promoted-Symbols"><span class="toc-text">Promoted Symbols</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HLists"><span class="toc-text">HLists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Typelevel-Dictionaries"><span class="toc-text">Typelevel Dictionaries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Advanced-Proofs"><span class="toc-text">Advanced Proofs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Liquid-Haskell"><span class="toc-text">Liquid Haskell</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 我，Lionel Messi，我不是天生强大，我只是天生要强。 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Haskell-Promotion
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-10-09 10:52:54</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/blog/tags/#Wish-Knew" title="Wish-Knew">Wish-Knew</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Haskell" title="Haskell">Haskell</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Promotion" title="Promotion">Promotion</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p><a href="http://dev.stephendiehl.com/hask/#promotion" target="_blank" rel="noopener">http://dev.stephendiehl.com/hask/#promotion</a></p>
</blockquote>
<h3 id="Higher-Kinded-Types"><a href="#Higher-Kinded-Types" class="headerlink" title="Higher Kinded Types"></a>Higher Kinded Types</h3><p><code>higher kinded types</code>是什麼?<br>与大多数其他语言相比，<code>Haskell</code>中的<code>kind</code>系统是独特的，因为它允许构造将<code>types</code>(类型)和<code>type constructors</code>(类型构造函数)带到其他类型的<code>datatypes</code>(数据类型)。<br>据说这样的系统支持<code>higher kinded types</code>。</p>
<p><code>haskell</code>中的所有<code>Kind</code>註解都必然会产生一個<code>kind *</code>，尽管左边的任何<code>terms</code>(术语)都可能是<code>higher-kinded</code>(<code>* -&gt; *</code>)。<br>常见的例子是<code>Monad</code>，它的种类为<code>* -&gt; *</code>。<br>但是我们也已经在<code>free monads</code>中看到了这种<code>higher-kindedness</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Free</span> f a where</span></span><br><span class="line">  <span class="type">Pure</span> :: a -&gt; <span class="type">Free</span> f a</span><br><span class="line">  <span class="type">Free</span> :: f (<span class="type">Free</span> f a) -&gt; <span class="type">Free</span> f a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Cofree</span> f a where</span></span><br><span class="line">  <span class="type">Cofree</span> :: a -&gt; f (<span class="type">Cofree</span> f a) -&gt; <span class="type">Cofree</span> f a</span><br><span class="line"><span class="type">Free</span> :: (* -&gt; *) -&gt; * -&gt; *</span><br><span class="line"><span class="type">Cofree</span> :: (* -&gt; *) -&gt; * -&gt; *</span><br></pre></td></tr></table></figure></p>
<p>例如，对于某些<code>monokinded</code>(单种)类型<code>a</code>的<code>Cofree Maybe a</code>可以通过<code>Maybe :: * -&gt; *</code>来建模非空列表。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Cofree Maybe a is a non-empty list</span></span><br><span class="line"><span class="title">testCofree</span> :: <span class="type">Cofree</span> <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">testCofree</span> = (<span class="type">Cofree</span> <span class="number">1</span> (<span class="type">Just</span> (<span class="type">Cofree</span> <span class="number">2</span> <span class="type">Nothing</span>)))</span><br></pre></td></tr></table></figure></p>
<h3 id="Kind-Polymorphism"><a href="#Kind-Polymorphism" class="headerlink" title="Kind Polymorphism"></a>Kind Polymorphism</h3><blockquote>
<p>这是高级部分，编写Haskell通常不需要了解<code>kind polymorphism</code>(种类多态性)。</p>
</blockquote>
<p><code>regular</code>(正则/常規)值级函数接受一个函数并将其应用于一个参数，它被普遍地推广到通常的<code>hindley-milner</code>方法中。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">app</span> :: <span class="keyword">forall</span> a b. (a -&gt; b) -&gt; a -&gt; b</span><br><span class="line"><span class="title">app</span> f a = f a</span><br></pre></td></tr></table></figure></p>
<p>但是，当我们在<code>type-level</code>(类型级别)执行相同的操作时，我们会发现丢失了有关所应用构造函数的<code>polymorphism</code>(多态性)的信息。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- TApp :: (* -&gt; *) -&gt; * -&gt; *</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">TApp</span> f a = <span class="type">MkTApp</span> (<span class="title">f</span> <span class="title">a</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>启用<code>-XPolyKinds</code>擴展也会允许<code>kind</code>级别的<code>polymorphic</code>(多态)变量。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Default:   (* -&gt; *) -&gt; * -&gt; *</span></span><br><span class="line"><span class="comment">-- PolyKinds: (k -&gt; *) -&gt; k -&gt; *</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">TApp</span> f a = <span class="type">MkTApp</span> (<span class="title">f</span> <span class="title">a</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Default:   ((* -&gt; *) -&gt; (* -&gt; *)) -&gt; (* -&gt; *)</span></span><br><span class="line"><span class="comment">-- PolyKinds: ((k -&gt; *) -&gt; (k -&gt; *)) -&gt; (k -&gt; *)</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Mu</span> f a = <span class="type">Roll</span> (<span class="title">f</span> (<span class="type">Mu</span> <span class="title">f</span>) a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Default:   * -&gt; *</span></span><br><span class="line"><span class="comment">-- PolyKinds: k -&gt; *</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Proxy</span> a = <span class="type">Proxy</span></span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>polykinded</code>(多种类)的<code>Proxy</code>类型允许我们在任意<code>kind</code>(种类)的构造函数上写下类型类函数。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE PolyKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE KindSignatures #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Proxy</span> a = <span class="type">Proxy</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Rep</span> = <span class="type">Rep</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">PolyClass</span> a <span class="keyword">where</span></span></span><br><span class="line">  foo :: <span class="type">Proxy</span> a -&gt; <span class="type">Rep</span></span><br><span class="line">  foo = const <span class="type">Rep</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- () :: *</span></span><br><span class="line"><span class="comment">-- [] :: * -&gt; *</span></span><br><span class="line"><span class="comment">-- Either :: * -&gt; * -&gt; *</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">PolyClass</span> ()</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">PolyClass</span> []</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">PolyClass</span> <span class="type">Either</span></span></span><br></pre></td></tr></table></figure></p>
<p>例如，我们现在可以在类型级别上写下<code>polymorphic</code>(多态)<code>S K combinators</code>(组合器)。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE PolyKinds #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">I</span> (<span class="title">a</span> :: *) = <span class="type">I</span> a</span></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">K</span> (<span class="title">a</span> :: *) (<span class="title">b</span> :: <span class="title">k</span>) = <span class="type">K</span> a</span></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Flip</span> (<span class="title">f</span> :: <span class="title">k1</span> -&gt; <span class="title">k2</span> -&gt; *) (<span class="title">x</span> :: <span class="title">k2</span>) (<span class="title">y</span> :: <span class="title">k1</span>) = <span class="type">Flip</span> (<span class="title">f</span> <span class="title">y</span> <span class="title">x</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="title">unI</span> :: <span class="type">I</span> a -&gt; a</span><br><span class="line"><span class="title">unI</span> (<span class="type">I</span> x) = x</span><br><span class="line"></span><br><span class="line"><span class="title">unK</span> :: <span class="type">K</span> a b -&gt; a</span><br><span class="line"><span class="title">unK</span> (<span class="type">K</span> x) = x</span><br><span class="line"></span><br><span class="line"><span class="title">unFlip</span> :: <span class="type">Flip</span> f x y -&gt; f y x</span><br><span class="line"><span class="title">unFlip</span> (<span class="type">Flip</span> x) = x</span><br></pre></td></tr></table></figure></p>
<h3 id="Data-Kinds"><a href="#Data-Kinds" class="headerlink" title="Data Kinds"></a>Data Kinds</h3><blockquote>
<p>这是高级部分，编写Haskell通常不需要了解<code>Data Kinds</code>。</p>
</blockquote>
<p><code>-XDataKinds</code>扩展允许我们在值级别和类型级别使用<code>refer to</code>(引用)构造函数。考虑一个简单的<code>sum</code>类型:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">S</span> a b = <span class="type">L</span> a | <span class="type">R</span> b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- S :: * -&gt; * -&gt; *</span></span><br><span class="line"><span class="comment">-- L :: a -&gt; S a b</span></span><br><span class="line"><span class="comment">-- R :: b -&gt; S a b</span></span><br></pre></td></tr></table></figure></p>
<p>启用扩展后，我们可以看到我们的类型构造函数现在已自动升级，因此可以将<code>L</code>或<code>R</code>视为类型为<code>S</code>的数据构造函数或<code>kind</code>(種類)为<code>S</code>的<code>L</code>类型的数据构造器。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">S</span> a b = <span class="type">L</span> a | <span class="type">R</span> b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- S :: * -&gt; * -&gt; *</span></span><br><span class="line"><span class="comment">-- L :: * -&gt; S * *</span></span><br><span class="line"><span class="comment">-- R :: * -&gt; S * *</span></span><br></pre></td></tr></table></figure>
<p>可以在类型签名中以单引号作为前缀来引用升级的数据构造函数。<br>同样重要的是，默认情况下，这些提升的构造函数不随模块一起导出，但是可以为勾选的<code>promoted</code>(提升)类型创建<code>type synonym</code>(类型同义词)实例，并直接将其导出。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Foo</span> = <span class="type">Bar</span> | <span class="type">Baz</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Bar</span> = '<span class="type">Bar</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Baz</span> = '<span class="type">Baz</span></span></span><br></pre></td></tr></table></figure></p>
<p>将此与<code>type families</code>相结合，我们看到可以通过将<code>types</code>(类型)提升到<code>kind</code>(种类)级别来编写有意义的类型级别的函数。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Prelude <span class="keyword">hiding</span> (<span class="type">Bool(..)</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Bool</span> = <span class="type">False</span> | <span class="type">True</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Not</span> (<span class="title">a</span> :: <span class="type">Bool</span>) :: <span class="type">Bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">Not</span> <span class="type">True</span> = <span class="type">False</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> instance <span class="type">Not</span> <span class="type">False</span> = <span class="type">True</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">false</span> :: <span class="type">Not</span> <span class="type">True</span> ~ <span class="type">False</span> =&gt; a</span><br><span class="line"><span class="title">false</span> = undefined</span><br><span class="line"></span><br><span class="line"><span class="title">true</span> :: <span class="type">Not</span> <span class="type">False</span> ~ <span class="type">True</span> =&gt; a</span><br><span class="line"><span class="title">true</span> = undefined</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Fails at compile time.</span></span><br><span class="line"><span class="comment">-- Couldn't match type 'False with 'True</span></span><br><span class="line"><span class="title">invalid</span> :: <span class="type">Not</span> <span class="type">True</span> ~ <span class="type">True</span> =&gt; a</span><br><span class="line"><span class="title">invalid</span> = undefined</span><br></pre></td></tr></table></figure></p>
<h3 id="Size-Indexed-Vectors"><a href="#Size-Indexed-Vectors" class="headerlink" title="Size-Indexed Vectors"></a>Size-Indexed Vectors</h3><p>使用这种新结构，我们现在可以创建一个<code>Vec</code>类型，该类型通过其长度和元素类型进行参数化，因为我们有一种<code>kind</code>(种类)丰富的语言，足以在广义代数数据类型的<code>kind</code>(种类)签名中对后继类型进行编码。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE KindSignatures #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleInstances #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleContexts #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Nat</span> = <span class="type">Z</span> | <span class="type">S</span> <span class="type">Nat</span> <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Zero</span>  = <span class="type">Z</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">One</span>   = <span class="type">S</span> <span class="type">Zero</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Two</span>   = <span class="type">S</span> <span class="type">One</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Three</span> = <span class="type">S</span> <span class="type">Two</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Four</span>  = <span class="type">S</span> <span class="type">Three</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Five</span>  = <span class="type">S</span> <span class="type">Four</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Vec</span> :: <span class="type">Nat</span> -&gt; * -&gt; * where</span></span><br><span class="line">  <span class="type">Nil</span> :: <span class="type">Vec</span> <span class="type">Z</span> a</span><br><span class="line">  <span class="type">Cons</span> :: a -&gt; <span class="type">Vec</span> n a -&gt; <span class="type">Vec</span> (<span class="type">S</span> n) a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Show</span> a =&gt; <span class="type">Show</span> (<span class="type">Vec</span> <span class="title">n</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">  show <span class="type">Nil</span>         = <span class="string">"Nil"</span></span><br><span class="line">  show (<span class="type">Cons</span> x xs) = <span class="string">"Cons "</span> ++ show x ++ <span class="string">" ("</span> ++ show xs ++ <span class="string">")"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">FromList</span> n <span class="keyword">where</span></span></span><br><span class="line">  fromList :: [a] -&gt; <span class="type">Vec</span> n a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">FromList</span> <span class="type">Z</span> <span class="keyword">where</span></span></span><br><span class="line">  fromList [] = <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">FromList</span> n =&gt; <span class="type">FromList</span> (<span class="type">S</span> <span class="title">n</span>) <span class="keyword">where</span></span></span><br><span class="line">  fromList (x:xs) = <span class="type">Cons</span> x $ fromList xs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">lengthVec</span> :: <span class="type">Vec</span> n a -&gt; <span class="type">Nat</span></span><br><span class="line"><span class="title">lengthVec</span> <span class="type">Nil</span> = <span class="type">Z</span></span><br><span class="line"><span class="title">lengthVec</span> (<span class="type">Cons</span> x xs) = <span class="type">S</span> (lengthVec xs)</span><br><span class="line"></span><br><span class="line"><span class="title">zipVec</span> :: <span class="type">Vec</span> n a -&gt; <span class="type">Vec</span> n b -&gt; <span class="type">Vec</span> n (a,b)</span><br><span class="line"><span class="title">zipVec</span> <span class="type">Nil</span> <span class="type">Nil</span> = <span class="type">Nil</span></span><br><span class="line"><span class="title">zipVec</span> (<span class="type">Cons</span> x xs) (<span class="type">Cons</span> y ys) = <span class="type">Cons</span> (x,y) (zipVec xs ys)</span><br><span class="line"></span><br><span class="line"><span class="title">vec4</span> :: <span class="type">Vec</span> <span class="type">Four</span> <span class="type">Int</span></span><br><span class="line"><span class="title">vec4</span> = fromList [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">vec5</span> :: <span class="type">Vec</span> <span class="type">Five</span> <span class="type">Int</span></span><br><span class="line"><span class="title">vec5</span> = fromList [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">example1</span> :: <span class="type">Nat</span></span><br><span class="line"><span class="title">example1</span> = lengthVec vec4</span><br><span class="line"><span class="comment">-- S (S (S (S Z)))</span></span><br><span class="line"></span><br><span class="line"><span class="title">example2</span> :: <span class="type">Vec</span> <span class="type">Four</span> (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="title">example2</span> = zipVec vec4 vec4</span><br><span class="line"><span class="comment">-- Cons (0,0) (Cons (1,1) (Cons (2,2) (Cons (3,3) (Nil))))</span></span><br></pre></td></tr></table></figure></p>
<p>所以现在如果我们尝试<code>zip</code>两个形状错误的<code>vec</code>类型，那么在编译时会得到一个关于<code>off by one</code>错误的错误。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">example2</span> = zipVec vec4 vec5</span><br><span class="line"><span class="comment">-- Couldn't match type 'S 'Z with 'Z</span></span><br><span class="line"><span class="comment">-- Expected type: Vec Four Int</span></span><br><span class="line"><span class="comment">--   Actual type: Vec Five Int</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以使用相同的技术来创建一个由空或非空标志静态索引的容器,这样,如果我们尝试获取空列表的头部,则会得到编译时错误,或者等效地声明为我們有义务向编译器证明我们传递给<code>head</code>函数的参数是非空的。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE KindSignatures #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleInstances #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleContexts #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Size</span> = <span class="type">Empty</span> | <span class="type">NonEmpty</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">List</span> a b where</span></span><br><span class="line">  <span class="type">Nil</span>  :: <span class="type">List</span> <span class="type">Empty</span> a</span><br><span class="line">  <span class="type">Cons</span> :: a -&gt; <span class="type">List</span> b a -&gt; <span class="type">List</span> <span class="type">NonEmpty</span> a</span><br><span class="line"></span><br><span class="line"><span class="title">head'</span> :: <span class="type">List</span> <span class="type">NonEmpty</span> a -&gt; a</span><br><span class="line"><span class="title">head'</span> (<span class="type">Cons</span> x _) = x</span><br><span class="line"></span><br><span class="line"><span class="title">example1</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">example1</span> = head' (<span class="number">1</span> `<span class="type">Cons</span>` (<span class="number">2</span> `<span class="type">Cons</span>` <span class="type">Nil</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Cannot match type Empty with NonEmpty</span></span><br><span class="line"><span class="title">example2</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">example2</span> = head' <span class="type">Nil</span></span><br><span class="line"><span class="type">Couldn't</span> match <span class="class"><span class="keyword">type</span> <span class="type">None</span> with <span class="type">Many</span></span></span><br><span class="line"><span class="type">Expected</span> <span class="class"><span class="keyword">type</span>: <span class="type">List</span> <span class="type">NonEmpty</span> <span class="type">Int</span></span></span><br><span class="line">  <span class="type">Actual</span> <span class="class"><span class="keyword">type</span>: <span class="type">List</span> <span class="type">Empty</span> <span class="type">Int</span></span></span><br></pre></td></tr></table></figure></p>
<p>請看: <a href="https://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf" target="_blank" rel="noopener">Giving Haskell a Promotion</a></p>
<h3 id="Typelevel-Numbers"><a href="#Typelevel-Numbers" class="headerlink" title="Typelevel Numbers"></a>Typelevel Numbers</h3><p><code>GHC</code>的<code>type literals</code>(类型文字)也可以用来代替显式<code>Peano</code>算术。</p>
<p><code>GHC 7.6</code>在执行<code>reduction</code>(约简)方面非常保守，而<code>GHC 7.8</code>则要少得多，它可以解决许多涉及自然数的类型级约束，但有时仍需要一点儿<code>coaxing</code>(哄骗)。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE KindSignatures #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.TypeLits</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Vec</span> :: <span class="type">Nat</span> -&gt; * -&gt; * where</span></span><br><span class="line">  <span class="type">Nil</span> :: <span class="type">Vec</span> <span class="number">0</span> a</span><br><span class="line">  <span class="type">Cons</span> :: a -&gt; <span class="type">Vec</span> n a -&gt; <span class="type">Vec</span> (<span class="number">1</span> + n) a</span><br><span class="line"></span><br><span class="line"><span class="comment">-- GHC 7.6 will not reduce</span></span><br><span class="line"><span class="comment">-- vec3 :: Vec (1 + (1 + (1 + 0))) Int</span></span><br><span class="line"></span><br><span class="line"><span class="title">vec3</span> :: <span class="type">Vec</span> <span class="number">3</span> <span class="type">Int</span></span><br><span class="line"><span class="title">vec3</span> = <span class="number">0</span> `<span class="type">Cons</span>` (<span class="number">1</span> `<span class="type">Cons</span>` (<span class="number">2</span> `<span class="type">Cons</span>` <span class="type">Nil</span>))</span><br><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE KindSignatures #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleContexts #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.TypeLits</span><br><span class="line"><span class="keyword">import</span> Data.Type.Equality</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Foo</span> :: <span class="type">Nat</span> -&gt; * where</span></span><br><span class="line">  <span class="type">Small</span>    :: (n &lt;= <span class="number">2</span>)  =&gt; <span class="type">Foo</span> n</span><br><span class="line">  <span class="type">Big</span>      :: (<span class="number">3</span> &lt;= n) =&gt; <span class="type">Foo</span> n</span><br><span class="line"></span><br><span class="line">  <span class="type">Empty</span>    :: ((n == <span class="number">0</span>) ~ <span class="type">True</span>) =&gt; <span class="type">Foo</span> n</span><br><span class="line">  <span class="type">NonEmpty</span> :: ((n == <span class="number">0</span>) ~ <span class="type">False</span>) =&gt; <span class="type">Foo</span> n</span><br><span class="line"></span><br><span class="line"><span class="title">big</span> :: <span class="type">Foo</span> <span class="number">10</span></span><br><span class="line"><span class="title">big</span> = <span class="type">Big</span></span><br><span class="line"></span><br><span class="line"><span class="title">small</span> :: <span class="type">Foo</span> <span class="number">2</span></span><br><span class="line"><span class="title">small</span> = <span class="type">Small</span></span><br><span class="line"></span><br><span class="line"><span class="title">empty</span> :: <span class="type">Foo</span> <span class="number">0</span></span><br><span class="line"><span class="title">empty</span> = <span class="type">Empty</span></span><br><span class="line"></span><br><span class="line"><span class="title">nonempty</span> :: <span class="type">Foo</span> <span class="number">3</span></span><br><span class="line"><span class="title">nonempty</span> = <span class="type">NonEmpty</span></span><br></pre></td></tr></table></figure></p>
<p>請看: <a href="http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/type-level-literals.html" target="_blank" rel="noopener">Type-Level Literals</a>  </p>
<h3 id="Typelevel-Strings"><a href="#Typelevel-Strings" class="headerlink" title="Typelevel Strings"></a>Typelevel Strings</h3><blockquote>
<p>TODO</p>
</blockquote>
<h3 id="Custom-Errors"><a href="#Custom-Errors" class="headerlink" title="Custom Errors"></a>Custom Errors</h3><p>从<code>GHC 8.0</code>开始，我们可以使用<code>type families</code>提供自定义类型错误。<br>消息本身<code>hook into</code>(挂接)到<code>GHC</code>中，并使用在<code>GHC.TypeLits</code>中找到的小<code>datatype</code>(数据类型)表示。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">ErrorMessage</span> where</span></span><br><span class="line">  <span class="type">Text</span> :: <span class="type">Symbol</span> -&gt; <span class="type">ErrorMessage</span></span><br><span class="line">  <span class="type">ShowType</span> :: t -&gt; <span class="type">ErrorMessage</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Put two messages next to each other</span></span><br><span class="line">  (:&lt;&gt;:) :: <span class="type">ErrorMessage</span> -&gt; <span class="type">ErrorMessage</span> -&gt; <span class="type">ErrorMessage</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Put two messages on top of each other</span></span><br><span class="line">  (:$$:) :: <span class="type">ErrorMessage</span> -&gt; <span class="type">ErrorMessage</span> -&gt; <span class="type">ErrorMessage</span></span><br></pre></td></tr></table></figure></p>
<p>如果在表达式的签名中找到這些表达式中的任意一個，<code>GHC</code>将报告以下形式的错误消息：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">example</span>.hs:<span class="number">1</span>:<span class="number">1</span>: error:</span><br><span class="line">    • <span class="type">My</span> custom error message line <span class="number">1.</span></span><br><span class="line">    • <span class="type">My</span> custom error message line <span class="number">2.</span></span><br><span class="line">    • <span class="type">In</span> the expression: example</span><br><span class="line">      <span class="type">In</span> an equation for ‘foo’: foo = <span class="type">ECoerce</span> (<span class="type">EFloat</span> <span class="number">3</span>) (<span class="type">EInt</span> <span class="number">4</span>)</span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE UndecidableInstances #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.TypeLits</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span></span></span><br><span class="line"><span class="class">  <span class="comment">-- Error Message</span></span></span><br><span class="line">  TypeError (Text "Equality is not defined for functions"</span><br><span class="line">  :$$:</span><br><span class="line">  (<span class="type">ShowType</span> a :&lt;&gt;: <span class="type">Text</span> <span class="string">" -&gt; "</span> :&lt;&gt;: <span class="type">ShowType</span> b))</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Instance head</span></span><br><span class="line">  =&gt; <span class="type">Eq</span> (a -&gt; b) <span class="keyword">where</span> (==) = undefined</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Fail when we try to equate two functions</span></span><br><span class="line"><span class="title">example</span> = id == id</span><br></pre></td></tr></table></figure></p>
<p>一个不太人为的示例是创建一个类型安全的嵌入式<code>DSL</code>，该类型的<code>DSL</code>在类型级别上强制实现<code>semantics</code>(语义上)的<code>invariants</code>(不变性)。 一段时间以来，我们已经能够使用<code>GADT</code>和<code>type-families</code>来做这种事情，但是错误报告却非常可怕。使用<code>GHC 8.0</code>，我们可以拥有<code>type-families</code>，它可以发出有用的类型错误，以反映实际出了什么问题，并将其集成到<code>GHC</code>中。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE UndecidableInstances #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.TypeLits</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">Coerce</span> a b where</span></span><br><span class="line">  <span class="type">Coerce</span> <span class="type">Int</span> <span class="type">Int</span>     = <span class="type">Int</span></span><br><span class="line">  <span class="type">Coerce</span> <span class="type">Float</span> <span class="type">Float</span> = <span class="type">Float</span></span><br><span class="line">  <span class="type">Coerce</span> <span class="type">Int</span> <span class="type">Float</span>   = <span class="type">Float</span></span><br><span class="line">  <span class="type">Coerce</span> <span class="type">Float</span> <span class="type">Int</span>   = <span class="type">TypeError</span> (<span class="type">Text</span> <span class="string">"Cannot cast to smaller type"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span> a where</span></span><br><span class="line">  <span class="type">EInt</span>    :: <span class="type">Int</span> -&gt; <span class="type">Expr</span> <span class="type">Int</span></span><br><span class="line">  <span class="type">EFloat</span>  :: <span class="type">Float</span> -&gt; <span class="type">Expr</span> <span class="type">Float</span></span><br><span class="line">  <span class="type">ECoerce</span> :: <span class="type">Expr</span> b -&gt; <span class="type">Expr</span> c -&gt; <span class="type">Expr</span> (<span class="type">Coerce</span> b c)</span><br><span class="line"></span><br><span class="line"><span class="title">foo</span> :: <span class="type">Expr</span> <span class="type">Int</span></span><br><span class="line"><span class="title">foo</span> = <span class="type">ECoerce</span> (<span class="type">EFloat</span> <span class="number">3</span>) (<span class="type">EInt</span> <span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="Type-Equality"><a href="#Type-Equality" class="headerlink" title="Type Equality"></a>Type Equality</h3><p>继续以在<code>Haskell</code>中构建更详尽的证明为主题，<code>ghc 7.8</code>最近附带了<code>data.type.equality</code>模块，该模块为我们提供了一组扩展的类型级操作集，用于将<code>the equality of types</code>(类型相等)表示为<code>values</code>(值)、<code>constraints</code>(约束)和<code>promoted booleans</code>(提升的布尔值)。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(~)   :: k -&gt; k -&gt; <span class="type">Constraint</span></span><br><span class="line">(==)  :: k -&gt; k -&gt; <span class="type">Bool</span></span><br><span class="line">(&lt;=)  :: <span class="type">Nat</span> -&gt; <span class="type">Nat</span> -&gt; <span class="type">Constraint</span></span><br><span class="line">(&lt;=?) :: <span class="type">Nat</span> -&gt; <span class="type">Nat</span> -&gt; <span class="type">Bool</span></span><br><span class="line">(+)   :: <span class="type">Nat</span> -&gt; <span class="type">Nat</span> -&gt; <span class="type">Nat</span></span><br><span class="line">(-)   :: <span class="type">Nat</span> -&gt; <span class="type">Nat</span> -&gt; <span class="type">Nat</span></span><br><span class="line">(*)   :: <span class="type">Nat</span> -&gt; <span class="type">Nat</span> -&gt; <span class="type">Nat</span></span><br><span class="line">(^)   :: <span class="type">Nat</span> -&gt; <span class="type">Nat</span> -&gt; <span class="type">Nat</span></span><br><span class="line">(:~:)     :: k -&gt; k -&gt; *</span><br><span class="line"><span class="type">Refl</span>      :: a1 :~: a1</span><br><span class="line"><span class="title">sym</span>       :: (a :~: b) -&gt; b :~: a</span><br><span class="line"><span class="title">trans</span>     :: (a :~: b) -&gt; (b :~: c) -&gt; a :~: c</span><br><span class="line"><span class="title">castWith</span>  :: (a :~: b) -&gt; a -&gt; b</span><br><span class="line"><span class="title">gcastWith</span> :: (a :~: b) -&gt; (a ~ b =&gt; r) -&gt; r</span><br></pre></td></tr></table></figure></p>
<p>这样，我们就有了一种更强大的语言来编写可以在编译时检查的<code>restrictions</code>(限制/限定/框框)，以及一种将允许我们(稍后)编写更高级的证明的机制。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ConstraintKinds #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.TypeLits</span><br><span class="line"><span class="keyword">import</span> Data.Type.Equality</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Not</span> a b = ((<span class="title">b</span> == <span class="title">a</span>) ~ <span class="type">False</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="title">restrictUnit</span> :: <span class="type">Not</span> () a =&gt; a -&gt; a</span><br><span class="line"><span class="title">restrictUnit</span> = id</span><br><span class="line"></span><br><span class="line"><span class="title">restrictChar</span> :: <span class="type">Not</span> <span class="type">Char</span> a =&gt; a -&gt; a</span><br><span class="line"><span class="title">restrictChar</span> = id</span><br></pre></td></tr></table></figure></p>
<h3 id="Proxies-代理人"><a href="#Proxies-代理人" class="headerlink" title="Proxies (代理人)"></a>Proxies (代理人)</h3><p>对<code>phantom</code>(幻影)类型使用<code>kind polymorphism</code>(種類多态性)使我们可以表达<code>Proxy</code>类型，<br>该代理类型由一个没有参数的构造函数<code>inhabited</code>(所驻留)，但带有一個(可以携带任意一個類型的)<code>polykinded</code>(多種類)幻像类型变量。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE PolyKinds #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | A concrete, poly-kinded proxy type</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Proxy</span> t = <span class="type">Proxy</span></span></span><br><span class="line"><span class="keyword">import</span> Data.Proxy</span><br><span class="line"></span><br><span class="line"><span class="title">a</span> :: <span class="type">Proxy</span> ()</span><br><span class="line"><span class="title">a</span> = <span class="type">Proxy</span></span><br><span class="line"></span><br><span class="line"><span class="title">b</span> :: <span class="type">Proxy</span> <span class="number">3</span></span><br><span class="line"><span class="title">b</span> = <span class="type">Proxy</span></span><br><span class="line"></span><br><span class="line"><span class="title">c</span> :: <span class="type">Proxy</span> <span class="string">"symbol"</span></span><br><span class="line"><span class="title">c</span> = <span class="type">Proxy</span></span><br><span class="line"></span><br><span class="line"><span class="title">d</span> :: <span class="type">Proxy</span> <span class="type">Maybe</span></span><br><span class="line"><span class="title">d</span> = <span class="type">Proxy</span></span><br><span class="line"></span><br><span class="line"><span class="title">e</span> :: <span class="type">Proxy</span> (<span class="type">Maybe</span> ())</span><br><span class="line"><span class="title">e</span> = <span class="type">Proxy</span></span><br></pre></td></tr></table></figure></p>
<p>如果我们通常将<code>undefined</code>作为类型类字典的<code>witness</code>(见证)来传递，我们可以改为传递一个带有幻像类型的<code>Proxy</code>对象，而无需<code>bottom</code>(底部)。<br>(<code>Using scoped type variables we can then operate with the phantom parameter and manipulate wherever is needed.</code>)<br>使用作用域类型变量，我们可以与<code>phantom</code>参数<code>operate with</code>(合作)，并在需要的地方进行<code>manipulate</code>(操作)。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">t1</span> :: a</span><br><span class="line"><span class="title">t1</span> = (undefined :: a)</span><br><span class="line"></span><br><span class="line"><span class="title">t2</span> :: <span class="type">Proxy</span> a</span><br><span class="line"><span class="title">t2</span> <span class="type">Proxy</span> :: <span class="type">Proxy</span> a</span><br></pre></td></tr></table></figure>
<h3 id="Promoted-Syntax"><a href="#Promoted-Syntax" class="headerlink" title="Promoted Syntax"></a>Promoted Syntax</h3><h3 id="Singleton-Types"><a href="#Singleton-Types" class="headerlink" title="Singleton Types"></a>Singleton Types</h3><blockquote>
<p>这是高级部分，编写Haskell通常不需要<code>Singleton Types</code>知识。</p>
</blockquote>
<h3 id="Closed-Type-Families"><a href="#Closed-Type-Families" class="headerlink" title="Closed Type Families"></a>Closed Type Families</h3><h3 id="Kind-Indexed-Type-Families"><a href="#Kind-Indexed-Type-Families" class="headerlink" title="Kind Indexed Type Families"></a>Kind Indexed Type Families</h3><blockquote>
<p>这是高级部分，编写Haskell通常不需要。</p>
</blockquote>
<h3 id="Promoted-Symbols"><a href="#Promoted-Symbols" class="headerlink" title="Promoted Symbols"></a>Promoted Symbols</h3><h3 id="HLists"><a href="#HLists" class="headerlink" title="HLists"></a>HLists</h3><blockquote>
<p>这是高级部分，编写Haskell通常不需要。</p>
</blockquote>
<h3 id="Typelevel-Dictionaries"><a href="#Typelevel-Dictionaries" class="headerlink" title="Typelevel Dictionaries"></a>Typelevel Dictionaries</h3><h3 id="Advanced-Proofs"><a href="#Advanced-Proofs" class="headerlink" title="Advanced Proofs"></a>Advanced Proofs</h3><blockquote>
<p>这是高级部分，编写Haskell通常不需要。</p>
</blockquote>
<h3 id="Liquid-Haskell"><a href="#Liquid-Haskell" class="headerlink" title="Liquid Haskell"></a>Liquid Haskell</h3><blockquote>
<p>这是高级部分，编写Haskell通常不需要<code>LiquidLiskell</code>的知识。</p>
</blockquote>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/blog/js/index.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/blog/js/gitment.js"></script>
<script>
    var gitment = new Gitment({
        id: 'Haskell-Promotion',
        owner: 'limengyu1990',
        repo: 'hexo-blog',
        oauth: {
            client_id: '7cfc73dd62b57f07ed83',
            client_secret: 'dd03b7e54aadf0d81e4c9c93e23a41272bcfcfa1',
        },
    })
    gitment.render('comment-container')
</script>

</html>
