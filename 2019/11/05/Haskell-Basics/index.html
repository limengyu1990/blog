<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        Haskell-Basics - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>不负如来不负卿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cabal"><span class="toc-text">Cabal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack"><span class="toc-text">Stack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Install"><span class="toc-text">Install</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Usage"><span class="toc-text">Usage</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flags"><span class="toc-text">Flags</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hackage"><span class="toc-text">Hackage</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Reusable-Code-Building-Blocks-可重复使用的代码-构建块"><span class="toc-text">Reusable Code / Building Blocks(可重复使用的代码/构建块)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#A-Staging-Area-Request-for-Comments-暂存区-征求意见"><span class="toc-text">A Staging Area / Request for Comments(暂存区/征求意见)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GHCi"><span class="toc-text">GHCi</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GHCi-Performance-性能"><span class="toc-text">GHCi Performance(性能)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Editor-Integration"><span class="toc-text">Editor Integration</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vim"><span class="toc-text">Vim</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Emacs"><span class="toc-text">Emacs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Atom"><span class="toc-text">Atom</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bottoms"><span class="toc-text">Bottoms</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exhaustiveness-穷举"><span class="toc-text">Exhaustiveness(穷举)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Debugger"><span class="toc-text">Debugger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack-Traces-堆栈跟踪"><span class="toc-text">Stack Traces(堆栈跟踪)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trace"><span class="toc-text">Trace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Type-Inference-类型推断"><span class="toc-text">Type Inference(类型推断)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mutually-Recursive-Binding-Groups-相互递归绑定组"><span class="toc-text">Mutually Recursive Binding Groups(相互递归绑定组)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Polymorphic-recursion-多态递归"><span class="toc-text">Polymorphic recursion(多态递归)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Monomorphism-Restriction-单态限制"><span class="toc-text">Monomorphism Restriction(单态限制)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Type-Holes-Pattern-Wildcards"><span class="toc-text">Type Holes / Pattern Wildcards</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deferred-Type-Errors-延迟的类型错误"><span class="toc-text">Deferred Type Errors(延迟的类型错误)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ghcid"><span class="toc-text">ghcid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Haddock"><span class="toc-text">Haddock</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Haskell-Basics
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-11-05 16:57:40</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/blog/tags/#Wish-Knew" title="Wish-Knew">Wish-Knew</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Haskell" title="Haskell">Haskell</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Basics" title="Basics">Basics</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p><a href="http://dev.stephendiehl.com/hask/#basics" target="_blank" rel="noopener">原文</a></p>
</blockquote>
<h3 id="Cabal"><a href="#Cabal" class="headerlink" title="Cabal"></a>Cabal</h3><blockquote>
<p>历史上，Cabal有一个称为Cabal install的组件，它在很大程度上被Stack所取代。由于历史原因，下面使用的是Cabal沙箱，通常可以用现代工具代替。</p>
</blockquote>
<p><a href="https://www.haskell.org/cabal/" target="_blank" rel="noopener">Cabal</a>是<code>Haskell</code>的构建系统。</p>
<p>例如，要从<code>Hackage</code>(<code>Haskell</code>包的上游源)将<code>parsec</code>包安装到系统中，请调用<code>install</code>命令:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cabal install parsec           # latest version</span><br><span class="line">$ cabal install parsec==<span class="number">3.1</span><span class="number">.5</span>    # exact version</span><br></pre></td></tr></table></figure></p>
<p><code>Haskell</code>软件包的常规构建调用如下:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cabal get parsec    # fetch source</span><br><span class="line">$ cd parsec<span class="number">-3.1</span><span class="number">.5</span></span><br><span class="line"></span><br><span class="line">$ cabal configure</span><br><span class="line">$ cabal build</span><br><span class="line">$ cabal install</span><br></pre></td></tr></table></figure></p>
<p>要从<code>Hackage</code>更新软件包索引，请运行:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cabal update</span><br></pre></td></tr></table></figure>
<p>要启动一个新的<code>Haskell</code>项目，请运行:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cabal init</span><br><span class="line">$ cabal configure</span><br></pre></td></tr></table></figure></p>
<p>将使用新项目的配置选项创建一个<code>.cabal</code>文件。</p>
<p><code>cabal</code>的最新功能是增加了<code>Sandboxes</code>(沙箱)(在<code>cabal</code>&gt;1.18中)，它们是<code>Haskell</code>软件包的独立环境，与存储在我们项目根目录<code>./.cabal-sandbox</code>中的全局软件包索引分开。要为我们的<code>cabal</code>项目创建一个新的沙箱，请运行:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cabal sandbox init</span><br></pre></td></tr></table></figure></p>
<p>此外，可以将沙箱拆除:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cabal sandbox delete</span><br></pre></td></tr></table></figure></p>
<p>当在具有已设置配置的沙箱的项目的工作目录中时，调用<code>cabal</code>命令会更改<code>cabal</code>本身的行为。 例如，<code>cabal install</code>命令只将安装更改为本地包索引, 而不更改全局配置。</p>
<p>要将<code>.cabal</code>文件中的依赖项安装到新创建的沙盒中，请运行:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cabal install <span class="comment">--only-dependencies</span></span><br></pre></td></tr></table></figure></p>
<p>也可以通过传递<code>-j&lt;n&gt;</code>来并行构建依赖关系，其中<code>n</code>是并发构建的数量。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cabal install -j4 <span class="comment">--only-dependencies</span></span><br></pre></td></tr></table></figure></p>
<p>让我们看一个示例<code>.cabal</code>文件。任何软件包都可以提供两个主要入口点：一个<code>library</code>(库)和一个<code>executable</code>(可执行文件)。<br>可以定义多个可执行文件，但只能定义一个<code>library</code>(库)。另外，还有一种特殊形式的可执行入口<code>Test-Suite</code>，它定义了一个接口，用于从<code>cabal</code>调用单元测试。</p>
<p>对于<code>library</code>，<code>.cabal</code>文件中的<code>exposed-modules</code>字段指示在安装软件包时，该软件包结构中的哪些模块将公开可见。这些模块是我们希望向下游使用者公开的面向用户的<code>API</code>。</p>
<p>对于<code>executable</code>，<code>main-is</code>字段表示导出运行应用程序可执行逻辑的<code>main</code>函數的模块。包中的每个模块都必须在<code>ther-modules</code>，<code>exposed-modules</code>或<code>main-is</code>字段之一中列出。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">name</span>:               mylibrary</span><br><span class="line"><span class="title">version</span>:            <span class="number">0.1</span></span><br><span class="line"><span class="title">cabal</span>-version:      &gt;= <span class="number">1.10</span></span><br><span class="line"><span class="title">author</span>:             <span class="type">Paul</span> <span class="type">Atreides</span></span><br><span class="line"><span class="title">license</span>:            <span class="type">MIT</span></span><br><span class="line"><span class="title">license</span>-file:       <span class="type">LICENSE</span></span><br><span class="line"><span class="title">synopsis</span>:           <span class="type">The</span> code must flow.</span><br><span class="line"><span class="title">category</span>:           <span class="type">Math</span></span><br><span class="line"><span class="title">tested</span>-with:        <span class="type">GHC</span></span><br><span class="line"><span class="title">build</span>-<span class="class"><span class="keyword">type</span>:         <span class="type">Simple</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">library</span></span><br><span class="line">    exposed-modules:</span><br><span class="line">      <span class="type">Library</span>.<span class="type">ExampleModule1</span></span><br><span class="line">      <span class="type">Library</span>.<span class="type">ExampleModule2</span></span><br><span class="line"></span><br><span class="line">    build-depends:</span><br><span class="line">      base &gt;= <span class="number">4</span> &amp;&amp; &lt; <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>-language: <span class="type">Haskell2010</span></span><br><span class="line"></span><br><span class="line">    ghc-options: -<span class="type">O2</span> -<span class="type">Wall</span> -fwarn-tabs</span><br><span class="line"></span><br><span class="line"><span class="title">executable</span> <span class="string">"example"</span></span><br><span class="line">    build-depends:</span><br><span class="line">        base &gt;= <span class="number">4</span> &amp;&amp; &lt; <span class="number">5</span>,</span><br><span class="line">        mylibrary == <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">default</span>-language: <span class="type">Haskell2010</span></span><br><span class="line">    main-is: <span class="type">Main</span>.hs</span><br><span class="line"></span><br><span class="line"><span class="type">Test</span>-<span class="type">Suite</span> test</span><br><span class="line">  <span class="class"><span class="keyword">type</span>: exitcode-stdio-1.0</span></span><br><span class="line">  main-is: <span class="type">Test</span>.hs</span><br><span class="line">  <span class="keyword">default</span>-language: <span class="type">Haskell2010</span></span><br><span class="line">  build-depends:</span><br><span class="line">      base &gt;= <span class="number">4</span> &amp;&amp; &lt; <span class="number">5</span>,</span><br><span class="line">      mylibrary == <span class="number">0.1</span></span><br></pre></td></tr></table></figure>
<p>为<code>cabal sandbox</code>下的项目运行<code>executable</code>:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cabal run</span><br><span class="line">$ cabal run &lt;name&gt; # 当项目中有多个可执行文件时</span><br></pre></td></tr></table></figure></p>
<p>要将<code>library</code>加载到<code>cabal sandbox</code>下的<a href="http://dev.stephendiehl.com/hask/#ghci" target="_blank" rel="noopener">GHCi shell</a>中:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cabal repl</span><br><span class="line">$ cabal repl &lt;name&gt;</span><br></pre></td></tr></table></figure></p>
<p>元变量<code>&lt;name&gt;</code>是<code>.cabal</code>文件中的可执行文件或库声明之一，可以分别由前缀<code>exe：&lt;name&gt;</code>或<code>lib：&lt;name&gt;</code>消除歧义。</p>
<p>要在本地将包构建到<code>./dist/build</code>文件夹中，请执行<code>build</code>命令:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cabal build</span><br></pre></td></tr></table></figure></p>
<p>要运行测试，我们的软件包本身必须使用<code>--enable-tests</code>和<code>build-depends</code>选项进行重新配置。如果尚未安装，则必须手动安装<code>Test-Suite</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cabal install <span class="comment">--only-dependencies --enable-tests</span></span><br><span class="line">$ cabal configure <span class="comment">--enable-tests</span></span><br><span class="line">$ cabal test</span><br><span class="line">$ cabal test &lt;name&gt;</span><br></pre></td></tr></table></figure></p>
<p>此外，可以使用为<code>sandbox</code>设置的<code>GHC</code>环境变量来调用任意的<code>shell</code>命令。很常见的是使用此命令调用新的<code>shell</code>，以便<code>ghc</code>和<code>ghci</code>命令使用<code>sandbox</code>。(默认情况下，它们不是默认值，这是造成失败的常见原因。)<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cabal exec</span><br><span class="line">$ cabal exec sh # 使用<span class="type">GHC</span>沙箱路径集启动shell</span><br></pre></td></tr></table></figure></p>
<p><code>haddock</code>文档可以通过执行<code>haddock</code>命令为本地项目生成。该文档将建立在<code>./dist</code>文件夹中.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cabal haddock</span><br></pre></td></tr></table></figure></p>
<p>当我们终于准备好上传到<code>Hackage</code>时（假设我们已经设置了<code>Hackage</code>帐户），那么我们可以构建<code>tarball</code>并使用以下命令上传:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cabal sdist</span><br><span class="line">$ cabal upload dist/mylibrary<span class="number">-0.1</span>.tar.gz</span><br></pre></td></tr></table></figure>
<p>有时，您还想将本地项目中的库添加到沙箱中。在这种情况下，请运行<code>add-source</code>命令将库从本地目录引入沙箱:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cabal sandbox add-source /path/to/project</span><br></pre></td></tr></table></figure></p>
<p>沙箱的当前状态可以在枚举所有当前程序包约束的情况下<code>frozen</code>(冻结):<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cabal freeze</span><br></pre></td></tr></table></figure></p>
<p>这将创建带有约束集的文件<code>cabal.config</code>.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">constraints</span>: mtl ==<span class="number">2.2</span><span class="number">.1</span>,</span><br><span class="line">             text ==<span class="number">1.1</span><span class="number">.1</span><span class="number">.3</span>,</span><br><span class="line">             transformers ==<span class="number">0.4</span><span class="number">.1</span><span class="number">.0</span></span><br></pre></td></tr></table></figure></p>
<p>最好使用<code>cabal repl</code>和<code>cabal run</code>命令，但有时我们想在<code>shell</code>上手动执行它们的等效操作。<br>几个有用的别名依靠<code>shell</code>目录扩展来在当前工作目录中找到程序包数据库，并使用适当的标志启动<code>GHC</code>:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">alias</span> ghc-sandbox=<span class="string">"ghc -no-user-package-db -package-db .cabal-sandbox/*-packages.conf.d"</span></span><br><span class="line"><span class="title">alias</span> ghci-sandbox=<span class="string">"ghci -no-user-package-db -package-db .cabal-sandbox/*-packages.conf.d"</span></span><br><span class="line"><span class="title">alias</span> runhaskell-sandbox=<span class="string">"runhaskell -no-user-package-db -package-db .cabal-sandbox/*-packages.conf.d"</span></span><br></pre></td></tr></table></figure></p>
<p>还有一个<code>zsh</code>脚本，用于在我们的<code>Shell</code>中显示当前工作目录的沙箱状态:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function cabal_sandbox_info() &#123;</span><br><span class="line">    cabal_files=(*.cabal(N))</span><br><span class="line">    if [ $#cabal_files -gt 0 ]; then</span><br><span class="line">        if [ -f cabal.sandbox.config ]; then</span><br><span class="line">            echo "%&#123;$fg[green]%&#125;sandboxed%&#123;$reset_color%&#125;"</span><br><span class="line">        else</span><br><span class="line">            echo "%&#123;$fg[red]%&#125;not sandboxed%&#123;$reset_color%&#125;"</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RPROMPT="\$(cabal_sandbox_info) $RPROMPT"</span><br></pre></td></tr></table></figure></p>
<p><code>cabal</code>配置存储在<code>$HOME/.cabal/config</code>中，包含各种选项，包括用于<code>Hackage</code>上傳的凭据信息。<br>配置的另一个附加功能是完全禁止在沙盒外安装包，以防止意外冲突。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Don't allow global install of packages.</span></span><br><span class="line"><span class="title">require</span>-sandbox: <span class="type">True</span></span><br></pre></td></tr></table></figure></p>
<p>也可以在启用运行时分析信息的情况下编译<code>library</code>(库)。关于<a href="http://dev.stephendiehl.com/hask/#concurrency" target="_blank" rel="noopener">并发</a>和<a href="http://dev.stephendiehl.com/hask/#profiling" target="_blank" rel="noopener">概要分析</a>的部分将对此进行更多讨论.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">library</span>-profiling: <span class="type">True</span></span><br></pre></td></tr></table></figure></p>
<p>启用的另一个常见标志是<code>documentation</code>，它强制在本地构建<code>Haddock</code>文档，这对于<code>offline reference</code>(離線引用)很有用。</p>
<p>在<code>Linux</code>文件系统上，这些文件构建在<code>/usr/share/doc/ghc-doc/html/libraries/</code>目录中.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">documentation</span>: <span class="type">True</span></span><br></pre></td></tr></table></figure></p>
<p>如果当前已安装<code>GHC</code>，则可以在此本地链接上找到<code>Prelude</code>和<code>Base</code>库的文档:<br><a href="file:///usr/share/doc/ghc-doc/html/libraries/index.html" target="_blank" rel="noopener">/usr/share/doc/ghc-doc/html/libraries/index.html</a></p>
<p>請看:</p>
<ul>
<li><a href="http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html" target="_blank" rel="noopener">An Introduction to Cabal Sandboxes</a>(<code>Cabal</code>沙箱简介)</li>
<li><a href="http://www.vex.net/~trebla/haskell/sicp.xhtml" target="_blank" rel="noopener">Storage and Identification of Cabalized Packages</a>(<code>Cabal</code>包的存储和标识)</li>
</ul>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p><a href="http://docs.haskellstack.org/en/stable/README/" target="_blank" rel="noopener">Stack</a>是2015年出现的<code>Haskell</code>包结构的一种新方法。<code>stack</code>没有使用类似于<code>cabal install</code>的滚动构建，而是将一组软件包分解成保证软件包之间内部兼容性的<code>release</code>(发布/版本)块。<br>与<code>cabal-install</code>过去使用的软件包相比，<code>stack</code>的软件包<code>solver</code>(求解器)使用了一种不同的，更强大的策略来解决依赖关系。</p>
<h4 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h4><p>要在<code>Ubuntu Linux</code>上安装<code>stack</code>，请运行:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> get fp complete key</span><br><span class="line">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 575159689BEFB442</span><br><span class="line"><span class="meta">#</span> add appropriate source repo</span><br><span class="line">echo 'deb http://download.fpcomplete.com/ubuntu trusty main'|sudo tee /etc/apt/sources.list.d/fpco.list</span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install stack -y</span><br></pre></td></tr></table></figure></p>
<p>对于其他操作系统，请参阅<a href="http://docs.haskellstack.org/en/stable/install_and_upgrade/" target="_blank" rel="noopener">官方安装说明</a>。</p>
<h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><p>一旦安装了<code>Stack</code>，就可以通过运行以下命令在现有项目的<code>cabal</code>文件之上设置构建环境:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">stack</span> init</span><br></pre></td></tr></table></figure></p>
<p><code>GHC 7.10.3</code>的示例<code>stack.yaml</code>文件如下所示:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">resolver</span>: lts<span class="number">-7.12</span></span><br><span class="line"><span class="title">flags</span>: &#123;&#125;</span><br><span class="line"><span class="title">extra</span>-package-dbs: []</span><br><span class="line"><span class="title">packages</span>: []</span><br><span class="line"><span class="title">extra</span>-deps: []</span><br></pre></td></tr></table></figure></p>
<p>日常开发中使用的大多数常见库已经在<a href="https://www.stackage.org/" target="_blank" rel="noopener">Stackage</a>存储库中。<code>extra-deps</code>字段可用于添加不在<code>Stackage</code>存储库中的<a href="http://hackage.haskell.org/" target="_blank" rel="noopener">Hackage</a>依赖项。它们由<code>package</code>(软件包)和<code>version key</code>(版本密钥)指定。<br>例如，可以将<code>zenc</code>软件包添加到堆栈构建中:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">extra</span>-deps:</span><br><span class="line">- zenc<span class="number">-0.1</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></p>
<p><code>stack</code>命令可用于将<code>packages</code>(软件包)和<code>executables</code>(可执行文件)安装到当前构建环境或全局环境中。例如，以下命令为<code>Haskell</code>流行的<code>linting</code>工具<a href="https://github.com/ndmitchell/hlint" target="_blank" rel="noopener">hlint</a>安装<code>executable</code>(可执行文件)，并将其放置在<code>PATH</code>中:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> stack install hlint</span><br></pre></td></tr></table></figure></p>
<p>要检查依赖项集，请运行:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> stack list-dependencies</span><br></pre></td></tr></table></figure></p>
<p>就像<code>cabal</code>一样，可以使用<code>stack</code>命令来<code>orchestrated</code>(编排)<code>build</code>(构建)和<code>debug</code>(调试)过程:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> stack build                 # Build a cabal target</span><br><span class="line"><span class="meta">$</span> stack repl                  # 啟動ghci</span><br><span class="line"><span class="meta">$</span> stack ghc                   # 在堆栈环境中调用独立编译器</span><br><span class="line"><span class="meta">$</span> stack exec bash             # 使用堆栈GHC环境变量执行Shell命令</span><br><span class="line"><span class="meta">$</span> stack build --file-watch    # 在每次文件系统更改的基础上构建</span><br></pre></td></tr></table></figure></p>
<p>要可视化依赖关系图，请先使用<code>dot</code>命令将其通过管道传送到<code>graphviz</code>，然后再通过管道将其传送到您喜欢的图像查看器中:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> stack dot --external | dot -Tpng | feh -</span><br></pre></td></tr></table></figure></p>
<h3 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h3><p>启用<code>GHC</code><a href="[https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flag-reference.html">编译器标志</a>可以使用户在检测常见代码错误时拥有更多控制权。最常用的标志是:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Flag	                            Description</span><br><span class="line">--------------------------------------------------</span><br><span class="line">-fwarn-tabs	                        在源代码中发出制表符而不是空格的警告</span><br><span class="line"></span><br><span class="line">-fwarn-unused-imports	            警告已导入卻未使用的库</span><br><span class="line"></span><br><span class="line">-fwarn-name-shadowing	            警告嵌套绑定中的重复名称</span><br><span class="line"></span><br><span class="line">-fwarn-incomplete-uni-patterns	    对lambda或模式绑定中的不完整模式发出警告</span><br><span class="line"></span><br><span class="line">-fwarn-incomplete-patterns	        对非穷举(non-exhaustive)模式发出警告</span><br><span class="line"></span><br><span class="line">-fwarn-overlapping-patterns	        对重叠的模式匹配分支发出警告</span><br><span class="line"></span><br><span class="line">-fwarn-incomplete-record-updates    当未使用所有字段实例化Record时发出警告</span><br><span class="line"></span><br><span class="line">-fdefer-type-errors	                将类型错误转化为警告</span><br><span class="line"></span><br><span class="line">-fwarn-missing-signatures	        對top-level缺少类型签名发出警告</span><br><span class="line"></span><br><span class="line">-fwarn-monomorphism-restriction	    当隐式应用单态限定时发出警告</span><br><span class="line"></span><br><span class="line">-fwarn-orphans	                    孤立(orphan)类型类实例警告</span><br><span class="line"></span><br><span class="line">-fforce-recomp	                    强制重新编译，而不考虑时间戳</span><br><span class="line"></span><br><span class="line">-fno-code	                        省略代码生成，只解析和类型检查</span><br><span class="line"></span><br><span class="line">-fobject-code	                    生成目标(object)代码</span><br></pre></td></tr></table></figure></p>
<p>像大多数编译器一样，<code>GHC</code>带有<code>-Wall</code>标志来启用所有警告。但是，一些启用的警告非常详细。<br>例如，<code>-fwarn-unused-do-bind</code>和<code>-fwarn-unused-matches</code>通常不会对应于错误或失败。<br>这些标志中的任何一个都可以添加到项目<code>.cabal</code>文件的<code>ghc-options</code>部分中。例如:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">library</span> mylib</span><br><span class="line"></span><br><span class="line">  ghc-options:</span><br><span class="line">    -fwarn-tabs</span><br><span class="line">    -fwarn-unused-imports</span><br><span class="line">    -fwarn-missing-signatures</span><br><span class="line">    -fwarn-name-shadowing</span><br><span class="line">    -fwarn-incomplete-patterns</span><br></pre></td></tr></table></figure></p>
<p>上面描述的标志只是最有用的。有关<code>GHC</code>支持的标志的完整集合，请参见<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flag-reference.html" target="_blank" rel="noopener">官方参考</a>。</p>
<p>有关调试GHC内部组件的信息，请参见有关<code>GHC</code>内部组件的<a href="http://dev.stephendiehl.com/hask/#block-diagram" target="_blank" rel="noopener">注释/評論</a>。</p>
<h3 id="Hackage"><a href="#Hackage" class="headerlink" title="Hackage"></a>Hackage</h3><p><code>Hackage</code>是免费(和/或)开源<code>Haskell</code>包的上游源代码。</p>
<p>随着<code>Haskell</code>的不断发展，<code>Hackage</code>对开发人员来说已经成为很多<code>things</code>(事情)，但是对于上传的库来说，似乎有两种主要的哲学。</p>
<h4 id="Reusable-Code-Building-Blocks-可重复使用的代码-构建块"><a href="#Reusable-Code-Building-Blocks-可重复使用的代码-构建块" class="headerlink" title="Reusable Code / Building Blocks(可重复使用的代码/构建块)"></a>Reusable Code / Building Blocks(可重复使用的代码/构建块)</h4><p>在第一种哲学中，<code>libraries</code>作为可靠的，由社区支持的<code>building blocks</code>(构建模块)存在，用于在通用的稳定建筑物之上构建更高级别的功能。</p>
<p>在以这种方法为主导理念的开发社区中，<code>libraries</code>的作者将其编写为一种打包他们对问题领域的理解的方法，以便其他人可以在其理解和专业知识的基础上进行构建。</p>
<h4 id="A-Staging-Area-Request-for-Comments-暂存区-征求意见"><a href="#A-Staging-Area-Request-for-Comments-暂存区-征求意见" class="headerlink" title="A Staging Area / Request for Comments(暂存区/征求意见)"></a>A Staging Area / Request for Comments(暂存区/征求意见)</h4><p>与上一個的打包方法相比，<code>Haskell</code>社区的一个普遍哲学是<code>Hackage</code>是一个上传实验库的地方，以此作为获取社区反馈和使代码公开可用的一种方式。 <code>Library</code>作者通常通过简单地指出他们打算拆除代码并在以后重新编写代码，来合理化地将这些类型的图书馆设置为无文档状态，而通常不指明图书馆的实际功能。 不幸的是，这种方法意味着许多<code>Hackage</code>命名空间已被<code>dead-end</code>(死胡同)，<code>bit-rotting code</code>(位腐烂)的代码所污染。有时，软件包也纯粹是上傳的，供组织内部使用，与论文一起使用，或仅与<code>cabal</code>构建系统集成。这些软件包通常也没有文档记录。</p>
<p>对于从其他语言生态系统(如<code>Python</code>、<code>JavaScript</code>、<code>Ruby</code>)来到<code>Haskell</code>的开发人员来说，看到成千上万的库而没有任何文档或目的描述可能会令人不安。鉴于这些哲学上的差异，目前的黑客文化状态是否可持续，这是一个悬而未决的问题。<br>不用说，现在有很多非常低质量的<code>Haskell</code>代码和文档，所以在<code>library</code>评估中保持保守是一项必要的技能。也就是说，在<code>Hackage</code>上也有很多非凡的<code>library</code>，它们被很多人精心策划。</p>
<p>通常，如果该库的<code>Haddock</code>文档没有一个简单的示例，通常可以安全地假定它是<code>RFC</code>样式的库，并且应该在生产级代码中避免使用。</p>
<p>同样，如果该库早于<a href="http://hackage.haskell.org/package/text" target="_blank" rel="noopener">text</a>库（于2007年发布），则应在生产代码中避免使用它。 自早期以来，我们编写<code>Haskell</code>的方式已经发生了巨大变化。</p>
<h3 id="GHCi"><a href="#GHCi" class="headerlink" title="GHCi"></a>GHCi</h3><p><a href="https://wiki.haskell.org/GHC/GHCi" target="_blank" rel="noopener">GHCi</a>是<code>GHC</code>编译器的交互式<code>shell</code>。<br><code>GHCi</code>是我们将大部分时间用于日常开发的地方。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Command	Shortcut	Action</span><br><span class="line">-----------------------------</span><br><span class="line">:reload	:r	        代码重新加载</span><br><span class="line">:type	:t	        类型检查</span><br><span class="line">:kind	:k	        Kind检查</span><br><span class="line">:info	:i	        信息</span><br><span class="line">:print	:p	        打印表达式</span><br><span class="line">:edit	:e	        在系统编辑器中加载文件</span><br><span class="line">:load	:l	        在REPL中设置活动的Main模块</span><br><span class="line">:add	:ad	        将文件加载到REPL名称空间</span><br><span class="line">:browse	:bro	    浏览REPL名称空间中的所有可用符号</span><br></pre></td></tr></table></figure></p>
<p><code>introspection</code>(自省)命令是调试和与<code>Haskell</code>代码进行交互的重要部分:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">λ: :<span class="class"><span class="keyword">type</span> 3</span></span><br><span class="line"><span class="number">3</span> :: <span class="type">Num</span> a =&gt; a</span><br><span class="line">λ: :kind <span class="type">Either</span></span><br><span class="line"><span class="type">Either</span> :: * -&gt; * -&gt; *</span><br><span class="line">λ: :info <span class="type">Functor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">  fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">  (&lt;$) :: a -&gt; f b -&gt; f a</span><br><span class="line">        <span class="comment">-- Defined in `GHC.Base'</span></span><br><span class="line">  ...</span><br><span class="line">λ: :i (:)</span><br><span class="line"><span class="class"><span class="keyword">data</span> [] a = ... | a : [a]       <span class="comment">-- Defined in `GHC.Types'</span></span></span><br><span class="line"><span class="keyword">infixr</span> <span class="number">5</span> :</span><br></pre></td></tr></table></figure></p>
<p>在<code>shell</code>中查询全局环境的当前状态也是可能的。例如，要查看<code>GHCi</code>中的模块级绑定和类型，请运行:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">λ: :browse</span><br><span class="line">λ: :show bindings</span><br></pre></td></tr></table></figure></p>
<p>检查模块级别的导入，执行:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">λ: :show imports</span><br><span class="line"><span class="keyword">import</span> Prelude <span class="comment">-- implicit</span></span><br><span class="line"><span class="keyword">import</span> Data.Eq</span><br><span class="line"><span class="keyword">import</span> Control.Monad</span><br></pre></td></tr></table></figure></p>
<p>要查看编译器级别的标志和编译指示，请使用:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">λ: :set</span><br><span class="line"><span class="title">options</span> currently set: none.</span><br><span class="line"><span class="title">base</span> language is: <span class="type">Haskell2010</span></span><br><span class="line"><span class="title">with</span> the following modifiers:</span><br><span class="line">  -<span class="type">XNoDatatypeContexts</span></span><br><span class="line">  -<span class="type">XNondecreasingIndentation</span></span><br><span class="line"><span class="type">GHCi</span>-specific dynamic flag settings:</span><br><span class="line"><span class="title">other</span> dynamic, non-language, flag settings:</span><br><span class="line">  -fimplicit-<span class="keyword">import</span>-<span class="keyword">qualified</span></span><br><span class="line"><span class="title">warning</span> settings:</span><br><span class="line"></span><br><span class="line">λ: :showi language</span><br><span class="line"><span class="title">base</span> language is: <span class="type">Haskell2010</span></span><br><span class="line"><span class="title">with</span> the following modifiers:</span><br><span class="line">  -<span class="type">XNoDatatypeContexts</span></span><br><span class="line">  -<span class="type">XNondecreasingIndentation</span></span><br><span class="line">  -<span class="type">XExtendedDefaultRules</span></span><br></pre></td></tr></table></figure></p>
<p>可以在提示符下设置语言扩展名和编译器编译指示。有关大量编译器标志选项的信息，请参见<a href="http://dev.stephendiehl.com/hask/#flags" target="_blank" rel="noopener">标志参考</a>。</p>
<p>交互式<code>shell</code>的一些命令具有快捷方式:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">Function</span></span><br><span class="line">+t	显示评估表达式的类型</span><br><span class="line">+s	显示计时和内存使用情况</span><br><span class="line">+m	启用以:&#123;和:&#125;分隔的多行表达式。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">λ: :set +t</span><br><span class="line">λ: []</span><br><span class="line">[]</span><br><span class="line"><span class="title">it</span> :: [a]</span><br><span class="line"></span><br><span class="line">λ: :set +s</span><br><span class="line">λ: foldr (+) <span class="number">0</span> [<span class="number">1.</span><span class="number">.25</span>]</span><br><span class="line"><span class="number">325</span></span><br><span class="line"><span class="title">it</span> :: <span class="type">Prelude</span>.<span class="type">Integer</span></span><br><span class="line">(<span class="number">0.02</span> secs, <span class="number">4900952</span> bytes)</span><br><span class="line"></span><br><span class="line">λ: :&#123;</span><br><span class="line">λ:| <span class="keyword">let</span> foo = <span class="keyword">do</span></span><br><span class="line">λ:|           putStrLn <span class="string">"hello ghci"</span></span><br><span class="line">λ:| :&#125;</span><br><span class="line">λ: foo</span><br><span class="line"><span class="string">"hello ghci"</span></span><br></pre></td></tr></table></figure></p>
<p>通过在<code>$HOME/.ghc/</code>中定义<code>ghci.conf</code>，或在当前工作目录中为<code>./.ghci.conf</code>，可以全局定制<code>GHCi shell</code>的配置。</p>
<p>例如，我们可以添加一条命令，以从<code>GHCi</code>中使用<code>Hoogle</code>类型搜索。首先，安装<code>hoogle</code>:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">cabal</span> install hoogle</span><br></pre></td></tr></table></figure></p>
<p>然后，我们可以通过向<code>ghci.conf</code>中添加命令来启用搜索功能:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:set prompt <span class="string">"λ: "</span></span><br><span class="line"></span><br><span class="line">:def hlint const . return $ <span class="string">":! hlint \"src\""</span></span><br><span class="line">:def hoogle \s -&gt; return $ <span class="string">":! hoogle --count=15 \""</span> ++ s ++ <span class="string">"\""</span></span><br><span class="line">λ: :hoogle (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line"><span class="type">Data</span>.<span class="type">Traversable</span> fmapDefault :: <span class="type">Traversable</span> t =&gt; (a -&gt; b) -&gt; t a -&gt; t b</span><br><span class="line"><span class="type">Prelude</span> fmap :: <span class="type">Functor</span> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure></p>
<p>出于性感的原因，希望将<code>GHC</code>提示设置为一个<code>λ</code>或一个<code>λΠ</code>。不过，前提是你喜欢那种生活方式。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:set prompt <span class="string">"λ: "</span></span><br><span class="line">:set prompt <span class="string">"ΠΣ: "</span></span><br></pre></td></tr></table></figure></p>
<h4 id="GHCi-Performance-性能"><a href="#GHCi-Performance-性能" class="headerlink" title="GHCi Performance(性能)"></a>GHCi Performance(性能)</h4><p>对于大型项目，带有默认标志的<code>GHCi</code>可以使用相当多的内存，并且需要很长时间来编译。为了通过保留编译模块的工件来加速编译，我们可以启用目标代码编译而不是字节码。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set -fobject-code</span><br></pre></td></tr></table></figure></p>
<p>启用目标代码编译可能会使类型推断复杂化，因为提供给外壳的类型信息有时可能比源代码加载的代码少。这种特殊性可能会导致某些语言扩展的损坏。在这种情况下，您可以使用<code>-fbyte-code</code>标志在每个模块的基础上临时重新启用字节码编译。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:set -fbyte-code</span><br><span class="line">:load <span class="type">MyModule</span>.hs</span><br></pre></td></tr></table></figure></p>
<p>如果您只需要在交互式外壳中对代码进行类型检查，则完全禁用代码生成将使重新加载代码几乎是瞬间的:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set -fno-code</span><br></pre></td></tr></table></figure></p>
<h3 id="Editor-Integration"><a href="#Editor-Integration" class="headerlink" title="Editor Integration"></a>Editor Integration</h3><p><code>Haskell</code>有多种编辑器工具，可用于提供交互式开发反馈和功能，如查询子表达式的类型、<code>linting</code>、类型检查和代码完成。</p>
<p>存在几个预先打包的设置，以加快设置<code>Haskell</code>开发的许多程序员编辑器的过程。特别是，使用<a href="http://www.mew.org/~kazu/proj/ghc-mod/en/" target="_blank" rel="noopener">ghc mod</a>可以显著提高程序员的效率和生产力，因为该项目试图实现现代<code>ide</code>的通用特性。</p>
<h4 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h4><ul>
<li><a href="https://github.com/begriffs/haskell-vim-now" target="_blank" rel="noopener">haskell-vim-now</a></li>
<li><a href="http://www.stephendiehl.com/posts/vim_2016.html" target="_blank" rel="noopener">Vim and Haskell in 2016</a></li>
</ul>
<h4 id="Emacs"><a href="#Emacs" class="headerlink" title="Emacs"></a>Emacs</h4><ul>
<li><a href="https://github.com/chrisdone/chrisdone-emacs" target="_blank" rel="noopener">Chris Done’s Emacs Config</a></li>
<li><a href="http://tim.dysinger.net/posts/2014-02-18-haskell-with-emacs.html" target="_blank" rel="noopener">Haskell Development From Emacs</a></li>
<li><a href="https://github.com/chrisdone/structured-haskell-mode" target="_blank" rel="noopener">Structured Haskell Mode</a></li>
</ul>
<h4 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h4><ul>
<li><a href="https://atom.io/packages/language-haskell" target="_blank" rel="noopener">language-haskell plugin</a></li>
<li><a href="https://atom.io/packages/ide-haskell" target="_blank" rel="noopener">ide-haskell plugin</a></li>
</ul>
<h3 id="Bottoms"><a href="#Bottoms" class="headerlink" title="Bottoms"></a>Bottoms</h3><p><code>Bottoms</code>是每个类型都存在的奇特值。评估此值时，<code>Haskell</code>的语义不再产生有意义的值。换句话说，无法在<code>Haskell</code>中定义对该值的进一步操作。<code>bottom</code>值通常写为符号<a href="https://en.wikipedia.org/wiki/Up_tack" target="_blank" rel="noopener">⊥</a>(即<code>the compiler flipping you off</code>)。 存在几种表示<code>Haskell</code>代码<code>bottoms</code>的方法。<br>例如，<code>undefined</code>是一个<code>bottom</code>值的简单例子。该函数具有类型<code>a</code>，但其类型签名中没有任何类型约束。因此，<code>undefined</code>可以代表函数体中的任何类型，即使函数不完整或完全缺少定义，也可以使类型检查成功。<code>undefined</code>功能对于调试或容纳编写不完整的程序非常实用。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">undefined</span> :: a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">mean</span> :: <span class="type">Num</span> a =&gt; <span class="type">Vector</span> a -&gt; a</span><br><span class="line"><span class="title">mean</span> nums = (total / count) <span class="keyword">where</span>  <span class="comment">-- 部分定义的功能</span></span><br><span class="line">              total = undefined</span><br><span class="line">              count = undefined</span><br><span class="line"></span><br><span class="line"><span class="title">addThreeNums</span> :: <span class="type">Num</span> a =&gt; a -&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">addThreeNums</span> n m j = undefined    <span class="comment">-- 根本没有声明函数体</span></span><br><span class="line"></span><br><span class="line"><span class="title">f</span> :: a -&gt; <span class="type">Complicated</span> <span class="type">Type</span></span><br><span class="line"><span class="title">f</span> = undefined   <span class="comment">-- 明天写，今天类型检查！欢迎任意复杂的类型！</span></span><br></pre></td></tr></table></figure></p>
<p><code>bottom</code>值的另一个示例来自对<code>error</code>函数的求值，该函数接受<code>String</code>并返回可以是任何类型的东西。这个属性非常类似于<code>undefined</code>，它也可以代表任何类型。</p>
<p>在函数中调用<code>error</code>会导致编译器引发异常，停止程序并打印指定的错误消息。<br>在下面的<code>divByY</code>函数中，将<code>0</code>用作除数会导致此函数导致此类异常。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 接收String类型的错误消息并返回所需的任何类型</span></span><br><span class="line"><span class="title">error</span> :: <span class="type">String</span> -&gt; a</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 带注释的代码，具有使用`error`函数的函數。</span></span><br><span class="line"></span><br><span class="line"><span class="title">divByY</span>:: (<span class="type">Num</span> a, <span class="type">Eq</span> a, <span class="type">Fractional</span> a) =&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">divByY</span> _ <span class="number">0</span> = error <span class="string">"Divide by zero error"</span>      <span class="comment">-- Dividing by 0 causes an error</span></span><br><span class="line"><span class="title">divByY</span> dividend divisor = dividend / divisor   <span class="comment">-- Handles defined division</span></span><br></pre></td></tr></table></figure></p>
<p>表示<code>bottom</code>的第三种方式是使用无限循环项:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: a</span><br><span class="line"><span class="title">f</span> = <span class="keyword">let</span> x = x <span class="keyword">in</span> x</span><br></pre></td></tr></table></figure></p>
<p>使用此循环语法的实际<code>Haskell</code>代码示例包含在<a href="https://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/GHC-Prim.html" target="_blank" rel="noopener">GHC.Prim</a>模块的源代码中。</p>
<p>存在这些<code>bottom</code>是因为无法在<a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/primitives.html" target="_blank" rel="noopener">native Haskell</a>中定义操作。这些操作以非常低的级别被<code>baked</code>(烘焙)到编译器中。</p>
<p>但是，存在此模块是为了使<a href="http://dev.stephendiehl.com/hask/#haddock" target="_blank" rel="noopener">Haddock</a>可以为这些<code>primitive</code>(原始)操作生成文档，而循环语法充当<code>primops</code>实际实现的占位符。</p>
<p><code>bottom</code>最常见的介绍可能是编写未定义<a href="http://dev.stephendiehl.com/hask/#exhaustiveness" target="_blank" rel="noopener">详尽</a>模式匹配的部分函数。例如，以下代码具有非穷尽的模式匹配，因为<code>case</code>表达式缺少对<code>B</code>的处理方式的定义：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">F</span> = <span class="type">A</span> | <span class="type">B</span></span></span><br><span class="line"><span class="title">case</span> x <span class="keyword">of</span></span><br><span class="line">  <span class="type">A</span> -&gt; ()</span><br></pre></td></tr></table></figure></p>
<p>上面的代码段被转换为以下<a href="http://dev.stephendiehl.com/hask/#code" target="_blank" rel="noopener">GHC Core</a>输出。编译器插入异常以说明<code>non-exhaustive</code>(非穷举)模式:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">case</span> x <span class="keyword">of</span> _ &#123;</span><br><span class="line">  <span class="type">A</span> -&gt; ();</span><br><span class="line">  <span class="type">B</span> -&gt; patError <span class="string">"&lt;interactive&gt;:3:11-31|case"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>-fwarn-incomplete-patterns</code>和<code>-fwarn-incomplete-uni-patterns</code>标志可以使<code>GHC</code>对不完整的模式更加清晰。</p>
<p><code>Record</code>也会出现类似情况。尽管构建缺少字段的<code>Record</code>很少有用，但仍然可以实现。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Foo</span> = <span class="type">Foo</span> &#123; <span class="title">example1</span> :: <span class="type">Int</span> &#125;</span></span><br><span class="line"><span class="title">f</span> = <span class="type">Foo</span> &#123;&#125;  <span class="comment">-- 定义缺少字段的Record</span></span><br></pre></td></tr></table></figure></p>
<p>当开发人员忽略字段的定义时，编译器将在<code>GHC Core</code>表示中插入一个异常:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Foo</span> (recConError <span class="string">"&lt;interactive&gt;:4:9-12|a"</span>)</span><br></pre></td></tr></table></figure></p>
<p>幸运的是，<code>GHC</code>默认会警告我们有关缺少<code>Record</code>字段的信息。</p>
<p><code>bottom</code>在整个<a href="http://dev.stephendiehl.com/hask/#prelude" target="_blank" rel="noopener">Prelude</a>中被广泛使用，尽管这一事实可能不会立即显现出来。包括<code>bottom</code>在内的原因是实践性的或历史性的。</p>
<p>典型的例子是<code>head</code>函数，它的类型是<code>[a] -&gt; a</code>。如果没有<code>bottom</code>，这个函数的类型就是不好的。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GHC.Err</span><br><span class="line"><span class="keyword">import</span> Prelude <span class="keyword">hiding</span> (<span class="title">head</span>, (!!), undefined)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- degenerate(退化) functions</span></span><br><span class="line"></span><br><span class="line"><span class="title">undefined</span> :: a</span><br><span class="line"><span class="title">undefined</span> = error <span class="string">"Prelude.undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="title">head</span> :: [a] -&gt; a</span><br><span class="line"><span class="title">head</span> (x:_) =  x</span><br><span class="line"><span class="title">head</span> []    =  error <span class="string">"Prelude.head: empty list"</span></span><br><span class="line"></span><br><span class="line">(!!) :: [a] -&gt; <span class="type">Int</span> -&gt; a</span><br><span class="line"><span class="title">xs</span>     !! n | n &lt; <span class="number">0</span> =  error <span class="string">"Prelude.!!: negative index"</span></span><br><span class="line">[]     !! _         =  error <span class="string">"Prelude.!!: index too large"</span></span><br><span class="line">(x:_)  !! <span class="number">0</span>         =  x</span><br><span class="line">(_:xs) !! n         =  xs !! (n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p>
<p>在生产代码中很少看到这些不小心抛出的部分函数，因为它们会导致程序停止。处理异常的首选方法是结合使用<code>Data.Maybe</code>中提供的安全变体和常用的折叠函数<code>maybe</code>和<code>any</code>.<br>另一种方法是使用模式匹配，如<code>listToMaybe</code>中所示，这是<code>head</code>的更安全版本，如下所述:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">listToMaybe</span> :: [a] -&gt; <span class="type">Maybe</span> a</span><br><span class="line"><span class="title">listToMaybe</span> []     =  <span class="type">Nothing</span></span><br><span class="line"><span class="title">listToMaybe</span> (a:_)  =  <span class="type">Just</span> a</span><br></pre></td></tr></table></figure></p>
<p>调用根据<code>error</code>定义的<code>bottom</code>通常不会生成任何位置信息。<br>但是，用于提供断言的<code>assert</code>可以被短路以生成位置信息，以代替<code>undefined</code>或<code>error</code>调用。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GHC.Base</span><br><span class="line"></span><br><span class="line"><span class="title">foo</span> :: a</span><br><span class="line"><span class="title">foo</span> = undefined</span><br><span class="line"><span class="comment">-- *** Exception: Prelude.undefined</span></span><br><span class="line"></span><br><span class="line"><span class="title">bar</span> :: a</span><br><span class="line"><span class="title">bar</span> = assert <span class="type">False</span> undefined</span><br><span class="line"><span class="comment">-- *** Exception: src/fail.hs:8:7-12: Assertion failed</span></span><br></pre></td></tr></table></figure></p>
<p>請看:</p>
<ul>
<li><a href="https://wiki.haskell.org/Avoiding_partial_functions" target="_blank" rel="noopener">Avoiding Partial Functions</a></li>
</ul>
<h3 id="Exhaustiveness-穷举"><a href="#Exhaustiveness-穷举" class="headerlink" title="Exhaustiveness(穷举)"></a>Exhaustiveness(穷举)</h3><p><code>Haskell</code>中的模式匹配允许使用<code>non-exhaustive</code>(非穷尽)模式。<br>例如，将<code>Nothing</code>传递给<code>unsafe</code>将导致程序在运行时崩溃。但是，此函數是其他有效的类型检查程序。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">unsafe</span> :: <span class="type">Num</span> a =&gt; <span class="type">Maybe</span> a -&gt; <span class="type">Maybe</span> a</span><br><span class="line"><span class="title">unsafe</span> (<span class="type">Just</span> x) = <span class="type">Just</span> $ x + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>由于<code>unsafe</code>以<code>Maybe a</code>值作为参数，因此有两个可能的值是有效输入: <code>Nothing</code>和<code>Just a</code>.<br>由于<code>unsafe</code>中没有定义<code>Nothing</code>的情况，我们认为该函数中的模式匹配是非穷尽的。换句话说，函数没有实现对所有有效输入的适当处理。这样的函数将停止不完全匹配，而不是产生值。</p>
<p>非穷举的部分函数是一个有争议的话题，频繁使用非穷举模式被认为是一种危险的代码气味。<br>然而，从语言中完全删除非穷尽模式本身就过于严格，并且禁止太多有效的程序。</p>
<p>存在几个标志，我们可以传递给编译器以向我们警告此类模式，或者在本地或全局范围内完全禁止它们。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ghc -c -<span class="type">Wall</span> -<span class="type">Werror</span> <span class="type">A</span>.hs</span><br><span class="line"><span class="type">A</span>.hs:<span class="number">3</span>:<span class="number">1</span>:</span><br><span class="line">    <span class="type">Warning</span>: <span class="type">Pattern</span> match(es) are non-exhaustive</span><br><span class="line">             <span class="type">In</span> an equation for `<span class="keyword">unsafe</span>': <span class="type">Patterns</span> not matched: <span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p><code>-Wall</code>或<code>-fwarn-incomplete-patterns</code>标志也可以通过使用<code>OPTIONS_GHC</code><a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/pragmas.html" target="_blank" rel="noopener">编译指示</a>按模块添加。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# OPTIONS_GHC -Wall #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# OPTIONS_GHC -fwarn-incomplete-patterns #-&#125;</span></span><br></pre></td></tr></table></figure>
<p>一个更微妙的<code>non-exhaustivity</code>例子是使用隐式模式匹配<code>lambda</code>表达式中的单个<code>uni pattern</code>。<br>与上面的<code>unsafe</code>函数类似，<code>uni pattern</code>无法处理所有类型的有效输入。例如，即使<code>lambda</code>表达式的参数类型是<code>Maybe a</code>，但当给定<code>Nothing</code>时，<code>boom</code>函数将失败。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">boom</span> = \(<span class="type">Just</span> a) -&gt; something</span><br></pre></td></tr></table></figure></p>
<p><code>lambda</code>表达式中的<code>uni patterns</code>引起的<code>non-exhaustivity</code>(非穷尽)性经常出现在脫糖后的<code>let</code>或<code>do blocks</code>中，因为这类代码被转换成类似于<code>boom</code>的<code>lambda</code>表达式。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">boom2</span> = <span class="keyword">let</span></span><br><span class="line">  <span class="type">Just</span> a = something</span><br><span class="line"></span><br><span class="line"><span class="title">boom3</span> = <span class="keyword">do</span></span><br><span class="line">  <span class="type">Just</span> a &lt;- something</span><br></pre></td></tr></table></figure></p>
<p><code>GHC</code>可以使用<code>-fwarn-incomplete-uni-patterns</code>标志来警告这些<code>non-exhaustivity</code>(非穷举)性情况。</p>
<p>概括地说，任何非平凡的程序都会使用某种程度的部分函数。这只是事实。 因此，对于程序员而言，存在着比在<code>Haskell</code>类型系统中无法体现的义务。</p>
<h3 id="Debugger"><a href="#Debugger" class="headerlink" title="Debugger"></a>Debugger</h3><p>从<a href="http://dev.stephendiehl.com/hask/#ghci" target="_blank" rel="noopener">GHCi</a>版本6.8.1开始，内置<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-debugger.html" target="_blank" rel="noopener">调试器</a>已经可用，尽管很少使用。从底部调试未捕获的异常或异步异常的方式类似于使用<code>gdb</code>调试<code>segfault</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">λ: :set -fbreak-on-exception  <span class="comment">-- 设置评估选项以在异常情况下停止</span></span><br><span class="line">λ: :break <span class="number">2</span> <span class="number">15</span>                <span class="comment">-- 在第2行第15列设置一个断点</span></span><br><span class="line">λ: :trace main                <span class="comment">-- 运行一个函数以生成一系列评估步骤</span></span><br><span class="line">λ: :hist                      <span class="comment">-- 从断点處后退到先前的评估步骤</span></span><br><span class="line">λ: :back                      <span class="comment">-- 根據历史记录一步步後退</span></span><br><span class="line">λ: :forward                   <span class="comment">-- 根據历史记录一步步向前</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Stack-Traces-堆栈跟踪"><a href="#Stack-Traces-堆栈跟踪" class="headerlink" title="Stack Traces(堆栈跟踪)"></a>Stack Traces(堆栈跟踪)</h3><p>启用<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html" target="_blank" rel="noopener">运行时分析</a>后，<code>GHC</code>还可以在<code>hit</code>(遇到/命中)<code>diverging</code>发散<code>bottom term</code>(底部项)(<code>error</code>，<code>undefined</code>)时打印堆栈跟踪,不过，此操作需要启用一个特殊标志和<code>profiling</code>(配置)，这两个功能在默认情况下都是禁用的。例如：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Exception</span><br><span class="line"></span><br><span class="line"><span class="title">f</span> x = g x</span><br><span class="line"></span><br><span class="line"><span class="title">g</span> x = error (show x)</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = try (evaluate (f ())) :: <span class="type">IO</span> (<span class="type">Either</span> <span class="type">SomeException</span> ())</span><br><span class="line">$ ghc -<span class="type">O0</span> -rtsopts=all -prof -auto-all <span class="comment">--make stacktrace.hs</span></span><br><span class="line">./stacktrace +<span class="type">RTS</span> -xc</span><br></pre></td></tr></table></figure></p>
<p>实际上，运行时告诉我们该异常发生在函数<code>g</code>中，并枚举了调用堆栈。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*** <span class="type">Exception</span> (reporting due to +<span class="type">RTS</span> -xc): (<span class="type">THUNK_2_0</span>), stack trace:</span><br><span class="line">  <span class="type">Main</span>.g,</span><br><span class="line">  called from <span class="type">Main</span>.f,</span><br><span class="line">  called from <span class="type">Main</span>.main,</span><br><span class="line">  called from <span class="type">Main</span>.<span class="type">CAF</span></span><br><span class="line">  <span class="comment">--&gt; evaluated by: Main.main,</span></span><br><span class="line">  called from <span class="type">Main</span>.<span class="type">CAF</span></span><br></pre></td></tr></table></figure></p>
<p>最好在不应用<code>-O0</code>优化的情况下运行此代码，以保留源代码中表示的原始调用堆栈。通过应用优化，<code>GHC</code>将以非常激烈的方式重新安排程序，从而导致完全不同的调用堆栈。<br>請看:</p>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime-control.html#idp13041968" target="_blank" rel="noopener">xc flag</a></li>
</ul>
<h3 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h3><p>由于<code>Haskell</code>是一种<a href="http://dev.stephendiehl.com/fun/000_introduction.html#functional-languages" target="_blank" rel="noopener">纯语言</a>，所以它有一个独特的特性，即大多数代码都可以自己进行内省。<br>因此，在整个执行过程中，使用<a href="https://www.codingunit.com/printf-format-specifiers-format-conversions-and-formatted-output" target="_blank" rel="noopener">printf</a>来显示程序在关键时刻的状态通常是不必要的，因为我们可以简单地打开<a href="http://dev.stephendiehl.com/hask/#ghci" target="_blank" rel="noopener">GHCi</a>并测试函数。<br>不过，<code>Haskell</code>确实附带了一个不安全的跟踪函数，可以用来在<code>IO monad</code>之外执行任意打印语句。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Debug.Trace</span><br><span class="line"></span><br><span class="line"><span class="comment">-- trace :: String -&gt; a -&gt; a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- traceShow :: Show a =&gt; a -&gt; b -&gt; b</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">example1</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">example1</span> = trace <span class="string">"impure print"</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="title">example2</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">example2</span> = traceShow <span class="string">"tracing"</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="title">example3</span> :: [<span class="type">Int</span>]</span><br><span class="line"><span class="title">example3</span> = [trace <span class="string">"will not be called"</span> <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  print example1</span><br><span class="line">  print example2</span><br><span class="line">  print $ length example3</span><br><span class="line"><span class="comment">-- impure print</span></span><br><span class="line"><span class="comment">-- 1</span></span><br><span class="line"><span class="comment">-- "tracing"</span></span><br><span class="line"><span class="comment">-- 2</span></span><br><span class="line"><span class="comment">-- 1</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Trace在后台使用unsafePerformIO，因此不应在稳定的代码中使用。</p>
</blockquote>
<p>除了<code>trace</code>函數外，还有几种单子<code>trace</code>变量也很常见:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Text.Printf</span><br><span class="line"><span class="keyword">import</span> Debug.Trace</span><br><span class="line"></span><br><span class="line"><span class="title">traceM</span> :: (<span class="type">Monad</span> m) =&gt; <span class="type">String</span> -&gt; m ()</span><br><span class="line"><span class="title">traceM</span> string = trace string $ return ()</span><br><span class="line"></span><br><span class="line"><span class="title">traceShowM</span> :: (<span class="type">Show</span> a, <span class="type">Monad</span> m) =&gt; a -&gt; m ()</span><br><span class="line"><span class="title">traceShowM</span> = traceM . show</span><br><span class="line"></span><br><span class="line"><span class="comment">-- printf :: PrintfType r =&gt; String -&gt; r</span></span><br><span class="line"></span><br><span class="line"><span class="title">tracePrintfM</span> :: (<span class="type">Monad</span> m, <span class="type">PrintfArg</span> a) =&gt; <span class="type">String</span> -&gt; a -&gt; m ()</span><br><span class="line"><span class="title">tracePrintfM</span> s = traceM . printf s</span><br></pre></td></tr></table></figure></p>
<h3 id="Type-Inference-类型推断"><a href="#Type-Inference-类型推断" class="headerlink" title="Type Inference(类型推断)"></a>Type Inference(类型推断)</h3><p>虽然通常可以完成<code>Haskell</code>的推断，但在某些情况下无法推断主体类型。三种常见情况是:</p>
<ul>
<li>由于相互递归的綁定組，<code>Reduced</code>(降低)了多态性</li>
<li>由于多态递归导致的不确定性</li>
<li>由于单态性限制，<code>Reduced</code>(降低)了多态性</li>
</ul>
<p>在每种情况下，<code>Haskell</code>都需要程序员的提示，可以通过添加显式类型签名来提供提示。</p>
<h4 id="Mutually-Recursive-Binding-Groups-相互递归绑定组"><a href="#Mutually-Recursive-Binding-Groups-相互递归绑定组" class="headerlink" title="Mutually Recursive Binding Groups(相互递归绑定组)"></a>Mutually Recursive Binding Groups(相互递归绑定组)</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> x = const x g</span><br><span class="line"><span class="title">g</span> y = f '<span class="type">A'</span></span><br></pre></td></tr></table></figure>
<p>推断出的类型签名在<code>usage</code>(用法)上是正确的，但并不代表最通用的签名。当<code>GHC</code>分析模块时，它会分析表达式之间的依赖关系，将它们分组在一起，并在相互定义的组之间应用统一的替换。因此，推断的类型可能不是最<code>general</code>(通用)的类型，因此可能需要显式签名。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Inferred types 推断类型</span></span><br><span class="line"><span class="title">f</span> :: <span class="type">Char</span> -&gt; <span class="type">Char</span></span><br><span class="line"><span class="title">g</span> :: t -&gt; <span class="type">Char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 最通用的类型</span></span><br><span class="line"><span class="title">f</span> :: a -&gt; a</span><br><span class="line"><span class="title">g</span> :: a -&gt; <span class="type">Char</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Polymorphic-recursion-多态递归"><a href="#Polymorphic-recursion-多态递归" class="headerlink" title="Polymorphic recursion(多态递归)"></a>Polymorphic recursion(多态递归)</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">Leaf</span> | <span class="type">Bin</span> a (<span class="type">Tree</span> (<span class="title">a</span>, <span class="title">a</span>))</span></span><br><span class="line"></span><br><span class="line"><span class="title">size</span> <span class="type">Leaf</span> = <span class="number">0</span></span><br><span class="line"><span class="title">size</span> (<span class="type">Bin</span> _ t) = <span class="number">1</span> + <span class="number">2</span> * size t</span><br></pre></td></tr></table></figure>
<p>递归是多态的，因为在<code>size</code>中推断出的类型变量<code>a</code>跨越两种可能的类型(<code>a</code>和<code>(a，a)</code>).<br>这两种类型不会通过类型检查器的<code>occurs-check</code>，并且会产生不正确的推断类型。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Occurs</span> check: cannot construct the infinite <span class="class"><span class="keyword">type</span>: t0 = (<span class="title">t0</span>, <span class="title">t0</span>)</span></span><br><span class="line"><span class="type">Expected</span> <span class="class"><span class="keyword">type</span>: <span class="type">Tree</span> t0</span></span><br><span class="line">  <span class="type">Actual</span> <span class="class"><span class="keyword">type</span>: <span class="type">Tree</span> (<span class="title">t0</span>, <span class="title">t0</span>)</span></span><br><span class="line"><span class="type">In</span> the first argument <span class="keyword">of</span> `size', namely `t'</span><br><span class="line"><span class="type">In</span> the second argument <span class="keyword">of</span> `(*)', namely `size t'</span><br><span class="line"><span class="type">In</span> the second argument <span class="keyword">of</span> `(+)', namely `<span class="number">2</span> * size t'</span><br></pre></td></tr></table></figure></p>
<p>简单地添加一个显式类型签名就可以解决这个问题。在一般情况下，使用多态递归的类型推断是不可判定的。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">size</span> :: <span class="type">Tree</span> a -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">size</span> <span class="type">Leaf</span> = <span class="number">0</span></span><br><span class="line"><span class="title">size</span> (<span class="type">Bin</span> _ t) = <span class="number">1</span> + <span class="number">2</span> * size t</span><br></pre></td></tr></table></figure></p>
<p>請看:</p>
<ul>
<li><a href="https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-880004.5" target="_blank" rel="noopener">Static Semantics of Function and Pattern Bindings</a>(函數和模式绑定的静态语义)</li>
</ul>
<h4 id="Monomorphism-Restriction-单态限制"><a href="#Monomorphism-Restriction-单态限制" class="headerlink" title="Monomorphism Restriction(单态限制)"></a>Monomorphism Restriction(单态限制)</h4><p>单态性限制是一个有争议的类型规则。 默认情况下，它在编译时处于打开状态，而在<code>GHCi</code>中处于关闭状态。该规则的实际效果是，为没有显式类型签名的函数推断的类型可能比预期的更<code>specific</code>(具体/明確)。</p>
<p>这是因为<code>GHC</code>有时会将<code>general</code>(一般)类型(例如<code>Num</code>)减少为默认类型(例如<code>Double</code>)。在<code>GHCi</code>中的以下示例中可以看出:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">λ: :set +t</span><br><span class="line"></span><br><span class="line">λ: <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="title">it</span> :: <span class="type">Num</span> a =&gt; a</span><br><span class="line"></span><br><span class="line">λ: <span class="keyword">default</span> (<span class="type">Double</span>)</span><br><span class="line"></span><br><span class="line">λ: <span class="number">3</span></span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="title">it</span> :: <span class="type">Num</span> a =&gt; a</span><br></pre></td></tr></table></figure></p>
<p>可以使用<code>NoMonomorphicRestriction</code>扩展来禁用此规则，请参见<a href="http://dev.stephendiehl.com/hask/#nomonomorphicrestriction" target="_blank" rel="noopener">下文</a>。</p>
<p>請看:</p>
<ul>
<li><a href="https://wiki.haskell.org/Monomorphism_restriction" target="_blank" rel="noopener">Monomorphism Restriction</a>(单态限制)</li>
</ul>
<h3 id="Type-Holes-Pattern-Wildcards"><a href="#Type-Holes-Pattern-Wildcards" class="headerlink" title="Type Holes / Pattern Wildcards"></a>Type Holes / Pattern Wildcards</h3><p>自<code>GHC 7.8</code>发布以来，类型孔或模式通配符，允许使用下划线作为实际值的替代。它们可以在声明或类型签名中使用。</p>
<p>类型孔对于调试不完整的程序很有用。通过在声明右侧的任何值上加一个下划线，<code>GHC</code>将在类型检查期间引发错误。错误消息描述了哪些值可以合法填充类型孔。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">head'</span> = head _</span><br><span class="line"><span class="title">typedhole</span>.hs:<span class="number">3</span>:<span class="number">14</span>: error:</span><br><span class="line">    • <span class="type">Found</span> hole: _ :: [a]</span><br><span class="line">      <span class="type">Where</span>: ‘a’ is a rigid <span class="class"><span class="keyword">type</span> variable bound by</span></span><br><span class="line">               the inferred <span class="class"><span class="keyword">type</span> of head' :: a at typedhole.hs:3:1</span></span><br><span class="line">    • <span class="type">In</span> the first argument <span class="keyword">of</span> ‘head’, namely ‘_’</span><br><span class="line">      <span class="type">In</span> the expression: head _</span><br><span class="line">      <span class="type">In</span> an equation for ‘head'’: head' = head _</span><br><span class="line">    • <span class="type">Relevant</span> bindings include head' :: a (bound at typedhole.hs:<span class="number">3</span>:<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p><code>GHC</code>正确地建议完成程序所需的表达式是<code>xs :: [a]</code>.<br>同样的孔技术可以应用于顶级签名:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">const'</span> :: _</span><br><span class="line"><span class="title">const'</span> x y = x</span><br><span class="line"><span class="title">typedhole</span>.hs:<span class="number">5</span>:<span class="number">11</span>: error:</span><br><span class="line">    • <span class="type">Found</span> <span class="class"><span class="keyword">type</span> wildcard ‘_’ standing for ‘t -&gt; t1 -&gt; t’</span></span><br><span class="line">      <span class="type">Where</span>: ‘t1’ is a rigid <span class="class"><span class="keyword">type</span> variable bound by</span></span><br><span class="line">               the inferred <span class="class"><span class="keyword">type</span> of const' :: t -&gt; t1 -&gt; t at typedhole.hs:6:1</span></span><br><span class="line">             ‘t’ is a rigid <span class="class"><span class="keyword">type</span> variable bound by</span></span><br><span class="line">               the inferred <span class="class"><span class="keyword">type</span> of const' :: t -&gt; t1 -&gt; t at typedhole.hs:6:1</span></span><br><span class="line">      <span class="type">To</span> use the inferred <span class="class"><span class="keyword">type</span>, enable <span class="type">PartialTypeSignatures</span></span></span><br><span class="line">    • <span class="type">In</span> the <span class="class"><span class="keyword">type</span> signature:</span></span><br><span class="line">        const' :: _</span><br><span class="line">    • <span class="type">Relevant</span> bindings include</span><br><span class="line">        const' :: t -&gt; t1 -&gt; t (bound at typedhole.hs:<span class="number">6</span>:<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>还可以为模式通配符指定显式名称，以便<code>GHC</code>在报告结果消息中的推断类型时使用。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> :: _a -&gt; _a</span><br><span class="line"><span class="title">foo</span> _ = <span class="type">False</span></span><br><span class="line"><span class="title">typedhole</span>.hs:<span class="number">9</span>:<span class="number">9</span>: error:</span><br><span class="line">    • <span class="type">Couldn't</span> match expected <span class="class"><span class="keyword">type</span> ‘_a’ with actual <span class="keyword">type</span> ‘<span class="type">Bool</span>’</span></span><br><span class="line">      ‘_a’ is a rigid <span class="class"><span class="keyword">type</span> variable bound by</span></span><br><span class="line">        the <span class="class"><span class="keyword">type</span> signature for:</span></span><br><span class="line">          foo :: <span class="keyword">forall</span> _a. _a -&gt; _a</span><br><span class="line">        at typedhole.hs:<span class="number">8</span>:<span class="number">8</span></span><br><span class="line">    • <span class="type">In</span> the expression: <span class="type">False</span></span><br><span class="line">      <span class="type">In</span> an equation for ‘foo’: foo _ = <span class="type">False</span></span><br><span class="line">    • <span class="type">Relevant</span> bindings include</span><br><span class="line">        foo :: _a -&gt; _a (bound at typedhole.hs:<span class="number">9</span>:<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>可以在类型上下文中使用相同的通配符来<code>dump out</code>(转出)推断的类型类约束：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">succ'</span> :: _ =&gt; a -&gt; a</span><br><span class="line"><span class="title">succ'</span> x = x + <span class="number">1</span></span><br><span class="line"><span class="title">typedhole</span>.hs:<span class="number">11</span>:<span class="number">10</span>: error:</span><br><span class="line">    <span class="type">Found</span> constraint wildcard ‘_’ standing for ‘<span class="type">Num</span> a’</span><br><span class="line">    <span class="type">To</span> use the inferred <span class="class"><span class="keyword">type</span>, enable <span class="type">PartialTypeSignatures</span></span></span><br><span class="line">    <span class="type">In</span> the <span class="class"><span class="keyword">type</span> signature:</span></span><br><span class="line">      succ' :: _ =&gt; a -&gt; a</span><br></pre></td></tr></table></figure></p>
<p>当将标志<code>-XPartialTypeSignatures</code>传递给<code>GHC</code>且推断的类型是明确的时，<code>GHC</code>将让我们保留这些空缺，然后进行编译。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">typedhole</span>.hs:<span class="number">3</span>:<span class="number">10</span>: <span class="type">Warning</span>:</span><br><span class="line">    <span class="type">Found</span> hole ‘_’ with <span class="class"><span class="keyword">type</span>: w_</span></span><br><span class="line">    <span class="type">Where</span>: ‘w_’ is a rigid <span class="class"><span class="keyword">type</span> variable bound by</span></span><br><span class="line">                the inferred <span class="class"><span class="keyword">type</span> of succ' :: w_ -&gt; w_1 -&gt; w_ at foo.hs:4:1</span></span><br><span class="line">    <span class="type">In</span> the <span class="class"><span class="keyword">type</span> signature for ‘succ'’: _ -&gt; _ -&gt; _</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Deferred-Type-Errors-延迟的类型错误"><a href="#Deferred-Type-Errors-延迟的类型错误" class="headerlink" title="Deferred Type Errors(延迟的类型错误)"></a>Deferred Type Errors(延迟的类型错误)</h3><p>自7.8版发布以来，<code>GHC</code>支持将类型错误视为运行时错误的选项。启用此选项后，程序将运行，但在评估输入错误的表达式时它们将失败。</p>
<p>使用<code>-fdefer-type-errors</code>标志以三种方式启用此功能: 在模块级别，从命令行编译时或在<code>GHCi</code>交互式会话内部。</p>
<p>例如，下面的程序将编译:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# OPTIONS_GHC -fdefer-type-errors #-&#125;</span> <span class="comment">-- 在模块级别启用延迟的类型错误</span></span><br><span class="line"></span><br><span class="line"><span class="title">x</span> :: ()</span><br><span class="line"><span class="title">x</span> = print <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="title">y</span> :: <span class="type">Char</span></span><br><span class="line"><span class="title">y</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="title">z</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">z</span> = <span class="number">0</span> + <span class="string">"foo"</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  print x</span><br></pre></td></tr></table></figure></p>
<p>但是，当在运行时评估病理学术语时，我们将看到类似以下的消息:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">defer</span>: defer.hs:<span class="number">4</span>:<span class="number">5</span>:</span><br><span class="line">    <span class="type">Couldn't</span> match expected <span class="class"><span class="keyword">type</span> ‘()’ with actual <span class="keyword">type</span> ‘<span class="type">IO</span> ()’</span></span><br><span class="line">    <span class="type">In</span> the expression: print <span class="number">3</span></span><br><span class="line">    <span class="type">In</span> an equation for ‘x’: x = print <span class="number">3</span></span><br><span class="line">(deferred <span class="class"><span class="keyword">type</span> error)</span></span><br></pre></td></tr></table></figure></p>
<p>该错误告诉我们，虽然<code>x</code>具有声明的类型<code>()</code>，但是函数<code>print 3</code>的主体具有<code>IO ()</code>类型。但是，如果从未对该术语进行评估，那麼<code>GHC</code>將不会抛出异常。</p>
<h3 id="ghcid"><a href="#ghcid" class="headerlink" title="ghcid"></a>ghcid</h3><p><a href="https://github.com/ndmitchell/ghcid" target="_blank" rel="noopener">ghcid</a>是一个轻量级的<code>IDE hook</code>，无论何时更新代码，它都可以提供持续的反馈。可以通过指定要运行的命令(例如<code>ghci</code>，<code>cabal repl</code>或<code>stack repl</code>)从<code>cabal</code>项目目录根目录中的命令行运行。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghcid</span> <span class="comment">--command="cabal repl"  # Run cabal repl under ghcid</span></span><br><span class="line"><span class="title">ghcid</span> <span class="comment">--command="stack repl"  # Run stack repl under ghcid</span></span><br><span class="line"><span class="title">ghcid</span> <span class="comment">--command="ghci baz.hs" # Open baz.hs under ghcid</span></span><br></pre></td></tr></table></figure></p>
<p>当将<code>Haskell</code>模块加载到<code>ghcid</code>中时，将对代码进行评估，以向用户提供在编译时可能发生的任何错误或警告。当开发人员编辑并保存加载到<code>ghcid</code>中的代码时，程序会自动重新加载并评估代码中的错误和警告。</p>
<h3 id="Haddock"><a href="#Haddock" class="headerlink" title="Haddock"></a>Haddock</h3><p><a href="https://www.haskell.org/haddock/#Overview" target="_blank" rel="noopener">Haddock</a>是<code>Haskell</code>源代码的自动文档生成工具。它与通常的<code>cabal</code>工具链集成在一起。在本节中，我们将探索如何编写代码文档，以便<code>Haddock</code>可以成功生成文档。</p>
<p>有几种常见的注释模式用于记录<code>Haddock</code>的代码。这些方法中的第一种使用<code>-|</code>来描述注释的开头:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- | Documentation for f</span></span><br><span class="line"><span class="title">f</span> :: a -&gt; a</span><br><span class="line"><span class="title">f</span> = ...</span><br></pre></td></tr></table></figure></p>
<p>多行注释也是可能的:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- | Multiline documentation for the function</span></span><br><span class="line"><span class="comment">-- f with multiple arguments.</span></span><br><span class="line"><span class="title">fmap</span> :: <span class="type">Functor</span> f =&gt;</span><br><span class="line">     =&gt; (a -&gt; b)  <span class="comment">-- ^ function</span></span><br><span class="line">     -&gt; f a       <span class="comment">-- ^ input</span></span><br><span class="line">     -&gt; f b       <span class="comment">-- ^ output</span></span><br></pre></td></tr></table></figure></p>
<p><code>-- ^</code>也用于注释构造函数或记录字段:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">T</span> a b</span></span><br><span class="line">  = <span class="type">A</span> a <span class="comment">-- ^ Documentation for A</span></span><br><span class="line">  | <span class="type">B</span> b <span class="comment">-- ^ Documentation for B</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">R</span> a b = <span class="type">R</span></span></span><br><span class="line">  &#123; f1 :: a <span class="comment">-- ^ Documentation for the field f1</span></span><br><span class="line">  , f2 :: b <span class="comment">-- ^ Documentation for the field f2</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过将标识符括在单引号中，可以超链接 模块(即<code>value</code>、<code>types</code>、<code>classes</code>)中的元素:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">T</span> a b</span></span><br><span class="line">  = <span class="type">A</span> a <span class="comment">-- ^ Documentation for 'A'</span></span><br><span class="line">  | <span class="type">B</span> b <span class="comment">-- ^ Documentation for 'B'</span></span><br></pre></td></tr></table></figure></p>
<p>可以通过将模块括在双引号中来引用模块本身:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- | Here we use the "Data.Text" library and import</span></span><br><span class="line"><span class="comment">-- the 'Data.Text.pack' function.</span></span><br></pre></td></tr></table></figure></p>
<p><code>haddock</code>还允许用户在生成的文档中包含代码块。<code>haddock</code>中存在两种划分代码块的方法。例如，用<code>@</code>符号括起来的代码段将其标记为代码块:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- | An example of a code block.</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- @</span></span><br><span class="line"><span class="comment">--    f x = f (f x)</span></span><br><span class="line"><span class="comment">-- @</span></span><br></pre></td></tr></table></figure></p>
<p>同样，可以在注释行中使用鸟形轨迹<code>(&gt;)</code>来設置代码块。这种用法与<code>Bird</code>风格的<a href="https://wiki.haskell.org/Literate_programming#Bird_Style" target="_blank" rel="noopener">Literate Haskell</a>非常相似。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- | A similar code block example that uses bird tracks (i.e. '&gt;')</span></span><br><span class="line"><span class="comment">-- &gt; f x = f (f x)</span></span><br></pre></td></tr></table></figure></p>
<p>交互式<code>shell</code>会话的片段也可以包含在<code>haddock</code>文档中。为了表示打算在<code>REPL</code>中运行的代码的开头，使用<code>&gt;&gt;&gt;</code>符号:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- | 嵌入文档中的交互式shell会话示例</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- &gt;&gt;&gt; factorial 5</span></span><br><span class="line"><span class="comment">-- 120</span></span><br></pre></td></tr></table></figure></p>
<p>可以通过在模块块中的注释前面加上<code>*</code>来添加特定块的标题:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Foo (</span><br><span class="line">  <span class="comment">-- * My Header</span></span><br><span class="line">  <span class="title">example1</span>,</span><br><span class="line">  <span class="title">example2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>也可以用与模块主体中的引用有关的<code>$</code>块来描述各章節:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Foo (</span><br><span class="line">  <span class="comment">-- $section1</span></span><br><span class="line">  <span class="title">example1</span>,</span><br><span class="line">  <span class="title">example2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- $section1</span></span><br><span class="line"><span class="comment">-- Here is the documentation section that describes the symbols</span></span><br><span class="line"><span class="comment">-- 'example1' and 'example2'.</span></span><br></pre></td></tr></table></figure></p>
<p>可以使用以下语法添加链接:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;url text&gt;</span><br></pre></td></tr></table></figure></p>
<p>只要路径是绝对路径或相对于运行<code>haddock</code>的目录的相对路径，也可以包含<code>image</code>.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;diagram.png title&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>haddock</code>选项也可以在源代码中用<code>pragmas</code>指定，无论是在模块级还是项目级.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# OPTIONS_HADDOCK show-extensions, ignore-exports #-&#125;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Option</span>	        <span class="type">Description</span></span><br><span class="line"><span class="comment">-------------------------------</span></span><br><span class="line"><span class="title">ignore</span>-exports    忽略导出列表，并包括作用域内的所有签名。</span><br><span class="line"><span class="title">not</span>-home          根文档中将不考虑模块。</span><br><span class="line"><span class="title">show</span>-extensions   使用所使用的语言扩展注释文档。</span><br><span class="line"><span class="title">hide</span>              强制从<span class="type">Haddock</span>隐藏该模块。</span><br><span class="line"><span class="title">prune</span>             省略没有注释的定义.</span><br></pre></td></tr></table></figure>
        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> thank you </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
        <span><a href="https://serokell.io/blog">serokell</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/blog/js/index.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--create by tea9-->

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <script>
        var gitalk = new Gitalk({
          clientID: '7cfc73dd62b57f07ed83',
          clientSecret: 'dd03b7e54aadf0d81e4c9c93e23a41272bcfcfa1',
          repo: 'hexo-blog',
          owner: 'limengyu1990',
          admin: 'limengyu1990',
          id: location.pathname,      // Ensure uniqueness and length less than 50
          distractionFreeMode: false  // Facebook-like distraction free mode
        })
        gitalk.render('comment-container')
    </script>

<!--end-->


</html>
