<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/blog/img/favicon.ico">

    <title>
        
        Haskell-Testing - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/aircloud.css">
    <link rel="stylesheet" href="/blog/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/blog/img/photo.png" />
        </div>
        <div class="name">
            <i>不负如来不负卿</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/blog/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/blog/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/blog/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/blog/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#QuickCheck"><span class="toc-text">QuickCheck</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SmallCheck"><span class="toc-text">SmallCheck</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QuickSpec"><span class="toc-text">QuickSpec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Criterion-标准"><span class="toc-text">Criterion(标准)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tasty"><span class="toc-text">Tasty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#silently"><span class="toc-text">silently</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 所有的善恶都是我，良心一路走来依旧清澈鲜活... </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Haskell-Testing
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-11-05 16:58:26</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/blog/tags/#Wish-Knew" title="Wish-Knew">Wish-Knew</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Haskell" title="Haskell">Haskell</a>
        <span>/</span>
        
        <a class="tag" href="/blog/tags/#Testing" title="Testing">Testing</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p><a href="http://dev.stephendiehl.com/hask/#testing" target="_blank" rel="noopener">原文</a></p>
</blockquote>
<p>与许多错误信息相反，<code>Haskell</code>中的单元测试非常常见和健壮。尽管一般来说，单元测试在<code>Haskell</code>中的重要性较低，因为类型系统使得大量的无效程序在构造时完全无法表达。<br>单元测试往往是在开发生命周期的后期编写的，通常是关于程序的核心逻辑的，而不是<code>intermediate plumbing</code>(中间管道)。</p>
<p>关于<code>Haskell</code>库设计的著名思想流派倾向于围绕以强大的方程定律为基础构建的程序，这些定律可保证在组合下程序行为具有强大的不变性。许多测试工具都是围绕这种设计风格构建的。</p>
<h3 id="QuickCheck"><a href="#QuickCheck" class="headerlink" title="QuickCheck"></a>QuickCheck</h3><p><code>QuickCheck</code>可能是最著名的<code>Haskell</code>库，它是一个测试框架，用于根据参数的类型自动为任意函数生成大型随机测试:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">quickCheck</span> :: <span class="type">Testable</span> prop =&gt; prop -&gt; <span class="type">IO</span> ()</span><br><span class="line">(==&gt;) :: <span class="type">Testable</span> prop =&gt; <span class="type">Bool</span> -&gt; prop -&gt; <span class="type">Property</span></span><br><span class="line"><span class="title">forAll</span> :: (<span class="type">Show</span> a, <span class="type">Testable</span> prop) =&gt; <span class="type">Gen</span> a -&gt; (a -&gt; prop) -&gt; <span class="type">Property</span></span><br><span class="line"><span class="title">choose</span> :: <span class="type">Random</span> a =&gt; (a, a) -&gt; <span class="type">Gen</span> a</span><br><span class="line"><span class="keyword">import</span> Test.QuickCheck</span><br><span class="line"></span><br><span class="line"><span class="title">qsort</span> :: [<span class="type">Int</span>] -&gt; [<span class="type">Int</span>]</span><br><span class="line"><span class="title">qsort</span> []     = []</span><br><span class="line"><span class="title">qsort</span> (x:xs) = qsort lhs ++ [x] ++ qsort rhs</span><br><span class="line">    <span class="keyword">where</span> lhs = filter  (&lt; x) xs</span><br><span class="line">          rhs = filter (&gt;= x) xs</span><br><span class="line"></span><br><span class="line"><span class="title">prop_maximum</span> ::  [<span class="type">Int</span>] -&gt; <span class="type">Property</span></span><br><span class="line"><span class="title">prop_maximum</span> xs = not (null xs) ==&gt;</span><br><span class="line">                  last (qsort xs) == maximum xs</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = quickCheck prop_maximum</span><br><span class="line">$ runhaskell qcheck.hs</span><br><span class="line">*** <span class="type">Failed</span>! <span class="type">Falsifiable</span> (after <span class="number">3</span> tests and <span class="number">4</span> shrinks):</span><br><span class="line">[<span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">$ runhaskell qcheck.hs</span><br><span class="line">+++ <span class="type">OK</span>, passed <span class="number">1000</span> tests.</span><br></pre></td></tr></table></figure>
<p>可以使用自定义类型扩展测试数据生成器，并使用限制要测试案例范围的谓词来完善测试数据生成器:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Test.QuickCheck</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Color</span> = <span class="type">Red</span> | <span class="type">Green</span> | <span class="type">Blue</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Arbitrary</span> <span class="type">Color</span> <span class="keyword">where</span></span></span><br><span class="line">  arbitrary = <span class="keyword">do</span></span><br><span class="line">    n &lt;- choose (<span class="number">0</span>,<span class="number">2</span>) :: <span class="type">Gen</span> <span class="type">Int</span></span><br><span class="line">    return $ <span class="keyword">case</span> n <span class="keyword">of</span></span><br><span class="line">      <span class="number">0</span> -&gt; <span class="type">Red</span></span><br><span class="line">      <span class="number">1</span> -&gt; <span class="type">Green</span></span><br><span class="line">      <span class="number">2</span> -&gt; <span class="type">Blue</span></span><br><span class="line"></span><br><span class="line"><span class="title">example1</span> :: <span class="type">IO</span> [<span class="type">Color</span>]</span><br><span class="line"><span class="title">example1</span> = sample' arbitrary</span><br><span class="line"><span class="comment">-- [Red,Green,Red,Blue,Red,Red,Red,Blue,Green,Red,Red]</span></span><br></pre></td></tr></table></figure></p>
<p>請看:</p>
<ul>
<li><a href="http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html" target="_blank" rel="noopener">QuickCheck: An Automatic Testing Tool for Haskell</a></li>
</ul>
<h3 id="SmallCheck"><a href="#SmallCheck" class="headerlink" title="SmallCheck"></a>SmallCheck</h3><p>与<code>QuickCheck</code>一样，<code>SmallCheck</code>是一个属性测试系统，但它不会生成随机的任意测试数据，而是枚举确定性的一系列测试数据到固定深度。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">smallCheck</span> :: <span class="type">Testable</span> <span class="type">IO</span> a =&gt; <span class="type">Depth</span> -&gt; a -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">list</span> :: <span class="type">Depth</span> -&gt; <span class="type">Series</span> <span class="type">Identity</span> a -&gt; [a]</span><br><span class="line"><span class="title">sample'</span> :: <span class="type">Gen</span> a -&gt; <span class="type">IO</span> [a]</span><br><span class="line">λ: list <span class="number">3</span> series :: [<span class="type">Int</span>]</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">3</span>,<span class="number">-3</span>]</span><br><span class="line"></span><br><span class="line">λ: list <span class="number">3</span> series :: [<span class="type">Double</span>]</span><br><span class="line">[<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">-1.0</span>,<span class="number">2.0</span>,<span class="number">0.5</span>,<span class="number">-2.0</span>,<span class="number">4.0</span>,<span class="number">0.25</span>,<span class="number">-0.5</span>,<span class="number">-4.0</span>,<span class="number">-0.25</span>]</span><br><span class="line"></span><br><span class="line">λ: list <span class="number">3</span> series :: [(<span class="type">Int</span>, <span class="type">String</span>)]</span><br><span class="line">[(<span class="number">0</span>,<span class="string">""</span>),(<span class="number">1</span>,<span class="string">""</span>),(<span class="number">0</span>,<span class="string">"a"</span>),(<span class="number">-1</span>,<span class="string">""</span>),(<span class="number">0</span>,<span class="string">"b"</span>),(<span class="number">1</span>,<span class="string">"a"</span>),(<span class="number">2</span>,<span class="string">""</span>),(<span class="number">1</span>,<span class="string">"b"</span>),(<span class="number">-1</span>,<span class="string">"a"</span>),(<span class="number">-2</span>,<span class="string">""</span>),(<span class="number">-1</span>,<span class="string">"b"</span>),(<span class="number">2</span>,<span class="string">"a"</span>),(<span class="number">-2</span>,<span class="string">"a"</span></span><br></pre></td></tr></table></figure>
<p>在一个程序的所有可能的输入上生成测试用例，直到一定深度是很有用的。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Test.SmallCheck</span><br><span class="line"></span><br><span class="line"><span class="title">distrib</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">distrib</span> a b c = a * (b + c) == a * b + a * c</span><br><span class="line"></span><br><span class="line"><span class="title">cauchy</span> :: [<span class="type">Double</span>] -&gt; [<span class="type">Double</span>] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">cauchy</span> xs ys = (abs (dot xs ys))^<span class="number">2</span> &lt;= (dot xs xs) * (dot ys ys)</span><br><span class="line"></span><br><span class="line"><span class="title">failure</span> :: [<span class="type">Double</span>] -&gt; [<span class="type">Double</span>] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">failure</span> xs ys = abs (dot xs ys) &lt;= (dot xs xs) * (dot ys ys)</span><br><span class="line"></span><br><span class="line"><span class="title">dot</span> :: <span class="type">Num</span> a =&gt; [a] -&gt; [a] -&gt; a</span><br><span class="line"><span class="title">dot</span> xs ys = sum (zipWith (*) xs ys)</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  putStrLn <span class="string">"Testing distributivity..."</span></span><br><span class="line">  smallCheck <span class="number">25</span> distrib</span><br><span class="line"></span><br><span class="line">  putStrLn <span class="string">"Testing Cauchy-Schwarz..."</span></span><br><span class="line">  smallCheck <span class="number">4</span> cauchy</span><br><span class="line"></span><br><span class="line">  putStrLn <span class="string">"Testing invalid Cauchy-Schwarz..."</span></span><br><span class="line">  smallCheck <span class="number">4</span> failure</span><br><span class="line">$ runhaskell smallcheck.hs</span><br><span class="line"><span class="type">Testing</span> distributivity...</span><br><span class="line"><span class="type">Completed</span> <span class="number">132651</span> tests without failure.</span><br><span class="line"></span><br><span class="line"><span class="type">Testing</span> <span class="type">Cauchy</span>-<span class="type">Schwarz</span>...</span><br><span class="line"><span class="type">Completed</span> <span class="number">27556</span> tests without failure.</span><br><span class="line"></span><br><span class="line"><span class="type">Testing</span> invalid <span class="type">Cauchy</span>-<span class="type">Schwarz</span>...</span><br><span class="line"><span class="type">Failed</span> test no. <span class="number">349.</span></span><br><span class="line"><span class="title">there</span> exist [<span class="number">1.0</span>] [<span class="number">0.5</span>] such that</span><br><span class="line">  condition is false</span><br></pre></td></tr></table></figure>
<p>就像<code>QuickCheck</code>一样，我们可以为我們的自定义数据类型实现<code>series</code>(系列)实例。 例如，<code>Vector</code>没有默认实例，因此让我们实现一个实例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleInstances #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE MultiParamTypeClasses #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Test.SmallCheck</span><br><span class="line"><span class="keyword">import</span> Test.SmallCheck.Series</span><br><span class="line"><span class="keyword">import</span> Control.Applicative</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Vector <span class="keyword">as</span> V</span><br><span class="line"></span><br><span class="line"><span class="title">dot</span> :: <span class="type">Num</span> a =&gt; <span class="type">V</span>.<span class="type">Vector</span> a -&gt; <span class="type">V</span>.<span class="type">Vector</span> a -&gt; a</span><br><span class="line"><span class="title">dot</span> xs ys = <span class="type">V</span>.sum (<span class="type">V</span>.zipWith (*) xs ys)</span><br><span class="line"></span><br><span class="line"><span class="title">cauchy</span> :: <span class="type">V</span>.<span class="type">Vector</span> <span class="type">Double</span> -&gt; <span class="type">V</span>.<span class="type">Vector</span> <span class="type">Double</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">cauchy</span> xs ys = (abs (dot xs ys))^<span class="number">2</span> &lt;= (dot xs xs) * (dot ys ys)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Serial</span> <span class="title">m</span> <span class="title">a</span>, <span class="type">Monad</span> <span class="title">m</span>) =&gt; <span class="type">Serial</span> m (<span class="type">V</span>.<span class="type">Vector</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">  series = <span class="type">V</span>.fromList &lt;$&gt; series</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = smallCheck <span class="number">4</span> cauchy</span><br></pre></td></tr></table></figure>
<p><code>SmallCheck</code>也可以使用泛型来派生<code>Serial</code>实例，例如，枚举一定深度的所有树，我们可以使用:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleInstances #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE MultiParamTypeClasses #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DeriveGeneric #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.Generics</span><br><span class="line"><span class="keyword">import</span> Test.SmallCheck.Series</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">Null</span> | <span class="type">Fork</span> (<span class="type">Tree</span> <span class="title">a</span>) a (<span class="type">Tree</span> <span class="title">a</span>)</span></span><br><span class="line">    <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Generic</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Serial</span> m a =&gt; <span class="type">Serial</span> m (<span class="type">Tree</span> <span class="title">a</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">example :: [<span class="type">Tree</span> ()]</span></span><br><span class="line"><span class="class">example = list 3 series</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">main = print example</span></span><br></pre></td></tr></table></figure>
<h3 id="QuickSpec"><a href="#QuickSpec" class="headerlink" title="QuickSpec"></a>QuickSpec</h3><p>使用<code>QuickCheck</code>任意机制，我们还可以显着地列举大量函數组合，以尝试从<code>small cases</code>(小情况)下尝试输入来推导代数定律。</p>
<p>当然，这种方法的基本局限性在于，对于小情况或简单的函数组合，函数可能不会表现出任何令人感兴趣的特性。 因此，在一般情况下，这种方法将行不通，但实际上它仍然非常有用。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ConstraintKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE ScopedTypeVariables #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.List</span><br><span class="line"><span class="keyword">import</span> Data.Typeable</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Test.QuickSpec <span class="keyword">hiding</span> (<span class="title">lists</span>, <span class="title">bools</span>, <span class="title">arith</span>)</span><br><span class="line"><span class="keyword">import</span> Test.QuickCheck</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Var</span> k a = (<span class="type">Typeable</span> <span class="title">a</span>, <span class="type">Arbitrary</span> <span class="title">a</span>, <span class="type">CoArbitrary</span> <span class="title">a</span>, <span class="title">k</span> <span class="title">a</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="title">listCons</span> :: <span class="keyword">forall</span> a. <span class="type">Var</span> <span class="type">Ord</span> a =&gt; a -&gt; <span class="type">Sig</span></span><br><span class="line"><span class="title">listCons</span> a = background</span><br><span class="line">  [</span><br><span class="line">    <span class="string">"[]"</span>      `fun0` ([]      :: [a]),</span><br><span class="line">    <span class="string">":"</span>       `fun2` ((:)     :: a -&gt; [a] -&gt; [a])</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="title">lists</span> :: <span class="keyword">forall</span> a. <span class="type">Var</span> <span class="type">Ord</span> a =&gt; a -&gt; [<span class="type">Sig</span>]</span><br><span class="line"><span class="title">lists</span> a =</span><br><span class="line">  [</span><br><span class="line">    <span class="comment">-- 打印任意变量的名称</span></span><br><span class="line">    funs',</span><br><span class="line">    funvars',</span><br><span class="line">    vars',</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 环境定义</span></span><br><span class="line">    listCons a,</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 推导...的性质的表达式</span></span><br><span class="line">    <span class="string">"sort"</span>     `fun1` (sort    :: [a] -&gt; [a]),</span><br><span class="line">    <span class="string">"map"</span>      `fun2` (map     :: (a -&gt; a) -&gt; [a] -&gt; [a]),</span><br><span class="line">    <span class="string">"id"</span>       `fun1` (id      :: [a] -&gt; [a]),</span><br><span class="line">    <span class="string">"reverse"</span>  `fun1` (reverse :: [a] -&gt; [a]),</span><br><span class="line">    <span class="string">"minimum"</span>  `fun1` (minimum :: [a] -&gt; a),</span><br><span class="line">    <span class="string">"length"</span>   `fun1` (length  :: [a] -&gt; <span class="type">Int</span>),</span><br><span class="line">    <span class="string">"++"</span>       `fun2` ((++)    :: [a] -&gt; [a] -&gt; [a])</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    funs'    = funs (undefined :: a)</span><br><span class="line">    funvars' = vars [<span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>] (undefined :: a -&gt; a)</span><br><span class="line">    vars'    = [<span class="string">"xs"</span>, <span class="string">"ys"</span>, <span class="string">"zs"</span>] `vars` (undefined :: [a])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">tvar</span> :: <span class="type">A</span></span><br><span class="line"><span class="title">tvar</span> = undefined</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = quickSpec (lists tvar)</span><br></pre></td></tr></table></figure>
<p>运行这个我们更愿意看到它能够推导出列表函数的大多数定律:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">$ runhaskell src/quickspec.hs</span><br><span class="line">== <span class="type">API</span> ==</span><br><span class="line"><span class="comment">-- functions --</span></span><br><span class="line"><span class="title">map</span> :: (<span class="type">A</span> -&gt; <span class="type">A</span>) -&gt; [<span class="type">A</span>] -&gt; [<span class="type">A</span>]</span><br><span class="line"><span class="title">minimum</span> :: [<span class="type">A</span>] -&gt; <span class="type">A</span></span><br><span class="line">(++) :: [<span class="type">A</span>] -&gt; [<span class="type">A</span>] -&gt; [<span class="type">A</span>]</span><br><span class="line"><span class="title">length</span> :: [<span class="type">A</span>] -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">sort</span>, id, reverse :: [<span class="type">A</span>] -&gt; [<span class="type">A</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- background functions --</span></span><br><span class="line"><span class="title">id</span> :: <span class="type">A</span> -&gt; <span class="type">A</span></span><br><span class="line">(:) :: <span class="type">A</span> -&gt; [<span class="type">A</span>] -&gt; [<span class="type">A</span>]</span><br><span class="line">(.) :: (<span class="type">A</span> -&gt; <span class="type">A</span>) -&gt; (<span class="type">A</span> -&gt; <span class="type">A</span>) -&gt; <span class="type">A</span> -&gt; <span class="type">A</span></span><br><span class="line">[] :: [<span class="type">A</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- variables --</span></span><br><span class="line"><span class="title">f</span>, g, h :: <span class="type">A</span> -&gt; <span class="type">A</span></span><br><span class="line"><span class="title">xs</span>, ys, zs :: [<span class="type">A</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 以下类型正在使用非标准的相等性 --</span></span><br><span class="line"><span class="type">A</span> -&gt; <span class="type">A</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- WARNING: 没有以下类型的变量；考虑添加一些 --</span></span><br><span class="line"><span class="type">A</span></span><br><span class="line"></span><br><span class="line">== <span class="type">Testing</span> ==</span><br><span class="line"><span class="type">Depth</span> <span class="number">1</span>: <span class="number">12</span> terms, <span class="number">4</span> tests, <span class="number">24</span> evaluations, <span class="number">12</span> classes, <span class="number">0</span> raw equations.</span><br><span class="line"><span class="type">Depth</span> <span class="number">2</span>: <span class="number">80</span> terms, <span class="number">500</span> tests, <span class="number">18673</span> evaluations, <span class="number">52</span> classes, <span class="number">28</span> raw equations.</span><br><span class="line"><span class="type">Depth</span> <span class="number">3</span>: <span class="number">1553</span> terms, <span class="number">500</span> tests, <span class="number">255056</span> evaluations, <span class="number">1234</span> classes, <span class="number">319</span> raw equations.</span><br><span class="line"><span class="number">319</span> raw equations; <span class="number">1234</span> terms <span class="keyword">in</span> universe.</span><br><span class="line"></span><br><span class="line">== <span class="type">Equations</span> about map ==</span><br><span class="line">  <span class="number">1</span>: map f [] == []</span><br><span class="line">  <span class="number">2</span>: map id xs == xs</span><br><span class="line">  <span class="number">3</span>: map (f.g) xs == map f (map g xs)</span><br><span class="line"></span><br><span class="line">== <span class="type">Equations</span> about minimum ==</span><br><span class="line">  <span class="number">4</span>: minimum [] == undefined</span><br><span class="line"></span><br><span class="line">== <span class="type">Equations</span> about (++) ==</span><br><span class="line">  <span class="number">5</span>: xs++[] == xs</span><br><span class="line">  <span class="number">6</span>: []++xs == xs</span><br><span class="line">  <span class="number">7</span>: (xs++ys)++zs == xs++(ys++zs)</span><br><span class="line"></span><br><span class="line">== <span class="type">Equations</span> about sort ==</span><br><span class="line">  <span class="number">8</span>: sort [] == []</span><br><span class="line">  <span class="number">9</span>: sort (sort xs) == sort xs</span><br><span class="line"></span><br><span class="line">== <span class="type">Equations</span> about id ==</span><br><span class="line"> <span class="number">10</span>: id xs == xs</span><br><span class="line"></span><br><span class="line">== <span class="type">Equations</span> about reverse ==</span><br><span class="line"> <span class="number">11</span>: reverse [] == []</span><br><span class="line"> <span class="number">12</span>: reverse (reverse xs) == xs</span><br><span class="line"></span><br><span class="line">== <span class="type">Equations</span> about several functions ==</span><br><span class="line"> <span class="number">13</span>: minimum (xs++ys) == minimum (ys++xs)</span><br><span class="line"> <span class="number">14</span>: length (map f xs) == length xs</span><br><span class="line"> <span class="number">15</span>: length (xs++ys) == length (ys++xs)</span><br><span class="line"> <span class="number">16</span>: sort (xs++ys) == sort (ys++xs)</span><br><span class="line"> <span class="number">17</span>: map f (reverse xs) == reverse (map f xs)</span><br><span class="line"> <span class="number">18</span>: minimum (sort xs) == minimum xs</span><br><span class="line"> <span class="number">19</span>: minimum (reverse xs) == minimum xs</span><br><span class="line"> <span class="number">20</span>: minimum (xs++xs) == minimum xs</span><br><span class="line"> <span class="number">21</span>: length (sort xs) == length xs</span><br><span class="line"> <span class="number">22</span>: length (reverse xs) == length xs</span><br><span class="line"> <span class="number">23</span>: sort (reverse xs) == sort xs</span><br><span class="line"> <span class="number">24</span>: map f xs++map f ys == map f (xs++ys)</span><br><span class="line"> <span class="number">25</span>: reverse xs++reverse ys == reverse (ys++xs)</span><br></pre></td></tr></table></figure>
<p>请记住一个相当显着的事实，那就是所有这些都是从类型中自动推导出的！</p>
<h3 id="Criterion-标准"><a href="#Criterion-标准" class="headerlink" title="Criterion(标准)"></a>Criterion(标准)</h3><p><code>Criterion</code>是一种具有统计意义的基准测试工具。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">whnf</span> :: (a -&gt; b) -&gt; a -&gt; <span class="type">Pure</span></span><br><span class="line"><span class="title">nf</span> :: <span class="type">NFData</span> b =&gt; (a -&gt; b) -&gt; a -&gt; <span class="type">Pure</span></span><br><span class="line"><span class="title">nfIO</span> :: <span class="type">NFData</span> a =&gt; <span class="type">IO</span> a -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">bench</span> :: <span class="type">Benchmarkable</span> b =&gt; <span class="type">String</span> -&gt; b -&gt; <span class="type">Benchmark</span></span><br><span class="line"><span class="keyword">import</span> Criterion.Main</span><br><span class="line"><span class="keyword">import</span> Criterion.Config</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 斐波那契数的幼稚递归</span></span><br><span class="line"><span class="title">fib1</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">fib1</span> <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="title">fib1</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="title">fib1</span> n = fib1 (n<span class="number">-1</span>) + fib1 (n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Use the De Moivre closed form for fibonacci numbers.</span></span><br><span class="line"><span class="title">fib2</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">fib2</span> x = truncate $ ( <span class="number">1</span> / sqrt <span class="number">5</span> ) * ( phi ^ x - psi ^ x )</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">      phi = ( <span class="number">1</span> + sqrt <span class="number">5</span> ) / <span class="number">2</span></span><br><span class="line">      psi = ( <span class="number">1</span> - sqrt <span class="number">5</span> ) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="title">suite</span> :: [<span class="type">Benchmark</span>]</span><br><span class="line"><span class="title">suite</span> = [</span><br><span class="line">    bgroup <span class="string">"naive"</span> [</span><br><span class="line">      bench <span class="string">"fib 10"</span> $ whnf fib1 <span class="number">5</span></span><br><span class="line">    , bench <span class="string">"fib 20"</span> $ whnf fib1 <span class="number">10</span></span><br><span class="line">    ],</span><br><span class="line">    bgroup <span class="string">"de moivre"</span> [</span><br><span class="line">      bench <span class="string">"fib 10"</span> $ whnf fib2 <span class="number">5</span></span><br><span class="line">    , bench <span class="string">"fib 20"</span> $ whnf fib2 <span class="number">10</span></span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = defaultMain suite</span><br><span class="line">$ runhaskell criterion.hs</span><br><span class="line"><span class="title">warming</span> up</span><br><span class="line"><span class="title">estimating</span> clock resolution...</span><br><span class="line"><span class="title">mean</span> is <span class="number">2.349801</span> us (<span class="number">320001</span> iterations)</span><br><span class="line"><span class="title">found</span> <span class="number">1788</span> outliers among <span class="number">319999</span> samples (<span class="number">0.6</span>%)</span><br><span class="line">  <span class="number">1373</span> (<span class="number">0.4</span>%) high severe</span><br><span class="line"><span class="title">estimating</span> cost <span class="keyword">of</span> a clock call...</span><br><span class="line"><span class="title">mean</span> is <span class="number">65.52118</span> ns (<span class="number">23</span> iterations)</span><br><span class="line"><span class="title">found</span> <span class="number">1</span> outliers among <span class="number">23</span> samples (<span class="number">4.3</span>%)</span><br><span class="line">  <span class="number">1</span> (<span class="number">4.3</span>%) high severe</span><br><span class="line"></span><br><span class="line"><span class="title">benchmarking</span> naive/fib <span class="number">10</span></span><br><span class="line"><span class="title">mean</span>: <span class="number">9.903067</span> us, lb <span class="number">9.885143</span> us, ub <span class="number">9.924404</span> us, ci <span class="number">0.950</span></span><br><span class="line"><span class="title">std</span> dev: <span class="number">100.4508</span> ns, lb <span class="number">85.04638</span> ns, ub <span class="number">123.1707</span> ns, ci <span class="number">0.950</span></span><br><span class="line"></span><br><span class="line"><span class="title">benchmarking</span> naive/fib <span class="number">20</span></span><br><span class="line"><span class="title">mean</span>: <span class="number">120.7269</span> us, lb <span class="number">120.5470</span> us, ub <span class="number">120.9459</span> us, ci <span class="number">0.950</span></span><br><span class="line"><span class="title">std</span> dev: <span class="number">1.014556</span> us, lb <span class="number">858.6037</span> ns, ub <span class="number">1.296920</span> us, ci <span class="number">0.950</span></span><br><span class="line"></span><br><span class="line"><span class="title">benchmarking</span> de moivre/fib <span class="number">10</span></span><br><span class="line"><span class="title">mean</span>: <span class="number">7.699219</span> us, lb <span class="number">7.671107</span> us, ub <span class="number">7.802116</span> us, ci <span class="number">0.950</span></span><br><span class="line"><span class="title">std</span> dev: <span class="number">247.3021</span> ns, lb <span class="number">61.66586</span> ns, ub <span class="number">572.1260</span> ns, ci <span class="number">0.950</span></span><br><span class="line"><span class="title">found</span> <span class="number">4</span> outliers among <span class="number">100</span> samples (<span class="number">4.0</span>%)</span><br><span class="line">  <span class="number">2</span> (<span class="number">2.0</span>%) high mild</span><br><span class="line">  <span class="number">2</span> (<span class="number">2.0</span>%) high severe</span><br><span class="line"><span class="title">variance</span> introduced by outliers: <span class="number">27.726</span>%</span><br><span class="line"><span class="title">variance</span> is moderately inflated by outliers</span><br><span class="line"></span><br><span class="line"><span class="title">benchmarking</span> de moivre/fib <span class="number">20</span></span><br><span class="line"><span class="title">mean</span>: <span class="number">8.082639</span> us, lb <span class="number">8.018560</span> us, ub <span class="number">8.350159</span> us, ci <span class="number">0.950</span></span><br><span class="line"><span class="title">std</span> dev: <span class="number">595.2161</span> ns, lb <span class="number">77.46251</span> ns, ub <span class="number">1.408784</span> us, ci <span class="number">0.950</span></span><br><span class="line"><span class="title">found</span> <span class="number">8</span> outliers among <span class="number">100</span> samples (<span class="number">8.0</span>%)</span><br><span class="line">  <span class="number">4</span> (<span class="number">4.0</span>%) high mild</span><br><span class="line">  <span class="number">4</span> (<span class="number">4.0</span>%) high severe</span><br><span class="line"><span class="title">variance</span> introduced by outliers: <span class="number">67.628</span>%</span><br><span class="line"><span class="title">variance</span> is severely inflated by outliers</span><br></pre></td></tr></table></figure>
<p><code>Criterion</code>还可以生成一个<code>HTML</code>页面，其中包含绘制的基准测试结果:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ghc -<span class="type">O2</span> <span class="comment">--make criterion.hs</span></span><br><span class="line">$ ./criterion -o bench.html</span><br></pre></td></tr></table></figure>
<p><img src="img/img01.png" alt=""></p>
<h3 id="Tasty"><a href="#Tasty" class="headerlink" title="Tasty"></a>Tasty</h3><p><code>Tasty</code>将所有测试框架组合到一个通用<code>API</code>中，以形成可运行的批量测试并收集结果。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Test.Tasty</span><br><span class="line"><span class="keyword">import</span> Test.Tasty.HUnit</span><br><span class="line"><span class="keyword">import</span> Test.Tasty.QuickCheck</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Test.Tasty.SmallCheck <span class="keyword">as</span> SC</span><br><span class="line"></span><br><span class="line"><span class="title">arith</span> :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span> -&gt; <span class="type">Property</span></span><br><span class="line"><span class="title">arith</span> x y = (x &gt; <span class="number">0</span>) &amp;&amp; (y &gt; <span class="number">0</span>) ==&gt; (x+y)^<span class="number">2</span> &gt; x^<span class="number">2</span> + y^<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="title">negation</span> :: <span class="type">Integer</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">negation</span> x = abs (x^<span class="number">2</span>) &gt;= x</span><br><span class="line"></span><br><span class="line"><span class="title">suite</span> :: <span class="type">TestTree</span></span><br><span class="line"><span class="title">suite</span> = testGroup <span class="string">"Test Suite"</span> [</span><br><span class="line">    testGroup <span class="string">"Units"</span></span><br><span class="line">      [ testCase <span class="string">"Equality"</span> $ <span class="type">True</span> @=? <span class="type">True</span></span><br><span class="line">      , testCase <span class="string">"Assertion"</span> $ assert $ (length [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) == <span class="number">3</span></span><br><span class="line">      ],</span><br><span class="line"></span><br><span class="line">    testGroup <span class="string">"QuickCheck tests"</span></span><br><span class="line">      [ testProperty <span class="string">"Quickcheck test"</span> arith</span><br><span class="line">      ],</span><br><span class="line"></span><br><span class="line">    testGroup <span class="string">"SmallCheck tests"</span></span><br><span class="line">      [ <span class="type">SC</span>.testProperty <span class="string">"Negation"</span> negation</span><br><span class="line">      ]</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = defaultMain suite</span><br><span class="line">$ runhaskell <span class="type">TestSuite</span>.hs</span><br><span class="line"><span class="type">Unit</span> tests</span><br><span class="line">  <span class="type">Units</span></span><br><span class="line">    <span class="type">Equality</span>:        <span class="type">OK</span></span><br><span class="line">    <span class="type">Assertion</span>:       <span class="type">OK</span></span><br><span class="line">  <span class="type">QuickCheck</span> tests</span><br><span class="line">    <span class="type">Quickcheck</span> test: <span class="type">OK</span></span><br><span class="line">      +++ <span class="type">OK</span>, passed <span class="number">100</span> tests.</span><br><span class="line">  <span class="type">SmallCheck</span> tests</span><br><span class="line">    <span class="type">Negation</span>:        <span class="type">OK</span></span><br><span class="line">      <span class="number">11</span> tests completed</span><br></pre></td></tr></table></figure>
<h3 id="silently"><a href="#silently" class="headerlink" title="silently"></a>silently</h3><p>通常在测试<code>IO heavy</code>繁重代码的过程中，我们需要重定向<code>stdout</code>来比较一些已知的<code>quantity</code>(数量)。<br><code>silent</code>包允许我们捕获<code>IO</code>块内任何库中对<code>stdout</code>所做的任何操作，并将结果返回给测试运行程序.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">capture</span> :: <span class="type">IO</span> a -&gt; <span class="type">IO</span> (<span class="type">String</span>, a)</span><br><span class="line"><span class="keyword">import</span> Test.Tasty</span><br><span class="line"><span class="keyword">import</span> Test.Tasty.HUnit</span><br><span class="line"><span class="keyword">import</span> System.IO.Silently</span><br><span class="line"></span><br><span class="line"><span class="title">test</span> :: <span class="type">Int</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">test</span> n = print (n * n)</span><br><span class="line"></span><br><span class="line"><span class="title">testCapture</span> n = <span class="keyword">do</span></span><br><span class="line">  (stdout, result) &lt;- capture (test n)</span><br><span class="line">  assert (stdout == show (n*n) ++ <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">suite</span> :: <span class="type">TestTree</span></span><br><span class="line"><span class="title">suite</span> = testGroup <span class="string">"Test Suite"</span> [</span><br><span class="line">    testGroup <span class="string">"Units"</span></span><br><span class="line">      [ testCase <span class="string">"Equality"</span> $ testCapture <span class="number">10</span></span><br><span class="line">      ]</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = defaultMain suite</span><br></pre></td></tr></table></figure>
        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/blog/img/pay.png">
        <p> thank you </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://medium.com/netflix-techblog">Netflix</a></span>
        <span>/</span>
        
        <span><a href="https://engineering.linkedin.com/blog">Linkedin</a></span>
        <span>/</span>
        
        <span><a href="https://blogs.dropbox.com/tech/">Dropbox</a></span>
        <span>/</span>
        
        <span><a href="https://code.fb.com/">Facebook</a></span>
        <span>/</span>
        
        <span><a href="https://www.fpcomplete.com/blog">FPComplete</a></span>
        <span>/</span>
        
        <span><a href="https://blog.janestreet.com/">JaneStreet</a></span>
        <span>/</span>
        
        <span><a href="https://github.com/limengyu1990/">Github</a></span>
        <span>/</span>
        
        <span><a href="https://serokell.io/blog">serokell</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/blog/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/blog/js/index.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</html>
